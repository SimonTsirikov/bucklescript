console = {log = print};

Arg = require "../../lib/js/arg";
Sys = require "../../lib/js/sys";
Char = require "../../lib/js/char";
List = require "../../lib/js/list";
Path = require "";
__Array = require "../../lib/js/array";
Block = require "../../lib/js/block";
Bytes = require "../../lib/js/bytes";
Curry = require "../../lib/js/curry";
Int32 = require "../../lib/js/int32";
Int64 = require "../../lib/js/int64";
__Buffer = require "../../lib/js/buffer";
Digest = require "../../lib/js/digest";
Format = require "../../lib/js/format";
Lexing = require "../../lib/js/lexing";
Printf = require "../../lib/js/printf";
__String = require "../../lib/js/string";
Assert = require "as";
Caml_io = require "../../lib/js/caml_io";
Hashtbl = require "../../lib/js/hashtbl";
Marshal = require "../../lib/js/marshal";
Parsing = require "../../lib/js/parsing";
Process = require "pro";
Caml_obj = require "../../lib/js/caml_obj";
Caml_sys = require "../../lib/js/caml_sys";
Filename = require "../../lib/js/filename";
Caml_weak = require "../../lib/js/caml_weak";
Nativeint = require "../../lib/js/nativeint";
Caml_array = require "../../lib/js/caml_array";
Caml_bytes = require "../../lib/js/caml_bytes";
Caml_int32 = require "../../lib/js/caml_int32";
Caml_int64 = require "../../lib/js/caml_int64";
Pervasives = require "../../lib/js/pervasives";
Caml_format = require "../../lib/js/caml_format";
Caml_option = require "../../lib/js/caml_option";
Caml_string = require "../../lib/js/caml_string";
Caml_primitive = require "../../lib/js/caml_primitive";
Caml_exceptions = require "../../lib/js/caml_exceptions";
CamlinternalLazy = require "../../lib/js/camlinternalLazy";
Caml_js_exceptions = require "../../lib/js/caml_js_exceptions";
Caml_external_polyfill = require "../../lib/js/caml_external_polyfill";
Caml_builtin_exceptions = require "../../lib/js/caml_builtin_exceptions";

cmi_magic_number = "Caml1999I017";

load_path = do
  contents: --[[ [] ]]0
end;

interface_suffix = do
  contents: ".mli"
end;

print_types = do
  contents: false
end;

debug = false;

fast = do
  contents: false
end;

classic = do
  contents: false
end;

nopervasives = false;

annotations = do
  contents: false
end;

binary_annotations = do
  contents: false
end;

principal = do
  contents: false
end;

real_paths = do
  contents: true
end;

recursive_types = do
  contents: false
end;

strict_sequence = do
  contents: false
end;

applicative_functors = do
  contents: true
end;

error_size = do
  contents: 500
end;

transparent_modules = do
  contents: false
end;

native_code = do
  contents: false
end;

dont_write_files = do
  contents: false
end;

keep_docs = do
  contents: false
end;

keep_locs = do
  contents: false
end;

unsafe_string = true;

assume_no_mli = do
  contents: --[[ Mli_na ]]0
end;

record_event_when_debug = true;

bs_vscode;

xpcall(function() do
  Caml_sys.caml_sys_getenv("BS_VSCODE");
  bs_vscode = true;
end end,function(exn) do
  bs_vscode = false;
end end)

dont_record_crc_unit = do
  contents: undefined
end;

bs_only = do
  contents: false
end;

color = do
  contents: undefined
end;

Fatal_error = Caml_exceptions.create("Ocaml_typedtree_test.Misc.Fatal_error");

function fatal_error(msg) do
  Pervasives.prerr_string(">> Fatal error: ");
  console.error(msg);
  error(Fatal_error)
end end

function try_finally(work, cleanup) do
  result;
  xpcall(function() do
    result = Curry._1(work, --[[ () ]]0);
  end end,function(e) do
    Curry._1(cleanup, --[[ () ]]0);
    error(e)
  end end)
  Curry._1(cleanup, --[[ () ]]0);
  return result;
end end

function map_end(f, l1, l2) do
  if (l1) then do
    return --[[ :: ]]{
            Curry._1(f, l1[0]),
            map_end(f, l1[1], l2)
          };
  end else do
    return l2;
  end end 
end end

function for_all2(pred, _l1, _l2) do
  while(true) do
    l2 = _l2;
    l1 = _l1;
    if (l1) then do
      if (l2 and Curry._2(pred, l1[0], l2[0])) then do
        _l2 = l2[1];
        _l1 = l1[1];
        ::continue:: ;
      end else do
        return false;
      end end 
    end else if (l2) then do
      return false;
    end else do
      return true;
    end end  end 
  end;
end end

function replicate_list(elem, n) do
  if (n <= 0) then do
    return --[[ [] ]]0;
  end else do
    return --[[ :: ]]{
            elem,
            replicate_list(elem, n - 1 | 0)
          };
  end end 
end end

function split_last(param) do
  if (param) then do
    tl = param[1];
    x = param[0];
    if (tl) then do
      match = split_last(tl);
      return --[[ tuple ]]{
              --[[ :: ]]{
                x,
                match[0]
              },
              match[1]
            };
    end else do
      return --[[ tuple ]]{
              --[[ [] ]]0,
              x
            };
    end end 
  end else do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "misc.ml",
        54,
        10
      }
    })
  end end 
end end

function may(f, param) do
  if (param ~= undefined) then do
    return Curry._1(f, Caml_option.valFromOption(param));
  end else do
    return --[[ () ]]0;
  end end 
end end

function may_map(f, param) do
  if (param ~= undefined) then do
    return Caml_option.some(Curry._1(f, Caml_option.valFromOption(param)));
  end
   end 
end end

function find_in_path_uncap(path, name) do
  uname = Caml_bytes.bytes_to_string(Bytes.uncapitalize(Caml_bytes.bytes_of_string(name)));
  _param = path;
  while(true) do
    param = _param;
    if (param) then do
      dir = param[0];
      fullname = Filename.concat(dir, name);
      ufullname = Filename.concat(dir, uname);
      if (Caml_external_polyfill.resolve("caml_sys_file_exists")(ufullname)) then do
        return ufullname;
      end else if (Caml_external_polyfill.resolve("caml_sys_file_exists")(fullname)) then do
        return fullname;
      end else do
        _param = param[1];
        ::continue:: ;
      end end  end 
    end else do
      error(Caml_builtin_exceptions.not_found)
    end end 
  end;
end end

function remove_file(filename) do
  xpcall(function() do
    return Caml_external_polyfill.resolve("caml_sys_remove")(filename);
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Caml_builtin_exceptions.sys_error) then do
      return --[[ () ]]0;
    end else do
      error(exn)
    end end 
  end end)
end end

function create_hashtable(size, init) do
  tbl = Hashtbl.create(undefined, size);
  List.iter((function(param) do
          return Hashtbl.add(tbl, param[0], param[1]);
        end end), init);
  return tbl;
end end

function chop_extension_if_any(fname) do
  xpcall(function() do
    return Filename.chop_extension(fname);
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Caml_builtin_exceptions.invalid_argument) then do
      return fname;
    end else do
      error(exn)
    end end 
  end end)
end end

function get_ref(r) do
  v = r.contents;
  r.contents = --[[ [] ]]0;
  return v;
end end

function edit_distance(a, b, cutoff) do
  la = #a;
  lb = #b;
  cutoff_1 = Caml_primitive.caml_int_min(la > lb and la or lb, cutoff);
  if (Pervasives.abs(la - lb | 0) > cutoff_1) then do
    return ;
  end else do
    m = __Array.make_matrix(la + 1 | 0, lb + 1 | 0, cutoff_1 + 1 | 0);
    Caml_array.caml_array_set(Caml_array.caml_array_get(m, 0), 0, 0);
    for i = 1 , la , 1 do
      Caml_array.caml_array_set(Caml_array.caml_array_get(m, i), 0, i);
    end
    for j = 1 , lb , 1 do
      Caml_array.caml_array_set(Caml_array.caml_array_get(m, 0), j, j);
    end
    for i_1 = 1 , la , 1 do
      for j_1 = Caml_primitive.caml_int_max(1, (i_1 - cutoff_1 | 0) - 1 | 0) , Caml_primitive.caml_int_min(lb, (i_1 + cutoff_1 | 0) + 1 | 0) , 1 do
        cost = Caml_string.get(a, i_1 - 1 | 0) == Caml_string.get(b, j_1 - 1 | 0) and 0 or 1;
        best = Caml_primitive.caml_int_min(1 + Caml_primitive.caml_int_min(Caml_array.caml_array_get(Caml_array.caml_array_get(m, i_1 - 1 | 0), j_1), Caml_array.caml_array_get(Caml_array.caml_array_get(m, i_1), j_1 - 1 | 0)) | 0, Caml_array.caml_array_get(Caml_array.caml_array_get(m, i_1 - 1 | 0), j_1 - 1 | 0) + cost | 0);
        best_1 = i_1 > 1 and j_1 > 1 and Caml_string.get(a, i_1 - 1 | 0) == Caml_string.get(b, j_1 - 2 | 0) and Caml_string.get(a, i_1 - 2 | 0) == Caml_string.get(b, j_1 - 1 | 0) and Caml_primitive.caml_int_min(best, Caml_array.caml_array_get(Caml_array.caml_array_get(m, i_1 - 2 | 0), j_1 - 2 | 0) + cost | 0) or best;
        Caml_array.caml_array_set(Caml_array.caml_array_get(m, i_1), j_1, best_1);
      end
    end
    result = Caml_array.caml_array_get(Caml_array.caml_array_get(m, la), lb);
    if (result > cutoff_1) then do
      return ;
    end else do
      return result;
    end end 
  end end 
end end

function ansi_of_color(param) do
  local ___conditional___=(param);
  do
     if ___conditional___ == 0--[[ Black ]] then do
        return "0"; end end 
     if ___conditional___ == 1--[[ Red ]] then do
        return "1"; end end 
     if ___conditional___ == 2--[[ Green ]] then do
        return "2"; end end 
     if ___conditional___ == 3--[[ Yellow ]] then do
        return "3"; end end 
     if ___conditional___ == 4--[[ Blue ]] then do
        return "4"; end end 
     if ___conditional___ == 5--[[ Magenta ]] then do
        return "5"; end end 
     if ___conditional___ == 6--[[ Cyan ]] then do
        return "6"; end end 
     if ___conditional___ == 7--[[ White ]] then do
        return "7"; end end 
    
  end
end end

function code_of_style(param) do
  if (typeof param == "number") then do
    local ___conditional___=(param);
    do
       if ___conditional___ == 0--[[ Bold ]] then do
          return "1"; end end 
       if ___conditional___ == 1--[[ Reset ]] then do
          return "0"; end end 
       if ___conditional___ == 2--[[ Dim ]] then do
          return "2"; end end 
      
    end
  end else if (param.tag) then do
    return "4" .. ansi_of_color(param[0]);
  end else do
    return "3" .. ansi_of_color(param[0]);
  end end  end 
end end

function ansi_of_style_l(l) do
  s = l and (
      l[1] and __String.concat(";", List.map(code_of_style, l)) or code_of_style(l[0])
    ) or "0";
  return "\x1b[" .. (s .. "m");
end end

default_styles = do
  error: --[[ :: ]]{
    --[[ Bold ]]0,
    --[[ :: ]]{
      --[[ FG ]]Block.__(0, {--[[ Red ]]1}),
      --[[ [] ]]0
    }
  },
  warning: --[[ :: ]]{
    --[[ Bold ]]0,
    --[[ :: ]]{
      --[[ FG ]]Block.__(0, {--[[ Magenta ]]5}),
      --[[ [] ]]0
    }
  },
  loc: --[[ :: ]]{
    --[[ Bold ]]0,
    --[[ [] ]]0
  }
end;

cur_styles = do
  contents: default_styles
end;

function get_styles(param) do
  return cur_styles.contents;
end end

function set_styles(s) do
  cur_styles.contents = s;
  return --[[ () ]]0;
end end

function style_of_tag(s) do
  local ___conditional___=(s);
  do
     if ___conditional___ == "dim" then do
        return --[[ :: ]]{
                --[[ Dim ]]2,
                --[[ [] ]]0
              }; end end 
     if ___conditional___ == "error" then do
        return cur_styles.contents.error; end end 
     if ___conditional___ == "filename" then do
        return --[[ :: ]]{
                --[[ FG ]]Block.__(0, {--[[ Cyan ]]6}),
                --[[ [] ]]0
              }; end end 
     if ___conditional___ == "info" then do
        return --[[ :: ]]{
                --[[ Bold ]]0,
                --[[ :: ]]{
                  --[[ FG ]]Block.__(0, {--[[ Yellow ]]3}),
                  --[[ [] ]]0
                }
              }; end end 
     if ___conditional___ == "loc" then do
        return cur_styles.contents.loc; end end 
     if ___conditional___ == "warning" then do
        return cur_styles.contents.warning; end end 
    error(Caml_builtin_exceptions.not_found)
      
  end
end end

color_enabled = do
  contents: true
end;

function set_color_tag_handling(ppf) do
  functions = Format.pp_get_formatter_tag_functions(ppf, --[[ () ]]0);
  partial_arg = functions.mark_open_tag;
  partial_arg_1 = functions.mark_close_tag;
  functions$prime_mark_open_tag = function(param) do
    or_else = partial_arg;
    s = param;
    xpcall(function() do
      style = style_of_tag(s);
      if (color_enabled.contents) then do
        return ansi_of_style_l(style);
      end else do
        return "";
      end end 
    end end,function(exn) do
      if (exn == Caml_builtin_exceptions.not_found) then do
        return Curry._1(or_else, s);
      end else do
        error(exn)
      end end 
    end end)
  end end;
  functions$prime_mark_close_tag = function(param) do
    or_else = partial_arg_1;
    s = param;
    xpcall(function() do
      style_of_tag(s);
      if (color_enabled.contents) then do
        return ansi_of_style_l(--[[ :: ]]{
                    --[[ Reset ]]1,
                    --[[ [] ]]0
                  });
      end else do
        return "";
      end end 
    end end,function(exn) do
      if (exn == Caml_builtin_exceptions.not_found) then do
        return Curry._1(or_else, s);
      end else do
        error(exn)
      end end 
    end end)
  end end;
  functions$prime_print_open_tag = functions.print_open_tag;
  functions$prime_print_close_tag = functions.print_close_tag;
  functions$prime = do
    mark_open_tag: functions$prime_mark_open_tag,
    mark_close_tag: functions$prime_mark_close_tag,
    print_open_tag: functions$prime_print_open_tag,
    print_close_tag: functions$prime_print_close_tag
  end;
  ppf.pp_mark_tags = true;
  return Format.pp_set_formatter_tag_functions(ppf, functions$prime);
end end

first = do
  contents: true
end;

formatter_l_001 = --[[ :: ]]{
  Format.err_formatter,
  --[[ :: ]]{
    Format.str_formatter,
    --[[ [] ]]0
  }
};

formatter_l = --[[ :: ]]{
  Format.std_formatter,
  formatter_l_001
};

function setup(o) do
  if (first.contents) then do
    first.contents = false;
    Format.set_mark_tags(true);
    List.iter(set_color_tag_handling, formatter_l);
    tmp;
    if (o ~= undefined) then do
      local ___conditional___=(o);
      do
         if ___conditional___ == 1--[[ Always ]] then do
            tmp = true; end else 
         if ___conditional___ == 0--[[ Auto ]]
         or ___conditional___ == 2--[[ Never ]] then do
            tmp = false; end else 
         end end end end
        
      end
    end else do
      tmp = false;
    end end 
    color_enabled.contents = tmp;
  end
   end 
  return --[[ () ]]0;
end end

Misc_Color = do
  ansi_of_style_l: ansi_of_style_l,
  default_styles: default_styles,
  get_styles: get_styles,
  set_styles: set_styles,
  setup: setup,
  set_color_tag_handling: set_color_tag_handling
end;

function number(param) do
  if (typeof param == "number") then do
    local ___conditional___=(param);
    do
       if ___conditional___ == 0--[[ Comment_start ]] then do
          return 1; end end 
       if ___conditional___ == 1--[[ Comment_not_end ]] then do
          return 2; end end 
       if ___conditional___ == 2--[[ Partial_application ]] then do
          return 5; end end 
       if ___conditional___ == 3--[[ Labels_omitted ]] then do
          return 6; end end 
       if ___conditional___ == 4--[[ Statement_type ]] then do
          return 10; end end 
       if ___conditional___ == 5--[[ Unused_match ]] then do
          return 11; end end 
       if ___conditional___ == 6--[[ Unused_pat ]] then do
          return 12; end end 
       if ___conditional___ == 7--[[ Illegal_backslash ]] then do
          return 14; end end 
       if ___conditional___ == 8--[[ Unerasable_optional_argument ]] then do
          return 16; end end 
       if ___conditional___ == 9--[[ Unused_argument ]] then do
          return 20; end end 
       if ___conditional___ == 10--[[ Nonreturning_statement ]] then do
          return 21; end end 
       if ___conditional___ == 11--[[ Useless_record_with ]] then do
          return 23; end end 
       if ___conditional___ == 12--[[ All_clauses_guarded ]] then do
          return 25; end end 
       if ___conditional___ == 13--[[ Wildcard_arg_to_constant_constr ]] then do
          return 28; end end 
       if ___conditional___ == 14--[[ Eol_in_string ]] then do
          return 29; end end 
       if ___conditional___ == 15--[[ Unused_rec_flag ]] then do
          return 39; end end 
       if ___conditional___ == 16--[[ Bs_polymorphic_comparison ]] then do
          return 102; end end 
      
    end
  end else do
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ == 0--[[ Deprecated ]] then do
          return 3; end end 
       if ___conditional___ == 1--[[ Fragile_match ]] then do
          return 4; end end 
       if ___conditional___ == 2--[[ Method_override ]] then do
          return 7; end end 
       if ___conditional___ == 3--[[ Partial_match ]] then do
          return 8; end end 
       if ___conditional___ == 4--[[ Non_closed_record_pattern ]] then do
          return 9; end end 
       if ___conditional___ == 5--[[ Instance_variable_override ]] then do
          return 13; end end 
       if ___conditional___ == 6--[[ Implicit_public_methods ]] then do
          return 15; end end 
       if ___conditional___ == 7--[[ Undeclared_virtual_method ]] then do
          return 17; end end 
       if ___conditional___ == 8--[[ Not_principal ]] then do
          return 18; end end 
       if ___conditional___ == 9--[[ Without_principality ]] then do
          return 19; end end 
       if ___conditional___ == 10--[[ Preprocessor ]] then do
          return 22; end end 
       if ___conditional___ == 11--[[ Bad_module_name ]] then do
          return 24; end end 
       if ___conditional___ == 12--[[ Unused_var ]] then do
          return 26; end end 
       if ___conditional___ == 13--[[ Unused_var_strict ]] then do
          return 27; end end 
       if ___conditional___ == 14--[[ Duplicate_definitions ]] then do
          return 30; end end 
       if ___conditional___ == 15--[[ Multiple_definition ]] then do
          return 31; end end 
       if ___conditional___ == 16--[[ Unused_value_declaration ]] then do
          return 32; end end 
       if ___conditional___ == 17--[[ Unused_open ]] then do
          return 33; end end 
       if ___conditional___ == 18--[[ Unused_type_declaration ]] then do
          return 34; end end 
       if ___conditional___ == 19--[[ Unused_for_index ]] then do
          return 35; end end 
       if ___conditional___ == 20--[[ Unused_ancestor ]] then do
          return 36; end end 
       if ___conditional___ == 21--[[ Unused_constructor ]] then do
          return 37; end end 
       if ___conditional___ == 22--[[ Unused_extension ]] then do
          return 38; end end 
       if ___conditional___ == 23--[[ Name_out_of_scope ]] then do
          return 40; end end 
       if ___conditional___ == 24--[[ Ambiguous_name ]] then do
          return 41; end end 
       if ___conditional___ == 25--[[ Disambiguated_name ]] then do
          return 42; end end 
       if ___conditional___ == 26--[[ Nonoptional_label ]] then do
          return 43; end end 
       if ___conditional___ == 27--[[ Open_shadow_identifier ]] then do
          return 44; end end 
       if ___conditional___ == 28--[[ Open_shadow_label_constructor ]] then do
          return 45; end end 
       if ___conditional___ == 29--[[ Bad_env_variable ]] then do
          return 46; end end 
       if ___conditional___ == 30--[[ Attribute_payload ]] then do
          return 47; end end 
       if ___conditional___ == 31--[[ Eliminated_optional_arguments ]] then do
          return 48; end end 
       if ___conditional___ == 32--[[ No_cmi_file ]] then do
          return 49; end end 
       if ___conditional___ == 33--[[ Bad_docstring ]] then do
          return 50; end end 
       if ___conditional___ == 34--[[ Bs_unused_attribute ]] then do
          return 101; end end 
       if ___conditional___ == 35--[[ Bs_ffi_warning ]] then do
          return 103; end end 
       if ___conditional___ == 36--[[ Bs_derive_warning ]] then do
          return 104; end end 
      
    end
  end end 
end end

function loop(i) do
  if (i == 0) then do
    return --[[ [] ]]0;
  end else do
    return --[[ :: ]]{
            i,
            loop(i - 1 | 0)
          };
  end end 
end end

letter_all = loop(104);

function letter(param) do
  local ___conditional___=(param);
  do
     if ___conditional___ == 97 then do
        return letter_all; end end 
     if ___conditional___ == 99 then do
        return --[[ :: ]]{
                1,
                --[[ :: ]]{
                  2,
                  --[[ [] ]]0
                }
              }; end end 
     if ___conditional___ == 100 then do
        return --[[ :: ]]{
                3,
                --[[ [] ]]0
              }; end end 
     if ___conditional___ == 101 then do
        return --[[ :: ]]{
                4,
                --[[ [] ]]0
              }; end end 
     if ___conditional___ == 102 then do
        return --[[ :: ]]{
                5,
                --[[ [] ]]0
              }; end end 
     if ___conditional___ == 107 then do
        return --[[ :: ]]{
                32,
                --[[ :: ]]{
                  33,
                  --[[ :: ]]{
                    34,
                    --[[ :: ]]{
                      35,
                      --[[ :: ]]{
                        36,
                        --[[ :: ]]{
                          37,
                          --[[ :: ]]{
                            38,
                            --[[ :: ]]{
                              39,
                              --[[ [] ]]0
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }; end end 
     if ___conditional___ == 108 then do
        return --[[ :: ]]{
                6,
                --[[ [] ]]0
              }; end end 
     if ___conditional___ == 109 then do
        return --[[ :: ]]{
                7,
                --[[ [] ]]0
              }; end end 
     if ___conditional___ == 112 then do
        return --[[ :: ]]{
                8,
                --[[ [] ]]0
              }; end end 
     if ___conditional___ == 114 then do
        return --[[ :: ]]{
                9,
                --[[ [] ]]0
              }; end end 
     if ___conditional___ == 115 then do
        return --[[ :: ]]{
                10,
                --[[ [] ]]0
              }; end end 
     if ___conditional___ == 117 then do
        return --[[ :: ]]{
                11,
                --[[ :: ]]{
                  12,
                  --[[ [] ]]0
                }
              }; end end 
     if ___conditional___ == 118 then do
        return --[[ :: ]]{
                13,
                --[[ [] ]]0
              }; end end 
     if ___conditional___ == 98
     or ___conditional___ == 103
     or ___conditional___ == 104
     or ___conditional___ == 105
     or ___conditional___ == 106
     or ___conditional___ == 110
     or ___conditional___ == 111
     or ___conditional___ == 113
     or ___conditional___ == 116
     or ___conditional___ == 119 then do
        return --[[ [] ]]0; end end 
     if ___conditional___ == 120 then do
        return --[[ :: ]]{
                14,
                --[[ :: ]]{
                  15,
                  --[[ :: ]]{
                    16,
                    --[[ :: ]]{
                      17,
                      --[[ :: ]]{
                        18,
                        --[[ :: ]]{
                          19,
                          --[[ :: ]]{
                            20,
                            --[[ :: ]]{
                              21,
                              --[[ :: ]]{
                                22,
                                --[[ :: ]]{
                                  23,
                                  --[[ :: ]]{
                                    24,
                                    --[[ :: ]]{
                                      25,
                                      --[[ :: ]]{
                                        30,
                                        --[[ [] ]]0
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }; end end 
     if ___conditional___ == 121 then do
        return --[[ :: ]]{
                26,
                --[[ [] ]]0
              }; end end 
     if ___conditional___ == 122 then do
        return --[[ :: ]]{
                27,
                --[[ [] ]]0
              }; end end 
    error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "warnings.ml",
          176,
          9
        }
      })
      
  end
end end

current = do
  contents: do
    active: Caml_array.caml_make_vect(105, true),
    error: Caml_array.caml_make_vect(105, false)
  end
end;

function is_active(x) do
  return Caml_array.caml_array_get(current.contents.active, number(x));
end end

function parse_opt(error, active, flags, s) do
  set = function(i) do
    return Caml_array.caml_array_set(flags, i, true);
  end end;
  clear = function(i) do
    return Caml_array.caml_array_set(flags, i, false);
  end end;
  set_all = function(i) do
    Caml_array.caml_array_set(active, i, true);
    return Caml_array.caml_array_set(error, i, true);
  end end;
  get_num = function(_n, _i) do
    while(true) do
      i = _i;
      n = _n;
      if (i >= #s) then do
        return --[[ tuple ]]{
                i,
                n
              };
      end else do
        match = Caml_string.get(s, i);
        if (match > 57 or match < 48) then do
          return --[[ tuple ]]{
                  i,
                  n
                };
        end else do
          _i = i + 1 | 0;
          _n = (Caml_int32.imul(10, n) + Caml_string.get(s, i) | 0) - --[[ "0" ]]48 | 0;
          ::continue:: ;
        end end 
      end end 
    end;
  end end;
  get_range = function(i) do
    match = get_num(0, i);
    n1 = match[1];
    i_1 = match[0];
    if ((i_1 + 2 | 0) < #s and Caml_string.get(s, i_1) == --[[ "." ]]46 and Caml_string.get(s, i_1 + 1 | 0) == --[[ "." ]]46) then do
      match_1 = get_num(0, i_1 + 2 | 0);
      n2 = match_1[1];
      if (n2 < n1) then do
        error({
          Arg.Bad,
          "Ill-formed list of warnings"
        })
      end
       end 
      return --[[ tuple ]]{
              match_1[0],
              n1,
              n2
            };
    end else do
      return --[[ tuple ]]{
              i_1,
              n1,
              n1
            };
    end end 
  end end;
  loop = function(_i) do
    while(true) do
      i = _i;
      if (i >= #s) then do
        return --[[ () ]]0;
      end else do
        c = Caml_string.get(s, i);
        if (c >= 65) then do
          if (c >= 97) then do
            if (c >= 123) then do
              error({
                Arg.Bad,
                "Ill-formed list of warnings"
              })
            end
             end 
            List.iter(clear, letter(Caml_string.get(s, i)));
            _i = i + 1 | 0;
            ::continue:: ;
          end else do
            if (c >= 91) then do
              error({
                Arg.Bad,
                "Ill-formed list of warnings"
              })
            end
             end 
            List.iter(set, letter(Char.lowercase(Caml_string.get(s, i))));
            _i = i + 1 | 0;
            ::continue:: ;
          end end 
        end else if (c >= 46) then do
          if (c >= 64) then do
            return loop_letter_num(set_all, i + 1 | 0);
          end else do
            error({
              Arg.Bad,
              "Ill-formed list of warnings"
            })
          end end 
        end else if (c >= 43) then do
          local ___conditional___=(c - 43 | 0);
          do
             if ___conditional___ == 0 then do
                return loop_letter_num(set, i + 1 | 0); end end 
             if ___conditional___ == 1 then do
                error({
                  Arg.Bad,
                  "Ill-formed list of warnings"
                }) end end 
             if ___conditional___ == 2 then do
                return loop_letter_num(clear, i + 1 | 0); end end 
            
          end
        end else do
          error({
            Arg.Bad,
            "Ill-formed list of warnings"
          })
        end end  end  end 
      end end 
    end;
  end end;
  loop_letter_num = function(myset, i) do
    if (i >= #s) then do
      error({
        Arg.Bad,
        "Ill-formed list of warnings"
      })
    end
     end 
    match = Caml_string.get(s, i);
    if (match >= 65) then do
      if (match >= 97) then do
        if (match >= 123) then do
          error({
            Arg.Bad,
            "Ill-formed list of warnings"
          })
        end
         end 
        List.iter(myset, letter(Caml_string.get(s, i)));
        return loop(i + 1 | 0);
      end else do
        if (match >= 91) then do
          error({
            Arg.Bad,
            "Ill-formed list of warnings"
          })
        end
         end 
        List.iter(myset, letter(Char.lowercase(Caml_string.get(s, i))));
        return loop(i + 1 | 0);
      end end 
    end else do
      if (match > 57 or match < 48) then do
        error({
          Arg.Bad,
          "Ill-formed list of warnings"
        })
      end
       end 
      match_1 = get_range(i);
      for n = match_1[1] , Caml_primitive.caml_int_min(match_1[2], 104) , 1 do
        Curry._1(myset, n);
      end
      return loop(match_1[0]);
    end end 
  end end;
  return loop(0);
end end

function parse_options(errflag, s) do
  error = __Array.copy(current.contents.error);
  active = __Array.copy(current.contents.active);
  parse_opt(error, active, errflag and error or active, s);
  current.contents = do
    active: active,
    error: error
  end;
  return --[[ () ]]0;
end end

parse_options(false, "+a-4-6-7-9-27-29-32..39-41..42-44-45-48-50-102");

parse_options(true, "-a");

function message(param) do
  if (typeof param == "number") then do
    local ___conditional___=(param);
    do
       if ___conditional___ == 0--[[ Comment_start ]] then do
          return "this is the start of a comment."; end end 
       if ___conditional___ == 1--[[ Comment_not_end ]] then do
          return "this is not the end of a comment."; end end 
       if ___conditional___ == 2--[[ Partial_application ]] then do
          return "this function application is partial,\nmaybe some arguments are missing."; end end 
       if ___conditional___ == 3--[[ Labels_omitted ]] then do
          return "labels were omitted in the application of this function."; end end 
       if ___conditional___ == 4--[[ Statement_type ]] then do
          return "this expression should have type unit."; end end 
       if ___conditional___ == 5--[[ Unused_match ]] then do
          return "this match case is unused."; end end 
       if ___conditional___ == 6--[[ Unused_pat ]] then do
          return "this sub-pattern is unused."; end end 
       if ___conditional___ == 7--[[ Illegal_backslash ]] then do
          return "illegal backslash escape in string."; end end 
       if ___conditional___ == 8--[[ Unerasable_optional_argument ]] then do
          return "this optional argument cannot be erased."; end end 
       if ___conditional___ == 9--[[ Unused_argument ]] then do
          return "this argument will not be used by the function."; end end 
       if ___conditional___ == 10--[[ Nonreturning_statement ]] then do
          return "this statement never returns (or has an unsound type.)"; end end 
       if ___conditional___ == 11--[[ Useless_record_with ]] then do
          return "all the fields are explicitly listed in this record:\nthe 'with' clause is useless."; end end 
       if ___conditional___ == 12--[[ All_clauses_guarded ]] then do
          return "bad style, all clauses in this pattern-matching are guarded."; end end 
       if ___conditional___ == 13--[[ Wildcard_arg_to_constant_constr ]] then do
          return "wildcard pattern given as argument to a constant constructor"; end end 
       if ___conditional___ == 14--[[ Eol_in_string ]] then do
          return "unescaped end-of-line in a string constant (non-portable code)"; end end 
       if ___conditional___ == 15--[[ Unused_rec_flag ]] then do
          return "unused rec flag."; end end 
       if ___conditional___ == 16--[[ Bs_polymorphic_comparison ]] then do
          return "polymorphic comparison introduced (maybe unsafe)"; end end 
      
    end
  end else do
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ == 0--[[ Deprecated ]] then do
          return "deprecated: " .. param[0]; end end 
       if ___conditional___ == 1--[[ Fragile_match ]] then do
          s = param[0];
          if (s == "") then do
            return "this pattern-matching is fragile.";
          end else do
            return "this pattern-matching is fragile.\nIt will remain exhaustive when constructors are added to type " .. (s .. ".");
          end end  end end 
       if ___conditional___ == 2--[[ Method_override ]] then do
          match = param[0];
          if (match) then do
            slist = match[1];
            lab = match[0];
            if (slist) then do
              return __String.concat(" ", --[[ :: ]]{
                          "the following methods are overridden by the class",
                          --[[ :: ]]{
                            lab,
                            --[[ :: ]]{
                              ":\n ",
                              slist
                            }
                          }
                        });
            end else do
              return "the method " .. (lab .. " is overridden.");
            end end 
          end else do
            error({
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "warnings.ml",
                283,
                26
              }
            })
          end end  end end 
       if ___conditional___ == 3--[[ Partial_match ]] then do
          s_1 = param[0];
          if (s_1 == "") then do
            return "this pattern-matching is not exhaustive.";
          end else do
            return "this pattern-matching is not exhaustive.\nHere is an example of a value that is not matched:\n" .. s_1;
          end end  end end 
       if ___conditional___ == 4--[[ Non_closed_record_pattern ]] then do
          return "the following labels are not bound in this record pattern:\n" .. (param[0] .. "\nEither bind these labels explicitly or add '; _' to the pattern."); end end 
       if ___conditional___ == 5--[[ Instance_variable_override ]] then do
          match_1 = param[0];
          if (match_1) then do
            slist_1 = match_1[1];
            lab_1 = match_1[0];
            if (slist_1) then do
              return __String.concat(" ", --[[ :: ]]{
                          "the following instance variables are overridden by the class",
                          --[[ :: ]]{
                            lab_1,
                            --[[ :: ]]{
                              ":\n ",
                              slist_1
                            }
                          }
                        }) .. "\nThe behaviour changed in ocaml 3.10 (previous behaviour was hiding.)";
            end else do
              return "the instance variable " .. (lab_1 .. " is overridden.\nThe behaviour changed in ocaml 3.10 (previous behaviour was hiding.)");
            end end 
          end else do
            error({
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "warnings.ml",
                303,
                37
              }
            })
          end end  end end 
       if ___conditional___ == 6--[[ Implicit_public_methods ]] then do
          return "the following private methods were made public implicitly:\n " .. (__String.concat(" ", param[0]) .. "."); end end 
       if ___conditional___ == 7--[[ Undeclared_virtual_method ]] then do
          return "the virtual method " .. (param[0] .. " is not declared."); end end 
       if ___conditional___ == 8--[[ Not_principal ]] then do
          return param[0] .. " is not principal."; end end 
       if ___conditional___ == 9--[[ Without_principality ]] then do
          return param[0] .. " without principality."; end end 
       if ___conditional___ == 10--[[ Preprocessor ]] then do
          return param[0]; end end 
       if ___conditional___ == 11--[[ Bad_module_name ]] then do
          return "bad source file name: \"" .. (param[0] .. "\" is not a valid module name."); end end 
       if ___conditional___ == 12--[[ Unused_var ]]
       or ___conditional___ == 13--[[ Unused_var_strict ]] then do
          return "unused variable " .. (param[0] .. "."); end end 
       if ___conditional___ == 14--[[ Duplicate_definitions ]] then do
          return Curry._4(Printf.sprintf(--[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "the ",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ Char_literal ]]Block.__(12, {
                                      --[[ " " ]]32,
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ String_literal ]]Block.__(11, {
                                              " is defined in both types ",
                                              --[[ String ]]Block.__(2, {
                                                  --[[ No_padding ]]0,
                                                  --[[ String_literal ]]Block.__(11, {
                                                      " and ",
                                                      --[[ String ]]Block.__(2, {
                                                          --[[ No_padding ]]0,
                                                          --[[ Char_literal ]]Block.__(12, {
                                                              --[[ "." ]]46,
                                                              --[[ End_of_format ]]0
                                                            })
                                                        })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            }),
                          "the %s %s is defined in both types %s and %s."
                        }), param[0], param[1], param[2], param[3]); end end 
       if ___conditional___ == 15--[[ Multiple_definition ]] then do
          return Curry._3(Printf.sprintf(--[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "files ",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ String_literal ]]Block.__(11, {
                                      " and ",
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ String_literal ]]Block.__(11, {
                                              " both define a module named ",
                                              --[[ String ]]Block.__(2, {
                                                  --[[ No_padding ]]0,
                                                  --[[ End_of_format ]]0
                                                })
                                            })
                                        })
                                    })
                                })
                            }),
                          "files %s and %s both define a module named %s"
                        }), param[1], param[2], param[0]); end end 
       if ___conditional___ == 16--[[ Unused_value_declaration ]] then do
          return "unused value " .. (param[0] .. "."); end end 
       if ___conditional___ == 17--[[ Unused_open ]] then do
          return "unused open " .. (param[0] .. "."); end end 
       if ___conditional___ == 18--[[ Unused_type_declaration ]] then do
          return "unused type " .. (param[0] .. "."); end end 
       if ___conditional___ == 19--[[ Unused_for_index ]] then do
          return "unused for-loop index " .. (param[0] .. "."); end end 
       if ___conditional___ == 20--[[ Unused_ancestor ]] then do
          return "unused ancestor variable " .. (param[0] .. "."); end end 
       if ___conditional___ == 21--[[ Unused_constructor ]] then do
          s_2 = param[0];
          if (param[1]) then do
            return "constructor " .. (s_2 .. " is never used to build values.\n(However, this constructor appears in patterns.)");
          end else if (param[2]) then do
            return "constructor " .. (s_2 .. " is never used to build values.\nIts type is exported as a private type.");
          end else do
            return "unused constructor " .. (s_2 .. ".");
          end end  end  end end 
       if ___conditional___ == 22--[[ Unused_extension ]] then do
          s_3 = param[0];
          if (param[1]) then do
            return "extension constructor " .. (s_3 .. " is never used to build values.\n(However, this constructor appears in patterns.)");
          end else if (param[2]) then do
            return "extension constructor " .. (s_3 .. " is never used to build values.\nIt is exported or rebound as a private extension.");
          end else do
            return "unused extension constructor " .. (s_3 .. ".");
          end end  end  end end 
       if ___conditional___ == 23--[[ Name_out_of_scope ]] then do
          slist_2 = param[1];
          ty = param[0];
          if (slist_2 and not slist_2[1] and not param[2]) then do
            return slist_2[0] .. (" was selected from type " .. (ty .. ".\nIt is not visible in the current scope, and will not \nbe selected if the type becomes unknown."));
          end
           end 
          if (param[2]) then do
            return "this record of type " .. (ty .. (" contains fields that are \nnot visible in the current scope: " .. (__String.concat(" ", slist_2) .. ".\nThey will not be selected if the type becomes unknown.")));
          end else do
            error({
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "warnings.ml",
                365,
                39
              }
            })
          end end  end else 
       if ___conditional___ == 24--[[ Ambiguous_name ]] then do
          slist_3 = param[0];
          if (slist_3 and not slist_3[1] and not param[2]) then do
            return slist_3[0] .. (" belongs to several types: " .. (__String.concat(" ", param[1]) .. "\nThe first one was selected. Please disambiguate if this is wrong."));
          end
           end 
          if (param[2]) then do
            return "these field labels belong to several types: " .. (__String.concat(" ", param[1]) .. "\nThe first one was selected. Please disambiguate if this is wrong.");
          end else do
            error({
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "warnings.ml",
                374,
                36
              }
            })
          end end  end else 
       if ___conditional___ == 25--[[ Disambiguated_name ]] then do
          return "this use of " .. (param[0] .. " required disambiguation."); end end end end end end 
       if ___conditional___ == 26--[[ Nonoptional_label ]] then do
          return "the label " .. (param[0] .. " is not optional."); end end 
       if ___conditional___ == 27--[[ Open_shadow_identifier ]] then do
          return Curry._2(Printf.sprintf(--[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "this open statement shadows the ",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ String_literal ]]Block.__(11, {
                                      " identifier ",
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ String_literal ]]Block.__(11, {
                                              " (which is later used)",
                                              --[[ End_of_format ]]0
                                            })
                                        })
                                    })
                                })
                            }),
                          "this open statement shadows the %s identifier %s (which is later used)"
                        }), param[0], param[1]); end end 
       if ___conditional___ == 28--[[ Open_shadow_label_constructor ]] then do
          return Curry._2(Printf.sprintf(--[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "this open statement shadows the ",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ Char_literal ]]Block.__(12, {
                                      --[[ " " ]]32,
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ String_literal ]]Block.__(11, {
                                              " (which is later used)",
                                              --[[ End_of_format ]]0
                                            })
                                        })
                                    })
                                })
                            }),
                          "this open statement shadows the %s %s (which is later used)"
                        }), param[0], param[1]); end end 
       if ___conditional___ == 29--[[ Bad_env_variable ]] then do
          return Curry._2(Printf.sprintf(--[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "illegal environment variable ",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ String_literal ]]Block.__(11, {
                                      " : ",
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ End_of_format ]]0
                                        })
                                    })
                                })
                            }),
                          "illegal environment variable %s : %s"
                        }), param[0], param[1]); end end 
       if ___conditional___ == 30--[[ Attribute_payload ]] then do
          return Curry._2(Printf.sprintf(--[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "illegal payload for attribute '",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ String_literal ]]Block.__(11, {
                                      "'.\n",
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ End_of_format ]]0
                                        })
                                    })
                                })
                            }),
                          "illegal payload for attribute '%s'.\n%s"
                        }), param[0], param[1]); end end 
       if ___conditional___ == 31--[[ Eliminated_optional_arguments ]] then do
          sl = param[0];
          return Curry._2(Printf.sprintf(--[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "implicit elimination of optional argument",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ Char_literal ]]Block.__(12, {
                                      --[[ " " ]]32,
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ End_of_format ]]0
                                        })
                                    })
                                })
                            }),
                          "implicit elimination of optional argument%s %s"
                        }), List.length(sl) == 1 and "" or "s", __String.concat(", ", sl)); end end 
       if ___conditional___ == 32--[[ No_cmi_file ]] then do
          return "no cmi file was found in path for module " .. param[0]; end end 
       if ___conditional___ == 33--[[ Bad_docstring ]] then do
          if (param[0]) then do
            return "unattached documentation comment (ignored)";
          end else do
            return "ambiguous documentation comment";
          end end  end end 
       if ___conditional___ == 34--[[ Bs_unused_attribute ]] then do
          return "Unused BuckleScript attribute: " .. param[0]; end end 
       if ___conditional___ == 35--[[ Bs_ffi_warning ]] then do
          return "BuckleScript FFI warning: " .. param[0]; end end 
       if ___conditional___ == 36--[[ Bs_derive_warning ]] then do
          return "BuckleScript bs.deriving warning: " .. param[0]; end end 
      
    end
  end end 
end end

nerrors = do
  contents: 0
end;

function print(ppf, w) do
  msg = message(w);
  num = number(w);
  Curry._2(Format.fprintf(ppf, --[[ Format ]]{
            --[[ Int ]]Block.__(4, {
                --[[ Int_d ]]0,
                --[[ No_padding ]]0,
                --[[ No_precision ]]0,
                --[[ String_literal ]]Block.__(11, {
                    ": ",
                    --[[ String ]]Block.__(2, {
                        --[[ No_padding ]]0,
                        --[[ End_of_format ]]0
                      })
                  })
              }),
            "%d: %s"
          }), num, msg);
  Format.pp_print_flush(ppf, --[[ () ]]0);
  if (Caml_array.caml_array_get(current.contents.error, num)) then do
    nerrors.contents = nerrors.contents + 1 | 0;
    return --[[ () ]]0;
  end else do
    return 0;
  end end 
end end

Errors = Caml_exceptions.create("Ocaml_typedtree_test.Warnings.Errors");

absname = do
  contents: false
end;

function in_file(name) do
  loc = do
    pos_fname: name,
    pos_lnum: 1,
    pos_bol: 0,
    pos_cnum: -1
  end;
  return do
          loc_start: loc,
          loc_end: loc,
          loc_ghost: true
        end;
end end

none = in_file("_none_");

function curr(lexbuf) do
  return do
          loc_start: lexbuf.lex_start_p,
          loc_end: lexbuf.lex_curr_p,
          loc_ghost: false
        end;
end end

function symbol_rloc(param) do
  return do
          loc_start: Parsing.symbol_start_pos(--[[ () ]]0),
          loc_end: Parsing.symbol_end_pos(--[[ () ]]0),
          loc_ghost: false
        end;
end end

function symbol_gloc(param) do
  return do
          loc_start: Parsing.symbol_start_pos(--[[ () ]]0),
          loc_end: Parsing.symbol_end_pos(--[[ () ]]0),
          loc_ghost: true
        end;
end end

function rhs_loc(n) do
  return do
          loc_start: Parsing.rhs_start_pos(n),
          loc_end: Parsing.rhs_end_pos(n),
          loc_ghost: false
        end;
end end

input_name = do
  contents: "_none_"
end;

input_lexbuf = do
  contents: undefined
end;

status = do
  contents: --[[ Uninitialised ]]0
end;

num_loc_lines = do
  contents: 0
end;

function highlight_terminfo(ppf, num_lines, lb, locs) do
  Format.pp_print_flush(ppf, --[[ () ]]0);
  pos0 = -lb.lex_abs_pos | 0;
  if (pos0 < 0) then do
    error(Pervasives.Exit)
  end
   end 
  lines = num_loc_lines.contents;
  for i = pos0 , lb.lex_buffer_len - 1 | 0 , 1 do
    if (Caml_bytes.get(lb.lex_buffer, i) == --[[ "\n" ]]10) then do
      lines = lines + 1 | 0;
    end
     end 
  end
  if (lines >= (num_lines - 2 | 0)) then do
    error(Pervasives.Exit)
  end
   end 
  Caml_io.caml_ml_flush(Pervasives.stdout);
  Caml_external_polyfill.resolve("caml_terminfo_backup")(lines);
  bol = false;
  Pervasives.print_string("# ");
  for pos = 0 , (lb.lex_buffer_len - pos0 | 0) - 1 | 0 , 1 do
    if (bol) then do
      Pervasives.print_string("  ");
      bol = false;
    end
     end 
    if (List.exists((function(pos)do
          return function (loc) do
            return pos == loc.loc_start.pos_cnum;
          end end
          end end)(pos), locs)) then do
      Caml_external_polyfill.resolve("caml_terminfo_standout")(true);
    end
     end 
    if (List.exists((function(pos)do
          return function (loc) do
            return pos == loc.loc_end.pos_cnum;
          end end
          end end)(pos), locs)) then do
      Caml_external_polyfill.resolve("caml_terminfo_standout")(false);
    end
     end 
    c = Caml_bytes.get(lb.lex_buffer, pos + pos0 | 0);
    Pervasives.print_char(c);
    bol = c == --[[ "\n" ]]10;
  end
  Caml_external_polyfill.resolve("caml_terminfo_standout")(false);
  Caml_external_polyfill.resolve("caml_terminfo_resume")(num_loc_lines.contents);
  return Caml_io.caml_ml_flush(Pervasives.stdout);
end end

function highlight_dumb(ppf, lb, loc) do
  pos0 = -lb.lex_abs_pos | 0;
  if (pos0 < 0) then do
    error(Pervasives.Exit)
  end
   end 
  end_pos = (lb.lex_buffer_len - pos0 | 0) - 1 | 0;
  line_start = 0;
  line_end = 0;
  for pos = 0 , end_pos , 1 do
    if (Caml_bytes.get(lb.lex_buffer, pos + pos0 | 0) == --[[ "\n" ]]10) then do
      if (loc.loc_start.pos_cnum > pos) then do
        line_start = line_start + 1 | 0;
      end
       end 
      if (loc.loc_end.pos_cnum > pos) then do
        line_end = line_end + 1 | 0;
      end
       end 
    end
     end 
  end
  Curry._2(Format.fprintf(ppf, --[[ Format ]]{
            --[[ String_literal ]]Block.__(11, {
                "Characters ",
                --[[ Int ]]Block.__(4, {
                    --[[ Int_i ]]3,
                    --[[ No_padding ]]0,
                    --[[ No_precision ]]0,
                    --[[ Char_literal ]]Block.__(12, {
                        --[[ "-" ]]45,
                        --[[ Int ]]Block.__(4, {
                            --[[ Int_i ]]3,
                            --[[ No_padding ]]0,
                            --[[ No_precision ]]0,
                            --[[ Char_literal ]]Block.__(12, {
                                --[[ ":" ]]58,
                                --[[ Formatting_lit ]]Block.__(17, {
                                    --[[ Flush_newline ]]4,
                                    --[[ End_of_format ]]0
                                  })
                              })
                          })
                      })
                  })
              }),
            "Characters %i-%i:@."
          }), loc.loc_start.pos_cnum, loc.loc_end.pos_cnum);
  Format.pp_print_string(ppf, "  ");
  line = 0;
  pos_at_bol = 0;
  for pos_1 = 0 , end_pos , 1 do
    c = Caml_bytes.get(lb.lex_buffer, pos_1 + pos0 | 0);
    if (c ~= 10) then do
      if (c ~= 13) then do
        if (line == line_start and line == line_end) then do
          Format.pp_print_char(ppf, c);
        end else if (line == line_start) then do
          if (pos_1 < loc.loc_start.pos_cnum) then do
            Format.pp_print_char(ppf, --[[ "." ]]46);
          end else do
            Format.pp_print_char(ppf, c);
          end end 
        end else if (line == line_end) then do
          if (pos_1 < loc.loc_end.pos_cnum) then do
            Format.pp_print_char(ppf, c);
          end else do
            Format.pp_print_char(ppf, --[[ "." ]]46);
          end end 
        end else if (line > line_start and line < line_end) then do
          Format.pp_print_char(ppf, c);
        end
         end  end  end  end 
      end
       end 
    end else do
      if (line == line_start and line == line_end) then do
        Format.fprintf(ppf, --[[ Format ]]{
              --[[ Formatting_lit ]]Block.__(17, {
                  --[[ Flush_newline ]]4,
                  --[[ String_literal ]]Block.__(11, {
                      "  ",
                      --[[ End_of_format ]]0
                    })
                }),
              "@.  "
            });
        for _i = pos_at_bol , loc.loc_start.pos_cnum - 1 | 0 , 1 do
          Format.pp_print_char(ppf, --[[ " " ]]32);
        end
        for _i_1 = loc.loc_start.pos_cnum , loc.loc_end.pos_cnum - 1 | 0 , 1 do
          Format.pp_print_char(ppf, --[[ "^" ]]94);
        end
      end
       end 
      if (line >= line_start and line <= line_end) then do
        Format.fprintf(ppf, --[[ Format ]]{
              --[[ Formatting_lit ]]Block.__(17, {
                  --[[ Flush_newline ]]4,
                  --[[ End_of_format ]]0
                }),
              "@."
            });
        if (pos_1 < loc.loc_end.pos_cnum) then do
          Format.pp_print_string(ppf, "  ");
        end
         end 
      end
       end 
      line = line + 1 | 0;
      pos_at_bol = pos_1 + 1 | 0;
    end end 
  end
  return --[[ () ]]0;
end end

function highlight_locations(ppf, locs) do
  while(true) do
    match = status.contents;
    if (typeof match == "number") then do
      if (match ~= 0) then do
        match_1 = input_lexbuf.contents;
        if (match_1 ~= undefined) then do
          norepeat;
          xpcall(function() do
            norepeat = Caml_sys.caml_sys_getenv("TERM") == "norepeat";
          end end,function(exn) do
            if (exn == Caml_builtin_exceptions.not_found) then do
              norepeat = false;
            end else do
              error(exn)
            end end 
          end end)
          if (norepeat) then do
            return false;
          end else do
            loc1 = List.hd(locs);
            xpcall(function() do
              highlight_dumb(ppf, match_1, loc1);
              return true;
            end end,function(exn_1) do
              if (exn_1 == Pervasives.Exit) then do
                return false;
              end else do
                error(exn_1)
              end end 
            end end)
          end end 
        end else do
          return false;
        end end 
      end else do
        status.contents = Caml_external_polyfill.resolve("caml_terminfo_setup")(Pervasives.stdout);
        ::continue:: ;
      end end 
    end else do
      match_2 = input_lexbuf.contents;
      if (match_2 ~= undefined) then do
        xpcall(function() do
          highlight_terminfo(ppf, match[0], match_2, locs);
          return true;
        end end,function(exn_2) do
          if (exn_2 == Pervasives.Exit) then do
            return false;
          end else do
            error(exn_2)
          end end 
        end end)
      end else do
        return false;
      end end 
    end end 
  end;
end end

function show_filename(file) do
  if (absname.contents) then do
    s = file;
    s_1 = Curry._1(Filename.is_relative, s) and Filename.concat(Caml_sys.caml_sys_getcwd(--[[ () ]]0), s) or s;
    aux = function(_s) do
      while(true) do
        s = _s;
        base = Curry._1(Filename.basename, s);
        dir = Curry._1(Filename.dirname, s);
        if (dir == s) then do
          return dir;
        end else if (base == Filename.current_dir_name) then do
          _s = dir;
          ::continue:: ;
        end else if (base == Filename.parent_dir_name) then do
          return Curry._1(Filename.dirname, aux(dir));
        end else do
          return Filename.concat(aux(dir), base);
        end end  end  end 
      end;
    end end;
    return aux(s_1);
  end else do
    return file;
  end end 
end end

function print_filename(ppf, file) do
  return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                  --[[ String ]]Block.__(2, {
                      --[[ No_padding ]]0,
                      --[[ End_of_format ]]0
                    }),
                  "%s"
                }), show_filename(file));
end end

function get_pos_info(pos) do
  return --[[ tuple ]]{
          pos.pos_fname,
          pos.pos_lnum,
          pos.pos_cnum - pos.pos_bol | 0
        };
end end

function print_loc(ppf, loc) do
  Curry._1(Misc_Color.setup, color.contents);
  match = get_pos_info(loc.loc_start);
  startchar = match[2];
  file = match[0];
  startchar_1 = bs_vscode and startchar + 1 | 0 or startchar;
  endchar = (loc.loc_end.pos_cnum - loc.loc_start.pos_cnum | 0) + startchar_1 | 0;
  if (file == "//toplevel//") then do
    if (highlight_locations(ppf, --[[ :: ]]{
            loc,
            --[[ [] ]]0
          })) then do
      return --[[ () ]]0;
    end else do
      return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "Characters ",
                          --[[ Int ]]Block.__(4, {
                              --[[ Int_i ]]3,
                              --[[ No_padding ]]0,
                              --[[ No_precision ]]0,
                              --[[ Char_literal ]]Block.__(12, {
                                  --[[ "-" ]]45,
                                  --[[ Int ]]Block.__(4, {
                                      --[[ Int_i ]]3,
                                      --[[ No_padding ]]0,
                                      --[[ No_precision ]]0,
                                      --[[ End_of_format ]]0
                                    })
                                })
                            })
                        }),
                      "Characters %i-%i"
                    }), loc.loc_start.pos_cnum, loc.loc_end.pos_cnum);
    end end 
  end else do
    Curry._5(Format.fprintf(ppf, --[[ Format ]]{
              --[[ String ]]Block.__(2, {
                  --[[ No_padding ]]0,
                  --[[ Formatting_gen ]]Block.__(18, {
                      --[[ Open_tag ]]Block.__(0, {--[[ Format ]]{
                            --[[ String_literal ]]Block.__(11, {
                                "<loc>",
                                --[[ End_of_format ]]0
                              }),
                            "<loc>"
                          }}),
                      --[[ Alpha ]]Block.__(15, {--[[ String ]]Block.__(2, {
                              --[[ No_padding ]]0,
                              --[[ Int ]]Block.__(4, {
                                  --[[ Int_i ]]3,
                                  --[[ No_padding ]]0,
                                  --[[ No_precision ]]0,
                                  --[[ End_of_format ]]0
                                })
                            })})
                    })
                }),
              "%s@{<loc>%a%s%i"
            }), "File \"", print_filename, file, "\", line ", match[1]);
    if (startchar_1 >= 0) then do
      Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                --[[ String ]]Block.__(2, {
                    --[[ No_padding ]]0,
                    --[[ Int ]]Block.__(4, {
                        --[[ Int_i ]]3,
                        --[[ No_padding ]]0,
                        --[[ No_precision ]]0,
                        --[[ String ]]Block.__(2, {
                            --[[ No_padding ]]0,
                            --[[ Int ]]Block.__(4, {
                                --[[ Int_i ]]3,
                                --[[ No_padding ]]0,
                                --[[ No_precision ]]0,
                                --[[ End_of_format ]]0
                              })
                          })
                      })
                  }),
                "%s%i%s%i"
              }), ", characters ", startchar_1, "-", endchar);
    end
     end 
    return Format.fprintf(ppf, --[[ Format ]]{
                --[[ Formatting_lit ]]Block.__(17, {
                    --[[ Close_tag ]]1,
                    --[[ End_of_format ]]0
                  }),
                "@}"
              });
  end end 
end end

function print_1(ppf, loc) do
  Curry._1(Misc_Color.setup, color.contents);
  if (loc.loc_start.pos_fname == "//toplevel//" and highlight_locations(ppf, --[[ :: ]]{
          loc,
          --[[ [] ]]0
        })) then do
    return --[[ () ]]0;
  end else do
    return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_tag ]]Block.__(0, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<loc>",
                                  --[[ End_of_format ]]0
                                }),
                              "<loc>"
                            }}),
                        --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                --[[ Close_tag ]]1,
                                --[[ String ]]Block.__(2, {
                                    --[[ No_padding ]]0,
                                    --[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Flush_newline ]]4,
                                        --[[ End_of_format ]]0
                                      })
                                  })
                              })})
                      }),
                    "@{<loc>%a@}%s@."
                  }), print_loc, loc, ":");
  end end 
end end

error_prefix = "Error";

function print_error(ppf, loc) do
  print_1(ppf, loc);
  ppf_1 = ppf;
  Curry._1(Misc_Color.setup, color.contents);
  Curry._1(Format.fprintf(ppf_1, --[[ Format ]]{
            --[[ Formatting_gen ]]Block.__(18, {
                --[[ Open_tag ]]Block.__(0, {--[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "<error>",
                          --[[ End_of_format ]]0
                        }),
                      "<error>"
                    }}),
                --[[ String ]]Block.__(2, {
                    --[[ No_padding ]]0,
                    --[[ Formatting_lit ]]Block.__(17, {
                        --[[ Close_tag ]]1,
                        --[[ Char_literal ]]Block.__(12, {
                            --[[ ":" ]]58,
                            --[[ End_of_format ]]0
                          })
                      })
                  })
              }),
            "@{<error>%s@}:"
          }), error_prefix);
  return --[[ () ]]0;
end end

function default_warning_printer(loc, ppf, w) do
  if (is_active(w)) then do
    Curry._1(Misc_Color.setup, color.contents);
    print_1(ppf, loc);
    return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_tag ]]Block.__(0, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<warning>",
                                  --[[ End_of_format ]]0
                                }),
                              "<warning>"
                            }}),
                        --[[ String ]]Block.__(2, {
                            --[[ No_padding ]]0,
                            --[[ Formatting_lit ]]Block.__(17, {
                                --[[ Close_tag ]]1,
                                --[[ Char_literal ]]Block.__(12, {
                                    --[[ " " ]]32,
                                    --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Flush_newline ]]4,
                                            --[[ End_of_format ]]0
                                          })})
                                  })
                              })
                          })
                      }),
                    "@{<warning>%s@} %a@."
                  }), "Warning", print, w);
  end else do
    return 0;
  end end 
end end

warning_printer = do
  contents: default_warning_printer
end;

formatter_for_warnings = do
  contents: Format.err_formatter
end;

function prerr_warning(loc, w) do
  loc_1 = loc;
  ppf = formatter_for_warnings.contents;
  w_1 = w;
  ppf_1 = ppf;
  f = Curry._1(warning_printer.contents, loc_1);
  arg = w_1;
  out_functions = Format.pp_get_formatter_out_functions(ppf_1, --[[ () ]]0);
  out_string = function(str, start, len) do
    count = function(_i, _c) do
      while(true) do
        c = _c;
        i = _i;
        if (i == (start + len | 0)) then do
          return c;
        end else if (Caml_string.get(str, i) == --[[ "\n" ]]10) then do
          _c = c + 1 | 0;
          _i = i + 1 | 0;
          ::continue:: ;
        end else do
          _i = i + 1 | 0;
          ::continue:: ;
        end end  end 
      end;
    end end;
    num_loc_lines.contents = num_loc_lines.contents + count(start, 0) | 0;
    return Curry._3(out_functions.out_string, str, start, len);
  end end;
  Format.pp_set_formatter_out_functions(ppf_1, do
        out_string: out_string,
        out_flush: out_functions.out_flush,
        out_newline: out_functions.out_newline,
        out_spaces: out_functions.out_spaces,
        out_indent: out_functions.out_indent
      end);
  Curry._2(f, ppf_1, arg);
  Format.pp_print_flush(ppf_1, --[[ () ]]0);
  return Format.pp_set_formatter_out_functions(ppf_1, out_functions);
end end

function print_phanton_error_prefix(ppf) do
  return Format.pp_print_as(ppf, #error_prefix + 2 | 0, "");
end end

function errorf(locOpt, subOpt, if_highlightOpt, fmt) do
  loc = locOpt ~= undefined and locOpt or none;
  sub = subOpt ~= undefined and subOpt or --[[ [] ]]0;
  if_highlight = if_highlightOpt ~= undefined and if_highlightOpt or "";
  before = print_phanton_error_prefix;
  k = function(msg) do
    return do
            loc: loc,
            msg: msg,
            sub: sub,
            if_highlight: if_highlight
          end;
  end end;
  fmt_1 = fmt;
  buf = __Buffer.create(64);
  ppf = Format.formatter_of_buffer(buf);
  Curry._1(Misc_Color.set_color_tag_handling, ppf);
  if (before ~= undefined) then do
    Curry._1(before, ppf);
  end
   end 
  return Format.kfprintf((function(param) do
                Format.pp_print_flush(ppf, --[[ () ]]0);
                return Curry._1(k, __Buffer.contents(buf));
              end end), ppf, fmt_1);
end end

function error(locOpt, subOpt, if_highlightOpt, msg) do
  loc = locOpt ~= undefined and locOpt or none;
  sub = subOpt ~= undefined and subOpt or --[[ [] ]]0;
  if_highlight = if_highlightOpt ~= undefined and if_highlightOpt or "";
  return do
          loc: loc,
          msg: msg,
          sub: sub,
          if_highlight: if_highlight
        end;
end end

error_of_exn = do
  contents: --[[ [] ]]0
end;

function register_error_of_exn(f) do
  error_of_exn.contents = --[[ :: ]]{
    f,
    error_of_exn.contents
  };
  return --[[ () ]]0;
end end

function error_of_printer(loc, print, x) do
  return Curry._2(errorf(loc, undefined, undefined, --[[ Format ]]{
                  --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                          --[[ FFlush ]]2,
                          --[[ End_of_format ]]0
                        })}),
                  "%a@?"
                }), print, x);
end end

function error_of_printer_file(print, x) do
  return error_of_printer(in_file(input_name.contents), print, x);
end end

register_error_of_exn((function(param) do
        if (param[0] == Caml_builtin_exceptions.sys_error) then do
          return Curry._1(errorf(in_file(input_name.contents), undefined, undefined, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "I/O error: ",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ End_of_format ]]0
                                })
                            }),
                          "I/O error: %s"
                        }), param[1]);
        end else if (param[0] == Errors) then do
          return Curry._1(errorf(in_file(input_name.contents), undefined, undefined, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "Some fatal warnings were triggered (",
                              --[[ Int ]]Block.__(4, {
                                  --[[ Int_d ]]0,
                                  --[[ No_padding ]]0,
                                  --[[ No_precision ]]0,
                                  --[[ String_literal ]]Block.__(11, {
                                      " occurrences)",
                                      --[[ End_of_format ]]0
                                    })
                                })
                            }),
                          "Some fatal warnings were triggered (%d occurrences)"
                        }), param[1]);
        end else do
          return ;
        end end  end 
      end end));

__Error = Caml_exceptions.create("Ocaml_typedtree_test.Location.Error");

register_error_of_exn((function(param) do
        if (param[0] == __Error) then do
          return param[1];
        end
         end 
      end end));

currentstamp = do
  contents: 0
end;

function create(s) do
  currentstamp.contents = currentstamp.contents + 1 | 0;
  return do
          stamp: currentstamp.contents,
          name: s,
          flags: 0
        end;
end end

function create_predef_exn(s) do
  currentstamp.contents = currentstamp.contents + 1 | 0;
  return do
          stamp: currentstamp.contents,
          name: s,
          flags: 2
        end;
end end

function rename(i) do
  currentstamp.contents = currentstamp.contents + 1 | 0;
  return do
          stamp: currentstamp.contents,
          name: i.name,
          flags: i.flags
        end;
end end

function unique_toplevel_name(i) do
  return i.name .. ("/" .. String(i.stamp));
end end

function equal(i1, i2) do
  return i1.name == i2.name;
end end

function set_current_time(t) do
  currentstamp.contents = currentstamp.contents > t and currentstamp.contents or t;
  return --[[ () ]]0;
end end

function hide(i) do
  return do
          stamp: -1,
          name: i.name,
          flags: i.flags
        end;
end end

function make_global(i) do
  i.flags = i.flags | 1;
  return --[[ () ]]0;
end end

function __global(i) do
  return (i.flags & 1) ~= 0;
end end

function print_2(ppf, i) do
  n = i.stamp;
  if (n ~= -1) then do
    if (n ~= 0) then do
      return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String ]]Block.__(2, {
                          --[[ No_padding ]]0,
                          --[[ Char_literal ]]Block.__(12, {
                              --[[ "/" ]]47,
                              --[[ Int ]]Block.__(4, {
                                  --[[ Int_i ]]3,
                                  --[[ No_padding ]]0,
                                  --[[ No_precision ]]0,
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ End_of_format ]]0
                                    })
                                })
                            })
                        }),
                      "%s/%i%s"
                    }), i.name, n, __global(i) and "g" or "");
    end else do
      return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String ]]Block.__(2, {
                          --[[ No_padding ]]0,
                          --[[ Char_literal ]]Block.__(12, {
                              --[[ "!" ]]33,
                              --[[ End_of_format ]]0
                            })
                        }),
                      "%s!"
                    }), i.name);
    end end 
  end else do
    return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ String ]]Block.__(2, {
                        --[[ No_padding ]]0,
                        --[[ Char_literal ]]Block.__(12, {
                            --[[ "#" ]]35,
                            --[[ End_of_format ]]0
                          })
                      }),
                    "%s#"
                  }), i.name);
  end end 
end end

function mknode(l, d, r) do
  hl = l and l[3] or 0;
  hr = r and r[3] or 0;
  return --[[ Node ]]{
          l,
          d,
          r,
          hl >= hr and hl + 1 | 0 or hr + 1 | 0
        };
end end

function balance(l, d, r) do
  hl = l and l[3] or 0;
  hr = r and r[3] or 0;
  if (hl > (hr + 1 | 0)) then do
    if (l) then do
      lr = l[2];
      ld = l[1];
      ll = l[0];
      if ((
          ll and ll[3] or 0
        ) >= (
          lr and lr[3] or 0
        )) then do
        return mknode(ll, ld, mknode(lr, d, r));
      end else if (lr) then do
        return mknode(mknode(ll, ld, lr[0]), lr[1], mknode(lr[2], d, r));
      end else do
        error({
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ident.ml",
            120,
            11
          }
        })
      end end  end 
    end else do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "ident.ml",
          120,
          11
        }
      })
    end end 
  end else if (hr > (hl + 1 | 0)) then do
    if (r) then do
      rl = r[0];
      rr = r[2];
      if ((
          rr and rr[3] or 0
        ) >= (
          rl and rl[3] or 0
        )) then do
        return mknode(mknode(l, d, rl), r[1], rr);
      end else if (rl) then do
        return mknode(mknode(l, d, rl[0]), rl[1], mknode(rl[2], r[1], r[2]));
      end else do
        error({
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ident.ml",
            129,
            11
          }
        })
      end end  end 
    end else do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "ident.ml",
          129,
          11
        }
      })
    end end 
  end else do
    return mknode(l, d, r);
  end end  end 
end end

function add(id, data, param) do
  if (param) then do
    r = param[2];
    k = param[1];
    l = param[0];
    c = Caml_primitive.caml_string_compare(id.name, k.ident.name);
    if (c == 0) then do
      return --[[ Node ]]{
              l,
              do
                ident: id,
                data: data,
                previous: k
              end,
              r,
              param[3]
            };
    end else if (c < 0) then do
      return balance(add(id, data, l), k, r);
    end else do
      return balance(l, k, add(id, data, r));
    end end  end 
  end else do
    return --[[ Node ]]{
            --[[ Empty ]]0,
            do
              ident: id,
              data: data,
              previous: undefined
            end,
            --[[ Empty ]]0,
            1
          };
  end end 
end end

function find_same(id, _param) do
  while(true) do
    param = _param;
    if (param) then do
      k = param[1];
      c = Caml_primitive.caml_string_compare(id.name, k.ident.name);
      if (c == 0) then do
        if (id.stamp == k.ident.stamp) then do
          return k.data;
        end else do
          s = id.stamp;
          _param_1 = k.previous;
          while(true) do
            param_1 = _param_1;
            if (param_1 ~= undefined) then do
              k_1 = param_1;
              if (k_1.ident.stamp == s) then do
                return k_1.data;
              end else do
                _param_1 = k_1.previous;
                ::continue:: ;
              end end 
            end else do
              error(Caml_builtin_exceptions.not_found)
            end end 
          end;
        end end 
      end else do
        _param = c < 0 and param[0] or param[2];
        ::continue:: ;
      end end 
    end else do
      error(Caml_builtin_exceptions.not_found)
    end end 
  end;
end end

function find_name(name, _param) do
  while(true) do
    param = _param;
    if (param) then do
      k = param[1];
      c = Caml_primitive.caml_string_compare(name, k.ident.name);
      if (c == 0) then do
        return k.data;
      end else do
        _param = c < 0 and param[0] or param[2];
        ::continue:: ;
      end end 
    end else do
      error(Caml_builtin_exceptions.not_found)
    end end 
  end;
end end

function get_all(param) do
  if (param ~= undefined) then do
    k = param;
    return --[[ :: ]]{
            k.data,
            get_all(k.previous)
          };
  end else do
    return --[[ [] ]]0;
  end end 
end end

function find_all(name, _param) do
  while(true) do
    param = _param;
    if (param) then do
      k = param[1];
      c = Caml_primitive.caml_string_compare(name, k.ident.name);
      if (c == 0) then do
        return --[[ :: ]]{
                k.data,
                get_all(k.previous)
              };
      end else do
        _param = c < 0 and param[0] or param[2];
        ::continue:: ;
      end end 
    end else do
      return --[[ [] ]]0;
    end end 
  end;
end end

function iter(f, _param) do
  while(true) do
    param = _param;
    if (param) then do
      k = param[1];
      iter(f, param[0]);
      Curry._2(f, k.ident, k.data);
      _param = param[2];
      ::continue:: ;
    end else do
      return --[[ () ]]0;
    end end 
  end;
end end

function same(_p1, _p2) do
  while(true) do
    p2 = _p2;
    p1 = _p1;
    local ___conditional___=(p1.tag | 0);
    do
       if ___conditional___ == 0--[[ Pident ]] then do
          local ___conditional___=(p2.tag | 0);
          do
             if ___conditional___ == 0--[[ Pident ]] then do
                return Caml_obj.caml_equal(p1[0], p2[0]); end end 
             if ___conditional___ == 1--[[ Pdot ]]
             or ___conditional___ == 2--[[ Papply ]] then do
                return false; end end 
            
          end end end 
       if ___conditional___ == 1--[[ Pdot ]] then do
          local ___conditional___=(p2.tag | 0);
          do
             if ___conditional___ == 1--[[ Pdot ]] then do
                if (p1[1] == p2[1]) then do
                  _p2 = p2[0];
                  _p1 = p1[0];
                  ::continue:: ;
                end else do
                  return false;
                end end  end end 
             if ___conditional___ == 0--[[ Pident ]]
             or ___conditional___ == 2--[[ Papply ]] then do
                return false; end end 
            
          end end end 
       if ___conditional___ == 2--[[ Papply ]] then do
          local ___conditional___=(p2.tag | 0);
          do
             if ___conditional___ == 0--[[ Pident ]]
             or ___conditional___ == 1--[[ Pdot ]] then do
                return false; end end 
             if ___conditional___ == 2--[[ Papply ]] then do
                if (same(p1[0], p2[0])) then do
                  _p2 = p2[1];
                  _p1 = p1[1];
                  ::continue:: ;
                end else do
                  return false;
                end end  end end 
            
          end end end 
      
    end
  end;
end end

function isfree(id, _param) do
  while(true) do
    param = _param;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ == 0--[[ Pident ]] then do
          return Caml_obj.caml_equal(id, param[0]); end end 
       if ___conditional___ == 1--[[ Pdot ]] then do
          _param = param[0];
          ::continue:: ; end end 
       if ___conditional___ == 2--[[ Papply ]] then do
          if (isfree(id, param[0])) then do
            return true;
          end else do
            _param = param[1];
            ::continue:: ;
          end end  end end 
      
    end
  end;
end end

function binding_time(_param) do
  while(true) do
    param = _param;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ == 0--[[ Pident ]] then do
          return param[0].stamp; end end 
       if ___conditional___ == 1--[[ Pdot ]] then do
          _param = param[0];
          ::continue:: ; end end 
       if ___conditional___ == 2--[[ Papply ]] then do
          return Caml_primitive.caml_int_max(binding_time(param[0]), binding_time(param[1])); end end 
      
    end
  end;
end end

function kfalse(x) do
  return false;
end end

function name($staropt$star, param) do
  paren = $staropt$star ~= undefined and $staropt$star or kfalse;
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Pident ]] then do
        return param[0].name; end end 
     if ___conditional___ == 1--[[ Pdot ]] then do
        s = param[1];
        return name(paren, param[0]) .. (
                Curry._1(paren, s) and ".( " .. (s .. " )") or "." .. s
              ); end end 
     if ___conditional___ == 2--[[ Papply ]] then do
        return name(paren, param[0]) .. ("(" .. (name(paren, param[1]) .. ")")); end end 
    
  end
end end

function head(_param) do
  while(true) do
    param = _param;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ == 0--[[ Pident ]] then do
          return param[0]; end end 
       if ___conditional___ == 1--[[ Pdot ]] then do
          _param = param[0];
          ::continue:: ; end end 
       if ___conditional___ == 2--[[ Papply ]] then do
          error({
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "path.ml",
              49,
              22
            }
          }) end end 
      
    end
  end;
end end

function last(_param) do
  while(true) do
    param = _param;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ == 0--[[ Pident ]] then do
          return param[0].name; end end 
       if ___conditional___ == 1--[[ Pdot ]] then do
          return param[1]; end end 
       if ___conditional___ == 2--[[ Papply ]] then do
          _param = param[1];
          ::continue:: ; end end 
      
    end
  end;
end end

function flat(_accu, _param) do
  while(true) do
    param = _param;
    accu = _accu;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ == 0--[[ Lident ]] then do
          return --[[ :: ]]{
                  param[0],
                  accu
                }; end end 
       if ___conditional___ == 1--[[ Ldot ]] then do
          _param = param[0];
          _accu = --[[ :: ]]{
            param[1],
            accu
          };
          ::continue:: ; end end 
       if ___conditional___ == 2--[[ Lapply ]] then do
          return fatal_error("Longident.flat"); end end 
      
    end
  end;
end end

function flatten(lid) do
  return flat(--[[ [] ]]0, lid);
end end

function last_1(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Lident ]] then do
        return param[0]; end end 
     if ___conditional___ == 1--[[ Ldot ]] then do
        return param[1]; end end 
     if ___conditional___ == 2--[[ Lapply ]] then do
        return fatal_error("Longident.last"); end end 
    
  end
end end

function parse_declaration(arity, decl) do
  if (decl) then do
    match = decl[1];
    name = decl[0];
    if (match) then do
      name2 = match[0];
      if (name2 == "noalloc") then do
        match_1 = match[1];
        if (match_1) then do
          match_2 = match_1[1];
          name2_1 = match_1[0];
          if (match_2 and match_2[0] == "float") then do
            return do
                    prim_name: name,
                    prim_arity: arity,
                    prim_alloc: false,
                    prim_native_name: name2_1,
                    prim_native_float: true
                  end;
          end else do
            return do
                    prim_name: name,
                    prim_arity: arity,
                    prim_alloc: false,
                    prim_native_name: name2_1,
                    prim_native_float: false
                  end;
          end end 
        end
         end 
      end else do
        match_3 = match[1];
        if (match_3 and match_3[0] == "float") then do
          return do
                  prim_name: name,
                  prim_arity: arity,
                  prim_alloc: true,
                  prim_native_name: name2,
                  prim_native_float: true
                end;
        end
         end 
      end end 
      if (name2 == "noalloc") then do
        return do
                prim_name: name,
                prim_arity: arity,
                prim_alloc: false,
                prim_native_name: "",
                prim_native_float: false
              end;
      end else do
        return do
                prim_name: name,
                prim_arity: arity,
                prim_alloc: true,
                prim_native_name: name2,
                prim_native_float: false
              end;
      end end 
    end else do
      return do
              prim_name: name,
              prim_arity: arity,
              prim_alloc: true,
              prim_native_name: "",
              prim_native_float: false
            end;
    end end 
  end else do
    return fatal_error("Primitive.parse_declaration");
  end end 
end end

function description_list(p) do
  list_000 = p.prim_name;
  list = --[[ :: ]]{
    list_000,
    --[[ [] ]]0
  };
  list_1 = p.prim_alloc and list or --[[ :: ]]{
      "noalloc",
      list
    };
  list_2 = p.prim_native_name ~= "" and --[[ :: ]]{
      p.prim_native_name,
      list_1
    } or list_1;
  return List.rev(p.prim_native_float and --[[ :: ]]{
                "float",
                list_2
              } or list_2);
end end

function compare(t1, t2) do
  return t1.id - t2.id | 0;
end end

function hash(t) do
  return t.id;
end end

function equal_1(t1, t2) do
  return t1 == t2;
end end

function height(param) do
  if (param) then do
    return param[--[[ h ]]4];
  end else do
    return 0;
  end end 
end end

function create_1(l, x, d, r) do
  hl = height(l);
  hr = height(r);
  return --[[ Node ]]{
          --[[ l ]]l,
          --[[ v ]]x,
          --[[ d ]]d,
          --[[ r ]]r,
          --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
        };
end end

function bal(l, x, d, r) do
  hl = l and l[--[[ h ]]4] or 0;
  hr = r and r[--[[ h ]]4] or 0;
  if (hl > (hr + 2 | 0)) then do
    if (l) then do
      lr = l[--[[ r ]]3];
      ld = l[--[[ d ]]2];
      lv = l[--[[ v ]]1];
      ll = l[--[[ l ]]0];
      if (height(ll) >= height(lr)) then do
        return create_1(ll, lv, ld, create_1(lr, x, d, r));
      end else if (lr) then do
        return create_1(create_1(ll, lv, ld, lr[--[[ l ]]0]), lr[--[[ v ]]1], lr[--[[ d ]]2], create_1(lr[--[[ r ]]3], x, d, r));
      end else do
        error({
          Caml_builtin_exceptions.invalid_argument,
          "Map.bal"
        })
      end end  end 
    end else do
      error({
        Caml_builtin_exceptions.invalid_argument,
        "Map.bal"
      })
    end end 
  end else if (hr > (hl + 2 | 0)) then do
    if (r) then do
      rr = r[--[[ r ]]3];
      rd = r[--[[ d ]]2];
      rv = r[--[[ v ]]1];
      rl = r[--[[ l ]]0];
      if (height(rr) >= height(rl)) then do
        return create_1(create_1(l, x, d, rl), rv, rd, rr);
      end else if (rl) then do
        return create_1(create_1(l, x, d, rl[--[[ l ]]0]), rl[--[[ v ]]1], rl[--[[ d ]]2], create_1(rl[--[[ r ]]3], rv, rd, rr));
      end else do
        error({
          Caml_builtin_exceptions.invalid_argument,
          "Map.bal"
        })
      end end  end 
    end else do
      error({
        Caml_builtin_exceptions.invalid_argument,
        "Map.bal"
      })
    end end 
  end else do
    return --[[ Node ]]{
            --[[ l ]]l,
            --[[ v ]]x,
            --[[ d ]]d,
            --[[ r ]]r,
            --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
          };
  end end  end 
end end

function add_1(x, data, m) do
  if (m) then do
    r = m[--[[ r ]]3];
    d = m[--[[ d ]]2];
    v = m[--[[ v ]]1];
    l = m[--[[ l ]]0];
    c = Caml_primitive.caml_string_compare(x, v);
    if (c == 0) then do
      if (d == data) then do
        return m;
      end else do
        return --[[ Node ]]{
                --[[ l ]]l,
                --[[ v ]]x,
                --[[ d ]]data,
                --[[ r ]]r,
                --[[ h ]]m[--[[ h ]]4]
              };
      end end 
    end else if (c < 0) then do
      ll = add_1(x, data, l);
      if (l == ll) then do
        return m;
      end else do
        return bal(ll, v, d, r);
      end end 
    end else do
      rr = add_1(x, data, r);
      if (r == rr) then do
        return m;
      end else do
        return bal(l, v, d, rr);
      end end 
    end end  end 
  end else do
    return --[[ Node ]]{
            --[[ l : Empty ]]0,
            --[[ v ]]x,
            --[[ d ]]data,
            --[[ r : Empty ]]0,
            --[[ h ]]1
          };
  end end 
end end

function find(x, _param) do
  while(true) do
    param = _param;
    if (param) then do
      c = Caml_primitive.caml_string_compare(x, param[--[[ v ]]1]);
      if (c == 0) then do
        return param[--[[ d ]]2];
      end else do
        _param = c < 0 and param[--[[ l ]]0] or param[--[[ r ]]3];
        ::continue:: ;
      end end 
    end else do
      error(Caml_builtin_exceptions.not_found)
    end end 
  end;
end end

function mem(x, _param) do
  while(true) do
    param = _param;
    if (param) then do
      c = Caml_primitive.caml_string_compare(x, param[--[[ v ]]1]);
      if (c == 0) then do
        return true;
      end else do
        _param = c < 0 and param[--[[ l ]]0] or param[--[[ r ]]3];
        ::continue:: ;
      end end 
    end else do
      return false;
    end end 
  end;
end end

function iter_1(f, _param) do
  while(true) do
    param = _param;
    if (param) then do
      iter_1(f, param[--[[ l ]]0]);
      Curry._2(f, param[--[[ v ]]1], param[--[[ d ]]2]);
      _param = param[--[[ r ]]3];
      ::continue:: ;
    end else do
      return --[[ () ]]0;
    end end 
  end;
end end

function map(f, param) do
  if (param) then do
    l$prime = map(f, param[--[[ l ]]0]);
    d$prime = Curry._1(f, param[--[[ d ]]2]);
    r$prime = map(f, param[--[[ r ]]3]);
    return --[[ Node ]]{
            --[[ l ]]l$prime,
            --[[ v ]]param[--[[ v ]]1],
            --[[ d ]]d$prime,
            --[[ r ]]r$prime,
            --[[ h ]]param[--[[ h ]]4]
          };
  end else do
    return --[[ Empty ]]0;
  end end 
end end

function fold(f, _m, _accu) do
  while(true) do
    accu = _accu;
    m = _m;
    if (m) then do
      _accu = Curry._3(f, m[--[[ v ]]1], m[--[[ d ]]2], fold(f, m[--[[ l ]]0], accu));
      _m = m[--[[ r ]]3];
      ::continue:: ;
    end else do
      return accu;
    end end 
  end;
end end

function single(param) do
  local ___conditional___=(param);
  do
     if ___conditional___ == 0--[[ May_pos ]] then do
        return 1; end end 
     if ___conditional___ == 1--[[ May_neg ]] then do
        return 2; end end 
     if ___conditional___ == 2--[[ May_weak ]] then do
        return 4; end end 
     if ___conditional___ == 3--[[ Inj ]] then do
        return 8; end end 
     if ___conditional___ == 4--[[ Pos ]] then do
        return 16; end end 
     if ___conditional___ == 5--[[ Neg ]] then do
        return 32; end end 
     if ___conditional___ == 6--[[ Inv ]] then do
        return 64; end end 
    
  end
end end

function union(v1, v2) do
  return v1 | v2;
end end

function inter(v1, v2) do
  return v1 & v2;
end end

function subset(v1, v2) do
  return (v1 & v2) == v1;
end end

function set(x, b, v) do
  if (b) then do
    return v | single(x);
  end else do
    return v & (single(x) ^ -1);
  end end 
end end

function mem_1(x) do
  partial_arg = single(x);
  return (function(param) do
      return subset(partial_arg, param);
    end end);
end end

function swap(f1, f2, v) do
  v$prime = set(f1, mem_1(f2)(v), v);
  return set(f2, mem_1(f1)(v), v$prime);
end end

function conjugate(v) do
  return swap(--[[ May_pos ]]0, --[[ May_neg ]]1, swap(--[[ Pos ]]4, --[[ Neg ]]5, v));
end end

function get_upper(v) do
  return --[[ tuple ]]{
          mem_1(--[[ May_pos ]]0)(v),
          mem_1(--[[ May_neg ]]1)(v)
        };
end end

function get_lower(v) do
  return --[[ tuple ]]{
          mem_1(--[[ Pos ]]4)(v),
          mem_1(--[[ Neg ]]5)(v),
          mem_1(--[[ Inv ]]6)(v),
          mem_1(--[[ Inj ]]3)(v)
        };
end end

function height_1(param) do
  if (param) then do
    return param[--[[ h ]]3];
  end else do
    return 0;
  end end 
end end

function create_2(l, v, r) do
  hl = l and l[--[[ h ]]3] or 0;
  hr = r and r[--[[ h ]]3] or 0;
  return --[[ Node ]]{
          --[[ l ]]l,
          --[[ v ]]v,
          --[[ r ]]r,
          --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
        };
end end

function bal_1(l, v, r) do
  hl = l and l[--[[ h ]]3] or 0;
  hr = r and r[--[[ h ]]3] or 0;
  if (hl > (hr + 2 | 0)) then do
    if (l) then do
      lr = l[--[[ r ]]2];
      lv = l[--[[ v ]]1];
      ll = l[--[[ l ]]0];
      if (height_1(ll) >= height_1(lr)) then do
        return create_2(ll, lv, create_2(lr, v, r));
      end else if (lr) then do
        return create_2(create_2(ll, lv, lr[--[[ l ]]0]), lr[--[[ v ]]1], create_2(lr[--[[ r ]]2], v, r));
      end else do
        error({
          Caml_builtin_exceptions.invalid_argument,
          "Set.bal"
        })
      end end  end 
    end else do
      error({
        Caml_builtin_exceptions.invalid_argument,
        "Set.bal"
      })
    end end 
  end else if (hr > (hl + 2 | 0)) then do
    if (r) then do
      rr = r[--[[ r ]]2];
      rv = r[--[[ v ]]1];
      rl = r[--[[ l ]]0];
      if (height_1(rr) >= height_1(rl)) then do
        return create_2(create_2(l, v, rl), rv, rr);
      end else if (rl) then do
        return create_2(create_2(l, v, rl[--[[ l ]]0]), rl[--[[ v ]]1], create_2(rl[--[[ r ]]2], rv, rr));
      end else do
        error({
          Caml_builtin_exceptions.invalid_argument,
          "Set.bal"
        })
      end end  end 
    end else do
      error({
        Caml_builtin_exceptions.invalid_argument,
        "Set.bal"
      })
    end end 
  end else do
    return --[[ Node ]]{
            --[[ l ]]l,
            --[[ v ]]v,
            --[[ r ]]r,
            --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
          };
  end end  end 
end end

function add_2(x, t) do
  if (t) then do
    r = t[--[[ r ]]2];
    v = t[--[[ v ]]1];
    l = t[--[[ l ]]0];
    c = Caml_primitive.caml_string_compare(x, v);
    if (c == 0) then do
      return t;
    end else if (c < 0) then do
      ll = add_2(x, l);
      if (l == ll) then do
        return t;
      end else do
        return bal_1(ll, v, r);
      end end 
    end else do
      rr = add_2(x, r);
      if (r == rr) then do
        return t;
      end else do
        return bal_1(l, v, rr);
      end end 
    end end  end 
  end else do
    return --[[ Node ]]{
            --[[ l : Empty ]]0,
            --[[ v ]]x,
            --[[ r : Empty ]]0,
            --[[ h ]]1
          };
  end end 
end end

function singleton(x) do
  return --[[ Node ]]{
          --[[ l : Empty ]]0,
          --[[ v ]]x,
          --[[ r : Empty ]]0,
          --[[ h ]]1
        };
end end

function add_min_element(x, param) do
  if (param) then do
    return bal_1(add_min_element(x, param[--[[ l ]]0]), param[--[[ v ]]1], param[--[[ r ]]2]);
  end else do
    return singleton(x);
  end end 
end end

function add_max_element(x, param) do
  if (param) then do
    return bal_1(param[--[[ l ]]0], param[--[[ v ]]1], add_max_element(x, param[--[[ r ]]2]));
  end else do
    return singleton(x);
  end end 
end end

function join(l, v, r) do
  if (l) then do
    if (r) then do
      rh = r[--[[ h ]]3];
      lh = l[--[[ h ]]3];
      if (lh > (rh + 2 | 0)) then do
        return bal_1(l[--[[ l ]]0], l[--[[ v ]]1], join(l[--[[ r ]]2], v, r));
      end else if (rh > (lh + 2 | 0)) then do
        return bal_1(join(l, v, r[--[[ l ]]0]), r[--[[ v ]]1], r[--[[ r ]]2]);
      end else do
        return create_2(l, v, r);
      end end  end 
    end else do
      return add_max_element(v, l);
    end end 
  end else do
    return add_min_element(v, r);
  end end 
end end

function min_elt(_param) do
  while(true) do
    param = _param;
    if (param) then do
      l = param[--[[ l ]]0];
      if (l) then do
        _param = l;
        ::continue:: ;
      end else do
        return param[--[[ v ]]1];
      end end 
    end else do
      error(Caml_builtin_exceptions.not_found)
    end end 
  end;
end end

function remove_min_elt(param) do
  if (param) then do
    l = param[--[[ l ]]0];
    if (l) then do
      return bal_1(remove_min_elt(l), param[--[[ v ]]1], param[--[[ r ]]2]);
    end else do
      return param[--[[ r ]]2];
    end end 
  end else do
    error({
      Caml_builtin_exceptions.invalid_argument,
      "Set.remove_min_elt"
    })
  end end 
end end

function concat(t1, t2) do
  if (t1) then do
    if (t2) then do
      return join(t1, min_elt(t2), remove_min_elt(t2));
    end else do
      return t1;
    end end 
  end else do
    return t2;
  end end 
end end

function split(x, param) do
  if (param) then do
    r = param[--[[ r ]]2];
    v = param[--[[ v ]]1];
    l = param[--[[ l ]]0];
    c = Caml_primitive.caml_string_compare(x, v);
    if (c == 0) then do
      return --[[ tuple ]]{
              l,
              true,
              r
            };
    end else if (c < 0) then do
      match = split(x, l);
      return --[[ tuple ]]{
              match[0],
              match[1],
              join(match[2], v, r)
            };
    end else do
      match_1 = split(x, r);
      return --[[ tuple ]]{
              join(l, v, match_1[0]),
              match_1[1],
              match_1[2]
            };
    end end  end 
  end else do
    return --[[ tuple ]]{
            --[[ Empty ]]0,
            false,
            --[[ Empty ]]0
          };
  end end 
end end

function mem_2(x, _param) do
  while(true) do
    param = _param;
    if (param) then do
      c = Caml_primitive.caml_string_compare(x, param[--[[ v ]]1]);
      if (c == 0) then do
        return true;
      end else do
        _param = c < 0 and param[--[[ l ]]0] or param[--[[ r ]]2];
        ::continue:: ;
      end end 
    end else do
      return false;
    end end 
  end;
end end

function union_1(s1, s2) do
  if (s1) then do
    if (s2) then do
      h2 = s2[--[[ h ]]3];
      v2 = s2[--[[ v ]]1];
      h1 = s1[--[[ h ]]3];
      v1 = s1[--[[ v ]]1];
      if (h1 >= h2) then do
        if (h2 == 1) then do
          return add_2(v2, s1);
        end else do
          match = split(v1, s2);
          return join(union_1(s1[--[[ l ]]0], match[0]), v1, union_1(s1[--[[ r ]]2], match[2]));
        end end 
      end else if (h1 == 1) then do
        return add_2(v1, s2);
      end else do
        match_1 = split(v2, s1);
        return join(union_1(match_1[0], s2[--[[ l ]]0]), v2, union_1(match_1[2], s2[--[[ r ]]2]));
      end end  end 
    end else do
      return s1;
    end end 
  end else do
    return s2;
  end end 
end end

function inter_1(s1, s2) do
  if (s1 and s2) then do
    r1 = s1[--[[ r ]]2];
    v1 = s1[--[[ v ]]1];
    l1 = s1[--[[ l ]]0];
    match = split(v1, s2);
    l2 = match[0];
    if (match[1]) then do
      return join(inter_1(l1, l2), v1, inter_1(r1, match[2]));
    end else do
      return concat(inter_1(l1, l2), inter_1(r1, match[2]));
    end end 
  end else do
    return --[[ Empty ]]0;
  end end 
end end

function diff(s1, s2) do
  if (s1) then do
    if (s2) then do
      r1 = s1[--[[ r ]]2];
      v1 = s1[--[[ v ]]1];
      l1 = s1[--[[ l ]]0];
      match = split(v1, s2);
      l2 = match[0];
      if (match[1]) then do
        return concat(diff(l1, l2), diff(r1, match[2]));
      end else do
        return join(diff(l1, l2), v1, diff(r1, match[2]));
      end end 
    end else do
      return s1;
    end end 
  end else do
    return --[[ Empty ]]0;
  end end 
end end

function cons_enum(_s, _e) do
  while(true) do
    e = _e;
    s = _s;
    if (s) then do
      _e = --[[ More ]]{
        s[--[[ v ]]1],
        s[--[[ r ]]2],
        e
      };
      _s = s[--[[ l ]]0];
      ::continue:: ;
    end else do
      return e;
    end end 
  end;
end end

function compare_1(s1, s2) do
  _e1 = cons_enum(s1, --[[ End ]]0);
  _e2 = cons_enum(s2, --[[ End ]]0);
  while(true) do
    e2 = _e2;
    e1 = _e1;
    if (e1) then do
      if (e2) then do
        c = Caml_primitive.caml_string_compare(e1[0], e2[0]);
        if (c ~= 0) then do
          return c;
        end else do
          _e2 = cons_enum(e2[1], e2[2]);
          _e1 = cons_enum(e1[1], e1[2]);
          ::continue:: ;
        end end 
      end else do
        return 1;
      end end 
    end else if (e2) then do
      return -1;
    end else do
      return 0;
    end end  end 
  end;
end end

function equal_2(s1, s2) do
  return compare_1(s1, s2) == 0;
end end

function fold_1(f, _s, _accu) do
  while(true) do
    accu = _accu;
    s = _s;
    if (s) then do
      _accu = Curry._2(f, s[--[[ v ]]1], fold_1(f, s[--[[ l ]]0], accu));
      _s = s[--[[ r ]]2];
      ::continue:: ;
    end else do
      return accu;
    end end 
  end;
end end

function elements_aux(_accu, _param) do
  while(true) do
    param = _param;
    accu = _accu;
    if (param) then do
      _param = param[--[[ l ]]0];
      _accu = --[[ :: ]]{
        param[--[[ v ]]1],
        elements_aux(accu, param[--[[ r ]]2])
      };
      ::continue:: ;
    end else do
      return accu;
    end end 
  end;
end end

function equal_tag(t1, t2) do
  local ___conditional___=(t1.tag | 0);
  do
     if ___conditional___ == 0--[[ Cstr_constant ]] then do
        local ___conditional___=(t2.tag | 0);
        do
           if ___conditional___ == 0--[[ Cstr_constant ]] then do
              return t2[0] == t1[0]; end end 
           if ___conditional___ == 1--[[ Cstr_block ]]
           or ___conditional___ == 2--[[ Cstr_extension ]] then do
              return false; end end 
          
        end end end 
     if ___conditional___ == 1--[[ Cstr_block ]] then do
        local ___conditional___=(t2.tag | 0);
        do
           if ___conditional___ == 1--[[ Cstr_block ]] then do
              return t2[0] == t1[0]; end end 
           if ___conditional___ == 0--[[ Cstr_constant ]]
           or ___conditional___ == 2--[[ Cstr_extension ]] then do
              return false; end end 
          
        end end end 
     if ___conditional___ == 2--[[ Cstr_extension ]] then do
        local ___conditional___=(t2.tag | 0);
        do
           if ___conditional___ == 0--[[ Cstr_constant ]]
           or ___conditional___ == 1--[[ Cstr_block ]] then do
              return false; end end 
           if ___conditional___ == 2--[[ Cstr_extension ]] then do
              if (same(t1[0], t2[0])) then do
                return t1[1] == t2[1];
              end else do
                return false;
              end end  end end 
          
        end end end 
    
  end
end end

Types_TypeOps = do
  compare: compare,
  equal: equal_1,
  hash: hash
end;

Types_Variance = do
  __null: 0,
  full: 127,
  covariant: 25,
  may_inv: 7,
  union: union,
  inter: inter,
  subset: subset,
  set: set,
  mem: mem_1,
  conjugate: conjugate,
  get_upper: get_upper,
  get_lower: get_lower
end;

funarg = Types_TypeOps;

function height_2(param) do
  if (param) then do
    return param[--[[ h ]]3];
  end else do
    return 0;
  end end 
end end

function create_3(l, v, r) do
  hl = l and l[--[[ h ]]3] or 0;
  hr = r and r[--[[ h ]]3] or 0;
  return --[[ Node ]]{
          --[[ l ]]l,
          --[[ v ]]v,
          --[[ r ]]r,
          --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
        };
end end

function bal_2(l, v, r) do
  hl = l and l[--[[ h ]]3] or 0;
  hr = r and r[--[[ h ]]3] or 0;
  if (hl > (hr + 2 | 0)) then do
    if (l) then do
      lr = l[--[[ r ]]2];
      lv = l[--[[ v ]]1];
      ll = l[--[[ l ]]0];
      if (height_2(ll) >= height_2(lr)) then do
        return create_3(ll, lv, create_3(lr, v, r));
      end else if (lr) then do
        return create_3(create_3(ll, lv, lr[--[[ l ]]0]), lr[--[[ v ]]1], create_3(lr[--[[ r ]]2], v, r));
      end else do
        error({
          Caml_builtin_exceptions.invalid_argument,
          "Set.bal"
        })
      end end  end 
    end else do
      error({
        Caml_builtin_exceptions.invalid_argument,
        "Set.bal"
      })
    end end 
  end else if (hr > (hl + 2 | 0)) then do
    if (r) then do
      rr = r[--[[ r ]]2];
      rv = r[--[[ v ]]1];
      rl = r[--[[ l ]]0];
      if (height_2(rr) >= height_2(rl)) then do
        return create_3(create_3(l, v, rl), rv, rr);
      end else if (rl) then do
        return create_3(create_3(l, v, rl[--[[ l ]]0]), rl[--[[ v ]]1], create_3(rl[--[[ r ]]2], rv, rr));
      end else do
        error({
          Caml_builtin_exceptions.invalid_argument,
          "Set.bal"
        })
      end end  end 
    end else do
      error({
        Caml_builtin_exceptions.invalid_argument,
        "Set.bal"
      })
    end end 
  end else do
    return --[[ Node ]]{
            --[[ l ]]l,
            --[[ v ]]v,
            --[[ r ]]r,
            --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
          };
  end end  end 
end end

function add_3(x, t) do
  if (t) then do
    r = t[--[[ r ]]2];
    v = t[--[[ v ]]1];
    l = t[--[[ l ]]0];
    c = Curry._2(funarg.compare, x, v);
    if (c == 0) then do
      return t;
    end else if (c < 0) then do
      ll = add_3(x, l);
      if (l == ll) then do
        return t;
      end else do
        return bal_2(ll, v, r);
      end end 
    end else do
      rr = add_3(x, r);
      if (r == rr) then do
        return t;
      end else do
        return bal_2(l, v, rr);
      end end 
    end end  end 
  end else do
    return --[[ Node ]]{
            --[[ l : Empty ]]0,
            --[[ v ]]x,
            --[[ r : Empty ]]0,
            --[[ h ]]1
          };
  end end 
end end

function singleton_1(x) do
  return --[[ Node ]]{
          --[[ l : Empty ]]0,
          --[[ v ]]x,
          --[[ r : Empty ]]0,
          --[[ h ]]1
        };
end end

function add_min_element_1(x, param) do
  if (param) then do
    return bal_2(add_min_element_1(x, param[--[[ l ]]0]), param[--[[ v ]]1], param[--[[ r ]]2]);
  end else do
    return singleton_1(x);
  end end 
end end

function add_max_element_1(x, param) do
  if (param) then do
    return bal_2(param[--[[ l ]]0], param[--[[ v ]]1], add_max_element_1(x, param[--[[ r ]]2]));
  end else do
    return singleton_1(x);
  end end 
end end

function join_1(l, v, r) do
  if (l) then do
    if (r) then do
      rh = r[--[[ h ]]3];
      lh = l[--[[ h ]]3];
      if (lh > (rh + 2 | 0)) then do
        return bal_2(l[--[[ l ]]0], l[--[[ v ]]1], join_1(l[--[[ r ]]2], v, r));
      end else if (rh > (lh + 2 | 0)) then do
        return bal_2(join_1(l, v, r[--[[ l ]]0]), r[--[[ v ]]1], r[--[[ r ]]2]);
      end else do
        return create_3(l, v, r);
      end end  end 
    end else do
      return add_max_element_1(v, l);
    end end 
  end else do
    return add_min_element_1(v, r);
  end end 
end end

function min_elt_1(_param) do
  while(true) do
    param = _param;
    if (param) then do
      l = param[--[[ l ]]0];
      if (l) then do
        _param = l;
        ::continue:: ;
      end else do
        return param[--[[ v ]]1];
      end end 
    end else do
      error(Caml_builtin_exceptions.not_found)
    end end 
  end;
end end

function remove_min_elt_1(param) do
  if (param) then do
    l = param[--[[ l ]]0];
    if (l) then do
      return bal_2(remove_min_elt_1(l), param[--[[ v ]]1], param[--[[ r ]]2]);
    end else do
      return param[--[[ r ]]2];
    end end 
  end else do
    error({
      Caml_builtin_exceptions.invalid_argument,
      "Set.remove_min_elt"
    })
  end end 
end end

function concat_1(t1, t2) do
  if (t1) then do
    if (t2) then do
      return join_1(t1, min_elt_1(t2), remove_min_elt_1(t2));
    end else do
      return t1;
    end end 
  end else do
    return t2;
  end end 
end end

function split_1(x, param) do
  if (param) then do
    r = param[--[[ r ]]2];
    v = param[--[[ v ]]1];
    l = param[--[[ l ]]0];
    c = Curry._2(funarg.compare, x, v);
    if (c == 0) then do
      return --[[ tuple ]]{
              l,
              true,
              r
            };
    end else if (c < 0) then do
      match = split_1(x, l);
      return --[[ tuple ]]{
              match[0],
              match[1],
              join_1(match[2], v, r)
            };
    end else do
      match_1 = split_1(x, r);
      return --[[ tuple ]]{
              join_1(l, v, match_1[0]),
              match_1[1],
              match_1[2]
            };
    end end  end 
  end else do
    return --[[ tuple ]]{
            --[[ Empty ]]0,
            false,
            --[[ Empty ]]0
          };
  end end 
end end

function mem_3(x, _param) do
  while(true) do
    param = _param;
    if (param) then do
      c = Curry._2(funarg.compare, x, param[--[[ v ]]1]);
      if (c == 0) then do
        return true;
      end else do
        _param = c < 0 and param[--[[ l ]]0] or param[--[[ r ]]2];
        ::continue:: ;
      end end 
    end else do
      return false;
    end end 
  end;
end end

function union_2(s1, s2) do
  if (s1) then do
    if (s2) then do
      h2 = s2[--[[ h ]]3];
      v2 = s2[--[[ v ]]1];
      h1 = s1[--[[ h ]]3];
      v1 = s1[--[[ v ]]1];
      if (h1 >= h2) then do
        if (h2 == 1) then do
          return add_3(v2, s1);
        end else do
          match = split_1(v1, s2);
          return join_1(union_2(s1[--[[ l ]]0], match[0]), v1, union_2(s1[--[[ r ]]2], match[2]));
        end end 
      end else if (h1 == 1) then do
        return add_3(v1, s2);
      end else do
        match_1 = split_1(v2, s1);
        return join_1(union_2(match_1[0], s2[--[[ l ]]0]), v2, union_2(match_1[2], s2[--[[ r ]]2]));
      end end  end 
    end else do
      return s1;
    end end 
  end else do
    return s2;
  end end 
end end

function inter_2(s1, s2) do
  if (s1 and s2) then do
    r1 = s1[--[[ r ]]2];
    v1 = s1[--[[ v ]]1];
    l1 = s1[--[[ l ]]0];
    match = split_1(v1, s2);
    l2 = match[0];
    if (match[1]) then do
      return join_1(inter_2(l1, l2), v1, inter_2(r1, match[2]));
    end else do
      return concat_1(inter_2(l1, l2), inter_2(r1, match[2]));
    end end 
  end else do
    return --[[ Empty ]]0;
  end end 
end end

function diff_1(s1, s2) do
  if (s1) then do
    if (s2) then do
      r1 = s1[--[[ r ]]2];
      v1 = s1[--[[ v ]]1];
      l1 = s1[--[[ l ]]0];
      match = split_1(v1, s2);
      l2 = match[0];
      if (match[1]) then do
        return concat_1(diff_1(l1, l2), diff_1(r1, match[2]));
      end else do
        return join_1(diff_1(l1, l2), v1, diff_1(r1, match[2]));
      end end 
    end else do
      return s1;
    end end 
  end else do
    return --[[ Empty ]]0;
  end end 
end end

function subset_1(_s1, _s2) do
  while(true) do
    s2 = _s2;
    s1 = _s1;
    if (s1) then do
      if (s2) then do
        r2 = s2[--[[ r ]]2];
        l2 = s2[--[[ l ]]0];
        r1 = s1[--[[ r ]]2];
        v1 = s1[--[[ v ]]1];
        l1 = s1[--[[ l ]]0];
        c = Curry._2(funarg.compare, v1, s2[--[[ v ]]1]);
        if (c == 0) then do
          if (subset_1(l1, l2)) then do
            _s2 = r2;
            _s1 = r1;
            ::continue:: ;
          end else do
            return false;
          end end 
        end else if (c < 0) then do
          if (subset_1(--[[ Node ]]{
                  --[[ l ]]l1,
                  --[[ v ]]v1,
                  --[[ r : Empty ]]0,
                  --[[ h ]]0
                }, l2)) then do
            _s1 = r1;
            ::continue:: ;
          end else do
            return false;
          end end 
        end else if (subset_1(--[[ Node ]]{
                --[[ l : Empty ]]0,
                --[[ v ]]v1,
                --[[ r ]]r1,
                --[[ h ]]0
              }, r2)) then do
          _s1 = l1;
          ::continue:: ;
        end else do
          return false;
        end end  end  end 
      end else do
        return false;
      end end 
    end else do
      return true;
    end end 
  end;
end end

function fold_2(f, _s, _accu) do
  while(true) do
    accu = _accu;
    s = _s;
    if (s) then do
      _accu = Curry._2(f, s[--[[ v ]]1], fold_2(f, s[--[[ l ]]0], accu));
      _s = s[--[[ r ]]2];
      ::continue:: ;
    end else do
      return accu;
    end end 
  end;
end end

function exists(p, _param) do
  while(true) do
    param = _param;
    if (param) then do
      if (Curry._1(p, param[--[[ v ]]1]) or exists(p, param[--[[ l ]]0])) then do
        return true;
      end else do
        _param = param[--[[ r ]]2];
        ::continue:: ;
      end end 
    end else do
      return false;
    end end 
  end;
end end

function elements_aux_1(_accu, _param) do
  while(true) do
    param = _param;
    accu = _accu;
    if (param) then do
      _param = param[--[[ l ]]0];
      _accu = --[[ :: ]]{
        param[--[[ v ]]1],
        elements_aux_1(accu, param[--[[ r ]]2])
      };
      ::continue:: ;
    end else do
      return accu;
    end end 
  end;
end end

funarg_1 = Types_TypeOps;

function height_3(param) do
  if (param) then do
    return param[--[[ h ]]4];
  end else do
    return 0;
  end end 
end end

function create_4(l, x, d, r) do
  hl = height_3(l);
  hr = height_3(r);
  return --[[ Node ]]{
          --[[ l ]]l,
          --[[ v ]]x,
          --[[ d ]]d,
          --[[ r ]]r,
          --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
        };
end end

function bal_3(l, x, d, r) do
  hl = l and l[--[[ h ]]4] or 0;
  hr = r and r[--[[ h ]]4] or 0;
  if (hl > (hr + 2 | 0)) then do
    if (l) then do
      lr = l[--[[ r ]]3];
      ld = l[--[[ d ]]2];
      lv = l[--[[ v ]]1];
      ll = l[--[[ l ]]0];
      if (height_3(ll) >= height_3(lr)) then do
        return create_4(ll, lv, ld, create_4(lr, x, d, r));
      end else if (lr) then do
        return create_4(create_4(ll, lv, ld, lr[--[[ l ]]0]), lr[--[[ v ]]1], lr[--[[ d ]]2], create_4(lr[--[[ r ]]3], x, d, r));
      end else do
        error({
          Caml_builtin_exceptions.invalid_argument,
          "Map.bal"
        })
      end end  end 
    end else do
      error({
        Caml_builtin_exceptions.invalid_argument,
        "Map.bal"
      })
    end end 
  end else if (hr > (hl + 2 | 0)) then do
    if (r) then do
      rr = r[--[[ r ]]3];
      rd = r[--[[ d ]]2];
      rv = r[--[[ v ]]1];
      rl = r[--[[ l ]]0];
      if (height_3(rr) >= height_3(rl)) then do
        return create_4(create_4(l, x, d, rl), rv, rd, rr);
      end else if (rl) then do
        return create_4(create_4(l, x, d, rl[--[[ l ]]0]), rl[--[[ v ]]1], rl[--[[ d ]]2], create_4(rl[--[[ r ]]3], rv, rd, rr));
      end else do
        error({
          Caml_builtin_exceptions.invalid_argument,
          "Map.bal"
        })
      end end  end 
    end else do
      error({
        Caml_builtin_exceptions.invalid_argument,
        "Map.bal"
      })
    end end 
  end else do
    return --[[ Node ]]{
            --[[ l ]]l,
            --[[ v ]]x,
            --[[ d ]]d,
            --[[ r ]]r,
            --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
          };
  end end  end 
end end

function add_4(x, data, m) do
  if (m) then do
    r = m[--[[ r ]]3];
    d = m[--[[ d ]]2];
    v = m[--[[ v ]]1];
    l = m[--[[ l ]]0];
    c = Curry._2(funarg_1.compare, x, v);
    if (c == 0) then do
      if (d == data) then do
        return m;
      end else do
        return --[[ Node ]]{
                --[[ l ]]l,
                --[[ v ]]x,
                --[[ d ]]data,
                --[[ r ]]r,
                --[[ h ]]m[--[[ h ]]4]
              };
      end end 
    end else if (c < 0) then do
      ll = add_4(x, data, l);
      if (l == ll) then do
        return m;
      end else do
        return bal_3(ll, v, d, r);
      end end 
    end else do
      rr = add_4(x, data, r);
      if (r == rr) then do
        return m;
      end else do
        return bal_3(l, v, d, rr);
      end end 
    end end  end 
  end else do
    return --[[ Node ]]{
            --[[ l : Empty ]]0,
            --[[ v ]]x,
            --[[ d ]]data,
            --[[ r : Empty ]]0,
            --[[ h ]]1
          };
  end end 
end end

function find_1(x, _param) do
  while(true) do
    param = _param;
    if (param) then do
      c = Curry._2(funarg_1.compare, x, param[--[[ v ]]1]);
      if (c == 0) then do
        return param[--[[ d ]]2];
      end else do
        _param = c < 0 and param[--[[ l ]]0] or param[--[[ r ]]3];
        ::continue:: ;
      end end 
    end else do
      error(Caml_builtin_exceptions.not_found)
    end end 
  end;
end end

function fold_3(f, _m, _accu) do
  while(true) do
    accu = _accu;
    m = _m;
    if (m) then do
      _accu = Curry._3(f, m[--[[ v ]]1], m[--[[ d ]]2], fold_3(f, m[--[[ l ]]0], accu));
      _m = m[--[[ r ]]3];
      ::continue:: ;
    end else do
      return accu;
    end end 
  end;
end end

__let = Types_TypeOps;

TypeHash = Hashtbl.Make(do
      equal: __let.equal,
      hash: __let.hash
    end);

function print_raw(param) do
  error({
    Caml_builtin_exceptions.assert_failure,
    --[[ tuple ]]{
      "btype.ml",
      27,
      16
    }
  })
end end

pivot_level = -1;

new_id = do
  contents: -1
end;

function newty2(level, desc) do
  new_id.contents = new_id.contents + 1 | 0;
  return do
          desc: desc,
          level: level,
          id: new_id.contents
        end;
end end

function is_Tvar(param) do
  match = param.desc;
  if (typeof match == "number" or match.tag) then do
    return false;
  end else do
    return true;
  end end 
end end

function is_Tunivar(param) do
  match = param.desc;
  if (typeof match == "number" or match.tag ~= --[[ Tunivar ]]9) then do
    return false;
  end else do
    return true;
  end end 
end end

dummy_method = "*dummy method*";

function default_mty(param) do
  if (param ~= undefined) then do
    return param;
  end else do
    return --[[ Mty_signature ]]Block.__(1, {--[[ [] ]]0});
  end end 
end end

function field_kind_repr(_kind) do
  while(true) do
    kind = _kind;
    if (typeof kind == "number") then do
      return kind;
    end else do
      match = kind[0].contents;
      if (match ~= undefined) then do
        _kind = match;
        ::continue:: ;
      end else do
        return kind;
      end end 
    end end 
  end;
end end

function repr(_t) do
  while(true) do
    t = _t;
    match = t.desc;
    if (typeof match == "number") then do
      return t;
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 5--[[ Tfield ]] then do
            if (field_kind_repr(match[1]) == --[[ Fabsent ]]1) then do
              _t = match[3];
              ::continue:: ;
            end else do
              return t;
            end end  end end 
         if ___conditional___ == 6--[[ Tlink ]] then do
            _t = match[0];
            ::continue:: ; end end 
        return t;
          
      end
    end end 
  end;
end end

function commu_repr(_c) do
  while(true) do
    c = _c;
    if (typeof c == "number") then do
      return c;
    end else do
      r = c[0];
      if (r.contents ~= --[[ Cunknown ]]1) then do
        _c = r.contents;
        ::continue:: ;
      end else do
        return c;
      end end 
    end end 
  end;
end end

function row_field_repr_aux(_tl, _fi) do
  while(true) do
    fi = _fi;
    tl = _tl;
    if (typeof fi == "number") then do
      return fi;
    end else if (fi.tag) then do
      r = fi[3];
      tl$prime = fi[1];
      match = r.contents;
      if (match ~= undefined) then do
        _fi = match;
        _tl = Pervasives.$at(tl, tl$prime);
        ::continue:: ;
      end else do
        return --[[ Reither ]]Block.__(1, {
                  fi[0],
                  Pervasives.$at(tl, tl$prime),
                  fi[2],
                  r
                });
      end end 
    end else if (fi[0] ~= undefined and tl ~= --[[ [] ]]0) then do
      return --[[ Rpresent ]]Block.__(0, {List.hd(tl)});
    end else do
      return fi;
    end end  end  end 
  end;
end end

function rev_concat(_l, _ll) do
  while(true) do
    ll = _ll;
    l = _l;
    if (ll) then do
      _ll = ll[1];
      _l = Pervasives.$at(ll[0], l);
      ::continue:: ;
    end else do
      return l;
    end end 
  end;
end end

function row_repr_aux(_ll, _row) do
  while(true) do
    row = _row;
    ll = _ll;
    match = repr(row.row_more).desc;
    if (typeof match ~= "number" and match.tag == --[[ Tvariant ]]8) then do
      f = row.row_fields;
      _row = match[0];
      _ll = f == --[[ [] ]]0 and ll or --[[ :: ]]{
          f,
          ll
        };
      ::continue:: ;
    end
     end 
    if (ll == --[[ [] ]]0) then do
      return row;
    end else do
      return do
              row_fields: rev_concat(row.row_fields, ll),
              row_more: row.row_more,
              row_bound: row.row_bound,
              row_closed: row.row_closed,
              row_fixed: row.row_fixed,
              row_name: row.row_name
            end;
    end end 
  end;
end end

function row_field(tag, row) do
  _param = row.row_fields;
  while(true) do
    param = _param;
    if (param) then do
      match = param[0];
      if (tag == match[0]) then do
        return row_field_repr_aux(--[[ [] ]]0, match[1]);
      end else do
        _param = param[1];
        ::continue:: ;
      end end 
    end else do
      match_1 = repr(row.row_more);
      match_2 = match_1.desc;
      if (typeof match_2 == "number" or match_2.tag ~= --[[ Tvariant ]]8) then do
        return --[[ Rabsent ]]0;
      end else do
        return row_field(tag, match_2[0]);
      end end 
    end end 
  end;
end end

function row_more(_row) do
  while(true) do
    row = _row;
    ty = repr(row.row_more);
    match = ty.desc;
    if (typeof match == "number" or match.tag ~= --[[ Tvariant ]]8) then do
      return ty;
    end else do
      _row = match[0];
      ::continue:: ;
    end end 
  end;
end end

function row_fixed(row) do
  row_1 = row_repr_aux(--[[ [] ]]0, row);
  if (row_1.row_fixed) then do
    return true;
  end else do
    match = repr(row_1.row_more).desc;
    if (typeof match == "number") then do
      return false;
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 0--[[ Tvar ]] then do
            return false; end end 
         if ___conditional___ == 3--[[ Tconstr ]]
         or ___conditional___ == 9--[[ Tunivar ]] then do
            return true; end end 
        error({
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "btype.ml",
              137,
              9
            }
          })
          
      end
    end end 
  end end 
end end

function static_row(row) do
  row_1 = row_repr_aux(--[[ [] ]]0, row);
  if (row_1.row_closed) then do
    return List.for_all((function(param) do
                  match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                  if (typeof match == "number" or not match.tag) then do
                    return true;
                  end else do
                    return false;
                  end end 
                end end), row_1.row_fields);
  end else do
    return false;
  end end 
end end

function hash_variant(s) do
  accu = 0;
  for i = 0 , #s - 1 | 0 , 1 do
    accu = Caml_int32.imul(223, accu) + Caml_string.get(s, i) | 0;
  end
  accu = accu & 2147483647;
  if (accu > 1073741823) then do
    return accu - -2147483648 | 0;
  end else do
    return accu;
  end end 
end end

function proxy(ty) do
  ty0 = repr(ty);
  match = ty0.desc;
  if (typeof match == "number") then do
    return ty0;
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 4--[[ Tobject ]] then do
          _ty = match[0];
          while(true) do
            ty_1 = _ty;
            match_1 = ty_1.desc;
            if (typeof match_1 == "number") then do
              return ty0;
            end else do
              local ___conditional___=(match_1.tag | 0);
              do
                 if ___conditional___ == 5--[[ Tfield ]] then do
                    _ty = match_1[3];
                    ::continue:: ; end end 
                 if ___conditional___ == 6--[[ Tlink ]] then do
                    _ty = match_1[0];
                    ::continue:: ; end end 
                 if ___conditional___ == 0--[[ Tvar ]]
                 or ___conditional___ == 3--[[ Tconstr ]]
                 or ___conditional___ == 9--[[ Tunivar ]] then do
                    return ty_1; end end 
                error({
                    Caml_builtin_exceptions.assert_failure,
                    --[[ tuple ]]{
                      "btype.ml",
                      167,
                      15
                    }
                  })
                  
              end
            end end 
          end; end end 
       if ___conditional___ == 8--[[ Tvariant ]] then do
          row = match[0];
          if (static_row(row)) then do
            return ty0;
          end else do
            return row_more(row);
          end end  end end 
      return ty0;
        
    end
  end end 
end end

function has_constr_row(t) do
  match = repr(t).desc;
  if (typeof match == "number") then do
    return false;
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 4--[[ Tobject ]] then do
          _t = match[0];
          while(true) do
            t_1 = _t;
            match_1 = repr(t_1).desc;
            if (typeof match_1 == "number") then do
              return false;
            end else do
              local ___conditional___=(match_1.tag | 0);
              do
                 if ___conditional___ == 3--[[ Tconstr ]] then do
                    return true; end end 
                 if ___conditional___ == 5--[[ Tfield ]] then do
                    _t = match_1[3];
                    ::continue:: ; end end 
                return false;
                  
              end
            end end 
          end; end end 
       if ___conditional___ == 8--[[ Tvariant ]] then do
          match_2 = row_more(match[0]);
          match_3 = match_2.desc;
          if (typeof match_3 == "number" or match_3.tag ~= --[[ Tconstr ]]3) then do
            return false;
          end else do
            return true;
          end end  end end 
      return false;
        
    end
  end end 
end end

function is_row_name(s) do
  l = #s;
  if (l < 4) then do
    return false;
  end else do
    return __String.sub(s, l - 4 | 0, 4) == "#row";
  end end 
end end

function is_constr_row(t) do
  match = t.desc;
  if (typeof match == "number" or match.tag ~= --[[ Tconstr ]]3) then do
    return false;
  end else do
    match_1 = match[0];
    local ___conditional___=(match_1.tag | 0);
    do
       if ___conditional___ == 0--[[ Pident ]] then do
          return is_row_name(match_1[0].name); end end 
       if ___conditional___ == 1--[[ Pdot ]] then do
          return is_row_name(match_1[1]); end end 
       if ___conditional___ == 2--[[ Papply ]] then do
          return false; end end 
      
    end
  end end 
end end

function iter_row(f, _row) do
  while(true) do
    row = _row;
    List.iter((function(param) do
            match = row_field_repr_aux(--[[ [] ]]0, param[1]);
            if (typeof match == "number") then do
              return --[[ () ]]0;
            end else if (match.tag) then do
              return List.iter(f, match[1]);
            end else do
              match_1 = match[0];
              if (match_1 ~= undefined) then do
                return Curry._1(f, match_1);
              end else do
                return --[[ () ]]0;
              end end 
            end end  end 
          end end), row.row_fields);
    match = repr(row.row_more).desc;
    if (typeof match ~= "number") then do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 8--[[ Tvariant ]] then do
            _row = match[0];
            ::continue:: ; end end 
         if ___conditional___ == 0--[[ Tvar ]]
         or ___conditional___ == 3--[[ Tconstr ]]
         or ___conditional___ == 7--[[ Tsubst ]]
         or ___conditional___ == 9--[[ Tunivar ]]
         end
        error({
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "btype.ml",
              214,
              9
            }
          })
          
      end
    end
     end 
    return may((function(param) do
                  return List.iter(f, param[1]);
                end end), row.row_name);
  end;
end end

function iter_type_expr(f, ty) do
  match = ty.desc;
  if (typeof match == "number") then do
    return --[[ () ]]0;
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 1--[[ Tarrow ]] then do
          Curry._1(f, match[1]);
          return Curry._1(f, match[2]); end end 
       if ___conditional___ == 2--[[ Ttuple ]] then do
          return List.iter(f, match[0]); end end 
       if ___conditional___ == 3--[[ Tconstr ]] then do
          return List.iter(f, match[1]); end end 
       if ___conditional___ == 4--[[ Tobject ]] then do
          ty_1 = match[0];
          match_1 = match[1].contents;
          if (match_1 ~= undefined) then do
            Curry._1(f, ty_1);
            return List.iter(f, match_1[1]);
          end else do
            return Curry._1(f, ty_1);
          end end  end end 
       if ___conditional___ == 5--[[ Tfield ]] then do
          Curry._1(f, match[2]);
          return Curry._1(f, match[3]); end end 
       if ___conditional___ == 6--[[ Tlink ]]
       or ___conditional___ == 7--[[ Tsubst ]] then do
          return Curry._1(f, match[0]); end end 
       if ___conditional___ == 8--[[ Tvariant ]] then do
          row = match[0];
          iter_row(f, row);
          return Curry._1(f, row_more(row)); end end 
       if ___conditional___ == 10--[[ Tpoly ]] then do
          Curry._1(f, match[0]);
          return List.iter(f, match[1]); end end 
       if ___conditional___ == 11--[[ Tpackage ]] then do
          return List.iter(f, match[2]); end end 
      return --[[ () ]]0;
        
    end
  end end 
end end

function iter_abbrev(f, _param) do
  while(true) do
    param = _param;
    if (typeof param == "number") then do
      return --[[ () ]]0;
    end else if (param.tag) then do
      _param = param[0].contents;
      ::continue:: ;
    end else do
      Curry._1(f, param[2]);
      Curry._1(f, param[3]);
      _param = param[4];
      ::continue:: ;
    end end  end 
  end;
end end

function it_signature(it) do
  partial_arg = Curry._1(it.it_signature_item, it);
  return (function(param) do
      return List.iter(partial_arg, param);
    end end);
end end

function it_signature_item(it, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Sig_value ]] then do
        return Curry._2(it.it_value_description, it, param[1]); end end 
     if ___conditional___ == 1--[[ Sig_type ]] then do
        return Curry._2(it.it_type_declaration, it, param[1]); end end 
     if ___conditional___ == 2--[[ Sig_typext ]] then do
        return Curry._2(it.it_extension_constructor, it, param[1]); end end 
     if ___conditional___ == 3--[[ Sig_module ]] then do
        return Curry._2(it.it_module_declaration, it, param[1]); end end 
     if ___conditional___ == 4--[[ Sig_modtype ]] then do
        return Curry._2(it.it_modtype_declaration, it, param[1]); end end 
     if ___conditional___ == 5--[[ Sig_class ]] then do
        return Curry._2(it.it_class_declaration, it, param[1]); end end 
     if ___conditional___ == 6--[[ Sig_class_type ]] then do
        return Curry._2(it.it_class_type_declaration, it, param[1]); end end 
    
  end
end end

function it_value_description(it, vd) do
  return Curry._2(it.it_type_expr, it, vd.val_type);
end end

function it_type_declaration(it, td) do
  List.iter(Curry._1(it.it_type_expr, it), td.type_params);
  may(Curry._1(it.it_type_expr, it), td.type_manifest);
  return Curry._2(it.it_type_kind, it, td.type_kind);
end end

function it_extension_constructor(it, td) do
  Curry._1(it.it_path, td.ext_type_path);
  List.iter(Curry._1(it.it_type_expr, it), td.ext_type_params);
  List.iter(Curry._1(it.it_type_expr, it), td.ext_args);
  return may(Curry._1(it.it_type_expr, it), td.ext_ret_type);
end end

function it_module_declaration(it, md) do
  return Curry._2(it.it_module_type, it, md.md_type);
end end

function it_modtype_declaration(it, mtd) do
  return may(Curry._1(it.it_module_type, it), mtd.mtd_type);
end end

function it_class_declaration(it, cd) do
  List.iter(Curry._1(it.it_type_expr, it), cd.cty_params);
  Curry._2(it.it_class_type, it, cd.cty_type);
  may(Curry._1(it.it_type_expr, it), cd.cty_new);
  return Curry._1(it.it_path, cd.cty_path);
end end

function it_class_type_declaration(it, ctd) do
  List.iter(Curry._1(it.it_type_expr, it), ctd.clty_params);
  Curry._2(it.it_class_type, it, ctd.clty_type);
  return Curry._1(it.it_path, ctd.clty_path);
end end

function it_module_type(it, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 1--[[ Mty_signature ]] then do
        return Curry._2(it.it_signature, it, param[0]); end end 
     if ___conditional___ == 2--[[ Mty_functor ]] then do
        may(Curry._1(it.it_module_type, it), param[1]);
        return Curry._2(it.it_module_type, it, param[2]); end end 
     if ___conditional___ == 0--[[ Mty_ident ]]
     or ___conditional___ == 3--[[ Mty_alias ]] then do
        return Curry._1(it.it_path, param[0]); end end 
    
  end
end end

function it_class_type(it, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Cty_constr ]] then do
        Curry._1(it.it_path, param[0]);
        List.iter(Curry._1(it.it_type_expr, it), param[1]);
        return Curry._2(it.it_class_type, it, param[2]); end end 
     if ___conditional___ == 1--[[ Cty_signature ]] then do
        cs = param[0];
        Curry._2(it.it_type_expr, it, cs.csig_self);
        iter_1((function(param, param_1) do
                return Curry._2(it.it_type_expr, it, param_1[2]);
              end end), cs.csig_vars);
        return List.iter((function(param) do
                      Curry._1(it.it_path, param[0]);
                      return List.iter(Curry._1(it.it_type_expr, it), param[1]);
                    end end), cs.csig_inher); end end 
     if ___conditional___ == 2--[[ Cty_arrow ]] then do
        Curry._2(it.it_type_expr, it, param[1]);
        return Curry._2(it.it_class_type, it, param[2]); end end 
    
  end
end end

function it_type_kind(it, param) do
  if (typeof param == "number") then do
    return --[[ () ]]0;
  end else if (param.tag) then do
    return List.iter((function(cd) do
                  List.iter(Curry._1(it.it_type_expr, it), cd.cd_args);
                  return may(Curry._1(it.it_type_expr, it), cd.cd_res);
                end end), param[0]);
  end else do
    return List.iter((function(ld) do
                  return Curry._2(it.it_type_expr, it, ld.ld_type);
                end end), param[0]);
  end end  end 
end end

function it_do_type_expr(it, ty) do
  iter_type_expr(Curry._1(it.it_type_expr, it), ty);
  match = ty.desc;
  if (typeof match == "number") then do
    return --[[ () ]]0;
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 4--[[ Tobject ]] then do
          match_1 = match[1].contents;
          if (match_1 ~= undefined) then do
            return Curry._1(it.it_path, match_1[0]);
          end else do
            return --[[ () ]]0;
          end end  end end 
       if ___conditional___ == 8--[[ Tvariant ]] then do
          return may((function(param) do
                        return Curry._1(it.it_path, param[0]);
                      end end), row_repr_aux(--[[ [] ]]0, match[0]).row_name); end end 
       if ___conditional___ == 3--[[ Tconstr ]]
       or ___conditional___ == 11--[[ Tpackage ]] then do
          return Curry._1(it.it_path, match[0]); end end 
      return --[[ () ]]0;
        
    end
  end end 
end end

function it_path(p) do
  return --[[ () ]]0;
end end

function copy_row(f, fixed, row, keep, more) do
  fields = List.map((function(param) do
          fi = param[1];
          match = row_field_repr_aux(--[[ [] ]]0, fi);
          tmp;
          if (typeof match == "number") then do
            tmp = fi;
          end else if (match.tag) then do
            e = keep and match[3] or (do
                  contents: undefined
                end);
            m = row.row_fixed and fixed or match[2];
            tl = List.map(f, match[1]);
            tmp = --[[ Reither ]]Block.__(1, {
                match[0],
                tl,
                m,
                e
              });
          end else do
            match_1 = match[0];
            tmp = match_1 ~= undefined and --[[ Rpresent ]]Block.__(0, {Curry._1(f, match_1)}) or fi;
          end end  end 
          return --[[ tuple ]]{
                  param[0],
                  tmp
                };
        end end), row.row_fields);
  match = row.row_name;
  name;
  if (match ~= undefined) then do
    match_1 = match;
    name = --[[ tuple ]]{
      match_1[0],
      List.map(f, match_1[1])
    };
  end else do
    name = undefined;
  end end 
  return do
          row_fields: fields,
          row_more: more,
          row_bound: --[[ () ]]0,
          row_closed: row.row_closed,
          row_fixed: row.row_fixed and fixed,
          row_name: name
        end;
end end

function copy_kind(_param) do
  while(true) do
    param = _param;
    if (typeof param == "number") then do
      if (param ~= 0) then do
        error({
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "btype.ml",
            363,
            16
          }
        })
      end else do
        return --[[ Fpresent ]]0;
      end end 
    end else do
      match = param[0].contents;
      if (match ~= undefined) then do
        _param = match;
        ::continue:: ;
      end else do
        return --[[ Fvar ]]{do
                  contents: undefined
                end};
      end end 
    end end 
  end;
end end

function copy_commu(c) do
  if (commu_repr(c) == --[[ Cok ]]0) then do
    return --[[ Cok ]]0;
  end else do
    return --[[ Clink ]]{do
              contents: --[[ Cunknown ]]1
            end};
  end end 
end end

function copy_type_desc(_keep_namesOpt, f, _ty) do
  while(true) do
    keep_namesOpt = _keep_namesOpt;
    ty = _ty;
    keep_names = keep_namesOpt ~= undefined and keep_namesOpt or false;
    if (typeof ty == "number") then do
      return --[[ Tnil ]]0;
    end else do
      local ___conditional___=(ty.tag | 0);
      do
         if ___conditional___ == 0--[[ Tvar ]] then do
            if (keep_names) then do
              return ty;
            end else do
              return --[[ Tvar ]]Block.__(0, {undefined});
            end end  end end 
         if ___conditional___ == 1--[[ Tarrow ]] then do
            return --[[ Tarrow ]]Block.__(1, {
                      ty[0],
                      Curry._1(f, ty[1]),
                      Curry._1(f, ty[2]),
                      copy_commu(ty[3])
                    }); end end 
         if ___conditional___ == 2--[[ Ttuple ]] then do
            return --[[ Ttuple ]]Block.__(2, {List.map(f, ty[0])}); end end 
         if ___conditional___ == 3--[[ Tconstr ]] then do
            return --[[ Tconstr ]]Block.__(3, {
                      ty[0],
                      List.map(f, ty[1]),
                      do
                        contents: --[[ Mnil ]]0
                      end
                    }); end end 
         if ___conditional___ == 4--[[ Tobject ]] then do
            ty_1 = ty[0];
            match = ty[1].contents;
            if (match ~= undefined) then do
              match_1 = match;
              return --[[ Tobject ]]Block.__(4, {
                        Curry._1(f, ty_1),
                        do
                          contents: --[[ tuple ]]{
                            match_1[0],
                            List.map(f, match_1[1])
                          }
                        end
                      });
            end else do
              return --[[ Tobject ]]Block.__(4, {
                        Curry._1(f, ty_1),
                        do
                          contents: undefined
                        end
                      });
            end end  end end 
         if ___conditional___ == 5--[[ Tfield ]] then do
            return --[[ Tfield ]]Block.__(5, {
                      ty[0],
                      field_kind_repr(ty[1]),
                      Curry._1(f, ty[2]),
                      Curry._1(f, ty[3])
                    }); end end 
         if ___conditional___ == 6--[[ Tlink ]] then do
            _ty = ty[0].desc;
            _keep_namesOpt = undefined;
            ::continue:: ; end end 
         if ___conditional___ == 7--[[ Tsubst ]] then do
            error({
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "btype.ml",
                390,
                27
              }
            }) end end 
         if ___conditional___ == 8--[[ Tvariant ]] then do
            error({
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "btype.ml",
                385,
                27
              }
            }) end end 
         if ___conditional___ == 9--[[ Tunivar ]] then do
            return ty; end end 
         if ___conditional___ == 10--[[ Tpoly ]] then do
            tyl = List.map((function(x) do
                    _ty = Curry._1(f, x);
                    while(true) do
                      ty = _ty;
                      match = ty.desc;
                      if (typeof match ~= "number") then do
                        local ___conditional___=(match.tag | 0);
                        do
                           if ___conditional___ == 2--[[ Ttuple ]] then do
                              match_1 = match[0];
                              if (match_1) then do
                                _ty = match_1[0];
                                ::continue:: ;
                              end
                               end  end else 
                           if ___conditional___ == 6--[[ Tlink ]] then do
                              _ty = match[0];
                              ::continue:: ; end end end end 
                           if ___conditional___ == 7--[[ Tsubst ]]
                           or ___conditional___ == 9--[[ Tunivar ]] then do
                              return ty; end end 
                          
                        end
                      end
                       end 
                      error({
                        Caml_builtin_exceptions.assert_failure,
                        --[[ tuple ]]{
                          "btype.ml",
                          375,
                          26
                        }
                      })
                    end;
                  end end), ty[1]);
            return --[[ Tpoly ]]Block.__(10, {
                      Curry._1(f, ty[0]),
                      tyl
                    }); end end 
         if ___conditional___ == 11--[[ Tpackage ]] then do
            return --[[ Tpackage ]]Block.__(11, {
                      ty[0],
                      ty[1],
                      List.map(f, ty[2])
                    }); end end 
        
      end
    end end 
  end;
end end

saved_desc = do
  contents: --[[ [] ]]0
end;

function save_desc(ty, desc) do
  saved_desc.contents = --[[ :: ]]{
    --[[ tuple ]]{
      ty,
      desc
    },
    saved_desc.contents
  };
  return --[[ () ]]0;
end end

saved_kinds = do
  contents: --[[ [] ]]0
end;

new_kinds = do
  contents: --[[ [] ]]0
end;

function dup_kind(r) do
  match = r.contents;
  if (match ~= undefined) then do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "btype.ml",
        408,
        40
      }
    })
  end
   end 
  if (List.memq(r, new_kinds.contents)) then do
    return 0;
  end else do
    saved_kinds.contents = --[[ :: ]]{
      r,
      saved_kinds.contents
    };
    r$prime = do
      contents: undefined
    end;
    new_kinds.contents = --[[ :: ]]{
      r$prime,
      new_kinds.contents
    };
    r.contents = --[[ Fvar ]]{r$prime};
    return --[[ () ]]0;
  end end 
end end

function cleanup_types(param) do
  List.iter((function(param) do
          param[0].desc = param[1];
          return --[[ () ]]0;
        end end), saved_desc.contents);
  List.iter((function(r) do
          r.contents = undefined;
          return --[[ () ]]0;
        end end), saved_kinds.contents);
  saved_desc.contents = --[[ [] ]]0;
  saved_kinds.contents = --[[ [] ]]0;
  new_kinds.contents = --[[ [] ]]0;
  return --[[ () ]]0;
end end

function mark_type(ty) do
  ty_1 = repr(ty);
  if (ty_1.level >= 0) then do
    ty_1.level = pivot_level - ty_1.level | 0;
    return iter_type_expr(mark_type, ty_1);
  end else do
    return 0;
  end end 
end end

function mark_type_node(ty) do
  ty_1 = repr(ty);
  if (ty_1.level >= 0) then do
    ty_1.level = pivot_level - ty_1.level | 0;
    return --[[ () ]]0;
  end else do
    return 0;
  end end 
end end

function it_type_expr(it, ty) do
  ty_1 = repr(ty);
  if (ty_1.level >= 0) then do
    mark_type_node(ty_1);
    return Curry._2(it.it_do_type_expr, it, ty_1);
  end else do
    return 0;
  end end 
end end

function unmark_type(ty) do
  ty_1 = repr(ty);
  if (ty_1.level < 0) then do
    ty_1.level = pivot_level - ty_1.level | 0;
    return iter_type_expr(unmark_type, ty_1);
  end else do
    return 0;
  end end 
end end

function it_type_expr_1(it, ty) do
  return unmark_type(ty);
end end

unmark_iterators = do
  it_signature: it_signature,
  it_signature_item: it_signature_item,
  it_value_description: it_value_description,
  it_type_declaration: it_type_declaration,
  it_extension_constructor: it_extension_constructor,
  it_module_declaration: it_module_declaration,
  it_modtype_declaration: it_modtype_declaration,
  it_class_declaration: it_class_declaration,
  it_class_type_declaration: it_class_type_declaration,
  it_module_type: it_module_type,
  it_class_type: it_class_type,
  it_type_kind: it_type_kind,
  it_do_type_expr: it_do_type_expr,
  it_type_expr: it_type_expr_1,
  it_path: it_path
end;

function unmark_extension_constructor(ext) do
  List.iter(unmark_type, ext.ext_type_params);
  List.iter(unmark_type, ext.ext_args);
  return may(unmark_type, ext.ext_ret_type);
end end

function unmark_class_signature(sign) do
  unmark_type(sign.csig_self);
  return iter_1((function(l, param) do
                return unmark_type(param[2]);
              end end), sign.csig_vars);
end end

function find_expans(priv, p1, _param) do
  while(true) do
    param = _param;
    if (typeof param == "number") then do
      return ;
    end else if (param.tag) then do
      rem = param[0].contents;
      _param = rem;
      ::continue:: ;
    end else if (param[0] >= priv and same(p1, param[1])) then do
      return param[3];
    end else do
      _param = param[4];
      ::continue:: ;
    end end  end  end 
  end;
end end

memo = do
  contents: --[[ [] ]]0
end;

function cleanup_abbrev(param) do
  List.iter((function(abbr) do
          abbr.contents = --[[ Mnil ]]0;
          return --[[ () ]]0;
        end end), memo.contents);
  memo.contents = --[[ [] ]]0;
  return --[[ () ]]0;
end end

function memorize_abbrev(mem, priv, path, v, v$prime) do
  mem.contents = --[[ Mcons ]]Block.__(0, {
      priv,
      path,
      v,
      v$prime,
      mem.contents
    });
  memo.contents = --[[ :: ]]{
    mem,
    memo.contents
  };
  return --[[ () ]]0;
end end

function forget_abbrev_rec(mem, path) do
  if (typeof mem == "number") then do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "btype.ml",
        520,
        6
      }
    })
  end else if (mem.tag) then do
    mem$prime = mem[0];
    mem$prime.contents = forget_abbrev_rec(mem$prime.contents, path);
    error(Pervasives.Exit)
  end else do
    rem = mem[4];
    path$prime = mem[1];
    if (same(path, path$prime)) then do
      return rem;
    end else do
      return --[[ Mcons ]]Block.__(0, {
                mem[0],
                path$prime,
                mem[2],
                mem[3],
                forget_abbrev_rec(rem, path)
              });
    end end 
  end end  end 
end end

function forget_abbrev(mem, path) do
  xpcall(function() do
    mem.contents = forget_abbrev_rec(mem.contents, path);
    return --[[ () ]]0;
  end end,function(exn) do
    if (exn == Pervasives.Exit) then do
      return --[[ () ]]0;
    end else do
      error(exn)
    end end 
  end end)
end end

function is_optional(l) do
  if (#l ~= 0) then do
    return Caml_string.get(l, 0) == --[[ "?" ]]63;
  end else do
    return false;
  end end 
end end

function label_name(l) do
  if (is_optional(l)) then do
    return __String.sub(l, 1, #l - 1 | 0);
  end else do
    return l;
  end end 
end end

function prefixed_label_name(l) do
  if (is_optional(l)) then do
    return l;
  end else do
    return "~" .. l;
  end end 
end end

function extract_label_aux(_hd, l, _param) do
  while(true) do
    param = _param;
    hd = _hd;
    if (param) then do
      ls = param[1];
      p = param[0];
      l$prime = p[0];
      if (label_name(l$prime) == l) then do
        return --[[ tuple ]]{
                l$prime,
                p[1],
                List.rev(hd),
                ls
              };
      end else do
        _param = ls;
        _hd = --[[ :: ]]{
          p,
          hd
        };
        ::continue:: ;
      end end 
    end else do
      error(Caml_builtin_exceptions.not_found)
    end end 
  end;
end end

function undo_change(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Ctype ]] then do
        param[0].desc = param[1];
        return --[[ () ]]0; end end 
     if ___conditional___ == 1--[[ Clevel ]] then do
        param[0].level = param[1];
        return --[[ () ]]0; end end 
    param[0].contents = param[1];
      return --[[ () ]]0;
      
  end
end end

trail = Caml_weak.caml_weak_create(1);

last_snapshot = do
  contents: 0
end;

function log_change(ch) do
  match = Caml_weak.caml_weak_get(trail, 0);
  if (match ~= undefined) then do
    r$prime = do
      contents: --[[ Unchanged ]]0
    end;
    match.contents = --[[ Change ]]{
      ch,
      r$prime
    };
    return Caml_weak.caml_weak_set(trail, 0, r$prime);
  end else do
    return --[[ () ]]0;
  end end 
end end

function log_type(ty) do
  if (ty.id <= last_snapshot.contents) then do
    return log_change(--[[ Ctype ]]Block.__(0, {
                  ty,
                  ty.desc
                }));
  end else do
    return 0;
  end end 
end end

function link_type(ty, ty$prime) do
  log_type(ty);
  desc = ty.desc;
  ty.desc = --[[ Tlink ]]Block.__(6, {ty$prime});
  match = ty$prime.desc;
  if (typeof desc == "number" or desc.tag or typeof match == "number" or match.tag) then do
    return --[[ () ]]0;
  end else do
    name = desc[0];
    if (name ~= undefined and not (match[0] ~= undefined and ty.level >= ty$prime.level)) then do
      log_type(ty$prime);
      ty$prime.desc = --[[ Tvar ]]Block.__(0, {name});
      return --[[ () ]]0;
    end else do
      return --[[ () ]]0;
    end end 
  end end 
end end

function set_level(ty, level) do
  if (ty.id <= last_snapshot.contents) then do
    log_change(--[[ Clevel ]]Block.__(1, {
            ty,
            ty.level
          }));
  end
   end 
  ty.level = level;
  return --[[ () ]]0;
end end

function set_univar(rty, ty) do
  log_change(--[[ Cuniv ]]Block.__(6, {
          rty,
          rty.contents
        }));
  rty.contents = ty;
  return --[[ () ]]0;
end end

function set_name(nm, v) do
  log_change(--[[ Cname ]]Block.__(2, {
          nm,
          nm.contents
        }));
  nm.contents = v;
  return --[[ () ]]0;
end end

function set_row_field(e, v) do
  log_change(--[[ Crow ]]Block.__(3, {
          e,
          e.contents
        }));
  e.contents = v;
  return --[[ () ]]0;
end end

function set_kind(rk, k) do
  log_change(--[[ Ckind ]]Block.__(4, {
          rk,
          rk.contents
        }));
  rk.contents = k;
  return --[[ () ]]0;
end end

function set_commu(rc, c) do
  log_change(--[[ Ccommu ]]Block.__(5, {
          rc,
          rc.contents
        }));
  rc.contents = c;
  return --[[ () ]]0;
end end

function set_typeset(rs, s) do
  log_change(--[[ Ctypeset ]]Block.__(7, {
          rs,
          rs.contents
        }));
  rs.contents = s;
  return --[[ () ]]0;
end end

function snapshot(param) do
  old = last_snapshot.contents;
  last_snapshot.contents = new_id.contents;
  match = Caml_weak.caml_weak_get(trail, 0);
  if (match ~= undefined) then do
    return --[[ tuple ]]{
            match,
            old
          };
  end else do
    r = do
      contents: --[[ Unchanged ]]0
    end;
    Caml_weak.caml_weak_set(trail, 0, r);
    return --[[ tuple ]]{
            r,
            old
          };
  end end 
end end

function rev_log(_accu, _param) do
  while(true) do
    param = _param;
    accu = _accu;
    if (typeof param == "number") then do
      if (param ~= 0) then do
        error({
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "btype.ml",
            656,
            15
          }
        })
      end
       end 
      return accu;
    end else do
      next = param[1];
      d = next.contents;
      next.contents = --[[ Invalid ]]1;
      _param = d;
      _accu = --[[ :: ]]{
        param[0],
        accu
      };
      ::continue:: ;
    end end 
  end;
end end

function backtrack(param) do
  old = param[1];
  changes = param[0];
  change = changes.contents;
  if (typeof change == "number") then do
    if (change ~= 0) then do
      error({
        Caml_builtin_exceptions.failure,
        "Btype.backtrack"
      })
    end
     end 
    last_snapshot.contents = old;
    return --[[ () ]]0;
  end else do
    cleanup_abbrev(--[[ () ]]0);
    backlog = rev_log(--[[ [] ]]0, change);
    List.iter(undo_change, backlog);
    changes.contents = --[[ Unchanged ]]0;
    last_snapshot.contents = old;
    return Caml_weak.caml_weak_set(trail, 0, changes);
  end end 
end end

__Error_1 = Caml_exceptions.create("Ocaml_typedtree_test.Cmi_format.Error");

function input_cmi(ic) do
  match = Caml_external_polyfill.resolve("caml_input_value")(ic);
  crcs = Caml_external_polyfill.resolve("caml_input_value")(ic);
  flags = Caml_external_polyfill.resolve("caml_input_value")(ic);
  return do
          cmi_name: match[0],
          cmi_sign: match[1],
          cmi_crcs: crcs,
          cmi_flags: flags
        end;
end end

function read_cmi(filename) do
  ic = Pervasives.open_in_bin(filename);
  xpcall(function() do
    buffer = Pervasives.really_input_string(ic, #cmi_magic_number);
    if (buffer ~= cmi_magic_number) then do
      Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
      pre_len = #cmi_magic_number - 3 | 0;
      if (__String.sub(buffer, 0, pre_len) == __String.sub(cmi_magic_number, 0, pre_len)) then do
        msg = buffer < cmi_magic_number and "an older" or "a newer";
        error({
          __Error_1,
          --[[ Wrong_version_interface ]]Block.__(1, {
              filename,
              msg
            })
        })
      end else do
        error({
          __Error_1,
          --[[ Not_an_interface ]]Block.__(0, {filename})
        })
      end end 
    end
     end 
    cmi = input_cmi(ic);
    Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
    return cmi;
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn == Caml_builtin_exceptions.end_of_file) then do
      Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
      error({
        __Error_1,
        --[[ Corrupted_interface ]]Block.__(2, {filename})
      })
    end else if (exn[0] == Caml_builtin_exceptions.failure) then do
      Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
      error({
        __Error_1,
        --[[ Corrupted_interface ]]Block.__(2, {filename})
      })
    end else if (exn[0] == __Error_1) then do
      Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
      error({
        __Error_1,
        exn[1]
      })
    end else do
      error(exn)
    end end  end  end 
  end end)
end end

function output_cmi(filename, oc, cmi) do
  Pervasives.output_string(oc, cmi_magic_number);
  Caml_external_polyfill.resolve("caml_output_value")(oc, --[[ tuple ]]{
        cmi.cmi_name,
        cmi.cmi_sign
      }, --[[ [] ]]0);
  Caml_io.caml_ml_flush(oc);
  crc = Digest.file(filename);
  crcs_000 = --[[ tuple ]]{
    cmi.cmi_name,
    crc
  };
  crcs_001 = cmi.cmi_crcs;
  crcs = --[[ :: ]]{
    crcs_000,
    crcs_001
  };
  Caml_external_polyfill.resolve("caml_output_value")(oc, crcs, --[[ [] ]]0);
  Caml_external_polyfill.resolve("caml_output_value")(oc, cmi.cmi_flags, --[[ [] ]]0);
  return crc;
end end

function report_error(ppf, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Not_an_interface ]] then do
        return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@ ",
                                    1,
                                    0
                                  }),
                                --[[ String_literal ]]Block.__(11, {
                                    "is not a compiled interface",
                                    --[[ End_of_format ]]0
                                  })
                              })}),
                        "%a@ is not a compiled interface"
                      }), print_filename, param[0]); end end 
     if ___conditional___ == 1--[[ Wrong_version_interface ]] then do
        return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@ ",
                                    1,
                                    0
                                  }),
                                --[[ String_literal ]]Block.__(11, {
                                    "is not a compiled interface for this version of OCaml.",
                                    --[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Flush_newline ]]4,
                                        --[[ String_literal ]]Block.__(11, {
                                            "It seems to be for ",
                                            --[[ String ]]Block.__(2, {
                                                --[[ No_padding ]]0,
                                                --[[ String_literal ]]Block.__(11, {
                                                    " version of OCaml.",
                                                    --[[ End_of_format ]]0
                                                  })
                                              })
                                          })
                                      })
                                  })
                              })}),
                        "%a@ is not a compiled interface for this version of OCaml.@.It seems to be for %s version of OCaml."
                      }), print_filename, param[0], param[1]); end end 
     if ___conditional___ == 2--[[ Corrupted_interface ]] then do
        return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ String_literal ]]Block.__(11, {
                            "Corrupted compiled interface",
                            --[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@ ",
                                    1,
                                    0
                                  }),
                                --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                              })
                          }),
                        "Corrupted compiled interface@ %a"
                      }), print_filename, param[0]); end end 
    
  end
end end

register_error_of_exn((function(param) do
        if (param[0] == __Error_1) then do
          return error_of_printer_file(report_error, param[1]);
        end
         end 
      end end));

Inconsistency = Caml_exceptions.create("Ocaml_typedtree_test.Consistbl.Inconsistency");

function set_1(tbl, name, crc, source) do
  return Hashtbl.add(tbl, name, --[[ tuple ]]{
              crc,
              source
            });
end end

function extract(l, tbl) do
  l_1 = List.sort_uniq(__String.compare, l);
  return List.fold_left((function(assc, name) do
                xpcall(function() do
                  match = Hashtbl.find(tbl, name);
                  return --[[ :: ]]{
                          --[[ tuple ]]{
                            name,
                            Caml_option.some(match[0])
                          },
                          assc
                        };
                end end,function(exn) do
                  if (exn == Caml_builtin_exceptions.not_found) then do
                    return --[[ :: ]]{
                            --[[ tuple ]]{
                              name,
                              undefined
                            },
                            assc
                          };
                  end else do
                    error(exn)
                  end end 
                end end)
              end end), --[[ [] ]]0, l_1);
end end

function free_vars(ty) do
  ret = do
    contents: --[[ Empty ]]0
  end;
  loop = function(_ty) do
    while(true) do
      ty = _ty;
      ty_1 = repr(ty);
      if (ty_1.level >= 0) then do
        ty_1.level = pivot_level - ty_1.level | 0;
        match = ty_1.desc;
        if (typeof match == "number") then do
          return iter_type_expr(loop, ty_1);
        end else do
          local ___conditional___=(match.tag | 0);
          do
             if ___conditional___ == 0--[[ Tvar ]] then do
                ret.contents = add_3(ty_1, ret.contents);
                return --[[ () ]]0; end end 
             if ___conditional___ == 8--[[ Tvariant ]] then do
                row = row_repr_aux(--[[ [] ]]0, match[0]);
                iter_row(loop, row);
                if (static_row(row)) then do
                  return 0;
                end else do
                  _ty = row.row_more;
                  ::continue:: ;
                end end  end end 
            return iter_type_expr(loop, ty_1);
              
          end
        end end 
      end else do
        return 0;
      end end 
    end;
  end end;
  loop(ty);
  unmark_type(ty);
  return ret.contents;
end end

optional_shape_000 = do
  txt: "internal.optional",
  loc: none
end;

optional_shape_001 = --[[ PStr ]]Block.__(0, {--[[ [] ]]0});

optional_shape = --[[ tuple ]]{
  optional_shape_000,
  optional_shape_001
};

function extension_descr(path_ext, ext) do
  match = ext.ext_ret_type;
  ty_res = match ~= undefined and match or newty2(100000000, --[[ Tconstr ]]Block.__(3, {
            ext.ext_type_path,
            ext.ext_type_params,
            do
              contents: --[[ Mnil ]]0
            end
          }));
  tag_001 = ext.ext_args == --[[ [] ]]0;
  tag = --[[ Cstr_extension ]]Block.__(2, {
      path_ext,
      tag_001
    });
  match_1 = ext.ext_ret_type;
  existentials;
  if (match_1 ~= undefined) then do
    ret_vars = free_vars(match_1);
    arg_vars = free_vars(newty2(100000000, --[[ Ttuple ]]Block.__(2, {ext.ext_args})));
    existentials = elements_aux_1(--[[ [] ]]0, diff_1(arg_vars, ret_vars));
  end else do
    existentials = --[[ [] ]]0;
  end end 
  return do
          cstr_name: last(path_ext),
          cstr_res: ty_res,
          cstr_existentials: existentials,
          cstr_args: ext.ext_args,
          cstr_arity: List.length(ext.ext_args),
          cstr_tag: tag,
          cstr_consts: -1,
          cstr_nonconsts: -1,
          cstr_normal: -1,
          cstr_generalized: ext.ext_ret_type ~= undefined,
          cstr_private: ext.ext_private,
          cstr_loc: ext.ext_loc,
          cstr_attributes: ext.ext_attributes
        end;
end end

none_1 = do
  desc: --[[ Ttuple ]]Block.__(2, {--[[ [] ]]0}),
  level: -1,
  id: -1
end;

dummy_label_lbl_all = {};

dummy_label = do
  lbl_name: "",
  lbl_res: none_1,
  lbl_arg: none_1,
  lbl_mut: --[[ Immutable ]]0,
  lbl_pos: -1,
  lbl_all: dummy_label_lbl_all,
  lbl_repres: --[[ Record_regular ]]0,
  lbl_private: --[[ Public ]]1,
  lbl_loc: none,
  lbl_attributes: --[[ [] ]]0
end;

builtin_idents = do
  contents: --[[ [] ]]0
end;

function wrap(create, s) do
  id = Curry._1(create, s);
  builtin_idents.contents = --[[ :: ]]{
    --[[ tuple ]]{
      s,
      id
    },
    builtin_idents.contents
  };
  return id;
end end

ident_int = wrap(create, "int");

ident_char = wrap(create, "char");

ident_string = wrap(create, "string");

ident_float = wrap(create, "float");

ident_bool = wrap(create, "bool");

ident_unit = wrap(create, "unit");

ident_exn = wrap(create, "exn");

ident_array = wrap(create, "array");

ident_list = wrap(create, "list");

ident_option = wrap(create, "option");

ident_nativeint = wrap(create, "nativeint");

ident_int32 = wrap(create, "int32");

ident_int64 = wrap(create, "int64");

ident_lazy_t = wrap(create, "lazy_t");

ident_bytes = wrap(create, "bytes");

path_int = --[[ Pident ]]Block.__(0, {ident_int});

path_char = --[[ Pident ]]Block.__(0, {ident_char});

path_string = --[[ Pident ]]Block.__(0, {ident_string});

path_float = --[[ Pident ]]Block.__(0, {ident_float});

path_bool = --[[ Pident ]]Block.__(0, {ident_bool});

path_unit = --[[ Pident ]]Block.__(0, {ident_unit});

path_exn = --[[ Pident ]]Block.__(0, {ident_exn});

path_array = --[[ Pident ]]Block.__(0, {ident_array});

path_list = --[[ Pident ]]Block.__(0, {ident_list});

path_option = --[[ Pident ]]Block.__(0, {ident_option});

path_nativeint = --[[ Pident ]]Block.__(0, {ident_nativeint});

path_int32 = --[[ Pident ]]Block.__(0, {ident_int32});

path_int64 = --[[ Pident ]]Block.__(0, {ident_int64});

path_lazy_t = --[[ Pident ]]Block.__(0, {ident_lazy_t});

path_bytes = --[[ Pident ]]Block.__(0, {ident_bytes});

type_int = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
        path_int,
        --[[ [] ]]0,
        do
          contents: --[[ Mnil ]]0
        end
      }));

type_char = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
        path_char,
        --[[ [] ]]0,
        do
          contents: --[[ Mnil ]]0
        end
      }));

type_string = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
        path_string,
        --[[ [] ]]0,
        do
          contents: --[[ Mnil ]]0
        end
      }));

type_float = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
        path_float,
        --[[ [] ]]0,
        do
          contents: --[[ Mnil ]]0
        end
      }));

type_bool = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
        path_bool,
        --[[ [] ]]0,
        do
          contents: --[[ Mnil ]]0
        end
      }));

type_unit = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
        path_unit,
        --[[ [] ]]0,
        do
          contents: --[[ Mnil ]]0
        end
      }));

type_exn = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
        path_exn,
        --[[ [] ]]0,
        do
          contents: --[[ Mnil ]]0
        end
      }));

function type_array(t) do
  return newty2(100000000, --[[ Tconstr ]]Block.__(3, {
                path_array,
                --[[ :: ]]{
                  t,
                  --[[ [] ]]0
                },
                do
                  contents: --[[ Mnil ]]0
                end
              }));
end end

function type_list(t) do
  return newty2(100000000, --[[ Tconstr ]]Block.__(3, {
                path_list,
                --[[ :: ]]{
                  t,
                  --[[ [] ]]0
                },
                do
                  contents: --[[ Mnil ]]0
                end
              }));
end end

function type_option(t) do
  return newty2(100000000, --[[ Tconstr ]]Block.__(3, {
                path_option,
                --[[ :: ]]{
                  t,
                  --[[ [] ]]0
                },
                do
                  contents: --[[ Mnil ]]0
                end
              }));
end end

type_nativeint = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
        path_nativeint,
        --[[ [] ]]0,
        do
          contents: --[[ Mnil ]]0
        end
      }));

type_int32 = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
        path_int32,
        --[[ [] ]]0,
        do
          contents: --[[ Mnil ]]0
        end
      }));

type_int64 = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
        path_int64,
        --[[ [] ]]0,
        do
          contents: --[[ Mnil ]]0
        end
      }));

function type_lazy_t(t) do
  return newty2(100000000, --[[ Tconstr ]]Block.__(3, {
                path_lazy_t,
                --[[ :: ]]{
                  t,
                  --[[ [] ]]0
                },
                do
                  contents: --[[ Mnil ]]0
                end
              }));
end end

newty2(100000000, --[[ Tconstr ]]Block.__(3, {
        path_bytes,
        --[[ [] ]]0,
        do
          contents: --[[ Mnil ]]0
        end
      }));

ident_match_failure = wrap(create_predef_exn, "Match_failure");

ident_out_of_memory = wrap(create_predef_exn, "Out_of_memory");

ident_invalid_argument = wrap(create_predef_exn, "Invalid_argument");

ident_failure = wrap(create_predef_exn, "Failure");

ident_not_found = wrap(create_predef_exn, "Not_found");

ident_sys_error = wrap(create_predef_exn, "Sys_error");

ident_end_of_file = wrap(create_predef_exn, "End_of_file");

ident_division_by_zero = wrap(create_predef_exn, "Division_by_zero");

ident_stack_overflow = wrap(create_predef_exn, "Stack_overflow");

ident_sys_blocked_io = wrap(create_predef_exn, "Sys_blocked_io");

ident_assert_failure = wrap(create_predef_exn, "Assert_failure");

ident_undefined_recursive_module = wrap(create_predef_exn, "Undefined_recursive_module");

decl_abstr = do
  type_params: --[[ [] ]]0,
  type_arity: 0,
  type_kind: --[[ Type_abstract ]]0,
  type_private: --[[ Public ]]1,
  type_manifest: undefined,
  type_variance: --[[ [] ]]0,
  type_newtype_level: undefined,
  type_loc: none,
  type_attributes: --[[ [] ]]0
end;

function cstr(id, args) do
  return do
          cd_id: id,
          cd_args: args,
          cd_res: undefined,
          cd_loc: none,
          cd_attributes: --[[ [] ]]0
        end;
end end

ident_false = wrap(create, "false");

ident_true = wrap(create, "true");

ident_void = wrap(create, "()");

ident_nil = wrap(create, "[]");

ident_cons = wrap(create, "::");

ident_none = wrap(create, "None");

ident_some = wrap(create, "Some");

function common_initial_env(add_type, add_extension, empty_env) do
  decl_bool_type_kind = --[[ Type_variant ]]Block.__(1, {--[[ :: ]]{
        cstr(ident_false, --[[ [] ]]0),
        --[[ :: ]]{
          cstr(ident_true, --[[ [] ]]0),
          --[[ [] ]]0
        }
      }});
  decl_bool = do
    type_params: --[[ [] ]]0,
    type_arity: 0,
    type_kind: decl_bool_type_kind,
    type_private: --[[ Public ]]1,
    type_manifest: undefined,
    type_variance: --[[ [] ]]0,
    type_newtype_level: undefined,
    type_loc: none,
    type_attributes: --[[ [] ]]0
  end;
  decl_unit_type_kind = --[[ Type_variant ]]Block.__(1, {--[[ :: ]]{
        cstr(ident_void, --[[ [] ]]0),
        --[[ [] ]]0
      }});
  decl_unit = do
    type_params: --[[ [] ]]0,
    type_arity: 0,
    type_kind: decl_unit_type_kind,
    type_private: --[[ Public ]]1,
    type_manifest: undefined,
    type_variance: --[[ [] ]]0,
    type_newtype_level: undefined,
    type_loc: none,
    type_attributes: --[[ [] ]]0
  end;
  decl_exn = do
    type_params: --[[ [] ]]0,
    type_arity: 0,
    type_kind: --[[ Type_open ]]1,
    type_private: --[[ Public ]]1,
    type_manifest: undefined,
    type_variance: --[[ [] ]]0,
    type_newtype_level: undefined,
    type_loc: none,
    type_attributes: --[[ [] ]]0
  end;
  tvar = newty2(100000000, --[[ Tvar ]]Block.__(0, {undefined}));
  decl_array_type_params = --[[ :: ]]{
    tvar,
    --[[ [] ]]0
  };
  decl_array_type_variance = --[[ :: ]]{
    Types_Variance.full,
    --[[ [] ]]0
  };
  decl_array = do
    type_params: decl_array_type_params,
    type_arity: 1,
    type_kind: --[[ Type_abstract ]]0,
    type_private: --[[ Public ]]1,
    type_manifest: undefined,
    type_variance: decl_array_type_variance,
    type_newtype_level: undefined,
    type_loc: none,
    type_attributes: --[[ [] ]]0
  end;
  tvar_1 = newty2(100000000, --[[ Tvar ]]Block.__(0, {undefined}));
  decl_list_type_params = --[[ :: ]]{
    tvar_1,
    --[[ [] ]]0
  };
  decl_list_type_kind = --[[ Type_variant ]]Block.__(1, {--[[ :: ]]{
        cstr(ident_nil, --[[ [] ]]0),
        --[[ :: ]]{
          cstr(ident_cons, --[[ :: ]]{
                tvar_1,
                --[[ :: ]]{
                  type_list(tvar_1),
                  --[[ [] ]]0
                }
              }),
          --[[ [] ]]0
        }
      }});
  decl_list_type_variance = --[[ :: ]]{
    Types_Variance.covariant,
    --[[ [] ]]0
  };
  decl_list = do
    type_params: decl_list_type_params,
    type_arity: 1,
    type_kind: decl_list_type_kind,
    type_private: --[[ Public ]]1,
    type_manifest: undefined,
    type_variance: decl_list_type_variance,
    type_newtype_level: undefined,
    type_loc: none,
    type_attributes: --[[ [] ]]0
  end;
  tvar_2 = newty2(100000000, --[[ Tvar ]]Block.__(0, {undefined}));
  decl_option_type_params = --[[ :: ]]{
    tvar_2,
    --[[ [] ]]0
  };
  decl_option_type_kind = --[[ Type_variant ]]Block.__(1, {--[[ :: ]]{
        cstr(ident_none, --[[ [] ]]0),
        --[[ :: ]]{
          cstr(ident_some, --[[ :: ]]{
                tvar_2,
                --[[ [] ]]0
              }),
          --[[ [] ]]0
        }
      }});
  decl_option_type_variance = --[[ :: ]]{
    Types_Variance.covariant,
    --[[ [] ]]0
  };
  decl_option = do
    type_params: decl_option_type_params,
    type_arity: 1,
    type_kind: decl_option_type_kind,
    type_private: --[[ Public ]]1,
    type_manifest: undefined,
    type_variance: decl_option_type_variance,
    type_newtype_level: undefined,
    type_loc: none,
    type_attributes: --[[ [] ]]0
  end;
  tvar_3 = newty2(100000000, --[[ Tvar ]]Block.__(0, {undefined}));
  decl_lazy_t_type_params = --[[ :: ]]{
    tvar_3,
    --[[ [] ]]0
  };
  decl_lazy_t_type_variance = --[[ :: ]]{
    Types_Variance.covariant,
    --[[ [] ]]0
  };
  decl_lazy_t = do
    type_params: decl_lazy_t_type_params,
    type_arity: 1,
    type_kind: --[[ Type_abstract ]]0,
    type_private: --[[ Public ]]1,
    type_manifest: undefined,
    type_variance: decl_lazy_t_type_variance,
    type_newtype_level: undefined,
    type_loc: none,
    type_attributes: --[[ [] ]]0
  end;
  add_extension_1 = function(id, l) do
    return Curry._2(add_extension, id, do
                ext_type_path: path_exn,
                ext_type_params: --[[ [] ]]0,
                ext_args: l,
                ext_ret_type: undefined,
                ext_private: --[[ Public ]]1,
                ext_loc: none,
                ext_attributes: --[[ [] ]]0
              end);
  end end;
  return Curry._1(add_extension_1(ident_match_failure, --[[ :: ]]{
                  newty2(100000000, --[[ Ttuple ]]Block.__(2, {--[[ :: ]]{
                            type_string,
                            --[[ :: ]]{
                              type_int,
                              --[[ :: ]]{
                                type_int,
                                --[[ [] ]]0
                              }
                            }
                          }})),
                  --[[ [] ]]0
                }), Curry._1(add_extension_1(ident_out_of_memory, --[[ [] ]]0), Curry._1(add_extension_1(ident_stack_overflow, --[[ [] ]]0), Curry._1(add_extension_1(ident_invalid_argument, --[[ :: ]]{
                              type_string,
                              --[[ [] ]]0
                            }), Curry._1(add_extension_1(ident_failure, --[[ :: ]]{
                                  type_string,
                                  --[[ [] ]]0
                                }), Curry._1(add_extension_1(ident_not_found, --[[ [] ]]0), Curry._1(add_extension_1(ident_sys_blocked_io, --[[ [] ]]0), Curry._1(add_extension_1(ident_sys_error, --[[ :: ]]{
                                              type_string,
                                              --[[ [] ]]0
                                            }), Curry._1(add_extension_1(ident_end_of_file, --[[ [] ]]0), Curry._1(add_extension_1(ident_division_by_zero, --[[ [] ]]0), Curry._1(add_extension_1(ident_assert_failure, --[[ :: ]]{
                                                          newty2(100000000, --[[ Ttuple ]]Block.__(2, {--[[ :: ]]{
                                                                    type_string,
                                                                    --[[ :: ]]{
                                                                      type_int,
                                                                      --[[ :: ]]{
                                                                        type_int,
                                                                        --[[ [] ]]0
                                                                      }
                                                                    }
                                                                  }})),
                                                          --[[ [] ]]0
                                                        }), Curry._1(add_extension_1(ident_undefined_recursive_module, --[[ :: ]]{
                                                              newty2(100000000, --[[ Ttuple ]]Block.__(2, {--[[ :: ]]{
                                                                        type_string,
                                                                        --[[ :: ]]{
                                                                          type_int,
                                                                          --[[ :: ]]{
                                                                            type_int,
                                                                            --[[ [] ]]0
                                                                          }
                                                                        }
                                                                      }})),
                                                              --[[ [] ]]0
                                                            }), Curry._3(add_type, ident_int64, decl_abstr, Curry._3(add_type, ident_int32, decl_abstr, Curry._3(add_type, ident_nativeint, decl_abstr, Curry._3(add_type, ident_lazy_t, decl_lazy_t, Curry._3(add_type, ident_option, decl_option, Curry._3(add_type, ident_list, decl_list, Curry._3(add_type, ident_array, decl_array, Curry._3(add_type, ident_exn, decl_exn, Curry._3(add_type, ident_unit, decl_unit, Curry._3(add_type, ident_bool, decl_bool, Curry._3(add_type, ident_float, decl_abstr, Curry._3(add_type, ident_string, decl_abstr, Curry._3(add_type, ident_char, decl_abstr, Curry._3(add_type, ident_int, decl_abstr, empty_env))))))))))))))))))))))))));
end end

function build_initial_env(add_type, add_exception, empty_env) do
  common = common_initial_env(add_type, add_exception, empty_env);
  safe_string = Curry._3(add_type, ident_bytes, decl_abstr, common);
  decl_bytes_unsafe_type_manifest = type_string;
  decl_bytes_unsafe = do
    type_params: --[[ [] ]]0,
    type_arity: 0,
    type_kind: --[[ Type_abstract ]]0,
    type_private: --[[ Public ]]1,
    type_manifest: decl_bytes_unsafe_type_manifest,
    type_variance: --[[ [] ]]0,
    type_newtype_level: undefined,
    type_loc: none,
    type_attributes: --[[ [] ]]0
  end;
  unsafe_string = Curry._3(add_type, ident_bytes, decl_bytes_unsafe, common);
  return --[[ tuple ]]{
          safe_string,
          unsafe_string
        };
end end

List.map((function(id) do
        make_global(id);
        return --[[ tuple ]]{
                id.name,
                id
              };
      end end), --[[ :: ]]{
      ident_match_failure,
      --[[ :: ]]{
        ident_out_of_memory,
        --[[ :: ]]{
          ident_stack_overflow,
          --[[ :: ]]{
            ident_invalid_argument,
            --[[ :: ]]{
              ident_failure,
              --[[ :: ]]{
                ident_not_found,
                --[[ :: ]]{
                  ident_sys_error,
                  --[[ :: ]]{
                    ident_end_of_file,
                    --[[ :: ]]{
                      ident_division_by_zero,
                      --[[ :: ]]{
                        ident_sys_blocked_io,
                        --[[ :: ]]{
                          ident_assert_failure,
                          --[[ :: ]]{
                            ident_undefined_recursive_module,
                            --[[ [] ]]0
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    });

set_current_time(999);

List.rev(builtin_idents.contents);

docstrings = do
  contents: --[[ [] ]]0
end;

function warn_bad_docstrings(param) do
  if (is_active(--[[ Bad_docstring ]]Block.__(33, {true}))) then do
    return List.iter((function(ds) do
                  match = ds.ds_attached;
                  local ___conditional___=(match);
                  do
                     if ___conditional___ == 0--[[ Unattached ]] then do
                        return prerr_warning(ds.ds_loc, --[[ Bad_docstring ]]Block.__(33, {true})); end end 
                     if ___conditional___ == 1--[[ Info ]] then do
                        return --[[ () ]]0; end end 
                     if ___conditional___ == 2--[[ Docs ]] then do
                        match_1 = ds.ds_associated;
                        if (match_1 >= 2) then do
                          return prerr_warning(ds.ds_loc, --[[ Bad_docstring ]]Block.__(33, {false}));
                        end else do
                          return --[[ () ]]0;
                        end end  end end 
                    
                  end
                end end), List.rev(docstrings.contents));
  end else do
    return 0;
  end end 
end end

function docstring(body, loc) do
  ds = do
    ds_body: body,
    ds_loc: loc,
    ds_attached: --[[ Unattached ]]0,
    ds_associated: --[[ Zero ]]0
  end;
  docstrings.contents = --[[ :: ]]{
    ds,
    docstrings.contents
  };
  return ds;
end end

empty_docs = do
  docs_pre: undefined,
  docs_post: undefined
end;

doc_loc = do
  txt: "ocaml.doc",
  loc: none
end;

function docs_attr(ds) do
  exp_pexp_desc = --[[ Pexp_constant ]]Block.__(1, {--[[ Const_string ]]Block.__(2, {
          ds.ds_body,
          undefined
        })});
  exp_pexp_loc = ds.ds_loc;
  exp = do
    pexp_desc: exp_pexp_desc,
    pexp_loc: exp_pexp_loc,
    pexp_attributes: --[[ [] ]]0
  end;
  item_pstr_desc = --[[ Pstr_eval ]]Block.__(0, {
      exp,
      --[[ [] ]]0
    });
  item_pstr_loc = exp_pexp_loc;
  item = do
    pstr_desc: item_pstr_desc,
    pstr_loc: item_pstr_loc
  end;
  return --[[ tuple ]]{
          doc_loc,
          --[[ PStr ]]Block.__(0, {--[[ :: ]]{
                item,
                --[[ [] ]]0
              }})
        };
end end

function add_docs_attrs(docs, attrs) do
  match = docs.docs_pre;
  attrs_1 = match ~= undefined and --[[ :: ]]{
      docs_attr(match),
      attrs
    } or attrs;
  match_1 = docs.docs_post;
  if (match_1 ~= undefined) then do
    return Pervasives.$at(attrs_1, --[[ :: ]]{
                docs_attr(match_1),
                --[[ [] ]]0
              });
  end else do
    return attrs_1;
  end end 
end end

function add_info_attrs(info, attrs) do
  if (info ~= undefined) then do
    return Pervasives.$at(attrs, --[[ :: ]]{
                docs_attr(info),
                --[[ [] ]]0
              });
  end else do
    return attrs;
  end end 
end end

text_loc = do
  txt: "ocaml.text",
  loc: none
end;

function text_attr(ds) do
  exp_pexp_desc = --[[ Pexp_constant ]]Block.__(1, {--[[ Const_string ]]Block.__(2, {
          ds.ds_body,
          undefined
        })});
  exp_pexp_loc = ds.ds_loc;
  exp = do
    pexp_desc: exp_pexp_desc,
    pexp_loc: exp_pexp_loc,
    pexp_attributes: --[[ [] ]]0
  end;
  item_pstr_desc = --[[ Pstr_eval ]]Block.__(0, {
      exp,
      --[[ [] ]]0
    });
  item_pstr_loc = exp_pexp_loc;
  item = do
    pstr_desc: item_pstr_desc,
    pstr_loc: item_pstr_loc
  end;
  return --[[ tuple ]]{
          text_loc,
          --[[ PStr ]]Block.__(0, {--[[ :: ]]{
                item,
                --[[ [] ]]0
              }})
        };
end end

function add_text_attrs(dsl, attrs) do
  return Pervasives.$at(List.map(text_attr, dsl), attrs);
end end

function get_docstring(info, dsl) do
  _param = dsl;
  while(true) do
    param = _param;
    if (param) then do
      ds = param[0];
      match = ds.ds_attached;
      if (match ~= 1) then do
        ds.ds_attached = info and --[[ Info ]]1 or --[[ Docs ]]2;
        return ds;
      end else do
        _param = param[1];
        ::continue:: ;
      end end 
    end else do
      return ;
    end end 
  end;
end end

function get_docstrings(dsl) do
  _acc = --[[ [] ]]0;
  _param = dsl;
  while(true) do
    param = _param;
    acc = _acc;
    if (param) then do
      ds = param[0];
      match = ds.ds_attached;
      if (match ~= 1) then do
        ds.ds_attached = --[[ Docs ]]2;
        _param = param[1];
        _acc = --[[ :: ]]{
          ds,
          acc
        };
        ::continue:: ;
      end else do
        _param = param[1];
        ::continue:: ;
      end end 
    end else do
      return List.rev(acc);
    end end 
  end;
end end

function associate_docstrings(dsl) do
  return List.iter((function(ds) do
                match = ds.ds_associated;
                if (match ~= 0) then do
                  ds.ds_associated = --[[ Many ]]2;
                  return --[[ () ]]0;
                end else do
                  ds.ds_associated = --[[ One ]]1;
                  return --[[ () ]]0;
                end end 
              end end), dsl);
end end

pre_table = Hashtbl.create(undefined, 50);

function set_pre_docstrings(pos, dsl) do
  if (dsl ~= --[[ [] ]]0) then do
    return Hashtbl.add(pre_table, pos, dsl);
  end else do
    return 0;
  end end 
end end

function get_pre_docs(pos) do
  xpcall(function() do
    dsl = Hashtbl.find(pre_table, pos);
    associate_docstrings(dsl);
    return get_docstring(false, dsl);
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return ;
    end else do
      error(exn)
    end end 
  end end)
end end

function mark_pre_docs(pos) do
  xpcall(function() do
    return associate_docstrings(Hashtbl.find(pre_table, pos));
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return --[[ () ]]0;
    end else do
      error(exn)
    end end 
  end end)
end end

post_table = Hashtbl.create(undefined, 50);

function set_post_docstrings(pos, dsl) do
  if (dsl ~= --[[ [] ]]0) then do
    return Hashtbl.add(post_table, pos, dsl);
  end else do
    return 0;
  end end 
end end

function get_post_docs(pos) do
  xpcall(function() do
    dsl = Hashtbl.find(post_table, pos);
    associate_docstrings(dsl);
    return get_docstring(false, dsl);
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return ;
    end else do
      error(exn)
    end end 
  end end)
end end

function mark_post_docs(pos) do
  xpcall(function() do
    return associate_docstrings(Hashtbl.find(post_table, pos));
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return --[[ () ]]0;
    end else do
      error(exn)
    end end 
  end end)
end end

function get_info(pos) do
  xpcall(function() do
    dsl = Hashtbl.find(post_table, pos);
    return get_docstring(true, dsl);
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return ;
    end else do
      error(exn)
    end end 
  end end)
end end

floating_table = Hashtbl.create(undefined, 50);

function set_floating_docstrings(pos, dsl) do
  if (dsl ~= --[[ [] ]]0) then do
    return Hashtbl.add(floating_table, pos, dsl);
  end else do
    return 0;
  end end 
end end

function get_text(pos) do
  xpcall(function() do
    return get_docstrings(Hashtbl.find(floating_table, pos));
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return --[[ [] ]]0;
    end else do
      error(exn)
    end end 
  end end)
end end

pre_extra_table = Hashtbl.create(undefined, 50);

function set_pre_extra_docstrings(pos, dsl) do
  if (dsl ~= --[[ [] ]]0) then do
    return Hashtbl.add(pre_extra_table, pos, dsl);
  end else do
    return 0;
  end end 
end end

function get_pre_extra_text(pos) do
  xpcall(function() do
    return get_docstrings(Hashtbl.find(pre_extra_table, pos));
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return --[[ [] ]]0;
    end else do
      error(exn)
    end end 
  end end)
end end

post_extra_table = Hashtbl.create(undefined, 50);

function set_post_extra_docstrings(pos, dsl) do
  if (dsl ~= --[[ [] ]]0) then do
    return Hashtbl.add(post_extra_table, pos, dsl);
  end else do
    return 0;
  end end 
end end

function get_post_extra_text(pos) do
  xpcall(function() do
    return get_docstrings(Hashtbl.find(post_extra_table, pos));
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return --[[ [] ]]0;
    end else do
      error(exn)
    end end 
  end end)
end end

function symbol_docs(param) do
  return do
          docs_pre: get_pre_docs(Parsing.symbol_start_pos(--[[ () ]]0)),
          docs_post: get_post_docs(Parsing.symbol_end_pos(--[[ () ]]0))
        end;
end end

function symbol_docs_lazy(param) do
  p1 = Parsing.symbol_start_pos(--[[ () ]]0);
  p2 = Parsing.symbol_end_pos(--[[ () ]]0);
  return Caml_obj.caml_lazy_make((function(param) do
                return do
                        docs_pre: get_pre_docs(p1),
                        docs_post: get_post_docs(p2)
                      end;
              end end));
end end

function mark_symbol_docs(param) do
  mark_pre_docs(Parsing.symbol_start_pos(--[[ () ]]0));
  return mark_post_docs(Parsing.symbol_end_pos(--[[ () ]]0));
end end

function mark_rhs_docs(pos1, pos2) do
  mark_pre_docs(Parsing.rhs_start_pos(pos1));
  return mark_post_docs(Parsing.rhs_end_pos(pos2));
end end

function symbol_text_lazy(param) do
  pos = Parsing.symbol_start_pos(--[[ () ]]0);
  return Caml_obj.caml_lazy_make((function(param) do
                return get_text(pos);
              end end));
end end

function init(param) do
  docstrings.contents = --[[ [] ]]0;
  Hashtbl.reset(pre_table);
  Hashtbl.reset(post_table);
  Hashtbl.reset(floating_table);
  Hashtbl.reset(pre_extra_table);
  return Hashtbl.reset(post_extra_table);
end end

default_loc = do
  contents: none
end;

function mk(locOpt, attrsOpt, d) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  return do
          ptyp_desc: d,
          ptyp_loc: loc,
          ptyp_attributes: attrs
        end;
end end

function attr(d, a) do
  return do
          ptyp_desc: d.ptyp_desc,
          ptyp_loc: d.ptyp_loc,
          ptyp_attributes: Pervasives.$at(d.ptyp_attributes, --[[ :: ]]{
                a,
                --[[ [] ]]0
              })
        end;
end end

function __var(loc, attrs, a) do
  return mk(loc, attrs, --[[ Ptyp_var ]]Block.__(0, {a}));
end end

function arrow(loc, attrs, a, b, c) do
  return mk(loc, attrs, --[[ Ptyp_arrow ]]Block.__(1, {
                a,
                b,
                c
              }));
end end

function tuple(loc, attrs, a) do
  return mk(loc, attrs, --[[ Ptyp_tuple ]]Block.__(2, {a}));
end end

function constr(loc, attrs, a, b) do
  return mk(loc, attrs, --[[ Ptyp_constr ]]Block.__(3, {
                a,
                b
              }));
end end

function object_(loc, attrs, a, b) do
  return mk(loc, attrs, --[[ Ptyp_object ]]Block.__(4, {
                a,
                b
              }));
end end

function class_(loc, attrs, a, b) do
  return mk(loc, attrs, --[[ Ptyp_class ]]Block.__(5, {
                a,
                b
              }));
end end

function alias(loc, attrs, a, b) do
  return mk(loc, attrs, --[[ Ptyp_alias ]]Block.__(6, {
                a,
                b
              }));
end end

function variant(loc, attrs, a, b, c) do
  return mk(loc, attrs, --[[ Ptyp_variant ]]Block.__(7, {
                a,
                b,
                c
              }));
end end

function poly(loc, attrs, a, b) do
  return mk(loc, attrs, --[[ Ptyp_poly ]]Block.__(8, {
                a,
                b
              }));
end end

function __package(loc, attrs, a, b) do
  return mk(loc, attrs, --[[ Ptyp_package ]]Block.__(9, {--[[ tuple ]]{
                  a,
                  b
                }}));
end end

function extension(loc, attrs, a) do
  return mk(loc, attrs, --[[ Ptyp_extension ]]Block.__(10, {a}));
end end

function force_poly(t) do
  match = t.ptyp_desc;
  if (typeof match ~= "number" and match.tag == --[[ Ptyp_poly ]]8) then do
    return t;
  end
   end 
  return poly(t.ptyp_loc, undefined, --[[ [] ]]0, t);
end end

function mk_1(locOpt, attrsOpt, d) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  return do
          ppat_desc: d,
          ppat_loc: loc,
          ppat_attributes: attrs
        end;
end end

function attr_1(d, a) do
  return do
          ppat_desc: d.ppat_desc,
          ppat_loc: d.ppat_loc,
          ppat_attributes: Pervasives.$at(d.ppat_attributes, --[[ :: ]]{
                a,
                --[[ [] ]]0
              })
        end;
end end

function __var_1(loc, attrs, a) do
  return mk_1(loc, attrs, --[[ Ppat_var ]]Block.__(0, {a}));
end end

function alias_1(loc, attrs, a, b) do
  return mk_1(loc, attrs, --[[ Ppat_alias ]]Block.__(1, {
                a,
                b
              }));
end end

function constant(loc, attrs, a) do
  return mk_1(loc, attrs, --[[ Ppat_constant ]]Block.__(2, {a}));
end end

function interval(loc, attrs, a, b) do
  return mk_1(loc, attrs, --[[ Ppat_interval ]]Block.__(3, {
                a,
                b
              }));
end end

function tuple_1(loc, attrs, a) do
  return mk_1(loc, attrs, --[[ Ppat_tuple ]]Block.__(4, {a}));
end end

function construct(loc, attrs, a, b) do
  return mk_1(loc, attrs, --[[ Ppat_construct ]]Block.__(5, {
                a,
                b
              }));
end end

function variant_1(loc, attrs, a, b) do
  return mk_1(loc, attrs, --[[ Ppat_variant ]]Block.__(6, {
                a,
                b
              }));
end end

function record(loc, attrs, a, b) do
  return mk_1(loc, attrs, --[[ Ppat_record ]]Block.__(7, {
                a,
                b
              }));
end end

function array(loc, attrs, a) do
  return mk_1(loc, attrs, --[[ Ppat_array ]]Block.__(8, {a}));
end end

function or_(loc, attrs, a, b) do
  return mk_1(loc, attrs, --[[ Ppat_or ]]Block.__(9, {
                a,
                b
              }));
end end

function constraint_(loc, attrs, a, b) do
  return mk_1(loc, attrs, --[[ Ppat_constraint ]]Block.__(10, {
                a,
                b
              }));
end end

function type_(loc, attrs, a) do
  return mk_1(loc, attrs, --[[ Ppat_type ]]Block.__(11, {a}));
end end

function lazy_(loc, attrs, a) do
  return mk_1(loc, attrs, --[[ Ppat_lazy ]]Block.__(12, {a}));
end end

function unpack(loc, attrs, a) do
  return mk_1(loc, attrs, --[[ Ppat_unpack ]]Block.__(13, {a}));
end end

function exception_(loc, attrs, a) do
  return mk_1(loc, attrs, --[[ Ppat_exception ]]Block.__(14, {a}));
end end

function extension_1(loc, attrs, a) do
  return mk_1(loc, attrs, --[[ Ppat_extension ]]Block.__(15, {a}));
end end

function mk_2(locOpt, attrsOpt, d) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  return do
          pexp_desc: d,
          pexp_loc: loc,
          pexp_attributes: attrs
        end;
end end

function attr_2(d, a) do
  return do
          pexp_desc: d.pexp_desc,
          pexp_loc: d.pexp_loc,
          pexp_attributes: Pervasives.$at(d.pexp_attributes, --[[ :: ]]{
                a,
                --[[ [] ]]0
              })
        end;
end end

function ident(loc, attrs, a) do
  return mk_2(loc, attrs, --[[ Pexp_ident ]]Block.__(0, {a}));
end end

function constant_1(loc, attrs, a) do
  return mk_2(loc, attrs, --[[ Pexp_constant ]]Block.__(1, {a}));
end end

function let_(loc, attrs, a, b, c) do
  return mk_2(loc, attrs, --[[ Pexp_let ]]Block.__(2, {
                a,
                b,
                c
              }));
end end

function fun_(loc, attrs, a, b, c, d) do
  return mk_2(loc, attrs, --[[ Pexp_fun ]]Block.__(4, {
                a,
                b,
                c,
                d
              }));
end end

function function_(loc, attrs, a) do
  return mk_2(loc, attrs, --[[ Pexp_function ]]Block.__(3, {a}));
end end

function apply(loc, attrs, a, b) do
  return mk_2(loc, attrs, --[[ Pexp_apply ]]Block.__(5, {
                a,
                b
              }));
end end

function match_(loc, attrs, a, b) do
  return mk_2(loc, attrs, --[[ Pexp_match ]]Block.__(6, {
                a,
                b
              }));
end end

function try_(loc, attrs, a, b) do
  return mk_2(loc, attrs, --[[ Pexp_try ]]Block.__(7, {
                a,
                b
              }));
end end

function tuple_2(loc, attrs, a) do
  return mk_2(loc, attrs, --[[ Pexp_tuple ]]Block.__(8, {a}));
end end

function construct_1(loc, attrs, a, b) do
  return mk_2(loc, attrs, --[[ Pexp_construct ]]Block.__(9, {
                a,
                b
              }));
end end

function variant_2(loc, attrs, a, b) do
  return mk_2(loc, attrs, --[[ Pexp_variant ]]Block.__(10, {
                a,
                b
              }));
end end

function record_1(loc, attrs, a, b) do
  return mk_2(loc, attrs, --[[ Pexp_record ]]Block.__(11, {
                a,
                b
              }));
end end

function field(loc, attrs, a, b) do
  return mk_2(loc, attrs, --[[ Pexp_field ]]Block.__(12, {
                a,
                b
              }));
end end

function setfield(loc, attrs, a, b, c) do
  return mk_2(loc, attrs, --[[ Pexp_setfield ]]Block.__(13, {
                a,
                b,
                c
              }));
end end

function array_1(loc, attrs, a) do
  return mk_2(loc, attrs, --[[ Pexp_array ]]Block.__(14, {a}));
end end

function ifthenelse(loc, attrs, a, b, c) do
  return mk_2(loc, attrs, --[[ Pexp_ifthenelse ]]Block.__(15, {
                a,
                b,
                c
              }));
end end

function sequence(loc, attrs, a, b) do
  return mk_2(loc, attrs, --[[ Pexp_sequence ]]Block.__(16, {
                a,
                b
              }));
end end

function while_(loc, attrs, a, b) do
  return mk_2(loc, attrs, --[[ Pexp_while ]]Block.__(17, {
                a,
                b
              }));
end end

function for_(loc, attrs, a, b, c, d, e) do
  return mk_2(loc, attrs, --[[ Pexp_for ]]Block.__(18, {
                a,
                b,
                c,
                d,
                e
              }));
end end

function constraint__1(loc, attrs, a, b) do
  return mk_2(loc, attrs, --[[ Pexp_constraint ]]Block.__(19, {
                a,
                b
              }));
end end

function coerce(loc, attrs, a, b, c) do
  return mk_2(loc, attrs, --[[ Pexp_coerce ]]Block.__(20, {
                a,
                b,
                c
              }));
end end

function send(loc, attrs, a, b) do
  return mk_2(loc, attrs, --[[ Pexp_send ]]Block.__(21, {
                a,
                b
              }));
end end

function new_(loc, attrs, a) do
  return mk_2(loc, attrs, --[[ Pexp_new ]]Block.__(22, {a}));
end end

function setinstvar(loc, attrs, a, b) do
  return mk_2(loc, attrs, --[[ Pexp_setinstvar ]]Block.__(23, {
                a,
                b
              }));
end end

function override(loc, attrs, a) do
  return mk_2(loc, attrs, --[[ Pexp_override ]]Block.__(24, {a}));
end end

function letmodule(loc, attrs, a, b, c) do
  return mk_2(loc, attrs, --[[ Pexp_letmodule ]]Block.__(25, {
                a,
                b,
                c
              }));
end end

function assert_(loc, attrs, a) do
  return mk_2(loc, attrs, --[[ Pexp_assert ]]Block.__(26, {a}));
end end

function lazy__1(loc, attrs, a) do
  return mk_2(loc, attrs, --[[ Pexp_lazy ]]Block.__(27, {a}));
end end

function poly_1(loc, attrs, a, b) do
  return mk_2(loc, attrs, --[[ Pexp_poly ]]Block.__(28, {
                a,
                b
              }));
end end

function object__1(loc, attrs, a) do
  return mk_2(loc, attrs, --[[ Pexp_object ]]Block.__(29, {a}));
end end

function newtype(loc, attrs, a, b) do
  return mk_2(loc, attrs, --[[ Pexp_newtype ]]Block.__(30, {
                a,
                b
              }));
end end

function pack(loc, attrs, a) do
  return mk_2(loc, attrs, --[[ Pexp_pack ]]Block.__(31, {a}));
end end

function open_(loc, attrs, a, b, c) do
  return mk_2(loc, attrs, --[[ Pexp_open ]]Block.__(32, {
                a,
                b,
                c
              }));
end end

function extension_2(loc, attrs, a) do
  return mk_2(loc, attrs, --[[ Pexp_extension ]]Block.__(33, {a}));
end end

function __case(lhs, guard, rhs) do
  return do
          pc_lhs: lhs,
          pc_guard: guard,
          pc_rhs: rhs
        end;
end end

function mk_3(locOpt, attrsOpt, d) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  return do
          pmty_desc: d,
          pmty_loc: loc,
          pmty_attributes: attrs
        end;
end end

function attr_3(d, a) do
  return do
          pmty_desc: d.pmty_desc,
          pmty_loc: d.pmty_loc,
          pmty_attributes: Pervasives.$at(d.pmty_attributes, --[[ :: ]]{
                a,
                --[[ [] ]]0
              })
        end;
end end

function ident_1(loc, attrs, a) do
  return mk_3(loc, attrs, --[[ Pmty_ident ]]Block.__(0, {a}));
end end

function alias_2(loc, attrs, a) do
  return mk_3(loc, attrs, --[[ Pmty_alias ]]Block.__(6, {a}));
end end

function signature(loc, attrs, a) do
  return mk_3(loc, attrs, --[[ Pmty_signature ]]Block.__(1, {a}));
end end

function functor_(loc, attrs, a, b, c) do
  return mk_3(loc, attrs, --[[ Pmty_functor ]]Block.__(2, {
                a,
                b,
                c
              }));
end end

function with_(loc, attrs, a, b) do
  return mk_3(loc, attrs, --[[ Pmty_with ]]Block.__(3, {
                a,
                b
              }));
end end

function typeof_(loc, attrs, a) do
  return mk_3(loc, attrs, --[[ Pmty_typeof ]]Block.__(4, {a}));
end end

function extension_3(loc, attrs, a) do
  return mk_3(loc, attrs, --[[ Pmty_extension ]]Block.__(5, {a}));
end end

function mk_4(locOpt, attrsOpt, d) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  return do
          pmod_desc: d,
          pmod_loc: loc,
          pmod_attributes: attrs
        end;
end end

function attr_4(d, a) do
  return do
          pmod_desc: d.pmod_desc,
          pmod_loc: d.pmod_loc,
          pmod_attributes: Pervasives.$at(d.pmod_attributes, --[[ :: ]]{
                a,
                --[[ [] ]]0
              })
        end;
end end

function ident_2(loc, attrs, x) do
  return mk_4(loc, attrs, --[[ Pmod_ident ]]Block.__(0, {x}));
end end

function structure(loc, attrs, x) do
  return mk_4(loc, attrs, --[[ Pmod_structure ]]Block.__(1, {x}));
end end

function functor__1(loc, attrs, arg, arg_ty, body) do
  return mk_4(loc, attrs, --[[ Pmod_functor ]]Block.__(2, {
                arg,
                arg_ty,
                body
              }));
end end

function apply_1(loc, attrs, m1, m2) do
  return mk_4(loc, attrs, --[[ Pmod_apply ]]Block.__(3, {
                m1,
                m2
              }));
end end

function constraint__2(loc, attrs, m, mty) do
  return mk_4(loc, attrs, --[[ Pmod_constraint ]]Block.__(4, {
                m,
                mty
              }));
end end

function unpack_1(loc, attrs, e) do
  return mk_4(loc, attrs, --[[ Pmod_unpack ]]Block.__(5, {e}));
end end

function extension_4(loc, attrs, a) do
  return mk_4(loc, attrs, --[[ Pmod_extension ]]Block.__(6, {a}));
end end

function mk_5(locOpt, d) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  return do
          psig_desc: d,
          psig_loc: loc
        end;
end end

function extension_5(loc, attrsOpt, a) do
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  return mk_5(loc, --[[ Psig_extension ]]Block.__(12, {
                a,
                attrs
              }));
end end

function text(txt) do
  return List.map((function(ds) do
                a = text_attr(ds);
                loc = ds.ds_loc;
                return mk_5(loc, --[[ Psig_attribute ]]Block.__(11, {a}));
              end end), txt);
end end

function mk_6(locOpt, d) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  return do
          pstr_desc: d,
          pstr_loc: loc
        end;
end end

function __eval(loc, attrsOpt, a) do
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  return mk_6(loc, --[[ Pstr_eval ]]Block.__(0, {
                a,
                attrs
              }));
end end

function value(loc, a, b) do
  return mk_6(loc, --[[ Pstr_value ]]Block.__(1, {
                a,
                b
              }));
end end

function extension_6(loc, attrsOpt, a) do
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  return mk_6(loc, --[[ Pstr_extension ]]Block.__(14, {
                a,
                attrs
              }));
end end

function text_1(txt) do
  return List.map((function(ds) do
                a = text_attr(ds);
                loc = ds.ds_loc;
                return mk_6(loc, --[[ Pstr_attribute ]]Block.__(13, {a}));
              end end), txt);
end end

function mk_7(locOpt, attrsOpt, d) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  return do
          pcl_desc: d,
          pcl_loc: loc,
          pcl_attributes: attrs
        end;
end end

function attr_5(d, a) do
  return do
          pcl_desc: d.pcl_desc,
          pcl_loc: d.pcl_loc,
          pcl_attributes: Pervasives.$at(d.pcl_attributes, --[[ :: ]]{
                a,
                --[[ [] ]]0
              })
        end;
end end

function constr_1(loc, attrs, a, b) do
  return mk_7(loc, attrs, --[[ Pcl_constr ]]Block.__(0, {
                a,
                b
              }));
end end

function structure_1(loc, attrs, a) do
  return mk_7(loc, attrs, --[[ Pcl_structure ]]Block.__(1, {a}));
end end

function fun__1(loc, attrs, a, b, c, d) do
  return mk_7(loc, attrs, --[[ Pcl_fun ]]Block.__(2, {
                a,
                b,
                c,
                d
              }));
end end

function apply_2(loc, attrs, a, b) do
  return mk_7(loc, attrs, --[[ Pcl_apply ]]Block.__(3, {
                a,
                b
              }));
end end

function let__1(loc, attrs, a, b, c) do
  return mk_7(loc, attrs, --[[ Pcl_let ]]Block.__(4, {
                a,
                b,
                c
              }));
end end

function constraint__3(loc, attrs, a, b) do
  return mk_7(loc, attrs, --[[ Pcl_constraint ]]Block.__(5, {
                a,
                b
              }));
end end

function extension_7(loc, attrs, a) do
  return mk_7(loc, attrs, --[[ Pcl_extension ]]Block.__(6, {a}));
end end

function mk_8(locOpt, attrsOpt, d) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  return do
          pcty_desc: d,
          pcty_loc: loc,
          pcty_attributes: attrs
        end;
end end

function attr_6(d, a) do
  return do
          pcty_desc: d.pcty_desc,
          pcty_loc: d.pcty_loc,
          pcty_attributes: Pervasives.$at(d.pcty_attributes, --[[ :: ]]{
                a,
                --[[ [] ]]0
              })
        end;
end end

function constr_2(loc, attrs, a, b) do
  return mk_8(loc, attrs, --[[ Pcty_constr ]]Block.__(0, {
                a,
                b
              }));
end end

function signature_1(loc, attrs, a) do
  return mk_8(loc, attrs, --[[ Pcty_signature ]]Block.__(1, {a}));
end end

function arrow_1(loc, attrs, a, b, c) do
  return mk_8(loc, attrs, --[[ Pcty_arrow ]]Block.__(2, {
                a,
                b,
                c
              }));
end end

function extension_8(loc, attrs, a) do
  return mk_8(loc, attrs, --[[ Pcty_extension ]]Block.__(3, {a}));
end end

function mk_9(locOpt, attrsOpt, docsOpt, d) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  return do
          pctf_desc: d,
          pctf_loc: loc,
          pctf_attributes: add_docs_attrs(docs, attrs)
        end;
end end

function inherit_(loc, attrs, a) do
  return mk_9(loc, attrs, undefined, --[[ Pctf_inherit ]]Block.__(0, {a}));
end end

function val_(loc, attrs, a, b, c, d) do
  return mk_9(loc, attrs, undefined, --[[ Pctf_val ]]Block.__(1, {--[[ tuple ]]{
                  a,
                  b,
                  c,
                  d
                }}));
end end

function method_(loc, attrs, a, b, c, d) do
  return mk_9(loc, attrs, undefined, --[[ Pctf_method ]]Block.__(2, {--[[ tuple ]]{
                  a,
                  b,
                  c,
                  d
                }}));
end end

function constraint__4(loc, attrs, a, b) do
  return mk_9(loc, attrs, undefined, --[[ Pctf_constraint ]]Block.__(3, {--[[ tuple ]]{
                  a,
                  b
                }}));
end end

function extension_9(loc, attrs, a) do
  return mk_9(loc, attrs, undefined, --[[ Pctf_extension ]]Block.__(5, {a}));
end end

function attribute(loc, a) do
  return mk_9(loc, undefined, undefined, --[[ Pctf_attribute ]]Block.__(4, {a}));
end end

function text_2(txt) do
  return List.map((function(ds) do
                return attribute(ds.ds_loc, text_attr(ds));
              end end), txt);
end end

function attr_7(d, a) do
  return do
          pctf_desc: d.pctf_desc,
          pctf_loc: d.pctf_loc,
          pctf_attributes: Pervasives.$at(d.pctf_attributes, --[[ :: ]]{
                a,
                --[[ [] ]]0
              })
        end;
end end

function mk_10(locOpt, attrsOpt, docsOpt, d) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  return do
          pcf_desc: d,
          pcf_loc: loc,
          pcf_attributes: add_docs_attrs(docs, attrs)
        end;
end end

function inherit__1(loc, attrs, a, b, c) do
  return mk_10(loc, attrs, undefined, --[[ Pcf_inherit ]]Block.__(0, {
                a,
                b,
                c
              }));
end end

function val__1(loc, attrs, a, b, c) do
  return mk_10(loc, attrs, undefined, --[[ Pcf_val ]]Block.__(1, {--[[ tuple ]]{
                  a,
                  b,
                  c
                }}));
end end

function method__1(loc, attrs, a, b, c) do
  return mk_10(loc, attrs, undefined, --[[ Pcf_method ]]Block.__(2, {--[[ tuple ]]{
                  a,
                  b,
                  c
                }}));
end end

function constraint__5(loc, attrs, a, b) do
  return mk_10(loc, attrs, undefined, --[[ Pcf_constraint ]]Block.__(3, {--[[ tuple ]]{
                  a,
                  b
                }}));
end end

function initializer_(loc, attrs, a) do
  return mk_10(loc, attrs, undefined, --[[ Pcf_initializer ]]Block.__(4, {a}));
end end

function extension_10(loc, attrs, a) do
  return mk_10(loc, attrs, undefined, --[[ Pcf_extension ]]Block.__(6, {a}));
end end

function attribute_1(loc, a) do
  return mk_10(loc, undefined, undefined, --[[ Pcf_attribute ]]Block.__(5, {a}));
end end

function text_3(txt) do
  return List.map((function(ds) do
                return attribute_1(ds.ds_loc, text_attr(ds));
              end end), txt);
end end

function virtual_(ct) do
  return --[[ Cfk_virtual ]]Block.__(0, {ct});
end end

function concrete(o, e) do
  return --[[ Cfk_concrete ]]Block.__(1, {
            o,
            e
          });
end end

function attr_8(d, a) do
  return do
          pcf_desc: d.pcf_desc,
          pcf_loc: d.pcf_loc,
          pcf_attributes: Pervasives.$at(d.pcf_attributes, --[[ :: ]]{
                a,
                --[[ [] ]]0
              })
        end;
end end

function mk_11(locOpt, attrsOpt, docsOpt, primOpt, name, typ) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  prim = primOpt ~= undefined and primOpt or --[[ [] ]]0;
  return do
          pval_name: name,
          pval_type: typ,
          pval_prim: prim,
          pval_attributes: add_docs_attrs(docs, attrs),
          pval_loc: loc
        end;
end end

function mk_12(locOpt, attrsOpt, docsOpt, textOpt, name, typ) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  text = textOpt ~= undefined and textOpt or --[[ [] ]]0;
  return do
          pmd_name: name,
          pmd_type: typ,
          pmd_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs)),
          pmd_loc: loc
        end;
end end

function mk_13(locOpt, attrsOpt, docsOpt, textOpt, typ, name) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  text = textOpt ~= undefined and textOpt or --[[ [] ]]0;
  return do
          pmtd_name: name,
          pmtd_type: typ,
          pmtd_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs)),
          pmtd_loc: loc
        end;
end end

function mk_14(locOpt, attrsOpt, docsOpt, textOpt, name, expr) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  text = textOpt ~= undefined and textOpt or --[[ [] ]]0;
  return do
          pmb_name: name,
          pmb_expr: expr,
          pmb_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs)),
          pmb_loc: loc
        end;
end end

function mk_15(locOpt, attrsOpt, docsOpt, overrideOpt, lid) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  override = overrideOpt ~= undefined and overrideOpt or --[[ Fresh ]]1;
  return do
          popen_lid: lid,
          popen_override: override,
          popen_loc: loc,
          popen_attributes: add_docs_attrs(docs, attrs)
        end;
end end

function mk_16(locOpt, attrsOpt, docsOpt, mexpr) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  return do
          pincl_mod: mexpr,
          pincl_loc: loc,
          pincl_attributes: add_docs_attrs(docs, attrs)
        end;
end end

function mk_17(locOpt, attrsOpt, docsOpt, textOpt, pat, expr) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  text = textOpt ~= undefined and textOpt or --[[ [] ]]0;
  return do
          pvb_pat: pat,
          pvb_expr: expr,
          pvb_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs)),
          pvb_loc: loc
        end;
end end

function mk_18(locOpt, attrsOpt, docsOpt, textOpt, virtOpt, paramsOpt, name, expr) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  text = textOpt ~= undefined and textOpt or --[[ [] ]]0;
  virt = virtOpt ~= undefined and virtOpt or --[[ Concrete ]]1;
  params = paramsOpt ~= undefined and paramsOpt or --[[ [] ]]0;
  return do
          pci_virt: virt,
          pci_params: params,
          pci_name: name,
          pci_expr: expr,
          pci_loc: loc,
          pci_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs))
        end;
end end

function mk_19(locOpt, attrsOpt, docsOpt, textOpt, paramsOpt, cstrsOpt, kindOpt, privOpt, manifest, name) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  text = textOpt ~= undefined and textOpt or --[[ [] ]]0;
  params = paramsOpt ~= undefined and paramsOpt or --[[ [] ]]0;
  cstrs = cstrsOpt ~= undefined and cstrsOpt or --[[ [] ]]0;
  kind = kindOpt ~= undefined and kindOpt or --[[ Ptype_abstract ]]0;
  priv = privOpt ~= undefined and privOpt or --[[ Public ]]1;
  return do
          ptype_name: name,
          ptype_params: params,
          ptype_cstrs: cstrs,
          ptype_kind: kind,
          ptype_private: priv,
          ptype_manifest: manifest,
          ptype_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs)),
          ptype_loc: loc
        end;
end end

function constructor(locOpt, attrsOpt, infoOpt, argsOpt, res, name) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  info = infoOpt ~= undefined and Caml_option.valFromOption(infoOpt) or undefined;
  args = argsOpt ~= undefined and argsOpt or --[[ [] ]]0;
  return do
          pcd_name: name,
          pcd_args: args,
          pcd_res: res,
          pcd_loc: loc,
          pcd_attributes: add_info_attrs(info, attrs)
        end;
end end

function field_1(locOpt, attrsOpt, infoOpt, mutOpt, name, typ) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  info = infoOpt ~= undefined and Caml_option.valFromOption(infoOpt) or undefined;
  mut = mutOpt ~= undefined and mutOpt or --[[ Immutable ]]0;
  return do
          pld_name: name,
          pld_mutable: mut,
          pld_type: typ,
          pld_loc: loc,
          pld_attributes: add_info_attrs(info, attrs)
        end;
end end

function mk_20(attrsOpt, docsOpt, paramsOpt, privOpt, path, constructors) do
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  params = paramsOpt ~= undefined and paramsOpt or --[[ [] ]]0;
  priv = privOpt ~= undefined and privOpt or --[[ Public ]]1;
  return do
          ptyext_path: path,
          ptyext_params: params,
          ptyext_constructors: constructors,
          ptyext_private: priv,
          ptyext_attributes: add_docs_attrs(docs, attrs)
        end;
end end

function constructor_1(locOpt, attrsOpt, docsOpt, infoOpt, name, kind) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  info = infoOpt ~= undefined and Caml_option.valFromOption(infoOpt) or undefined;
  return do
          pext_name: name,
          pext_kind: kind,
          pext_loc: loc,
          pext_attributes: add_docs_attrs(docs, add_info_attrs(info, attrs))
        end;
end end

function decl(locOpt, attrsOpt, docsOpt, infoOpt, argsOpt, res, name) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  info = infoOpt ~= undefined and Caml_option.valFromOption(infoOpt) or undefined;
  args = argsOpt ~= undefined and argsOpt or --[[ [] ]]0;
  return do
          pext_name: name,
          pext_kind: --[[ Pext_decl ]]Block.__(0, {
              args,
              res
            }),
          pext_loc: loc,
          pext_attributes: add_docs_attrs(docs, add_info_attrs(info, attrs))
        end;
end end

function rebind(locOpt, attrsOpt, docsOpt, infoOpt, name, lid) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  info = infoOpt ~= undefined and Caml_option.valFromOption(infoOpt) or undefined;
  return do
          pext_name: name,
          pext_kind: --[[ Pext_rebind ]]Block.__(1, {lid}),
          pext_loc: loc,
          pext_attributes: add_docs_attrs(docs, add_info_attrs(info, attrs))
        end;
end end

Ast_helper_Exp = do
  mk: mk_2,
  attr: attr_2,
  ident: ident,
  constant: constant_1,
  let_: let_,
  fun_: fun_,
  function_: function_,
  apply: apply,
  match_: match_,
  try_: try_,
  tuple: tuple_2,
  construct: construct_1,
  variant: variant_2,
  record: record_1,
  field: field,
  setfield: setfield,
  array: array_1,
  ifthenelse: ifthenelse,
  sequence: sequence,
  while_: while_,
  for_: for_,
  coerce: coerce,
  constraint_: constraint__1,
  send: send,
  new_: new_,
  setinstvar: setinstvar,
  override: override,
  letmodule: letmodule,
  assert_: assert_,
  lazy_: lazy__1,
  poly: poly_1,
  object_: object__1,
  newtype: newtype,
  pack: pack,
  open_: open_,
  extension: extension_2,
  __case: __case
end;

Ast_helper_Ctf = do
  mk: mk_9,
  attr: attr_7,
  inherit_: inherit_,
  val_: val_,
  method_: method_,
  constraint_: constraint__4,
  extension: extension_9,
  attribute: attribute,
  text: text_2
end;

Ast_helper_Cf = do
  mk: mk_10,
  attr: attr_8,
  inherit_: inherit__1,
  val_: val__1,
  method_: method__1,
  constraint_: constraint__5,
  initializer_: initializer_,
  extension: extension_10,
  attribute: attribute_1,
  text: text_3,
  virtual_: virtual_,
  concrete: concrete
end;

function map_fst(f, param) do
  return --[[ tuple ]]{
          Curry._1(f, param[0]),
          param[1]
        };
end end

function map_snd(f, param) do
  return --[[ tuple ]]{
          param[0],
          Curry._1(f, param[1])
        };
end end

function map_tuple(f1, f2, param) do
  return --[[ tuple ]]{
          Curry._1(f1, param[0]),
          Curry._1(f2, param[1])
        };
end end

function map_opt(f, param) do
  if (param ~= undefined) then do
    return Caml_option.some(Curry._1(f, Caml_option.valFromOption(param)));
  end
   end 
end end

function map_loc(sub, param) do
  return do
          txt: param.txt,
          loc: Curry._2(sub.location, sub, param.loc)
        end;
end end

function map_1(sub, param) do
  desc = param.ptyp_desc;
  loc = Curry._2(sub.location, sub, param.ptyp_loc);
  attrs = Curry._2(sub.attributes, sub, param.ptyp_attributes);
  if (typeof desc == "number") then do
    return mk(loc, attrs, --[[ Ptyp_any ]]0);
  end else do
    local ___conditional___=(desc.tag | 0);
    do
       if ___conditional___ == 0--[[ Ptyp_var ]] then do
          return __var(loc, attrs, desc[0]); end end 
       if ___conditional___ == 1--[[ Ptyp_arrow ]] then do
          return arrow(loc, attrs, desc[0], Curry._2(sub.typ, sub, desc[1]), Curry._2(sub.typ, sub, desc[2])); end end 
       if ___conditional___ == 2--[[ Ptyp_tuple ]] then do
          return tuple(loc, attrs, List.map(Curry._1(sub.typ, sub), desc[0])); end end 
       if ___conditional___ == 3--[[ Ptyp_constr ]] then do
          return constr(loc, attrs, map_loc(sub, desc[0]), List.map(Curry._1(sub.typ, sub), desc[1])); end end 
       if ___conditional___ == 4--[[ Ptyp_object ]] then do
          f = function(param) do
            return --[[ tuple ]]{
                    param[0],
                    Curry._2(sub.attributes, sub, param[1]),
                    Curry._2(sub.typ, sub, param[2])
                  };
          end end;
          return object_(loc, attrs, List.map(f, desc[0]), desc[1]); end end 
       if ___conditional___ == 5--[[ Ptyp_class ]] then do
          return class_(loc, attrs, map_loc(sub, desc[0]), List.map(Curry._1(sub.typ, sub), desc[1])); end end 
       if ___conditional___ == 6--[[ Ptyp_alias ]] then do
          return alias(loc, attrs, Curry._2(sub.typ, sub, desc[0]), desc[1]); end end 
       if ___conditional___ == 7--[[ Ptyp_variant ]] then do
          return variant(loc, attrs, List.map((function(param) do
                            sub_1 = sub;
                            param_1 = param;
                            if (param_1.tag) then do
                              return --[[ Rinherit ]]Block.__(1, {Curry._2(sub_1.typ, sub_1, param_1[0])});
                            end else do
                              return --[[ Rtag ]]Block.__(0, {
                                        param_1[0],
                                        Curry._2(sub_1.attributes, sub_1, param_1[1]),
                                        param_1[2],
                                        List.map(Curry._1(sub_1.typ, sub_1), param_1[3])
                                      });
                            end end 
                          end end), desc[0]), desc[1], desc[2]); end end 
       if ___conditional___ == 8--[[ Ptyp_poly ]] then do
          return poly(loc, attrs, desc[0], Curry._2(sub.typ, sub, desc[1])); end end 
       if ___conditional___ == 9--[[ Ptyp_package ]] then do
          match = desc[0];
          partial_arg = Curry._1(sub.typ, sub);
          return __package(loc, attrs, map_loc(sub, match[0]), List.map((function(param) do
                            return map_tuple((function(param) do
                                          return map_loc(sub, param);
                                        end end), partial_arg, param);
                          end end), match[1])); end end 
       if ___conditional___ == 10--[[ Ptyp_extension ]] then do
          return extension(loc, attrs, Curry._2(sub.extension, sub, desc[0])); end end 
      
    end
  end end 
end end

function map_type_declaration(sub, param) do
  partial_arg = Curry._1(sub.typ, sub);
  partial_arg_1 = Curry._1(sub.location, sub);
  partial_arg_2 = Curry._1(sub.typ, sub);
  partial_arg_3 = Curry._1(sub.typ, sub);
  return mk_19(Curry._2(sub.location, sub, param.ptype_loc), Curry._2(sub.attributes, sub, param.ptype_attributes), undefined, undefined, List.map((function(param) do
                    return map_fst(partial_arg, param);
                  end end), param.ptype_params), List.map((function(param) do
                    f1 = partial_arg_3;
                    f2 = partial_arg_2;
                    f3 = partial_arg_1;
                    param_1 = param;
                    return --[[ tuple ]]{
                            Curry._1(f1, param_1[0]),
                            Curry._1(f2, param_1[1]),
                            Curry._1(f3, param_1[2])
                          };
                  end end), param.ptype_cstrs), Curry._2(sub.type_kind, sub, param.ptype_kind), param.ptype_private, map_opt(Curry._1(sub.typ, sub), param.ptype_manifest), map_loc(sub, param.ptype_name));
end end

function map_type_kind(sub, param) do
  if (typeof param == "number") then do
    if (param == --[[ Ptype_abstract ]]0) then do
      return --[[ Ptype_abstract ]]0;
    end else do
      return --[[ Ptype_open ]]1;
    end end 
  end else if (param.tag) then do
    return --[[ Ptype_record ]]Block.__(1, {List.map(Curry._1(sub.label_declaration, sub), param[0])});
  end else do
    return --[[ Ptype_variant ]]Block.__(0, {List.map(Curry._1(sub.constructor_declaration, sub), param[0])});
  end end  end 
end end

function map_type_extension(sub, param) do
  partial_arg = Curry._1(sub.typ, sub);
  return mk_20(Curry._2(sub.attributes, sub, param.ptyext_attributes), undefined, List.map((function(param) do
                    return map_fst(partial_arg, param);
                  end end), param.ptyext_params), param.ptyext_private, map_loc(sub, param.ptyext_path), List.map(Curry._1(sub.extension_constructor, sub), param.ptyext_constructors));
end end

function map_extension_constructor_kind(sub, param) do
  if (param.tag) then do
    return --[[ Pext_rebind ]]Block.__(1, {map_loc(sub, param[0])});
  end else do
    return --[[ Pext_decl ]]Block.__(0, {
              List.map(Curry._1(sub.typ, sub), param[0]),
              map_opt(Curry._1(sub.typ, sub), param[1])
            });
  end end 
end end

function map_extension_constructor(sub, param) do
  return constructor_1(Curry._2(sub.location, sub, param.pext_loc), Curry._2(sub.attributes, sub, param.pext_attributes), undefined, undefined, map_loc(sub, param.pext_name), map_extension_constructor_kind(sub, param.pext_kind));
end end

function map_2(sub, param) do
  desc = param.pcty_desc;
  loc = Curry._2(sub.location, sub, param.pcty_loc);
  attrs = Curry._2(sub.attributes, sub, param.pcty_attributes);
  local ___conditional___=(desc.tag | 0);
  do
     if ___conditional___ == 0--[[ Pcty_constr ]] then do
        return constr_2(loc, attrs, map_loc(sub, desc[0]), List.map(Curry._1(sub.typ, sub), desc[1])); end end 
     if ___conditional___ == 1--[[ Pcty_signature ]] then do
        return signature_1(loc, attrs, Curry._2(sub.class_signature, sub, desc[0])); end end 
     if ___conditional___ == 2--[[ Pcty_arrow ]] then do
        return arrow_1(loc, attrs, desc[0], Curry._2(sub.typ, sub, desc[1]), Curry._2(sub.class_type, sub, desc[2])); end end 
     if ___conditional___ == 3--[[ Pcty_extension ]] then do
        return extension_8(loc, attrs, Curry._2(sub.extension, sub, desc[0])); end end 
    
  end
end end

function map_field(sub, param) do
  desc = param.pctf_desc;
  loc = Curry._2(sub.location, sub, param.pctf_loc);
  attrs = Curry._2(sub.attributes, sub, param.pctf_attributes);
  local ___conditional___=(desc.tag | 0);
  do
     if ___conditional___ == 0--[[ Pctf_inherit ]] then do
        return Curry._3(Ast_helper_Ctf.inherit_, loc, attrs, Curry._2(sub.class_type, sub, desc[0])); end end 
     if ___conditional___ == 1--[[ Pctf_val ]] then do
        match = desc[0];
        return Curry._6(Ast_helper_Ctf.val_, loc, attrs, match[0], match[1], match[2], Curry._2(sub.typ, sub, match[3])); end end 
     if ___conditional___ == 2--[[ Pctf_method ]] then do
        match_1 = desc[0];
        return Curry._6(Ast_helper_Ctf.method_, loc, attrs, match_1[0], match_1[1], match_1[2], Curry._2(sub.typ, sub, match_1[3])); end end 
     if ___conditional___ == 3--[[ Pctf_constraint ]] then do
        match_2 = desc[0];
        return Curry._4(Ast_helper_Ctf.constraint_, loc, attrs, Curry._2(sub.typ, sub, match_2[0]), Curry._2(sub.typ, sub, match_2[1])); end end 
     if ___conditional___ == 4--[[ Pctf_attribute ]] then do
        return Curry._2(Ast_helper_Ctf.attribute, loc, Curry._2(sub.attribute, sub, desc[0])); end end 
     if ___conditional___ == 5--[[ Pctf_extension ]] then do
        return Curry._3(Ast_helper_Ctf.extension, loc, attrs, Curry._2(sub.extension, sub, desc[0])); end end 
    
  end
end end

function map_signature(sub, param) do
  return do
          pcsig_self: Curry._2(sub.typ, sub, param.pcsig_self),
          pcsig_fields: List.map(Curry._1(sub.class_type_field, sub), param.pcsig_fields)
        end;
end end

function map_3(sub, param) do
  desc = param.pmty_desc;
  loc = Curry._2(sub.location, sub, param.pmty_loc);
  attrs = Curry._2(sub.attributes, sub, param.pmty_attributes);
  local ___conditional___=(desc.tag | 0);
  do
     if ___conditional___ == 0--[[ Pmty_ident ]] then do
        return ident_1(loc, attrs, map_loc(sub, desc[0])); end end 
     if ___conditional___ == 1--[[ Pmty_signature ]] then do
        return signature(loc, attrs, Curry._2(sub.signature, sub, desc[0])); end end 
     if ___conditional___ == 2--[[ Pmty_functor ]] then do
        return functor_(loc, attrs, map_loc(sub, desc[0]), may_map(Curry._1(sub.module_type, sub), desc[1]), Curry._2(sub.module_type, sub, desc[2])); end end 
     if ___conditional___ == 3--[[ Pmty_with ]] then do
        return with_(loc, attrs, Curry._2(sub.module_type, sub, desc[0]), List.map(Curry._1(sub.with_constraint, sub), desc[1])); end end 
     if ___conditional___ == 4--[[ Pmty_typeof ]] then do
        return typeof_(loc, attrs, Curry._2(sub.module_expr, sub, desc[0])); end end 
     if ___conditional___ == 5--[[ Pmty_extension ]] then do
        return extension_3(loc, attrs, Curry._2(sub.extension, sub, desc[0])); end end 
     if ___conditional___ == 6--[[ Pmty_alias ]] then do
        return alias_2(loc, attrs, map_loc(sub, desc[0])); end end 
    
  end
end end

function map_with_constraint(sub, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Pwith_type ]] then do
        return --[[ Pwith_type ]]Block.__(0, {
                  map_loc(sub, param[0]),
                  Curry._2(sub.type_declaration, sub, param[1])
                }); end end 
     if ___conditional___ == 1--[[ Pwith_module ]] then do
        return --[[ Pwith_module ]]Block.__(1, {
                  map_loc(sub, param[0]),
                  map_loc(sub, param[1])
                }); end end 
     if ___conditional___ == 2--[[ Pwith_typesubst ]] then do
        return --[[ Pwith_typesubst ]]Block.__(2, {Curry._2(sub.type_declaration, sub, param[0])}); end end 
     if ___conditional___ == 3--[[ Pwith_modsubst ]] then do
        return --[[ Pwith_modsubst ]]Block.__(3, {
                  map_loc(sub, param[0]),
                  map_loc(sub, param[1])
                }); end end 
    
  end
end end

function map_signature_item(sub, param) do
  desc = param.psig_desc;
  loc = Curry._2(sub.location, sub, param.psig_loc);
  local ___conditional___=(desc.tag | 0);
  do
     if ___conditional___ == 0--[[ Psig_value ]] then do
        a = Curry._2(sub.value_description, sub, desc[0]);
        return mk_5(loc, --[[ Psig_value ]]Block.__(0, {a})); end end 
     if ___conditional___ == 1--[[ Psig_type ]] then do
        a_1 = List.map(Curry._1(sub.type_declaration, sub), desc[0]);
        return mk_5(loc, --[[ Psig_type ]]Block.__(1, {a_1})); end end 
     if ___conditional___ == 2--[[ Psig_typext ]] then do
        a_2 = Curry._2(sub.type_extension, sub, desc[0]);
        return mk_5(loc, --[[ Psig_typext ]]Block.__(2, {a_2})); end end 
     if ___conditional___ == 3--[[ Psig_exception ]] then do
        a_3 = Curry._2(sub.extension_constructor, sub, desc[0]);
        return mk_5(loc, --[[ Psig_exception ]]Block.__(3, {a_3})); end end 
     if ___conditional___ == 4--[[ Psig_module ]] then do
        a_4 = Curry._2(sub.module_declaration, sub, desc[0]);
        return mk_5(loc, --[[ Psig_module ]]Block.__(4, {a_4})); end end 
     if ___conditional___ == 5--[[ Psig_recmodule ]] then do
        a_5 = List.map(Curry._1(sub.module_declaration, sub), desc[0]);
        return mk_5(loc, --[[ Psig_recmodule ]]Block.__(5, {a_5})); end end 
     if ___conditional___ == 6--[[ Psig_modtype ]] then do
        a_6 = Curry._2(sub.module_type_declaration, sub, desc[0]);
        return mk_5(loc, --[[ Psig_modtype ]]Block.__(6, {a_6})); end end 
     if ___conditional___ == 7--[[ Psig_open ]] then do
        a_7 = Curry._2(sub.open_description, sub, desc[0]);
        return mk_5(loc, --[[ Psig_open ]]Block.__(7, {a_7})); end end 
     if ___conditional___ == 8--[[ Psig_include ]] then do
        a_8 = Curry._2(sub.include_description, sub, desc[0]);
        return mk_5(loc, --[[ Psig_include ]]Block.__(8, {a_8})); end end 
     if ___conditional___ == 9--[[ Psig_class ]] then do
        a_9 = List.map(Curry._1(sub.class_description, sub), desc[0]);
        return mk_5(loc, --[[ Psig_class ]]Block.__(9, {a_9})); end end 
     if ___conditional___ == 10--[[ Psig_class_type ]] then do
        a_10 = List.map(Curry._1(sub.class_type_declaration, sub), desc[0]);
        return mk_5(loc, --[[ Psig_class_type ]]Block.__(10, {a_10})); end end 
     if ___conditional___ == 11--[[ Psig_attribute ]] then do
        a_11 = Curry._2(sub.attribute, sub, desc[0]);
        return mk_5(loc, --[[ Psig_attribute ]]Block.__(11, {a_11})); end end 
     if ___conditional___ == 12--[[ Psig_extension ]] then do
        return extension_5(loc, Curry._2(sub.attributes, sub, desc[1]), Curry._2(sub.extension, sub, desc[0])); end end 
    
  end
end end

function map_4(sub, param) do
  desc = param.pmod_desc;
  loc = Curry._2(sub.location, sub, param.pmod_loc);
  attrs = Curry._2(sub.attributes, sub, param.pmod_attributes);
  local ___conditional___=(desc.tag | 0);
  do
     if ___conditional___ == 0--[[ Pmod_ident ]] then do
        return ident_2(loc, attrs, map_loc(sub, desc[0])); end end 
     if ___conditional___ == 1--[[ Pmod_structure ]] then do
        return structure(loc, attrs, Curry._2(sub.structure, sub, desc[0])); end end 
     if ___conditional___ == 2--[[ Pmod_functor ]] then do
        return functor__1(loc, attrs, map_loc(sub, desc[0]), may_map(Curry._1(sub.module_type, sub), desc[1]), Curry._2(sub.module_expr, sub, desc[2])); end end 
     if ___conditional___ == 3--[[ Pmod_apply ]] then do
        return apply_1(loc, attrs, Curry._2(sub.module_expr, sub, desc[0]), Curry._2(sub.module_expr, sub, desc[1])); end end 
     if ___conditional___ == 4--[[ Pmod_constraint ]] then do
        return constraint__2(loc, attrs, Curry._2(sub.module_expr, sub, desc[0]), Curry._2(sub.module_type, sub, desc[1])); end end 
     if ___conditional___ == 5--[[ Pmod_unpack ]] then do
        return unpack_1(loc, attrs, Curry._2(sub.expr, sub, desc[0])); end end 
     if ___conditional___ == 6--[[ Pmod_extension ]] then do
        return extension_4(loc, attrs, Curry._2(sub.extension, sub, desc[0])); end end 
    
  end
end end

function map_structure_item(sub, param) do
  desc = param.pstr_desc;
  loc = Curry._2(sub.location, sub, param.pstr_loc);
  local ___conditional___=(desc.tag | 0);
  do
     if ___conditional___ == 0--[[ Pstr_eval ]] then do
        return __eval(loc, Curry._2(sub.attributes, sub, desc[1]), Curry._2(sub.expr, sub, desc[0])); end end 
     if ___conditional___ == 1--[[ Pstr_value ]] then do
        return value(loc, desc[0], List.map(Curry._1(sub.value_binding, sub), desc[1])); end end 
     if ___conditional___ == 2--[[ Pstr_primitive ]] then do
        a = Curry._2(sub.value_description, sub, desc[0]);
        return mk_6(loc, --[[ Pstr_primitive ]]Block.__(2, {a})); end end 
     if ___conditional___ == 3--[[ Pstr_type ]] then do
        a_1 = List.map(Curry._1(sub.type_declaration, sub), desc[0]);
        return mk_6(loc, --[[ Pstr_type ]]Block.__(3, {a_1})); end end 
     if ___conditional___ == 4--[[ Pstr_typext ]] then do
        a_2 = Curry._2(sub.type_extension, sub, desc[0]);
        return mk_6(loc, --[[ Pstr_typext ]]Block.__(4, {a_2})); end end 
     if ___conditional___ == 5--[[ Pstr_exception ]] then do
        a_3 = Curry._2(sub.extension_constructor, sub, desc[0]);
        return mk_6(loc, --[[ Pstr_exception ]]Block.__(5, {a_3})); end end 
     if ___conditional___ == 6--[[ Pstr_module ]] then do
        a_4 = Curry._2(sub.module_binding, sub, desc[0]);
        return mk_6(loc, --[[ Pstr_module ]]Block.__(6, {a_4})); end end 
     if ___conditional___ == 7--[[ Pstr_recmodule ]] then do
        a_5 = List.map(Curry._1(sub.module_binding, sub), desc[0]);
        return mk_6(loc, --[[ Pstr_recmodule ]]Block.__(7, {a_5})); end end 
     if ___conditional___ == 8--[[ Pstr_modtype ]] then do
        a_6 = Curry._2(sub.module_type_declaration, sub, desc[0]);
        return mk_6(loc, --[[ Pstr_modtype ]]Block.__(8, {a_6})); end end 
     if ___conditional___ == 9--[[ Pstr_open ]] then do
        a_7 = Curry._2(sub.open_description, sub, desc[0]);
        return mk_6(loc, --[[ Pstr_open ]]Block.__(9, {a_7})); end end 
     if ___conditional___ == 10--[[ Pstr_class ]] then do
        a_8 = List.map(Curry._1(sub.class_declaration, sub), desc[0]);
        return mk_6(loc, --[[ Pstr_class ]]Block.__(10, {a_8})); end end 
     if ___conditional___ == 11--[[ Pstr_class_type ]] then do
        a_9 = List.map(Curry._1(sub.class_type_declaration, sub), desc[0]);
        return mk_6(loc, --[[ Pstr_class_type ]]Block.__(11, {a_9})); end end 
     if ___conditional___ == 12--[[ Pstr_include ]] then do
        a_10 = Curry._2(sub.include_declaration, sub, desc[0]);
        return mk_6(loc, --[[ Pstr_include ]]Block.__(12, {a_10})); end end 
     if ___conditional___ == 13--[[ Pstr_attribute ]] then do
        a_11 = Curry._2(sub.attribute, sub, desc[0]);
        return mk_6(loc, --[[ Pstr_attribute ]]Block.__(13, {a_11})); end end 
     if ___conditional___ == 14--[[ Pstr_extension ]] then do
        return extension_6(loc, Curry._2(sub.attributes, sub, desc[1]), Curry._2(sub.extension, sub, desc[0])); end end 
    
  end
end end

function map_5(sub, param) do
  desc = param.pexp_desc;
  loc = Curry._2(sub.location, sub, param.pexp_loc);
  attrs = Curry._2(sub.attributes, sub, param.pexp_attributes);
  local ___conditional___=(desc.tag | 0);
  do
     if ___conditional___ == 0--[[ Pexp_ident ]] then do
        return Curry._3(Ast_helper_Exp.ident, loc, attrs, map_loc(sub, desc[0])); end end 
     if ___conditional___ == 1--[[ Pexp_constant ]] then do
        return Curry._3(Ast_helper_Exp.constant, loc, attrs, desc[0]); end end 
     if ___conditional___ == 2--[[ Pexp_let ]] then do
        return Curry._5(Ast_helper_Exp.let_, loc, attrs, desc[0], List.map(Curry._1(sub.value_binding, sub), desc[1]), Curry._2(sub.expr, sub, desc[2])); end end 
     if ___conditional___ == 3--[[ Pexp_function ]] then do
        return Curry._3(Ast_helper_Exp.function_, loc, attrs, Curry._2(sub.cases, sub, desc[0])); end end 
     if ___conditional___ == 4--[[ Pexp_fun ]] then do
        return Curry._6(Ast_helper_Exp.fun_, loc, attrs, desc[0], map_opt(Curry._1(sub.expr, sub), desc[1]), Curry._2(sub.pat, sub, desc[2]), Curry._2(sub.expr, sub, desc[3])); end end 
     if ___conditional___ == 5--[[ Pexp_apply ]] then do
        partial_arg = Curry._1(sub.expr, sub);
        return Curry._4(Ast_helper_Exp.apply, loc, attrs, Curry._2(sub.expr, sub, desc[0]), List.map((function(param) do
                          return map_snd(partial_arg, param);
                        end end), desc[1])); end end 
     if ___conditional___ == 6--[[ Pexp_match ]] then do
        return Curry._4(Ast_helper_Exp.match_, loc, attrs, Curry._2(sub.expr, sub, desc[0]), Curry._2(sub.cases, sub, desc[1])); end end 
     if ___conditional___ == 7--[[ Pexp_try ]] then do
        return Curry._4(Ast_helper_Exp.try_, loc, attrs, Curry._2(sub.expr, sub, desc[0]), Curry._2(sub.cases, sub, desc[1])); end end 
     if ___conditional___ == 8--[[ Pexp_tuple ]] then do
        return Curry._3(Ast_helper_Exp.tuple, loc, attrs, List.map(Curry._1(sub.expr, sub), desc[0])); end end 
     if ___conditional___ == 9--[[ Pexp_construct ]] then do
        return Curry._4(Ast_helper_Exp.construct, loc, attrs, map_loc(sub, desc[0]), map_opt(Curry._1(sub.expr, sub), desc[1])); end end 
     if ___conditional___ == 10--[[ Pexp_variant ]] then do
        return Curry._4(Ast_helper_Exp.variant, loc, attrs, desc[0], map_opt(Curry._1(sub.expr, sub), desc[1])); end end 
     if ___conditional___ == 11--[[ Pexp_record ]] then do
        partial_arg_1 = Curry._1(sub.expr, sub);
        return Curry._4(Ast_helper_Exp.record, loc, attrs, List.map((function(param) do
                          return map_tuple((function(param) do
                                        return map_loc(sub, param);
                                      end end), partial_arg_1, param);
                        end end), desc[0]), map_opt(Curry._1(sub.expr, sub), desc[1])); end end 
     if ___conditional___ == 12--[[ Pexp_field ]] then do
        return Curry._4(Ast_helper_Exp.field, loc, attrs, Curry._2(sub.expr, sub, desc[0]), map_loc(sub, desc[1])); end end 
     if ___conditional___ == 13--[[ Pexp_setfield ]] then do
        return Curry._5(Ast_helper_Exp.setfield, loc, attrs, Curry._2(sub.expr, sub, desc[0]), map_loc(sub, desc[1]), Curry._2(sub.expr, sub, desc[2])); end end 
     if ___conditional___ == 14--[[ Pexp_array ]] then do
        return Curry._3(Ast_helper_Exp.array, loc, attrs, List.map(Curry._1(sub.expr, sub), desc[0])); end end 
     if ___conditional___ == 15--[[ Pexp_ifthenelse ]] then do
        return Curry._5(Ast_helper_Exp.ifthenelse, loc, attrs, Curry._2(sub.expr, sub, desc[0]), Curry._2(sub.expr, sub, desc[1]), map_opt(Curry._1(sub.expr, sub), desc[2])); end end 
     if ___conditional___ == 16--[[ Pexp_sequence ]] then do
        return Curry._4(Ast_helper_Exp.sequence, loc, attrs, Curry._2(sub.expr, sub, desc[0]), Curry._2(sub.expr, sub, desc[1])); end end 
     if ___conditional___ == 17--[[ Pexp_while ]] then do
        return Curry._4(Ast_helper_Exp.while_, loc, attrs, Curry._2(sub.expr, sub, desc[0]), Curry._2(sub.expr, sub, desc[1])); end end 
     if ___conditional___ == 18--[[ Pexp_for ]] then do
        return Curry._7(Ast_helper_Exp.for_, loc, attrs, Curry._2(sub.pat, sub, desc[0]), Curry._2(sub.expr, sub, desc[1]), Curry._2(sub.expr, sub, desc[2]), desc[3], Curry._2(sub.expr, sub, desc[4])); end end 
     if ___conditional___ == 19--[[ Pexp_constraint ]] then do
        return Curry._4(Ast_helper_Exp.constraint_, loc, attrs, Curry._2(sub.expr, sub, desc[0]), Curry._2(sub.typ, sub, desc[1])); end end 
     if ___conditional___ == 20--[[ Pexp_coerce ]] then do
        return Curry._5(Ast_helper_Exp.coerce, loc, attrs, Curry._2(sub.expr, sub, desc[0]), map_opt(Curry._1(sub.typ, sub), desc[1]), Curry._2(sub.typ, sub, desc[2])); end end 
     if ___conditional___ == 21--[[ Pexp_send ]] then do
        return Curry._4(Ast_helper_Exp.send, loc, attrs, Curry._2(sub.expr, sub, desc[0]), desc[1]); end end 
     if ___conditional___ == 22--[[ Pexp_new ]] then do
        return Curry._3(Ast_helper_Exp.new_, loc, attrs, map_loc(sub, desc[0])); end end 
     if ___conditional___ == 23--[[ Pexp_setinstvar ]] then do
        return Curry._4(Ast_helper_Exp.setinstvar, loc, attrs, map_loc(sub, desc[0]), Curry._2(sub.expr, sub, desc[1])); end end 
     if ___conditional___ == 24--[[ Pexp_override ]] then do
        partial_arg_2 = Curry._1(sub.expr, sub);
        return Curry._3(Ast_helper_Exp.override, loc, attrs, List.map((function(param) do
                          return map_tuple((function(param) do
                                        return map_loc(sub, param);
                                      end end), partial_arg_2, param);
                        end end), desc[0])); end end 
     if ___conditional___ == 25--[[ Pexp_letmodule ]] then do
        return Curry._5(Ast_helper_Exp.letmodule, loc, attrs, map_loc(sub, desc[0]), Curry._2(sub.module_expr, sub, desc[1]), Curry._2(sub.expr, sub, desc[2])); end end 
     if ___conditional___ == 26--[[ Pexp_assert ]] then do
        return Curry._3(Ast_helper_Exp.assert_, loc, attrs, Curry._2(sub.expr, sub, desc[0])); end end 
     if ___conditional___ == 27--[[ Pexp_lazy ]] then do
        return Curry._3(Ast_helper_Exp.lazy_, loc, attrs, Curry._2(sub.expr, sub, desc[0])); end end 
     if ___conditional___ == 28--[[ Pexp_poly ]] then do
        return Curry._4(Ast_helper_Exp.poly, loc, attrs, Curry._2(sub.expr, sub, desc[0]), map_opt(Curry._1(sub.typ, sub), desc[1])); end end 
     if ___conditional___ == 29--[[ Pexp_object ]] then do
        return Curry._3(Ast_helper_Exp.object_, loc, attrs, Curry._2(sub.class_structure, sub, desc[0])); end end 
     if ___conditional___ == 30--[[ Pexp_newtype ]] then do
        return Curry._4(Ast_helper_Exp.newtype, loc, attrs, desc[0], Curry._2(sub.expr, sub, desc[1])); end end 
     if ___conditional___ == 31--[[ Pexp_pack ]] then do
        return Curry._3(Ast_helper_Exp.pack, loc, attrs, Curry._2(sub.module_expr, sub, desc[0])); end end 
     if ___conditional___ == 32--[[ Pexp_open ]] then do
        return Curry._5(Ast_helper_Exp.open_, loc, attrs, desc[0], map_loc(sub, desc[1]), Curry._2(sub.expr, sub, desc[2])); end end 
     if ___conditional___ == 33--[[ Pexp_extension ]] then do
        return Curry._3(Ast_helper_Exp.extension, loc, attrs, Curry._2(sub.extension, sub, desc[0])); end end 
    
  end
end end

function map_6(sub, param) do
  desc = param.ppat_desc;
  loc = Curry._2(sub.location, sub, param.ppat_loc);
  attrs = Curry._2(sub.attributes, sub, param.ppat_attributes);
  if (typeof desc == "number") then do
    return mk_1(loc, attrs, --[[ Ppat_any ]]0);
  end else do
    local ___conditional___=(desc.tag | 0);
    do
       if ___conditional___ == 0--[[ Ppat_var ]] then do
          return __var_1(loc, attrs, map_loc(sub, desc[0])); end end 
       if ___conditional___ == 1--[[ Ppat_alias ]] then do
          return alias_1(loc, attrs, Curry._2(sub.pat, sub, desc[0]), map_loc(sub, desc[1])); end end 
       if ___conditional___ == 2--[[ Ppat_constant ]] then do
          return constant(loc, attrs, desc[0]); end end 
       if ___conditional___ == 3--[[ Ppat_interval ]] then do
          return interval(loc, attrs, desc[0], desc[1]); end end 
       if ___conditional___ == 4--[[ Ppat_tuple ]] then do
          return tuple_1(loc, attrs, List.map(Curry._1(sub.pat, sub), desc[0])); end end 
       if ___conditional___ == 5--[[ Ppat_construct ]] then do
          return construct(loc, attrs, map_loc(sub, desc[0]), map_opt(Curry._1(sub.pat, sub), desc[1])); end end 
       if ___conditional___ == 6--[[ Ppat_variant ]] then do
          return variant_1(loc, attrs, desc[0], map_opt(Curry._1(sub.pat, sub), desc[1])); end end 
       if ___conditional___ == 7--[[ Ppat_record ]] then do
          partial_arg = Curry._1(sub.pat, sub);
          return record(loc, attrs, List.map((function(param) do
                            return map_tuple((function(param) do
                                          return map_loc(sub, param);
                                        end end), partial_arg, param);
                          end end), desc[0]), desc[1]); end end 
       if ___conditional___ == 8--[[ Ppat_array ]] then do
          return array(loc, attrs, List.map(Curry._1(sub.pat, sub), desc[0])); end end 
       if ___conditional___ == 9--[[ Ppat_or ]] then do
          return or_(loc, attrs, Curry._2(sub.pat, sub, desc[0]), Curry._2(sub.pat, sub, desc[1])); end end 
       if ___conditional___ == 10--[[ Ppat_constraint ]] then do
          return constraint_(loc, attrs, Curry._2(sub.pat, sub, desc[0]), Curry._2(sub.typ, sub, desc[1])); end end 
       if ___conditional___ == 11--[[ Ppat_type ]] then do
          return type_(loc, attrs, map_loc(sub, desc[0])); end end 
       if ___conditional___ == 12--[[ Ppat_lazy ]] then do
          return lazy_(loc, attrs, Curry._2(sub.pat, sub, desc[0])); end end 
       if ___conditional___ == 13--[[ Ppat_unpack ]] then do
          return unpack(loc, attrs, map_loc(sub, desc[0])); end end 
       if ___conditional___ == 14--[[ Ppat_exception ]] then do
          return exception_(loc, attrs, Curry._2(sub.pat, sub, desc[0])); end end 
       if ___conditional___ == 15--[[ Ppat_extension ]] then do
          return extension_1(loc, attrs, Curry._2(sub.extension, sub, desc[0])); end end 
      
    end
  end end 
end end

function map_7(sub, param) do
  desc = param.pcl_desc;
  loc = Curry._2(sub.location, sub, param.pcl_loc);
  attrs = Curry._2(sub.attributes, sub, param.pcl_attributes);
  local ___conditional___=(desc.tag | 0);
  do
     if ___conditional___ == 0--[[ Pcl_constr ]] then do
        return constr_1(loc, attrs, map_loc(sub, desc[0]), List.map(Curry._1(sub.typ, sub), desc[1])); end end 
     if ___conditional___ == 1--[[ Pcl_structure ]] then do
        return structure_1(loc, attrs, Curry._2(sub.class_structure, sub, desc[0])); end end 
     if ___conditional___ == 2--[[ Pcl_fun ]] then do
        return fun__1(loc, attrs, desc[0], map_opt(Curry._1(sub.expr, sub), desc[1]), Curry._2(sub.pat, sub, desc[2]), Curry._2(sub.class_expr, sub, desc[3])); end end 
     if ___conditional___ == 3--[[ Pcl_apply ]] then do
        partial_arg = Curry._1(sub.expr, sub);
        return apply_2(loc, attrs, Curry._2(sub.class_expr, sub, desc[0]), List.map((function(param) do
                          return map_snd(partial_arg, param);
                        end end), desc[1])); end end 
     if ___conditional___ == 4--[[ Pcl_let ]] then do
        return let__1(loc, attrs, desc[0], List.map(Curry._1(sub.value_binding, sub), desc[1]), Curry._2(sub.class_expr, sub, desc[2])); end end 
     if ___conditional___ == 5--[[ Pcl_constraint ]] then do
        return constraint__3(loc, attrs, Curry._2(sub.class_expr, sub, desc[0]), Curry._2(sub.class_type, sub, desc[1])); end end 
     if ___conditional___ == 6--[[ Pcl_extension ]] then do
        return extension_7(loc, attrs, Curry._2(sub.extension, sub, desc[0])); end end 
    
  end
end end

function map_kind(sub, param) do
  if (param.tag) then do
    return --[[ Cfk_concrete ]]Block.__(1, {
              param[0],
              Curry._2(sub.expr, sub, param[1])
            });
  end else do
    return --[[ Cfk_virtual ]]Block.__(0, {Curry._2(sub.typ, sub, param[0])});
  end end 
end end

function map_field_1(sub, param) do
  desc = param.pcf_desc;
  loc = Curry._2(sub.location, sub, param.pcf_loc);
  attrs = Curry._2(sub.attributes, sub, param.pcf_attributes);
  local ___conditional___=(desc.tag | 0);
  do
     if ___conditional___ == 0--[[ Pcf_inherit ]] then do
        return Curry._5(Ast_helper_Cf.inherit_, loc, attrs, desc[0], Curry._2(sub.class_expr, sub, desc[1]), desc[2]); end end 
     if ___conditional___ == 1--[[ Pcf_val ]] then do
        match = desc[0];
        return Curry._5(Ast_helper_Cf.val_, loc, attrs, map_loc(sub, match[0]), match[1], map_kind(sub, match[2])); end end 
     if ___conditional___ == 2--[[ Pcf_method ]] then do
        match_1 = desc[0];
        return Curry._5(Ast_helper_Cf.method_, loc, attrs, map_loc(sub, match_1[0]), match_1[1], map_kind(sub, match_1[2])); end end 
     if ___conditional___ == 3--[[ Pcf_constraint ]] then do
        match_2 = desc[0];
        return Curry._4(Ast_helper_Cf.constraint_, loc, attrs, Curry._2(sub.typ, sub, match_2[0]), Curry._2(sub.typ, sub, match_2[1])); end end 
     if ___conditional___ == 4--[[ Pcf_initializer ]] then do
        return Curry._3(Ast_helper_Cf.initializer_, loc, attrs, Curry._2(sub.expr, sub, desc[0])); end end 
     if ___conditional___ == 5--[[ Pcf_attribute ]] then do
        return Curry._2(Ast_helper_Cf.attribute, loc, Curry._2(sub.attribute, sub, desc[0])); end end 
     if ___conditional___ == 6--[[ Pcf_extension ]] then do
        return Curry._3(Ast_helper_Cf.extension, loc, attrs, Curry._2(sub.extension, sub, desc[0])); end end 
    
  end
end end

function map_structure(sub, param) do
  return do
          pcstr_self: Curry._2(sub.pat, sub, param.pcstr_self),
          pcstr_fields: List.map(Curry._1(sub.class_field, sub), param.pcstr_fields)
        end;
end end

function class_infos(sub, f, param) do
  partial_arg = Curry._1(sub.typ, sub);
  return mk_18(Curry._2(sub.location, sub, param.pci_loc), Curry._2(sub.attributes, sub, param.pci_attributes), undefined, undefined, param.pci_virt, List.map((function(param) do
                    return map_fst(partial_arg, param);
                  end end), param.pci_params), map_loc(sub, param.pci_name), Curry._1(f, param.pci_expr));
end end

function default_mapper_attribute(__this, param) do
  return --[[ tuple ]]{
          map_loc(__this, param[0]),
          Curry._2(__this.payload, __this, param[1])
        };
end end

function default_mapper_attributes(__this, l) do
  return List.map(Curry._1(__this.attribute, __this), l);
end end

function default_mapper_case(__this, param) do
  return do
          pc_lhs: Curry._2(__this.pat, __this, param.pc_lhs),
          pc_guard: map_opt(Curry._1(__this.expr, __this), param.pc_guard),
          pc_rhs: Curry._2(__this.expr, __this, param.pc_rhs)
        end;
end end

function default_mapper_cases(__this, l) do
  return List.map(Curry._1(__this.case, __this), l);
end end

function default_mapper_class_declaration(__this) do
  partial_arg = Curry._1(__this.class_expr, __this);
  return (function(param) do
      return class_infos(__this, partial_arg, param);
    end end);
end end

function default_mapper_class_description(__this) do
  partial_arg = Curry._1(__this.class_type, __this);
  return (function(param) do
      return class_infos(__this, partial_arg, param);
    end end);
end end

function default_mapper_class_type_declaration(__this) do
  partial_arg = Curry._1(__this.class_type, __this);
  return (function(param) do
      return class_infos(__this, partial_arg, param);
    end end);
end end

function default_mapper_constructor_declaration(__this, param) do
  return constructor(Curry._2(__this.location, __this, param.pcd_loc), Curry._2(__this.attributes, __this, param.pcd_attributes), undefined, List.map(Curry._1(__this.typ, __this), param.pcd_args), map_opt(Curry._1(__this.typ, __this), param.pcd_res), map_loc(__this, param.pcd_name));
end end

function default_mapper_extension(__this, param) do
  return --[[ tuple ]]{
          map_loc(__this, param[0]),
          Curry._2(__this.payload, __this, param[1])
        };
end end

function default_mapper_include_declaration(__this, param) do
  return mk_16(Curry._2(__this.location, __this, param.pincl_loc), Curry._2(__this.attributes, __this, param.pincl_attributes), undefined, Curry._2(__this.module_expr, __this, param.pincl_mod));
end end

function default_mapper_include_description(__this, param) do
  return mk_16(Curry._2(__this.location, __this, param.pincl_loc), Curry._2(__this.attributes, __this, param.pincl_attributes), undefined, Curry._2(__this.module_type, __this, param.pincl_mod));
end end

function default_mapper_label_declaration(__this, param) do
  return field_1(Curry._2(__this.location, __this, param.pld_loc), Curry._2(__this.attributes, __this, param.pld_attributes), undefined, param.pld_mutable, map_loc(__this, param.pld_name), Curry._2(__this.typ, __this, param.pld_type));
end end

function default_mapper_location(__this, l) do
  return l;
end end

function default_mapper_module_binding(__this, param) do
  return mk_14(Curry._2(__this.location, __this, param.pmb_loc), Curry._2(__this.attributes, __this, param.pmb_attributes), undefined, undefined, map_loc(__this, param.pmb_name), Curry._2(__this.module_expr, __this, param.pmb_expr));
end end

function default_mapper_module_declaration(__this, param) do
  return mk_12(Curry._2(__this.location, __this, param.pmd_loc), Curry._2(__this.attributes, __this, param.pmd_attributes), undefined, undefined, map_loc(__this, param.pmd_name), Curry._2(__this.module_type, __this, param.pmd_type));
end end

function default_mapper_module_type_declaration(__this, param) do
  return mk_13(Curry._2(__this.location, __this, param.pmtd_loc), Curry._2(__this.attributes, __this, param.pmtd_attributes), undefined, undefined, map_opt(Curry._1(__this.module_type, __this), param.pmtd_type), map_loc(__this, param.pmtd_name));
end end

function default_mapper_open_description(__this, param) do
  return mk_15(Curry._2(__this.location, __this, param.popen_loc), Curry._2(__this.attributes, __this, param.popen_attributes), undefined, param.popen_override, map_loc(__this, param.popen_lid));
end end

function default_mapper_payload(__this, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ PStr ]] then do
        return --[[ PStr ]]Block.__(0, {Curry._2(__this.structure, __this, param[0])}); end end 
     if ___conditional___ == 1--[[ PTyp ]] then do
        return --[[ PTyp ]]Block.__(1, {Curry._2(__this.typ, __this, param[0])}); end end 
     if ___conditional___ == 2--[[ PPat ]] then do
        return --[[ PPat ]]Block.__(2, {
                  Curry._2(__this.pat, __this, param[0]),
                  map_opt(Curry._1(__this.expr, __this), param[1])
                }); end end 
    
  end
end end

function default_mapper_signature(__this, l) do
  return List.map(Curry._1(__this.signature_item, __this), l);
end end

function default_mapper_structure(__this, l) do
  return List.map(Curry._1(__this.structure_item, __this), l);
end end

function default_mapper_value_binding(__this, param) do
  return mk_17(Curry._2(__this.location, __this, param.pvb_loc), Curry._2(__this.attributes, __this, param.pvb_attributes), undefined, undefined, Curry._2(__this.pat, __this, param.pvb_pat), Curry._2(__this.expr, __this, param.pvb_expr));
end end

function default_mapper_value_description(__this, param) do
  return mk_11(Curry._2(__this.location, __this, param.pval_loc), Curry._2(__this.attributes, __this, param.pval_attributes), undefined, param.pval_prim, map_loc(__this, param.pval_name), Curry._2(__this.typ, __this, param.pval_type));
end end

default_mapper = do
  attribute: default_mapper_attribute,
  attributes: default_mapper_attributes,
  case: default_mapper_case,
  cases: default_mapper_cases,
  class_declaration: default_mapper_class_declaration,
  class_description: default_mapper_class_description,
  class_expr: map_7,
  class_field: map_field_1,
  class_signature: map_signature,
  class_structure: map_structure,
  class_type: map_2,
  class_type_declaration: default_mapper_class_type_declaration,
  class_type_field: map_field,
  constructor_declaration: default_mapper_constructor_declaration,
  expr: map_5,
  extension: default_mapper_extension,
  extension_constructor: map_extension_constructor,
  include_declaration: default_mapper_include_declaration,
  include_description: default_mapper_include_description,
  label_declaration: default_mapper_label_declaration,
  location: default_mapper_location,
  module_binding: default_mapper_module_binding,
  module_declaration: default_mapper_module_declaration,
  module_expr: map_4,
  module_type: map_3,
  module_type_declaration: default_mapper_module_type_declaration,
  open_description: default_mapper_open_description,
  pat: map_6,
  payload: default_mapper_payload,
  signature: default_mapper_signature,
  signature_item: map_signature_item,
  structure: default_mapper_structure,
  structure_item: map_structure_item,
  typ: map_1,
  type_declaration: map_type_declaration,
  type_extension: map_type_extension,
  type_kind: map_type_kind,
  value_binding: default_mapper_value_binding,
  value_description: default_mapper_value_description,
  with_constraint: map_with_constraint
end;

function height_4(param) do
  if (param) then do
    return param[4];
  end else do
    return 0;
  end end 
end end

function create_5(l, x, d, r) do
  hl = height_4(l);
  hr = height_4(r);
  return --[[ Node ]]{
          l,
          x,
          d,
          r,
          hl >= hr and hl + 1 | 0 or hr + 1 | 0
        };
end end

function bal_4(l, x, d, r) do
  hl = height_4(l);
  hr = height_4(r);
  if (hl > (hr + 1 | 0)) then do
    if (l) then do
      lr = l[3];
      ld = l[2];
      lv = l[1];
      ll = l[0];
      if (height_4(ll) >= height_4(lr)) then do
        return create_5(ll, lv, ld, create_5(lr, x, d, r));
      end else if (lr) then do
        return create_5(create_5(ll, lv, ld, lr[0]), lr[1], lr[2], create_5(lr[3], x, d, r));
      end else do
        error({
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "tbl.ml",
            35,
            11
          }
        })
      end end  end 
    end else do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "tbl.ml",
          35,
          11
        }
      })
    end end 
  end else if (hr > (hl + 1 | 0)) then do
    if (r) then do
      rl = r[0];
      rr = r[3];
      if (height_4(rr) >= height_4(rl)) then do
        return create_5(create_5(l, x, d, rl), r[1], r[2], rr);
      end else if (rl) then do
        return create_5(create_5(l, x, d, rl[0]), rl[1], rl[2], create_5(rl[3], r[1], r[2], r[3]));
      end else do
        error({
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "tbl.ml",
            42,
            11
          }
        })
      end end  end 
    end else do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "tbl.ml",
          42,
          11
        }
      })
    end end 
  end else do
    return create_5(l, x, d, r);
  end end  end 
end end

function add_5(x, data, param) do
  if (param) then do
    r = param[3];
    d = param[2];
    v = param[1];
    l = param[0];
    c = Caml_obj.caml_compare(x, v);
    if (c == 0) then do
      return --[[ Node ]]{
              l,
              x,
              data,
              r,
              param[4]
            };
    end else if (c < 0) then do
      return bal_4(add_5(x, data, l), v, d, r);
    end else do
      return bal_4(l, v, d, add_5(x, data, r));
    end end  end 
  end else do
    return --[[ Node ]]{
            --[[ Empty ]]0,
            x,
            data,
            --[[ Empty ]]0,
            1
          };
  end end 
end end

function find_2(x, _param) do
  while(true) do
    param = _param;
    if (param) then do
      c = Caml_obj.caml_compare(x, param[1]);
      if (c == 0) then do
        return param[2];
      end else do
        _param = c < 0 and param[0] or param[3];
        ::continue:: ;
      end end 
    end else do
      error(Caml_builtin_exceptions.not_found)
    end end 
  end;
end end

function mem_4(x, _param) do
  while(true) do
    param = _param;
    if (param) then do
      c = Caml_obj.caml_compare(x, param[1]);
      if (c == 0) then do
        return true;
      end else do
        _param = c < 0 and param[0] or param[3];
        ::continue:: ;
      end end 
    end else do
      return false;
    end end 
  end;
end end

function iter_2(f, _param) do
  while(true) do
    param = _param;
    if (param) then do
      iter_2(f, param[0]);
      Curry._2(f, param[1], param[2]);
      _param = param[3];
      ::continue:: ;
    end else do
      return --[[ () ]]0;
    end end 
  end;
end end

function fold_4(f, _m, _accu) do
  while(true) do
    accu = _accu;
    m = _m;
    if (m) then do
      _accu = Curry._3(f, m[1], m[2], fold_4(f, m[0], accu));
      _m = m[3];
      ::continue:: ;
    end else do
      return accu;
    end end 
  end;
end end

identity = do
  types: --[[ Empty ]]0,
  modules: --[[ Empty ]]0,
  modtypes: --[[ Empty ]]0,
  for_saving: false
end;

function add_type(id, p, s) do
  return do
          types: add_5(id, p, s.types),
          modules: s.modules,
          modtypes: s.modtypes,
          for_saving: s.for_saving
        end;
end end

function add_module(id, p, s) do
  return do
          types: s.types,
          modules: add_5(id, p, s.modules),
          modtypes: s.modtypes,
          for_saving: s.for_saving
        end;
end end

function add_modtype(id, ty, s) do
  return do
          types: s.types,
          modules: s.modules,
          modtypes: add_5(id, ty, s.modtypes),
          for_saving: s.for_saving
        end;
end end

function for_saving(s) do
  return do
          types: s.types,
          modules: s.modules,
          modtypes: s.modtypes,
          for_saving: true
        end;
end end

function loc(s, x) do
  if (s.for_saving and not keep_locs.contents) then do
    return none;
  end else do
    return x;
  end end 
end end

newrecord = Caml_obj.caml_obj_dup(default_mapper);

newrecord.location = (function(_this, _loc) do
    return none;
  end end);

function is_not_doc(param) do
  local ___conditional___=(param[0].txt);
  do
     if ___conditional___ == "doc"
     or ___conditional___ == "ocaml.doc"
     or ___conditional___ == "ocaml.text"
     or ___conditional___ == "text" then do
        return false; end end 
    return true;
      
  end
end end

function attrs(s, x) do
  x_1 = s.for_saving and not keep_docs.contents and List.filter(is_not_doc)(x) or x;
  if (s.for_saving and not keep_locs.contents) then do
    return Curry._2(newrecord.attributes, newrecord, x_1);
  end else do
    return x_1;
  end end 
end end

function module_path(s, p) do
  local ___conditional___=(p.tag | 0);
  do
     if ___conditional___ == 0--[[ Pident ]] then do
        xpcall(function() do
          return find_2(p[0], s.modules);
        end end,function(exn) do
          if (exn == Caml_builtin_exceptions.not_found) then do
            return p;
          end else do
            error(exn)
          end end 
        end end) end end 
     if ___conditional___ == 1--[[ Pdot ]] then do
        return --[[ Pdot ]]Block.__(1, {
                  module_path(s, p[0]),
                  p[1],
                  p[2]
                }); end end 
     if ___conditional___ == 2--[[ Papply ]] then do
        return --[[ Papply ]]Block.__(2, {
                  module_path(s, p[0]),
                  module_path(s, p[1])
                }); end end 
    
  end
end end

function modtype_path(s, p) do
  local ___conditional___=(p.tag | 0);
  do
     if ___conditional___ == 0--[[ Pident ]] then do
        xpcall(function() do
          match = find_2(p[0], s.modtypes);
          if (match.tag) then do
            return fatal_error("Subst.modtype_path");
          end else do
            return match[0];
          end end 
        end end,function(exn) do
          if (exn == Caml_builtin_exceptions.not_found) then do
            return p;
          end else do
            error(exn)
          end end 
        end end) end end 
     if ___conditional___ == 1--[[ Pdot ]] then do
        return --[[ Pdot ]]Block.__(1, {
                  module_path(s, p[0]),
                  p[1],
                  p[2]
                }); end end 
     if ___conditional___ == 2--[[ Papply ]] then do
        return fatal_error("Subst.modtype_path"); end end 
    
  end
end end

function type_path(s, p) do
  local ___conditional___=(p.tag | 0);
  do
     if ___conditional___ == 0--[[ Pident ]] then do
        xpcall(function() do
          return find_2(p[0], s.types);
        end end,function(exn) do
          if (exn == Caml_builtin_exceptions.not_found) then do
            return p;
          end else do
            error(exn)
          end end 
        end end) end end 
     if ___conditional___ == 1--[[ Pdot ]] then do
        return --[[ Pdot ]]Block.__(1, {
                  module_path(s, p[0]),
                  p[1],
                  p[2]
                }); end end 
     if ___conditional___ == 2--[[ Papply ]] then do
        return fatal_error("Subst.type_path"); end end 
    
  end
end end

new_id_1 = do
  contents: -1
end;

function newpersty(desc) do
  new_id_1.contents = new_id_1.contents - 1 | 0;
  return do
          desc: desc,
          level: 100000000,
          id: new_id_1.contents
        end;
end end

function norm(d) do
  if (typeof d == "number") then do
    return d;
  end else do
    local ___conditional___=(d.tag | 0);
    do
       if ___conditional___ == 0--[[ Tvar ]] then do
          if (d[0] ~= undefined) then do
            return d;
          end else do
            return --[[ Tvar ]]Block.__(0, {undefined});
          end end  end end 
       if ___conditional___ == 9--[[ Tunivar ]] then do
          if (d[0] ~= undefined) then do
            return d;
          end else do
            return --[[ Tunivar ]]Block.__(9, {undefined});
          end end  end end 
      return d;
        
    end
  end end 
end end

function typexp(s, ty) do
  ty_1 = repr(ty);
  desc = ty_1.desc;
  exit = 0;
  if (typeof desc == "number") then do
    exit = 1;
  end else do
    local ___conditional___=(desc.tag | 0);
    do
       if ___conditional___ == 7--[[ Tsubst ]] then do
          return desc[0]; end end 
       if ___conditional___ == 0--[[ Tvar ]]
       or ___conditional___ == 9--[[ Tunivar ]] then do
          exit = 2; end else 
       end end
      exit = 1;
        
    end
  end end 
  local ___conditional___=(exit);
  do
     if ___conditional___ == 1 then do
        desc_1 = ty_1.desc;
        save_desc(ty_1, desc_1);
        ty$prime = s.for_saving and newpersty(--[[ Tvar ]]Block.__(0, {undefined})) or newty2(100000000, --[[ Tvar ]]Block.__(0, {undefined}));
        ty_1.desc = --[[ Tsubst ]]Block.__(7, {ty$prime});
        tmp;
        exit_1 = 0;
        if (typeof desc_1 == "number") then do
          exit_1 = 3;
        end else do
          local ___conditional___=(desc_1.tag | 0);
          do
             if ___conditional___ == 3--[[ Tconstr ]] then do
                tmp = --[[ Tconstr ]]Block.__(3, {
                    type_path(s, desc_1[0]),
                    List.map((function(param) do
                            return typexp(s, param);
                          end end), desc_1[1]),
                    do
                      contents: --[[ Mnil ]]0
                    end
                  }); end else 
             if ___conditional___ == 4--[[ Tobject ]] then do
                match = desc_1[1].contents;
                tmp_1;
                if (match ~= undefined) then do
                  match_1 = match;
                  tmp_1 = --[[ tuple ]]{
                    type_path(s, match_1[0]),
                    List.map((function(param) do
                            return typexp(s, param);
                          end end), match_1[1])
                  };
                end else do
                  tmp_1 = undefined;
                end end 
                tmp = --[[ Tobject ]]Block.__(4, {
                    typexp(s, desc_1[0]),
                    do
                      contents: tmp_1
                    end
                  }); end else 
             if ___conditional___ == 5--[[ Tfield ]] then do
                t2 = desc_1[3];
                k = desc_1[1];
                m = desc_1[0];
                if (s == identity and ty_1.level < 100000000 and m == dummy_method) then do
                  tmp = --[[ Tfield ]]Block.__(5, {
                      m,
                      k,
                      desc_1[2],
                      typexp(s, t2)
                    });
                end else if (field_kind_repr(k) == --[[ Fabsent ]]1) then do
                  tmp = --[[ Tlink ]]Block.__(6, {typexp(s, t2)});
                end else do
                  exit_1 = 3;
                end end  end  end else 
             if ___conditional___ == 8--[[ Tvariant ]] then do
                row = row_repr_aux(--[[ [] ]]0, desc_1[0]);
                more = repr(row.row_more);
                match_2 = more.desc;
                exit_2 = 0;
                if (typeof match_2 == "number" or match_2.tag ~= --[[ Tsubst ]]7) then do
                  exit_2 = 4;
                end else do
                  match_3 = match_2[0].desc;
                  if (typeof match_3 == "number" or match_3.tag ~= --[[ Ttuple ]]2) then do
                    exit_2 = 4;
                  end else do
                    match_4 = match_3[0];
                    if (match_4) then do
                      match_5 = match_4[1];
                      if (match_5 and not match_5[1]) then do
                        ty2 = match_5[0];
                        ty_1.desc = --[[ Tsubst ]]Block.__(7, {ty2});
                        tmp = --[[ Tlink ]]Block.__(6, {ty2});
                      end else do
                        exit_2 = 4;
                      end end 
                    end else do
                      exit_2 = 4;
                    end end 
                  end end 
                end end 
                if (exit_2 == 4) then do
                  dup = true;
                  if (not s.for_saving) then do
                    tmp_2 = true;
                    if (more.level ~= 100000000) then do
                      tmp_3 = true;
                      if (not static_row(row)) then do
                        match_6 = more.desc;
                        tmp_4;
                        tmp_4 = typeof match_6 == "number" or match_6.tag ~= --[[ Tconstr ]]3 and false or true;
                        tmp_3 = tmp_4;
                      end
                       end 
                      tmp_2 = tmp_3;
                    end
                     end 
                    dup = tmp_2;
                  end
                   end 
                  match_7 = more.desc;
                  more$prime;
                  exit_3 = 0;
                  if (typeof match_7 == "number") then do
                    more$prime = typexp(s, more);
                  end else do
                    local ___conditional___=(match_7.tag | 0);
                    do
                       if ___conditional___ == 3--[[ Tconstr ]] then do
                          more$prime = typexp(s, more); end else 
                       if ___conditional___ == 7--[[ Tsubst ]] then do
                          more$prime = match_7[0]; end else 
                       if ___conditional___ == 0--[[ Tvar ]]
                       or ___conditional___ == 9--[[ Tunivar ]] then do
                          exit_3 = 5; end else 
                       end end end end end end
                      error({
                          Caml_builtin_exceptions.assert_failure,
                          --[[ tuple ]]{
                            "subst.ml",
                            170,
                            23
                          }
                        })
                        
                    end
                  end end 
                  if (exit_3 == 5) then do
                    save_desc(more, more.desc);
                    more$prime = s.for_saving and newpersty(norm(more.desc)) or (
                        dup and is_Tvar(more) and newty2(100000000, more.desc) or more
                      );
                  end
                   end 
                  more.desc = --[[ Tsubst ]]Block.__(7, {newty2(100000000, --[[ Ttuple ]]Block.__(2, {--[[ :: ]]{
                                more$prime,
                                --[[ :: ]]{
                                  ty$prime,
                                  --[[ [] ]]0
                                }
                              }}))});
                  row_1 = copy_row((function(param) do
                          return typexp(s, param);
                        end end), true, row, not dup, more$prime);
                  match_8 = row_1.row_name;
                  if (match_8 ~= undefined) then do
                    match_9 = match_8;
                    tmp = --[[ Tvariant ]]Block.__(8, {do
                          row_fields: row_1.row_fields,
                          row_more: row_1.row_more,
                          row_bound: row_1.row_bound,
                          row_closed: row_1.row_closed,
                          row_fixed: row_1.row_fixed,
                          row_name: --[[ tuple ]]{
                            type_path(s, match_9[0]),
                            match_9[1]
                          }
                        end});
                  end else do
                    tmp = --[[ Tvariant ]]Block.__(8, {row_1});
                  end end 
                end
                 end  end else 
             if ___conditional___ == 11--[[ Tpackage ]] then do
                tmp = --[[ Tpackage ]]Block.__(11, {
                    modtype_path(s, desc_1[0]),
                    desc_1[1],
                    List.map((function(param) do
                            return typexp(s, param);
                          end end), desc_1[2])
                  }); end else 
             end end end end end end end end end end
            exit_1 = 3;
              
          end
        end end 
        if (exit_1 == 3) then do
          tmp = copy_type_desc(undefined, (function(param) do
                  return typexp(s, param);
                end end), desc_1);
        end
         end 
        ty$prime.desc = tmp;
        return ty$prime; end end 
     if ___conditional___ == 2 then do
        if (s.for_saving or ty_1.id < 0) then do
          ty$prime_1 = s.for_saving and newpersty(norm(desc)) or newty2(ty_1.level, desc);
          save_desc(ty_1, desc);
          ty_1.desc = --[[ Tsubst ]]Block.__(7, {ty$prime_1});
          return ty$prime_1;
        end else do
          return ty_1;
        end end  end end 
    
  end
end end

function type_expr(s, ty) do
  ty$prime = typexp(s, ty);
  cleanup_types(--[[ () ]]0);
  return ty$prime;
end end

function type_declaration(s, decl) do
  match = decl.type_kind;
  tmp;
  tmp = typeof match == "number" and (
      match == --[[ Type_abstract ]]0 and --[[ Type_abstract ]]0 or --[[ Type_open ]]1
    ) or (
      match.tag and --[[ Type_variant ]]Block.__(1, {List.map((function(c) do
                    return do
                            cd_id: c.cd_id,
                            cd_args: List.map((function(param) do
                                    return typexp(s, param);
                                  end end), c.cd_args),
                            cd_res: may_map((function(param) do
                                    return typexp(s, param);
                                  end end), c.cd_res),
                            cd_loc: loc(s, c.cd_loc),
                            cd_attributes: attrs(s, c.cd_attributes)
                          end;
                  end end), match[0])}) or --[[ Type_record ]]Block.__(0, {
            List.map((function(l) do
                    return do
                            ld_id: l.ld_id,
                            ld_mutable: l.ld_mutable,
                            ld_type: typexp(s, l.ld_type),
                            ld_loc: loc(s, l.ld_loc),
                            ld_attributes: attrs(s, l.ld_attributes)
                          end;
                  end end), match[0]),
            match[1]
          })
    );
  match_1 = decl.type_manifest;
  decl_type_params = List.map((function(param) do
          return typexp(s, param);
        end end), decl.type_params);
  decl_type_arity = decl.type_arity;
  decl_type_private = decl.type_private;
  decl_type_manifest = match_1 ~= undefined and typexp(s, match_1) or undefined;
  decl_type_variance = decl.type_variance;
  decl_type_loc = loc(s, decl.type_loc);
  decl_type_attributes = attrs(s, decl.type_attributes);
  decl_1 = do
    type_params: decl_type_params,
    type_arity: decl_type_arity,
    type_kind: tmp,
    type_private: decl_type_private,
    type_manifest: decl_type_manifest,
    type_variance: decl_type_variance,
    type_newtype_level: undefined,
    type_loc: decl_type_loc,
    type_attributes: decl_type_attributes
  end;
  cleanup_types(--[[ () ]]0);
  return decl_1;
end end

function class_signature(s, sign) do
  return do
          csig_self: typexp(s, sign.csig_self),
          csig_vars: map((function(param) do
                  return --[[ tuple ]]{
                          param[0],
                          param[1],
                          typexp(s, param[2])
                        };
                end end), sign.csig_vars),
          csig_concr: sign.csig_concr,
          csig_inher: List.map((function(param) do
                  return --[[ tuple ]]{
                          type_path(s, param[0]),
                          List.map((function(param) do
                                  return typexp(s, param);
                                end end), param[1])
                        };
                end end), sign.csig_inher)
        end;
end end

function class_type(s, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Cty_constr ]] then do
        return --[[ Cty_constr ]]Block.__(0, {
                  type_path(s, param[0]),
                  List.map((function(param) do
                          return typexp(s, param);
                        end end), param[1]),
                  class_type(s, param[2])
                }); end end 
     if ___conditional___ == 1--[[ Cty_signature ]] then do
        return --[[ Cty_signature ]]Block.__(1, {class_signature(s, param[0])}); end end 
     if ___conditional___ == 2--[[ Cty_arrow ]] then do
        return --[[ Cty_arrow ]]Block.__(2, {
                  param[0],
                  typexp(s, param[1]),
                  class_type(s, param[2])
                }); end end 
    
  end
end end

function class_declaration(s, decl) do
  match = decl.cty_new;
  decl_1 = do
    cty_params: List.map((function(param) do
            return typexp(s, param);
          end end), decl.cty_params),
    cty_type: class_type(s, decl.cty_type),
    cty_path: type_path(s, decl.cty_path),
    cty_new: match ~= undefined and typexp(s, match) or undefined,
    cty_variance: decl.cty_variance,
    cty_loc: loc(s, decl.cty_loc),
    cty_attributes: attrs(s, decl.cty_attributes)
  end;
  if (not s.for_saving) then do
    cleanup_types(--[[ () ]]0);
  end
   end 
  return decl_1;
end end

function cltype_declaration(s, decl) do
  decl_clty_params = List.map((function(param) do
          return typexp(s, param);
        end end), decl.clty_params);
  decl_clty_type = class_type(s, decl.clty_type);
  decl_clty_path = type_path(s, decl.clty_path);
  decl_clty_variance = decl.clty_variance;
  decl_clty_loc = loc(s, decl.clty_loc);
  decl_clty_attributes = attrs(s, decl.clty_attributes);
  decl_1 = do
    clty_params: decl_clty_params,
    clty_type: decl_clty_type,
    clty_path: decl_clty_path,
    clty_variance: decl_clty_variance,
    clty_loc: decl_clty_loc,
    clty_attributes: decl_clty_attributes
  end;
  cleanup_types(--[[ () ]]0);
  return decl_1;
end end

function class_type_1(s, cty) do
  cty_1 = class_type(s, cty);
  cleanup_types(--[[ () ]]0);
  return cty_1;
end end

function value_description(s, descr) do
  return do
          val_type: type_expr(s, descr.val_type),
          val_kind: descr.val_kind,
          val_loc: loc(s, descr.val_loc),
          val_attributes: attrs(s, descr.val_attributes)
        end;
end end

function extension_constructor(s, ext) do
  ext_ext_type_path = type_path(s, ext.ext_type_path);
  ext_ext_type_params = List.map((function(param) do
          return typexp(s, param);
        end end), ext.ext_type_params);
  ext_ext_args = List.map((function(param) do
          return typexp(s, param);
        end end), ext.ext_args);
  ext_ext_ret_type = may_map((function(param) do
          return typexp(s, param);
        end end), ext.ext_ret_type);
  ext_ext_private = ext.ext_private;
  ext_ext_loc = s.for_saving and none or ext.ext_loc;
  ext_ext_attributes = attrs(s, ext.ext_attributes);
  ext_1 = do
    ext_type_path: ext_ext_type_path,
    ext_type_params: ext_ext_type_params,
    ext_args: ext_ext_args,
    ext_ret_type: ext_ext_ret_type,
    ext_private: ext_ext_private,
    ext_loc: ext_ext_loc,
    ext_attributes: ext_ext_attributes
  end;
  cleanup_types(--[[ () ]]0);
  return ext_1;
end end

function rename_bound_idents(_s, _idents, _param) do
  while(true) do
    param = _param;
    idents = _idents;
    s = _s;
    if (param) then do
      match = param[0];
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 1--[[ Sig_type ]] then do
            id = match[0];
            id$prime = rename(id);
            _param = param[1];
            _idents = --[[ :: ]]{
              id$prime,
              idents
            };
            _s = add_type(id, --[[ Pident ]]Block.__(0, {id$prime}), s);
            ::continue:: ; end end 
         if ___conditional___ == 3--[[ Sig_module ]] then do
            id_1 = match[0];
            id$prime_1 = rename(id_1);
            _param = param[1];
            _idents = --[[ :: ]]{
              id$prime_1,
              idents
            };
            _s = add_module(id_1, --[[ Pident ]]Block.__(0, {id$prime_1}), s);
            ::continue:: ; end end 
         if ___conditional___ == 4--[[ Sig_modtype ]] then do
            id_2 = match[0];
            id$prime_2 = rename(id_2);
            _param = param[1];
            _idents = --[[ :: ]]{
              id$prime_2,
              idents
            };
            _s = add_modtype(id_2, --[[ Mty_ident ]]Block.__(0, {--[[ Pident ]]Block.__(0, {id$prime_2})}), s);
            ::continue:: ; end end 
        id$prime_3 = rename(match[0]);
          _param = param[1];
          _idents = --[[ :: ]]{
            id$prime_3,
            idents
          };
          ::continue:: ;
          
      end
    end else do
      return --[[ tuple ]]{
              List.rev(idents),
              s
            };
    end end 
  end;
end end

function modtype(s, mty) do
  local ___conditional___=(mty.tag | 0);
  do
     if ___conditional___ == 0--[[ Mty_ident ]] then do
        p = mty[0];
        local ___conditional___=(p.tag | 0);
        do
           if ___conditional___ == 0--[[ Pident ]] then do
              xpcall(function() do
                return find_2(p[0], s.modtypes);
              end end,function(exn) do
                if (exn == Caml_builtin_exceptions.not_found) then do
                  return mty;
                end else do
                  error(exn)
                end end 
              end end) end end 
           if ___conditional___ == 1--[[ Pdot ]] then do
              return --[[ Mty_ident ]]Block.__(0, {--[[ Pdot ]]Block.__(1, {
                            module_path(s, p[0]),
                            p[1],
                            p[2]
                          })}); end end 
           if ___conditional___ == 2--[[ Papply ]] then do
              return fatal_error("Subst.modtype"); end end 
          
        end end end 
     if ___conditional___ == 1--[[ Mty_signature ]] then do
        return --[[ Mty_signature ]]Block.__(1, {signature_2(s, mty[0])}); end end 
     if ___conditional___ == 2--[[ Mty_functor ]] then do
        id = mty[0];
        id$prime = rename(id);
        return --[[ Mty_functor ]]Block.__(2, {
                  id$prime,
                  may_map((function(param) do
                          return modtype(s, param);
                        end end), mty[1]),
                  modtype(add_module(id, --[[ Pident ]]Block.__(0, {id$prime}), s), mty[2])
                }); end end 
     if ___conditional___ == 3--[[ Mty_alias ]] then do
        return --[[ Mty_alias ]]Block.__(3, {module_path(s, mty[0])}); end end 
    
  end
end end

function signature_2(s, sg) do
  match = rename_bound_idents(s, --[[ [] ]]0, sg);
  s$prime = match[1];
  return List.map2((function(param, param_1) do
                s = s$prime;
                comp = param;
                newid = param_1;
                local ___conditional___=(comp.tag | 0);
                do
                   if ___conditional___ == 0--[[ Sig_value ]] then do
                      return --[[ Sig_value ]]Block.__(0, {
                                newid,
                                value_description(s, comp[1])
                              }); end end 
                   if ___conditional___ == 1--[[ Sig_type ]] then do
                      return --[[ Sig_type ]]Block.__(1, {
                                newid,
                                type_declaration(s, comp[1]),
                                comp[2]
                              }); end end 
                   if ___conditional___ == 2--[[ Sig_typext ]] then do
                      return --[[ Sig_typext ]]Block.__(2, {
                                newid,
                                extension_constructor(s, comp[1]),
                                comp[2]
                              }); end end 
                   if ___conditional___ == 3--[[ Sig_module ]] then do
                      return --[[ Sig_module ]]Block.__(3, {
                                newid,
                                module_declaration(s, comp[1]),
                                comp[2]
                              }); end end 
                   if ___conditional___ == 4--[[ Sig_modtype ]] then do
                      return --[[ Sig_modtype ]]Block.__(4, {
                                newid,
                                modtype_declaration(s, comp[1])
                              }); end end 
                   if ___conditional___ == 5--[[ Sig_class ]] then do
                      return --[[ Sig_class ]]Block.__(5, {
                                newid,
                                class_declaration(s, comp[1]),
                                comp[2]
                              }); end end 
                   if ___conditional___ == 6--[[ Sig_class_type ]] then do
                      return --[[ Sig_class_type ]]Block.__(6, {
                                newid,
                                cltype_declaration(s, comp[1]),
                                comp[2]
                              }); end end 
                  
                end
              end end), sg, match[0]);
end end

function module_declaration(s, decl) do
  return do
          md_type: modtype(s, decl.md_type),
          md_attributes: attrs(s, decl.md_attributes),
          md_loc: loc(s, decl.md_loc)
        end;
end end

function modtype_declaration(s, decl) do
  return do
          mtd_type: may_map((function(param) do
                  return modtype(s, param);
                end end), decl.mtd_type),
          mtd_attributes: attrs(s, decl.mtd_attributes),
          mtd_loc: loc(s, decl.mtd_loc)
        end;
end end

add_delayed_check_forward = do
  contents: (function(param) do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "env.ml",
          24,
          46
        }
      })
    end end)
end;

value_declarations = Hashtbl.create(undefined, 16);

type_declarations = Hashtbl.create(undefined, 16);

function add_constructor_usage(cu, param) do
  local ___conditional___=(param);
  do
     if ___conditional___ == 0--[[ Positive ]] then do
        cu.cu_positive = true;
        return --[[ () ]]0; end end 
     if ___conditional___ == 1--[[ Pattern ]] then do
        cu.cu_pattern = true;
        return --[[ () ]]0; end end 
     if ___conditional___ == 2--[[ Privatize ]] then do
        cu.cu_privatize = true;
        return --[[ () ]]0; end end 
    
  end
end end

used_constructors = Hashtbl.create(undefined, 16);

prefixed_sg = Hashtbl.create(undefined, 113);

__Error_2 = Caml_exceptions.create("Ocaml_typedtree_test.Env.Error");

function force(f, x) do
  match = x.contents;
  local ___conditional___=(match.tag | 0);
  do
     if ___conditional___ == 0--[[ Done ]] then do
        return match[0]; end end 
     if ___conditional___ == 1--[[ Raise ]] then do
        error(match[0]) end end 
     if ___conditional___ == 2--[[ Thunk ]] then do
        xpcall(function() do
          y = Curry._1(f, match[0]);
          x.contents = --[[ Done ]]Block.__(0, {y});
          return y;
        end end,function(raw_e) do
          e = Caml_js_exceptions.internalToOCamlException(raw_e);
          x.contents = --[[ Raise ]]Block.__(1, {e});
          error(e)
        end end) end end 
    
  end
end end

function get_arg(x) do
  match = x.contents;
  local ___conditional___=(match.tag | 0);
  do
     if ___conditional___ == 0--[[ Done ]]
     or ___conditional___ == 1--[[ Raise ]] then do
        return ; end end 
     if ___conditional___ == 2--[[ Thunk ]] then do
        return Caml_option.some(match[0]); end end 
    
  end
end end

function nothing(param) do
  return --[[ () ]]0;
end end

function already_defined(s, tbl) do
  xpcall(function() do
    find_name(s, tbl);
    return true;
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return false;
    end else do
      error(exn)
    end end 
  end end)
end end

function add_6(kind, slot, id, x, tbl, ref_tbl) do
  slot_1;
  if (slot ~= undefined) then do
    f = slot;
    slot_1 = (function(param) do
        s = id.name;
        return Curry._3(f, kind, s, already_defined(s, ref_tbl));
      end end);
  end else do
    slot_1 = nothing;
  end end 
  return add(id, --[[ tuple ]]{
              x,
              slot_1
            }, tbl);
end end

function find_same_1(id, tbl) do
  match = find_same(id, tbl);
  Curry._1(match[1], --[[ () ]]0);
  return match[0];
end end

function find_name_1(s, tbl) do
  match = find_name(s, tbl);
  Curry._1(match[1], --[[ () ]]0);
  return match[0];
end end

function fold_name(f) do
  return (function(param, param_1) do
      f_1 = function(k, param) do
        return Curry._2(f, k, param[0]);
      end end;
      tbl = param;
      accu = param_1;
      f_2 = function(k) do
        return Curry._2(f_1, k.ident, k.data);
      end end;
      _stack = --[[ [] ]]0;
      _accu = accu;
      _param = tbl;
      while(true) do
        param_2 = _param;
        accu_1 = _accu;
        stack = _stack;
        if (param_2) then do
          _param = param_2[2];
          _accu = Curry._2(f_2, param_2[1], accu_1);
          _stack = --[[ :: ]]{
            param_2[0],
            stack
          };
          ::continue:: ;
        end else if (stack) then do
          _param = stack[0];
          _stack = stack[1];
          ::continue:: ;
        end else do
          return accu_1;
        end end  end 
      end;
    end end);
end end

function subst_modtype_maker(param) do
  return modtype(param[0], param[1]);
end end

empty = do
  values: --[[ Empty ]]0,
  constrs: --[[ Empty ]]0,
  labels: --[[ Empty ]]0,
  types: --[[ Empty ]]0,
  modules: --[[ Empty ]]0,
  modtypes: --[[ Empty ]]0,
  components: --[[ Empty ]]0,
  classes: --[[ Empty ]]0,
  cltypes: --[[ Empty ]]0,
  functor_args: --[[ Empty ]]0,
  summary: --[[ Env_empty ]]0,
  local_constraints: false,
  gadt_instances: --[[ [] ]]0,
  flags: 0
end;

function in_signature(env) do
  return do
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: env.summary,
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags | 1
        end;
end end

function implicit_coercion(env) do
  return do
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: env.summary,
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags | 2
        end;
end end

function is_in_signature(env) do
  return (env.flags & 1) ~= 0;
end end

function is_implicit_coercion(env) do
  return (env.flags & 2) ~= 0;
end end

components_of_module$prime = do
  contents: (function(env, sub, path, mty) do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "env.ml",
          272,
          32
        }
      })
    end end)
end;

components_of_module_maker$prime = do
  contents: (function(param) do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "env.ml",
          275,
          37
        }
      })
    end end)
end;

components_of_functor_appl$prime = do
  contents: (function(f, p1, p2) do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "env.ml",
          278,
          23
        }
      })
    end end)
end;

check_modtype_inclusion = do
  contents: (function(env, mty1, path1, mty2) do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "env.ml",
          282,
          35
        }
      })
    end end)
end;

strengthen = do
  contents: (function(env, mty, path) do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "env.ml",
          286,
          28
        }
      })
    end end)
end;

current_unit = do
  contents: ""
end;

persistent_structures = Hashtbl.create(undefined, 17);

crc_units = Hashtbl.create(undefined, 13);

function height_5(param) do
  if (param) then do
    return param[--[[ h ]]3];
  end else do
    return 0;
  end end 
end end

function create_6(l, v, r) do
  hl = l and l[--[[ h ]]3] or 0;
  hr = r and r[--[[ h ]]3] or 0;
  return --[[ Node ]]{
          --[[ l ]]l,
          --[[ v ]]v,
          --[[ r ]]r,
          --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
        };
end end

function bal_5(l, v, r) do
  hl = l and l[--[[ h ]]3] or 0;
  hr = r and r[--[[ h ]]3] or 0;
  if (hl > (hr + 2 | 0)) then do
    if (l) then do
      lr = l[--[[ r ]]2];
      lv = l[--[[ v ]]1];
      ll = l[--[[ l ]]0];
      if (height_5(ll) >= height_5(lr)) then do
        return create_6(ll, lv, create_6(lr, v, r));
      end else if (lr) then do
        return create_6(create_6(ll, lv, lr[--[[ l ]]0]), lr[--[[ v ]]1], create_6(lr[--[[ r ]]2], v, r));
      end else do
        error({
          Caml_builtin_exceptions.invalid_argument,
          "Set.bal"
        })
      end end  end 
    end else do
      error({
        Caml_builtin_exceptions.invalid_argument,
        "Set.bal"
      })
    end end 
  end else if (hr > (hl + 2 | 0)) then do
    if (r) then do
      rr = r[--[[ r ]]2];
      rv = r[--[[ v ]]1];
      rl = r[--[[ l ]]0];
      if (height_5(rr) >= height_5(rl)) then do
        return create_6(create_6(l, v, rl), rv, rr);
      end else if (rl) then do
        return create_6(create_6(l, v, rl[--[[ l ]]0]), rl[--[[ v ]]1], create_6(rl[--[[ r ]]2], rv, rr));
      end else do
        error({
          Caml_builtin_exceptions.invalid_argument,
          "Set.bal"
        })
      end end  end 
    end else do
      error({
        Caml_builtin_exceptions.invalid_argument,
        "Set.bal"
      })
    end end 
  end else do
    return --[[ Node ]]{
            --[[ l ]]l,
            --[[ v ]]v,
            --[[ r ]]r,
            --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
          };
  end end  end 
end end

function add_7(x, t) do
  if (t) then do
    r = t[--[[ r ]]2];
    v = t[--[[ v ]]1];
    l = t[--[[ l ]]0];
    c = Caml_primitive.caml_string_compare(x, v);
    if (c == 0) then do
      return t;
    end else if (c < 0) then do
      ll = add_7(x, l);
      if (l == ll) then do
        return t;
      end else do
        return bal_5(ll, v, r);
      end end 
    end else do
      rr = add_7(x, r);
      if (r == rr) then do
        return t;
      end else do
        return bal_5(l, v, rr);
      end end 
    end end  end 
  end else do
    return --[[ Node ]]{
            --[[ l : Empty ]]0,
            --[[ v ]]x,
            --[[ r : Empty ]]0,
            --[[ h ]]1
          };
  end end 
end end

function fold_5(f, _s, _accu) do
  while(true) do
    accu = _accu;
    s = _s;
    if (s) then do
      _accu = Curry._2(f, s[--[[ v ]]1], fold_5(f, s[--[[ l ]]0], accu));
      _s = s[--[[ r ]]2];
      ::continue:: ;
    end else do
      return accu;
    end end 
  end;
end end

function elements_aux_2(_accu, _param) do
  while(true) do
    param = _param;
    accu = _accu;
    if (param) then do
      _param = param[--[[ l ]]0];
      _accu = --[[ :: ]]{
        param[--[[ v ]]1],
        elements_aux_2(accu, param[--[[ r ]]2])
      };
      ::continue:: ;
    end else do
      return accu;
    end end 
  end;
end end

imported_units = do
  contents: --[[ Empty ]]0
end;

function add_import(s) do
  imported_units.contents = add_7(s, imported_units.contents);
  return --[[ () ]]0;
end end

function check_consistency(ps) do
  if (ps.ps_crcs_checked) then do
    return 0;
  end else do
    xpcall(function() do
      List.iter((function(param) do
              crco = param[1];
              if (crco ~= undefined) then do
                name = param[0];
                add_import(name);
                tbl = crc_units;
                name_1 = name;
                crc = crco;
                source = ps.ps_filename;
                xpcall(function() do
                  match = Hashtbl.find(tbl, name_1);
                  if (Caml_obj.caml_notequal(crc, match[0])) then do
                    error({
                      Inconsistency,
                      name_1,
                      source,
                      match[1]
                    })
                  end else do
                    return 0;
                  end end 
                end end,function(exn) do
                  if (exn == Caml_builtin_exceptions.not_found) then do
                    return Hashtbl.add(tbl, name_1, --[[ tuple ]]{
                                crc,
                                source
                              });
                  end else do
                    error(exn)
                  end end 
                end end)
              end else do
                return --[[ () ]]0;
              end end 
            end end), ps.ps_crcs);
      ps.ps_crcs_checked = true;
      return --[[ () ]]0;
    end end,function(raw_exn) do
      exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] == Inconsistency) then do
        error({
          __Error_2,
          --[[ Inconsistent_import ]]Block.__(1, {
              exn[1],
              exn[3],
              exn[2]
            })
        })
      end
       end 
      error(exn)
    end end)
  end end 
end end

function save_pers_struct(crc, ps) do
  modname = ps.ps_name;
  Hashtbl.add(persistent_structures, modname, ps);
  set_1(crc_units, modname, crc, ps.ps_filename);
  return add_import(modname);
end end

function read_pers_struct(modname, filename) do
  cmi = read_cmi(filename);
  name = cmi.cmi_name;
  sign = cmi.cmi_sign;
  crcs = cmi.cmi_crcs;
  flags = cmi.cmi_flags;
  comps = Curry._4(components_of_module$prime.contents, empty, identity, --[[ Pident ]]Block.__(0, {do
            stamp: 0,
            name: name,
            flags: 1
          end}), --[[ Mty_signature ]]Block.__(1, {sign}));
  ps = do
    ps_name: name,
    ps_sig: sign,
    ps_comps: comps,
    ps_crcs: crcs,
    ps_crcs_checked: false,
    ps_filename: filename,
    ps_flags: flags
  end;
  if (ps.ps_name ~= modname) then do
    error({
      __Error_2,
      --[[ Illegal_renaming ]]Block.__(0, {
          modname,
          ps.ps_name,
          filename
        })
    })
  end
   end 
  add_import(name);
  List.iter((function(param) do
          if (recursive_types.contents) then do
            return 0;
          end else do
            error({
              __Error_2,
              --[[ Need_recursive_types ]]Block.__(2, {
                  ps.ps_name,
                  current_unit.contents
                })
            })
          end end 
        end end), ps.ps_flags);
  Hashtbl.add(persistent_structures, modname, ps);
  return ps;
end end

function find_pers_struct(checkOpt, name) do
  check = checkOpt ~= undefined and checkOpt or true;
  if (name == "*predef*") then do
    error(Caml_builtin_exceptions.not_found)
  end
   end 
  r;
  xpcall(function() do
    r = Caml_option.some(Hashtbl.find(persistent_structures, name));
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      r = undefined;
    end else do
      error(exn)
    end end 
  end end)
  ps;
  if (r ~= undefined) then do
    match = Caml_option.valFromOption(r);
    if (match ~= undefined) then do
      ps = match;
    end else do
      error(Caml_builtin_exceptions.not_found)
    end end 
  end else do
    add_import(name);
    filename;
    xpcall(function() do
      filename = find_in_path_uncap(load_path.contents, name .. ".cmi");
    end end,function(exn_1) do
      if (exn_1 == Caml_builtin_exceptions.not_found) then do
        Hashtbl.add(persistent_structures, name, undefined);
        error(Caml_builtin_exceptions.not_found)
      end else do
        error(exn_1)
      end end 
    end end)
    ps = read_pers_struct(name, filename);
  end end 
  if (check) then do
    check_consistency(ps);
  end
   end 
  return ps;
end end

function find_module_descr(path, env) do
  local ___conditional___=(path.tag | 0);
  do
     if ___conditional___ == 0--[[ Pident ]] then do
        id = path[0];
        xpcall(function() do
          return find_same_1(id, env.components)[1];
        end end,function(exn) do
          if (exn == Caml_builtin_exceptions.not_found) then do
            if (id.stamp == 0 and id.name ~= current_unit.contents) then do
              return find_pers_struct(undefined, id.name).ps_comps;
            end else do
              error(Caml_builtin_exceptions.not_found)
            end end 
          end else do
            error(exn)
          end end 
        end end) end end 
     if ___conditional___ == 1--[[ Pdot ]] then do
        match = force(components_of_module_maker$prime.contents, find_module_descr(path[0], env));
        if (match.tag) then do
          error(Caml_builtin_exceptions.not_found)
        end else do
          return find_2(path[1], match[0].comp_components)[0];
        end end  end end 
     if ___conditional___ == 2--[[ Papply ]] then do
        p1 = path[0];
        match_1 = force(components_of_module_maker$prime.contents, find_module_descr(p1, env));
        if (match_1.tag) then do
          return Curry._3(components_of_functor_appl$prime.contents, match_1[0], p1, path[1]);
        end else do
          error(Caml_builtin_exceptions.not_found)
        end end  end end 
    
  end
end end

function find_3(proj1, proj2, path, env) do
  local ___conditional___=(path.tag | 0);
  do
     if ___conditional___ == 0--[[ Pident ]] then do
        return find_same_1(path[0], Curry._1(proj1, env))[1]; end end 
     if ___conditional___ == 1--[[ Pdot ]] then do
        match = force(components_of_module_maker$prime.contents, find_module_descr(path[0], env));
        if (match.tag) then do
          error(Caml_builtin_exceptions.not_found)
        end else do
          return find_2(path[1], Curry._1(proj2, match[0]))[0];
        end end  end end 
     if ___conditional___ == 2--[[ Papply ]] then do
        error(Caml_builtin_exceptions.not_found) end end 
    
  end
end end

function find_value(param, param_1) do
  return find_3((function(env) do
                return env.values;
              end end), (function(sc) do
                return sc.comp_values;
              end end), param, param_1);
end end

function find_type_full(param, param_1) do
  return find_3((function(env) do
                return env.types;
              end end), (function(sc) do
                return sc.comp_types;
              end end), param, param_1);
end end

function find_modtype(param, param_1) do
  return find_3((function(env) do
                return env.modtypes;
              end end), (function(sc) do
                return sc.comp_modtypes;
              end end), param, param_1);
end end

function find_class(param, param_1) do
  return find_3((function(env) do
                return env.classes;
              end end), (function(sc) do
                return sc.comp_classes;
              end end), param, param_1);
end end

function find_module(alias, path, env) do
  local ___conditional___=(path.tag | 0);
  do
     if ___conditional___ == 0--[[ Pident ]] then do
        id = path[0];
        xpcall(function() do
          return find_same_1(id, env.modules)[1];
        end end,function(exn) do
          if (exn == Caml_builtin_exceptions.not_found) then do
            if (id.stamp == 0 and id.name ~= current_unit.contents) then do
              ps = find_pers_struct(undefined, id.name);
              return do
                      md_type: --[[ Mty_signature ]]Block.__(1, {ps.ps_sig}),
                      md_attributes: --[[ [] ]]0,
                      md_loc: none
                    end;
            end else do
              error(Caml_builtin_exceptions.not_found)
            end end 
          end else do
            error(exn)
          end end 
        end end) end end 
     if ___conditional___ == 1--[[ Pdot ]] then do
        match = force(components_of_module_maker$prime.contents, find_module_descr(path[0], env));
        if (match.tag) then do
          error(Caml_builtin_exceptions.not_found)
        end else do
          match_1 = find_2(path[1], match[0].comp_modules);
          md_type = force(subst_modtype_maker, match_1[0]);
          return do
                  md_type: md_type,
                  md_attributes: --[[ [] ]]0,
                  md_loc: none
                end;
        end end  end end 
     if ___conditional___ == 2--[[ Papply ]] then do
        p2 = path[1];
        desc1 = find_module_descr(path[0], env);
        match_2 = force(components_of_module_maker$prime.contents, desc1);
        if (match_2.tag) then do
          f = match_2[0];
          mty = f.fcomp_res;
          md_type_1;
          if (mty.tag == --[[ Mty_alias ]]3) then do
            md_type_1 = --[[ Mty_alias ]]Block.__(3, {module_path(f.fcomp_subst, mty[0])});
          end else if (alias) then do
            md_type_1 = mty;
          end else do
            xpcall(function() do
              md_type_1 = Hashtbl.find(f.fcomp_subst_cache, p2);
            end end,function(exn_1) do
              if (exn_1 == Caml_builtin_exceptions.not_found) then do
                mty_1 = modtype(add_module(f.fcomp_param, p2, f.fcomp_subst), f.fcomp_res);
                Hashtbl.add(f.fcomp_subst_cache, p2, mty_1);
                md_type_1 = mty_1;
              end else do
                error(exn_1)
              end end 
            end end)
          end end  end 
          return do
                  md_type: md_type_1,
                  md_attributes: --[[ [] ]]0,
                  md_loc: none
                end;
        end else do
          error(Caml_builtin_exceptions.not_found)
        end end  end end 
    
  end
end end

required_globals = do
  contents: --[[ [] ]]0
end;

function add_required_global(id) do
  if (__global(id) and not transparent_modules.contents and not List.exists((function(param) do
            return Caml_obj.caml_equal(id, param);
          end end), required_globals.contents)) then do
    required_globals.contents = --[[ :: ]]{
      id,
      required_globals.contents
    };
    return --[[ () ]]0;
  end else do
    return 0;
  end end 
end end

function normalize_path(lax, env, path) do
  path_1;
  local ___conditional___=(path.tag | 0);
  do
     if ___conditional___ == 0--[[ Pident ]] then do
        path_1 = path; end else 
     if ___conditional___ == 1--[[ Pdot ]] then do
        path_1 = --[[ Pdot ]]Block.__(1, {
            normalize_path(lax, env, path[0]),
            path[1],
            path[2]
          }); end else 
     if ___conditional___ == 2--[[ Papply ]] then do
        path_1 = --[[ Papply ]]Block.__(2, {
            normalize_path(lax, env, path[0]),
            normalize_path(true, env, path[1])
          }); end else 
     end end end end end end
    
  end
  xpcall(function() do
    match = find_module(true, path_1, env);
    match_1 = match.md_type;
    if (match_1.tag == --[[ Mty_alias ]]3) then do
      path$prime = normalize_path(lax, env, match_1[0]);
      if (lax or transparent_modules.contents) then do
        return path$prime;
      end else do
        id = head(path_1);
        if (__global(id) and not Caml_obj.caml_equal(id, head(path$prime))) then do
          add_required_global(id);
        end
         end 
        return path$prime;
      end end 
    end else do
      return path_1;
    end end 
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      tmp = true;
      if (not lax) then do
        tmp_1;
        local ___conditional___=(path_1.tag | 0);
        do
           if ___conditional___ == 0--[[ Pident ]] then do
              tmp_1 = path_1[0].stamp ~= 0; end else 
           if ___conditional___ == 1--[[ Pdot ]]
           or ___conditional___ == 2--[[ Papply ]] then do
              tmp_1 = true; end else 
           end end end end
          
        end
        tmp = tmp_1;
      end
       end 
      if (tmp) then do
        return path_1;
      end else do
        error(exn)
      end end 
    end else do
      error(exn)
    end end 
  end end)
end end

function normalize_path_1(oloc, env, path) do
  xpcall(function() do
    return normalize_path(oloc == undefined, env, path);
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      if (oloc ~= undefined) then do
        error({
          __Error_2,
          --[[ Missing_module ]]Block.__(3, {
              oloc,
              path,
              normalize_path(true, env, path)
            })
        })
      end
       end 
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "env.ml",
          579,
          28
        }
      })
    end else do
      error(exn)
    end end 
  end end)
end end

function find_type_expansion(path, env) do
  decl = find_type_full(path, env)[0];
  match = decl.type_manifest;
  if (match ~= undefined) then do
    body = match;
    if (decl.type_private == --[[ Public ]]1 or decl.type_kind ~= --[[ Type_abstract ]]0 or has_constr_row(body)) then do
      return --[[ tuple ]]{
              decl.type_params,
              body,
              may_map((function(prim) do
                      return prim[1];
                    end end), decl.type_newtype_level)
            };
    end
     end 
  end
   end 
  path$prime = normalize_path_1(undefined, env, path);
  if (same(path, path$prime)) then do
    error(Caml_builtin_exceptions.not_found)
  end
   end 
  return --[[ tuple ]]{
          decl.type_params,
          newty2(100000000, --[[ Tconstr ]]Block.__(3, {
                  path$prime,
                  decl.type_params,
                  do
                    contents: --[[ Mnil ]]0
                  end
                })),
          may_map((function(prim) do
                  return prim[1];
                end end), decl.type_newtype_level)
        };
end end

function find_type_expansion_opt(path, env) do
  decl = find_type_full(path, env)[0];
  match = decl.type_manifest;
  if (match ~= undefined) then do
    return --[[ tuple ]]{
            decl.type_params,
            match,
            may_map((function(prim) do
                    return prim[1];
                  end end), decl.type_newtype_level)
          };
  end else do
    path$prime = normalize_path_1(undefined, env, path);
    if (same(path, path$prime)) then do
      error(Caml_builtin_exceptions.not_found)
    end
     end 
    return --[[ tuple ]]{
            decl.type_params,
            newty2(100000000, --[[ Tconstr ]]Block.__(3, {
                    path$prime,
                    decl.type_params,
                    do
                      contents: --[[ Mnil ]]0
                    end
                  })),
            may_map((function(prim) do
                    return prim[1];
                  end end), decl.type_newtype_level)
          };
  end end 
end end

function find_modtype_expansion(path, env) do
  match = find_modtype(path, env).mtd_type;
  if (match ~= undefined) then do
    return match;
  end else do
    error(Caml_builtin_exceptions.not_found)
  end end 
end end

function is_functor_arg(_path, env) do
  while(true) do
    path = _path;
    local ___conditional___=(path.tag | 0);
    do
       if ___conditional___ == 0--[[ Pident ]] then do
          xpcall(function() do
            find_same(path[0], env.functor_args);
            return true;
          end end,function(exn) do
            if (exn == Caml_builtin_exceptions.not_found) then do
              return false;
            end else do
              error(exn)
            end end 
          end end) end end 
       if ___conditional___ == 1--[[ Pdot ]] then do
          _path = path[0];
          ::continue:: ; end end 
       if ___conditional___ == 2--[[ Papply ]] then do
          return true; end end 
      
    end
  end;
end end

Recmodule = Caml_exceptions.create("Ocaml_typedtree_test.Env.Recmodule");

function lookup_module_descr(lid, env) do
  local ___conditional___=(lid.tag | 0);
  do
     if ___conditional___ == 0--[[ Lident ]] then do
        s = lid[0];
        xpcall(function() do
          return find_name_1(s, env.components);
        end end,function(exn) do
          if (exn == Caml_builtin_exceptions.not_found) then do
            if (s == current_unit.contents) then do
              error(Caml_builtin_exceptions.not_found)
            end
             end 
            ps = find_pers_struct(undefined, s);
            return --[[ tuple ]]{
                    --[[ Pident ]]Block.__(0, {do
                          stamp: 0,
                          name: s,
                          flags: 1
                        end}),
                    ps.ps_comps
                  };
          end else do
            error(exn)
          end end 
        end end) end end 
     if ___conditional___ == 1--[[ Ldot ]] then do
        s_1 = lid[1];
        match = lookup_module_descr(lid[0], env);
        match_1 = force(components_of_module_maker$prime.contents, match[1]);
        if (match_1.tag) then do
          error(Caml_builtin_exceptions.not_found)
        end else do
          match_2 = find_2(s_1, match_1[0].comp_components);
          return --[[ tuple ]]{
                  --[[ Pdot ]]Block.__(1, {
                      match[0],
                      s_1,
                      match_2[1]
                    }),
                  match_2[0]
                };
        end end  end end 
     if ___conditional___ == 2--[[ Lapply ]] then do
        match_3 = lookup_module_descr(lid[0], env);
        p1 = match_3[0];
        p2 = lookup_module(true, lid[1], env);
        match_4 = find_module(false, p2, env);
        match_5 = force(components_of_module_maker$prime.contents, match_3[1]);
        if (match_5.tag) then do
          f = match_5[0];
          may(Curry._3(check_modtype_inclusion.contents, env, match_4.md_type, p2), f.fcomp_arg);
          return --[[ tuple ]]{
                  --[[ Papply ]]Block.__(2, {
                      p1,
                      p2
                    }),
                  Curry._3(components_of_functor_appl$prime.contents, f, p1, p2)
                };
        end else do
          error(Caml_builtin_exceptions.not_found)
        end end  end end 
    
  end
end end

function lookup_module(load, lid, env) do
  local ___conditional___=(lid.tag | 0);
  do
     if ___conditional___ == 0--[[ Lident ]] then do
        s = lid[0];
        xpcall(function() do
          r = find_name_1(s, env.modules);
          md_type = r[1].md_type;
          if (not md_type.tag) then do
            match = md_type[0];
            local ___conditional___=(match.tag | 0);
            do
               if ___conditional___ == 0--[[ Pident ]] then do
                  if (match[0].name == "#recmod#") then do
                    error(Recmodule)
                  end
                   end  end else 
               if ___conditional___ == 1--[[ Pdot ]]
               or ___conditional___ == 2--[[ Papply ]]
               end end end
              
            end
          end
           end 
          return r[0];
        end end,function(exn) do
          if (exn == Caml_builtin_exceptions.not_found) then do
            if (s == current_unit.contents) then do
              error(Caml_builtin_exceptions.not_found)
            end
             end 
            if (transparent_modules.contents and not load) then do
              xpcall(function() do
                find_pers_struct(false, s);
              end end,function(exn_1) do
                if (exn_1 == Caml_builtin_exceptions.not_found) then do
                  prerr_warning(none, --[[ No_cmi_file ]]Block.__(32, {s}));
                end else do
                  error(exn_1)
                end end 
              end end)
            end else do
              find_pers_struct(undefined, s);
            end end 
            return --[[ Pident ]]Block.__(0, {do
                        stamp: 0,
                        name: s,
                        flags: 1
                      end});
          end else do
            error(exn)
          end end 
        end end) end end 
     if ___conditional___ == 1--[[ Ldot ]] then do
        s_1 = lid[1];
        match_1 = lookup_module_descr(lid[0], env);
        match_2 = force(components_of_module_maker$prime.contents, match_1[1]);
        if (match_2.tag) then do
          error(Caml_builtin_exceptions.not_found)
        end else do
          match_3 = find_2(s_1, match_2[0].comp_modules);
          return --[[ Pdot ]]Block.__(1, {
                    match_1[0],
                    s_1,
                    match_3[1]
                  });
        end end  end end 
     if ___conditional___ == 2--[[ Lapply ]] then do
        match_4 = lookup_module_descr(lid[0], env);
        p2 = lookup_module(true, lid[1], env);
        match_5 = find_module(false, p2, env);
        p_000 = match_4[0];
        p = --[[ Papply ]]Block.__(2, {
            p_000,
            p2
          });
        match_6 = force(components_of_module_maker$prime.contents, match_4[1]);
        if (match_6.tag) then do
          may(Curry._3(check_modtype_inclusion.contents, env, match_5.md_type, p2), match_6[0].fcomp_arg);
          return p;
        end else do
          error(Caml_builtin_exceptions.not_found)
        end end  end end 
    
  end
end end

function lookup(proj1, proj2, lid, env) do
  local ___conditional___=(lid.tag | 0);
  do
     if ___conditional___ == 0--[[ Lident ]] then do
        return find_name_1(lid[0], Curry._1(proj1, env)); end end 
     if ___conditional___ == 1--[[ Ldot ]] then do
        s = lid[1];
        match = lookup_module_descr(lid[0], env);
        match_1 = force(components_of_module_maker$prime.contents, match[1]);
        if (match_1.tag) then do
          error(Caml_builtin_exceptions.not_found)
        end else do
          match_2 = find_2(s, Curry._1(proj2, match_1[0]));
          return --[[ tuple ]]{
                  --[[ Pdot ]]Block.__(1, {
                      match[0],
                      s,
                      match_2[1]
                    }),
                  match_2[0]
                };
        end end  end end 
     if ___conditional___ == 2--[[ Lapply ]] then do
        error(Caml_builtin_exceptions.not_found) end end 
    
  end
end end

function lookup_all_simple(proj1, proj2, shadow, lid, env) do
  local ___conditional___=(lid.tag | 0);
  do
     if ___conditional___ == 0--[[ Lident ]] then do
        xl = find_all(lid[0], Curry._1(proj1, env));
        do_shadow = function(param) do
          if (param) then do
            match = param[0];
            x = match[0];
            return --[[ :: ]]{
                    --[[ tuple ]]{
                      x,
                      match[1]
                    },
                    do_shadow(List.filter((function(param) do
                                  return not Curry._2(shadow, x, param[0]);
                                end end))(param[1]))
                  };
          end else do
            return --[[ [] ]]0;
          end end 
        end end;
        return do_shadow(xl); end end 
     if ___conditional___ == 1--[[ Ldot ]] then do
        match = lookup_module_descr(lid[0], env);
        match_1 = force(components_of_module_maker$prime.contents, match[1]);
        if (match_1.tag) then do
          error(Caml_builtin_exceptions.not_found)
        end else do
          comps;
          xpcall(function() do
            comps = find_2(lid[1], Curry._1(proj2, match_1[0]));
          end end,function(exn) do
            if (exn == Caml_builtin_exceptions.not_found) then do
              comps = --[[ [] ]]0;
            end else do
              error(exn)
            end end 
          end end)
          return List.map((function(param) do
                        return --[[ tuple ]]{
                                param[0],
                                (function(param) do
                                    return --[[ () ]]0;
                                  end end)
                              };
                      end end), comps);
        end end  end end 
     if ___conditional___ == 2--[[ Lapply ]] then do
        error(Caml_builtin_exceptions.not_found) end end 
    
  end
end end

function cstr_shadow(cstr1, cstr2) do
  match = cstr1.cstr_tag;
  match_1 = cstr2.cstr_tag;
  local ___conditional___=(match.tag | 0);
  do
     if ___conditional___ == 0--[[ Cstr_constant ]]
     or ___conditional___ == 1--[[ Cstr_block ]] then do
        return false; end end 
     if ___conditional___ == 2--[[ Cstr_extension ]] then do
        local ___conditional___=(match_1.tag | 0);
        do
           if ___conditional___ == 0--[[ Cstr_constant ]]
           or ___conditional___ == 1--[[ Cstr_block ]] then do
              return false; end end 
           if ___conditional___ == 2--[[ Cstr_extension ]] then do
              return true; end end 
          
        end end end 
    
  end
end end

function lbl_shadow(lbl1, lbl2) do
  return false;
end end

function lookup_value(param, param_1) do
  return lookup((function(env) do
                return env.values;
              end end), (function(sc) do
                return sc.comp_values;
              end end), param, param_1);
end end

function lookup_all_constructors(param, param_1) do
  return lookup_all_simple((function(env) do
                return env.constrs;
              end end), (function(sc) do
                return sc.comp_constrs;
              end end), cstr_shadow, param, param_1);
end end

function lookup_all_labels(param, param_1) do
  return lookup_all_simple((function(env) do
                return env.labels;
              end end), (function(sc) do
                return sc.comp_labels;
              end end), lbl_shadow, param, param_1);
end end

function lookup_type(param, param_1) do
  return lookup((function(env) do
                return env.types;
              end end), (function(sc) do
                return sc.comp_types;
              end end), param, param_1);
end end

function lookup_modtype(param, param_1) do
  return lookup((function(env) do
                return env.modtypes;
              end end), (function(sc) do
                return sc.comp_modtypes;
              end end), param, param_1);
end end

function lookup_class(param, param_1) do
  return lookup((function(env) do
                return env.classes;
              end end), (function(sc) do
                return sc.comp_classes;
              end end), param, param_1);
end end

function lookup_cltype(param, param_1) do
  return lookup((function(env) do
                return env.cltypes;
              end end), (function(sc) do
                return sc.comp_cltypes;
              end end), param, param_1);
end end

function mark_value_used(env, name, vd) do
  if (is_implicit_coercion(env)) then do
    return 0;
  end else do
    xpcall(function() do
      return Curry._1(Hashtbl.find(value_declarations, --[[ tuple ]]{
                      name,
                      vd.val_loc
                    }), --[[ () ]]0);
    end end,function(exn) do
      if (exn == Caml_builtin_exceptions.not_found) then do
        return --[[ () ]]0;
      end else do
        error(exn)
      end end 
    end end)
  end end 
end end

function mark_type_used(env, name, vd) do
  if (is_implicit_coercion(env)) then do
    return 0;
  end else do
    xpcall(function() do
      return Curry._1(Hashtbl.find(type_declarations, --[[ tuple ]]{
                      name,
                      vd.type_loc
                    }), --[[ () ]]0);
    end end,function(exn) do
      if (exn == Caml_builtin_exceptions.not_found) then do
        return --[[ () ]]0;
      end else do
        error(exn)
      end end 
    end end)
  end end 
end end

function mark_constructor_used(usage, env, name, vd, constr) do
  if (is_implicit_coercion(env)) then do
    return 0;
  end else do
    xpcall(function() do
      return Curry._1(Hashtbl.find(used_constructors, --[[ tuple ]]{
                      name,
                      vd.type_loc,
                      constr
                    }), usage);
    end end,function(exn) do
      if (exn == Caml_builtin_exceptions.not_found) then do
        return --[[ () ]]0;
      end else do
        error(exn)
      end end 
    end end)
  end end 
end end

function mark_extension_used(usage, env, ext, name) do
  if (is_implicit_coercion(env)) then do
    return 0;
  end else do
    ty_name = last(ext.ext_type_path);
    xpcall(function() do
      return Curry._1(Hashtbl.find(used_constructors, --[[ tuple ]]{
                      ty_name,
                      ext.ext_loc,
                      name
                    }), usage);
    end end,function(exn) do
      if (exn == Caml_builtin_exceptions.not_found) then do
        return --[[ () ]]0;
      end else do
        error(exn)
      end end 
    end end)
  end end 
end end

function set_type_used_callback(name, td, callback) do
  loc = td.type_loc;
  if (loc.loc_ghost) then do
    return --[[ () ]]0;
  end else do
    key = --[[ tuple ]]{
      name,
      loc
    };
    old;
    xpcall(function() do
      old = Hashtbl.find(type_declarations, key);
    end end,function(exn) do
      if (exn == Caml_builtin_exceptions.not_found) then do
        error({
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "env.ml",
            841,
            22
          }
        })
      end
       end 
      error(exn)
    end end)
    return Hashtbl.replace(type_declarations, key, (function(param) do
                  return Curry._1(callback, old);
                end end));
  end end 
end end

function lookup_value_1(lid, env) do
  r = lookup_value(lid, env);
  mark_value_used(env, last_1(lid), r[1]);
  return r;
end end

function lookup_type_1(lid, env) do
  match = lookup_type(lid, env);
  decl = match[1][0];
  mark_type_used(env, last_1(lid), decl);
  return --[[ tuple ]]{
          match[0],
          decl
        };
end end

function mark_type_path(env, path) do
  xpcall(function() do
    decl = find_type_full(path, env)[0];
    return mark_type_used(env, last(path), decl);
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return --[[ () ]]0;
    end else do
      error(exn)
    end end 
  end end)
end end

function ty_path(t) do
  match = repr(t);
  match_1 = match.desc;
  if (typeof match_1 == "number") then do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "env.ml",
        871,
        9
      }
    })
  end else if (match_1.tag == --[[ Tconstr ]]3) then do
    return match_1[0];
  end else do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "env.ml",
        871,
        9
      }
    })
  end end  end 
end end

function lookup_constructor(lid, env) do
  match = lookup_all_constructors(lid, env);
  if (match) then do
    match_1 = match[0];
    desc = match_1[0];
    mark_type_path(env, ty_path(desc.cstr_res));
    Curry._1(match_1[1], --[[ () ]]0);
    return desc;
  end else do
    error(Caml_builtin_exceptions.not_found)
  end end 
end end

function is_lident(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Lident ]] then do
        return true; end end 
     if ___conditional___ == 1--[[ Ldot ]]
     or ___conditional___ == 2--[[ Lapply ]] then do
        return false; end end 
    
  end
end end

function lookup_all_constructors_1(lid, env) do
  xpcall(function() do
    cstrs = lookup_all_constructors(lid, env);
    return List.map((function(param) do
                  use = param[1];
                  cstr = param[0];
                  return --[[ tuple ]]{
                          cstr,
                          (function(param) do
                              desc = cstr;
                              use_1 = use;
                              mark_type_path(env, ty_path(desc.cstr_res));
                              return Curry._1(use_1, --[[ () ]]0);
                            end end)
                        };
                end end), cstrs);
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      if (is_lident(lid)) then do
        return --[[ [] ]]0;
      end else do
        error(exn)
      end end 
    end else do
      error(exn)
    end end 
  end end)
end end

function mark_constructor(usage, env, name, desc) do
  if (is_implicit_coercion(env)) then do
    return 0;
  end else do
    match = desc.cstr_tag;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 0--[[ Cstr_constant ]]
       or ___conditional___ == 1--[[ Cstr_block ]]
       or ___conditional___ == 2--[[ Cstr_extension ]] then do
          ty_path_1 = ty_path(desc.cstr_res);
          ty_name = last(ty_path_1);
          xpcall(function() do
            return Curry._1(Hashtbl.find(used_constructors, --[[ tuple ]]{
                            ty_name,
                            desc.cstr_loc,
                            name
                          }), usage);
          end end,function(exn) do
            if (exn == Caml_builtin_exceptions.not_found) then do
              return --[[ () ]]0;
            end else do
              error(exn)
            end end 
          end end) end end 
      
    end
    ty_path_2 = ty_path(desc.cstr_res);
    ty_decl;
    xpcall(function() do
      ty_decl = find_type_full(ty_path_2, env)[0];
    end end,function(exn_1) do
      if (exn_1 == Caml_builtin_exceptions.not_found) then do
        error({
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "env.ml",
            908,
            64
          }
        })
      end
       end 
      error(exn_1)
    end end)
    ty_name_1 = last(ty_path_2);
    return mark_constructor_used(usage, env, ty_name_1, ty_decl, name);
  end end 
end end

function lookup_all_labels_1(lid, env) do
  xpcall(function() do
    lbls = lookup_all_labels(lid, env);
    return List.map((function(param) do
                  use = param[1];
                  lbl = param[0];
                  return --[[ tuple ]]{
                          lbl,
                          (function(param) do
                              desc = lbl;
                              use_1 = use;
                              mark_type_path(env, ty_path(desc.lbl_res));
                              return Curry._1(use_1, --[[ () ]]0);
                            end end)
                        };
                end end), lbls);
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      if (is_lident(lid)) then do
        return --[[ [] ]]0;
      end else do
        error(exn)
      end end 
    end else do
      error(exn)
    end end 
  end end)
end end

function lookup_class_1(lid, env) do
  r = lookup_class(lid, env);
  desc = r[1];
  if (name(undefined, desc.cty_path) == "") then do
    lookup_type_1(lid, env);
  end else do
    mark_type_path(env, desc.cty_path);
  end end 
  return r;
end end

function lookup_cltype_1(lid, env) do
  r = lookup_cltype(lid, env);
  desc = r[1];
  if (name(undefined, desc.clty_path) == "") then do
    lookup_type_1(lid, env);
  end else do
    mark_type_path(env, desc.clty_path);
  end end 
  mark_type_path(env, desc.clty_path);
  return r;
end end

iter_env_cont = do
  contents: --[[ [] ]]0
end;

function scrape_alias_safe(env, _mty) do
  while(true) do
    mty = _mty;
    if (mty.tag == --[[ Mty_alias ]]3) then do
      path = mty[0];
      local ___conditional___=(path.tag | 0);
      do
         if ___conditional___ == 0--[[ Pident ]] then do
            if (path[0].stamp == 0) then do
              return false;
            end
             end  end else 
         if ___conditional___ == 1--[[ Pdot ]]
         or ___conditional___ == 2--[[ Papply ]]
         end end end
        
      end
      _mty = find_module(false, path, env).md_type;
      ::continue:: ;
    end else do
      return true;
    end end 
  end;
end end

function run_iter_cont(l) do
  iter_env_cont.contents = --[[ [] ]]0;
  List.iter((function(c) do
          return Curry._1(c, --[[ () ]]0);
        end end), l);
  cont = List.rev(iter_env_cont.contents);
  iter_env_cont.contents = --[[ [] ]]0;
  return cont;
end end

function iter_types(f) do
  return (function(param, param_1) do
      proj1 = function(env) do
        return env.types;
      end end;
      proj2 = function(sc) do
        return sc.comp_types;
      end end;
      f_1 = f;
      env = param;
      iter((function(id, param) do
              return Curry._2(f_1, --[[ Pident ]]Block.__(0, {id}), param[0]);
            end end), Curry._1(proj1, env));
      iter_components = function(path, path$prime, mcomps) do
        cont = function(param) do
          match = get_arg(mcomps);
          safe;
          if (match ~= undefined) then do
            match_1 = match;
            xpcall(function() do
              safe = scrape_alias_safe(match_1[0], match_1[3]);
            end end,function(exn) do
              if (exn == Caml_builtin_exceptions.not_found) then do
                safe = false;
              end else do
                error(exn)
              end end 
            end end)
          end else do
            safe = true;
          end end 
          if (safe) then do
            match_2 = force(components_of_module_maker$prime.contents, mcomps);
            if (match_2.tag) then do
              return --[[ () ]]0;
            end else do
              comps = match_2[0];
              iter_2((function(s, param) do
                      n = param[1];
                      return Curry._2(f_1, --[[ Pdot ]]Block.__(1, {
                                    path,
                                    s,
                                    n
                                  }), --[[ tuple ]]{
                                  --[[ Pdot ]]Block.__(1, {
                                      path$prime,
                                      s,
                                      n
                                    }),
                                  param[0]
                                });
                    end end), Curry._1(proj2, comps));
              return iter_2((function(s, param) do
                            n = param[1];
                            return iter_components(--[[ Pdot ]]Block.__(1, {
                                          path,
                                          s,
                                          n
                                        }), --[[ Pdot ]]Block.__(1, {
                                          path$prime,
                                          s,
                                          n
                                        }), param[0]);
                          end end), comps.comp_components);
            end end 
          end else do
            return --[[ () ]]0;
          end end 
        end end;
        iter_env_cont.contents = --[[ :: ]]{
          --[[ tuple ]]{
            path,
            cont
          },
          iter_env_cont.contents
        };
        return --[[ () ]]0;
      end end;
      Hashtbl.iter((function(s, pso) do
              if (pso ~= undefined) then do
                id = --[[ Pident ]]Block.__(0, {do
                      stamp: 0,
                      name: s,
                      flags: 1
                    end});
                return iter_components(id, id, pso.ps_comps);
              end else do
                return --[[ () ]]0;
              end end 
            end end), persistent_structures);
      return iter((function(id, param) do
                    match = param[0];
                    return iter_components(--[[ Pident ]]Block.__(0, {id}), match[0], match[1]);
                  end end), env.components);
    end end);
end end

function same_types(env1, env2) do
  if (env1.types == env2.types) then do
    return env1.components == env2.components;
  end else do
    return false;
  end end 
end end

function used_persistent(param) do
  r = do
    contents: --[[ Empty ]]0
  end;
  Hashtbl.iter((function(s, pso) do
          if (pso ~= undefined) then do
            r.contents = add_2(s, r.contents);
            return --[[ () ]]0;
          end else do
            return 0;
          end end 
        end end), persistent_structures);
  return r.contents;
end end

function find_all_comps(proj, s, param) do
  match = force(components_of_module_maker$prime.contents, param[1]);
  if (match.tag) then do
    return --[[ [] ]]0;
  end else do
    xpcall(function() do
      match_1 = find_2(s, Curry._1(proj, match[0]));
      return --[[ :: ]]{
              --[[ tuple ]]{
                --[[ Pdot ]]Block.__(1, {
                    param[0],
                    s,
                    match_1[1]
                  }),
                match_1[0]
              },
              --[[ [] ]]0
            };
    end end,function(exn) do
      if (exn == Caml_builtin_exceptions.not_found) then do
        return --[[ [] ]]0;
      end else do
        error(exn)
      end end 
    end end)
  end end 
end end

function find_shadowed_comps(path, env) do
  local ___conditional___=(path.tag | 0);
  do
     if ___conditional___ == 0--[[ Pident ]] then do
        return List.map((function(prim) do
                      return prim[0];
                    end end), find_all(path[0].name, env.components)); end end 
     if ___conditional___ == 1--[[ Pdot ]] then do
        s = path[1];
        l = find_shadowed_comps(path[0], env);
        return List.flatten(List.map((function(param) do
                          return find_all_comps((function(comps) do
                                        return comps.comp_components;
                                      end end), s, param);
                        end end), l)); end end 
     if ___conditional___ == 2--[[ Papply ]] then do
        return --[[ [] ]]0; end end 
    
  end
end end

function find_shadowed(proj1, proj2, path, env) do
  local ___conditional___=(path.tag | 0);
  do
     if ___conditional___ == 0--[[ Pident ]] then do
        return List.map((function(prim) do
                      return prim[0];
                    end end), find_all(path[0].name, Curry._1(proj1, env))); end end 
     if ___conditional___ == 1--[[ Pdot ]] then do
        s = path[1];
        l = find_shadowed_comps(path[0], env);
        return List.flatten(List.map((function(param) do
                          return find_all_comps(proj2, s, param);
                        end end), l)); end end 
     if ___conditional___ == 2--[[ Papply ]] then do
        return --[[ [] ]]0; end end 
    
  end
end end

function find_shadowed_types(path, env) do
  l = find_shadowed((function(env) do
          return env.types;
        end end), (function(comps) do
          return comps.comp_types;
        end end), path, env);
  return List.map((function(prim) do
                return prim[0];
              end end), l);
end end

function add_gadt_instance_level(lv, env) do
  return do
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: env.summary,
          local_constraints: env.local_constraints,
          gadt_instances: --[[ :: ]]{
            --[[ tuple ]]{
              lv,
              do
                contents: --[[ Empty ]]0
              end
            },
            env.gadt_instances
          },
          flags: env.flags
        end;
end end

function is_Tlink(param) do
  match = param.desc;
  if (typeof match == "number" or match.tag ~= --[[ Tlink ]]6) then do
    return false;
  end else do
    return true;
  end end 
end end

function gadt_instance_level(env, t) do
  _param = env.gadt_instances;
  while(true) do
    param = _param;
    if (param) then do
      match = param[0];
      r = match[1];
      if (exists(is_Tlink, r.contents)) then do
        r.contents = fold_2((function(ty) do
                partial_arg = repr(ty);
                return (function(param) do
                    return add_3(partial_arg, param);
                  end end);
              end end), r.contents, --[[ Empty ]]0);
      end
       end 
      if (mem_3(t, r.contents)) then do
        return Caml_option.some(match[0]);
      end else do
        _param = param[1];
        ::continue:: ;
      end end 
    end else do
      return ;
    end end 
  end;
end end

function add_gadt_instances(env, lv, tl) do
  r;
  xpcall(function() do
    r = List.assoc(lv, env.gadt_instances);
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "env.ml",
          1066,
          59
        }
      })
    end
     end 
    error(exn)
  end end)
  return set_typeset(r, List.fold_right(add_3, tl, r.contents));
end end

function add_gadt_instance_chain(env, lv, t) do
  r;
  xpcall(function() do
    r = List.assoc(lv, env.gadt_instances);
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "env.ml",
          1075,
          59
        }
      })
    end
     end 
    error(exn)
  end end)
  add_instance = function(t) do
    t_1 = repr(t);
    if (mem_3(t_1, r.contents)) then do
      return 0;
    end else do
      set_typeset(r, add_3(t_1, r.contents));
      match = t_1.desc;
      if (typeof match == "number" or match.tag ~= --[[ Tconstr ]]3) then do
        return --[[ () ]]0;
      end else do
        return may(add_instance, find_expans(--[[ Private ]]0, match[0], match[2].contents));
      end end 
    end end 
  end end;
  return add_instance(t);
end end

function scrape_alias(env, path, mty) do
  local ___conditional___=(mty.tag | 0);
  do
     if ___conditional___ == 0--[[ Mty_ident ]] then do
        xpcall(function() do
          return scrape_alias(env, path, find_modtype_expansion(mty[0], env));
        end end,function(exn) do
          if (exn == Caml_builtin_exceptions.not_found) then do
            return mty;
          end else do
            error(exn)
          end end 
        end end) end end 
     if ___conditional___ == 1--[[ Mty_signature ]]
     or ___conditional___ == 2--[[ Mty_functor ]]
     or ___conditional___ == 3--[[ Mty_alias ]] then do
        path_1 = mty[0];
        xpcall(function() do
          return scrape_alias(env, path_1, find_module(false, path_1, env).md_type);
        end end,function(exn_1) do
          if (exn_1 == Caml_builtin_exceptions.not_found) then do
            return mty;
          end else do
            error(exn_1)
          end end 
        end end) end end 
    
  end
  if (path ~= undefined) then do
    return Curry._3(strengthen.contents, env, mty, path);
  end else do
    return mty;
  end end 
end end

function constructors_of_type(ty_path, decl) do
  match = decl.type_kind;
  if (typeof match == "number" or match.tag ~= --[[ Type_variant ]]1) then do
    return --[[ [] ]]0;
  end else do
    cstrs = match[0];
    ty_res = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
            ty_path,
            decl.type_params,
            do
              contents: --[[ Mnil ]]0
            end
          }));
    cstrs_1 = cstrs;
    priv = decl.type_private;
    num_consts = do
      contents: 0
    end;
    num_nonconsts = do
      contents: 0
    end;
    num_normal = do
      contents: 0
    end;
    List.iter((function(param) do
            if (param.cd_args == --[[ [] ]]0) then do
              num_consts.contents = num_consts.contents + 1 | 0;
            end else do
              num_nonconsts.contents = num_nonconsts.contents + 1 | 0;
            end end 
            if (param.cd_res == undefined) then do
              num_normal.contents = num_normal.contents + 1 | 0;
              return --[[ () ]]0;
            end else do
              return 0;
            end end 
          end end), cstrs_1);
    describe_constructors = function(idx_const, idx_nonconst, param) do
      if (param) then do
        rem = param[1];
        match = param[0];
        cd_res = match.cd_res;
        cd_args = match.cd_args;
        cd_id = match.cd_id;
        ty_res_1 = cd_res ~= undefined and cd_res or ty_res;
        match_1 = cd_args and --[[ tuple ]]{
            --[[ Cstr_block ]]Block.__(1, {idx_nonconst}),
            describe_constructors(idx_const, idx_nonconst + 1 | 0, rem)
          } or --[[ tuple ]]{
            --[[ Cstr_constant ]]Block.__(0, {idx_const}),
            describe_constructors(idx_const + 1 | 0, idx_nonconst, rem)
          };
        existentials;
        if (cd_res ~= undefined) then do
          res_vars = free_vars(cd_res);
          arg_vars = free_vars(newty2(100000000, --[[ Ttuple ]]Block.__(2, {cd_args})));
          existentials = elements_aux_1(--[[ [] ]]0, diff_1(arg_vars, res_vars));
        end else do
          existentials = --[[ [] ]]0;
        end end 
        cstr_cstr_name = cd_id.name;
        cstr_cstr_arity = List.length(cd_args);
        cstr_cstr_tag = match_1[0];
        cstr_cstr_consts = num_consts.contents;
        cstr_cstr_nonconsts = num_nonconsts.contents;
        cstr_cstr_normal = num_normal.contents;
        cstr_cstr_generalized = cd_res ~= undefined;
        cstr_cstr_loc = match.cd_loc;
        cstr_cstr_attributes = match.cd_attributes;
        cstr = do
          cstr_name: cstr_cstr_name,
          cstr_res: ty_res_1,
          cstr_existentials: existentials,
          cstr_args: cd_args,
          cstr_arity: cstr_cstr_arity,
          cstr_tag: cstr_cstr_tag,
          cstr_consts: cstr_cstr_consts,
          cstr_nonconsts: cstr_cstr_nonconsts,
          cstr_normal: cstr_cstr_normal,
          cstr_generalized: cstr_cstr_generalized,
          cstr_private: priv,
          cstr_loc: cstr_cstr_loc,
          cstr_attributes: cstr_cstr_attributes
        end;
        return --[[ :: ]]{
                --[[ tuple ]]{
                  cd_id,
                  cstr
                },
                match_1[1]
              };
      end else do
        return --[[ [] ]]0;
      end end 
    end end;
    result = describe_constructors(0, 0, cstrs_1);
    a_id;
    a_descr;
    b_id;
    b_descr;
    if (result) then do
      match_1 = result[0];
      a_id_1 = match_1[0];
      local ___conditional___=(a_id_1.name);
      do
         if ___conditional___ == "None" then do
            a_descr_1 = match_1[1];
            if (a_descr_1.cstr_args) then do
              return result;
            end else do
              match_2 = result[1];
              if (match_2) then do
                match_3 = match_2[0];
                b_id_1 = match_3[0];
                if (b_id_1.name == "Some") then do
                  b_descr_1 = match_3[1];
                  match_4 = b_descr_1.cstr_args;
                  if (match_4 and not (match_4[1] or match_2[1])) then do
                    a_id = a_id_1;
                    a_descr = a_descr_1;
                    b_id = b_id_1;
                    b_descr = b_descr_1;
                  end else do
                    return result;
                  end end 
                end else do
                  return result;
                end end 
              end else do
                return result;
              end end 
            end end  end else 
         if ___conditional___ == "Some" then do
            a_descr_2 = match_1[1];
            match_5 = a_descr_2.cstr_args;
            if (match_5 and not match_5[1]) then do
              match_6 = result[1];
              if (match_6) then do
                match_7 = match_6[0];
                b_id_2 = match_7[0];
                if (b_id_2.name == "None") then do
                  b_descr_2 = match_7[1];
                  if (b_descr_2.cstr_args or match_6[1]) then do
                    return result;
                  end else do
                    a_id = a_id_1;
                    a_descr = a_descr_2;
                    b_id = b_id_2;
                    b_descr = b_descr_2;
                  end end 
                end else do
                  return result;
                end end 
              end else do
                return result;
              end end 
            end else do
              return result;
            end end  end else 
         end end end end
        return result;
          
      end
    end else do
      return result;
    end end 
    return --[[ :: ]]{
            --[[ tuple ]]{
              a_id,
              do
                cstr_name: a_descr.cstr_name,
                cstr_res: a_descr.cstr_res,
                cstr_existentials: a_descr.cstr_existentials,
                cstr_args: a_descr.cstr_args,
                cstr_arity: a_descr.cstr_arity,
                cstr_tag: a_descr.cstr_tag,
                cstr_consts: a_descr.cstr_consts,
                cstr_nonconsts: a_descr.cstr_nonconsts,
                cstr_normal: a_descr.cstr_normal,
                cstr_generalized: a_descr.cstr_generalized,
                cstr_private: a_descr.cstr_private,
                cstr_loc: a_descr.cstr_loc,
                cstr_attributes: --[[ :: ]]{
                  optional_shape,
                  a_descr.cstr_attributes
                }
              end
            },
            --[[ :: ]]{
              --[[ tuple ]]{
                b_id,
                do
                  cstr_name: b_descr.cstr_name,
                  cstr_res: b_descr.cstr_res,
                  cstr_existentials: b_descr.cstr_existentials,
                  cstr_args: b_descr.cstr_args,
                  cstr_arity: b_descr.cstr_arity,
                  cstr_tag: b_descr.cstr_tag,
                  cstr_consts: b_descr.cstr_consts,
                  cstr_nonconsts: b_descr.cstr_nonconsts,
                  cstr_normal: b_descr.cstr_normal,
                  cstr_generalized: b_descr.cstr_generalized,
                  cstr_private: b_descr.cstr_private,
                  cstr_loc: b_descr.cstr_loc,
                  cstr_attributes: --[[ :: ]]{
                    optional_shape,
                    b_descr.cstr_attributes
                  }
                end
              },
              --[[ [] ]]0
            }
          };
  end end 
end end

function labels_of_type(ty_path, decl) do
  match = decl.type_kind;
  if (typeof match == "number" or match.tag) then do
    return --[[ [] ]]0;
  end else do
    ty_res = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
            ty_path,
            decl.type_params,
            do
              contents: --[[ Mnil ]]0
            end
          }));
    lbls = match[0];
    repres = match[1];
    priv = decl.type_private;
    all_labels = Caml_array.caml_make_vect(List.length(lbls), dummy_label);
    describe_labels = function(num, param) do
      if (param) then do
        l = param[0];
        lbl_lbl_name = l.ld_id.name;
        lbl_lbl_arg = l.ld_type;
        lbl_lbl_mut = l.ld_mutable;
        lbl_lbl_loc = l.ld_loc;
        lbl_lbl_attributes = l.ld_attributes;
        lbl = do
          lbl_name: lbl_lbl_name,
          lbl_res: ty_res,
          lbl_arg: lbl_lbl_arg,
          lbl_mut: lbl_lbl_mut,
          lbl_pos: num,
          lbl_all: all_labels,
          lbl_repres: repres,
          lbl_private: priv,
          lbl_loc: lbl_lbl_loc,
          lbl_attributes: lbl_lbl_attributes
        end;
        Caml_array.caml_array_set(all_labels, num, lbl);
        return --[[ :: ]]{
                --[[ tuple ]]{
                  l.ld_id,
                  lbl
                },
                describe_labels(num + 1 | 0, param[1])
              };
      end else do
        return --[[ [] ]]0;
      end end 
    end end;
    return describe_labels(0, lbls);
  end end 
end end

function prefix_idents(root, pos, sub, param) do
  if (param) then do
    match = param[0];
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 0--[[ Sig_value ]] then do
          p_001 = match[0].name;
          p = --[[ Pdot ]]Block.__(1, {
              root,
              p_001,
              pos
            });
          match_1 = match[1].val_kind;
          nextpos;
          nextpos = typeof match_1 == "number" or match_1.tag and pos + 1 | 0 or pos;
          match_2 = prefix_idents(root, nextpos, sub, param[1]);
          return --[[ tuple ]]{
                  --[[ :: ]]{
                    p,
                    match_2[0]
                  },
                  match_2[1]
                }; end end 
       if ___conditional___ == 1--[[ Sig_type ]] then do
          id = match[0];
          p_001_1 = id.name;
          p_1 = --[[ Pdot ]]Block.__(1, {
              root,
              p_001_1,
              -1
            });
          match_3 = prefix_idents(root, pos, add_type(id, p_1, sub), param[1]);
          return --[[ tuple ]]{
                  --[[ :: ]]{
                    p_1,
                    match_3[0]
                  },
                  match_3[1]
                }; end end 
       if ___conditional___ == 2--[[ Sig_typext ]] then do
          p_001_2 = match[0].name;
          p_2 = --[[ Pdot ]]Block.__(1, {
              root,
              p_001_2,
              pos
            });
          match_4 = prefix_idents(root, pos + 1 | 0, sub, param[1]);
          return --[[ tuple ]]{
                  --[[ :: ]]{
                    p_2,
                    match_4[0]
                  },
                  match_4[1]
                }; end end 
       if ___conditional___ == 3--[[ Sig_module ]] then do
          id_1 = match[0];
          p_001_3 = id_1.name;
          p_3 = --[[ Pdot ]]Block.__(1, {
              root,
              p_001_3,
              pos
            });
          match_5 = prefix_idents(root, pos + 1 | 0, add_module(id_1, p_3, sub), param[1]);
          return --[[ tuple ]]{
                  --[[ :: ]]{
                    p_3,
                    match_5[0]
                  },
                  match_5[1]
                }; end end 
       if ___conditional___ == 4--[[ Sig_modtype ]] then do
          id_2 = match[0];
          p_001_4 = id_2.name;
          p_4 = --[[ Pdot ]]Block.__(1, {
              root,
              p_001_4,
              -1
            });
          match_6 = prefix_idents(root, pos, add_modtype(id_2, --[[ Mty_ident ]]Block.__(0, {p_4}), sub), param[1]);
          return --[[ tuple ]]{
                  --[[ :: ]]{
                    p_4,
                    match_6[0]
                  },
                  match_6[1]
                }; end end 
       if ___conditional___ == 5--[[ Sig_class ]] then do
          p_001_5 = match[0].name;
          p_5 = --[[ Pdot ]]Block.__(1, {
              root,
              p_001_5,
              pos
            });
          match_7 = prefix_idents(root, pos + 1 | 0, sub, param[1]);
          return --[[ tuple ]]{
                  --[[ :: ]]{
                    p_5,
                    match_7[0]
                  },
                  match_7[1]
                }; end end 
       if ___conditional___ == 6--[[ Sig_class_type ]] then do
          p_001_6 = match[0].name;
          p_6 = --[[ Pdot ]]Block.__(1, {
              root,
              p_001_6,
              -1
            });
          match_8 = prefix_idents(root, pos, sub, param[1]);
          return --[[ tuple ]]{
                  --[[ :: ]]{
                    p_6,
                    match_8[0]
                  },
                  match_8[1]
                }; end end 
      
    end
  end else do
    return --[[ tuple ]]{
            --[[ [] ]]0,
            sub
          };
  end end 
end end

function prefix_idents_and_subst(root, sub, sg) do
  match = prefix_idents(root, 0, sub, sg);
  sub_1 = match[1];
  return --[[ tuple ]]{
          match[0],
          sub_1,
          Caml_obj.caml_lazy_make((function(param) do
                  sub_2 = sub_1;
                  sg_1 = sg;
                  return List.map((function(item) do
                                local ___conditional___=(item.tag | 0);
                                do
                                   if ___conditional___ == 0--[[ Sig_value ]] then do
                                      return --[[ Sig_value ]]Block.__(0, {
                                                item[0],
                                                value_description(sub_2, item[1])
                                              }); end end 
                                   if ___conditional___ == 1--[[ Sig_type ]] then do
                                      return --[[ Sig_type ]]Block.__(1, {
                                                item[0],
                                                type_declaration(sub_2, item[1]),
                                                item[2]
                                              }); end end 
                                   if ___conditional___ == 2--[[ Sig_typext ]] then do
                                      return --[[ Sig_typext ]]Block.__(2, {
                                                item[0],
                                                extension_constructor(sub_2, item[1]),
                                                item[2]
                                              }); end end 
                                   if ___conditional___ == 3--[[ Sig_module ]] then do
                                      return --[[ Sig_module ]]Block.__(3, {
                                                item[0],
                                                module_declaration(sub_2, item[1]),
                                                item[2]
                                              }); end end 
                                   if ___conditional___ == 4--[[ Sig_modtype ]] then do
                                      return --[[ Sig_modtype ]]Block.__(4, {
                                                item[0],
                                                modtype_declaration(sub_2, item[1])
                                              }); end end 
                                   if ___conditional___ == 5--[[ Sig_class ]] then do
                                      return --[[ Sig_class ]]Block.__(5, {
                                                item[0],
                                                class_declaration(sub_2, item[1]),
                                                item[2]
                                              }); end end 
                                   if ___conditional___ == 6--[[ Sig_class_type ]] then do
                                      return --[[ Sig_class_type ]]Block.__(6, {
                                                item[0],
                                                cltype_declaration(sub_2, item[1]),
                                                item[2]
                                              }); end end 
                                  
                                end
                              end end), sg_1);
                end end))
        };
end end

function prefix_idents_and_subst_1(root, sub, sg) do
  if (Caml_obj.caml_equal(sub, identity)) then do
    sgs;
    xpcall(function() do
      sgs = Hashtbl.find(prefixed_sg, root);
    end end,function(exn) do
      if (exn == Caml_builtin_exceptions.not_found) then do
        sgs_1 = do
          contents: --[[ [] ]]0
        end;
        Hashtbl.add(prefixed_sg, root, sgs_1);
        sgs = sgs_1;
      end else do
        error(exn)
      end end 
    end end)
    xpcall(function() do
      return List.assq(sg, sgs.contents);
    end end,function(exn_1) do
      if (exn_1 == Caml_builtin_exceptions.not_found) then do
        r = prefix_idents_and_subst(root, sub, sg);
        sgs.contents = --[[ :: ]]{
          --[[ tuple ]]{
            sg,
            r
          },
          sgs.contents
        };
        return r;
      end else do
        error(exn_1)
      end end 
    end end)
  end else do
    return prefix_idents_and_subst(root, sub, sg);
  end end 
end end

function add_to_tbl(id, decl, tbl) do
  decls;
  xpcall(function() do
    decls = find_2(id, tbl);
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      decls = --[[ [] ]]0;
    end else do
      error(exn)
    end end 
  end end)
  return add_5(id, --[[ :: ]]{
              decl,
              decls
            }, tbl);
end end

function components_of_module(env, sub, path, mty) do
  return do
          contents: --[[ Thunk ]]Block.__(2, {--[[ tuple ]]{
                env,
                sub,
                path,
                mty
              }})
        end;
end end

function check_usage(loc, id, warn, tbl) do
  if (not loc.loc_ghost and is_active(Curry._1(warn, ""))) then do
    name = id.name;
    key = --[[ tuple ]]{
      name,
      loc
    };
    if (Hashtbl.mem(tbl, key)) then do
      return --[[ () ]]0;
    end else do
      used = do
        contents: false
      end;
      Hashtbl.add(tbl, key, (function(param) do
              used.contents = true;
              return --[[ () ]]0;
            end end));
      if (name == "" or Caml_string.get(name, 0) == --[[ "_" ]]95 or Caml_string.get(name, 0) == --[[ "#" ]]35) then do
        return 0;
      end else do
        return Curry._1(add_delayed_check_forward.contents, (function(param) do
                      if (used.contents) then do
                        return 0;
                      end else do
                        return prerr_warning(loc, Curry._1(warn, name));
                      end end 
                    end end));
      end end 
    end end 
  end else do
    return 0;
  end end 
end end

function check_value_name(name, loc) do
  if (bs_only.contents and name == "|.") then do
    error({
      __Error_2,
      --[[ Illegal_value_name ]]Block.__(4, {
          loc,
          name
        })
    })
  end
   end 
  if (#name ~= 0 and Caml_string.get(name, 0) == --[[ "#" ]]35) then do
    for i = 1 , #name - 1 | 0 , 1 do
      if (Caml_string.get(name, i) == --[[ "#" ]]35) then do
        error({
          __Error_2,
          --[[ Illegal_value_name ]]Block.__(4, {
              loc,
              name
            })
        })
      end
       end 
    end
    return --[[ () ]]0;
  end else do
    return 0;
  end end 
end end

function store_modtype(slot, id, path, info, env, renv) do
  return do
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: add_6("module type", slot, id, --[[ tuple ]]{
                path,
                info
              }, env.modtypes, renv.modtypes),
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: --[[ Env_modtype ]]Block.__(4, {
              env.summary,
              id,
              info
            }),
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        end;
end end

function store_type_infos(slot, id, path, info, env, renv) do
  return do
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: add_6("type", slot, id, --[[ tuple ]]{
                path,
                --[[ tuple ]]{
                  info,
                  --[[ tuple ]]{
                    --[[ [] ]]0,
                    --[[ [] ]]0
                  }
                }
              }, env.types, renv.types),
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: --[[ Env_type ]]Block.__(1, {
              env.summary,
              id,
              info
            }),
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        end;
end end

function store_module(slot, id, path, md, env, renv) do
  return do
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: add_6("module", slot, id, --[[ tuple ]]{
                path,
                md
              }, env.modules, renv.modules),
          modtypes: env.modtypes,
          components: add_6("module", slot, id, --[[ tuple ]]{
                path,
                components_of_module(env, identity, path, md.md_type)
              }, env.components, renv.components),
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: --[[ Env_module ]]Block.__(3, {
              env.summary,
              id,
              md
            }),
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        end;
end end

function components_of_module_maker(param) do
  sub = param[1];
  env = param[0];
  match = scrape_alias(env, undefined, param[3]);
  local ___conditional___=(match.tag | 0);
  do
     if ___conditional___ == 1--[[ Mty_signature ]] then do
        sg = match[0];
        c = do
          comp_values: --[[ Empty ]]0,
          comp_constrs: --[[ Empty ]]0,
          comp_labels: --[[ Empty ]]0,
          comp_types: --[[ Empty ]]0,
          comp_modules: --[[ Empty ]]0,
          comp_modtypes: --[[ Empty ]]0,
          comp_components: --[[ Empty ]]0,
          comp_classes: --[[ Empty ]]0,
          comp_cltypes: --[[ Empty ]]0
        end;
        match_1 = prefix_idents_and_subst_1(param[2], sub, sg);
        sub_1 = match_1[1];
        env_1 = do
          contents: env
        end;
        pos = do
          contents: 0
        end;
        List.iter2((function(item, path) do
                local ___conditional___=(item.tag | 0);
                do
                   if ___conditional___ == 0--[[ Sig_value ]] then do
                      decl = item[1];
                      decl$prime = value_description(sub_1, decl);
                      c.comp_values = add_5(item[0].name, --[[ tuple ]]{
                            decl$prime,
                            pos.contents
                          }, c.comp_values);
                      match = decl.val_kind;
                      if (typeof match == "number" or match.tag) then do
                        pos.contents = pos.contents + 1 | 0;
                        return --[[ () ]]0;
                      end else do
                        return --[[ () ]]0;
                      end end  end end 
                   if ___conditional___ == 1--[[ Sig_type ]] then do
                      decl_1 = item[1];
                      id = item[0];
                      decl$prime_1 = type_declaration(sub_1, decl_1);
                      constructors = List.map((function(prim) do
                              return prim[1];
                            end end), constructors_of_type(path, decl$prime_1));
                      labels = List.map((function(prim) do
                              return prim[1];
                            end end), labels_of_type(path, decl$prime_1));
                      c.comp_types = add_5(id.name, --[[ tuple ]]{
                            --[[ tuple ]]{
                              decl$prime_1,
                              --[[ tuple ]]{
                                constructors,
                                labels
                              }
                            },
                            -1
                          }, c.comp_types);
                      List.iter((function(descr) do
                              c.comp_constrs = add_to_tbl(descr.cstr_name, --[[ tuple ]]{
                                    descr,
                                    -1
                                  }, c.comp_constrs);
                              return --[[ () ]]0;
                            end end), constructors);
                      List.iter((function(descr) do
                              c.comp_labels = add_to_tbl(descr.lbl_name, --[[ tuple ]]{
                                    descr,
                                    -1
                                  }, c.comp_labels);
                              return --[[ () ]]0;
                            end end), labels);
                      env_1.contents = store_type_infos(undefined, id, --[[ Pident ]]Block.__(0, {id}), decl_1, env_1.contents, env_1.contents);
                      return --[[ () ]]0; end end 
                   if ___conditional___ == 2--[[ Sig_typext ]] then do
                      ext$prime = extension_constructor(sub_1, item[1]);
                      descr = extension_descr(path, ext$prime);
                      c.comp_constrs = add_to_tbl(item[0].name, --[[ tuple ]]{
                            descr,
                            pos.contents
                          }, c.comp_constrs);
                      pos.contents = pos.contents + 1 | 0;
                      return --[[ () ]]0; end end 
                   if ___conditional___ == 3--[[ Sig_module ]] then do
                      md = item[1];
                      id_1 = item[0];
                      mty = md.md_type;
                      mty$prime = do
                        contents: --[[ Thunk ]]Block.__(2, {--[[ tuple ]]{
                              sub_1,
                              mty
                            }})
                      end;
                      c.comp_modules = add_5(id_1.name, --[[ tuple ]]{
                            mty$prime,
                            pos.contents
                          }, c.comp_modules);
                      comps = components_of_module(env_1.contents, sub_1, path, mty);
                      c.comp_components = add_5(id_1.name, --[[ tuple ]]{
                            comps,
                            pos.contents
                          }, c.comp_components);
                      env_1.contents = store_module(undefined, id_1, --[[ Pident ]]Block.__(0, {id_1}), md, env_1.contents, env_1.contents);
                      pos.contents = pos.contents + 1 | 0;
                      return --[[ () ]]0; end end 
                   if ___conditional___ == 4--[[ Sig_modtype ]] then do
                      decl_2 = item[1];
                      id_2 = item[0];
                      decl$prime_2 = modtype_declaration(sub_1, decl_2);
                      c.comp_modtypes = add_5(id_2.name, --[[ tuple ]]{
                            decl$prime_2,
                            -1
                          }, c.comp_modtypes);
                      env_1.contents = store_modtype(undefined, id_2, --[[ Pident ]]Block.__(0, {id_2}), decl_2, env_1.contents, env_1.contents);
                      return --[[ () ]]0; end end 
                   if ___conditional___ == 5--[[ Sig_class ]] then do
                      decl$prime_3 = class_declaration(sub_1, item[1]);
                      c.comp_classes = add_5(item[0].name, --[[ tuple ]]{
                            decl$prime_3,
                            pos.contents
                          }, c.comp_classes);
                      pos.contents = pos.contents + 1 | 0;
                      return --[[ () ]]0; end end 
                   if ___conditional___ == 6--[[ Sig_class_type ]] then do
                      decl$prime_4 = cltype_declaration(sub_1, item[1]);
                      c.comp_cltypes = add_5(item[0].name, --[[ tuple ]]{
                            decl$prime_4,
                            pos.contents
                          }, c.comp_cltypes);
                      return --[[ () ]]0; end end 
                  
                end
              end end), sg, match_1[0]);
        return --[[ Structure_comps ]]Block.__(0, {c}); end end 
     if ___conditional___ == 2--[[ Mty_functor ]] then do
        return --[[ Functor_comps ]]Block.__(1, {do
                    fcomp_param: match[0],
                    fcomp_arg: may_map((function(param) do
                            return modtype(sub, param);
                          end end), match[1]),
                    fcomp_res: match[2],
                    fcomp_env: env,
                    fcomp_subst: sub,
                    fcomp_cache: Hashtbl.create(undefined, 17),
                    fcomp_subst_cache: Hashtbl.create(undefined, 17)
                  end}); end end 
     if ___conditional___ == 0--[[ Mty_ident ]]
     or ___conditional___ == 3--[[ Mty_alias ]]
     end
    
  end
  return --[[ Structure_comps ]]Block.__(0, {do
              comp_values: --[[ Empty ]]0,
              comp_constrs: --[[ Empty ]]0,
              comp_labels: --[[ Empty ]]0,
              comp_types: --[[ Empty ]]0,
              comp_modules: --[[ Empty ]]0,
              comp_modtypes: --[[ Empty ]]0,
              comp_components: --[[ Empty ]]0,
              comp_classes: --[[ Empty ]]0,
              comp_cltypes: --[[ Empty ]]0
            end});
end end

function store_value(check, slot, id, path, decl, env, renv) do
  check_value_name(id.name, decl.val_loc);
  may((function(f) do
          return check_usage(decl.val_loc, id, f, value_declarations);
        end end), check);
  return do
          values: add_6("value", slot, id, --[[ tuple ]]{
                path,
                decl
              }, env.values, renv.values),
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: --[[ Env_value ]]Block.__(0, {
              env.summary,
              id,
              decl
            }),
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        end;
end end

function store_type(check, slot, id, path, info, env, renv) do
  loc = info.type_loc;
  if (check) then do
    check_usage(loc, id, (function(s) do
            return --[[ Unused_type_declaration ]]Block.__(18, {s});
          end end), type_declarations);
  end
   end 
  constructors = constructors_of_type(path, info);
  labels = labels_of_type(path, info);
  descrs_000 = List.map((function(prim) do
          return prim[1];
        end end), constructors);
  descrs_001 = List.map((function(prim) do
          return prim[1];
        end end), labels);
  descrs = --[[ tuple ]]{
    descrs_000,
    descrs_001
  };
  if (check and not loc.loc_ghost and is_active(--[[ Unused_constructor ]]Block.__(21, {
            "",
            false,
            false
          }))) then do
    ty = id.name;
    List.iter((function(param) do
            c = param[1].cstr_name;
            k = --[[ tuple ]]{
              ty,
              loc,
              c
            };
            if (Hashtbl.mem(used_constructors, k)) then do
              return 0;
            end else do
              used = do
                cu_positive: false,
                cu_pattern: false,
                cu_privatize: false
              end;
              Hashtbl.add(used_constructors, k, (function(param) do
                      return add_constructor_usage(used, param);
                    end end));
              if (ty == "" or Caml_string.get(ty, 0) == --[[ "_" ]]95) then do
                return 0;
              end else do
                return Curry._1(add_delayed_check_forward.contents, (function(param) do
                              if (not is_in_signature(env) and not used.cu_positive) then do
                                return prerr_warning(loc, --[[ Unused_constructor ]]Block.__(21, {
                                              c,
                                              used.cu_pattern,
                                              used.cu_privatize
                                            }));
                              end else do
                                return 0;
                              end end 
                            end end));
              end end 
            end end 
          end end), constructors);
  end
   end 
  return do
          values: env.values,
          constrs: List.fold_right((function(param, constrs) do
                  return add_6("constructor", slot, param[0], param[1], constrs, renv.constrs);
                end end), constructors, env.constrs),
          labels: List.fold_right((function(param, labels) do
                  return add_6("label", slot, param[0], param[1], labels, renv.labels);
                end end), labels, env.labels),
          types: add_6("type", slot, id, --[[ tuple ]]{
                path,
                --[[ tuple ]]{
                  info,
                  descrs
                }
              }, env.types, renv.types),
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: --[[ Env_type ]]Block.__(1, {
              env.summary,
              id,
              info
            }),
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        end;
end end

function store_extension(check, slot, id, path, ext, env, renv) do
  loc = ext.ext_loc;
  if (check and not loc.loc_ghost and is_active(--[[ Unused_extension ]]Block.__(22, {
            "",
            false,
            false
          }))) then do
    ty = last(ext.ext_type_path);
    n = id.name;
    k = --[[ tuple ]]{
      ty,
      loc,
      n
    };
    if (not Hashtbl.mem(used_constructors, k)) then do
      used = do
        cu_positive: false,
        cu_pattern: false,
        cu_privatize: false
      end;
      Hashtbl.add(used_constructors, k, (function(param) do
              return add_constructor_usage(used, param);
            end end));
      Curry._1(add_delayed_check_forward.contents, (function(param) do
              if (not is_in_signature(env) and not used.cu_positive) then do
                return prerr_warning(loc, --[[ Unused_extension ]]Block.__(22, {
                              n,
                              used.cu_pattern,
                              used.cu_privatize
                            }));
              end else do
                return 0;
              end end 
            end end));
    end
     end 
  end
   end 
  return do
          values: env.values,
          constrs: add_6("constructor", slot, id, extension_descr(path, ext), env.constrs, renv.constrs),
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: --[[ Env_extension ]]Block.__(2, {
              env.summary,
              id,
              ext
            }),
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        end;
end end

function store_class(slot, id, path, desc, env, renv) do
  return do
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: add_6("class", slot, id, --[[ tuple ]]{
                path,
                desc
              }, env.classes, renv.classes),
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: --[[ Env_class ]]Block.__(5, {
              env.summary,
              id,
              desc
            }),
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        end;
end end

function store_cltype(slot, id, path, desc, env, renv) do
  return do
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: add_6("class type", slot, id, --[[ tuple ]]{
                path,
                desc
              }, env.cltypes, renv.cltypes),
          functor_args: env.functor_args,
          summary: --[[ Env_cltype ]]Block.__(6, {
              env.summary,
              id,
              desc
            }),
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        end;
end end

function components_of_functor_appl(f, p1, p2) do
  xpcall(function() do
    return Hashtbl.find(f.fcomp_cache, p2);
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      p = --[[ Papply ]]Block.__(2, {
          p1,
          p2
        });
      mty = modtype(add_module(f.fcomp_param, p2, identity), f.fcomp_res);
      comps = components_of_module(f.fcomp_env, f.fcomp_subst, p, mty);
      Hashtbl.add(f.fcomp_cache, p2, comps);
      return comps;
    end else do
      error(exn)
    end end 
  end end)
end end

components_of_module$prime.contents = components_of_module;

components_of_functor_appl$prime.contents = components_of_functor_appl;

components_of_module_maker$prime.contents = components_of_module_maker;

function add_value(check, id, desc, env) do
  return store_value(check, undefined, id, --[[ Pident ]]Block.__(0, {id}), desc, env, env);
end end

function add_type_1(check, id, info, env) do
  return store_type(check, undefined, id, --[[ Pident ]]Block.__(0, {id}), info, env, env);
end end

function add_extension(check, id, ext, env) do
  return store_extension(check, undefined, id, --[[ Pident ]]Block.__(0, {id}), ext, env, env);
end end

function add_module_declaration(arg, id, md, env) do
  path = --[[ Pident ]]Block.__(0, {id});
  env_1 = store_module(undefined, id, path, md, env, env);
  argOpt = arg;
  id_1 = id;
  env_2 = env_1;
  arg_1 = argOpt ~= undefined and argOpt or false;
  if (arg_1) then do
    return do
            values: env_2.values,
            constrs: env_2.constrs,
            labels: env_2.labels,
            types: env_2.types,
            modules: env_2.modules,
            modtypes: env_2.modtypes,
            components: env_2.components,
            classes: env_2.classes,
            cltypes: env_2.cltypes,
            functor_args: add(id_1, --[[ () ]]0, env_2.functor_args),
            summary: --[[ Env_functor_arg ]]Block.__(8, {
                env_2.summary,
                id_1
              }),
            local_constraints: env_2.local_constraints,
            gadt_instances: env_2.gadt_instances,
            flags: env_2.flags
          end;
  end else do
    return env_2;
  end end 
end end

function add_modtype_1(id, info, env) do
  return store_modtype(undefined, id, --[[ Pident ]]Block.__(0, {id}), info, env, env);
end end

function add_class(id, ty, env) do
  return store_class(undefined, id, --[[ Pident ]]Block.__(0, {id}), ty, env, env);
end end

function add_cltype(id, ty, env) do
  return store_cltype(undefined, id, --[[ Pident ]]Block.__(0, {id}), ty, env, env);
end end

function add_module_1(arg, id, mty, env) do
  return add_module_declaration(arg, id, do
              md_type: mty,
              md_attributes: --[[ [] ]]0,
              md_loc: none
            end, env);
end end

function add_local_constraint(id, info, elv, env) do
  if (info.type_manifest ~= undefined) then do
    match = info.type_newtype_level;
    if (match ~= undefined) then do
      env_1 = add_type_1(false, id, do
            type_params: info.type_params,
            type_arity: info.type_arity,
            type_kind: info.type_kind,
            type_private: info.type_private,
            type_manifest: info.type_manifest,
            type_variance: info.type_variance,
            type_newtype_level: --[[ tuple ]]{
              match[0],
              elv
            },
            type_loc: info.type_loc,
            type_attributes: info.type_attributes
          end, env);
      return do
              values: env_1.values,
              constrs: env_1.constrs,
              labels: env_1.labels,
              types: env_1.types,
              modules: env_1.modules,
              modtypes: env_1.modtypes,
              components: env_1.components,
              classes: env_1.classes,
              cltypes: env_1.cltypes,
              functor_args: env_1.functor_args,
              summary: env_1.summary,
              local_constraints: true,
              gadt_instances: env_1.gadt_instances,
              flags: env_1.flags
            end;
    end else do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "env.ml",
          1538,
          9
        }
      })
    end end 
  end else do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "env.ml",
        1538,
        9
      }
    })
  end end 
end end

function enter(store_fun, name, data, env) do
  id = create(name);
  return --[[ tuple ]]{
          id,
          Curry._6(store_fun, undefined, id, --[[ Pident ]]Block.__(0, {id}), data, env, env)
        };
end end

function enter_value(check) do
  return (function(param, param_1, param_2) do
      return enter((function(param, param_1, param_2, param_3, param_4, param_5) do
                    return store_value(check, param, param_1, param_2, param_3, param_4, param_5);
                  end end), param, param_1, param_2);
    end end);
end end

function enter_type(param, param_1, param_2) do
  return enter((function(param, param_1, param_2, param_3, param_4, param_5) do
                return store_type(true, param, param_1, param_2, param_3, param_4, param_5);
              end end), param, param_1, param_2);
end end

function enter_module_declaration(arg, name, md, env) do
  id = create(name);
  return --[[ tuple ]]{
          id,
          add_module_declaration(arg, id, md, env)
        };
end end

function enter_modtype(param, param_1, param_2) do
  return enter(store_modtype, param, param_1, param_2);
end end

function enter_module(arg, s, mty, env) do
  return enter_module_declaration(arg, s, do
              md_type: mty,
              md_attributes: --[[ [] ]]0,
              md_loc: none
            end, env);
end end

function add_item(comp, env) do
  local ___conditional___=(comp.tag | 0);
  do
     if ___conditional___ == 0--[[ Sig_value ]] then do
        return add_value(undefined, comp[0], comp[1], env); end end 
     if ___conditional___ == 1--[[ Sig_type ]] then do
        return add_type_1(false, comp[0], comp[1], env); end end 
     if ___conditional___ == 2--[[ Sig_typext ]] then do
        return add_extension(false, comp[0], comp[1], env); end end 
     if ___conditional___ == 3--[[ Sig_module ]] then do
        return add_module_declaration(undefined, comp[0], comp[1], env); end end 
     if ___conditional___ == 4--[[ Sig_modtype ]] then do
        return add_modtype_1(comp[0], comp[1], env); end end 
     if ___conditional___ == 5--[[ Sig_class ]] then do
        return add_class(comp[0], comp[1], env); end end 
     if ___conditional___ == 6--[[ Sig_class_type ]] then do
        return add_cltype(comp[0], comp[1], env); end end 
    
  end
end end

function add_signature(_sg, _env) do
  while(true) do
    env = _env;
    sg = _sg;
    if (sg) then do
      _env = add_item(sg[0], env);
      _sg = sg[1];
      ::continue:: ;
    end else do
      return env;
    end end 
  end;
end end

function open_signature(slot, root, sg, env0) do
  match = prefix_idents_and_subst_1(root, identity, sg);
  sg_1 = CamlinternalLazy.force(match[2]);
  newenv = List.fold_left2((function(env, item, p) do
          local ___conditional___=(item.tag | 0);
          do
             if ___conditional___ == 0--[[ Sig_value ]] then do
                return store_value(undefined, slot, hide(item[0]), p, item[1], env, env0); end end 
             if ___conditional___ == 1--[[ Sig_type ]] then do
                return store_type(false, slot, hide(item[0]), p, item[1], env, env0); end end 
             if ___conditional___ == 2--[[ Sig_typext ]] then do
                return store_extension(false, slot, hide(item[0]), p, item[1], env, env0); end end 
             if ___conditional___ == 3--[[ Sig_module ]] then do
                return store_module(slot, hide(item[0]), p, item[1], env, env0); end end 
             if ___conditional___ == 4--[[ Sig_modtype ]] then do
                return store_modtype(slot, hide(item[0]), p, item[1], env, env0); end end 
             if ___conditional___ == 5--[[ Sig_class ]] then do
                return store_class(slot, hide(item[0]), p, item[1], env, env0); end end 
             if ___conditional___ == 6--[[ Sig_class_type ]] then do
                return store_cltype(slot, hide(item[0]), p, item[1], env, env0); end end 
            
          end
        end end), env0, sg_1, match[0]);
  return do
          values: newenv.values,
          constrs: newenv.constrs,
          labels: newenv.labels,
          types: newenv.types,
          modules: newenv.modules,
          modtypes: newenv.modtypes,
          components: newenv.components,
          classes: newenv.classes,
          cltypes: newenv.cltypes,
          functor_args: newenv.functor_args,
          summary: --[[ Env_open ]]Block.__(7, {
              env0.summary,
              root
            }),
          local_constraints: newenv.local_constraints,
          gadt_instances: newenv.gadt_instances,
          flags: newenv.flags
        end;
end end

function open_signature_1(locOpt, toplevelOpt, ovf, root, sg, env) do
  loc = locOpt ~= undefined and locOpt or none;
  toplevel = toplevelOpt ~= undefined and toplevelOpt or false;
  if (not toplevel and ovf == --[[ Fresh ]]1 and not loc.loc_ghost and (is_active(--[[ Unused_open ]]Block.__(17, {""})) or is_active(--[[ Open_shadow_identifier ]]Block.__(27, {
              "",
              ""
            })) or is_active(--[[ Open_shadow_label_constructor ]]Block.__(28, {
              "",
              ""
            })))) then do
    used = do
      contents: false
    end;
    Curry._1(add_delayed_check_forward.contents, (function(param) do
            if (used.contents) then do
              return 0;
            end else do
              return prerr_warning(loc, --[[ Unused_open ]]Block.__(17, {name(undefined, root)}));
            end end 
          end end));
    shadowed = do
      contents: --[[ [] ]]0
    end;
    slot = function(kind, s, b) do
      if (b and not List.mem(--[[ tuple ]]{
              kind,
              s
            }, shadowed.contents)) then do
        shadowed.contents = --[[ :: ]]{
          --[[ tuple ]]{
            kind,
            s
          },
          shadowed.contents
        };
        w;
        local ___conditional___=(kind);
        do
           if ___conditional___ == "constructor"
           or ___conditional___ == "label" then do
              w = --[[ Open_shadow_label_constructor ]]Block.__(28, {
                  kind,
                  s
                }); end else 
           end end
          w = --[[ Open_shadow_identifier ]]Block.__(27, {
                kind,
                s
              });
            
        end
        prerr_warning(loc, w);
      end
       end 
      used.contents = true;
      return --[[ () ]]0;
    end end;
    return open_signature(slot, root, sg, env);
  end else do
    return open_signature(undefined, root, sg, env);
  end end 
end end

function read_signature(modname, filename) do
  ps = read_pers_struct(modname, filename);
  check_consistency(ps);
  return ps.ps_sig;
end end

function imports(param) do
  dont_record_crc_unit_1 = dont_record_crc_unit.contents;
  if (dont_record_crc_unit_1 ~= undefined) then do
    x = dont_record_crc_unit_1;
    return extract(fold_5((function(m, acc) do
                      if (m == x) then do
                        return acc;
                      end else do
                        return --[[ :: ]]{
                                m,
                                acc
                              };
                      end end 
                    end end), imported_units.contents, --[[ [] ]]0), crc_units);
  end else do
    return extract(elements_aux_2(--[[ [] ]]0, imported_units.contents), crc_units);
  end end 
end end

function save_signature(sg, modname, filename) do
  sg_1 = sg;
  modname_1 = modname;
  filename_1 = filename;
  imports_1 = imports(--[[ () ]]0);
  cleanup_abbrev(--[[ () ]]0);
  new_id_1.contents = -1;
  sg_2 = signature_2(for_saving(identity), sg_1);
  oc = Pervasives.open_out_bin(filename_1);
  xpcall(function() do
    cmi_cmi_flags = recursive_types.contents and --[[ :: ]]{
        --[[ Rectypes ]]0,
        --[[ [] ]]0
      } or --[[ [] ]]0;
    cmi = do
      cmi_name: modname_1,
      cmi_sign: sg_2,
      cmi_crcs: imports_1,
      cmi_flags: cmi_cmi_flags
    end;
    crc = output_cmi(filename_1, oc, cmi);
    Caml_io.caml_ml_flush(oc);
    Caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
    comps = components_of_module(empty, identity, --[[ Pident ]]Block.__(0, {do
              stamp: 0,
              name: modname_1,
              flags: 1
            end}), --[[ Mty_signature ]]Block.__(1, {sg_2}));
    ps = do
      ps_name: modname_1,
      ps_sig: sg_2,
      ps_comps: comps,
      ps_crcs: --[[ :: ]]{
        --[[ tuple ]]{
          modname_1,
          crc
        },
        imports_1
      },
      ps_crcs_checked: false,
      ps_filename: filename_1,
      ps_flags: cmi_cmi_flags
    end;
    save_pers_struct(crc, ps);
    return sg_2;
  end end,function(exn) do
    Caml_io.caml_ml_flush(oc);
    Caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
    remove_file(filename_1);
    error(exn)
  end end)
end end

function find_all_1(proj1, proj2, f, lid, env, acc) do
  if (lid ~= undefined) then do
    match = lookup_module_descr(lid, env);
    p = match[0];
    match_1 = force(components_of_module_maker, match[1]);
    if (match_1.tag) then do
      return acc;
    end else do
      return fold_4((function(s, param, acc) do
                    return Curry._4(f, s, --[[ Pdot ]]Block.__(1, {
                                  p,
                                  s,
                                  param[1]
                                }), param[0], acc);
                  end end), Curry._1(proj2, match_1[0]), acc);
    end end 
  end else do
    return fold_name((function(id, param, acc) do
                    return Curry._4(f, id.name, param[0], param[1], acc);
                  end end))(Curry._1(proj1, env), acc);
  end end 
end end

function find_all_simple_list(proj1, proj2, f, lid, env, acc) do
  if (lid ~= undefined) then do
    match = lookup_module_descr(lid, env);
    match_1 = force(components_of_module_maker, match[1]);
    if (match_1.tag) then do
      return acc;
    end else do
      return fold_4((function(s, comps, acc) do
                    if (comps) then do
                      return Curry._2(f, comps[0][0], acc);
                    end else do
                      return acc;
                    end end 
                  end end), Curry._1(proj2, match_1[0]), acc);
    end end 
  end else do
    return fold_name((function(id, data, acc) do
                    return Curry._2(f, data, acc);
                  end end))(Curry._1(proj1, env), acc);
  end end 
end end

function fold_modules(f, lid, env, acc) do
  if (lid ~= undefined) then do
    match = lookup_module_descr(lid, env);
    p = match[0];
    match_1 = force(components_of_module_maker, match[1]);
    if (match_1.tag) then do
      return acc;
    end else do
      return fold_4((function(s, param, acc) do
                    md_type = force(subst_modtype_maker, param[0]);
                    return Curry._4(f, s, --[[ Pdot ]]Block.__(1, {
                                  p,
                                  s,
                                  param[1]
                                }), do
                                md_type: md_type,
                                md_attributes: --[[ [] ]]0,
                                md_loc: none
                              end, acc);
                  end end), match_1[0].comp_modules, acc);
    end end 
  end else do
    acc_1 = fold_name((function(id, param, acc) do
              return Curry._4(f, id.name, param[0], param[1], acc);
            end end))(env.modules, acc);
    return Hashtbl.fold((function(name, ps, acc) do
                  if (ps ~= undefined) then do
                    return Curry._4(f, name, --[[ Pident ]]Block.__(0, {do
                                    stamp: 0,
                                    name: name,
                                    flags: 1
                                  end}), do
                                md_type: --[[ Mty_signature ]]Block.__(1, {ps.ps_sig}),
                                md_attributes: --[[ [] ]]0,
                                md_loc: none
                              end, acc);
                  end else do
                    return acc;
                  end end 
                end end), persistent_structures, acc_1);
  end end 
end end

function fold_values(f) do
  return (function(param, param_1, param_2) do
      return find_all_1((function(env) do
                    return env.values;
                  end end), (function(sc) do
                    return sc.comp_values;
                  end end), f, param, param_1, param_2);
    end end);
end end

function fold_constructors(f) do
  return (function(param, param_1, param_2) do
      return find_all_simple_list((function(env) do
                    return env.constrs;
                  end end), (function(sc) do
                    return sc.comp_constrs;
                  end end), f, param, param_1, param_2);
    end end);
end end

function fold_labels(f) do
  return (function(param, param_1, param_2) do
      return find_all_simple_list((function(env) do
                    return env.labels;
                  end end), (function(sc) do
                    return sc.comp_labels;
                  end end), f, param, param_1, param_2);
    end end);
end end

function fold_types(f) do
  return (function(param, param_1, param_2) do
      return find_all_1((function(env) do
                    return env.types;
                  end end), (function(sc) do
                    return sc.comp_types;
                  end end), f, param, param_1, param_2);
    end end);
end end

function fold_modtypes(f) do
  return (function(param, param_1, param_2) do
      return find_all_1((function(env) do
                    return env.modtypes;
                  end end), (function(sc) do
                    return sc.comp_modtypes;
                  end end), f, param, param_1, param_2);
    end end);
end end

function fold_classs(f) do
  return (function(param, param_1, param_2) do
      return find_all_1((function(env) do
                    return env.classes;
                  end end), (function(sc) do
                    return sc.comp_classes;
                  end end), f, param, param_1, param_2);
    end end);
end end

function fold_cltypes(f) do
  return (function(param, param_1, param_2) do
      return find_all_1((function(env) do
                    return env.cltypes;
                  end end), (function(sc) do
                    return sc.comp_cltypes;
                  end end), f, param, param_1, param_2);
    end end);
end end

match = build_initial_env((function(param, param_1, param_2) do
        return add_type_1(false, param, param_1, param_2);
      end end), (function(param, param_1, param_2) do
        return add_extension(false, param, param_1, param_2);
      end end), empty);

initial_safe_string = match[0];

last_env = do
  contents: empty
end;

last_reduced_env = do
  contents: empty
end;

function keep_only_summary(env) do
  if (last_env.contents == env) then do
    return last_reduced_env.contents;
  end else do
    new_env_summary = env.summary;
    new_env_local_constraints = env.local_constraints;
    new_env_flags = env.flags;
    new_env = do
      values: --[[ Empty ]]0,
      constrs: --[[ Empty ]]0,
      labels: --[[ Empty ]]0,
      types: --[[ Empty ]]0,
      modules: --[[ Empty ]]0,
      modtypes: --[[ Empty ]]0,
      components: --[[ Empty ]]0,
      classes: --[[ Empty ]]0,
      cltypes: --[[ Empty ]]0,
      functor_args: --[[ Empty ]]0,
      summary: new_env_summary,
      local_constraints: new_env_local_constraints,
      gadt_instances: --[[ [] ]]0,
      flags: new_env_flags
    end;
    last_env.contents = env;
    last_reduced_env.contents = new_env;
    return new_env;
  end end 
end end

function report_error_1(ppf, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Illegal_renaming ]] then do
        return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ String_literal ]]Block.__(11, {
                            "Wrong file naming: ",
                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                    --[[ Break ]]Block.__(0, {
                                        "@ ",
                                        1,
                                        0
                                      }),
                                    --[[ String_literal ]]Block.__(11, {
                                        "contains the compiled interface for ",
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ String ]]Block.__(2, {
                                                --[[ No_padding ]]0,
                                                --[[ String_literal ]]Block.__(11, {
                                                    " when ",
                                                    --[[ String ]]Block.__(2, {
                                                        --[[ No_padding ]]0,
                                                        --[[ String_literal ]]Block.__(11, {
                                                            " was expected",
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })
                                                  })
                                              })
                                          })
                                      })
                                  })})
                          }),
                        "Wrong file naming: %a@ contains the compiled interface for @ %s when %s was expected"
                      }), print_filename, param[2], param[0], param[1]); end end 
     if ___conditional___ == 1--[[ Inconsistent_import ]] then do
        return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      "<hov>",
                                      --[[ End_of_format ]]0
                                    }),
                                  "<hov>"
                                }}),
                            --[[ String_literal ]]Block.__(11, {
                                "The files ",
                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Break ]]Block.__(0, {
                                            "@ ",
                                            1,
                                            0
                                          }),
                                        --[[ String_literal ]]Block.__(11, {
                                            "and ",
                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "make inconsistent assumptions",
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Break ]]Block.__(0, {
                                                                "@ ",
                                                                1,
                                                                0
                                                              }),
                                                            --[[ String_literal ]]Block.__(11, {
                                                                "over interface ",
                                                                --[[ String ]]Block.__(2, {
                                                                    --[[ No_padding ]]0,
                                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                                        --[[ Close_box ]]0,
                                                                        --[[ End_of_format ]]0
                                                                      })
                                                                  })
                                                              })
                                                          })
                                                      })
                                                  })})
                                          })
                                      })})
                              })
                          }),
                        "@[<hov>The files %a@ and %a@ make inconsistent assumptions@ over interface %s@]"
                      }), print_filename, param[1], print_filename, param[2], param[0]); end end 
     if ___conditional___ == 2--[[ Need_recursive_types ]] then do
        return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      "<hov>",
                                      --[[ End_of_format ]]0
                                    }),
                                  "<hov>"
                                }}),
                            --[[ String_literal ]]Block.__(11, {
                                "Unit ",
                                --[[ String ]]Block.__(2, {
                                    --[[ No_padding ]]0,
                                    --[[ String_literal ]]Block.__(11, {
                                        " imports from ",
                                        --[[ String ]]Block.__(2, {
                                            --[[ No_padding ]]0,
                                            --[[ String_literal ]]Block.__(11, {
                                                ", which uses recursive types.",
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ String ]]Block.__(2, {
                                                        --[[ No_padding ]]0,
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Close_box ]]0,
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })
                                                  })
                                              })
                                          })
                                      })
                                  })
                              })
                          }),
                        "@[<hov>Unit %s imports from %s, which uses recursive types.@ %s@]"
                      }), param[1], param[0], "The compilation flag -rectypes is required"); end end 
     if ___conditional___ == 3--[[ Missing_module ]] then do
        path2 = param[2];
        path1 = param[1];
        Format.fprintf(ppf, --[[ Format ]]{
              --[[ Formatting_gen ]]Block.__(18, {
                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                        --[[ End_of_format ]]0,
                        ""
                      }}),
                  --[[ Formatting_gen ]]Block.__(18, {
                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                            --[[ String_literal ]]Block.__(11, {
                                "<hov>",
                                --[[ End_of_format ]]0
                              }),
                            "<hov>"
                          }}),
                      --[[ End_of_format ]]0
                    })
                }),
              "@[@[<hov>"
            });
        if (same(path1, path2)) then do
          Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ String_literal ]]Block.__(11, {
                        "Internal path",
                        --[[ Formatting_lit ]]Block.__(17, {
                            --[[ Break ]]Block.__(0, {
                                "@ ",
                                1,
                                0
                              }),
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ Formatting_lit ]]Block.__(17, {
                                    --[[ Break ]]Block.__(0, {
                                        "@ ",
                                        1,
                                        0
                                      }),
                                    --[[ String_literal ]]Block.__(11, {
                                        "is dangling.",
                                        --[[ End_of_format ]]0
                                      })
                                  })
                              })
                          })
                      }),
                    "Internal path@ %s@ is dangling."
                  }), name(undefined, path1));
        end else do
          Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ String_literal ]]Block.__(11, {
                        "Internal path",
                        --[[ Formatting_lit ]]Block.__(17, {
                            --[[ Break ]]Block.__(0, {
                                "@ ",
                                1,
                                0
                              }),
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ Formatting_lit ]]Block.__(17, {
                                    --[[ Break ]]Block.__(0, {
                                        "@ ",
                                        1,
                                        0
                                      }),
                                    --[[ String_literal ]]Block.__(11, {
                                        "expands to",
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ String ]]Block.__(2, {
                                                --[[ No_padding ]]0,
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "which is dangling.",
                                                        --[[ End_of_format ]]0
                                                      })
                                                  })
                                              })
                                          })
                                      })
                                  })
                              })
                          })
                      }),
                    "Internal path@ %s@ expands to@ %s@ which is dangling."
                  }), name(undefined, path1), name(undefined, path2));
        end end 
        return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_lit ]]Block.__(17, {
                            --[[ Close_box ]]0,
                            --[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@ ",
                                    1,
                                    0
                                  }),
                                --[[ Formatting_gen ]]Block.__(18, {
                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                          --[[ End_of_format ]]0,
                                          ""
                                        }}),
                                    --[[ String ]]Block.__(2, {
                                        --[[ No_padding ]]0,
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ String ]]Block.__(2, {
                                                --[[ No_padding ]]0,
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ String ]]Block.__(2, {
                                                        --[[ No_padding ]]0,
                                                        --[[ Char_literal ]]Block.__(12, {
                                                            --[[ "." ]]46,
                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                --[[ Close_box ]]0,
                                                                --[[ Formatting_lit ]]Block.__(17, {
                                                                    --[[ Close_box ]]0,
                                                                    --[[ End_of_format ]]0
                                                                  })
                                                              })
                                                          })
                                                      })
                                                  })
                                              })
                                          })
                                      })
                                  })
                              })
                          }),
                        "@]@ @[%s@ %s@ %s.@]@]"
                      }), "The compiled interface for module", head(path2).name, "was not found"); end end 
     if ___conditional___ == 4--[[ Illegal_value_name ]] then do
        return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Char_literal ]]Block.__(12, {
                            --[[ "'" ]]39,
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ String_literal ]]Block.__(11, {
                                    "' is not a valid value identifier.",
                                    --[[ End_of_format ]]0
                                  })
                              })
                          }),
                        "'%s' is not a valid value identifier."
                      }), param[1]); end end 
    
  end
end end

register_error_of_exn((function(param) do
        if (param[0] == __Error_2) then do
          err = param[1];
          local ___conditional___=(err.tag | 0);
          do
             if ___conditional___ == 3--[[ Missing_module ]]
             or ___conditional___ == 4--[[ Illegal_value_name ]]
             end
            return error_of_printer_file(report_error_1, err);
              
          end
          loc = err[0];
          if (Caml_obj.caml_notequal(loc, none)) then do
            return error_of_printer(loc, report_error_1, err);
          end else do
            return error_of_printer_file(report_error_1, err);
          end end 
        end
         end 
      end end));

function assert_fail(msg) do
  Assert.fail(--[[ () ]]0, --[[ () ]]0, msg, "");
  return --[[ () ]]0;
end end

function is_mocha(param) do
  match = __Array.to_list(Process.argv);
  if (match) then do
    match_1 = match[1];
    if (match_1) then do
      exec = Path.basename(match_1[0]);
      if (exec == "mocha") then do
        return true;
      end else do
        return exec == "_mocha";
      end end 
    end else do
      return false;
    end end 
  end else do
    return false;
  end end 
end end

function close_enough(thresholdOpt, a, b) do
  threshold = thresholdOpt ~= undefined and thresholdOpt or 0.0000001;
  return Math.abs(a - b) < threshold;
end end

function from_pair_suites(name, suites) do
  match = __Array.to_list(Process.argv);
  if (match) then do
    if (is_mocha(--[[ () ]]0)) then do
      describe(name, (function() do
              return List.iter((function(param) do
                            code = param[1];
                            it(param[0], (function() do
                                    spec = Curry._1(code, --[[ () ]]0);
                                    local ___conditional___=(spec.tag | 0);
                                    do
                                       if ___conditional___ == 0--[[ Eq ]] then do
                                          Assert.deepEqual(spec[0], spec[1]);
                                          return --[[ () ]]0; end end 
                                       if ___conditional___ == 1--[[ Neq ]] then do
                                          Assert.notDeepEqual(spec[0], spec[1]);
                                          return --[[ () ]]0; end end 
                                       if ___conditional___ == 2--[[ StrictEq ]] then do
                                          Assert.strictEqual(spec[0], spec[1]);
                                          return --[[ () ]]0; end end 
                                       if ___conditional___ == 3--[[ StrictNeq ]] then do
                                          Assert.notStrictEqual(spec[0], spec[1]);
                                          return --[[ () ]]0; end end 
                                       if ___conditional___ == 4--[[ Ok ]] then do
                                          Assert.ok(spec[0]);
                                          return --[[ () ]]0; end end 
                                       if ___conditional___ == 5--[[ Approx ]] then do
                                          b = spec[1];
                                          a = spec[0];
                                          if (close_enough(undefined, a, b)) then do
                                            return 0;
                                          end else do
                                            Assert.deepEqual(a, b);
                                            return --[[ () ]]0;
                                          end end  end end 
                                       if ___conditional___ == 6--[[ ApproxThreshold ]] then do
                                          b_1 = spec[2];
                                          a_1 = spec[1];
                                          if (close_enough(spec[0], a_1, b_1)) then do
                                            return 0;
                                          end else do
                                            Assert.deepEqual(a_1, b_1);
                                            return --[[ () ]]0;
                                          end end  end end 
                                       if ___conditional___ == 7--[[ ThrowAny ]] then do
                                          Assert.throws(spec[0]);
                                          return --[[ () ]]0; end end 
                                       if ___conditional___ == 8--[[ Fail ]] then do
                                          return assert_fail("failed"); end end 
                                       if ___conditional___ == 9--[[ FailWith ]] then do
                                          return assert_fail(spec[0]); end end 
                                      
                                    end
                                  end end));
                            return --[[ () ]]0;
                          end end), suites);
            end end));
      return --[[ () ]]0;
    end else do
      name_1 = name;
      suites_1 = suites;
      console.log(--[[ tuple ]]{
            name_1,
            "testing"
          });
      return List.iter((function(param) do
                    name = param[0];
                    match = Curry._1(param[1], --[[ () ]]0);
                    local ___conditional___=(match.tag | 0);
                    do
                       if ___conditional___ == 0--[[ Eq ]] then do
                          console.log(--[[ tuple ]]{
                                name,
                                match[0],
                                "eq?",
                                match[1]
                              });
                          return --[[ () ]]0; end end 
                       if ___conditional___ == 1--[[ Neq ]] then do
                          console.log(--[[ tuple ]]{
                                name,
                                match[0],
                                "neq?",
                                match[1]
                              });
                          return --[[ () ]]0; end end 
                       if ___conditional___ == 2--[[ StrictEq ]] then do
                          console.log(--[[ tuple ]]{
                                name,
                                match[0],
                                "strict_eq?",
                                match[1]
                              });
                          return --[[ () ]]0; end end 
                       if ___conditional___ == 3--[[ StrictNeq ]] then do
                          console.log(--[[ tuple ]]{
                                name,
                                match[0],
                                "strict_neq?",
                                match[1]
                              });
                          return --[[ () ]]0; end end 
                       if ___conditional___ == 4--[[ Ok ]] then do
                          console.log(--[[ tuple ]]{
                                name,
                                match[0],
                                "ok?"
                              });
                          return --[[ () ]]0; end end 
                       if ___conditional___ == 5--[[ Approx ]] then do
                          console.log(--[[ tuple ]]{
                                name,
                                match[0],
                                "~",
                                match[1]
                              });
                          return --[[ () ]]0; end end 
                       if ___conditional___ == 6--[[ ApproxThreshold ]] then do
                          console.log(--[[ tuple ]]{
                                name,
                                match[1],
                                "~",
                                match[2],
                                " (",
                                match[0],
                                ")"
                              });
                          return --[[ () ]]0; end end 
                       if ___conditional___ == 7--[[ ThrowAny ]] then do
                          return --[[ () ]]0; end end 
                       if ___conditional___ == 8--[[ Fail ]] then do
                          console.log("failed");
                          return --[[ () ]]0; end end 
                       if ___conditional___ == 9--[[ FailWith ]] then do
                          console.log("failed: " .. match[0]);
                          return --[[ () ]]0; end end 
                      
                    end
                  end end), suites_1);
    end end 
  end else do
    return --[[ () ]]0;
  end end 
end end

Promise.resolve(--[[ () ]]0);

__Error_3 = Caml_exceptions.create("Ocaml_typedtree_test.Syntaxerr.Error");

Escape_error = Caml_exceptions.create("Ocaml_typedtree_test.Syntaxerr.Escape_error");

function prepare_error(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Unclosed ]] then do
        closing = param[3];
        opening = param[1];
        return Curry._1(errorf(param[2], --[[ :: ]]{
                        Curry._1(errorf(param[0], undefined, undefined, --[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      "This '",
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ String_literal ]]Block.__(11, {
                                              "' might be unmatched",
                                              --[[ End_of_format ]]0
                                            })
                                        })
                                    }),
                                  "This '%s' might be unmatched"
                                }), opening),
                        --[[ [] ]]0
                      }, Curry._2(Printf.sprintf(--[[ Format ]]{
                                --[[ String_literal ]]Block.__(11, {
                                    "Syntax error: '",
                                    --[[ String ]]Block.__(2, {
                                        --[[ No_padding ]]0,
                                        --[[ String_literal ]]Block.__(11, {
                                            "' expected, the highlighted '",
                                            --[[ String ]]Block.__(2, {
                                                --[[ No_padding ]]0,
                                                --[[ String_literal ]]Block.__(11, {
                                                    "' might be unmatched",
                                                    --[[ End_of_format ]]0
                                                  })
                                              })
                                          })
                                      })
                                  }),
                                "Syntax error: '%s' expected, the highlighted '%s' might be unmatched"
                              }), closing, opening), --[[ Format ]]{
                        --[[ String_literal ]]Block.__(11, {
                            "Syntax error: '",
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ String_literal ]]Block.__(11, {
                                    "' expected",
                                    --[[ End_of_format ]]0
                                  })
                              })
                          }),
                        "Syntax error: '%s' expected"
                      }), closing); end end 
     if ___conditional___ == 1--[[ Expecting ]] then do
        return Curry._1(errorf(param[0], undefined, undefined, --[[ Format ]]{
                        --[[ String_literal ]]Block.__(11, {
                            "Syntax error: ",
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ String_literal ]]Block.__(11, {
                                    " expected.",
                                    --[[ End_of_format ]]0
                                  })
                              })
                          }),
                        "Syntax error: %s expected."
                      }), param[1]); end end 
     if ___conditional___ == 2--[[ Not_expecting ]] then do
        return Curry._1(errorf(param[0], undefined, undefined, --[[ Format ]]{
                        --[[ String_literal ]]Block.__(11, {
                            "Syntax error: ",
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ String_literal ]]Block.__(11, {
                                    " not expected.",
                                    --[[ End_of_format ]]0
                                  })
                              })
                          }),
                        "Syntax error: %s not expected."
                      }), param[1]); end end 
     if ___conditional___ == 3--[[ Applicative_path ]] then do
        return errorf(param[0], undefined, undefined, --[[ Format ]]{
                    --[[ String_literal ]]Block.__(11, {
                        "Syntax error: applicative paths of the form F(X).t are not supported when the option -no-app-func is set.",
                        --[[ End_of_format ]]0
                      }),
                    "Syntax error: applicative paths of the form F(X).t are not supported when the option -no-app-func is set."
                  }); end end 
     if ___conditional___ == 4--[[ Variable_in_scope ]] then do
        __var = param[1];
        return Curry._2(errorf(param[0], undefined, undefined, --[[ Format ]]{
                        --[[ String_literal ]]Block.__(11, {
                            "In this scoped type, variable '",
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ String_literal ]]Block.__(11, {
                                    " is reserved for the local type ",
                                    --[[ String ]]Block.__(2, {
                                        --[[ No_padding ]]0,
                                        --[[ Char_literal ]]Block.__(12, {
                                            --[[ "." ]]46,
                                            --[[ End_of_format ]]0
                                          })
                                      })
                                  })
                              })
                          }),
                        "In this scoped type, variable '%s is reserved for the local type %s."
                      }), __var, __var); end end 
     if ___conditional___ == 5--[[ Other ]] then do
        return errorf(param[0], undefined, undefined, --[[ Format ]]{
                    --[[ String_literal ]]Block.__(11, {
                        "Syntax error",
                        --[[ End_of_format ]]0
                      }),
                    "Syntax error"
                  }); end end 
     if ___conditional___ == 6--[[ Ill_formed_ast ]] then do
        return Curry._1(errorf(param[0], undefined, undefined, --[[ Format ]]{
                        --[[ String_literal ]]Block.__(11, {
                            "broken invariant in parsetree: ",
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ End_of_format ]]0
                              })
                          }),
                        "broken invariant in parsetree: %s"
                      }), param[1]); end end 
    
  end
end end

register_error_of_exn((function(param) do
        if (param[0] == __Error_3) then do
          return prepare_error(param[1]);
        end
         end 
      end end));

function ill_formed_ast(loc, s) do
  error({
    __Error_3,
    --[[ Ill_formed_ast ]]Block.__(6, {
        loc,
        s
      })
  })
end end

function mktyp(d) do
  return mk(symbol_rloc(--[[ () ]]0), undefined, d);
end end

function mkpat(d) do
  return mk_1(symbol_rloc(--[[ () ]]0), undefined, d);
end end

function mkexp(d) do
  return Curry._3(Ast_helper_Exp.mk, symbol_rloc(--[[ () ]]0), undefined, d);
end end

function mkmty(d) do
  return mk_3(symbol_rloc(--[[ () ]]0), undefined, d);
end end

function mksig(d) do
  return mk_5(symbol_rloc(--[[ () ]]0), d);
end end

function mkmod(d) do
  return mk_4(symbol_rloc(--[[ () ]]0), undefined, d);
end end

function mkstr(d) do
  return mk_6(symbol_rloc(--[[ () ]]0), d);
end end

function mkclass(d) do
  return mk_7(symbol_rloc(--[[ () ]]0), undefined, d);
end end

function mkcty(d) do
  return mk_8(symbol_rloc(--[[ () ]]0), undefined, d);
end end

function mkctf(attrs, docs, d) do
  return Curry._4(Ast_helper_Ctf.mk, symbol_rloc(--[[ () ]]0), attrs, docs, d);
end end

function mkcf(attrs, docs, d) do
  return Curry._4(Ast_helper_Cf.mk, symbol_rloc(--[[ () ]]0), attrs, docs, d);
end end

function mkoption(d) do
  init = d.ptyp_loc;
  loc_loc_start = init.loc_start;
  loc_loc_end = init.loc_end;
  loc = do
    loc_start: loc_loc_start,
    loc_end: loc_loc_end,
    loc_ghost: true
  end;
  return mk(loc, undefined, --[[ Ptyp_constr ]]Block.__(3, {
                do
                  txt: --[[ Ldot ]]Block.__(1, {
                      --[[ Lident ]]Block.__(0, {"*predef*"}),
                      "option"
                    }),
                  loc: loc
                end,
                --[[ :: ]]{
                  d,
                  --[[ [] ]]0
                }
              }));
end end

function reloc_pat(x) do
  return do
          ppat_desc: x.ppat_desc,
          ppat_loc: symbol_rloc(--[[ () ]]0),
          ppat_attributes: x.ppat_attributes
        end;
end end

function reloc_exp(x) do
  return do
          pexp_desc: x.pexp_desc,
          pexp_loc: symbol_rloc(--[[ () ]]0),
          pexp_attributes: x.pexp_attributes
        end;
end end

function mkoperator(name, pos) do
  loc = rhs_loc(pos);
  return Curry._3(Ast_helper_Exp.mk, loc, undefined, --[[ Pexp_ident ]]Block.__(0, {do
                  txt: --[[ Lident ]]Block.__(0, {name}),
                  loc: loc
                end}));
end end

function mkpatvar(name, pos) do
  return mk_1(rhs_loc(pos), undefined, --[[ Ppat_var ]]Block.__(0, {do
                  txt: name,
                  loc: rhs_loc(pos)
                end}));
end end

function ghexp(d) do
  return Curry._3(Ast_helper_Exp.mk, symbol_gloc(--[[ () ]]0), undefined, d);
end end

function ghpat(d) do
  return mk_1(symbol_gloc(--[[ () ]]0), undefined, d);
end end

function ghtyp(d) do
  return mk(symbol_gloc(--[[ () ]]0), undefined, d);
end end

function mkinfix(arg1, name, arg2) do
  return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                mkoperator(name, 2),
                --[[ :: ]]{
                  --[[ tuple ]]{
                    "",
                    arg1
                  },
                  --[[ :: ]]{
                    --[[ tuple ]]{
                      "",
                      arg2
                    },
                    --[[ [] ]]0
                  }
                }
              }));
end end

function neg_float_string(f) do
  if (#f ~= 0 and Caml_string.get(f, 0) == --[[ "-" ]]45) then do
    return __String.sub(f, 1, #f - 1 | 0);
  end else do
    return "-" .. f;
  end end 
end end

function mkexp_cons(consloc, args, loc) do
  return Curry._3(Ast_helper_Exp.mk, loc, undefined, --[[ Pexp_construct ]]Block.__(9, {
                do
                  txt: --[[ Lident ]]Block.__(0, {"::"}),
                  loc: consloc
                end,
                args
              }));
end end

function mkpat_cons(consloc, args, loc) do
  return mk_1(loc, undefined, --[[ Ppat_construct ]]Block.__(5, {
                do
                  txt: --[[ Lident ]]Block.__(0, {"::"}),
                  loc: consloc
                end,
                args
              }));
end end

function mktailexp(nilloc, param) do
  if (param) then do
    e1 = param[0];
    exp_el = mktailexp(nilloc, param[1]);
    loc_loc_start = e1.pexp_loc.loc_start;
    loc_loc_end = exp_el.pexp_loc.loc_end;
    loc = do
      loc_start: loc_loc_start,
      loc_end: loc_loc_end,
      loc_ghost: true
    end;
    arg = Curry._3(Ast_helper_Exp.mk, loc, undefined, --[[ Pexp_tuple ]]Block.__(8, {--[[ :: ]]{
              e1,
              --[[ :: ]]{
                exp_el,
                --[[ [] ]]0
              }
            }}));
    return mkexp_cons(do
                loc_start: loc_loc_start,
                loc_end: loc_loc_end,
                loc_ghost: true
              end, arg, loc);
  end else do
    loc_loc_start_1 = nilloc.loc_start;
    loc_loc_end_1 = nilloc.loc_end;
    loc_1 = do
      loc_start: loc_loc_start_1,
      loc_end: loc_loc_end_1,
      loc_ghost: true
    end;
    nil_txt = --[[ Lident ]]Block.__(0, {"[]"});
    nil = do
      txt: nil_txt,
      loc: loc_1
    end;
    return Curry._3(Ast_helper_Exp.mk, loc_1, undefined, --[[ Pexp_construct ]]Block.__(9, {
                  nil,
                  undefined
                }));
  end end 
end end

function mktailpat(nilloc, param) do
  if (param) then do
    p1 = param[0];
    pat_pl = mktailpat(nilloc, param[1]);
    loc_loc_start = p1.ppat_loc.loc_start;
    loc_loc_end = pat_pl.ppat_loc.loc_end;
    loc = do
      loc_start: loc_loc_start,
      loc_end: loc_loc_end,
      loc_ghost: true
    end;
    arg = mk_1(loc, undefined, --[[ Ppat_tuple ]]Block.__(4, {--[[ :: ]]{
              p1,
              --[[ :: ]]{
                pat_pl,
                --[[ [] ]]0
              }
            }}));
    return mkpat_cons(do
                loc_start: loc_loc_start,
                loc_end: loc_loc_end,
                loc_ghost: true
              end, arg, loc);
  end else do
    loc_loc_start_1 = nilloc.loc_start;
    loc_loc_end_1 = nilloc.loc_end;
    loc_1 = do
      loc_start: loc_loc_start_1,
      loc_end: loc_loc_end_1,
      loc_ghost: true
    end;
    nil_txt = --[[ Lident ]]Block.__(0, {"[]"});
    nil = do
      txt: nil_txt,
      loc: loc_1
    end;
    return mk_1(loc_1, undefined, --[[ Ppat_construct ]]Block.__(5, {
                  nil,
                  undefined
                }));
  end end 
end end

function mkstrexp(e, attrs) do
  return do
          pstr_desc: --[[ Pstr_eval ]]Block.__(0, {
              e,
              attrs
            }),
          pstr_loc: e.pexp_loc
        end;
end end

function mkexp_constraint(e, param) do
  t2 = param[1];
  t1 = param[0];
  if (t1 ~= undefined) then do
    if (t2 ~= undefined) then do
      return ghexp(--[[ Pexp_coerce ]]Block.__(20, {
                    e,
                    t1,
                    t2
                  }));
    end else do
      return ghexp(--[[ Pexp_constraint ]]Block.__(19, {
                    e,
                    t1
                  }));
    end end 
  end else if (t2 ~= undefined) then do
    return ghexp(--[[ Pexp_coerce ]]Block.__(20, {
                  e,
                  t1,
                  t2
                }));
  end else do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "parser.mly",
        153,
        18
      }
    })
  end end  end 
end end

function array_function(str, name) do
  return do
          txt: --[[ Ldot ]]Block.__(1, {
              --[[ Lident ]]Block.__(0, {str}),
              fast.contents and "unsafe_" .. name or name
            }),
          loc: symbol_gloc(--[[ () ]]0)
        end;
end end

function unclosed(opening_name, opening_num, closing_name, closing_num) do
  error({
    __Error_3,
    --[[ Unclosed ]]Block.__(0, {
        rhs_loc(opening_num),
        opening_name,
        rhs_loc(closing_num),
        closing_name
      })
  })
end end

function expecting(pos, nonterm) do
  error({
    __Error_3,
    --[[ Expecting ]]Block.__(1, {
        rhs_loc(pos),
        nonterm
      })
  })
end end

function not_expecting(pos, nonterm) do
  error({
    __Error_3,
    --[[ Not_expecting ]]Block.__(2, {
        rhs_loc(pos),
        nonterm
      })
  })
end end

function bigarray_function(str, name) do
  return do
          txt: --[[ Ldot ]]Block.__(1, {
              --[[ Ldot ]]Block.__(1, {
                  --[[ Lident ]]Block.__(0, {"Bigarray"}),
                  str
                }),
              name
            }),
          loc: symbol_gloc(--[[ () ]]0)
        end;
end end

function bigarray_untuplify(exp) do
  match = exp.pexp_desc;
  if (match.tag == --[[ Pexp_tuple ]]8) then do
    return match[0];
  end else do
    return --[[ :: ]]{
            exp,
            --[[ [] ]]0
          };
  end end 
end end

function exp_of_label(lbl, pos) do
  rhs = --[[ Lident ]]Block.__(0, {last_1(lbl)});
  return mkexp(--[[ Pexp_ident ]]Block.__(0, {do
                  txt: rhs,
                  loc: rhs_loc(pos)
                end}));
end end

function pat_of_label(lbl, pos) do
  rhs = last_1(lbl);
  return mkpat(--[[ Ppat_var ]]Block.__(0, {do
                  txt: rhs,
                  loc: rhs_loc(pos)
                end}));
end end

function check_variable(vl, loc, v) do
  if (List.mem(v, vl)) then do
    error({
      __Error_3,
      --[[ Variable_in_scope ]]Block.__(4, {
          loc,
          v
        })
    })
  end else do
    return 0;
  end end 
end end

function varify_constructors(var_names, t) do
  loop = function(t) do
    match = t.ptyp_desc;
    desc;
    if (typeof match == "number") then do
      desc = --[[ Ptyp_any ]]0;
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 0--[[ Ptyp_var ]] then do
            x = match[0];
            check_variable(var_names, t.ptyp_loc, x);
            desc = --[[ Ptyp_var ]]Block.__(0, {x}); end else 
         if ___conditional___ == 1--[[ Ptyp_arrow ]] then do
            desc = --[[ Ptyp_arrow ]]Block.__(1, {
                match[0],
                loop(match[1]),
                loop(match[2])
              }); end else 
         if ___conditional___ == 2--[[ Ptyp_tuple ]] then do
            desc = --[[ Ptyp_tuple ]]Block.__(2, {List.map(loop, match[0])}); end else 
         if ___conditional___ == 3--[[ Ptyp_constr ]] then do
            longident = match[0];
            match_1 = longident.txt;
            exit = 0;
            local ___conditional___=(match_1.tag | 0);
            do
               if ___conditional___ == 0--[[ Lident ]] then do
                  if (match[1]) then do
                    exit = 1;
                  end else do
                    s = match_1[0];
                    if (List.mem(s, var_names)) then do
                      desc = --[[ Ptyp_var ]]Block.__(0, {s});
                    end else do
                      exit = 1;
                    end end 
                  end end  end else 
               if ___conditional___ == 1--[[ Ldot ]]
               or ___conditional___ == 2--[[ Lapply ]] then do
                  exit = 1; end else 
               end end end end
              
            end
            if (exit == 1) then do
              desc = --[[ Ptyp_constr ]]Block.__(3, {
                  longident,
                  List.map(loop, match[1])
                });
            end
             end  end else 
         if ___conditional___ == 4--[[ Ptyp_object ]] then do
            desc = --[[ Ptyp_object ]]Block.__(4, {
                List.map((function(param) do
                        return --[[ tuple ]]{
                                param[0],
                                param[1],
                                loop(param[2])
                              };
                      end end), match[0]),
                match[1]
              }); end else 
         if ___conditional___ == 5--[[ Ptyp_class ]] then do
            desc = --[[ Ptyp_class ]]Block.__(5, {
                match[0],
                List.map(loop, match[1])
              }); end else 
         if ___conditional___ == 6--[[ Ptyp_alias ]] then do
            string = match[1];
            check_variable(var_names, t.ptyp_loc, string);
            desc = --[[ Ptyp_alias ]]Block.__(6, {
                loop(match[0]),
                string
              }); end else 
         if ___conditional___ == 7--[[ Ptyp_variant ]] then do
            desc = --[[ Ptyp_variant ]]Block.__(7, {
                List.map(loop_row_field, match[0]),
                match[1],
                match[2]
              }); end else 
         if ___conditional___ == 8--[[ Ptyp_poly ]] then do
            string_lst = match[0];
            partial_arg = t.ptyp_loc;
            List.iter((function(param) do
                    return check_variable(var_names, partial_arg, param);
                  end end), string_lst);
            desc = --[[ Ptyp_poly ]]Block.__(8, {
                string_lst,
                loop(match[1])
              }); end else 
         if ___conditional___ == 9--[[ Ptyp_package ]] then do
            match_2 = match[0];
            desc = --[[ Ptyp_package ]]Block.__(9, {--[[ tuple ]]{
                  match_2[0],
                  List.map((function(param) do
                          return --[[ tuple ]]{
                                  param[0],
                                  loop(param[1])
                                };
                        end end), match_2[1])
                }}); end else 
         if ___conditional___ == 10--[[ Ptyp_extension ]] then do
            match_3 = match[0];
            desc = --[[ Ptyp_extension ]]Block.__(10, {--[[ tuple ]]{
                  match_3[0],
                  match_3[1]
                }}); end else 
         end end end end end end end end end end end end end end end end end end end end end end
        
      end
    end end 
    return do
            ptyp_desc: desc,
            ptyp_loc: t.ptyp_loc,
            ptyp_attributes: t.ptyp_attributes
          end;
  end end;
  loop_row_field = function(param) do
    if (param.tag) then do
      return --[[ Rinherit ]]Block.__(1, {loop(param[0])});
    end else do
      return --[[ Rtag ]]Block.__(0, {
                param[0],
                param[1],
                param[2],
                List.map(loop, param[3])
              });
    end end 
  end end;
  return loop(t);
end end

function wrap_type_annotation(newtypes, core_type, body) do
  exp = mkexp(--[[ Pexp_constraint ]]Block.__(19, {
          body,
          core_type
        }));
  exp_1 = List.fold_right((function(newtype, exp) do
          return mkexp(--[[ Pexp_newtype ]]Block.__(30, {
                        newtype,
                        exp
                      }));
        end end), newtypes, exp);
  return --[[ tuple ]]{
          exp_1,
          ghtyp(--[[ Ptyp_poly ]]Block.__(8, {
                  newtypes,
                  varify_constructors(newtypes, core_type)
                }))
        };
end end

function wrap_exp_attrs(body, param) do
  ext = param[0];
  body_pexp_desc = body.pexp_desc;
  body_pexp_loc = body.pexp_loc;
  body_pexp_attributes = Pervasives.$at(param[1], body.pexp_attributes);
  body_1 = do
    pexp_desc: body_pexp_desc,
    pexp_loc: body_pexp_loc,
    pexp_attributes: body_pexp_attributes
  end;
  if (ext ~= undefined) then do
    return ghexp(--[[ Pexp_extension ]]Block.__(33, {--[[ tuple ]]{
                    ext,
                    --[[ PStr ]]Block.__(0, {--[[ :: ]]{
                          mkstrexp(body_1, --[[ [] ]]0),
                          --[[ [] ]]0
                        }})
                  }}));
  end else do
    return body_1;
  end end 
end end

function text_def(pos) do
  return --[[ :: ]]{
          --[[ Ptop_def ]]Block.__(0, {text_1(get_text(Parsing.rhs_start_pos(pos)))}),
          --[[ [] ]]0
        };
end end

function extra_text(text, pos, items) do
  pre_extras = get_pre_extra_text(Parsing.rhs_start_pos(pos));
  post_extras = get_post_extra_text(Parsing.rhs_end_pos(pos));
  return Pervasives.$at(Curry._1(text, pre_extras), Pervasives.$at(items, Curry._1(text, post_extras)));
end end

function extra_cstr(pos, items) do
  return extra_text(Ast_helper_Cf.text, pos, items);
end end

function extra_csig(pos, items) do
  return extra_text(Ast_helper_Ctf.text, pos, items);
end end

function add_nonrec(rf, attrs, pos) do
  if (rf) then do
    return attrs;
  end else do
    name_loc = rhs_loc(pos);
    name = do
      txt: "nonrec",
      loc: name_loc
    end;
    return --[[ :: ]]{
            --[[ tuple ]]{
              name,
              --[[ PStr ]]Block.__(0, {--[[ [] ]]0})
            },
            attrs
          };
  end end 
end end

function mklb(param, attrs) do
  return do
          lb_pattern: param[0],
          lb_expression: param[1],
          lb_attributes: attrs,
          lb_docs: symbol_docs_lazy(--[[ () ]]0),
          lb_text: symbol_text_lazy(--[[ () ]]0),
          lb_loc: symbol_rloc(--[[ () ]]0)
        end;
end end

yytransl_const = {
  257,
  258,
  259,
  260,
  261,
  262,
  263,
  264,
  265,
  266,
  267,
  269,
  270,
  271,
  272,
  273,
  274,
  275,
  276,
  277,
  278,
  279,
  280,
  281,
  282,
  0,
  283,
  284,
  285,
  286,
  288,
  289,
  290,
  291,
  292,
  293,
  294,
  295,
  296,
  297,
  303,
  304,
  309,
  310,
  311,
  312,
  313,
  314,
  315,
  316,
  317,
  318,
  319,
  320,
  322,
  323,
  324,
  325,
  326,
  327,
  328,
  329,
  330,
  331,
  332,
  334,
  335,
  336,
  337,
  338,
  340,
  341,
  342,
  343,
  344,
  346,
  347,
  348,
  349,
  350,
  351,
  352,
  353,
  354,
  355,
  357,
  358,
  360,
  361,
  362,
  363,
  364,
  365,
  366,
  368,
  369,
  370,
  371,
  372,
  373,
  376,
  0
};

yytransl_block = {
  268,
  287,
  298,
  299,
  300,
  301,
  302,
  305,
  306,
  307,
  308,
  321,
  333,
  339,
  345,
  356,
  359,
  367,
  374,
  375,
  0
};

yyact = {
  (function(param) do
      error({
        Caml_builtin_exceptions.failure,
        "parser"
      })
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      return extra_text(text_1, 1, _1);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      return extra_text(text, 1, _1);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ Ptop_def ]]Block.__(0, {extra_text(text_1, 1, _1)});
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 1);
    end end),
  (function(__caml_parser_env) do
      error(Caml_builtin_exceptions.end_of_file)
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text_1(get_text(Parsing.rhs_start_pos(1))), --[[ :: ]]{
                  mkstrexp(_1, _2),
                  --[[ [] ]]0
                });
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      return --[[ [] ]]0;
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text_1(get_text(Parsing.rhs_start_pos(1))), --[[ :: ]]{
                  _1,
                  _2
                });
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      pos = 1;
      items = _1;
      return extra_text((function(txt) do
                    return --[[ :: ]]{
                            --[[ Ptop_def ]]Block.__(0, {text_1(txt)}),
                            --[[ [] ]]0
                          };
                  end end), pos, items);
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text_def(1), --[[ :: ]]{
                  --[[ Ptop_def ]]Block.__(0, {--[[ :: ]]{
                        mkstrexp(_1, _2),
                        --[[ [] ]]0
                      }}),
                  _3
                });
    end end),
  (function(__caml_parser_env) do
      return --[[ [] ]]0;
    end end),
  (function(__caml_parser_env) do
      return text_def(1);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      mark_rhs_docs(2, 3);
      return Pervasives.$at(text_def(1), Pervasives.$at(text_def(2), --[[ :: ]]{
                      --[[ Ptop_def ]]Block.__(0, {--[[ :: ]]{
                            mkstrexp(_2, _3),
                            --[[ [] ]]0
                          }}),
                      _4
                    }));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text_def(1), Pervasives.$at(text_def(2), --[[ :: ]]{
                      --[[ Ptop_def ]]Block.__(0, {--[[ :: ]]{
                            _2,
                            --[[ [] ]]0
                          }}),
                      _3
                    }));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      mark_rhs_docs(2, 3);
      return Pervasives.$at(text_def(1), Pervasives.$at(text_def(2), --[[ :: ]]{
                      _2,
                      _3
                    }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text_def(1), --[[ :: ]]{
                  --[[ Ptop_def ]]Block.__(0, {--[[ :: ]]{
                        _1,
                        --[[ [] ]]0
                      }}),
                  _2
                });
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      mark_rhs_docs(1, 1);
      return Pervasives.$at(text_def(1), --[[ :: ]]{
                  _1,
                  _2
                });
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 1);
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 1);
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 1);
    end end),
  (function(__caml_parser_env) do
      return --[[ tuple ]]{
              do
                txt: "*",
                loc: rhs_loc(2)
              end,
              undefined
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ tuple ]]{
              do
                txt: _2,
                loc: rhs_loc(2)
              end,
              _4
            };
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      return "_";
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _2,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmod(--[[ Pmod_ident ]]Block.__(0, {do
                      txt: _1,
                      loc: rhs_loc(1)
                    end}));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmod(--[[ Pmod_structure ]]Block.__(1, {extra_text(text_1, 2, _2)}));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("struct", 1, "end", 3);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return List.fold_left((function(acc, param) do
                    return mkmod(--[[ Pmod_functor ]]Block.__(2, {
                                  param[0],
                                  param[1],
                                  acc
                                }));
                  end end), _4, _2);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 3);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmod(--[[ Pmod_apply ]]Block.__(3, {
                    _1,
                    _3
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      return mkmod(--[[ Pmod_apply ]]Block.__(3, {
                    _1,
                    mkmod(--[[ Pmod_structure ]]Block.__(1, {--[[ [] ]]0}))
                  }));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 2, ")", 4);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmod(--[[ Pmod_constraint ]]Block.__(4, {
                    _2,
                    _4
                  }));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 5);
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 1);
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    end end),
  (function(__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmod(--[[ Pmod_unpack ]]Block.__(5, {_3}));
    end end),
  (function(__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      _5 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmod(--[[ Pmod_unpack ]]Block.__(5, {ghexp(--[[ Pexp_constraint ]]Block.__(19, {
                            _3,
                            ghtyp(--[[ Ptyp_package ]]Block.__(9, {_5}))
                          }))}));
    end end),
  (function(__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 5);
      _5 = Parsing.peek_val(__caml_parser_env, 3);
      _7 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmod(--[[ Pmod_unpack ]]Block.__(5, {ghexp(--[[ Pexp_coerce ]]Block.__(20, {
                            _3,
                            ghtyp(--[[ Ptyp_package ]]Block.__(9, {_5})),
                            ghtyp(--[[ Ptyp_package ]]Block.__(9, {_7}))
                          }))}));
    end end),
  (function(__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      _5 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmod(--[[ Pmod_unpack ]]Block.__(5, {ghexp(--[[ Pexp_coerce ]]Block.__(20, {
                            _3,
                            undefined,
                            ghtyp(--[[ Ptyp_package ]]Block.__(9, {_5}))
                          }))}));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      return unclosed("(", 1, ")", 5);
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      return unclosed("(", 1, ")", 5);
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 4);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return attr_4(_1, _2);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmod(--[[ Pmod_extension ]]Block.__(6, {_1}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      mark_rhs_docs(1, 2);
      return Pervasives.$at(text_1(get_text(Parsing.rhs_start_pos(1))), --[[ :: ]]{
                  mkstrexp(_1, _2),
                  _3
                });
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      return --[[ [] ]]0;
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text_1(get_text(Parsing.rhs_start_pos(1))), _2);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text_1(get_text(Parsing.rhs_start_pos(1))), --[[ :: ]]{
                  _1,
                  _2
                });
    end end),
  (function(__caml_parser_env) do
      lbs = Parsing.peek_val(__caml_parser_env, 0);
      bindings = lbs.lbs_bindings;
      str;
      exit = 0;
      if (bindings) then do
        lb = bindings[0];
        if (typeof lb.lb_pattern.ppat_desc == "number" and not bindings[1]) then do
          exp = wrap_exp_attrs(lb.lb_expression, --[[ tuple ]]{
                undefined,
                lbs.lbs_attributes
              });
          str = mkstr(--[[ Pstr_eval ]]Block.__(0, {
                  exp,
                  lb.lb_attributes
                }));
        end else do
          exit = 1;
        end end 
      end else do
        exit = 1;
      end end 
      if (exit == 1) then do
        if (lbs.lbs_attributes ~= --[[ [] ]]0) then do
          error({
            __Error_3,
            --[[ Not_expecting ]]Block.__(2, {
                lbs.lbs_loc,
                "attributes"
              })
          })
        end
         end 
        bindings_1 = List.map((function(lb) do
                return mk_17(lb.lb_loc, lb.lb_attributes, CamlinternalLazy.force(lb.lb_docs), CamlinternalLazy.force(lb.lb_text), lb.lb_pattern, lb.lb_expression);
              end end), bindings);
        str = mkstr(--[[ Pstr_value ]]Block.__(1, {
                lbs.lbs_rec,
                List.rev(bindings_1)
              }));
      end
       end 
      match = lbs.lbs_extension;
      if (match ~= undefined) then do
        d = --[[ Pstr_extension ]]Block.__(14, {
            --[[ tuple ]]{
              match,
              --[[ PStr ]]Block.__(0, {--[[ :: ]]{
                    str,
                    --[[ [] ]]0
                  }})
            },
            --[[ [] ]]0
          });
        return mk_6(symbol_gloc(--[[ () ]]0), d);
      end else do
        return str;
      end end 
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(--[[ Pstr_primitive ]]Block.__(2, {_1}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(--[[ Pstr_type ]]Block.__(3, {List.rev(_1)}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(--[[ Pstr_typext ]]Block.__(4, {_1}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(--[[ Pstr_exception ]]Block.__(5, {_1}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(--[[ Pstr_module ]]Block.__(6, {_1}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(--[[ Pstr_recmodule ]]Block.__(7, {List.rev(_1)}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(--[[ Pstr_modtype ]]Block.__(8, {_1}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(--[[ Pstr_open ]]Block.__(9, {_1}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(--[[ Pstr_class ]]Block.__(10, {List.rev(_1)}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(--[[ Pstr_class_type ]]Block.__(11, {List.rev(_1)}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(--[[ Pstr_include ]]Block.__(12, {_1}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(--[[ Pstr_extension ]]Block.__(14, {
                    _1,
                    add_docs_attrs(symbol_docs(--[[ () ]]0), _2)
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      mark_symbol_docs(--[[ () ]]0);
      return mkstr(--[[ Pstr_attribute ]]Block.__(13, {_1}));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mk_16(symbol_rloc(--[[ () ]]0), _3, symbol_docs(--[[ () ]]0), _2);
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmod(--[[ Pmod_constraint ]]Block.__(4, {
                    _4,
                    _2
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmod(--[[ Pmod_functor ]]Block.__(2, {
                    _1[0],
                    _1[1],
                    _2
                  }));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mk_14(symbol_rloc(--[[ () ]]0), _4, symbol_docs(--[[ () ]]0), undefined, do
                  txt: _2,
                  loc: rhs_loc(2)
                end, _3);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _2,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mk_14(symbol_rloc(--[[ () ]]0), _5, symbol_docs(--[[ () ]]0), undefined, do
                  txt: _3,
                  loc: rhs_loc(3)
                end, _4);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mk_14(symbol_rloc(--[[ () ]]0), _4, symbol_docs(--[[ () ]]0), get_text(Parsing.symbol_start_pos(--[[ () ]]0)), do
                  txt: _2,
                  loc: rhs_loc(2)
                end, _3);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmty(--[[ Pmty_ident ]]Block.__(0, {do
                      txt: _1,
                      loc: rhs_loc(1)
                    end}));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmty(--[[ Pmty_signature ]]Block.__(1, {extra_text(text, 2, _2)}));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("sig", 1, "end", 3);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return List.fold_left((function(acc, param) do
                    return mkmty(--[[ Pmty_functor ]]Block.__(2, {
                                  param[0],
                                  param[1],
                                  acc
                                }));
                  end end), _4, _2);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmty(--[[ Pmty_with ]]Block.__(3, {
                    _1,
                    List.rev(_3)
                  }));
    end end),
  (function(__caml_parser_env) do
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmty(--[[ Pmty_typeof ]]Block.__(4, {_4}));
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 1);
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmty(--[[ Pmty_extension ]]Block.__(5, {_1}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return attr_3(_1, _2);
    end end),
  (function(__caml_parser_env) do
      return --[[ [] ]]0;
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text(get_text(Parsing.rhs_start_pos(1))), _2);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text(get_text(Parsing.rhs_start_pos(1))), --[[ :: ]]{
                  _1,
                  _2
                });
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(--[[ Psig_value ]]Block.__(0, {_1}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(--[[ Psig_value ]]Block.__(0, {_1}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(--[[ Psig_type ]]Block.__(1, {List.rev(_1)}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(--[[ Psig_typext ]]Block.__(2, {_1}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(--[[ Psig_exception ]]Block.__(3, {_1}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(--[[ Psig_module ]]Block.__(4, {_1}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(--[[ Psig_module ]]Block.__(4, {_1}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(--[[ Psig_recmodule ]]Block.__(5, {List.rev(_1)}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(--[[ Psig_modtype ]]Block.__(6, {_1}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(--[[ Psig_open ]]Block.__(7, {_1}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(--[[ Psig_include ]]Block.__(8, {_1}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(--[[ Psig_class ]]Block.__(9, {List.rev(_1)}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(--[[ Psig_class_type ]]Block.__(10, {List.rev(_1)}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(--[[ Psig_extension ]]Block.__(12, {
                    _1,
                    add_docs_attrs(symbol_docs(--[[ () ]]0), _2)
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      mark_symbol_docs(--[[ () ]]0);
      return mksig(--[[ Psig_attribute ]]Block.__(11, {_1}));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mk_15(symbol_rloc(--[[ () ]]0), _4, symbol_docs(--[[ () ]]0), _2, do
                  txt: _3,
                  loc: rhs_loc(3)
                end);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mk_16(symbol_rloc(--[[ () ]]0), _3, symbol_docs(--[[ () ]]0), _2);
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmty(--[[ Pmty_functor ]]Block.__(2, {
                    do
                      txt: _2,
                      loc: rhs_loc(2)
                    end,
                    _4,
                    _6
                  }));
    end end),
  (function(__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmty(--[[ Pmty_functor ]]Block.__(2, {
                    do
                      txt: "*",
                      loc: rhs_loc(1)
                    end,
                    undefined,
                    _3
                  }));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mk_12(symbol_rloc(--[[ () ]]0), _4, symbol_docs(--[[ () ]]0), undefined, do
                  txt: _2,
                  loc: rhs_loc(2)
                end, _3);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mk_12(symbol_rloc(--[[ () ]]0), _5, symbol_docs(--[[ () ]]0), undefined, do
                  txt: _2,
                  loc: rhs_loc(2)
                end, alias_2(rhs_loc(4), undefined, do
                      txt: _4,
                      loc: rhs_loc(4)
                    end));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _2,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      _5 = Parsing.peek_val(__caml_parser_env, 1);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mk_12(symbol_rloc(--[[ () ]]0), _6, symbol_docs(--[[ () ]]0), undefined, do
                  txt: _3,
                  loc: rhs_loc(3)
                end, _5);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mk_12(symbol_rloc(--[[ () ]]0), _5, symbol_docs(--[[ () ]]0), get_text(Parsing.symbol_start_pos(--[[ () ]]0)), do
                  txt: _2,
                  loc: rhs_loc(2)
                end, _4);
    end end),
  (function(__caml_parser_env) do
      return ;
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mk_13(symbol_rloc(--[[ () ]]0), _5, symbol_docs(--[[ () ]]0), undefined, _4, do
                  txt: _3,
                  loc: rhs_loc(3)
                end);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _2,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 1);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mk_18(symbol_rloc(--[[ () ]]0), _6, symbol_docs(--[[ () ]]0), undefined, _2, _3, do
                  txt: _4,
                  loc: rhs_loc(4)
                end, _5);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 1);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mk_18(symbol_rloc(--[[ () ]]0), _6, symbol_docs(--[[ () ]]0), get_text(Parsing.symbol_start_pos(--[[ () ]]0)), _2, _3, do
                  txt: _4,
                  loc: rhs_loc(4)
                end, _5);
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(--[[ Pcl_constraint ]]Block.__(5, {
                    _4,
                    _2
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(--[[ Pcl_fun ]]Block.__(2, {
                    _1[0],
                    _1[1],
                    _1[2],
                    _2
                  }));
    end end),
  (function(__caml_parser_env) do
      return --[[ [] ]]0;
    end end),
  (function(__caml_parser_env) do
      return List.rev(Parsing.peek_val(__caml_parser_env, 1));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(--[[ Pcl_fun ]]Block.__(2, {
                    _1[0],
                    _1[1],
                    _1[2],
                    _3
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(--[[ Pcl_fun ]]Block.__(2, {
                    _1[0],
                    _1[1],
                    _1[2],
                    _2
                  }));
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(--[[ Pcl_apply ]]Block.__(3, {
                    _1,
                    List.rev(_2)
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      lbs = _1;
      body = _3;
      bindings = List.map((function(lb) do
              if (lb.lb_attributes ~= --[[ [] ]]0) then do
                error({
                  __Error_3,
                  --[[ Not_expecting ]]Block.__(2, {
                      lb.lb_loc,
                      "item attribute"
                    })
                })
              end
               end 
              return mk_17(lb.lb_loc, undefined, undefined, undefined, lb.lb_pattern, lb.lb_expression);
            end end), lbs.lbs_bindings);
      if (lbs.lbs_extension ~= undefined) then do
        error({
          __Error_3,
          --[[ Not_expecting ]]Block.__(2, {
              lbs.lbs_loc,
              "extension"
            })
        })
      end
       end 
      if (lbs.lbs_attributes ~= --[[ [] ]]0) then do
        error({
          __Error_3,
          --[[ Not_expecting ]]Block.__(2, {
              lbs.lbs_loc,
              "attributes"
            })
        })
      end
       end 
      return mkclass(--[[ Pcl_let ]]Block.__(4, {
                    lbs.lbs_rec,
                    List.rev(bindings),
                    body
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return attr_5(_1, _2);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(--[[ Pcl_extension ]]Block.__(6, {_1}));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(--[[ Pcl_constr ]]Block.__(0, {
                    do
                      txt: _4,
                      loc: rhs_loc(4)
                    end,
                    List.rev(_2)
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(--[[ Pcl_constr ]]Block.__(0, {
                    do
                      txt: _1,
                      loc: rhs_loc(1)
                    end,
                    --[[ [] ]]0
                  }));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mkclass(--[[ Pcl_structure ]]Block.__(1, {_2}));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("object", 1, "end", 3);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mkclass(--[[ Pcl_constraint ]]Block.__(5, {
                    _2,
                    _4
                  }));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 5);
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 1);
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return do
              pcstr_self: _1,
              pcstr_fields: extra_cstr(2, List.rev(_2))
            end;
    end end),
  (function(__caml_parser_env) do
      return reloc_pat(Parsing.peek_val(__caml_parser_env, 1));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mkpat(--[[ Ppat_constraint ]]Block.__(10, {
                    _2,
                    _4
                  }));
    end end),
  (function(__caml_parser_env) do
      return ghpat(--[[ Ppat_any ]]0);
    end end),
  (function(__caml_parser_env) do
      return --[[ [] ]]0;
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(--[[ :: ]]{
                  _2,
                  Curry._1(Ast_helper_Cf.text, get_text(Parsing.rhs_start_pos(2)))
                }, _1);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(_5, symbol_docs(--[[ () ]]0), --[[ Pcf_inherit ]]Block.__(0, {
                    _2,
                    _3,
                    _4
                  }));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(_3, symbol_docs(--[[ () ]]0), --[[ Pcf_val ]]Block.__(1, {_2}));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(_3, symbol_docs(--[[ () ]]0), --[[ Pcf_method ]]Block.__(2, {_2}));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(_3, symbol_docs(--[[ () ]]0), --[[ Pcf_constraint ]]Block.__(3, {_2}));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(_3, symbol_docs(--[[ () ]]0), --[[ Pcf_initializer ]]Block.__(4, {_2}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(_2, symbol_docs(--[[ () ]]0), --[[ Pcf_extension ]]Block.__(6, {_1}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      mark_symbol_docs(--[[ () ]]0);
      return mkcf(undefined, undefined, --[[ Pcf_attribute ]]Block.__(5, {_1}));
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      return ;
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 5);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      if (_1 == --[[ Override ]]0) then do
        error(Escape_error)
      end
       end 
      return --[[ tuple ]]{
              do
                txt: _4,
                loc: rhs_loc(4)
              end,
              --[[ Mutable ]]1,
              --[[ Cfk_virtual ]]Block.__(0, {_6})
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              do
                txt: _3,
                loc: rhs_loc(3)
              end,
              _2,
              --[[ Cfk_virtual ]]Block.__(0, {_5})
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              do
                txt: _3,
                loc: rhs_loc(3)
              end,
              _2,
              --[[ Cfk_concrete ]]Block.__(1, {
                  _1,
                  _5
                })
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 5);
      _2 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      e = mkexp_constraint(_6, _4);
      return --[[ tuple ]]{
              do
                txt: _3,
                loc: rhs_loc(3)
              end,
              _2,
              --[[ Cfk_concrete ]]Block.__(1, {
                  _1,
                  e
                })
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 5);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      if (_1 == --[[ Override ]]0) then do
        error(Escape_error)
      end
       end 
      return --[[ tuple ]]{
              do
                txt: _4,
                loc: rhs_loc(4)
              end,
              --[[ Private ]]0,
              --[[ Cfk_virtual ]]Block.__(0, {_6})
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 5);
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      if (_1 == --[[ Override ]]0) then do
        error(Escape_error)
      end
       end 
      return --[[ tuple ]]{
              do
                txt: _4,
                loc: rhs_loc(4)
              end,
              _3,
              --[[ Cfk_virtual ]]Block.__(0, {_6})
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 3);
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              do
                txt: _3,
                loc: rhs_loc(3)
              end,
              _2,
              --[[ Cfk_concrete ]]Block.__(1, {
                  _1,
                  ghexp(--[[ Pexp_poly ]]Block.__(28, {
                          _4,
                          undefined
                        }))
                })
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 6);
      _2 = Parsing.peek_val(__caml_parser_env, 5);
      _3 = Parsing.peek_val(__caml_parser_env, 4);
      _5 = Parsing.peek_val(__caml_parser_env, 2);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              do
                txt: _3,
                loc: rhs_loc(3)
              end,
              _2,
              --[[ Cfk_concrete ]]Block.__(1, {
                  _1,
                  ghexp(--[[ Pexp_poly ]]Block.__(28, {
                          _7,
                          _5
                        }))
                })
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 9);
      _2 = Parsing.peek_val(__caml_parser_env, 8);
      _3 = Parsing.peek_val(__caml_parser_env, 7);
      _6 = Parsing.peek_val(__caml_parser_env, 4);
      _8 = Parsing.peek_val(__caml_parser_env, 2);
      _10 = Parsing.peek_val(__caml_parser_env, 0);
      match = wrap_type_annotation(_6, _8, _10);
      return --[[ tuple ]]{
              do
                txt: _3,
                loc: rhs_loc(3)
              end,
              _2,
              --[[ Cfk_concrete ]]Block.__(1, {
                  _1,
                  ghexp(--[[ Pexp_poly ]]Block.__(28, {
                          match[0],
                          match[1]
                        }))
                })
            };
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcty(--[[ Pcty_arrow ]]Block.__(2, {
                    "?" .. _2,
                    mkoption(_4),
                    _6
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 3);
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcty(--[[ Pcty_arrow ]]Block.__(2, {
                    "?" .. _1,
                    mkoption(_2),
                    _4
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcty(--[[ Pcty_arrow ]]Block.__(2, {
                    _1,
                    _3,
                    _5
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcty(--[[ Pcty_arrow ]]Block.__(2, {
                    "",
                    _1,
                    _3
                  }));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcty(--[[ Pcty_constr ]]Block.__(0, {
                    do
                      txt: _4,
                      loc: rhs_loc(4)
                    end,
                    List.rev(_2)
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcty(--[[ Pcty_constr ]]Block.__(0, {
                    do
                      txt: _1,
                      loc: rhs_loc(1)
                    end,
                    --[[ [] ]]0
                  }));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mkcty(--[[ Pcty_signature ]]Block.__(1, {_2}));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("object", 1, "end", 3);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return attr_6(_1, _2);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcty(--[[ Pcty_extension ]]Block.__(3, {_1}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return do
              pcsig_self: _1,
              pcsig_fields: extra_csig(2, List.rev(_2))
            end;
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 1);
    end end),
  (function(__caml_parser_env) do
      return mktyp(--[[ Ptyp_any ]]0);
    end end),
  (function(__caml_parser_env) do
      return --[[ [] ]]0;
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(--[[ :: ]]{
                  _2,
                  Curry._1(Ast_helper_Ctf.text, get_text(Parsing.rhs_start_pos(2)))
                }, _1);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkctf(_3, symbol_docs(--[[ () ]]0), --[[ Pctf_inherit ]]Block.__(0, {_2}));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkctf(_3, symbol_docs(--[[ () ]]0), --[[ Pctf_val ]]Block.__(1, {_2}));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      _5 = Parsing.peek_val(__caml_parser_env, 1);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mkctf(_6, symbol_docs(--[[ () ]]0), --[[ Pctf_method ]]Block.__(2, {--[[ tuple ]]{
                      _3,
                      _2[0],
                      _2[1],
                      _5
                    }}));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkctf(_3, symbol_docs(--[[ () ]]0), --[[ Pctf_constraint ]]Block.__(3, {_2}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkctf(_2, symbol_docs(--[[ () ]]0), --[[ Pctf_extension ]]Block.__(5, {_1}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      mark_symbol_docs(--[[ () ]]0);
      return mkctf(undefined, undefined, --[[ Pctf_attribute ]]Block.__(4, {_1}));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _3,
              _2,
              --[[ Virtual ]]0,
              _5
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _3,
              --[[ Mutable ]]1,
              _2,
              _5
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _1,
              --[[ Immutable ]]0,
              --[[ Concrete ]]1,
              _3
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _1,
              _3,
              symbol_rloc(--[[ () ]]0)
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _1,
              _3
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _2,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 5);
      _3 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 3);
      _6 = Parsing.peek_val(__caml_parser_env, 1);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      return mk_18(symbol_rloc(--[[ () ]]0), _7, symbol_docs(--[[ () ]]0), undefined, _2, _3, do
                  txt: _4,
                  loc: rhs_loc(4)
                end, _6);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 5);
      _3 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 3);
      _6 = Parsing.peek_val(__caml_parser_env, 1);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      return mk_18(symbol_rloc(--[[ () ]]0), _7, symbol_docs(--[[ () ]]0), get_text(Parsing.symbol_start_pos(--[[ () ]]0)), _2, _3, do
                  txt: _4,
                  loc: rhs_loc(4)
                end, _6);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _2,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 5);
      _4 = Parsing.peek_val(__caml_parser_env, 4);
      _5 = Parsing.peek_val(__caml_parser_env, 3);
      _7 = Parsing.peek_val(__caml_parser_env, 1);
      _8 = Parsing.peek_val(__caml_parser_env, 0);
      return mk_18(symbol_rloc(--[[ () ]]0), _8, symbol_docs(--[[ () ]]0), undefined, _3, _4, do
                  txt: _5,
                  loc: rhs_loc(5)
                end, _7);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 5);
      _3 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 3);
      _6 = Parsing.peek_val(__caml_parser_env, 1);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      return mk_18(symbol_rloc(--[[ () ]]0), _7, symbol_docs(--[[ () ]]0), get_text(Parsing.symbol_start_pos(--[[ () ]]0)), _2, _3, do
                  txt: _4,
                  loc: rhs_loc(4)
                end, _6);
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      return reloc_exp(Parsing.peek_val(__caml_parser_env, 1));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_sequence ]]Block.__(16, {
                    _1,
                    _3
                  }));
    end end),
  (function(__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ tuple ]]{
              "?" .. _3[0],
              _4,
              _3[1]
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              "?" .. _2[0],
              undefined,
              _2[1]
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ tuple ]]{
              "?" .. _1,
              _4,
              _3
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              "?" .. _1,
              undefined,
              _2
            };
    end end),
  (function(__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ tuple ]]{
              _3[0],
              undefined,
              _3[1]
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _2[0],
              undefined,
              _2[1]
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _1,
              undefined,
              _2
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              "",
              undefined,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_var ]]Block.__(0, {do
                      txt: _1,
                      loc: rhs_loc(1)
                    end}));
    end end),
  (function(__caml_parser_env) do
      return mkpat(--[[ Ppat_any ]]0);
    end end),
  (function(__caml_parser_env) do
      return ;
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _1[0],
              mkpat(--[[ Ppat_constraint ]]Block.__(10, {
                      _1[1],
                      _3
                    }))
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _1,
              mkpat(--[[ Ppat_var ]]Block.__(0, {do
                        txt: _1,
                        loc: rhs_loc(1)
                      end}))
            };
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_constraint ]]Block.__(10, {
                    _1,
                    _3
                  }));
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                    _1,
                    List.rev(_2)
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      lbs = _1;
      body = _3;
      bindings = List.map((function(lb) do
              if (lb.lb_attributes ~= --[[ [] ]]0) then do
                error({
                  __Error_3,
                  --[[ Not_expecting ]]Block.__(2, {
                      lb.lb_loc,
                      "item attribute"
                    })
                })
              end
               end 
              return mk_17(lb.lb_loc, undefined, undefined, undefined, lb.lb_pattern, lb.lb_expression);
            end end), lbs.lbs_bindings);
      d_000 = lbs.lbs_rec;
      d_001 = List.rev(bindings);
      d = --[[ Pexp_let ]]Block.__(2, {
          d_000,
          d_001,
          body
        });
      return wrap_exp_attrs(mkexp(d), --[[ tuple ]]{
                  lbs.lbs_extension,
                  lbs.lbs_attributes
                });
    end end),
  (function(__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 3);
      _5 = Parsing.peek_val(__caml_parser_env, 2);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      d_000 = do
        txt: _4,
        loc: rhs_loc(4)
      end;
      d = --[[ Pexp_letmodule ]]Block.__(25, {
          d_000,
          _5,
          _7
        });
      return wrap_exp_attrs(mkexp(d), _3);
    end end),
  (function(__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 3);
      _5 = Parsing.peek_val(__caml_parser_env, 2);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      d_001 = do
        txt: _5,
        loc: rhs_loc(5)
      end;
      d = --[[ Pexp_open ]]Block.__(32, {
          _3,
          d_001,
          _7
        });
      return wrap_exp_attrs(mkexp(d), _4);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      d = --[[ Pexp_function ]]Block.__(3, {List.rev(_4)});
      return wrap_exp_attrs(mkexp(d), _2);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp(--[[ Pexp_fun ]]Block.__(4, {
                        _3[0],
                        _3[1],
                        _3[2],
                        _4
                      })), _2);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 5);
      _5 = Parsing.peek_val(__caml_parser_env, 2);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp(--[[ Pexp_newtype ]]Block.__(30, {
                        _5,
                        _7
                      })), _2);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      d_001 = List.rev(_6);
      d = --[[ Pexp_match ]]Block.__(6, {
          _3,
          d_001
        });
      return wrap_exp_attrs(mkexp(d), _2);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      d_001 = List.rev(_6);
      d = --[[ Pexp_try ]]Block.__(7, {
          _3,
          d_001
        });
      return wrap_exp_attrs(mkexp(d), _2);
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 2);
      error(Escape_error)
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_tuple ]]Block.__(8, {List.rev(_1)}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_construct ]]Block.__(9, {
                    do
                      txt: _1,
                      loc: rhs_loc(1)
                    end,
                    _2
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_variant ]]Block.__(10, {
                    _1,
                    _2
                  }));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 5);
      _3 = Parsing.peek_val(__caml_parser_env, 4);
      _5 = Parsing.peek_val(__caml_parser_env, 2);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp(--[[ Pexp_ifthenelse ]]Block.__(15, {
                        _3,
                        _5,
                        _7
                      })), _2);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp(--[[ Pexp_ifthenelse ]]Block.__(15, {
                        _3,
                        _5,
                        undefined
                      })), _2);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      _5 = Parsing.peek_val(__caml_parser_env, 1);
      return wrap_exp_attrs(mkexp(--[[ Pexp_while ]]Block.__(17, {
                        _3,
                        _5
                      })), _2);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 8);
      _3 = Parsing.peek_val(__caml_parser_env, 7);
      _5 = Parsing.peek_val(__caml_parser_env, 5);
      _6 = Parsing.peek_val(__caml_parser_env, 4);
      _7 = Parsing.peek_val(__caml_parser_env, 3);
      _9 = Parsing.peek_val(__caml_parser_env, 1);
      return wrap_exp_attrs(mkexp(--[[ Pexp_for ]]Block.__(18, {
                        _3,
                        _5,
                        _7,
                        _6,
                        _9
                      })), _2);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp_cons(rhs_loc(2), ghexp(--[[ Pexp_tuple ]]Block.__(8, {--[[ :: ]]{
                          _1,
                          --[[ :: ]]{
                            _3,
                            --[[ [] ]]0
                          }
                        }})), symbol_rloc(--[[ () ]]0));
    end end),
  (function(__caml_parser_env) do
      _5 = Parsing.peek_val(__caml_parser_env, 3);
      _7 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp_cons(rhs_loc(2), ghexp(--[[ Pexp_tuple ]]Block.__(8, {--[[ :: ]]{
                          _5,
                          --[[ :: ]]{
                            _7,
                            --[[ [] ]]0
                          }
                        }})), symbol_rloc(--[[ () ]]0));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "+", _3);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "+.", _3);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "+=", _3);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "-", _3);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "-.", _3);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "*", _3);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "%", _3);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "=", _3);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "<", _3);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, ">", _3);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "or", _3);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "||", _3);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "&", _3);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "&&", _3);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, ":=", _3);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      name = _1;
      arg = _2;
      match = arg.pexp_desc;
      exit = 0;
      local ___conditional___=(name);
      do
         if ___conditional___ == "-" then do
            if (match.tag == --[[ Pexp_constant ]]1) then do
              match_1 = match[0];
              local ___conditional___=(match_1.tag | 0);
              do
                 if ___conditional___ == 0--[[ Const_int ]] then do
                    return mkexp(--[[ Pexp_constant ]]Block.__(1, {--[[ Const_int ]]Block.__(0, {-match_1[0] | 0})})); end end 
                 if ___conditional___ == 4--[[ Const_int32 ]] then do
                    return mkexp(--[[ Pexp_constant ]]Block.__(1, {--[[ Const_int32 ]]Block.__(4, {-match_1[0] | 0})})); end end 
                 if ___conditional___ == 5--[[ Const_int64 ]] then do
                    return mkexp(--[[ Pexp_constant ]]Block.__(1, {--[[ Const_int64 ]]Block.__(5, {Caml_int64.neg(match_1[0])})})); end end 
                 if ___conditional___ == 6--[[ Const_nativeint ]] then do
                    return mkexp(--[[ Pexp_constant ]]Block.__(1, {--[[ Const_nativeint ]]Block.__(6, {-match_1[0]})})); end end 
                exit = 2;
                  
              end
            end else do
              exit = 2;
            end end  end else 
         if ___conditional___ == "-." then do
            exit = 2; end else 
         end end end end
        
      end
      if (exit == 2 and match.tag == --[[ Pexp_constant ]]1) then do
        match_2 = match[0];
        if (match_2.tag == --[[ Const_float ]]3) then do
          return mkexp(--[[ Pexp_constant ]]Block.__(1, {--[[ Const_float ]]Block.__(3, {neg_float_string(match_2[0])})}));
        end
         end 
      end
       end 
      return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                    mkoperator("~" .. name, 1),
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        "",
                        arg
                      },
                      --[[ [] ]]0
                    }
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      name = _1;
      arg = _2;
      desc = arg.pexp_desc;
      exit = 0;
      local ___conditional___=(name);
      do
         if ___conditional___ == "+" then do
            if (desc.tag == --[[ Pexp_constant ]]1) then do
              local ___conditional___=(desc[0].tag | 0);
              do
                 if ___conditional___ == 1--[[ Const_char ]]
                 or ___conditional___ == 2--[[ Const_string ]]
                 or ___conditional___ == 3--[[ Const_float ]] then do
                    exit = 2; end else 
                 end end
                return mkexp(desc);
                  
              end
            end else do
              exit = 2;
            end end  end else 
         if ___conditional___ == "+." then do
            exit = 2; end else 
         end end end end
        
      end
      if (exit == 2 and desc.tag == --[[ Pexp_constant ]]1 and desc[0].tag == --[[ Const_float ]]3) then do
        return mkexp(desc);
      end
       end 
      return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                    mkoperator("~" .. name, 1),
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        "",
                        arg
                      },
                      --[[ [] ]]0
                    }
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_setfield ]]Block.__(13, {
                    _1,
                    do
                      txt: _3,
                      loc: rhs_loc(3)
                    end,
                    _5
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 6);
      _4 = Parsing.peek_val(__caml_parser_env, 3);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                    ghexp(--[[ Pexp_ident ]]Block.__(0, {array_function("Array", "set")})),
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        "",
                        _1
                      },
                      --[[ :: ]]{
                        --[[ tuple ]]{
                          "",
                          _4
                        },
                        --[[ :: ]]{
                          --[[ tuple ]]{
                            "",
                            _7
                          },
                          --[[ [] ]]0
                        }
                      }
                    }
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 6);
      _4 = Parsing.peek_val(__caml_parser_env, 3);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                    ghexp(--[[ Pexp_ident ]]Block.__(0, {array_function("String", "set")})),
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        "",
                        _1
                      },
                      --[[ :: ]]{
                        --[[ tuple ]]{
                          "",
                          _4
                        },
                        --[[ :: ]]{
                          --[[ tuple ]]{
                            "",
                            _7
                          },
                          --[[ [] ]]0
                        }
                      }
                    }
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 6);
      _4 = Parsing.peek_val(__caml_parser_env, 3);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      arr = _1;
      arg = _4;
      newval = _7;
      set = fast.contents and "unsafe_set" or "set";
      coords = bigarray_untuplify(arg);
      if (coords) then do
        match = coords[1];
        c1 = coords[0];
        if (match) then do
          match_1 = match[1];
          c2 = match[0];
          if (match_1) then do
            if (not match_1[1]) then do
              return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                            ghexp(--[[ Pexp_ident ]]Block.__(0, {bigarray_function("Array3", set)})),
                            --[[ :: ]]{
                              --[[ tuple ]]{
                                "",
                                arr
                              },
                              --[[ :: ]]{
                                --[[ tuple ]]{
                                  "",
                                  c1
                                },
                                --[[ :: ]]{
                                  --[[ tuple ]]{
                                    "",
                                    c2
                                  },
                                  --[[ :: ]]{
                                    --[[ tuple ]]{
                                      "",
                                      match_1[0]
                                    },
                                    --[[ :: ]]{
                                      --[[ tuple ]]{
                                        "",
                                        newval
                                      },
                                      --[[ [] ]]0
                                    }
                                  }
                                }
                              }
                            }
                          }));
            end
             end 
          end else do
            return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                          ghexp(--[[ Pexp_ident ]]Block.__(0, {bigarray_function("Array2", set)})),
                          --[[ :: ]]{
                            --[[ tuple ]]{
                              "",
                              arr
                            },
                            --[[ :: ]]{
                              --[[ tuple ]]{
                                "",
                                c1
                              },
                              --[[ :: ]]{
                                --[[ tuple ]]{
                                  "",
                                  c2
                                },
                                --[[ :: ]]{
                                  --[[ tuple ]]{
                                    "",
                                    newval
                                  },
                                  --[[ [] ]]0
                                }
                              }
                            }
                          }
                        }));
          end end 
        end else do
          return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                        ghexp(--[[ Pexp_ident ]]Block.__(0, {bigarray_function("Array1", set)})),
                        --[[ :: ]]{
                          --[[ tuple ]]{
                            "",
                            arr
                          },
                          --[[ :: ]]{
                            --[[ tuple ]]{
                              "",
                              c1
                            },
                            --[[ :: ]]{
                              --[[ tuple ]]{
                                "",
                                newval
                              },
                              --[[ [] ]]0
                            }
                          }
                        }
                      }));
        end end 
      end
       end 
      return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                    ghexp(--[[ Pexp_ident ]]Block.__(0, {bigarray_function("Genarray", "set")})),
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        "",
                        arr
                      },
                      --[[ :: ]]{
                        --[[ tuple ]]{
                          "",
                          ghexp(--[[ Pexp_array ]]Block.__(14, {coords}))
                        },
                        --[[ :: ]]{
                          --[[ tuple ]]{
                            "",
                            newval
                          },
                          --[[ [] ]]0
                        }
                      }
                    }
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_setinstvar ]]Block.__(23, {
                    do
                      txt: _1,
                      loc: rhs_loc(1)
                    end,
                    _3
                  }));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp(--[[ Pexp_assert ]]Block.__(26, {_3})), _2);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp(--[[ Pexp_lazy ]]Block.__(27, {_3})), _2);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return wrap_exp_attrs(mkexp(--[[ Pexp_object ]]Block.__(29, {_3})), _2);
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("object", 1, "end", 4);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Curry._2(Ast_helper_Exp.attr, _1, _2);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_ident ]]Block.__(0, {do
                      txt: _1,
                      loc: rhs_loc(1)
                    end}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_constant ]]Block.__(1, {_1}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_construct ]]Block.__(9, {
                    do
                      txt: _1,
                      loc: rhs_loc(1)
                    end,
                    undefined
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_variant ]]Block.__(10, {
                    _1,
                    undefined
                  }));
    end end),
  (function(__caml_parser_env) do
      return reloc_exp(Parsing.peek_val(__caml_parser_env, 1));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return wrap_exp_attrs(reloc_exp(_3), _2);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      d_000 = do
        txt: --[[ Lident ]]Block.__(0, {"()"}),
        loc: symbol_rloc(--[[ () ]]0)
      end;
      d = --[[ Pexp_construct ]]Block.__(9, {
          d_000,
          undefined
        });
      return wrap_exp_attrs(mkexp(d), _2);
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("begin", 1, "end", 3);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp_constraint(_2, _3);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_field ]]Block.__(12, {
                    _1,
                    do
                      txt: _3,
                      loc: rhs_loc(3)
                    end
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(--[[ Pexp_open ]]Block.__(32, {
                    --[[ Fresh ]]1,
                    do
                      txt: _1,
                      loc: rhs_loc(1)
                    end,
                    _4
                  }));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 4);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 3, ")", 5);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                    ghexp(--[[ Pexp_ident ]]Block.__(0, {array_function("Array", "get")})),
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        "",
                        _1
                      },
                      --[[ :: ]]{
                        --[[ tuple ]]{
                          "",
                          _4
                        },
                        --[[ [] ]]0
                      }
                    }
                  }));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 4);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 3, ")", 5);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                    ghexp(--[[ Pexp_ident ]]Block.__(0, {array_function("String", "get")})),
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        "",
                        _1
                      },
                      --[[ :: ]]{
                        --[[ tuple ]]{
                          "",
                          _4
                        },
                        --[[ [] ]]0
                      }
                    }
                  }));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 4);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[", 3, "]", 5);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      arr = _1;
      arg = _4;
      get = fast.contents and "unsafe_get" or "get";
      coords = bigarray_untuplify(arg);
      if (coords) then do
        match = coords[1];
        c1 = coords[0];
        if (match) then do
          match_1 = match[1];
          c2 = match[0];
          if (match_1) then do
            if (not match_1[1]) then do
              return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                            ghexp(--[[ Pexp_ident ]]Block.__(0, {bigarray_function("Array3", get)})),
                            --[[ :: ]]{
                              --[[ tuple ]]{
                                "",
                                arr
                              },
                              --[[ :: ]]{
                                --[[ tuple ]]{
                                  "",
                                  c1
                                },
                                --[[ :: ]]{
                                  --[[ tuple ]]{
                                    "",
                                    c2
                                  },
                                  --[[ :: ]]{
                                    --[[ tuple ]]{
                                      "",
                                      match_1[0]
                                    },
                                    --[[ [] ]]0
                                  }
                                }
                              }
                            }
                          }));
            end
             end 
          end else do
            return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                          ghexp(--[[ Pexp_ident ]]Block.__(0, {bigarray_function("Array2", get)})),
                          --[[ :: ]]{
                            --[[ tuple ]]{
                              "",
                              arr
                            },
                            --[[ :: ]]{
                              --[[ tuple ]]{
                                "",
                                c1
                              },
                              --[[ :: ]]{
                                --[[ tuple ]]{
                                  "",
                                  c2
                                },
                                --[[ [] ]]0
                              }
                            }
                          }
                        }));
          end end 
        end else do
          return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                        ghexp(--[[ Pexp_ident ]]Block.__(0, {bigarray_function("Array1", get)})),
                        --[[ :: ]]{
                          --[[ tuple ]]{
                            "",
                            arr
                          },
                          --[[ :: ]]{
                            --[[ tuple ]]{
                              "",
                              c1
                            },
                            --[[ [] ]]0
                          }
                        }
                      }));
        end end 
      end
       end 
      return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                    ghexp(--[[ Pexp_ident ]]Block.__(0, {bigarray_function("Genarray", "get")})),
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        "",
                        arr
                      },
                      --[[ :: ]]{
                        --[[ tuple ]]{
                          "",
                          ghexp(--[[ Pexp_array ]]Block.__(14, {coords}))
                        },
                        --[[ [] ]]0
                      }
                    }
                  }));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 4);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{", 3, "}", 5);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(--[[ Pexp_record ]]Block.__(11, {
                    _2[1],
                    _2[0]
                  }));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{", 1, "}", 3);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      rec_exp = mkexp(--[[ Pexp_record ]]Block.__(11, {
              _4[1],
              _4[0]
            }));
      return mkexp(--[[ Pexp_open ]]Block.__(32, {
                    --[[ Fresh ]]1,
                    do
                      txt: _1,
                      loc: rhs_loc(1)
                    end,
                    rec_exp
                  }));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 4);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{", 3, "}", 5);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(--[[ Pexp_array ]]Block.__(14, {List.rev(_2)}));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[|", 1, "|]", 4);
    end end),
  (function(__caml_parser_env) do
      return mkexp(--[[ Pexp_array ]]Block.__(14, {--[[ [] ]]0}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 5);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(--[[ Pexp_open ]]Block.__(32, {
                    --[[ Fresh ]]1,
                    do
                      txt: _1,
                      loc: rhs_loc(1)
                    end,
                    mkexp(--[[ Pexp_array ]]Block.__(14, {List.rev(_4)}))
                  }));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 5);
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[|", 3, "|]", 6);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return reloc_exp(mktailexp(rhs_loc(4), List.rev(_2)));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[", 1, "]", 4);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 5);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      list_exp = reloc_exp(mktailexp(rhs_loc(6), List.rev(_4)));
      return mkexp(--[[ Pexp_open ]]Block.__(32, {
                    --[[ Fresh ]]1,
                    do
                      txt: _1,
                      loc: rhs_loc(1)
                    end,
                    list_exp
                  }));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 5);
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[", 3, "]", 6);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                    mkoperator(_1, 1),
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        "",
                        _2
                      },
                      --[[ [] ]]0
                    }
                  }));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                    mkoperator("!", 1),
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        "",
                        _2
                      },
                      --[[ [] ]]0
                    }
                  }));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      d = --[[ Pexp_new ]]Block.__(22, {do
            txt: _3,
            loc: rhs_loc(3)
          end});
      return wrap_exp_attrs(mkexp(d), _2);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(--[[ Pexp_override ]]Block.__(24, {List.rev(_2)}));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{<", 1, ">}", 4);
    end end),
  (function(__caml_parser_env) do
      return mkexp(--[[ Pexp_override ]]Block.__(24, {--[[ [] ]]0}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 5);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(--[[ Pexp_open ]]Block.__(32, {
                    --[[ Fresh ]]1,
                    do
                      txt: _1,
                      loc: rhs_loc(1)
                    end,
                    mkexp(--[[ Pexp_override ]]Block.__(24, {List.rev(_4)}))
                  }));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 5);
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{<", 3, ">}", 6);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_send ]]Block.__(21, {
                    _1,
                    _3
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    end end),
  (function(__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(--[[ Pexp_pack ]]Block.__(31, {_3}));
    end end),
  (function(__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      _5 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(--[[ Pexp_constraint ]]Block.__(19, {
                    ghexp(--[[ Pexp_pack ]]Block.__(31, {_3})),
                    ghtyp(--[[ Ptyp_package ]]Block.__(9, {_5}))
                  }));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      return unclosed("(", 1, ")", 5);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 7);
      _5 = Parsing.peek_val(__caml_parser_env, 3);
      _7 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(--[[ Pexp_open ]]Block.__(32, {
                    --[[ Fresh ]]1,
                    do
                      txt: _1,
                      loc: rhs_loc(1)
                    end,
                    mkexp(--[[ Pexp_constraint ]]Block.__(19, {
                            ghexp(--[[ Pexp_pack ]]Block.__(31, {_5})),
                            ghtyp(--[[ Ptyp_package ]]Block.__(9, {_7}))
                          }))
                  }));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 6);
      Parsing.peek_val(__caml_parser_env, 2);
      return unclosed("(", 3, ")", 7);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_extension ]]Block.__(33, {_1}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _2,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              "",
              _1
            };
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _1,
              _2
            };
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              "?" .. _2[0],
              _2[1]
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              "?" .. _1,
              _2
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _1,
              mkexp(--[[ Pexp_ident ]]Block.__(0, {do
                        txt: --[[ Lident ]]Block.__(0, {_1}),
                        loc: rhs_loc(1)
                      end}))
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              _2
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              mkpatvar(_1, 1),
              _2
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 6);
      _3 = Parsing.peek_val(__caml_parser_env, 4);
      _5 = Parsing.peek_val(__caml_parser_env, 2);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              ghpat(--[[ Ppat_constraint ]]Block.__(10, {
                      mkpatvar(_1, 1),
                      ghtyp(--[[ Ptyp_poly ]]Block.__(8, {
                              List.rev(_3),
                              _5
                            }))
                    })),
              _7
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 7);
      _4 = Parsing.peek_val(__caml_parser_env, 4);
      _6 = Parsing.peek_val(__caml_parser_env, 2);
      _8 = Parsing.peek_val(__caml_parser_env, 0);
      match = wrap_type_annotation(_4, _6, _8);
      return --[[ tuple ]]{
              ghpat(--[[ Ppat_constraint ]]Block.__(10, {
                      mkpatvar(_1, 1),
                      match[1]
                    })),
              match[0]
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _1,
              _3
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              ghpat(--[[ Ppat_constraint ]]Block.__(10, {
                      _1,
                      _3
                    })),
              _5
            };
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      lbs = _1;
      lb = _2;
      return do
              lbs_bindings: --[[ :: ]]{
                lb,
                lbs.lbs_bindings
              },
              lbs_rec: lbs.lbs_rec,
              lbs_extension: lbs.lbs_extension,
              lbs_attributes: lbs.lbs_attributes,
              lbs_loc: lbs.lbs_loc
            end;
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      param = _2;
      rf = _3;
      lb = mklb(_4, _5);
      return do
              lbs_bindings: --[[ :: ]]{
                lb,
                --[[ [] ]]0
              },
              lbs_rec: rf,
              lbs_extension: param[0],
              lbs_attributes: param[1],
              lbs_loc: symbol_rloc(--[[ () ]]0)
            end;
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mklb(_2, _3);
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp_constraint(_3, _1);
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return ghexp(--[[ Pexp_fun ]]Block.__(4, {
                    _1[0],
                    _1[1],
                    _1[2],
                    _2
                  }));
    end end),
  (function(__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_newtype ]]Block.__(30, {
                    _3,
                    _5
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return Curry._3(Ast_helper_Exp.__case, _1, undefined, _3);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return Curry._3(Ast_helper_Exp.__case, _1, _3, _5);
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return ghexp(--[[ Pexp_fun ]]Block.__(4, {
                    _1[0],
                    _1[1],
                    _1[2],
                    _2
                  }));
    end end),
  (function(__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_newtype ]]Block.__(30, {
                    _3,
                    _5
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              --[[ :: ]]{
                _1,
                --[[ [] ]]0
              }
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _1,
              _3
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              undefined,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              _3
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              do
                txt: _1,
                loc: rhs_loc(1)
              end,
              _3
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              do
                txt: _1,
                loc: rhs_loc(1)
              end,
              exp_of_label(_1, 1)
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              --[[ tuple ]]{
                do
                  txt: _1,
                  loc: rhs_loc(1)
                end,
                _3
              },
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              --[[ tuple ]]{
                do
                  txt: _3,
                  loc: rhs_loc(3)
                end,
                _5
              },
              _1
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _2,
              undefined
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _2,
              _4
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              undefined,
              _2
            };
    end end),
  (function(__caml_parser_env) do
      error(Escape_error)
    end end),
  (function(__caml_parser_env) do
      error(Escape_error)
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_alias ]]Block.__(1, {
                    _1,
                    do
                      txt: _3,
                      loc: rhs_loc(3)
                    end
                  }));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      return expecting(3, "identifier");
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_tuple ]]Block.__(4, {List.rev(_1)}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_construct ]]Block.__(5, {
                    do
                      txt: _1,
                      loc: rhs_loc(1)
                    end,
                    _2
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_variant ]]Block.__(6, {
                    _1,
                    _2
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat_cons(rhs_loc(2), ghpat(--[[ Ppat_tuple ]]Block.__(4, {--[[ :: ]]{
                          _1,
                          --[[ :: ]]{
                            _3,
                            --[[ [] ]]0
                          }
                        }})), symbol_rloc(--[[ () ]]0));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      return expecting(3, "pattern");
    end end),
  (function(__caml_parser_env) do
      _5 = Parsing.peek_val(__caml_parser_env, 3);
      _7 = Parsing.peek_val(__caml_parser_env, 1);
      return mkpat_cons(rhs_loc(2), ghpat(--[[ Ppat_tuple ]]Block.__(4, {--[[ :: ]]{
                          _5,
                          --[[ :: ]]{
                            _7,
                            --[[ [] ]]0
                          }
                        }})), symbol_rloc(--[[ () ]]0));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 4, ")", 8);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_or ]]Block.__(9, {
                    _1,
                    _3
                  }));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      return expecting(3, "pattern");
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_lazy ]]Block.__(12, {_2}));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_exception ]]Block.__(14, {_2}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return attr_1(_1, _2);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_var ]]Block.__(0, {do
                      txt: _1,
                      loc: rhs_loc(1)
                    end}));
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      return mkpat(--[[ Ppat_any ]]0);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_constant ]]Block.__(2, {_1}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_interval ]]Block.__(3, {
                    _1,
                    _3
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_construct ]]Block.__(5, {
                    do
                      txt: _1,
                      loc: rhs_loc(1)
                    end,
                    undefined
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_variant ]]Block.__(6, {
                    _1,
                    undefined
                  }));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_type ]]Block.__(11, {do
                      txt: _2,
                      loc: rhs_loc(2)
                    end}));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mkpat(--[[ Ppat_record ]]Block.__(7, {
                    _2[0],
                    _2[1]
                  }));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{", 1, "}", 3);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return reloc_pat(mktailpat(rhs_loc(4), List.rev(_2)));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[", 1, "]", 4);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return mkpat(--[[ Ppat_array ]]Block.__(8, {List.rev(_2)}));
    end end),
  (function(__caml_parser_env) do
      return mkpat(--[[ Ppat_array ]]Block.__(8, {--[[ [] ]]0}));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[|", 1, "|]", 4);
    end end),
  (function(__caml_parser_env) do
      return reloc_pat(Parsing.peek_val(__caml_parser_env, 1));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mkpat(--[[ Ppat_constraint ]]Block.__(10, {
                    _2,
                    _4
                  }));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 5);
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      return expecting(4, "type");
    end end),
  (function(__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mkpat(--[[ Ppat_unpack ]]Block.__(13, {do
                      txt: _3,
                      loc: rhs_loc(3)
                    end}));
    end end),
  (function(__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      _5 = Parsing.peek_val(__caml_parser_env, 1);
      return mkpat(--[[ Ppat_constraint ]]Block.__(10, {
                    mkpat(--[[ Ppat_unpack ]]Block.__(13, {do
                              txt: _3,
                              loc: rhs_loc(3)
                            end})),
                    ghtyp(--[[ Ptyp_package ]]Block.__(9, {_5}))
                  }));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 6);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_extension ]]Block.__(15, {_1}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              --[[ :: ]]{
                _1,
                --[[ [] ]]0
              }
            };
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      return expecting(3, "pattern");
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              --[[ :: ]]{
                _1,
                --[[ [] ]]0
              },
              --[[ Closed ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ tuple ]]{
              --[[ :: ]]{
                _1,
                --[[ [] ]]0
              },
              --[[ Closed ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              --[[ :: ]]{
                _1,
                --[[ [] ]]0
              },
              --[[ Open ]]1
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              --[[ :: ]]{
                _1,
                _3[0]
              },
              _3[1]
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              do
                txt: _1,
                loc: rhs_loc(1)
              end,
              _3
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              do
                txt: _1,
                loc: rhs_loc(1)
              end,
              pat_of_label(_1, 1)
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mk_11(symbol_rloc(--[[ () ]]0), _5, symbol_docs(--[[ () ]]0), undefined, do
                  txt: _2,
                  loc: rhs_loc(2)
                end, _4);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1[0],
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1[0],
              _2
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 5);
      _4 = Parsing.peek_val(__caml_parser_env, 3);
      _6 = Parsing.peek_val(__caml_parser_env, 1);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      return mk_11(symbol_rloc(--[[ () ]]0), _7, symbol_docs(--[[ () ]]0), _6, do
                  txt: _2,
                  loc: rhs_loc(2)
                end, _4);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _2,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 5);
      _3 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 3);
      _5 = Parsing.peek_val(__caml_parser_env, 2);
      _6 = Parsing.peek_val(__caml_parser_env, 1);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      return mk_19(symbol_rloc(--[[ () ]]0), add_nonrec(_2, _7, 2), symbol_docs(--[[ () ]]0), undefined, _3, List.rev(_6), _5[0], _5[1], _5[2], do
                  txt: _4,
                  loc: rhs_loc(4)
                end);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 1);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mk_19(symbol_rloc(--[[ () ]]0), _6, symbol_docs(--[[ () ]]0), get_text(Parsing.symbol_start_pos(--[[ () ]]0)), _2, List.rev(_5), _4[0], _4[1], _4[2], do
                  txt: _3,
                  loc: rhs_loc(3)
                end);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      return --[[ [] ]]0;
    end end),
  (function(__caml_parser_env) do
      return --[[ tuple ]]{
              --[[ Ptype_abstract ]]0,
              --[[ Public ]]1,
              undefined
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              --[[ Ptype_abstract ]]0,
              --[[ Public ]]1,
              _2
            };
    end end),
  (function(__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              --[[ Ptype_abstract ]]0,
              --[[ Private ]]0,
              _3
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              --[[ Ptype_variant ]]Block.__(0, {List.rev(_2)}),
              --[[ Public ]]1,
              undefined
            };
    end end),
  (function(__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              --[[ Ptype_variant ]]Block.__(0, {List.rev(_3)}),
              --[[ Private ]]0,
              undefined
            };
    end end),
  (function(__caml_parser_env) do
      return --[[ tuple ]]{
              --[[ Ptype_open ]]1,
              --[[ Public ]]1,
              undefined
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ tuple ]]{
              --[[ Ptype_record ]]Block.__(1, {_4}),
              _2,
              undefined
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              --[[ Ptype_variant ]]Block.__(0, {List.rev(_5)}),
              _4,
              _2
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      return --[[ tuple ]]{
              --[[ Ptype_open ]]1,
              --[[ Public ]]1,
              _2
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 5);
      _4 = Parsing.peek_val(__caml_parser_env, 3);
      _6 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ tuple ]]{
              --[[ Ptype_record ]]Block.__(1, {_6}),
              _4,
              _2
            };
    end end),
  (function(__caml_parser_env) do
      return --[[ [] ]]0;
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      return List.rev(Parsing.peek_val(__caml_parser_env, 1));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _2,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_var ]]Block.__(0, {_2}));
    end end),
  (function(__caml_parser_env) do
      return mktyp(--[[ Ptyp_any ]]0);
    end end),
  (function(__caml_parser_env) do
      return --[[ [] ]]0;
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      return List.rev(Parsing.peek_val(__caml_parser_env, 1));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _2,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      return --[[ Invariant ]]2;
    end end),
  (function(__caml_parser_env) do
      return --[[ Covariant ]]0;
    end end),
  (function(__caml_parser_env) do
      return --[[ Contravariant ]]1;
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_var ]]Block.__(0, {_2}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _2,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return constructor(symbol_rloc(--[[ () ]]0), _3, Caml_option.some(get_info(Parsing.symbol_end_pos(--[[ () ]]0))), _2[0], _2[1], do
                  txt: _1,
                  loc: rhs_loc(1)
                end);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return constructor(symbol_rloc(--[[ () ]]0), _4, Caml_option.some(get_info(Parsing.symbol_end_pos(--[[ () ]]0))), _3[0], _3[1], do
                  txt: _2,
                  loc: rhs_loc(2)
                end);
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 1);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      return rebind(symbol_rloc(--[[ () ]]0), Pervasives.$at(_5, _6), symbol_docs(--[[ () ]]0), undefined, do
                  txt: _2,
                  loc: rhs_loc(2)
                end, do
                  txt: _4,
                  loc: rhs_loc(4)
                end);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return decl(symbol_rloc(--[[ () ]]0), Pervasives.$at(_4, _5), symbol_docs(--[[ () ]]0), undefined, _3[0], _3[1], do
                  txt: _2,
                  loc: rhs_loc(2)
                end);
    end end),
  (function(__caml_parser_env) do
      return --[[ tuple ]]{
              --[[ [] ]]0,
              undefined
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              List.rev(_2),
              undefined
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              List.rev(_2),
              _4
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              --[[ [] ]]0,
              _2
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              _2
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return field_1(symbol_rloc(--[[ () ]]0), _5, Caml_option.some(get_info(Parsing.symbol_end_pos(--[[ () ]]0))), _1, do
                  txt: _2,
                  loc: rhs_loc(2)
                end, _4);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 6);
      _2 = Parsing.peek_val(__caml_parser_env, 5);
      _4 = Parsing.peek_val(__caml_parser_env, 3);
      _5 = Parsing.peek_val(__caml_parser_env, 2);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      info_before_semi = get_info(Parsing.rhs_end_pos(5));
      info = info_before_semi ~= undefined and info_before_semi or get_info(Parsing.symbol_end_pos(--[[ () ]]0));
      return field_1(symbol_rloc(--[[ () ]]0), Pervasives.$at(_5, _7), Caml_option.some(info), _1, do
                  txt: _2,
                  loc: rhs_loc(2)
                end, _4);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 6);
      _3 = Parsing.peek_val(__caml_parser_env, 5);
      _4 = Parsing.peek_val(__caml_parser_env, 4);
      _6 = Parsing.peek_val(__caml_parser_env, 2);
      _7 = Parsing.peek_val(__caml_parser_env, 1);
      _8 = Parsing.peek_val(__caml_parser_env, 0);
      if (_2 ~= --[[ Recursive ]]1) then do
        not_expecting(2, "nonrec flag");
      end
       end 
      return mk_20(_8, symbol_docs(--[[ () ]]0), _3, _6, do
                  txt: _4,
                  loc: rhs_loc(4)
                end, List.rev(_7));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 6);
      _3 = Parsing.peek_val(__caml_parser_env, 5);
      _4 = Parsing.peek_val(__caml_parser_env, 4);
      _6 = Parsing.peek_val(__caml_parser_env, 2);
      _7 = Parsing.peek_val(__caml_parser_env, 1);
      _8 = Parsing.peek_val(__caml_parser_env, 0);
      if (_2 ~= --[[ Recursive ]]1) then do
        not_expecting(2, "nonrec flag");
      end
       end 
      return mk_20(_8, symbol_docs(--[[ () ]]0), _3, _6, do
                  txt: _4,
                  loc: rhs_loc(4)
                end, List.rev(_7));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _2,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _2,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _2,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return decl(symbol_rloc(--[[ () ]]0), _3, undefined, Caml_option.some(get_info(Parsing.symbol_end_pos(--[[ () ]]0))), _2[0], _2[1], do
                  txt: _1,
                  loc: rhs_loc(1)
                end);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return decl(symbol_rloc(--[[ () ]]0), _4, undefined, Caml_option.some(get_info(Parsing.symbol_end_pos(--[[ () ]]0))), _3[0], _3[1], do
                  txt: _2,
                  loc: rhs_loc(2)
                end);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 3);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return rebind(symbol_rloc(--[[ () ]]0), _4, undefined, Caml_option.some(get_info(Parsing.symbol_end_pos(--[[ () ]]0))), do
                  txt: _1,
                  loc: rhs_loc(1)
                end, do
                  txt: _3,
                  loc: rhs_loc(3)
                end);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return rebind(symbol_rloc(--[[ () ]]0), _5, undefined, Caml_option.some(get_info(Parsing.symbol_end_pos(--[[ () ]]0))), do
                  txt: _2,
                  loc: rhs_loc(2)
                end, do
                  txt: _4,
                  loc: rhs_loc(4)
                end);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 1);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      rhs = last_1(_3);
      return --[[ Pwith_type ]]Block.__(0, {
                do
                  txt: _3,
                  loc: rhs_loc(3)
                end,
                mk_19(symbol_rloc(--[[ () ]]0), undefined, undefined, undefined, _2, List.rev(_6), undefined, _4, _5, do
                      txt: rhs,
                      loc: rhs_loc(3)
                    end)
              });
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Pwith_typesubst ]]Block.__(2, {mk_19(symbol_rloc(--[[ () ]]0), undefined, undefined, undefined, _2, undefined, undefined, undefined, _5, do
                      txt: _3,
                      loc: rhs_loc(3)
                    end)});
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Pwith_module ]]Block.__(1, {
                do
                  txt: _2,
                  loc: rhs_loc(2)
                end,
                do
                  txt: _4,
                  loc: rhs_loc(4)
                end
              });
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Pwith_modsubst ]]Block.__(3, {
                do
                  txt: _2,
                  loc: rhs_loc(2)
                end,
                do
                  txt: _4,
                  loc: rhs_loc(4)
                end
              });
    end end),
  (function(__caml_parser_env) do
      return --[[ Public ]]1;
    end end),
  (function(__caml_parser_env) do
      return --[[ Private ]]0;
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _2,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_poly ]]Block.__(8, {
                    List.rev(_1),
                    _3
                  }));
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_poly ]]Block.__(8, {
                    List.rev(_1),
                    _3
                  }));
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return attr(_1, _2);
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_alias ]]Block.__(6, {
                    _1,
                    _4
                  }));
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_arrow ]]Block.__(1, {
                    "?" .. _2,
                    mkoption(_4),
                    _6
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 3);
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_arrow ]]Block.__(1, {
                    "?" .. _1,
                    mkoption(_2),
                    _4
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_arrow ]]Block.__(1, {
                    _1,
                    _3,
                    _5
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_arrow ]]Block.__(1, {
                    "",
                    _1,
                    _3
                  }));
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      if (_2) then do
        if (_2[1]) then do
          error(Parsing.Parse_error)
        end
         end 
        return _2[0];
      end else do
        error(Parsing.Parse_error)
      end end 
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      if (_2) then do
        if (_2[1]) then do
          error(Parsing.Parse_error)
        end
         end 
        return _2[0];
      end else do
        error(Parsing.Parse_error)
      end end 
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_var ]]Block.__(0, {_2}));
    end end),
  (function(__caml_parser_env) do
      return mktyp(--[[ Ptyp_any ]]0);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_constr ]]Block.__(3, {
                    do
                      txt: _1,
                      loc: rhs_loc(1)
                    end,
                    --[[ [] ]]0
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_constr ]]Block.__(3, {
                    do
                      txt: _2,
                      loc: rhs_loc(2)
                    end,
                    --[[ :: ]]{
                      _1,
                      --[[ [] ]]0
                    }
                  }));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_constr ]]Block.__(3, {
                    do
                      txt: _4,
                      loc: rhs_loc(4)
                    end,
                    List.rev(_2)
                  }));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(--[[ Ptyp_object ]]Block.__(4, {
                    _2[0],
                    _2[1]
                  }));
    end end),
  (function(__caml_parser_env) do
      return mktyp(--[[ Ptyp_object ]]Block.__(4, {
                    --[[ [] ]]0,
                    --[[ Closed ]]0
                  }));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_class ]]Block.__(5, {
                    do
                      txt: _2,
                      loc: rhs_loc(2)
                    end,
                    --[[ [] ]]0
                  }));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_class ]]Block.__(5, {
                    do
                      txt: _3,
                      loc: rhs_loc(3)
                    end,
                    --[[ :: ]]{
                      _1,
                      --[[ [] ]]0
                    }
                  }));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_class ]]Block.__(5, {
                    do
                      txt: _5,
                      loc: rhs_loc(5)
                    end,
                    List.rev(_2)
                  }));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(--[[ Ptyp_variant ]]Block.__(7, {
                    --[[ :: ]]{
                      _2,
                      --[[ [] ]]0
                    },
                    --[[ Closed ]]0,
                    undefined
                  }));
    end end),
  (function(__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(--[[ Ptyp_variant ]]Block.__(7, {
                    List.rev(_3),
                    --[[ Closed ]]0,
                    undefined
                  }));
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(--[[ Ptyp_variant ]]Block.__(7, {
                    --[[ :: ]]{
                      _2,
                      List.rev(_4)
                    },
                    --[[ Closed ]]0,
                    undefined
                  }));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(--[[ Ptyp_variant ]]Block.__(7, {
                    List.rev(_3),
                    --[[ Open ]]1,
                    undefined
                  }));
    end end),
  (function(__caml_parser_env) do
      return mktyp(--[[ Ptyp_variant ]]Block.__(7, {
                    --[[ [] ]]0,
                    --[[ Open ]]1,
                    undefined
                  }));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(--[[ Ptyp_variant ]]Block.__(7, {
                    List.rev(_3),
                    --[[ Closed ]]0,
                    --[[ [] ]]0
                  }));
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      _5 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(--[[ Ptyp_variant ]]Block.__(7, {
                    List.rev(_3),
                    --[[ Closed ]]0,
                    List.rev(_5)
                  }));
    end end),
  (function(__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(--[[ Ptyp_package ]]Block.__(9, {_3}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_extension ]]Block.__(10, {_1}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              do
                txt: _1,
                loc: rhs_loc(1)
              end,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              do
                txt: _1,
                loc: rhs_loc(1)
              end,
              _3
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              do
                txt: _2,
                loc: rhs_loc(2)
              end,
              _4
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              _3
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Rinherit ]]Block.__(1, {_1});
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Rtag ]]Block.__(0, {
                _1,
                _5,
                _3,
                List.rev(_4)
              });
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Rtag ]]Block.__(0, {
                _1,
                _2,
                true,
                --[[ [] ]]0
              });
    end end),
  (function(__caml_parser_env) do
      return true;
    end end),
  (function(__caml_parser_env) do
      return false;
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _2,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_tuple ]]Block.__(2, {--[[ :: ]]{
                      _1,
                      List.rev(_3)
                    }}));
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_tuple ]]Block.__(2, {--[[ :: ]]{
                      _1,
                      List.rev(_3)
                    }}));
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              --[[ :: ]]{
                _1,
                _3[0]
              },
              _3[1]
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              --[[ :: ]]{
                _1,
                --[[ [] ]]0
              },
              --[[ Closed ]]0
            };
    end end),
  (function(__caml_parser_env) do
      return --[[ tuple ]]{
              --[[ [] ]]0,
              --[[ Open ]]1
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 3);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _1,
              _4,
              _3
            };
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_int ]]Block.__(0, {_1});
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_char ]]Block.__(1, {_1});
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_string ]]Block.__(2, {
                _1[0],
                _1[1]
              });
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_float ]]Block.__(3, {_1});
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_int32 ]]Block.__(4, {_1});
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_int64 ]]Block.__(5, {_1});
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_nativeint ]]Block.__(6, {_1});
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_int ]]Block.__(0, {-_2 | 0});
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_float ]]Block.__(3, {"-" .. _2});
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_int32 ]]Block.__(4, {-_2 | 0});
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_int64 ]]Block.__(5, {Caml_int64.neg(_2)});
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_nativeint ]]Block.__(6, {-_2});
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_int ]]Block.__(0, {_2});
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_float ]]Block.__(3, {_2});
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_int32 ]]Block.__(4, {_2});
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_int64 ]]Block.__(5, {_2});
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_nativeint ]]Block.__(6, {_2});
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 1);
    end end),
  (function(__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    end end),
  (function(__caml_parser_env) do
      return expecting(2, "operator");
    end end),
  (function(__caml_parser_env) do
      return expecting(3, "module-expr");
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      return "!";
    end end),
  (function(__caml_parser_env) do
      return "+";
    end end),
  (function(__caml_parser_env) do
      return "+.";
    end end),
  (function(__caml_parser_env) do
      return "-";
    end end),
  (function(__caml_parser_env) do
      return "-.";
    end end),
  (function(__caml_parser_env) do
      return "*";
    end end),
  (function(__caml_parser_env) do
      return "=";
    end end),
  (function(__caml_parser_env) do
      return "<";
    end end),
  (function(__caml_parser_env) do
      return ">";
    end end),
  (function(__caml_parser_env) do
      return "or";
    end end),
  (function(__caml_parser_env) do
      return "||";
    end end),
  (function(__caml_parser_env) do
      return "&";
    end end),
  (function(__caml_parser_env) do
      return "&&";
    end end),
  (function(__caml_parser_env) do
      return ":=";
    end end),
  (function(__caml_parser_env) do
      return "+=";
    end end),
  (function(__caml_parser_env) do
      return "%";
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      return "()";
    end end),
  (function(__caml_parser_env) do
      return "::";
    end end),
  (function(__caml_parser_env) do
      return "false";
    end end),
  (function(__caml_parser_env) do
      return "true";
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Lident ]]Block.__(0, {_1});
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Ldot ]]Block.__(1, {
                _1,
                _3
              });
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      return --[[ Lident ]]Block.__(0, {"[]"});
    end end),
  (function(__caml_parser_env) do
      return --[[ Lident ]]Block.__(0, {"()"});
    end end),
  (function(__caml_parser_env) do
      return --[[ Lident ]]Block.__(0, {"false"});
    end end),
  (function(__caml_parser_env) do
      return --[[ Lident ]]Block.__(0, {"true"});
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Lident ]]Block.__(0, {_1});
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Ldot ]]Block.__(1, {
                _1,
                _3
              });
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Lident ]]Block.__(0, {_1});
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Ldot ]]Block.__(1, {
                _1,
                _3
              });
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Lident ]]Block.__(0, {_1});
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Ldot ]]Block.__(1, {
                _1,
                _3
              });
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Lident ]]Block.__(0, {_1});
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Ldot ]]Block.__(1, {
                _1,
                _3
              });
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 3);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      p1 = _1;
      p2 = _3;
      if (applicative_functors.contents) then do
        return --[[ Lapply ]]Block.__(2, {
                  p1,
                  p2
                });
      end else do
        error({
          __Error_3,
          --[[ Applicative_path ]]Block.__(3, {symbol_rloc(--[[ () ]]0)})
        })
      end end 
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Lident ]]Block.__(0, {_1});
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Ldot ]]Block.__(1, {
                _1,
                _3
              });
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Lident ]]Block.__(0, {_1});
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Ldot ]]Block.__(1, {
                _1,
                _3
              });
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Lident ]]Block.__(0, {_1});
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Ldot ]]Block.__(1, {
                _1,
                _3
              });
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Ptop_dir ]]Block.__(1, {
                _2,
                --[[ Pdir_none ]]0
              });
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Ptop_dir ]]Block.__(1, {
                _2,
                --[[ Pdir_string ]]Block.__(0, {_3[0]})
              });
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Ptop_dir ]]Block.__(1, {
                _2,
                --[[ Pdir_int ]]Block.__(1, {_3})
              });
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Ptop_dir ]]Block.__(1, {
                _2,
                --[[ Pdir_ident ]]Block.__(2, {_3})
              });
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Ptop_dir ]]Block.__(1, {
                _2,
                --[[ Pdir_ident ]]Block.__(2, {_3})
              });
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ Ptop_dir ]]Block.__(1, {
                _2,
                --[[ Pdir_bool ]]Block.__(3, {false})
              });
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ Ptop_dir ]]Block.__(1, {
                _2,
                --[[ Pdir_bool ]]Block.__(3, {true})
              });
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      return --[[ Nonrecursive ]]0;
    end end),
  (function(__caml_parser_env) do
      return --[[ Recursive ]]1;
    end end),
  (function(__caml_parser_env) do
      return --[[ Recursive ]]1;
    end end),
  (function(__caml_parser_env) do
      return --[[ Nonrecursive ]]0;
    end end),
  (function(__caml_parser_env) do
      return --[[ Upto ]]0;
    end end),
  (function(__caml_parser_env) do
      return --[[ Downto ]]1;
    end end),
  (function(__caml_parser_env) do
      return --[[ Public ]]1;
    end end),
  (function(__caml_parser_env) do
      return --[[ Private ]]0;
    end end),
  (function(__caml_parser_env) do
      return --[[ Immutable ]]0;
    end end),
  (function(__caml_parser_env) do
      return --[[ Mutable ]]1;
    end end),
  (function(__caml_parser_env) do
      return --[[ Concrete ]]1;
    end end),
  (function(__caml_parser_env) do
      return --[[ Virtual ]]0;
    end end),
  (function(__caml_parser_env) do
      return --[[ tuple ]]{
              --[[ Public ]]1,
              --[[ Concrete ]]1
            };
    end end),
  (function(__caml_parser_env) do
      return --[[ tuple ]]{
              --[[ Private ]]0,
              --[[ Concrete ]]1
            };
    end end),
  (function(__caml_parser_env) do
      return --[[ tuple ]]{
              --[[ Public ]]1,
              --[[ Virtual ]]0
            };
    end end),
  (function(__caml_parser_env) do
      return --[[ tuple ]]{
              --[[ Private ]]0,
              --[[ Virtual ]]0
            };
    end end),
  (function(__caml_parser_env) do
      return --[[ tuple ]]{
              --[[ Private ]]0,
              --[[ Virtual ]]0
            };
    end end),
  (function(__caml_parser_env) do
      return --[[ Fresh ]]1;
    end end),
  (function(__caml_parser_env) do
      return --[[ Override ]]0;
    end end),
  (function(__caml_parser_env) do
      return --[[ () ]]0;
    end end),
  (function(__caml_parser_env) do
      return --[[ () ]]0;
    end end),
  (function(__caml_parser_env) do
      return --[[ () ]]0;
    end end),
  (function(__caml_parser_env) do
      return --[[ () ]]0;
    end end),
  (function(__caml_parser_env) do
      return "-";
    end end),
  (function(__caml_parser_env) do
      return "-.";
    end end),
  (function(__caml_parser_env) do
      return "+";
    end end),
  (function(__caml_parser_env) do
      return "+.";
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function(__caml_parser_env) do
      return "and";
    end end),
  (function(__caml_parser_env) do
      return "as";
    end end),
  (function(__caml_parser_env) do
      return "assert";
    end end),
  (function(__caml_parser_env) do
      return "begin";
    end end),
  (function(__caml_parser_env) do
      return "class";
    end end),
  (function(__caml_parser_env) do
      return "constraint";
    end end),
  (function(__caml_parser_env) do
      return "do";
    end end),
  (function(__caml_parser_env) do
      return "done";
    end end),
  (function(__caml_parser_env) do
      return "downto";
    end end),
  (function(__caml_parser_env) do
      return "else";
    end end),
  (function(__caml_parser_env) do
      return "end";
    end end),
  (function(__caml_parser_env) do
      return "exception";
    end end),
  (function(__caml_parser_env) do
      return "external";
    end end),
  (function(__caml_parser_env) do
      return "false";
    end end),
  (function(__caml_parser_env) do
      return "for";
    end end),
  (function(__caml_parser_env) do
      return "fun";
    end end),
  (function(__caml_parser_env) do
      return "function";
    end end),
  (function(__caml_parser_env) do
      return "functor";
    end end),
  (function(__caml_parser_env) do
      return "if";
    end end),
  (function(__caml_parser_env) do
      return "in";
    end end),
  (function(__caml_parser_env) do
      return "include";
    end end),
  (function(__caml_parser_env) do
      return "inherit";
    end end),
  (function(__caml_parser_env) do
      return "initializer";
    end end),
  (function(__caml_parser_env) do
      return "lazy";
    end end),
  (function(__caml_parser_env) do
      return "let";
    end end),
  (function(__caml_parser_env) do
      return "match";
    end end),
  (function(__caml_parser_env) do
      return "method";
    end end),
  (function(__caml_parser_env) do
      return "module";
    end end),
  (function(__caml_parser_env) do
      return "mutable";
    end end),
  (function(__caml_parser_env) do
      return "new";
    end end),
  (function(__caml_parser_env) do
      return "object";
    end end),
  (function(__caml_parser_env) do
      return "of";
    end end),
  (function(__caml_parser_env) do
      return "open";
    end end),
  (function(__caml_parser_env) do
      return "or";
    end end),
  (function(__caml_parser_env) do
      return "private";
    end end),
  (function(__caml_parser_env) do
      return "rec";
    end end),
  (function(__caml_parser_env) do
      return "sig";
    end end),
  (function(__caml_parser_env) do
      return "struct";
    end end),
  (function(__caml_parser_env) do
      return "then";
    end end),
  (function(__caml_parser_env) do
      return "to";
    end end),
  (function(__caml_parser_env) do
      return "true";
    end end),
  (function(__caml_parser_env) do
      return "try";
    end end),
  (function(__caml_parser_env) do
      return "type";
    end end),
  (function(__caml_parser_env) do
      return "val";
    end end),
  (function(__caml_parser_env) do
      return "virtual";
    end end),
  (function(__caml_parser_env) do
      return "when";
    end end),
  (function(__caml_parser_env) do
      return "while";
    end end),
  (function(__caml_parser_env) do
      return "with";
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return do
              txt: _1,
              loc: symbol_rloc(--[[ () ]]0)
            end;
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return do
              txt: _1 .. ("." .. _3.txt),
              loc: symbol_rloc(--[[ () ]]0)
            end;
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ tuple ]]{
              _2,
              _3
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ tuple ]]{
              _2,
              _3
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ tuple ]]{
              _2,
              _3
            };
    end end),
  (function(__caml_parser_env) do
      return --[[ [] ]]0;
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              _2
            };
    end end),
  (function(__caml_parser_env) do
      return --[[ [] ]]0;
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              _2
            };
    end end),
  (function(__caml_parser_env) do
      return --[[ tuple ]]{
              undefined,
              --[[ [] ]]0
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              undefined,
              --[[ :: ]]{
                _1,
                _2
              }
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _2,
              _3
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ tuple ]]{
              _2,
              _3
            };
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ tuple ]]{
              _2,
              _3
            };
    end end),
  (function(__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ PStr ]]Block.__(0, {_1});
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ PTyp ]]Block.__(1, {_2});
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ PPat ]]Block.__(2, {
                _2,
                undefined
              });
    end end),
  (function(__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ PPat ]]Block.__(2, {
                _2,
                _4
              });
    end end),
  (function(__caml_parser_env) do
      error({
        Parsing.YYexit,
        Parsing.peek_val(__caml_parser_env, 0)
      })
    end end),
  (function(__caml_parser_env) do
      error({
        Parsing.YYexit,
        Parsing.peek_val(__caml_parser_env, 0)
      })
    end end),
  (function(__caml_parser_env) do
      error({
        Parsing.YYexit,
        Parsing.peek_val(__caml_parser_env, 0)
      })
    end end),
  (function(__caml_parser_env) do
      error({
        Parsing.YYexit,
        Parsing.peek_val(__caml_parser_env, 0)
      })
    end end),
  (function(__caml_parser_env) do
      error({
        Parsing.YYexit,
        Parsing.peek_val(__caml_parser_env, 0)
      })
    end end),
  (function(__caml_parser_env) do
      error({
        Parsing.YYexit,
        Parsing.peek_val(__caml_parser_env, 0)
      })
    end end),
  (function(__caml_parser_env) do
      error({
        Parsing.YYexit,
        Parsing.peek_val(__caml_parser_env, 0)
      })
    end end)
};

yytables = do
  actions: yyact,
  transl_const: yytransl_const,
  transl_block: yytransl_block,
  lhs: "\xff\xff\x01\0\x02\0\x03\0\x03\0\x03\0\n\0\n\0\x0e\0\x0e\0\x04\0\x10\0\x10\0\x11\0\x11\0\x11\0\x11\0\x11\0\x11\0\x11\0\x05\0\x06\0\x07\0\x14\0\x14\0\x15\0\x15\0\x17\0\x17\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\b\0\b\0\x1e\0\x1e\0\x1e\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0*\0-\0-\0-\0$\0%\0%\0.\0/\0\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\t\0\t\0\t\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\0'\x009\0<\0<\0<\x006\x007\x008\x008\0=\0>\0?\0?\0&\0(\0(\0A\0B\0E\0E\0E\0D\0D\0J\0J\0F\0F\0F\0F\0F\0F\0K\0K\0K\0K\0K\0K\0K\0K\0O\0P\0P\0P\0Q\0Q\0R\0R\0R\0R\0R\0R\0R\0S\0S\0T\0T\0T\0T\0U\0U\0U\0U\0U\0G\0G\0G\0G\0G\0^\0^\0^\0^\0^\0^\0a\0b\0b\0c\0c\0d\0d\0d\0d\0d\0d\0e\0e\0e\0g\0V\0:\0:\0h\0i\0)\0)\0j\0k\0\f\0\f\0\f\0H\0H\0H\0H\0H\0H\0H\0H\0p\0p\0m\0m\0l\0l\0n\0o\0o\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0L\0L\0\x84\0\x84\0\x85\0\x85\0\x85\0\x85\0\x86\0]\0]\0\x87\0\x87\0\x87\0\x87\0\x87\0\x1f\0\x1f\0\x8c\0\x8d\0\x89\0\x89\0\\\0\\\0\\\0u\0u\0\x8f\0\x8f\0v\0v\0v\0w\0w\0\x80\0\x80\0\x90\0\x90\0\x90\0\x91\0\x91\0\x83\0\x83\0\x81\0\x81\0Y\0Y\0Y\0Y\0Y\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0q\0q\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x92\0\x92\0\x92\0\x96\0\x96\0\x95\0\x95\0\x95\0\x95\0\x97\0\x97\x003\0\x98\0\x98\0 \0!\0!\0\x99\0\x9a\0\x9e\0\x9e\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9c\0\x9c\0\x9c\0\xa1\0\xa2\0\xa2\0\xa4\0\xa4\0\xa5\0\xa5\0\xa5\0\xa6\0\xa3\0\xa3\0\xa3\0\xa7\0I\0I\0\x9f\0\x9f\0\x9f\0\xa8\0\xa9\0#\0#\x005\0\xab\0\xab\0\xab\0\xab\0\xa0\0\xa0\0\xa0\0\xaf\0\xb0\0\"\x004\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb3\0\xb3\0\xb3\0\xb4\0\xb5\0\xb6\0\xb7\x001\x001\0\xb8\0\xb8\0\xb8\0\xb8\0\xb9\0\xb9\0\x8a\0\x8a\0Z\0Z\0\xb1\0\xb1\0\x12\0\x12\0\xba\0\xba\0\xbc\0\xbc\0\xbc\0\xbc\0\xbc\0\xbe\0\xbe\0\xae\0\xae\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\x1b\0\x1b\0\xc6\0\xc5\0\xc5\0\xc2\0\xc2\0\xc3\0\xc3\0\xc1\0\xc1\0\xc7\0\xc7\0\xc8\0\xc8\0\xc4\0\xc4\0\xbd\0\xbd\0_\0_\0M\0M\0\xc9\0\xc9\0\xad\0\xad\0\xc0\0\xc0\0\xc0\0\xca\0W\0\x7f\0\x7f\0\x7f\0\x7f\0\x7f\0\x7f\0\x7f\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0@\0@\0\x88\0\x88\0\x88\0\x88\0\x88\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xaa\0\xaa\0\xaa\0\xaa\0\xaa\0~\0~\0x\0x\0x\0x\0x\0}\0}\0\x94\0\x94\0\x19\0\x19\0\xbb\0\xbb\0\xbb\x000\x000\0`\0`\0N\0N\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0y\0\x8e\0\x8e\0\x9b\0\x9b\0z\0z\0[\0[\0X\0X\0C\0C\0f\0f\0f\0f\0f\0;\0;\0t\0t\0\x82\0\x82\0{\0{\0|\0|\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcd\0\xcd\0\x1c\0\xcf\0,\0\r\0\r\0\xac\0\xac\0s\0s\0s\0\x1d\0+\0\xce\0\xce\0\xce\0\xce\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
  len: "\x02\0\x02\0\x02\0\x02\0\x02\0\x01\0\x02\0\x01\0\0\0\x02\0\x01\0\x01\0\x03\0\x01\0\x02\0\x04\0\x03\0\x03\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x05\0\x01\0\x01\0\x02\0\x01\0\x01\0\x03\0\x03\0\x04\0\x04\0\x03\0\x04\0\x05\0\x05\0\x03\0\x03\0\x04\0\x06\0\b\0\x06\0\x05\0\x05\0\x04\0\x02\0\x01\0\x03\0\x01\0\0\0\x02\0\x02\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x02\0\x01\0\x03\0\x02\0\x04\0\x02\0\x04\0\x01\0\x02\0\x05\0\x04\0\x01\0\x03\0\x03\0\x04\0\x03\0\x04\0\x03\0\x03\0\x01\0\x02\0\0\0\x02\0\x02\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x02\0\x01\0\x04\0\x03\0\x02\0\x06\0\x03\0\x04\0\x05\0\x01\0\x02\0\x06\0\x05\0\0\0\x02\0\x05\0\x01\0\x02\0\x06\0\x06\0\x02\0\x04\0\x02\0\0\0\x03\0\x03\0\x02\0\x01\0\x02\0\x02\0\x03\0\x02\0\x01\0\x04\0\x01\0\x03\0\x03\0\x05\0\x05\0\x03\0\x03\0\x02\0\x03\0\x05\0\0\0\0\0\x02\0\x05\0\x03\0\x03\0\x03\0\x03\0\x02\0\x01\0\x02\0\0\0\x06\0\x05\0\x05\0\x06\0\x06\0\x06\0\x04\0\x07\0\n\0\x01\0\x06\0\x04\0\x05\0\x03\0\x04\0\x01\0\x03\0\x03\0\x02\0\x01\0\x02\0\x03\0\0\0\0\0\x02\0\x03\0\x03\0\x06\0\x03\0\x02\0\x01\0\x05\0\x05\0\x03\0\x03\0\x03\0\x01\0\x02\0\x07\0\x07\0\x01\0\x02\0\b\0\x07\0\x01\0\x02\0\x03\0\x05\0\x02\0\x05\0\x02\0\x04\0\x02\0\x02\0\x01\0\x01\0\x01\0\0\0\x02\0\x01\0\x03\0\x01\0\x01\0\x03\0\x01\0\x02\0\x03\0\x07\0\x07\0\x04\0\x04\0\x07\0\x06\0\x06\0\x05\0\x01\0\x02\0\x02\0\x07\0\x05\0\x06\0\n\0\x03\0\b\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x02\0\x02\0\x05\0\x07\0\x07\0\x07\0\x03\0\x03\0\x03\0\x04\0\x04\0\x02\0\x01\0\x01\0\x01\0\x01\0\x03\0\x03\0\x04\0\x03\0\x04\0\x04\0\x03\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x03\0\x03\0\x05\0\x05\0\x04\0\x04\0\x02\0\x06\0\x06\0\x04\0\x04\0\x06\0\x06\0\x02\0\x02\0\x03\0\x04\0\x04\0\x02\0\x06\0\x06\0\x03\0\x03\0\x04\0\x06\0\x05\0\b\0\x07\0\x01\0\x01\0\x02\0\x01\0\x01\0\x02\0\x02\0\x02\0\x02\0\x01\0\x01\0\x02\0\x02\0\x07\0\b\0\x03\0\x05\0\x01\0\x02\0\x05\0\x03\0\x01\0\x03\0\x02\0\x02\0\x05\0\x01\0\x03\0\x03\0\x05\0\x02\0\x02\0\x05\0\x03\0\x03\0\x03\0\x01\0\x01\0\x03\0\x02\0\x03\0\x01\0\x03\0\x05\0\x01\0\x03\0\x02\0\x04\0\x02\0\x02\0\x02\0\x01\0\x03\0\x03\0\x01\0\x02\0\x02\0\x03\0\x03\0\b\0\b\0\x03\0\x03\0\x02\0\x02\0\x02\0\x01\0\x01\0\x01\0\x01\0\x03\0\x01\0\x01\0\x02\0\x03\0\x03\0\x04\0\x04\0\x04\0\x02\0\x04\0\x03\0\x03\0\x05\0\x05\0\x04\0\x04\0\x06\0\x06\0\x01\0\x03\0\x03\0\x03\0\x01\0\x03\0\x01\0\x02\0\x04\0\x03\0\x03\0\x01\0\x05\0\x01\0\x02\0\x07\0\x01\0\x02\0\x07\0\x06\0\x03\0\0\0\0\0\x02\0\x03\0\x02\0\x03\0\x02\0\x05\0\x05\0\x04\0\x07\0\0\0\x01\0\x03\0\x02\0\x01\0\x03\0\x02\0\x01\0\0\0\x01\0\x03\0\x02\0\0\0\x01\0\x01\0\x02\0\x01\0\x03\0\x01\0\x01\0\x02\0\x03\0\x04\0\x01\0\x06\0\x05\0\0\0\x02\0\x04\0\x02\0\x01\0\x01\0\x02\0\x05\0\x07\0\b\0\b\0\x01\0\x01\0\x01\0\x01\0\x02\0\x02\0\x01\0\x01\0\x02\0\x03\0\x04\0\x04\0\x05\0\x01\0\x03\0\x06\0\x05\0\x04\0\x04\0\x01\0\x02\0\x02\0\x03\0\x01\0\x03\0\x01\0\x03\0\x01\0\x02\0\x01\0\x04\0\x01\0\x06\0\x04\0\x05\0\x03\0\x01\0\x03\0\x01\0\x03\0\x02\0\x01\0\x01\0\x02\0\x04\0\x03\0\x02\0\x02\0\x03\0\x05\0\x03\0\x04\0\x05\0\x04\0\x02\0\x04\0\x06\0\x04\0\x01\0\x01\0\x03\0\x04\0\x01\0\x03\0\x01\0\x03\0\x01\0\x01\0\x05\0\x02\0\x01\0\0\0\x01\0\x03\0\x01\0\x02\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x03\0\x02\0\x01\0\x04\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x01\0\x01\0\x01\0\x03\0\x03\0\x02\0\x03\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x02\0\x01\0\x01\0\x01\0\x01\0\x03\0\x01\0\x02\0\x02\0\x01\0\x01\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x04\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x02\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x02\0\0\0\x01\0\0\0\x01\0\x01\0\x01\0\0\0\x01\0\0\0\x01\0\0\0\x01\0\0\0\x01\0\x01\0\x02\0\x02\0\0\0\x01\0\0\0\x01\0\0\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x03\0\x04\0\x04\0\x04\0\0\0\x02\0\0\0\x02\0\0\0\x02\0\x03\0\x04\0\x04\0\x01\0\x02\0\x02\0\x04\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0",
  defred: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0<\x02\0\0\0\0\0\0u\x02>\x02\0\0\0\0\0\0\0\0\0\0;\x02?\x02@\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa5\x02\xa6\x02\0\0A\x02\0\0\0\0\0\0\xa7\x02\xa8\x02\0\0\0\0=\x02v\x02\0\0\0\0{\x02\0\0\xed\x02\0\0\0\0\0\0\0\0\0\0B\x012\0\0\x007\0\0\x009\0:\0;\0\0\0=\0>\0\0\0\0\0A\0\0\0C\0I\0\xd2\x01w\0\0\0\xc7\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\x01\x14\x01p\x02S\x01\xab\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\x02\0\0[\0\0\0b\0c\0\0\0\0\0h\0\0\0Z\0]\0^\0_\0`\0\0\0d\0\0\0p\0\xc3\0\x05\0\0\0\xef\x02\0\0\0\0\0\0\x07\0\0\0\r\0\0\0\xf0\x02\0\0\0\0\0\0\n\0\x0b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0}\x02\t\x02\xf1\x02\0\0\x1a\x02\n\x02\xfb\x01\0\0\0\0\xff\x01\0\0\0\0\xf2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0O\x02\0\0\0\0\0\0\0\0\x86\x01\xf3\x02\0\0\0\0\x9b\x01u\x01\0\0\0\0B\x02\x84\x01\x85\x01\0\0\0\0\0\0\0\0\0\0\0\0N\x02M\x02\x8d\x02\0\x004\x01\x15\x01\x16\x01\0\0\0\0\x99\x02\0\0m\x02n\x02\0\0o\x02k\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x000\0\0\0\0\0\0\0\0\0\0\0\0\0f\x01\0\x008\x01:\x02\0\0\0\0s\x02\0\0\0\0,\x01\0\0\xab\x02\xac\x02\xad\x02\xae\x02\xaf\x02\xb0\x02\xb1\x02\xb2\x02\xb3\x02\xb4\x02\xb5\x02\xb6\x02\xb7\x02\xb8\x02\xb9\x02\xba\x02\xbb\x02\xbc\x02\xbd\x02\xbe\x02\xbf\x02\xc0\x02\xc1\x02\xc2\x02\xc3\x02\xa9\x02\xc4\x02\xc5\x02\xc6\x02\xc7\x02\xc8\x02\xc9\x02\xca\x02\xcb\x02\xcc\x02\xcd\x02\xce\x02\xcf\x02\xd0\x02\xd1\x02\xd2\x02\xd3\x02\xd4\x02\xd5\x02\xaa\x02\xd6\x02\xd7\x02\xd8\x02\xd9\x02\xda\x02\0\0\0\0\0\0\0\0\0\0\0\0R\x02g\x02f\x02\0\0e\x02\0\0h\x02a\x02c\x02U\x02V\x02W\x02X\x02Y\x02b\x02\0\0\0\0\0\0d\x02j\x02\0\0\0\0i\x02\0\0t\x02Z\x02`\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa0\x02\0\x003\x014\0\0\0\x91\x02\0\0\0\0\x01\0\0\0\0\0\0\0\0\x005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x12\x01\0\0\0\0T\x01\0\0\xac\x01\0\0J\0\0\0x\0\0\0\xc8\0B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0C\x01F\x01\0\0\0\0\0\0\x07\x01\b\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0U\0M\0\x80\x02\0\0\0\0\0\0X\0\0\0\0\0\x02\0g\0Y\0\0\0q\0\0\0\xc4\0\0\0\x03\0\x04\0\x06\0\t\0\x0e\0\0\0\0\0\0\0\x13\0\0\0\x12\0\0\0y\x02\0\0#\x02\0\0\0\0\xa2\x02\0\0\x16\x02\0\x008\x02\x0e\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\b\x02\x84\x02\0\0\x0f\x02\x14\0\xfc\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0b\x02\x15\0\x82\x01\0\0\x81\x01\x89\x01\x8a\x01w\x02\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01\0\0[\x02\0\0\0\0_\x02\0\0\0\0]\x02T\x02\0\0D\x02C\x02E\x02F\x02G\x02I\x02H\x02J\x02K\x02L\x02\x8b\x01\0\0\0\0\0\0\0\0\x16\0\x83\x01\0\0y\x01z\x01\0\0\0\0\0\0\0\0\0\0\xe5\x02\0\0\0\0\x1a\x01\0\0\0\0\0\0\0\0l\x02\0\0\0\0\0\0\0\0^\x02\0\0\\\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd5\0\0\0\0\0\0\0\x1c\0\0\0\0\0\0\0\0\0\0\0D\0/\0\0\0\0\0\0\0\0\0'\x01&\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe9\x02\0\0\0\0\0\0\0\0\x8f\x02\0\0\0\0S\x02\0\0\x18\x01\0\0\0\0\x17\x01\0\0Q\x02P\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x005\x01\0\0\0\0\x94\0\0\0\0\0\0\0\xc9\x01\xc8\x01\0\0\xbc\x01\0\0\0\0\0\x001\0\xe1\x02\0\0\0\0\0\0\0\0\0\0|\x02q\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcd\0\0\0\0\0\0\0\0\0\0\0\xe1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0K\x01I\x01;\x01\0\0H\x01D\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0j\0V\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8b\x02\x88\x02\x87\x02\x8c\x02\0\0\x89\x02\x11\0\0\0\x10\0\f\0\"\x02\0\0 \x02\0\0%\x02\x12\x02\0\0\0\0\0\0\0\0\r\x02\0\x007\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0z\x02~\x02\0\0\0\0\0\x002\x02\0\0\x10\x02\0\0\0\0\x8d\x01\x8c\x01\0\0\0\0\0\0\0\0\0\0\0\0\x94\x01\0\0\x93\x01w\x01v\x01\x80\x01\0\0|\x01\0\0\x9e\x01\0\0\0\0\x88\x01\0\0\xe6\x02\xe3\x02\0\0\0\0\0\0\x1d\x01\x1b\x01\x19\x01\0\0\0\0\0\0\xcb\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd6\x014\x02\0\0\0\0\0\0\xd4\0\0\0\xd6\0\0\0\xd7\0\xd1\0\xdc\0\0\0\xcf\0\0\0\xd3\0\0\0\0\0\0\0\xe5\0\0\0\0\0\\\x01\0\0\x17\0\x19\0\x1a\0\0\0\0\0\x1b\0\0\0'\0\0\0&\0\x1f\0\x1e\0\"\0\0\0\0\0e\x01\0\0h\x01\0\0\0\x007\x016\x01\0\x000\x01/\x01+\x01*\x01\xdc\x02\0\0\0\0\xe7\x02\xe8\x02\0\0\0\0\0\0\0\0\0\0=\x01s\x01\0\0t\x01\0\0\x1c\x01\xdf\x02\0\0\0\0\0\0\0\0\0\0\0\0G\0H\0\0\0\x11\x01\x10\x01\0\0i\0\0\0\xbf\x01\0\0\0\0\0\0\0\0\xc2\x01\xbe\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0V\x01\0\0\0\0\0\0\0\0\0\0W\x01N\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\0S\0\0\0O\0N\0\0\0\0\0\0\0\xed\x01\0\0\x81\x02\0\0\0\0\0\0\0\0\0\0n\0\0\0\0\0\0\0\0\0\0\0\x0f\0\0\0\x13\x02&\x02\0\0\0\0\0\0\x17\x02\x15\x02\0\0\0\0\0\0\xf9\x016\x02\0\0\x19\x02\0\0\0\0\0\0\f\x02\0\0\0\0\x85\x02\0\0\x7f\x02\xfe\x01\0\0x\x02\0\0\0\0\xa4\x01\0\0\x8f\x01\x8e\x01\x92\x01\x90\x01\0\0\0\0\x98\x01\x97\x01\0\0\xdd\x02\0\0\0\0\0\0\0\0\0\0\x7f\0\0\0\xc6\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd4\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01a\x01\0\0\0\0\0\0\0\0\0\0\0\0.\0\0\0\0\0(\0\0\0#\0!\0\0\0\0\0\0\0\0\0U\x01\0\0?\x01\0\0\0\0\0\0K\0\0\0v\0\0\0\0\0\x91\0\0\0\0\0\0\0\0\0\0\0\0\0\x9c\0\x95\0\xe9\0\0\0\0\0\xbd\x01\0\0\xb0\x01\0\0\xc1\x01\0\0\xde\x02)\x01(\x01\0\0\0\0\0\0\0\0\x1f\x01\x1e\x01Q\x01\0\0\0\0Y\x01\0\0Z\x01\0\0\0\0\xb0\x01L\0\0\0\0\0\0\0%\x01#\x01\0\0!\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc4\x01\0\0\0\0o\0m\0\0\0\0\0\xa7\x01\0\0\0\0!\x02(\x02\0\0\x14\x02*\x02\0\0\0\0\0\0\0\x009\x02\0\0\0\0\x1c\x02\0\0\x11\x02\0\x003\x02\xa4\x02\xa3\x01\0\0\0\0\x96\x01\x95\x01$\x01\"\x01 \x01\0\0\xcc\x01\xca\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xae\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x87\0\0\0\0\0\0\0\x89\0y\0}\0\0\0\xd7\x015\x02\xd3\x01\0\0\0\0\x93\x02\x92\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd2\0\0\0^\x01\0\0]\x01\0\0\0\0,\0\0\0-\0\0\0%\0$\0\0\0\xec\x02\0\0\0\0\0\0>\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x9b\0\0\0\xc0\x01\0\0\xb6\x01\0\0\0\0\0\0\0\0\0\0\0\0\xcd\x01\xce\x01\0\0\0\0\x95\x02\0\0\xef\0:\x019\x012\x011\x01.\x01-\x01\0\0\0\0\0\0\0\0\0\0X\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\x01r\0\0\0\0\0s\0\0\0\0\0$\x02\x18\x02+\x02\xfa\x01\xf6\x01\0\0\0\0\0\0\0\0\x9a\x01\x99\x01\0\0\x82\x02\xb2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb6\0\0\0\0\0\0\0\xb1\0\0\0\0\0\0\0\0\0\x83\0\0\0\0\0\0\0\0\0\x86\0\0\0\xa9\x01\xaa\x01\0\0\xe6\0\0\0\xd9\0\xd0\0\xce\0\0\0\0\0\0\0\0\0\x18\0\0\0)\0+\0\xe2\0\xe3\0\0\0\x92\0\0\0\x99\0\0\0\x9a\0\0\0\0\0\0\0\x98\0\x97\x02\0\0\0\0\0\0\x97\0\0\0\0\0\0\0\0\0\0\0\xcf\x01\0\0\0\0\xad\x01\0\0\0\0\0\0\xe0\x01\xe1\x01\xe2\x01\xe3\x01A\x01\0\0M\x01\0\0\0\0\0\0R\x01\xae\x01z\0\0\0\0\0\0\0\0\0\xc5\0\0\0\0\0\xc5\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe6\x01\xe7\x01\0\0)\x02\0\0\x1f\x02\0\0\xc9\0\0\0\0\0\0\0\0\0\0\0\xb0\0\xaf\0\0\0\0\0\0\0\0\0\xac\0/\x02\0\0\0\0\x81\0\0\0\x8f\0\0\0\x8e\0\x8b\0\x8a\0\0\0\0\0b\x01_\x01\0\0\xf2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb9\x01\0\0\0\0\0\0\xd9\x01\0\0\xd0\x01\0\0\xaf\x01\0\0\0\0\0\0\xde\x01\xe4\x01\xe5\x01@\x01\0\0\0\0[\x01\xca\0\xf0\x01\xf4\x01\xb0\x01l\0\0\0\xdf\x01\xe8\x01\xc6\0\0\0~\x01}\x01\x83\x02\xad\0\0\0\xb4\0\0\0\0\0\0\0\0\0\0\0\xbd\0\xb7\0\xaa\0\0\0\0\0\x88\0\0\0\0\0*\0\x9d\0\x96\0\0\0\0\0\0\0\xa5\0\0\0\0\0\0\0\0\0\xd1\x01\0\0\0\0\0\0\xb7\x01\xdb\x01\0\0\0\0\0\0\0\0\xe9\x01\0\0O\x01\0\0\xab\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xbc\0\0\0\x8d\0\x8c\0\xf0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\0\0\0\0\0\0\0\0\0\0\0\xea\x01\xeb\x01P\x01\xbb\0\xb8\0\x9d\x02\x9e\x02\0\0\0\0\0\0\0\0\xb9\0\xa9\0\xa3\0\xa4\0\0\0\0\0\0\0\0\0\xa2\0\xba\x01\0\0\xec\x01\0\0\0\0\0\0\0\0\0\0\xa6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xba\0\0\0\0\0\0\0\xdd\x01\xa7\0",
  dgoto: "\b\x008\0e\0{\0\x83\0\x95\0\x9f\0\xad\x007\x02f\0|\0\x84\0:\0Q\x01\x7f\0;\0\x87\0\x88\0\xc1\x01\xe9\x01N\x02\x16\x03\x93\x01 \x02\xd7\0<\0=\0\xbf\x02n\x01>\0?\0\xa1\0A\0B\0C\0D\0E\0F\0G\0H\0I\0J\0K\0L\0M\0O\x02N\0u\x01\x95\x01x\x03n\0o\0p\0O\0r\0s\0t\0u\0v\0H\x01\xa2\x02w\0\xa1\x01B\x03\x96\x01P\0w\x01\xc7\0\n\x02\xbb\x03Y\x04L\x04\r\x03\xef\x02\xdf\x04Z\x04\x83\x01\xc2\x01[\x04R\x02S\x02J\x03\xf1\x03U\x05\x8c\x04\x89\x04\x85\x04Q\0_\x05b\x03\xb9\x05\x96\x04c\x03\xa7\x04M\x04N\x04O\x04\xd5\x04\xd6\x04>\x05\x86\x05\xaf\x05\xab\x05e\x05x\0\xa3\x01R\0y\x01\xc7\x03j\x04\xc8\x03\xc6\x03\x05\x03\xb1\0S\0\"\x01\xb7\x01\x10\x03\x0e\x03T\0U\0V\0f\x04W\0X\0\xde\0Y\0Z\0\xdf\0\xe8\x000\x02\xe5\0\x85\x01\x86\x01\x8f\x02\x7f\x02[\0d\x03\xba\x05\xb6\0\\\0q\x01=\x02\x11\x03\xe0\0\xe1\0\xb7\0\xb8\0\x98\0\xdb\x01\xde\x01\xdc\x01c\x04]\0s\x01M\x01Y\x02\xf7\x03\x9b\x04\x97\x04`\x05Z\x02N\x03[\x02S\x03\x1d\x04\xf1\x02\xb8\x03\x98\x04\x99\x04\x9a\x04\x0f\x02\x03\x02\xf4\x02P\x04a\x05b\x05\x92\x03\x12\x05.\x05\x13\x05\x14\x05\x15\x05\x16\x05y\x03*\x05\x99\0\x9a\0\x9b\0\x9c\0\x9d\0\x9e\0\xbd\x01\xb1\x02\xb2\x02\xb3\x02-\x044\x045\x04\x8b\x03*\x04\xf7\x02\xbe\x01?\x01\x1d\x01\x1e\x018\x02R\x01",
  sindex: "\x14\b\xd9>\x9d\x06p,\x05,k\x0f\x90@\x96D\0\0\x84\x04l\x02WF\x84\x04\0\0\xca\x01e\0\x11\x01\0\0\0\0\x84\x04\x84\x04\x84\x04\x84\x04\x19\x03\0\0\0\0\0\0\x84\x04\x96FR\xff1?\x8b?\xdb:\xdb:\x1d\x05\0\0\xb87\xdb:\x84\x04\0\0\0\0\xe8\x04\0\0\x84\x04\x84\x04\x8e\xff\0\0\0\0WF\xd9>\0\0\0\0\x84\x04\xb9\xff\0\0\x84\x04\0\0(\x01/\0\x9b\x0b\x18\0\xd9G\0\0\0\0\xf6\x02\0\x008\0\0\0\0\0\0\0\xde\x01\0\0\0\0\"\x027\x02\0\0/\0\0\0\0\0\0\0\0\x000\x02\0\0\xd9E\x9b\0WFWF\x90@\x90@\0\0\0\0\0\0\0\0\0\0\xca\x01e\0\x18\x04B\x05\x9d\x06\xb9\xff\x11\x01\0\0\x88\x03\0\x008\0\0\0\0\x007\x02/\0\0\0\x9d\x06\0\0\0\0\0\0\0\0\0\0\x87\x02\0\0\x9e\x02\0\0\0\0\0\0l\x02\0\0<\x02`\x02/\0\0\0\xe3\x02\0\0\xe4,\0\0R\x04/\0R\x04\0\0\0\0\x0b\t\xd5\x02\xac\xff\x87\x04\n\x03\x85Ik\x0f\x8c\x03l\x02\xf3\x02\0\0\0\0\0\0L\0\0\0\0\0\0\0\xd4\x01\x13\0\0\0\x90\x03\xb6\x02\0\0+\x05\xf6\x02\x96D\x96E\x18\x03\x87C\xcdC\0\0\x90;f\x03\xb7\x03\x1c\x03\0\0\0\0J\0$\x04\0\0\0\0\x96D\x96D\0\0\0\0\0\0U\x04\x98\x04\xdb:\xdb:S\x04WF\0\0\0\0\0\0(8\0\0\0\0\0\0\xe2?\xcf\x03\0\0~\x04\0\0\0\0X\x04\0\0\0\0O\x02\x98G\xbd\x04\x96D\xc7B\xd5\x02\x90@\x95\x04o\x02\xd9>[\x05$\x04\0\0WF\0\0\xd9\x04\x0e\x01\xe5\x04\x91\xff\0\0\x93\x04\0\0\0\0\xea\x04\xa1\x04\0\0\x95H\xbe\x04\0\0\xbe\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x10\x05\x80>\x80>\x84\x04\x8e\xff\xd5\x04\0\0\0\0\0\0WF\0\0\xe1\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb3\0\0\0\0\0\0\0\0\0\0\0WF\0\0\0\0\0\0)\0v\xff\x80>\x90@\xcc\x04l\x02\xc1\x02\xf3\x02\b\x05\0\0\xe2\x04\0\0\0\0\x90@\0\0\xb9\x04\x90@\0\0\xdb:\x9b\x0b/\0\x84\x04\0\0W\x05\t\x06\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\0\0\x96D\x90@\0\0\xb9\x04\0\0\xfa\x04\0\0\xcf\x03\0\0\xcf\x03\0\0\0\0\x90@\x1f\x04WFWF6\x05;\x05WF6\x05\x18Fb\x01\0\0\0\0\x90@b\x01b\x01\0\0\0\0~\x04\x98\x01\x95\x04\x18\x04\x02\x05\x9d\x06\0\0;\x02\0\0\0\0\0\0\xad\x02\x1b\x05J\x03\0\0\xb9\x04\x80\x05\0\0\0\0\0\x003\x05\0\0\xcf\x03\0\0B\x06\0\0\0\0\0\0\0\0\0\0R\x04/\0R\x04\0\0R\x04\0\0I\f\0\0\x19\x04\0\0M\x05\xa5\x05\0\0I\f\0\0I\f\0\0\0\0\xab\x05\x97\x05]\x05k\x0f;\x03S\x04\x1d\x01{\x05\xba\x05\0\0\0\0\xb6\x05\0\0\0\0\0\0=\x03`\x05x\x05k\x0f_\x07\xf3\x02\0\0\0\0\0\0T=\0\0\0\0\0\0\0\0\xbf\x05\xbb\x05@\0z\x05\xf9\x03}\x05\0\0}\x05\0\0\x86\x05f\x03\0\0\x87\xff\xb7\x03\0\0\0\0\x81\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0,\x02\x94=\xd4=\x14>\0\0\0\0\x8b\x05\0\0\0\0\x96D\xc0\x02\x80>S\x04S\x04\0\0b\x01\xd0\x04\0\0\xf5\x02~\x04*\x04\xad\x05\0\0\x03't\x01\x03'S\x04\0\0\xec\x05\0\0k\x0f+\x03\x96E\x01<d\x02D\x05d\x05GB\0\0\x96D\x95\x05\x0e\x05\0\0\x0b\x01\x90@\x8b\x01\xa7\x03\xd6\x03\0\0\0\0b\x01|\x06\x18\x03\x90@\0\0\0\0\x18\x03\x90@;\x05\xc7\x03\x90@\xbb\xffz\xff\xdb:k\x0f\x96D\0\0\xa4\x05\xa6\x05\x94\x05\x84\x04\0\0\x96D\xc3\x05\0\0v\x01\0\0\x98\x0b\xd6\f\0\0\xaa\x05\0\0\0\0\xa8\x05\x96\x05\xc1\x02\xf1\x05\x18\x04\x19\x03\xc1\x02/\0\0\0\x96D5\x04\0\0l\x03\x9c\x05*\x04\0\0\0\0b\x03\0\0\xef\0\xfe\x05\x80>\0\0\0\0\x96F;\x05\x90@\x90@\x988\0\0\0\0\x86I\x86IQI\x1a\x07\x95HQI\x8f\f\x8f\f\x8f\f\x8f\f\xa5\x02\xe5\x05\xe5\x05\x8f\f\xa5\x02\xa5\x02QI\xe5\x05\xa5\x02\xa5\x02\xa5\x02\0\0\xe5\x05\x0f\x05/\0>A\x06\x06\0\0\xd5\x05\xc1\x02~\x04~\x04\x95H\x90@\x90@\x90@\xd9\x05b\x01b\x01\0\0\0\0\0\0\x01\x06\0\0\0\0QI\xdd\x05\x13\x05\x8f\xff\xc9\x05H\x04\xfe\x03\0\0\0\0m\x03\x14\x06\x18\x04\xe2\x04\xd8\x02/\0b\x03k\x0f\x18\x06~\x04\0\0\0\0\0\0\0\0\x11\x06\0\0\0\0R\x04\0\0\0\0\0\0\xda\0\0\0)\x06\0\0\0\0I\f\xbf\0\x19\x01\x1d\x10\0\0\xec\x01\0\0\xe2\x05\xda\x05\xc4\x05k\x0f/\x03k\x0fk\x0fu\x03\0\0\0\0\xbb\x01l\x02\xf2\x05\0\0\xd7\x05\0\0\x81\x03\x96D\0\0\0\0 \x03\x96D \0?\x03\x04\x06\"\x01\0\0\x9c\r\0\0\0\0\0\0\0\0\xaa\x02\0\x004\x06\0\0`\xff`\xff\0\0\xe9\x05\0\0\0\0\x90@\x90@\x90@\0\0\0\0\0\0\x07\x06\xbb\0\xf0\x05\0\0\xc4A\x85I\x03\x06\0\0\xb6\x02\xe8\x05\xf4\x05\xef\x05S\x04\0\0\0\0/\0\xc2\x01\x90@\0\0\x0f\x06\0\0\x96D\0\0\0\0\0\0\x17\x06\0\0\x17\x06\0\0r<\x90@GB\0\0\x1d\0Q\x06\0\0\x90@\0\0\0\0\0\0L\x06\x19\x03\0\0iG\0\0\x18\x04\0\0\0\0\0\0\0\0\xfd\0\0\0\0\0\x95H\0\0\x95HA\x06\0\0\0\0\x95H\0\0\0\0\0\0\0\0\0\0S\x04y\xff\0\0\0\0\xc1\x02\xe2\x04/\0\x90@\x94\xff\0\0\0\0\x10\x02\0\0S\x04\0\0\0\0\xd5\x02/\0\x18\x04/\0+\x01p\x05\0\0\0\x005\x02\0\0\0\0+\x02\0\0\x83\x05\0\x008\x01C\x06\x05\x06l\x02\0\0\0\0\x90@\x0b\x06S\0\xa1\x04\xbe\x04\xbe\x04\xb3\0\xa6\xff\x90@\0\0$\x0b\x90@\xe3<\x81AD\x06\0\0\0\0k\x0fC\x06/\0!\x06$\x06\xf9G\x03\x05E\0\xae\xff\x90@Y\x06\x18\x04\0\0\0\0\x19\x03\0\0\0\0\xfc\x05\xc2\x04i\x06\0\0\0\0\0\0\x18\x04$\x02l\x03v\x02c\x06\0\0\x1a\x06s\x05\x18\x048\x06\xe2\xff\0\0I\f\0\0\0\0k\x0f@\x01t\x06\0\0\0\0l\x02+\0S\x04\0\0\0\0k\x0f\0\0\x0e\x06S\x04\xf3\x02\0\0\xf2\x055\x06\0\0\x13\x06\0\0\0\0_\x07\0\0\xf9\x03&\x06\0\0\xf9\x03\0\0\0\0\0\0\0\0\x96D;\x03\0\0\0\0\xcd\xff\0\x007H\xb6\0\xd9\xffj\x06*\x04\0\0l\x02\0\0a\n\x9c\x04/\0\xc4A^\x01\x8d.\x03'/\0\0\0%\x06\x07\0(\x06\xcb\x03r\x06r\x06\x80\x06/\x06O\x06\0\0\0\0\x90@\x90@\x96DWH\x18\x04p\x05\0\0\x9c\xff\x9d\xff\0\0\xa0\xff\0\0\0\0\x90@\x90@l\x06\x18\x05\0\0\xb5H\0\x001\x06k\x0f\x96D\0\0$\x02\0\0\x19\x03k\x0f\0\0k\x0f\x8e\xff\x90@\x8e\xffu\xff/\0\0\0\0\0\0\0\x96D*\x04\0\0\xe3F\0\0<\x06\0\0\x82\x06\0\0\0\0\0\x003\x04\xeb\0>\x05U\x02\0\0\0\0\0\0Z\x06T\x01\0\0d\x06\0\0\x90@\xa3\x02\0\0\0\0\xc4A\x81\x06g\x06\0\0\0\0h\x06\0\0m\x06\x95Ha\n$\x02p\x05\x98\x06\x90\0*\x04\x96\x03\0\0\xfe\x03;\x02\0\0\0\0\x18\x04<\x06\0\0;\x02\x9f\x06\0\0\0\0.\x02\0\0\0\0A\x01\0\0k\x0fl\x02\0\0\xf2\x05\x18\x03\0\0\xac\x06\0\0k\x0f\0\0\0\0\0\0%\x04Z\0\0\0\0\0\0\0\0\0\0\0\f\x03\0\0\0\0r\x0e\xa8\x06\x85Iv\x06\x8d.z\x06\0\0\xa1\x06S\x04x\x06\0\0]\x06*\x03\xb6\x02\x07Ck\x0f\x9c\x04\b\x05\0\0P\x04S\x04\x18F\0\0\0\0\0\0/\x03\0\0\0\0\0\0%\x06/\0\0\0\0\0\x90@GBk\x0f\x90@`\x06e\x06k\x0f\0\0k\x06\0\0}\x06\0\0\x90@%\xff\0\0O\xff\0\0n\x06\0\0\0\0\x95H\0\0\x90@\x90@\x90@\0\0S\x04Q\x06p\x05;\xff\xff\x02/\0\x9c\x04/\0\0\x03/\0\x85\x06\x87\x06/\0\0\0Q\x06\0\0e\0\0\0\xdb0\"G\0\0o\x03\x8e\x06\xc0\x06\0\0\0\0\x98\x01\x01\x02\0\0%\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa9\xffZ\x06\xb3\x06k\x0fw\x06\0\0\x90@\x01\x02/\0\f\x03\x90@\x90@\x90@/\0`\x05`\x05\x95\x01\0\0\xbd\x06\xbb\x06\0\0\0\0\xde\x02y\x01\0\0a\nk\x0f\0\0\0\0\0\0\0\0\0\0\xc1\x06\x0e\x06\xf2\x05\x14>\0\0\0\0k\x0f\0\0\0\0s\x05\x99\x03W\x01\x90\x03\x8d.\x9f\x01k\x0f\x89\x04\0\0\x91\x06\xcf\x06\x9c\x04\0\0a\n\x03'\xb3\x03\x87B\0\0a\x01\xdf\xff\x90\x04\x9c\x04\0\0\x18F\0\0\0\0\xca\x06\0\0S\x04\0\0\0\0\0\0S\x04GB\x90@\x95H\0\0;\x03\0\0\0\0\0\0\0\0\x13I\0\0k\x0f\0\0\xc3\x01\0\0q\x06<\x06;\x05\0\0\0\0;\x05{\x06;\x05\0\0\x98\x01S\x04\xc0\x06\xc0\x01\x85\x06\0\0S\x04k\x0f\0\0e\0^\x02 \x02\0\0\0\0\0\0\0\0\0\0\x84\x06\0\0k\x0f\x92\x03\x81A\0\0\0\0\0\0s\x05\x95H\x95H\x95H\0\0\xf0\x03\xf0\x03\0\0k\x0f\x86\x06k\x0fv\x02e\0\x98\x01G\x02\0\0\0\0/\0\0\0k\x0f\0\0\x1f\x01\0\0\xce\x03\xd0\x03\x9c\x06/\x03W\0\0\0\0\0m\x01a\n\x8d.S\x04\0\0\0\0\0\0\x9c\x04\0\0\xf3\x02\0\0a\n\0\0\0\0\0\0S\x04\x90@\0\0\0\0\x8a\x06\0\0S\x04\xab\x06/\0;\x05;\x05\x07B\xe2\x06;\x05\f\x05S\x04\0\0\xcf\0;\x05\x94\x06\0\0\x85\x06\0\0\xdd\x03\0\0\x7f\x02t\x01S\x04\0\0\0\0\0\0\0\0\xe5\x03\x90@\0\0\0\0\0\0\0\0\0\0\0\0\x98\x01\0\0\0\0\0\0S\x04\0\0\0\0\0\0\0\0a\n\0\0k\x0f\f\x03:\x04\xba\x02/\0\0\0\0\0\0\0\xb2\x06S\x04\0\0l\0\xec\x06\0\0\0\0\0\0\xf4\x06\xf5\x06\xbdF\0\0k\x0f\xf8\x06\x90@\xef\x06\0\0\x85\x06\xc0\x06\xf9\x06\0\0\0\0k\x0ft\x01S\x04S\x04\0\0\x90@\0\0\xfa\x06\0\0/\0s\x05\xaa\x06\xb5\x06;\x05\xcf\x03\x85\x06\x0f\x07/\0\0\0a\n\0\0\0\0\0\0\x1d\x10\x1d\x10Z\x06S\x04\x06\x07\xac\x01S\x04k\x0f\0\0\x90@\xc5\x06\x1d\x10S\x04S\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15\x07;\x05;\x05k\x0f\0\0\0\0\0\0\0\0\x11\x07\x90@k\x0fS\x04\0\0\0\0S\x04\0\0\x1d\x10\x1c\x07\x1e\x07S\x04k\x0f\0\0S\x04\xcd\x06/\0k\x0fk\x0f\x04\x04S\x04\0\0S\x04S\x04\x90@\0\0\0\0",
  rindex: "\0\0/\b0\b\xd0\x06\0\0\0\0\0\0\0\0\0\0\xd5F\0\0\0\x009@\0\0s\x03\0\0\0\0\0\0\0\0\xd6DGC\x10D\xe7@\0\0\0\0\0\0\0\0\xd5F\0\0\0\0\0\0\0\0\0\0\0\0PD\xea\x10\0\0\0\0\xe7@\0\0\0\0\0\0\0\0\xf7\x03\xed\x01\xc2\x06\0\0\0\0\0\0G\0\0\0\0\0\xe7@\xd4\x03\0\0\xe7@\0\0\0\0\xe2\tG\0f\x11\x9a&\0\0\0\0@6\0\0g6\0\0\0\0\0\0\x936\0\0\0\0\xc06\xd66\0\0\xdf6\0\0\0\0\0\0\0\0\0\0\0\0\xfb\x16s\x17\x0e\x16\x84\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\x03\0\0\0\0\0\0n\0\xd4\x03\0\0\0\0\0\0\0\0y\x0e\0\0\0\0?1\xb51\0\0n\0\0\0\0\0\0\0\0\0\0\0\xf02\0\0Y3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd1\x06\0\0\xd0\x06\0\0\0\0\0\0\0\0\x7f\x04\0\0\0\0\0\0\0\0<\r<\r\0\0\n'\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0%\x0f\0\0\xed'R(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0V-\0\0\0\0\xa4\x02 \x06\0\0\0\0\0\0\x95\x06\xc8-\0\0\0\0\x039\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\x03\0\0\xfc\x06\0\0\0\0\0\0\0\0\0\0\xf84\0\0\0\0\0\0\0\0\x16E\0\0\0\0\0\0\xc5\x04\xdf6\xf3\x05\0\0\0\0`\x01\x9b\x04\0\0\xc9\xff\0\0\0\0[\0\0\0\0\0\0\0\x82\x04\0\0^\0\xfe\0\0\0\\\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0C7\xd7\x06\xd7\x06\xc7\x06\"\x04VE\0\0\0\0\0\0\x97\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0u9\xcd9\0\0\0\0\0\0%:}:\0\0\x99\0\0\0\0\0\0\0\0\0\0\0\xd7\x06\0\0\0\0\0\0\0\0\0\0[\x06\0\0\0\0\0\0\0\0\0\0\0\0\xf8\x02\0\0\0\0\0\0G\0\xf7/PD\0\0@6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xca\x1f\0\0\0\0\0\0\0\0\0\x002\x03\0\0\0\0\0\0s\x03\0\0s\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x11\xa9\x14\0\0\0\0\0\0\xe9\x17_\x18\0\0\0\0\xfc\x06\x8a\n\0\0\0\0\0\0\xd6\x04\xca\x07\xb51\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf8\x02\0\0\0\0\0\0\0\0\0\0\0\0s\x03\0\0o\x07\0\0\0\0\0\0\0\0\0\0\0\0\x7f\x04\0\0\0\0\0\0\0\0\0\0\0\0G\x01\0\x000\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1b\x07\0\0\0\0\x90\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xca\xff\0\0\x96\0\xa8\0\xfe\0\0\0\\\x05\0\0\0\0\xc9\0\0\0\0\0\xca\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd7\x06\x039\x95+\0\0\xd7\x18\0\0\0\0\0\0\xfc\x06\xe4\x06\0\0\0\0\0\0\0\0\0\0\xac\x0b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0M\x19\0\0\0\0\0\0\0\0\0\0\x0f\x01\0\0\xa9\x04\0\0\xa1\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc7\x06\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13'\0\0\0\0\0\0\xdf6\0\0\0\0\0\0\0\0z4\0\0/\x04\0\0\0\0\0\0\0\0\0\0\0\0\xd7\x06\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85\"\xf4\"P\t\x7f\x05\xcf\x0f^#@ \xb7 .!\xa4!\x02\x1d\xc3\x19:\x1a\x1b\"x\x1d\xef\x1d\xc8#\xb0\x1af\x1e\xdc\x1eS\x1f\0\0'\x1b\0\0F5\xaf\x04i\x05\0\0\0\0\0\0\xfc\x06\xfc\x06Z\x10\0\0\0\0\0\0W\x12!\x15\x98\x15\0\0\0\0\0\0\xce\x12\0\0\0\x002$\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb51\0\0\0\0\0\0\xfc\x06\0\0\0\0\0\0\0\0\x11\f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x036\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1d\x07\0\0\0\0\0\0\x99\xff\0\0\xb7(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83)\0\0\x1e)\0\0\0\0\0\0\0\0\0\0\x1c\x01\xa1\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\x04\0\0\t\n\0\0\xc6\x03+\b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0.0z0\0\0\0\0\0\0\xcb5\0\0\0\0z4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x9e\x1b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\x01\0\0\xdb\xff\0\0\xa9\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\xe0\x06\xe5\x06\0\0\0\0\0\0\0\0F5\0\0\0\0\0\0\0\x005\x01\0\0\xb9\x01\0\0\0\0\x16E\x0e6\0\0z4\0\0\x904\0\0\0\0\0\0\0\0\0\0\xdb\x04\0\0\x16E\0\0\0\0\xcd1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x04\xfe\0\\\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0v2\x0e6\0\0\0\0\0\0\xf3H\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\x02\x80\x03\0\0\xf3\n\0\0\0\0D\r\xb51\0\0\0\0\0\0\0\0\xb51\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1b\x02\0\0\0\0\0\0\0\0\0\0\x99\x01\0\0\0\0\xe8)\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\0,\x01\0\0\xf6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x06\0\0\0\0\0\0\0\0\0\0\x0e6\0\0\0\0\0\0\0\0\xdf6\0\0\0\0\0\0\0\0\xc7\x01\xea\x06\xea\x06\xd7\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0}'\0\0\xf7\x06\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe03\0\0\0\0\0\0\0\0\0\0\xf5\x04\0\0,\xff\xe7\x04:\b\0\0\0\0\0\0\0\0/\x04\0\0\x18\x07\0\0\b\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0D\x13\0\0\0\0\xbc\x13\0\x003\x14\x97$\0\0\xff1!+r\x04\0\0\xe4\x06\0\0\0\0\0\0\xe9\r\0\0\0\0\0\0\b\x02\0\0\xe9\r\0\0\0\0\0\0G\x01\0\0\0\0\0\0A;\0\0\0\0\0\0O*\0\0\0\0\xac\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0E/\0\0\xd8\x05\0\0\0\0\x80/\0\0\xc0\b\0\0\0\0\x01\x07\0\0\x8b0\0\0\0\0\0\0[\x06\0\0\0\0\\5\x14.\0\0\0\0\0\0\xe70\0\0\0\0\0\0\x124z4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb5\0\0\0\0\0\0\0\0\0\0\0\xdb\x01\x14\x1c\xbd4\0\0\0\0:\b\0\0:\b\x0e\x07:\b\x12\x07\x12\x07:\b\0\0\x8b\x1c\0\0\0\0\0\0\0\0 \x07\x9d.\xb12\0\0\xec2\0\0\0\0\x831M4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0:\x07\0\0\0\0\0\0\0\0\0\0M4\x0e6\0\0\0\0\0\0\0\0\xe9\r\0\0\0\0\0\x004\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb4*\0\0\0\0\0\0\0\0\0\0\0\0M4\0\0\0\0\r\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0O.\0\0\0\0\0\0\0\0\xf2\x01\0\0\0\0\0\0\t\x02\0\0\0\0\xfc$\0\0\0\0\0\0\0\0\0\0\0\0V\x01\0\0\0\0\0\x006\x02\0\0\x13\x07\x0e\x07\0\0\0\0\0\0\0\0%\x07\0\0\0\0\x831'3j3\xf3\x01\x12\x07\0\0:2\0\0\0\0\0\0\xef4\xdf6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0M4f%\xcb%0&\0\0P\f\xdd\f\0\0\0\0&A\0\0\0\0\0\0D\x07\xb51\0\0\0\0\xe9\r\0\0\0\0\0\0\xfa\x03\0\0\0\0\0\0\0\x0051\0\0\0\0\0\0\xe3\x04\0\0\0\0r5\0\0\0\0\xbb/\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd8.\0\0\0\0\0\0\0\0\0\0\t\x05\0\0:\b\0\0\0\0\0\0\0\0\0\0\0\0:2\0\0\0\0\0\0\0\0\0\0E\x02\0\0\0\0\0\0\xef4\0\0\xd73\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0D\x07\0\0\0\0\0\0\xbe\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&\x07\0\0\xe3\t\0\0\0\0\0\0\0\0\x13/\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x12\x07\xa53\0\0\0\0\0\0\0\0\0\0\xd73\xc15\0\0\0\0\0\0,\x0e\0\0\xe3\t\xe3\t-\x072\x07\0\x008\x07\x12\x07\0\0\xe3\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x000\x03\0\0\0\0/\x05\0\0\0\0\0\0\0\0\0\0\xef*\xc15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb4\x05\0\0\0\0\x9b\x02\0\0\0\0\0\0\0\0\xb8\x05\0\0\0\0i\x04\xff\x06\xe3\t\0\0\0\0\0\0\x9f\x04\0\0\xe1\x06\xd3\b\0\0\0\0\0\0",
  gindex: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\\\0\xf3\xff\0\0V\0\xfd\xff\xe8\x06\xff\x07>\0\0\0\xcc\xff\x87\0?\0[\xff\0\0\x94\xfe\0\x07G\xff\xd2\x07\xa3\x0e\xf3\xfc\x11\0\x16\x04\x0e\x001\x004\0B\0\0\0\0\0\0\0\0\0K\0X\0\0\0a\0\0\0\x02\0\x04\0^\xfe\0\0\0\0S\xfe\0\0\0\0\0\0\0\0c\0\0\0\0\0\0\0\0\0\0\0\xee\xfe\xa0\xfc\0\0\0\0\0\0\x06\0\0\0\0\0\xa4\xff\xcf\xfe\x88\xfe\x12\xfcr\xfcH\xffg\x04\xa8\x03\0\x000\x048\xfds\xff7\x04\0\0\0\0\0\0\0\0\0\0\0\0\x10\x03\xf7\xff\xcc\xfb\xc9\xfe$\xfe\x81\xfc9\x03\x8b\xfb\x1d\xfc\n\xfcZ\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8c\x05\xcd\x04\xa8\x04\0\0\0\0g\xff\x1e\0\xe7\0\x8c\xff\x05\x02\t\xfd]\xff\xbe\b1\x0b\0\0\0\0\0\0j\xff\xfb\x06\x8e\f>\x06\x01\0V\xffI\x06\x86\xfe\0\0\"\x07p\x06\xd6\x0b\xbd\xfcX\xfd\xd4\xfe\0\0\0\0\0\0\xdc\x04L\x04\0\0\0\0\xa6\x06w\xff\xdc\x05\n\b\0\0O\x04\0\0\0\0P\bI\x02P\x05-\xfc\xb8\xfb\xf4\xfc\xd2\xfd\0\0\x0f\xfe\0\0\0\0\xea\xff\0\0\0\0\xeb\xfb\xf9\xff\xf0\xfbi\xfe\xfe\xfd\"\xfe\0\0\0\0\xf7\x02\0\0\0\0\xfc\x03\xa0\xfb\0\0\xaa\x03\x9a\x04\0\0s\xfd\x03\f~\xff\0\0\t\0C\xfe\n\x06\x88\xff\xd7\xfe\x82\xff\0\0\xfd\x03\0\0\0\0\0\0\xee\x06\0\0\0\0\0\0\x1a\x005\xff\0\0",
  tablesize: 19189,
  table: "~\0\x85\0\x8c\x01\xa0\0l\0\xc8\x01m\0E\x02\xcd\0\x93\x02\xd5\x01\xb5\x01\xfb\x02\xc3\x01\xda\x01;\x02\xbf\0\xb4\x01\x91\x03\xc0\x02\xe4\0\xd1\x01\xcc\x03\xb9\x01\xf0\x02\x1a\x02\xbb\0\xb5\x02\"\x02\xbb\0\t\x04\"\x04\xea\0>\x01\xf4\x01\x97\x02\xbb\0\xbb\0\xbb\0\xbb\0M\x03\xc1\0\xe1\x03\xbd\x03\xbb\0\x93\x03\xf5\x02\x1f\x02\xfc\x02\x19\x05@\0\xbb\0@\0@\0g\0\xbb\0\x1b\x02\xac\x04\xdd\0\x1f\x01\xbb\0\xbb\x002\x02@\x013\x02\x80\0\x86\0\x81\x02h\0\xbb\0\xae\x003\0\xbb\0T\x01\xf9\x01\t\x05\xc9\x01i\0I\x01\xf6\x02\xad\x01\xf6\x02\xaf\x01\xd7\x049\x02\x9a\x01\x03\x05\x05\x05\x8d\x01}\0j\0\x95\x020\x059\0\x1c\x02\xce\x04\xf3\x04\x9f\x01@\0k\0l\0q\0m\0\xe1\x04\xb9\0\b\x02\xe6\x02\xe7\x02U\x01\x9f\x02W\0\xf7\x01l\0\x84\x01m\0\x88\x01\x89\x01H\x02F\x02\xe2\0\xfd\x02\x9d\x04,\x03@\x02G\x01\xf5\x01\xb9\0\xab\x01\xa4\x01\xf6\x01\f\x05\xbc\x01-\x03\xf2\x04\x9f\x02?\x02\xf7\x01\xb2\x04\r\x05\xf8\x01\x96\0J\x01\xb8\x02q\x03\xb9\x02+\x02\xb3\x01\xe3\0\xe0\x03G\x01g\0\xc5\x01\xfc\x04\x1b\x02\x9a\x02\xf9\x04t\x04v\x04\x9f\x02<\x04x\x04\xa4\x02g\0\xb9\0h\0\xbc\x04\x02\x04\xca\x01@\x03\x17\x05\x1b\x02\xa4\x02E\x03i\0\x14\x04\xf4\x04h\0U\x01j\x05@\0\xb6\x01U\x01\x06\x04U\x01P\x02i\0j\0*\x03\xb9\0>\x01\x80\0\xfa\x01\xac\x01\x07\x02\x86\0k\0\x86\0q\0j\0u\x04w\x04k\x01\xa6\x01 \x05\x02\x02=\x04w\x05k\0\x1d\x02q\0\xb9\0\0\x02\x01\x02\xbd\0G\x02\xee\x02\xaa\x01\x14\x04\x04\x02j\x019\x05\xbd\0\xbd\0H\x05C\x03\xd3\x01g\x03\xb9\0\xdd\x01\xdd\x01\x8b\x02\x8a\x04&\x02\x1f\x02\xbd\0A\x05\xdb\x03I\x05,\x02r\x03\xbc\0\xfc\x01\xfd\x01\xc4\0\f\x05M\x05\xd7\x02\\\x05'\x02\x1b\x02\xd0\0\xd1\0\xd2\0\xd3\0)\x04\xa4\x02y\x04h\x05\xda\0\x92\x01\x9a\x02\xa5\x01\x03\x04@\0L\x01\0\x05\xb8\x01\x92\x01\x92\x01A\x01\x15\x04\x14\x02\xb9\0\x81\x02E\x01F\x01\xbd\x02\x9a\x02\x9a\x05\xcd\x01\x92\x01+\x03\x85\x02K\x01\x86\x02h\x05N\x01d\x04\xa7\x03\xf5\x01\xb9\0\xa7\0\xce\0\xf6\x01k\x01\xa6\x01O\x01A\x02k\x01\xa6\x01\xf7\x01>\x04V\x01\xf8\x011\x05\xbb\0#\x02}\x03\xd4\x02\xe5\x02\xd5\x02B\x02j\x01A\x04C\x02r\x01j\x01\xbe\x02I\x02J\x05\xd0\x02/\x04\xd2\x05\xcd\x02\xc1\0\x12\x04\xa6\x023\0U\x02K\x02\x88\x05\\\x02\xca\x02B\x05\xf5\x01@\0@\0e\x02\xf6\x01\xfc\x03h\x03i\x03\xa0\x05\x89\x05I\x01\xf7\x01\xc9\x04g\x01\xf8\x01\xce\x01n\x01^\x02\xb9\x003\0\xa5\x01\xc0\x03\xbb\0\xa0\x05\xa5\x01\xcd\x03n\x01|\x02]\x02 \x03\xb2\x05\x82\x02W\0\xeb\x02\xe9\x04@\0e\x04P\x01\xc8\0\x85\x03\xad\x02\x90\x02\xaf\x02\xcc\x05\xb0\x02\x18\x03\0\x03\xd0\x04\xa8\x03\xd3\x04W\x05\x1b\x02U\x01\xc9\0\x99\x02\f\x05\xf0\x020\x04W\0D\x02\xc0\x02^\x05\xe0\x04\xb9\0\x8c\x03\xb9\0\xce\x03\xdc\x03U\x03l\0D\x03m\0\xa1\x01[\x02\x18\x05T\x02\xb9\0\x8c\x02\x8d\x02\xd1\x02\xa8\x05\x91\x02\xa5\x05\x84\x01\xc3\x04\x13\x04\x9c\x023\0\xfb\x01\xca\0\x9f\x01l\x01o\x01\xb4\x04\x1e\x02\x87\x01~\x02\xd7\x03\xfd\x03\x87\x05\x9f\x01?\x02o\x01m\x01\x12\x04\x7f\x05g\x01\xb3\x01\xca\x04\x8b\x05n\x01\x1e\x02\x1d\x02n\x01\xb3\x01\x1d\x02\xb3\x01\x02\x02\xf0\x02g\0\x8f\x04\x88\x03a\x03^\x02\\\x02t\x05\xb3\x05\xb5\x03l\x01\x1d\x02P\x03\xcb\0\xca\x01h\0\xcc\0\xe5\x03\xd4\0\x90\x04\xcb\x02o\x05m\x01U\x01i\0U\x01\xc8\0U\x01_\x04`\x04\x88\x03\x8d\x03\xfa\x01k\x03Q\x05\x1b\x02\x86\0j\0\x86\0\xa1\x04\x86\0\xc9\0\xfa\x01 \0\xa6\x05\x18\x03k\0\xa1\x01q\0\xd5\0\xa0\x01[\x02O\x05T\x02\xfa\x011\x04R\x04\xd8\x03\xa3\x02\xc0\x02\xa0\x01R\x04\xf6\x02\xd0\x04\x18\x04\x99\x05\x9f\x01:\x02o\x01\x9f\x01l\x01o\x01\x1e\x02\xfa\x01\xfa\x01i\x01 \x04\xca\0\x02\x02\x02\x02@\x04\xcb\x02m\x01\xcb\x02&\x04\xb6\x03\x82\x03\xd6\0\xa2\x01\x8e\x03\x1d\x02z\x05\x02\x02\x88\x036\0\xcf\x05\x05\x02\xfa\x01&\x03\xc0\x02\xc0\x02^\x02\\\x02\xf0\x02\xa3\x02\x10\x05\xf7\x01\xc1\x02\xac\x03@\x002\x05&\x02\xc8\0\xde\x02\xe0\x02\xe2\x02\x89\x03\x9a\x03\xbc\x03\xcb\0\xda\x01\xe3\x02\xcc\0$\x02\xb9\0\x9b\x03\x9c\x03\xc9\0]\x04k\x03\xe7\x03\n\0\x88\x03\xa2\x04\xf4\x03Q\x03\xbb\0\x1e\x02.\x03\xe2\x02p\x01&\x02\xa7\0\xce\0\xa0\x01\x17\x03\x9d\x05\xa0\x01\xe4\0\x1b\x02R\x04\x0f\x03\xa3\x02\xd9\x03\xd2\x03R\x03w\x02[\x03\xb9\0X\x03Y\x03s\x04d\x01\xca\0d\x01\xc1\x02\xa8\x04\xe2\x02i\x01\xd1\x01\xb9\0x\x02\xc1\x02\x80\x01\x81\x01\xc1\x02\x1b\x020\x03O\x02\x8f\x03\x05\x02\xa2\x01\x87\x03w\x02~\x02\xc2\x02\xdd\0{\x05\x80\x05,\x05\xad\x03)\x027\x03O\x02l\x03m\x03\xc8\0\xa3\x02x\x02\x1a\x03R\x04\xbf\x05@\0\xfa\x01G\x03\xcb\0\x11\0\xc0\x04\xcc\0p\x01\xad\x04\xc9\0\xf5\x03\x1b\x03\xfe\x02q\x05\x81\x05s\x05+\x04\xc1\x04\x9a\x02\x01\x040\x02{\x03\x89\x01\xe2\x02\f\x02\xb5\x03\x9c\x02a\x03!\x001\x02\xf8\x02\xfe\x03\xff\x03\0\x040\x04\xc1\x02%\0\xbc\x01\x82\x058\x05\xf9\x02\xbb\x04$\x02\xb9\0\x19\x04\xca\0/\x03w\x02^\x04G\x05\xb3\x01w\x02\xd4\x05O\x02O\x02\x80\x01\x81\x01T\x05\x1b\x02:\x03<\x03\xe3\x03x\x02$\x02\xb9\0\xa0\x03x\x02\x9e\x03O\x02O\x02r\x01O\x028\x03]\x05\xf3\x03\x86\x04C\x05\x88\x04\x8b\x04\xc2\x03\x83\x05U\x013\0t\x01\xdd\x006\0O\x02\xcb\0\xb2\x03\xb3\x03\xcc\0\x0e\x02\xcb\x01\x1c\x03\x86\0\xe4\x020\x02\xfa\x010\x02\xfa\x01\xda\0\xfa\x01\xfa\x01'\x05q\x011\x02\xc0\x021\x02:\x04\x94\x02\xc3\x03\xcc\x01\xfc\x02:\x05\xe4\x02R\x04\x94\x02\xba\x01\xbc\x03\xb9\0\xb9\0\xe4\x020\x04\xcb\x03(\x04\x02\x026\x04\xde\0\xa3\x03\xca\x01\x94\x02\x94\x02\xa6\x032\x04\x0e\x05R\x04\xcc\x01\x94\x02\x91\x03r\x01\x9c\x04\x9f\x03\xe4\x02\xe4\x02R\x04\xf6\x02\xfa\x01\xe2\x034\x03\x1b\x02\xdb\0v\x01\x94\x02\xdd\0\x10\x05\x94\x02\xe4\x02\x83\x03\xdb\x02\xe3\0\x82\x04\xe4\x02\xbf\x04&\x02\xe4\x02\x93\x03\xe4\x02\x94\x02\x9e\0\xda\0\xc5\0\xf5\x01x\x01q\x01\xc6\0\xf6\x01\xea\x03\xe2\x02\xca\x01\xfa\x01\xc5\x03\xe8\x03\xf7\x01P\x01\xc0\x02\xf8\x01\x98\x03\x9e\0\x94\x02\xca\x01\xef\x03\xca\x01\xf0\x03,\x05\x9e\0\xfa\x03\xde\0\xb9\0\x9c\x02&\x02\xbc\x03\xf9\x03\xfa\x01\x04\x04\xeb\x03\xec\x03\x07\x04\f\x02\xe4\x02\x94\x02\xaf\x03\x1e\x04\x94\x02\xa5\x04P\x01\x9e\0\x9e\0\xb9\0!\0\xdb\0\r\x02\x93\x02\f\x02\xa7\0\xce\0{\x01%\0\xb9\0\xed\x03\x9e\0\x94\x02\x1b\x02c\x05\x94\x02\xb9\0g\x05\x9e\0\x9e\0\xe2\x02\x9e\0\xb9\0P\x01Q\0\xd8\x02R\x04R\x04\x9f\x02\xf5\x01\x96\x02\xb8\x04\x9d\x01\xf6\x01\xa0\x01P\x01R\x04\f\x02\x9c\x02\xd9\x02\xf7\x01\xb3\x01\xd4\0\xf8\x01\xca\x01\xe9\x03.\x04$\x02\xb9\0\x9a\x02\x9f\x05\xde\x04\xee\x03\xc5\x04\xa5\x01C\x04\x0e\x02\xa2\x01\xda\x01\x02\x02\x89\x01\x02\x03\x03\x03\x9e\0\x89\x01\xca\x018\x04 \0\x89\x01\xbd\0\x89\x01\x0e\x02\x9a\x02\xd5\0\x89\x01\x89\x01\xfa\x01\xc7\x04\x89\x01\xfa\x01\xa1\x02\xf7\x01\x1b\x02\x83\x02\xf8\x01D\x04\xab\x04\x89\x01\xca\x01R\x04\xa6\x01\x9d\x02\xb9\0\x98\x05\x9d\x01\xb5\x018\x04\xd1\x01o\x04p\x04\r\0\xb4\x01\x1b\x02L\x02\x0e\x02\xa2\x05b\x01c\x01\x04\x03\x9a\x03\xfa\x01\xd6\0{\x04\xd0\x05\xd1\x05\xbe\0M\x02\xb6\x016\0\x12\0!\x02\xda\x02\xc3\x01&\x02\xa3\x02:\x03\xb9\0\x89\x01\x9c\x02\x87\x04;\x04X\x04\x0b\x04\xb9\0\x89\x01\xcc\x01\x0e\0\x18\0\x19\0\x1a\0R\x04\xec\x02\x9c\x02\xb1\x01\xe2\x02o\x01h\x01\xe3\0\xe2\x02\xc7\x01\xe2\x05\x0f\0\x10\0\x89\x01\x89\x01\x1e\x02\x89\x01\x89\x01\xac\x05\xaa\x04\xa9\0\xc3\x05\xc4\x05m\x01\x17\0*\0\x0f\x03\xed\x02\xc3\x01,\x02&\x02\x7f\x01\xb7\x04#\x02\xaa\0\x89\x01\xbf\x01\xd0\x01\xfa\x04\x97\0\xca\x01\xb0\0p\x01,\x02!\0\xb9\0\x0f\x03S\x01\x97\x05\x93\0\xde\x042\0%\0\x9c\x02&\x02\xd9\x05\xad\x05\xd9\0)\0\xf5\x01\xf7\x01\x9c\x02\x0f\x03\xf6\x01\xc6\x01-\0\xc4\x04\x9c\x02\x7f\x03\xbb\x01\xf7\x01\x02\x02\xd4\0\xf8\x01+\x05\xa9\x03\xdd\x04\xe1\x05\xb9\0\xf7\x01\xcb\x04\x1b\x02\xff\x02\x80\x03 \0\xaa\x03\xf7\x01\xf7\x01\xfa\x01\xcc\x04\xd1\x04\xeb\x05,\x025\0\x81\0\x9a\x02\xc7\x01 \0\x1b\x02,\x02\x9f\x02\xd8\x01\xfe\x04\xd5\0H\x04\xb1\x01\xda\x04\xf7\x01\xf7\x01\xd8\x016\0\xe8\x04a\x03\xa0\x02\xeb\x04\xbb\x01\xc7\x01\x80\x04\xe4\x04,\x02\xcc\x01\xf7\x01\xb9\0\x83\x04\xb1\x01\x84\x04\xff\x04\xbb\x01\xf7\x01\xf7\x01\x94\x01\xf7\x01\x84\x01\xf6\x04\xf7\x04\x93\0\xbd\0\x95\x04\xc6\x02\xe0\x02Q\0\xd6\0\xfb\x01\x1b\x02\x9c\x02\xea\x01X\x046\x006\0\x07\x05\n\x05\x93\0\xa1\x02Q\0\xc7\x016\0\xa4\x03\xca\x01\x99\x03&\x02\xca\x01\xca\x01\x11\x05\xeb\x01\xec\x01\xed\x01Q\0Q\0Q\0Q\0\x93\0\x97\0a\x03\xf7\x01\xc7\x01O\x03\x97\0\x97\0\xca\x01\x1d\x03\x1d\x05Q\0\x92\x01\x98\x02\xc7\x02n\x05\xbd\x007\x05P\x01\x9a\x03\xb9\0\xee\x01\x98\x02-\x05\x9d\x03X\x04\xb0\0\xb0\0\x8a\x05\xb0\0\xb0\0Q\0\xb0\0\x1b\x02Q\0\x1e\x03\xa2\x03Q\0Q\0Q\0\x9d\x01'\x03\xb0\0\xb0\0\x9d\x01Q\0\x9c\x02\xc4\x01\x9d\x01\xf5\x01\x9d\x01\x93\0Q\0\xf6\x01\x9d\x01\xb9\0\xef\x01\xb6\x04\x9d\x01h\x04\xf7\x01\xcc\x01z\x03\xf8\x01Q\0\xda\x04Q\0\x9d\x01Q\0Q\0e\x02\xcb\x02\xb0\0\xb0\0\xf0\x01\xf1\x01\xf2\x01\xd9\0(\x03P\x05Q\0\xea\x04e\x02Q\0\xe4\x04\xee\x04D\x05Q\0\xcf\x01X\x05\x9e\x05\xd4\0Y\x05\xca\x01[\x05\xf5\x01\x9d\x01\xca\x01\xa3\x05\xf6\x01\x9d\x01\x84\x01\xf3\x016\0\x9e\x035\x05\xf7\x01f\x05X\x04\xf8\x01\x9d\x01\xe4\x04\xb9\0|\x05\x9d\x01\xcc\x04 \0\x7f\x01X\x04\x90\x02\x90\x02\x7f\x01\xd5\0\xca\x01\b\x05\x7f\x01\x90\x02\x7f\x01\x02\x02\xea\x05\xb9\0\x7f\x01\xc7\x02\x9d\x01\x9d\x01u\x05\x9d\x01\x9d\x01\xb9\0\xf5\x01\x90\x02\xd2\x01\xca\x01\xf6\x01\x7f\x01\x1b\x05\x90\x02\xda\x04\xcc\x01\x9f\x04\xf7\x01H\x03\x1f\x03\xc8\x04\xe4\x02\x9d\x01\xfb\x01\x8e\x01\xb9\0\xc7\x02\xd6\0\x93\0\x84\x05\xc6\0\x85\x05\x90\x02\x90\x026\0\xfa\x01\xb9\0t\x03v\x03\xd9\0\x8c\x05\xca\x01\x90\x05\x91\x05I\x03\xcb\x05\x95\x05\xe4\x04o\x01 \0\x88\x02\x9b\x05\x89\x02\xa0\x04\xbd\0\x8f\x01;\x05\xb9\0\x7f\x01\xe4\x04\x0e\0\xd8\x01\x8a\x02u\x03\x90\x01\xca\x01\x9f\x02\xe4\x02\xfe\x01\xb9\0\xf8\x01\xb4\x02\xa4\x05w\x03\x02\x02\x0f\0\x10\0\x7f\x01\x7f\x01W\x02\x7f\x01\x7f\x01\xca\x01X\x04\x9f\x02\xe3\x04\x02\x02\xae\x05\x17\0\xf8\x01\x91\x01\xca\x01\xf1\0X\x02S\x05\xa3\x02\xf8\x01\xf8\x01\xb0\0\x7f\x01\x92\x01{\x02<\x05\xca\x01\xc7\x01\xe0\x02{\x026\0!\0K\x05\x9f\x02S\x01\xbd\x05\xa9\x05d\x05\xb9\0%\0\xf8\x01\xf8\x01\xe4\x04\xe0\x02\xe0\x02)\0\xba\x01\xc7\x01\xc5\x05m\x05\xca\x05=\x05-\0\x94\x01\xf8\x01\xa3\x02\xe0\x02\xa4\x02L\x05\xbb\x01\xaa\x05\xf8\x01\xf8\x01\xff\x01\xf8\x01\x02\x02\x02\x02\x84\x01\x82\0z\0\t\x02\x84\x01\x0b\x02\xda\x04y\x05\xd6\x05\xe0\x02S\x04\x84\x01\xe0\x025\0\x84\x01\xdb\x05\xdc\x05\xe0\x023\0\x97\0\xb9\0\xe3\0\xca\x01\xe0\x02\x13\x02\xca\x01\x97\0\xa4\x02\x97\0\xdf\x05\xe0\x02\xca\x01\x02\x02T\x04\x97\0W\0\x1e\x02 \0\xba\0\xf8\x01\x90\0S\x01\xc6\x01U\x043\0\xe2\x02\xe0\x02\xe0\x02\xb3\0\x97\0\x97\0\xca\x01\xec\x05\x81\x04\x02\x02\xb0\0\xe2\x02V\x04\xe0\x02\xca\x01(\x02W\0\xca\x01\x84\x01\x1d\0-\x02\x90\0\xca\x01\x02\x02\x8e\x04\xca\x01\xca\x01V\x02\xe2\x02\xb3\0r\x02r\x02*\x02W\x02/\x02\x11\x04\x1c\x04.\x02\xe8\x02\x84\x04\xe9\x02\xc2\0W\x026\0\xb0\0\xb0\0\xb0\0X\x02r\x02\xd8\x01\xea\x02\xf5\x01\xb0\0\x87\x01\x9f\x02\xf6\x01X\x02\xb8\x05B\x02\xbb\x05\xc2\0C\x02\xf7\x011\x02\x8a\x01\xf8\x01\x97\0\xc2\0\x97\0\xc1\x054\x02\x96\x05\x9f\x02\x97\0\\\x03\xb0\0\xb0\0\x9f\x02\xfb\x01\xa0\0\xb0\0\x9f\x02\xb0\0\x9f\x02<\x02\x9f\x02\x9f\x02\x9f\x02\xc2\0\xc2\0\xd9\0J\x02\xb8\x05\xb8\x05\xa3\x046\0}\x04>\x02\xa0\0\xd5\x05:\x02\x9f\x02\xc2\0B\x01\xa4\x04\xa0\0Q\x02\x97\0\xb0\0\xc2\0\xc2\0w\x02\xc2\x006\0\xb9\0\xb0\0\xdd\x05\x1e\x02C\x01D\x01\x97\0\x97\0o\x01\xe0\x05\xa3\x02p\x03\xa0\0\xa0\0\xb9\0\xb8\x05\x94\x01\xd9\0\x9f\x02\xe5\x05\xa3\x02\xb0\0 \x01\x84\x02\xe8\x05\xe9\x05\xa0\0\x85\x01\x13\x03!\x01\x98\x02\x85\x01\xba\0\xa0\0\xa0\0\"\x03\xa0\0\x8e\x02\x85\x01$\x03\xc2\0\x85\x01\xe3\0\x14\x03\x15\x03\xf1\0\xf1\0\xf1\0\xf1\0\xf2\x03\x85\x01\x06\x03\x07\x03\xf1\0\xf1\0\xf1\0\x9e\x02\xb6\x01\xf1\0\xf1\0\xa4\x02\xf1\0\xf1\0\xf1\0\xf1\0\xf1\0\xf1\0x\x01\xb0\0\xf1\0\xf1\0\xf1\0\xf1\0\xf1\0\xf1\0$\x02\xb9\0P\x01\xa0\0\x98\x01\xa5\x02\xf1\0\xf1\0\x06\x03\t\x03\xf1\0\xf1\0\xf1\0\xf1\0\xb6\x02\x85\x01\xb7\x02\xf1\0\xf1\0C\x01\x99\x01$\x02\xb9\0\x9f\0\x94\x01\xb9\0P\x01\xc0\0\xba\x02\x97\0\xbb\x02\xf1\0\xf1\0\xbc\x02\xf1\0\b\x03\n\x03\xf1\0\xf1\0\xf1\0\xc3\x02\xf1\0\x9f\0\xc4\x02\xf1\0\xf1\0\xc0\0\xc5\x02\x97\0\x9f\0\x93\0\x97\0\xf1\0\xc0\0\xf1\0\xc9\x02\xce\x02\xcf\x02\x97\0\xb5\0\x97\0\x97\0\xd2\x02\xf1\0\xf1\0\xd3\x02\xf1\0\xf1\0\xf1\0\xf1\0\x9f\0\x9f\0\xb0\0\xd6\x02\xc0\0\xf1\0\xb0\0\xf1\0\xb5\0?\x02\xf1\0\xf2\x02\x97\0\xf1\0\x9f\0\xb5\0\x1d\0\xf1\0\xc0\0\x1d\0 \0\x9f\0\x9f\0e\x02\x9f\0\xc0\0\xc0\0\x12\x03\xc0\0\x1d\0\x1d\x001\x033\x032\x036\x03>\x03\xb5\0\xb0\0\x97\0=\x03?\x03A\x03\x1d\0\x1d\0\x1d\0\x1d\0L\x03T\x03c\x01e\x03\xb5\0f\x03\x05\x02n\x03\xb0\0s\x03\x1d\0\x1d\0\xb5\0o\x03\xb5\0\x8a\x01\xb0\0|\x03\xb0\0\x8a\x01\x9f\0\x84\x03\x86\x03\x8a\x01\xc0\0\x8a\x01\x8a\x03\x95\x03\xd9\0\x8a\x01\x8a\x01\x1d\0\x94\x01\x8a\x01\x1d\0z\x01\x1d\0\x1d\0\x1d\0\x1d\0\x97\x03\x96\x03\x8a\x01\xce\x01\xa1\x03\x1d\0`\x02a\x02b\x02c\x02\xf7\x01\xd5\x01\x1d\0\xab\x03\xb0\x03\xb4\x03\xb5\0\xa7\0d\x02\xb7\x03\xbe\x03\xbf\x03;\x01\xc4\x03\x1d\0\xe6\0\x1d\0\x9e\x01\x1d\0\x1d\0\x94\x01\x06\x03\xcf\x03\xd1\x03\x93\0\xda\x03\xf8\x03\xf6\x03\n\x04\xa7\x02\x1d\0\x0e\x04\x8a\x01\x1d\0\x0f\x04\xa7\x01\x17\x04\x1d\0\xfb\x03\x8a\x01\x1a\x04\x1f\x04\xae\x01\x93\0\x86\x02\xd9\0#\x04$\x04\xa8\x02\x97\0\x93\0\xb0\0\xb0\0e\x02'\x04\n\0\x97\x003\x04\x8a\x01\x8a\x017\x04\x8a\x01\x8a\x01\xc7\x02\xa7\0\xce\0B\x04\x94\x019\x04g\x04\xd9\0\x93\0\x93\0b\x04i\x04l\x04m\x04n\x04\x7f\x04\x94\x01\x8a\x01|\x04x\x01\x9c\x04\x9e\x04\x93\0x\x01\x94\x01\xa6\x04\xae\x04x\x01\x97\0x\x01\x93\0\x97\0\x93\0x\x01x\x01\xa9\x04\xaf\x04\xb0\x04\xb3\x04\xa9\x02^\0\x97\0\xb1\x04\xbe\x04\xaa\x02\xc6\x04x\x016\0`\x02a\x02b\x02c\x02\xd2\x04\x97\0\xd4\x04_\0\x10\0\xd8\x04\xd9\x04!\x03d\x02%\x02\xec\x04\xb0\0\xdb\x04\xdc\x04\x0b\x05\xed\x04`\0\xf0\x04\x90\x04\x1a\x05M\x02\xef\x04\x93\0(\x05\xf5\x04K\x04W\x04\x02\x05\xb0\0\x04\x05\x97\0\x97\0)\x05\x1c\x05x\x01\xaf\0!\0?\x053\x05@\x05N\x05x\x01r\x05\xbf\0%\0V\x05l\x05\xb0\0~\x05\x94\x01a\0\xd8\0\x8d\x05e\x02\x8e\x05Z\x05\xdc\0-\0\x94\x05\x9c\x05x\x01x\x01\xbf\0x\x01x\x01 \0\x97\0\xb0\0 \0\xbf\0\xb1\x05\xd9\0\x97\0b\0\x97\0\xb4\x05\xb5\x05\xb6\x05 \0 \0\xbc\x05\xc0\x05x\x01\xb0\0\xbe\x05c\0\x97\0\x0e\x05d\0\xc9\x05\xbf\0 \0 \0 \0 \0\x01\0\x02\0\x03\0\x04\0\x05\0\x06\0\x07\0\xc8\x05\xcd\x05\xbf\0 \0 \0\xd3\x05\xd7\x05\xda\x05\xb0\0\xbf\0\xbf\0\xde\x05\xbf\0Z\x01\xe3\x05\x9c\x01\xe4\x05K\x04\xe6\x053\0W\0\x9f\x02\b\0\xe0\x02 \x003\0\xe4\x02 \0\"\x02\x94\x01_\x02 \0 \0~\0\xea\x02\xa3\x02\xc7\x01\xa4\x02 \0\xeb\x02\xd5\x01\x97\0a\x01b\x01c\x01 \0\xd8\0.\x02\xd5\x01\x97\0\x94\x02\x94\x02L\x01\xd5\x01\xbf\0\x96\x02\x95\x02 \0\x95\x02 \0\xcd\x04 \0 \0\x97\0\xdc\x01\x97\0\xd5\x01\x97\0\xd5\x01\xd5\x01e\x01f\x01\xc7\x01 \0\x97\x02\x9a\x02 \0\xb0\0\x97\0W\x04 \0\xd5\x01\x9b\x02h\x01i\x01j\x01k\x01\x9c\x02\xaf\0\xaf\0\xd9\x01\xaf\0\xaf\0\x98\x02\xaf\0\x9b\x02\x86\x02\xb0\0\x97\0\xa8\x01m\x01\xd5\x01\x97\0\xb5\x04\xaf\0\xaf\0F\x05\xd5\x01\xd5\x01\xd5\x01\xe5\x04\x86\x02\x86\x02\xe2\x04\x96\x02\xd5\x01\xa7\x05\x93\x05}\x05\xae\x02k\x04\xc9\x03\xd5\x01\x89\0\x86\x02\x8a\0\x8b\0 \0W\x04\x8c\0V\x03\xac\x02\xb1\x01\x8e\0\xaf\0\xaf\0\x92\x02\xe4\x02\xd5\x01\xd8\0\x97\0\x97\0W\x03q\x04\x86\x025\x03\xa5\x03\x86\x02\xe0\x01\xe6\x04\xd5\x01\x9b\x01\x86\x02\xd5\x01\f\x04\xd8\x05/\x05\xb9\x04\x86\x02\x91\0k\x05\xcc\x02\x97\0\0\0\xa8\0\x86\x02\x92\x004\x05\xcd\x04\xb2\0\x94\x03\0\0\0\0\xc2\0M\x02\0\0\0\0M\x02\x93\0\x94\0\0\0\x86\x02\x86\x02\0\0K\x04\x97\0\0\0M\x02\0\0\0\0\xc2\0M\x02\0\0\x86\x02\xb0\0\0\0}\x02\x97\0\0\0\0\0M\x02M\x02M\x02M\x02\x97\0\0\0\x97\0\0\0\0\0\0\0\xc2\0W\x04\0\0K\x04\x97\0M\x02\xb0\0\0\0\0\0\0\0\0\0W\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb0\0\xd8\0M\x02\0\0\0\0M\x02\0\0}\x02M\x02M\x02M\x02\x97\0\xc2\0\0\0\xc2\0\xc2\0M\x02\0\0\xc7\x01\0\0\0\0T\x02\0\0M\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x97\0\0\0\0\0\0\0M\x02\0\0M\x02\x9c\x01M\x02M\x02\0\0\x9c\x01\x97\0\0\0\xb0\0\x9c\x01\0\0\x9c\x01\0\0F\x03M\x02\x9c\x01\xe0\x02M\x02K\x03\x9c\x01\x97\0M\x02\x97\0\xaf\0\0\0\0\0\0\0\0\0\x9c\x01\0\0\0\0\x97\0\0\0\0\0\0\0\xe0\x02\xd9\x01\0\0\x03\x01\0\0\0\0\0\0\xe0\x02K\x04\x97\0\0\0\0\0\0\0\0\0W\x04\0\0\0\0\0\0K\x04\xb2\0\xd6\x01\0\0\xb2\0\xb2\0\0\0\xb2\0]\x03\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\xb0\0\0\0\xb2\0\xb2\0\0\0\0\0\0\0\x9c\x01\xab\x02\xe0\x02\0\0\0\0\xc2\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\x9c\x01\x9c\x01\x81\x03\x9c\x01\x9c\x01\0\0\xb2\0\xd6\x01\0\0\0\0\0\0\0\0K\x04\0\0\x97\0\xcd\x04\xc2\0\0\0\0\0\0\0\0\0\0\0\x9c\x01\0\0\0\0\0\0\xc7\x01\0\0\0\0\0\0\xaf\0\0\0\x97\0\0\0\x97\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x97\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa8\0\0\0\0\0\xa8\0\0\0\0\0\0\0K\x04\xaf\0\xaf\0\xaf\0\x97\0\x97\0\xa8\0\0\0\0\0\xaf\0\0\0\x97\0\xbe\0\0\0\0\0\x97\0\xd9\x01\0\0\0\0\xa8\0\xa8\0\xa8\0\xa8\0\0\0\xaf\0\0\0\0\0\xe0\x02\x97\0\xc2\0\xc1\x03\xbe\0\xaf\0\xaf\0\xa8\0\x97\0\0\0\xaf\0\xbe\0\xaf\0\0\0\x97\0\0\0\0\0\0\0\x97\0\0\0\xd8\0\0\0\xc2\0\x97\0\x97\0\xd9\x01\0\0\xa8\0\0\0\xd9\x01\0\0\0\0\xbe\0\0\0\xa8\0\xa8\0\0\0\0\0\xaf\0{\x01\0\0\xa8\0\0\0\0\0\0\0\xaf\0\xbe\0\n\0\xa8\0\xb0\x01\0\0\0\0\0\0\xbe\0\xbe\0\0\0\xbe\0\0\0\0\0\xde\x03\0\0\xd8\0\xa8\0\0\0\xa8\0\xaf\0\0\0\0\0\0\0\0\0\xe4\x03\0\0\xe6\x03\0\0\0\0\xb2\0\xa8\0\0\0\0\0\xa8\0\xdc\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc2\0\xc2\0\0\0\0\0\xc2\0\0\0\xc2\0\0\0\x89\0\xbe\0\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\0\0\xb1\x01\x8e\0\0\0\r\x04\x03\x01\0\0\xaf\0\x03\x01\0\0\0\0\0\0\0\0\x03\x01\0\0\x03\x01\0\0\0\0\x03\x01\x03\x01\0\0\x03\x01\x03\x01\x03\x01\x03\x01\x03\x01\x03\x01!\x04\x91\0\x03\x01\x03\x01\x03\x01%\x04\x03\x01\x03\x01\x92\0\0\0\0\0\0\0~\x03\0\0\0\0\x03\x01\0\0\0\0\x03\x01\x03\x01\x93\0\x94\0\0\0\0\0\0\0\x03\x01\x03\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd5\x01\0\0\0\0\x03\x01\0\0\0\0\x03\x01\0\0\xb2\0\0\0\x03\x01\x03\x01\0\0\x03\x01\0\0\0\0\x03\x01\x03\x01\0\0\0\0\0\0\0\0\0\0\xaf\0\x03\x01\\\x04\xd9\x01\xaf\0\0\0\0\0a\x04\0\0\0\0\0\0\0\0\x03\x01\x03\x01\0\0\x03\x01\x03\x01\x03\x01\x03\x01\xb2\0\xb2\0\xb2\0\0\0\0\0\x03\x01\0\0\x03\x01\xb2\0\0\0\x03\x01\0\0\0\0\x03\x01\0\0\0\0\xaf\0\x03\x01\0\0\0\0\0\0\0\0\0\0\xfa\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd6\x01\xb2\0\xaf\0\0\0\x8d\x04\xd6\x01\0\0\xb2\0\0\0\0\0\xaf\0\0\0\xaf\0\0\0\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\xd8\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0M\x02\xb2\0\0\0\xe0\x02\0\0\0\0\0\0\0\0\xb2\0\xe0\x02\xe0\x02\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\xdd\x03\0\0\xba\x04{\x01\0\0\xe0\x02\0\0{\x01\xbd\x04\xb2\0\0\0{\x01\xe0\x02{\x01\0\0\0\0\0\0{\x01\0\0\0\0\0\0{\x01\0\0\0\0\xc2\0\xe0\x02\xe0\x02\0\0\xe0\x02\0\0{\x01\0\0\0\0\xe0\x02\xe0\x02\0\0\xe0\x02\0\0\xd8\0\xe0\x02\0\0\0\0\0\0\0\0\xaf\0\xaf\0\xe0\x02\0\0\0\0\0\0\xb3\0\0\0\0\0\0\0\xc3\0\0\0\xd6\x01\0\0\xe0\x02\0\0\0\0\0\0\xe0\x02\xd8\0\0\0\0\0\x1b\x04\0\0\0\0\xe7\x04{\x01\xc3\0\0\0\0\0\xe0\x02\0\0\0\0{\x01\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc3\0\0\0\0\0\0\0\0\0{\x01{\x01\0\0{\x01{\x01\xc7\x01\0\0\xfb\x04\0\0\xfd\x04\0\0\x01\x05\0\0\0\0\x06\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0{\x01\xaf\0\0\0\0\0\0\0\0\0\0\0\x0f\x05\xc3\0\0\0\xc3\0\xc3\0\0\0\0\0\xd5\x01\0\0\xc7\x01\xb2\0\xaf\0\0\0\0\0\xb2\0\0\0\0\0\x1e\x05\x1f\x05\0\0\xd5\x01\0\0E\x04$\x05\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\xaf\0F\x04G\x04\xd5\x01\0\0\xd5\x01\xd5\x01\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\xd6\x01H\x04\0\0\xd5\x01I\x04\xaf\x006\x05\0\0\0\0\xd8\0\xb2\x01\0\0J\x04\x91\0\0\0\0\0\0\0\xb2\0\0\0\0\0\x92\0\xaf\0\0\0\xd5\x01\0\0\xb2\0\0\0\xd6\x01\0\0\xd5\x01\xd5\x01\xd5\x01\x93\0\x94\0\0\0\xb3\0\xd7\x01\xd5\x01\xb3\0\xb3\0\0\0\xb3\0\0\0\0\0\xd5\x01\xb5\0\0\0\0\0\xaf\0\0\0\0\0\xb3\0\xb3\0\0\0\xcf\0\0\0\0\0\0\0\0\0\0\0\xd5\x01\xc3\0\0\0\xd9\x01\0\0\0\0\0\0M\x02\0\0\0\0M\x02\0\0\xd5\x01\0\0i\x05\xd5\x01\0\0\0\0\0\0\0\0M\x02\xb3\0\xd7\x01\0\0M\x02\xd9\x01\0\0\0\0p\x05~\x02\0\0\xc3\0\0\0M\x02M\x02M\x02M\x02\x8a\x02\0\0\0\0\0\0\0\0v\x05\0\0\0\0x\x05\0\0\0\0M\x02\0\0\xb2\0\xd6\x01\0\0\0\0\0\0\0\x009\x03\xaf\0\0\0\xc7\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0M\x02\0\0\0\0M\x02\0\0~\x02M\x02M\x02M\x02\xaf\0\x9c\x01\0\0\0\0\x8f\x05M\x02\0\0\0\0\0\0\0\0\0\0\0\0M\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf2\x01M\x02\0\0M\x02\0\0M\x02M\x02\xc3\0\xc7\x01\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0M\x02\x8c\0\x97\x01M\x02\x8d\0\x8e\0\0\0M\x02\xb2\0\0\0\xc3\0\xb0\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8f\0\xb5\0\xb5\0\xd6\x01\xb5\0\xb5\0\0\0\xb5\0\x90\0\x90\x03\0\0\0\0\0\0\0\0\0\0\0\0\x92\0\xb5\0\xb5\0\0\0\0\0\0\0\xb2\0\0\0\xc6\x05\xc7\x05\0\0\x05\x04\x93\0\x94\0\xb4\0\0\0\xce\x059\x03\0\0\xaf\0\0\0\0\0\0\0\0\0\0\0\xb3\0\xb2\0\0\0\0\0\0\0\0\0\xb5\0\xb5\0\x0e\0\0\0\0\0\xc7\x01\xe2\x02\0\0\xc3\0\xc3\0\xaf\0\xb2\0\xc3\0\0\0\xc3\0\xc7\x01\0\0\x0f\0\x10\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xaf\0\0\0\0\0\x17\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe7\x05\0\0\xd6\x01\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\xe2\x02\x8c\0\0\0!\0\x8d\0\x8e\0S\x01\0\0\xf1\x01\0\0\0\0%\0\xb2\x01\0\0\0\0\0\0\0\0)\0\0\0\xb2\x01\xe2\x02\xb2\x01\x8f\0\xe2\x02-\0\xaf\0\0\0\xe2\x02\xe2\x02\0\0\x90\0\x91\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\x92\0\0\x001\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\xb3\0\0\0\x93\0\x94\x005\0\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\xd6\x01\0\0\0\0\0\0\0\0\0\0\xc7\x01\xc2\0\xc7\x01\xe2\x02\0\0\0\0\xe2\x02\x8a\x02\0\0\0\0\0\0\0\0\0\0\0\0\xd6\x01\0\0\xb3\0\xb3\0\xb3\0\xaf\0\0\0f\x02\x8a\x02\x8a\x02\xb3\0\xb4\0\xb4\0\0\0\xb4\0\xb4\0\0\0\xb4\0\0\0\0\0\xaf\0\x8a\x02\0\0\0\0\0\0\0\0\0\0\xb4\0\xb4\0\0\0\0\0k\0\x80\x02\xd7\x01\xb3\0\0\0\0\0\0\0\xd7\x01\0\0\xb3\0\x8a\x02\n\0\xf2\x01\x8a\x02\0\0\xf2\x01\0\0\0\0\x8a\x02\0\0\0\0\0\0\0\0\0\0\x8a\x02\xf2\x01\xb4\0\xb4\0\0\0\0\0\0\0\x8a\x02\0\0\0\0\0\0\xb3\0\0\0\0\0\xf2\x01\xf2\x01\xf2\x01\xf2\x01\xb3\0\0\0\0\0\xaf\0\0\0\x8a\x02\x8a\x02\0\0\0\0\0\0\0\0\xf2\x01\0\0\0\0\0\0\0\0\0\0\x8a\x02\0\0\x89\0\xb3\0\x8a\0\x8b\0 \0\xb2\0\x8c\0\0\0\0\0\xb1\x01\x8e\0\0\0\xf2\x01\0\0\0\0\xf2\x01\xc3\0\x97\x01\xf2\x01\xf2\x01\xf2\x01\0\0\0\0\0\0\0\0\0\0\xf2\x01\xd6\x01\0\0Z\x01\0\0\0\0\0\0\xf2\x01\xc2\0\0\0\x91\0\0\0\0\0\0\0\0\0\xb5\0\0\0\x92\0\xd6\x01\xf2\x01\0\0\xf2\x01\xd7\x01\xf2\x01\xf2\x01\0\0\0\0\0\0\0\0\x93\0\x94\0`\x01a\x01b\x01c\x01\xf2\x01\0\0\0\0\xf2\x01\0\0\x97\x01\0\0\xf2\x01\0\0\0\0\0\0\0\0\0\0\xdc\x02\xb5\0\xb5\0\xb5\0\xc8\x02\0\0\0\0\xb9\0\0\0\xb5\0\0\0;\x03e\x01f\x01\0\0\xd6\x01\0\0\0\0\xf1\x01\0\0\0\0\xf1\x01\0\0\0\0\0\0h\x01i\x01j\x01k\x01\xb2\x01\xe0\x02\xf1\x01\xb5\0\xb5\0\0\0\0\0\0\0\xb5\0\0\0\xb5\0\0\0\0\0m\x01\0\0\xf1\x01\xf1\x01\xf1\x01\xf1\x01\0\0\0\0\xb4\0f\x02\0\0\xb3\0\0\0\0\0\0\0\xb3\0\0\0\xf1\x01\0\0\0\0\0\0\0\0\0\0\xb5\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\x80\x02\x8c\0\0\0\xd6\x01\x8d\0\x8e\0\0\0\xf1\x01\0\0\0\0\xf1\x01\0\0\0\0\xf1\x01\xf1\x01\xf1\x01\xd7\x01\0\0\xa1\x05\0\0\xb5\0\xf1\x01\x8f\0\0\0\0\0\xef\x01\0\0\0\0\xf1\x01\0\0\x90\0\x91\0\0\0\xb3\0\0\0\0\0\0\0\0\0\x92\0\0\0\xf1\x01\xb3\0\xf1\x01\xd7\x01\xf1\x01\xf1\x01\0\0\xa1\x02\0\0k\0\x93\0\x94\0\0\0\0\0\0\0\0\0\xf1\x01\0\0\0\0\xf1\x01\x97\x01\0\0k\0\xf1\x01\0\0\0\0\0\0\xb5\0\0\0\0\0\0\0\0\0\0\0\0\0\xc2\x05k\0\0\0k\0k\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\x02\0\0\xa1\x02\xa1\x02\xa1\x02\\\0\xa1\x02\0\0\0\0\xa1\x02\xa1\x02\0\0\0\0k\0\0\0\0\0\xb4\0\xb4\0\xb4\0\0\0k\0k\0\0\0\0\0\xb4\0\xb4\0\0\0k\0\0\0\xb3\0\xd7\x01\0\0\0\0\0\0k\0\0\0\xa1\x02\0\0\0\0\0\0\xae\x03\0\0\0\0\xa1\x02\0\0\0\0\x97\x01\xb4\0\xb4\0\xb5\0k\0\0\0\xb4\0\xb5\0\xb4\0\xa1\x02\xa1\x02\0\0\0\0\0\0\0\0\0\0k\0\0\0\0\0k\0\0\0\0\0\0\0\xb2\x01\0\0\0\0\0\0\0\0,\x04\0\0\0\0\xe7\0\xe7\0\0\0\xb4\0\0\0\0\0\0\0\xb5\0\0\0\0\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\xb5\0\x8c\0\0\0\xb3\0\x8d\0\x8e\0\xb4\0\0\0\xb5\0\0\0\xb5\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\0\0\xe0\x02\xd7\x01\0\0\x8f\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\x90\0\x91\0\0\0\x8a\x01\x8b\x01\0\0\0\0\0\0\x92\0\xb3\0\0\0\0\0\xe0\x02\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\x93\0\x94\0\0\0\xb4\0\0\0\0\0\0\0\xe0\x02\0\0\xb3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x97\x01\0\0\0\0\0\0\0\0\0\0\xb3\0\xfd\x01\xe0\x02\0\0\0\0\0\0\0\0\0\0\xef\x01\0\0\xe0\x02\xef\x01\0\0\0\0\0\0\0\0\xe0\x02\0\0\xb5\0\xb5\0\0\0\xef\x01\x97\x01\xe0\x02\0\0\0\0\0\0\xd7\x01\0\0\0\0\0\0\0\0\x97\x01\0\0\xef\x01\xef\x01\xef\x01\xef\x01\0\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xef\x01\0\0\xe0\x02\0\0\0\0\xe0\x02\0\0f\x02\xb4\0\xc2\x04\0\0\0\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xef\x01\0\0\0\0\xef\x01\0\0\0\0\xef\x01\xef\x01\xef\x01\0\0\x97\x01\0\0\0\0\xb2\x01\xef\x01\n\0\\\0\xb0\x01\0\0\0\0\0\0\xef\x01\x97\x01\xb4\0\xb5\0\0\0\0\0\xd7\x01\0\0\\\0\x97\x01\0\0\0\0\xef\x01\xc3\0\xef\x01\0\0\xef\x01\xef\x01\0\0\xb4\0\xb5\0\\\0\0\0\\\0\\\0\0\0\xd7\x01\xb4\0\xef\x01\xb4\0\0\0\xef\x01\0\0\0\0\0\0\xef\x01\\\0\0\0\0\0\xb5\0\0\0\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\x97\x01\x8c\0\0\0\0\0\x8d\0\x8e\0\0\0\\\0\0\0\0\0\xb5\0\0\0\0\0Q\x04\0\0\\\0\0\0\0\0\0\0\0\0\0\0\\\0\x8f\0\0\0\0\0\0\0\xb5\0\0\0\\\0\0\0\x90\0\x91\0\x06\x01\0\0\0\0\0\0\0\0\x97\x01\x92\0\0\0\x97\x01\x97\x01\0\0\0\0\\\0\0\0\0\0\0\0\0\0\0\0\x93\0\x94\0\0\0\xb5\0\0\0\0\0\\\0\0\0\0\0\\\0\0\0\0\0\0\0\xb4\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb3\0g\x02h\x02i\x02j\x02k\x02l\x02m\x02n\x02o\x02p\x02q\x02r\x02s\x02t\x02u\x02v\x02w\x02x\x02y\x02z\x02{\x02\xd7\x01}\x02\0\0\0\0\0\0\0\0\0\0\xc3\0\0\0\0\0\0\0Q\x04\0\0\0\0\0\0\x87\x02\0\0\xd7\x01\0\0\0\0\0\0\0\0\xfd\x01\x97\x01\xfd\x01\xfd\x01\xb5\0\x94\x02\0\0\0\0\xfd\x01\0\0\0\0\0\0\0\0\xfd\x01\0\0\0\0\0\0\xfd\x01\xfd\x01\xfd\x01\xb4\0\0\0\0\0\0\0\xb5\0\0\0\xfd\x01\xfd\x01\xfd\x01\xfd\x01\0\0\0\0\xcf\x04\0\0\0\0\0\0\xfd\x01\xb4\0\0\0\0\0\xd7\x01\xfd\x01\0\0\0\0\0\0\0\0\0\0\xfd\x01\xfd\x01\0\0\0\0\0\0\0\0\r\x01\0\0\0\0\xb4\0\0\0\0\0\0\0\0\0\xfd\x01\0\0\0\0\xfd\x01\0\0\0\0\xfd\x01\xfd\x01\xfd\x01\0\0\xfd\x01\0\0\0\0\0\0\xfd\x01\xb4\0\0\0\0\0\0\0\0\0\0\0\xfd\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb4\0\xfd\x01\xfd\x01\0\0\xfd\x01\xfd\x01\xfd\x01\xfd\x01\xd7\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfd\x01\0\0\0\0\xfd\x01\0\0\0\0\0\0\xfd\x01\0\0\xb4\0\0\0\xb5\0\0\0\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\x97\x01\x8c\0\0\0\0\0\x8d\0\x8e\0\0\0\0\0\0\0\xcf\x04\0\0\0\0\xb5\0\0\0%\x05&\x05\0\0\0\0\0\0\0\0\0\0\0\0\x8f\0\0\0\0\0Q\x04\0\0\0\0\x19\x03\xb5\0\x90\0\x91\0\0\0\0\0\0\0\0\0\0\0#\x03\x92\0\x06\x01\0\0%\x03\x06\x01\0\0)\x03\0\0\0\0\x06\x01\0\0\x06\x01\x93\0\x94\0\x06\x01\x06\x01Q\x04\0\0\x06\x01\xb4\0\x06\x01\x06\x01\x06\x01\0\0\0\0\x06\x01\x06\x01\x06\x01O\x02\x06\x01\x06\x01\0\0\0\0\0\0\0\0\0\0\xb5\0\0\0\x06\x01\xb4\0\x97\x01\x06\x01\x06\x01\0\0\0\0\0\0\0\0\0\0\x06\x01\x06\x01\0\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\x06\x01\0\0\0\0\x06\x01\0\0\0\0\0\0\x06\x01\x06\x01\0\0\x06\x01\0\0\0\0\x06\x01\x06\x01\0\0\0\0\0\0\0\0\0\0\0\0\x06\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0j\x03\x06\x01\x06\x01\xb5\0\x06\x01\x06\x01\x06\x01\x06\x01\0\0\0\0\0\0\0\0\0\0\x06\x01\0\0\x06\x01\xcf\x04\0\0\x06\x01\0\0\0\0\x06\x01\0\0Q\x04\0\0\x06\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0Q\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x89\0\xb4\0\x8a\0\x8b\0 \0\r\x01\x8c\0\0\0\r\x01\x8d\0\x8e\0\0\0\0\0\r\x01\0\0\r\x01\0\0r\x02\r\x01\r\x01\0\0\0\0\r\x01\xb4\0\r\x01\r\x01\r\x01\x8f\0\0\0\r\x01\r\x01\r\x01\0\0\r\x01\r\x01\x90\0\x90\x03\0\0\0\0\0\0\xb4\0\0\0\r\x01\x92\0Q\x04\r\x01\r\x01\xcf\x04\0\0\0\0\0\0\0\0\r\x01\r\x01\xb1\x03\x93\0\x94\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\r\x01\0\0\0\0\r\x01\0\0\0\0\0\0\r\x01\r\x01\0\0\r\x01\0\0\0\0\r\x01\r\x01\0\0\0\0\0\0\0\0\xb4\0\0\0\r\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0Q\x04\xd0\x03\0\0\r\x01\r\x01\0\0\r\x01\r\x01\r\x01\r\x01\0\0\0\0\0\0\0\0\0\0\r\x01\0\0\r\x01\0\0\0\0\r\x01\0\0\0\0\r\x01\0\0\0\0\0\0\r\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xdf\x03\0\0\0\0\0\0\0\0\0\0\0\0\xe0\0\0\0\0\0\0\0\0\0\0\0\xb4\0\0\0\0\0\0\0O\x02O\x02O\x02O\x02\0\0\0\0O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02\0\0O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02\0\0\0\0\0\0\0\0O\x02O\x02\0\0\x16\x04O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02\0\0O\x02O\x02O\x02O\x02\0\0\0\0O\x02O\x02O\x02:\x02O\x02O\x02O\x02O\x02O\x02O\x02\0\0O\x02O\x02O\x02O\x02O\x02\0\0O\x02O\x02\0\0\0\0\0\0O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02\0\0O\x02\0\0O\x02O\x02\0\0O\x02O\x02O\x02O\x02O\x02\0\0O\x02O\x02\0\0O\x02O\x02O\x02O\x02\x1d\x01O\x02O\x02\0\0O\x02\0\0\0\0\0\0O\x02\0\0\0\0\0\0\0\0\0\0\0\0r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02\0\0z\x04r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02\0\0\0\0\0\0\0\0r\x02r\x02\0\0\0\0r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02r\x02r\x02\0\0\0\0r\x02r\x02r\x02\0\0r\x02r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02\0\0\0\0\0\0r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02\0\0r\x02\0\0r\x02r\x02\0\0r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02<\x01r\x02r\x02r\x02r\x02\0\0r\x02r\x02\0\0r\x02\0\0\0\0\0\0r\x02\0\0\0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\0\xe0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\xf1\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\0\xe0\0\0\0\xe0\0\xf8\x04\0\0\xe0\0\xe0\0\xe0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\xe0\0\xe0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0$\x01\0\0\xe0\0\0\0\0\0\xe0\0\0\0\xe0\0\0\0\0\0\xe0\0\0\0\0\0\xe0\0!\x05\"\x05#\x05\xe0\0\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\0\0\0\0\0\0\x1d\x01\x1d\x01\0\0\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\0\0\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\0\0\0\0\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\0\0\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\"\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\0\0\x1d\x01\0\0\0\0\0\0\x1d\x01\0\0<\x01<\x01<\x01<\x01<\x01\0\0<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01\0\0\0\0<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01\0\0\0\0\0\0\0\0<\x01<\x01\0\0\0\0<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01\0\0<\x01<\x01<\x01<\x01\0\0\0\0<\x01<\x01<\x01\0\0<\x01<\x01<\x01<\x01<\x01<\x01\0\0<\x01<\x01<\x01<\x01<\x01\0\0<\x01<\x01\0\0\0\0\0\0<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01\0\0<\x01\0\0<\x01<\x01\0\0<\x01<\x01<\x01<\x01<\x01 \x01<\x01<\x01\0\0<\x01<\x01<\x01<\x01\0\0<\x01<\x01\0\0<\x01\0\0\0\0\0\0<\x01$\x01$\x01$\x01$\x01\0\0\0\0$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01\0\0$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01\0\0\0\0\0\0\0\0$\x01$\x01\0\0\0\0$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01\0\0$\x01$\x01$\x01$\x01\0\0\0\0$\x01$\x01$\x01\0\0$\x01$\x01$\x01$\x01$\x01$\x01\0\0$\x01$\x01$\x01$\x01$\x01\0\0$\x01$\x01\0\0\0\0\0\0$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01\0\0$\x01\0\0$\x01$\x01\0\0$\x01$\x01$\x01$\x01$\x01E\x01$\x01$\x01\0\0$\x01$\x01$\x01$\x01\0\0$\x01$\x01\0\0$\x01\0\0\0\0\0\0$\x01\0\0\0\0\"\x01\"\x01\"\x01\"\x01\0\0\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\0\0\0\0\0\0\"\x01\"\x01\0\0\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\0\0\0\0\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\0\0\0\0\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\0\0\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\"\x01G\x01\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\0\0\"\x01\0\0\0\0\0\0\"\x01\0\0 \x01 \x01 \x01 \x01\0\0\0\0 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01\0\0 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01\0\0\0\0\0\0\0\0 \x01 \x01\0\0\0\0 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01\0\0 \x01 \x01 \x01 \x01\0\0\0\0 \x01 \x01 \x01\0\0 \x01 \x01 \x01 \x01 \x01 \x01\0\0 \x01 \x01 \x01 \x01 \x01\0\0 \x01 \x01\0\0\0\0\0\0 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01\0\0 \x01\0\0 \x01 \x01\0\0 \x01 \x01 \x01 \x01 \x01J\x01 \x01 \x01\0\0 \x01 \x01 \x01 \x01\0\0 \x01 \x01\0\0 \x01\0\0\0\0\0\0 \x01E\x01E\x01E\x01E\x01E\x01\0\0E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01\0\0\0\0E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01\0\0\0\0\0\0\0\0E\x01E\x01\0\0\0\0E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01\0\0E\x01E\x01E\x01E\x01\0\0\0\0E\x01E\x01E\x01\0\0E\x01E\x01E\x01E\x01E\x01E\x01\0\0E\x01E\x01E\x01E\x01E\x01\0\0E\x01E\x01\0\0\0\0\0\0E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01\0\0E\x01\0\0E\x01E\x01\0\0E\x01E\x01E\x01\0\0\0\0\x15\x01E\x01E\x01\0\0E\x01E\x01E\x01E\x01\0\0E\x01E\x01\0\0E\x01\0\0\0\0\0\0E\x01\0\0\0\0G\x01G\x01G\x01G\x01G\x01\0\0G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01\0\0\0\0G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01\0\0\0\0\0\0\0\0G\x01G\x01\0\0\0\0G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01\0\0G\x01G\x01G\x01G\x01\0\0\0\0G\x01G\x01G\x01\0\0G\x01G\x01G\x01G\x01G\x01G\x01\0\0G\x01G\x01G\x01G\x01G\x01\0\0G\x01G\x01\0\0\0\0\0\0G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01\0\0G\x01\0\0G\x01G\x01\0\0G\x01G\x01G\x01\x16\x01\0\0\0\0G\x01G\x01\0\0G\x01G\x01G\x01G\x01\0\0G\x01G\x01\0\0G\x01\0\0\0\0\0\0G\x01\0\0J\x01J\x01J\x01J\x01J\x01\0\0J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01\0\0\0\0J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01\0\0\0\0\0\0\0\0J\x01J\x01\0\0\0\0J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01\0\0J\x01J\x01J\x01J\x01\0\0\0\0J\x01J\x01J\x01\0\0J\x01J\x01J\x01J\x01J\x01J\x01\0\0J\x01J\x01J\x01J\x01J\x01\0\0J\x01J\x01\0\0\0\0\0\0J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01\0\0J\x01\0\0J\x01J\x01\0\0J\x01J\x01J\x01\xdf\0\0\0\0\0J\x01J\x01\0\0J\x01J\x01J\x01J\x01\0\0J\x01J\x01\0\0J\x01\0\0\0\0\0\0J\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\0\0\0\0\0\0\x15\x01\x15\x01\x15\x01\0\0\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\0\0\0\0\0\0\0\0\0\0\x15\x01\x15\x01\0\0\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\0\0\0\0\x15\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15\x01\x15\x01\0\0\x15\x01\0\0\0\0\x15\x01\x15\x01\x15\x01\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\0\0\0\0\0\0\0\0\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\0\0\x15\x01\0\0\x15\x01\x15\x01\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\xea\0\x15\x01\0\0\0\0\x15\x01\x15\x01\x15\x01\0\0\0\0\x15\x01\0\0\0\0\x15\x01\0\0\0\0\0\0\x15\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0\0\0\0\0\x16\x01\x16\x01\x16\x01\0\0\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0\0\0\0\0\0\0\0\0\x16\x01\x16\x01\0\0\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0\0\0\x16\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x01\x16\x01\0\0\x16\x01\0\0\0\0\x16\x01\x16\x01\x16\x01\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0\0\0\0\0\0\0\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0\x16\x01\0\0\x16\x01\x16\x01\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\xeb\0\x16\x01\0\0\0\0\x16\x01\x16\x01\x16\x01\0\0\0\0\x16\x01\0\0\0\0\x16\x01\0\0\0\0\0\0\x16\x01\0\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\xdf\0\xdf\0\xdf\0\0\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\0\0\0\0\xdf\0\xdf\0\0\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xdf\0\xdf\0\0\0\xdf\0\0\0\0\0\xdf\0\xdf\0\xdf\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\0\0\0\0\xdf\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\xdf\0\xdf\0\0\0\xdf\0\xdf\0\xdf\0\0\0\xec\0\0\0\xdf\0\0\0\0\0\xdf\0\0\0\xdf\0\0\0\0\0\xdf\0\0\0\0\0\xdf\0\0\0\0\0\0\0\xdf\0\0\0\0\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\xea\0\xea\0\xea\0\0\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\xea\0\xea\0\xea\0\0\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\0\0\0\0\xea\0\xea\0\0\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xea\0\xea\0\0\0\xea\0\0\0\0\0\xea\0\xea\0\xea\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\0\0\0\0\xea\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\xea\0\xea\0\0\0\xea\0\xea\0\xea\0\xea\0\x0e\x01\0\0\xea\0\0\0\0\0\xea\0\0\0\xea\0\0\0\0\0\xea\0\0\0\0\0\xea\0\0\0\0\0\0\0\xea\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\xeb\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\0\0\xeb\0\0\0\0\0\xeb\0\xeb\0\xeb\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\0\0\xeb\0\xeb\0\xeb\0\0\0\x0f\x01\0\0\xeb\0\0\0\0\0\xeb\0\0\0\xeb\0\0\0\0\0\xeb\0\0\0\0\0\xeb\0\0\0\0\0\0\0\xeb\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\0\0\0\0\xec\0\xec\0\xec\0\0\0\0\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\0\0\0\0\0\0\0\0\xec\0\xec\0\0\0\0\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xec\0\xec\0\0\0\xec\0\0\0\0\0\xec\0\xec\0\xec\0\0\0\xec\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\0\0\0\0\0\0\0\0\xec\0\0\0\xec\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\0\0\0\0\xec\0\xec\0\0\0\xec\0\xec\0\xec\0\0\0\xf6\0\0\0\xec\0\0\0\0\0\xec\0\0\0\xec\0\0\0\0\0\xec\0\0\0\0\0\xec\0\0\0\0\0\0\0\xec\0\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0e\x01\x0e\x01\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0e\x01\x0e\x01\0\0\x0e\x01\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0e\x01\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\0\0\0\0\x0e\x01\x0e\x01\0\0\x0e\x01\x0e\x01\x0e\x01\xf7\0\0\0\0\0\x0e\x01\0\0\0\0\x0e\x01\0\0\x0e\x01\0\0\0\0\x0e\x01\0\0\0\0\x0e\x01\0\0\0\0\0\0\x0e\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\0\0\0\0\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0f\x01\x0f\x01\0\0\0\0\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0f\x01\x0f\x01\0\0\x0f\x01\0\0\0\0\x0f\x01\x0f\x01\x0f\x01\0\0\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0f\x01\0\0\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\0\0\0\0\x0f\x01\x0f\x01\0\0\x0f\x01\x0f\x01\x0f\x01\xfe\0\0\0\0\0\x0f\x01\0\0\0\0\x0f\x01\0\0\x0f\x01\0\0\0\0\x0f\x01\0\0\0\0\x0f\x01\0\0\0\0\0\0\x0f\x01\xf6\0\xf6\0\xf6\0\xf6\0\0\0\0\0\0\0\0\0\xf6\0\xf6\0\xf6\0\0\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\0\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\0\0\0\0\0\0\0\0\0\0\0\0\xf6\0\xf6\0\0\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\0\0\xf6\0\xf6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf6\0\xf6\0\0\0\xf6\0\0\0\0\0\xf6\0\xf6\0\xf6\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\0\0\0\0\0\0\0\0\0\0\0\0\xf6\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\0\0\0\0\0\0\0\0\xf6\0\xf6\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xfd\0\0\0\xf6\0\0\0\0\0\xf6\0\0\0\xf6\0\0\0\0\0\xf6\0\0\0\0\0\xf6\0\0\0\0\0\0\0\xf6\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\0\0\0\0\0\0\xf7\0\xf7\0\xf7\0\0\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\0\0\0\0\0\0\0\0\0\0\xf7\0\xf7\0\0\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\xf7\0\xf7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf7\0\xf7\0\0\0\xf7\0\0\0\0\0\xf7\0\xf7\0\xf7\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\0\0\0\0\0\0\0\0\0\0\xf7\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\0\0\0\0\0\0\xf7\0\xf7\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xe4\0\0\0\xf7\0\0\0\0\0\xf7\0\0\0\xf7\0\0\0\0\0\xf7\0\0\0\0\0\xf7\0\0\0\0\0\0\0\xf7\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\0\0\0\0\0\0\xfe\0\xfe\0\xfe\0\0\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\0\0\0\0\0\0\0\0\0\0\xfe\0\xfe\0\0\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\xfe\0\xfe\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfe\0\xfe\0\0\0\xfe\0\0\0\0\0\xfe\0\xfe\0\xfe\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\0\0\0\0\0\0\0\0\0\0\xfe\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\0\0\0\0\0\0\xfe\0\xfe\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xe7\0\0\0\xfe\0\0\0\0\0\xfe\0\0\0\xfe\0\0\0\0\0\xfe\0\0\0\0\0\xfe\0\0\0\0\0\0\0\xfe\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\0\0\0\0\0\0\xfd\0\xfd\0\xfd\0\0\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\0\0\0\0\0\0\0\0\0\0\xfd\0\xfd\0\0\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\xfd\0\xfd\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfd\0\xfd\0\0\0\xfd\0\0\0\0\0\xfd\0\xfd\0\xfd\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\0\0\0\0\0\0\0\0\0\0\xfd\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\0\0\0\0\0\0\xfd\0\xfd\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xe8\0\0\0\xfd\0\0\0\0\0\xfd\0\0\0\xfd\0\0\0\0\0\xfd\0\0\0\0\0\xfd\0\0\0\0\0\0\0\xfd\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\0\0\0\0\0\0\xe4\0\xe4\0\0\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\0\xe4\0\0\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\0\xe4\0\0\0\xe4\0\0\0\0\0\xe4\0\xe4\0\xe4\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\0\0\0\0\xe4\0\xe4\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xf5\0\0\0\xe4\0\0\0\0\0\xe4\0\0\0\xe4\0\0\0\0\0\xe4\0\0\0\0\0\xe4\0\0\0\0\0\0\0\xe4\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\0\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\0\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\0\0\xe7\0\0\0\0\0\xe7\0\xe7\0\xe7\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\0\0\xe7\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xfb\0\0\0\xe7\0\0\0\0\0\xe7\0\0\0\xe7\0\0\0\0\0\xe7\0\0\0\0\0\xe7\0\0\0\0\0\0\0\xe7\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\0\0\0\0\0\0\xe8\0\xe8\0\0\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\0\0\0\0\0\0\0\0\xe8\0\xe8\0\0\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe8\0\xe8\0\0\0\xe8\0\0\0\0\0\xe8\0\xe8\0\xe8\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\0\0\0\0\0\0\0\0\xe8\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\0\0\0\0\xe8\0\xe8\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xfc\0\0\0\xe8\0\0\0\0\0\xe8\0\0\0\xe8\0\0\0\0\0\xe8\0\0\0\0\0\xe8\0\0\0\0\0\0\0\xe8\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\0\0\0\0\0\0\0\0\xf5\0\xf5\0\xf5\0\0\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\0\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\0\0\0\0\0\0\0\0\0\0\0\0\xf5\0\xf5\0\0\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\0\0\0\0\xf5\0\xf5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf5\0\xf5\0\0\0\xf5\0\0\0\0\0\xf5\0\xf5\0\xf5\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\0\0\0\0\0\0\0\0\0\0\0\0\xf5\0\0\0\xf5\0\0\0\xf5\0\xf5\0\xf5\0\0\0\0\0\0\0\0\0\xf5\0\xf5\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\xf8\0\0\0\0\0\0\0\0\0\xf5\0\0\0\xf5\0\0\0\0\0\xf5\0\0\0\0\0\xf5\0\0\0\0\0\0\0\xf5\0\xfb\0\xfb\0\xfb\0\xfb\0\0\0\0\0\0\0\0\0\xfb\0\xfb\0\xfb\0\0\0\0\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\0\0\0\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\0\0\0\0\0\0\0\0\0\0\0\0\xfb\0\xfb\0\0\0\0\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\0\0\0\0\xfb\0\xfb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfb\0\xfb\0\0\0\xfb\0\0\0\0\0\xfb\0\xfb\0\xfb\0\0\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\0\0\0\0\0\0\0\0\0\0\0\0\xfb\0\0\0\xfb\0\0\0\xfb\0\xfb\0\xfb\0\0\0\0\0\0\0\0\0\xfb\0\xfb\0\0\0\xfb\0\xfb\0\xfb\0\xfb\0\xf9\0\0\0\0\0\0\0\0\0\xfb\0\0\0\xfb\0\0\0\0\0\xfb\0\0\0\0\0\xfb\0\0\0\0\0\0\0\xfb\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\0\0\0\0\0\0\0\0\xfc\0\xfc\0\xfc\0\0\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\0\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\0\0\0\0\0\0\0\0\0\0\0\0\xfc\0\xfc\0\0\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\0\0\0\0\xfc\0\xfc\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfc\0\xfc\0\0\0\xfc\0\0\0\0\0\xfc\0\xfc\0\xfc\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\0\0\0\0\0\0\0\0\0\0\0\0\xfc\0\0\0\xfc\0\0\0\xfc\0\xfc\0\xfc\0\0\0\0\0\0\0\0\0\xfc\0\xfc\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\xfa\0\0\0\0\0\0\0\0\0\xfc\0\0\0\xfc\0\0\0\0\0\xfc\0\0\0\0\0\xfc\0\0\0\0\0\0\0\xfc\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\0\0\0\0\0\0\0\0\xf8\0\xf8\0\xf8\0\0\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\0\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\0\0\0\0\0\0\0\0\0\0\0\0\xf8\0\xf8\0\0\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\0\0\0\0\xf8\0\xf8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf8\0\xf8\0\0\0\xf8\0\0\0\0\0\xf8\0\xf8\0\xf8\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\0\0\0\0\0\0\0\0\0\0\0\0\xf8\0\0\0\xf8\0\0\0\xf8\0\xf8\0\xf8\0\0\0\0\0\0\0\0\0\xf8\0\xf8\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\xcc\0\0\0\0\0\0\0\0\0\xf8\0\0\0\xf8\0\0\0\0\0\xf8\0\0\0\0\0\xf8\0\0\0\0\0\0\0\xf8\0\xf9\0\xf9\0\xf9\0\xf9\0\0\0\0\0\0\0\0\0\xf9\0\xf9\0\xf9\0\0\0\0\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\0\0\0\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\0\0\0\0\0\0\0\0\0\0\0\0\xf9\0\xf9\0\0\0\0\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\0\0\0\0\xf9\0\xf9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf9\0\xf9\0\0\0\xf9\0\0\0\0\0\xf9\0\xf9\0\xf9\0\0\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\0\0\0\0\0\0\0\0\0\0\0\0\xf9\0\0\0\xf9\0\0\0\xf9\0\xf9\0\xf9\0\0\0\0\0\0\0\0\0\xf9\0\xf9\0\0\0\xf9\0\xf9\0\xf9\0\xf9\0\xff\0\0\0\0\0\0\0\0\0\xf9\0\0\0\xf9\0\0\0\0\0\xf9\0\0\0\0\0\xf9\0\0\0\0\0\0\0\xf9\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\0\0\0\0\0\0\0\0\xfa\0\xfa\0\xfa\0\0\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\0\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\0\0\0\0\0\0\0\0\0\0\0\0\xfa\0\xfa\0\0\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\0\0\0\0\xfa\0\xfa\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfa\0\xfa\0\0\0\xfa\0\0\0\0\0\xfa\0\xfa\0\xfa\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\0\0\0\0\0\0\0\0\0\0\0\0\xfa\0\0\0\xfa\0\0\0\xfa\0\xfa\0\xfa\0\0\0\0\0\0\0\0\0\xfa\0\xfa\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\x01\x01\0\0\0\0\0\0\0\0\xfa\0\0\0\xfa\0\0\0\0\0\xfa\0\0\0\0\0\xfa\0\0\0\0\0\0\0\xfa\0\0\0\xcc\0\xcc\0\xcc\0\xcc\0\0\0\0\0\0\0\0\0\xcc\0\xcc\0\xcc\0\0\0\0\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\0\0\0\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\0\0\0\0\0\0\0\0\0\0\0\0\xcc\0\xcc\0\0\0\0\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcc\0\xcc\0\0\0\0\0\0\0\0\0\xcc\0\xcc\0\xcc\0\0\0\xcc\0\0\0\0\0\xcc\0\xcc\0\0\0\0\0\0\0\0\0\0\0\0\0\xcc\0\0\0\xcc\0\xcc\0\0\0\0\0\xcc\0\0\0\0\0\0\0\0\0\xcc\0\xcc\0\0\0\xcc\0\xcc\0\xcc\0\xcc\0\xf3\0\0\0\xcc\0\0\0\0\0\xcc\0\0\0\xcc\0\0\0\0\0\xcc\0\0\0\0\0\xcc\0\0\0\0\0\0\0\xcc\0\xff\0\xff\0\xff\0\xff\0\0\0\0\0\0\0\0\0\xff\0\xff\0\xff\0\0\0\0\0\xff\0\xff\0\0\0\xff\0\xff\0\xff\0\xff\0\xff\0\xff\0\0\0\0\0\xff\0\xff\0\xff\0\xff\0\xff\0\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\0\xff\0\0\0\0\0\xff\0\xff\0\xff\0\0\0\0\0\0\0\0\0\xff\0\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\0\xff\0\0\0\xff\0\0\0\0\0\0\0\xff\0\xff\0\0\0\xff\0\0\0\0\0\xff\0\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\0\0\0\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\0\xff\0\0\0\xff\0\xff\0\xff\0\xff\0\xf4\0\0\0\0\0\0\0\0\0\xff\0\0\0\xff\0\0\0\0\0\xff\0\0\0\0\0\xff\0\0\0\0\0\0\0\xff\0\0\0\x01\x01\x01\x01\x01\x01\x01\x01\0\0\0\0\0\0\0\0\x01\x01\x01\x01\x01\x01\0\0\0\0\x01\x01\x01\x01\0\0\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\0\0\0\0\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\x01\x01\x01\x01\0\0\0\0\x01\x01\x01\x01\x01\x01\0\0\0\0\0\0\0\0\x01\x01\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\x01\x01\x01\0\0\x01\x01\0\0\0\0\0\0\x01\x01\x01\x01\0\0\x01\x01\0\0\0\0\x01\x01\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\x01\x01\0\0\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\x01\x01\x01\0\0\x01\x01\x01\x01\x01\x01\x01\x01\0\x01\0\0\0\0\0\0\0\0\x01\x01\0\0\x01\x01\0\0\0\0\x01\x01\0\0\0\0\x01\x01\0\0\0\0\0\0\x01\x01\0\0\xf3\0\xf3\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\xf3\0\xf3\0\xf3\0\0\0\0\0\xf3\0\xf3\0\0\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\0\0\0\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\0\0\0\0\xf3\0\xf3\0\0\0\0\0\xf3\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf3\0\xf3\0\0\0\xf3\0\0\0\0\0\0\0\xf3\0\xf3\0\0\0\xf3\0\0\0\0\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\0\0\0\0\xf3\0\0\0\xf3\0\0\0\0\0\x05\x01\0\0\0\0\0\0\0\0\0\0\xf3\0\xf3\0\0\0\xf3\0\xf3\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\0\0\xf3\0\0\0\xf3\0\0\0\0\0\xf3\0\0\0\0\0\xf3\0\0\0\0\0\0\0\xf3\0\xf4\0\xf4\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\xf4\0\xf4\0\xf4\0\0\0\0\0\xf4\0\xf4\0\0\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\0\0\0\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\0\0\0\0\xf4\0\xf4\0\0\0\0\0\xf4\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf4\0\xf4\0\0\0\xf4\0\0\0\0\0\0\0\xf4\0\xf4\0\0\0\xf4\0\0\0\0\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\x04\x01\0\0\xf4\0\0\0\xf4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf4\0\xf4\0\0\0\xf4\0\xf4\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\0\0\xf4\0\0\0\xf4\0\0\0\0\0\xf4\0\0\0\0\0\xf4\0\0\0\0\0\0\0\xf4\0\0\0\0\x01\0\x01\0\x01\0\x01\0\0\0\0\0\0\0\0\0\x01\0\x01\0\x01\0\0\0\0\0\x01\0\x01\0\0\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\0\0\0\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\x01\0\0\0\0\0\x01\0\x01\0\x01\0\0\0\0\0\0\0\0\0\x01\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\x01\0\0\0\x01\0\0\0\0d\x01\0\x01\0\x01\0\0\0\x01\0\0\0\0\0\x01\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\x01\0\0\0\x01\0\x01\0\x01\0\x01\0\0\0\0\0\0\0\0\0\0\0\x01\x05\x01\0\x01\0\0\x05\x01\0\x01\0\0\0\0\0\x01\x05\x01\x05\x01\x05\x01\0\x01\0\0\x05\x01\x05\x01\0\0\x05\x01\x05\x01\x05\x01\x05\x01\x05\x01\x05\x01\0\0\0\0\x05\x01\x05\x01\x05\x01\0\0\x05\x01\x05\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x01\0\0\0\0\x05\x01\x05\x01\0\0\0\0\0\0\0\0\0\0\x05\x01\x05\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x01\0\0\0\0\x05\x01\0\0\0\0\x02\x01\x05\x01\x05\x01\0\0\x05\x01\0\0\0\0\x05\x01\x05\x01\0\0\0\0\0\0\0\0\0\0\0\0\x05\x01\0\0\x05\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x01\x05\x01\0\0\x05\x01\x05\x01\x05\x01\x05\x01\0\0\0\0\0\0\0\0\0\0\x05\x01\0\0\x05\x01\0\0\0\0\x05\x01\x04\x01\0\0\x05\x01\x04\x01\0\0\0\0\x05\x01\0\0\x04\x01\x04\x01\x04\x01\0\0\0\0\x04\x01\x04\x01\0\0\x04\x01\x04\x01\x04\x01\x04\x01\x04\x01\x04\x01\0\0\0\0\x04\x01\x04\x01\x04\x01\0\0\x04\x01\x04\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\x01\0\0\0\0\x04\x01\x04\x01\0\0\0\0\0\0\0\0\0\0\x04\x01\x04\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\x01c\x01\0\0\x04\x01\0\0\0\0\0\0\x04\x01\x04\x01\0\0\x04\x01\0\0\0\0\x04\x01\x04\x01\0\0\0\0\0\0\0\0\0\0\0\0\x04\x01\0\0\x04\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\x01\x04\x01\0\0\x04\x01\x04\x01\x04\x01\x04\x01\0\0\0\0\0\0\0\0\0\0\x04\x01d\x01\x04\x01\0\0d\x01\x04\x01\0\0\0\0\x04\x01d\x01\0\0d\x01\x04\x01\0\0d\x01d\x01\0\0d\x01d\x01d\x01d\x01d\x01d\x01\0\0\0\0d\x01d\x01d\x01\0\0d\x01d\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\x01\0\0\0\0d\x01d\x01\0\0\0\0\0\0\0\0\0\0d\x01d\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\t\x01\0\0\0\0\0\0d\x01\0\0\0\0d\x01\0\0\0\0\0\0d\x01d\x01\0\0d\x01\0\0\0\0d\x01d\x01\0\0\0\0\0\0\0\0\0\0\0\0d\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\x01d\x01\0\0d\x01d\x01d\x01d\x01\0\0\0\0\0\0\0\0\0\0d\x01\x02\x01d\x01\0\0\x02\x01d\x01\0\0\0\0d\x01\x02\x01\0\0\x02\x01d\x01\0\0\x02\x01\x02\x01\0\0\x02\x01\x02\x01\x02\x01\x02\x01\x02\x01\x02\x01\0\0\0\0\x02\x01\x02\x01\x02\x01\0\0\x02\x01\x02\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x01\0\0\0\0\x02\x01\x02\x01\0\0\0\0\0\0\0\0\0\0\x02\x01\x02\x01\0\0\0\0\0\0\xed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x01\0\0\0\0\x02\x01\0\0\0\0\0\0\x02\x01\x02\x01\0\0\x02\x01\0\0\0\0\x02\x01\x02\x01\0\0\0\0\0\0\0\0\0\0\0\0\x02\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x01\x02\x01\0\0\x02\x01\x02\x01\x02\x01\x02\x01\0\0\0\0\0\0\0\0\0\0\x02\x01c\x01\x02\x01\0\0c\x01\x02\x01\0\0\0\0\x02\x01c\x01\0\0c\x01\x02\x01\0\0c\x01c\x01\0\0c\x01c\x01c\x01c\x01c\x01c\x01\0\0\0\0c\x01c\x01c\x01\0\0c\x01c\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0c\x01\0\0\0\0c\x01c\x01\0\0\0\0\0\0\0\0\0\0c\x01c\x01\0\0\0\0\0\0\f\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0c\x01\0\0\0\0c\x01\0\0\0\0\0\0c\x01c\x01\0\0c\x01\0\0\0\0c\x01c\x01\0\0\0\0\0\0\0\0\0\0\0\0c\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0c\x01c\x01\0\0c\x01c\x01c\x01c\x01\0\0\t\x01\0\0\0\0\t\x01c\x01\0\0c\x01\0\0\t\x01c\x01\t\x01\0\0c\x01\t\x01\t\x01\0\0c\x01\t\x01\0\0\t\x01\t\x01\t\x01\0\0\0\0\t\x01\t\x01\t\x01\0\0\t\x01\t\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\t\x01\0\0\0\0\t\x01\t\x01\0\0\0\0\0\0\0\0\0\0\t\x01\t\x01\0\0\0\0\0\0\x0b\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\t\x01\0\0\0\0\t\x01\0\0\0\0\0\0\t\x01\t\x01\0\0\t\x01\0\0\0\0\t\x01\t\x01\0\0\0\0\0\0\0\0\0\0\0\0\t\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\t\x01\t\x01\0\0\t\x01\t\x01\t\x01\t\x01\0\0\xed\0\0\0\0\0\xed\0\t\x01\0\0\t\x01\0\0\xed\0\t\x01\xed\0\0\0\t\x01\xed\0\xed\0\0\0\t\x01\xed\0\0\0\xed\0\xed\0\xed\0\0\0\0\0\xed\0\xed\0\xed\0\0\0\xed\0\xed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xed\0\0\0\0\0\xed\0\xed\0\0\0\0\0\0\0\0\0\0\0\xed\0\xed\0\0\0\0\0\0\0\n\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xed\0\0\0\0\0\xed\0\0\0\0\0\0\0\xed\0\xed\0\0\0\xed\0\0\0\0\0\xed\0\xed\0\0\0\0\0\0\0\0\0\0\0\0\0\xed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xed\0\xed\0\0\0\xed\0\xed\0\xed\0\xed\0\0\0\0\0\0\0\0\0\0\0\xed\0\f\x01\xed\0\0\0\f\x01\xed\0\0\0\0\0\xed\0\f\x01\0\0\f\x01\xed\0\0\0\f\x01\f\x01\0\0\0\0\f\x01\0\0\f\x01\f\x01\f\x01\0\0\0\0\f\x01\f\x01\f\x01\0\0\f\x01\f\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\x01\0\0\0\0\f\x01\f\x01\0\0\0\0\0\0\0\0\0\0\f\x01\f\x01\0\0\0\0\0\0\xcb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\x01\0\0\0\0\f\x01\0\0\0\0\0\0\f\x01\f\x01\0\0\f\x01\0\0\0\0\f\x01\f\x01\0\0\0\0\0\0\0\0\0\0\0\0\f\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\x01\f\x01\0\0\f\x01\f\x01\f\x01\f\x01\0\0\x0b\x01\0\0\0\0\x0b\x01\f\x01\0\0\f\x01\0\0\x0b\x01\f\x01\x0b\x01\0\0\f\x01\x0b\x01\x0b\x01\0\0\f\x01\x0b\x01\0\0\x0b\x01\x0b\x01\x0b\x01\0\0\0\0\x0b\x01\x0b\x01\x0b\x01\0\0\x0b\x01\x0b\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0b\x01\0\0\0\0\x0b\x01\x0b\x01\0\0\0\0\0\0\0\0\0\0\x0b\x01\x0b\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0b\x01\0\0y\x02\x0b\x01\0\0\0\0\0\0\x0b\x01\x0b\x01\0\0\x0b\x01t\0\0\0\x0b\x01\x0b\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0b\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0b\x01\x0b\x01\0\0\x0b\x01\x0b\x01\x0b\x01\x0b\x01\0\0\n\x01\0\0\0\0\n\x01\x0b\x01\0\0\x0b\x01\0\0\n\x01\x0b\x01\n\x01\0\0\x0b\x01\n\x01\n\x01\0\0\x0b\x01\n\x01\0\0\n\x01\n\x01\n\x01\0\0\0\0\n\x01\n\x01\n\x01\0\0\n\x01\n\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\x01\0\0\0\0\n\x01\n\x01\0\0\0\0\0\0\0\0\0\0\n\x01\n\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\x01\0\0\0\0\n\x01\0\0\0\0\0\0\n\x01\n\x01\0\0\n\x01\0\0\0\0\n\x01\n\x01\0\0\xee\0\0\0\0\0\0\0\0\0\n\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\x01\n\x01\0\0\n\x01\n\x01\n\x01\n\x01\0\0\0\0\0\0\0\0\0\0\n\x01\xcb\0\n\x01\0\0\xcb\0\n\x01\0\0\0\0\n\x01\xcb\0\0\0\xcb\0\n\x01\0\0\xcb\0\xcb\0\0\0\0\0\xcb\0\0\0\xcb\0\xcb\0\xcb\0\0\0\0\0\xcb\0\xcb\0\xcb\0\0\0\xcb\0\xcb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcb\0\0\0\0\0\xcb\0\xcb\0\0\0\0\0\0\0\0\0\0\0\xcb\0\xcb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcb\0\0\0\0\0\xcb\0\0\0\0\0\0\0\xcb\0\xcb\0\0\0\xcb\0\0\0\0\0\xcb\0\xcb\0\0\0\0\0\0\0\0\0\0\0\0\0\xcb\0,\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcb\0\xcb\0\0\0\xcb\0\0\0\xcb\0\xcb\0\0\0\0\0\0\0\0\0\0\0\xcb\0\0\0\xcb\0\0\0\0\0\xcb\0\0\0y\x02\xcb\0y\x02y\x02y\x02\xcb\0\0\0\0\0y\x02t\0\0\0\0\0\0\0y\x02\0\0\0\0\0\0y\x02y\x02y\x02\0\0\0\0t\0\0\0\0\0\0\0y\x02y\x02y\x02y\x02\0\0\0\0\0\0\0\0\0\0t\0y\x02t\0t\0\0\0\0\0y\x02\0\0\0\0\0\0\0\0\0\0y\x02y\x02\x89\0t\0\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\0\0\xb1\x01\xf3\x02\0\0y\x02\0\0\0\0y\x02y\x02\0\0y\x02y\x02y\x02t\0y\x02\x04\x02t\0y\x02y\x02\0\0t\0t\0\0\0\0\0\0\0y\x02\0\0t\0\x91\0\0\0\0\0\0\0\0\0\0\0t\0\x92\0y\x02y\x02\0\0y\x02y\x02y\x02y\x02\0\0\0\0y\x02t\0\x93\0\x94\0\0\0t\0t\0\0\0y\x02y\x02\0\0y\x02\0\0\xee\0\0\0y\x02\xee\0t\0\0\0\0\0t\0\xee\0\0\0\xee\0\0\0\0\0\xee\0\xee\0\0\0\0\0\xee\0\0\0\xee\0\xee\0\xee\0\0\0\0\0\xee\0\0\0\xee\0\0\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\0\0\0\0\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\0\0\0\0\xee\0\0\0\0\0\xee\0\0\0\0\0\0\0\xee\0\xee\0\0\0\xee\0\0\0\0\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\0\xee\0\0\0\xee\0\xee\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\xee\0\0\0\xee\0\0\0\0\0\xee\0\0\0,\x02\xee\0,\x02,\x02,\x02\xee\0\0\0\0\0,\x02\0\0\0\0\0\0\0\0,\x02\0\0\0\0\0\0,\x02,\x02,\x02\0\0\0\0\0\0\0\0\0\0\0\0,\x02,\x02,\x02,\x02\0\0\0\0\0\0\0\0\0\0\0\0,\x02\0\0\0\0\0\0\0\0,\x02\0\0\0\0\0\0\0\0\0\0,\x02,\x02-\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0,\x02\0\0\0\0,\x02\0\0\0\0,\x02,\x02,\x02\0\0,\x02\0\0\0\0,\x02,\x02\0\0\0\0\0\0\0\0\0\0\0\0,\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0,\x02,\x02\0\0,\x02,\x02,\x02,\x02\0\0\x04\x02\0\0\x04\x02\x04\x02\x04\x02\0\0\0\0\0\0\x04\x02,\x02\0\0\0\0,\x02\x04\x02\0\0\0\0,\x02\x04\x02\x04\x02\x04\x02\0\0\0\0\0\0\0\0\0\0\0\0\x04\x02\x04\x02\x04\x02\x04\x02\0\0\0\0\0\0\0\0\0\0\0\0\x04\x02\0\0\0\0\0\0\0\0\x04\x02\0\0\0\0\0\0\0\0\0\0\x04\x02\x04\x02\x03\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\x02\0\0\0\0\x04\x02\0\0\0\0\x04\x02\x04\x02\x04\x02\0\0\x04\x02\0\0\0\0\x04\x02\x04\x02\0\0\0\0\0\0\0\0\0\0\0\0\x04\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\x02\x04\x02\0\0\x04\x02\x04\x02\x04\x02\0\0\0\0\x05\x02\x04\x02\x05\x02\x05\x02\x05\x02\0\0\0\0\0\0\x05\x02\x04\x02\0\0\0\0\x04\x02\x05\x02\0\0\0\0\x04\x02\x05\x02\x05\x02\x05\x02\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\x05\x02\x05\x02\x05\x02\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\0\0\0\0\0\0\0\0\x05\x02\0\0\0\0\0\0\0\0\0\0\x05\x02\x05\x02\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\0\0\0\0\x05\x02\0\0\0\0\x05\x02\x05\x02\x05\x02\0\0\x05\x02\0\0\0\0\x05\x02\x05\x02\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\x05\x02\0\0\x05\x02\x05\x02\x05\x02\0\0\0\0\0\0\x05\x02-\x02\0\0-\x02-\x02-\x02\0\0\0\0\x05\x02-\x02\0\0\x05\x02\0\0\0\0-\x02\x05\x02\0\0\0\0-\x02-\x02-\x02\0\0\0\0\0\0\0\0\0\0\0\0-\x02-\x02-\x02-\x02\0\0\0\0\0\0\0\0\0\0\0\0-\x02\0\0\0\0\0\0\0\0-\x02\0\0\0\0\0\0\0\0\0\0-\x02-\x02\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0-\x02\0\0\0\0-\x02\0\0\0\0-\x02-\x02-\x02\0\0-\x02\0\0\0\0-\x02-\x02\0\0\0\0\0\0\0\0\0\0\0\0-\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0-\x02-\x02\0\0-\x02-\x02-\x02-\x02\0\0\x03\x02\0\0\x03\x02\x03\x02\x03\x02\0\0\0\0\0\0\x03\x02-\x02\0\0\0\0-\x02\x03\x02\0\0\0\0-\x02\x03\x02\x03\x02\x03\x02\0\0\0\0\0\0\0\0\0\0\0\0\x03\x02\x03\x02\x03\x02\x03\x02\0\0\0\0\0\0\0\0\0\0\0\0\x03\x02\0\0\0\0\0\0\0\0\x03\x02\0\0\0\0\0\0\0\0\0\0\x03\x02\x03\x02\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\x02\0\0\0\0\x03\x02\0\0\0\0\x03\x02\x03\x02\x03\x02\0\0\x03\x02\0\0\0\0\0\0\x03\x02\0\0\0\0\0\0\0\0\0\0\0\0\x03\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\x02\x03\x02\0\0\x03\x02\x03\x02\x03\x02\x03\x02\0\0\x01\x02\0\0\x01\x02\x01\x02\x01\x02\0\0\0\0\xc1\0\x01\x02\x03\x02\0\0\0\0\x03\x02\x01\x02\0\0\0\0\x03\x02\x01\x02\x01\x02\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\x01\x02\x01\x02\x01\x02\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\x01\x02\0\0\0\0\0\0\0\0\x01\x02\0\0\0\0\0\0\0\0\0\0\x01\x02\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0R\0\0\0\0\0\0\0\x01\x02\0\0\0\0\x01\x02\0\0\0\0\x01\x02\x01\x02\x01\x02\0\0\x01\x02\0\0\0\0\0\0\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\x02\x01\x02\0\0\x01\x02\x01\x02\x01\x02\x01\x02\0\0\0\0\0\0\x02\x02\0\0\x02\x02\x02\x02\x02\x02\0\0\0\0\x01\x02\x02\x02\0\0\x01\x02\0\0\0\0\x02\x02\x01\x02\0\0\0\0\x02\x02\x02\x02\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\x02\x02\x02\x02\x02\x02\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\x02\x02\0\0\0\0\0\0\0\0\x02\x02\0\0\0\0\0\0\0\0\0\0\x02\x02\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x02\0\0\0\0\x02\x02\0\0\0\0\x02\x02\x02\x02\x02\x02\xe2\x02\x02\x02\0\0\0\0\0\0\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x02\x02\x02\0\0\x02\x02\x02\x02\x02\x02\x02\x02\0\0\0\x02\0\0\0\x02\0\x02\0\x02\0\0\0\0\0\0\0\x02\x02\x02\0\0\0\0\x02\x02\0\x02\0\0\0\0\x02\x02\0\x02\0\x02\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\x02\0\x02\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\0\0\0\0\0\0\0\0\x02\0\0\0\0\0\0\0\0\0\0\0\x02\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc1\0\0\0\0\x02\xc1\0\0\0\0\x02\0\0\0\0\0\x02\0\x02\0\x02\0\0\0\x02\xc1\0\0\0\0\0\0\x02\0\0\0\0\xc1\0\0\0\0\0\x81\0\0\x02\0\0\0\0\xc1\0\xc1\0\xc1\0\xc1\0\0\0\0\0\0\0\0\0\0\x02\0\x02\0\0\0\x02\0\x02\0\x02\0\x02\xc1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0R\0\0\x02\0\0R\0\0\x02\0\0\0\0\0\0\0\x02\0\0\0\0\xc1\0\0\0R\0\xc1\0\0\0\0\0\0\0\xc1\0\xc1\0\0\0\0\0\0\0\0\0\0\0\xc1\0R\0R\0R\0R\0\0\0\0\0\xc1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0R\0\0\0\0\0\xc1\0\0\0\xc1\0\0\0\xc1\0\xc1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc1\0R\0\0\0\xc1\0R\0\0\0\0\0\xc1\0R\0R\0\0\0\0\0\0\0\0\0\0\0R\0\0\0\0\0\0\0y\0\0\0\0\0R\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0R\0\0\0R\0\0\0R\0R\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0R\0\0\0\0\0R\0\0\0\0\0\xe2\x02R\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xa9\x01\xe2\x02\0\0\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\t\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\x0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0f\0\x10\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\x17\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0!\0\0\0\0\0\"\0#\0$\0\0\0\0\0%\0&\0\0\0'\0(\0\0\0)\0\0\0*\0+\0\0\0,\0r\x02-\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\0z\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\x005\x006\0\t\0\n\0\x0b\0\0\x007\0\0\0\f\0\r\0\x0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0f\0\x10\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\x17\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0!\0\0\0\0\0\"\0#\0$\0\0\0\0\0%\0&\0\0\0'\0(\0\0\0)\0\0\0*\0+\0\0\0,\0\0\0-\0\0\0\0\0\0\0.\0/\0\x87\x010\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0z\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\x005\x006\0\0\0\0\0\0\0\0\x007\0\0\0\0\0\0\0\0\0\t\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\x0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0f\0\x10\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\x17\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0!\0\0\0\0\0\"\0#\0$\0\0\0\0\0%\0&\0\0\0'\0(\0\0\0)\0\0\0*\0+\0\0\0,\0\0\0-\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0z\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\x84\x003\x004\x005\x006\0\0\0\0\0r\x02\0\x007\0\0\0r\x02\0\0r\x02\0\0r\x02\0\0r\x02\0\0r\x02r\x02r\x02r\x02\0\0r\x02r\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0r\x02r\x02r\x02r\x02r\x02r\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0r\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0r\x02r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02\0\0\0\0r\x02r\x02\0\0\0\0r\x02r\x02r\x02r\x02r\x02r\x02\0\0k\x02r\x02\0\0r\x02r\x02\0\0r\x02\0\0\0\0\0\0\0\0r\x02r\x02\0\0\0\0r\x02\0\0\0\0\0\0\0\0r\x02\0\0r\x02r\x02\0\0r\x02r\x02r\x02r\x02\0\0\0\0\0\0r\x02\0\0\0\0r\x02\0\0r\x02\0\0r\x02r\x02r\x02\0\0\x87\x01r\x02\0\0\0\0\x87\x01\0\0\x87\x01\0\0\x87\x01\0\0\x87\x01\0\0\x87\x01\0\0\x87\x01\x87\x01\x85\0\x87\x01\x87\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x87\x01\0\0\0\0\x87\x01\x87\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x87\x01\x87\x01\x87\x01\x87\x01\0\0\x87\x01\0\0\x87\x01\x87\x01\0\0\0\0\x87\x01\0\0\0\0\0\0\0\0\x87\x01\x87\x01\x87\x01\0\0\0\0\0\0\0\0\x87\x01\0\0\x87\x01\x80\0\x82\0\x87\x01\0\0\x82\0\x82\0\0\0\0\0\x87\x01\0\0\0\0\x87\x01\0\0\0\0\x82\0\x82\0\x87\x01\0\0\x87\x01\x87\x01\x82\0\x87\x01\x87\x01\0\0\x87\x01\0\0\0\0\x82\0\x87\x01\x82\0\x82\0\x87\x01\0\0\x87\x01\0\0\0\0\x87\x01\x87\x01\0\0\0\0\x87\x01\0\0\x82\0\0\0\0\0\0\0\0\0\0\0\x82\0\x82\0\x82\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84\0\0\0\x82\0\x84\0\x84\0\x82\0\0\0\0\0\x82\0\x82\0\x82\0\0\0\x82\0\x84\0\x84\0\0\0\x82\0\0\0\0\0\x84\0\0\0\0\0\0\0\x82\0\0\0\0\0\x84\0\0\0\x84\0\x84\0\0\0\0\0\0\0\0\0\0\0\x82\0\0\0\x82\0\0\0\x82\0\x82\0\x84\0\0\0\0\0\0\0\0\0\0\0\x84\0\x84\0\xb2\0\0\0\x82\0\0\0\0\0\x82\0\0\0\0\0\0\0\0\0\0\0\0\0\x84\0\0\0\0\0\x84\0\0\0\0\0\x84\0\x84\0\x84\0\0\0\x84\0\0\0\0\0\0\0\x84\0\0\0\0\0k\x02\0\0\0\0k\x02\x84\0\0\0\0\0\0\0k\x02\0\0\0\0\0\0\0\0k\x02k\x02\0\0\x84\0\0\0\x84\0k\x02\x84\0\x84\0}\x02\0\0\0\0\0\0k\x02\0\0k\x02k\x02\x83\x02\0\0\x84\0\0\0\0\0\x84\0\0\0\0\0\0\0\0\0\x89\0k\x02\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\0\0\xb1\x01G\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85\0\0\0k\x02\x85\0\x85\0k\x02\0\0}\x02k\x02k\x02k\x02\0\0\0\0\x85\0\x85\0\0\0k\x02\x91\0\0\0\x85\0\0\0\0\0k\x02k\x02\x92\0\0\0\x85\0\0\0\x85\0\x85\0\0\0\xe0\x02\0\0\0\0\0\0k\x02\x93\0\x94\0\0\0k\x02k\x02\x85\0\0\0\0\0\0\0\0\0\0\0\x85\0\x85\0\0\0\0\0k\x02\0\0\0\0k\x02\0\0\0\0\0\0\0\0\x80\0\0\0\x85\0\x80\0\x80\0\x85\0\0\0\0\0\0\0\x85\0\x85\0\0\0\x85\0\x80\0\x80\0\0\0\x85\0\0\0\0\0\x80\0\0\0\0\0\0\0\x85\0\0\0\0\0\x80\0\xd8\x01\x80\0\x80\0\0\0\0\0\0\0\0\0\0\0\x85\0\0\0\x85\0\0\0\x85\0\x85\0\x80\0\0\0\0\0\0\0\0\0\0\0\x80\0\x80\0\0\0\x82\x02\x85\0\0\0\x82\x02\x85\0\0\0\0\0\0\0\0\0\0\0\0\0\x80\0\0\0\x82\x02\x80\0\0\0\0\0\0\0\x80\0\x80\0\0\0\x80\0\0\0\0\0\0\0\x80\0\x82\x02\x82\x02\x82\x02\x82\x02\0\0\0\0\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x02\0\0\0\0\x80\0\0\0\x80\0\0\0\x80\0\x80\0\0\0\0\0\0\0\x06\x02\0\0\0\0\0\0\0\0\0\0\xb2\0\x80\0\x82\x02\xb2\0\x80\0\0\0y\x02\0\0\x82\x02\x82\x02\x82\x02\x06\x02\0\0\xb2\0\0\0y\x02\x82\x02\0\0\0\0\0\0\0\0\0\0\0\0\x82\x02\0\0\0\0\xb2\0\xb2\0\xb2\0\xb2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x02\0\0\x82\x02y\x02\xb2\0\0\0y\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x02y\x02\0\0\x82\x02\0\0\0\0\0\0\0\0\x83\x02\0\0\xb2\0\x83\x02\0\0\0\0\x1a\x02\0\0\xb2\0\xb2\0\xb2\0\0\0\0\0\x83\x02\0\0\x1a\x02\xb2\0\0\0\0\0\0\0\0\0\0\0\0\0\xb2\0\0\0\0\0\x83\x02\x83\x02\x83\x02\x83\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb2\0\0\0\xb2\0\x1a\x02\x83\x02\0\0\x1a\x02\x07\x02\0\0\0\0\0\0\0\0\0\0\0\0\xb2\0\x1a\x02\0\0\xb2\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\x83\x02\0\0\xe0\x02\0\0z\x02\0\0\x83\x02\x83\x02\x83\x02\0\0\0\0\0\0\xe0\x02z\x02\x83\x02\0\0\0\0\0\0\xe0\x02\0\0\0\0\x83\x02\0\0\0\0\0\0\xe0\x02\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\x83\x02\0\0\x83\x02z\x02\xe0\x02\xe0\x02z\x02\0\0\0\0\0\0\0\0\xe0\x02\xe0\x02\0\0\x83\x02z\x02\0\0\x83\x02\0\0\xd8\x01\0\0\0\0\xd8\x01\0\0\0\0\xe0\x02\x07\x02\xd8\x01\xe0\x02\0\0\0\0\0\0\xd8\x01\xe0\x02\0\0\xe0\x02f\0\0\0\xd8\x01\xe0\x02\0\0\0\0\0\0\0\0\0\0\xd8\x01\xe0\x02\xd8\x01\xd8\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\xd8\x01\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\0\0\xe0\x02\0\0\0\0\xd8\x01\0\0\0\0\xd8\x01\0\0\0\0\xd8\x01\xd8\x01\xd8\x01\0\0\0\0\0\0\0\x004\x02\xd8\x01\x06\x02\0\0\0\0\x06\x02\0\0\0\0\xd8\x01\0\0\x06\x02\xd5\x01\0\0\0\0\0\0\x06\x02\0\0\0\0\0\0\x06\x02\xd8\x01\x06\x02\x06\x02\0\0\xd8\x01\xd8\x01\0\0\x06\x02\x06\x02\0\0\x06\x02\x06\x02\x06\x02\0\0\0\0\0\0\xd8\x01\0\0\x06\x02\xd8\x01\0\0\0\0\0\0\x06\x02\0\0\x06\x02\0\0\x06\x02\x06\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\x02\xe0\x02\0\0\x06\x02\0\0\0\0\x06\x02\0\0\0\0\x06\x02\x06\x02\x06\x02\0\0\0\0\0\0\0\0\x06\x02\x06\x02\0\0\0\0\x06\x02\0\0\0\0\x06\x02\x06\x02\xb1\x01\x06\x02\x06\x02\x06\x02\0\0\0\0\0\0\0\0\x06\x02\x06\x02\0\0\x06\x02\0\0\0\0\0\0\x06\x02\x06\x02\0\0\0\0\x04\x02\0\0\0\0\0\0\0\0\0\0\0\0\x07\x02\x06\x02\x06\x02\x07\x02\x06\x02\0\0\x06\x02\0\0\x07\x02\0\0\x06\x02\0\0\0\0\x07\x02\0\0\0\0\0\0\0\0\x06\x02\x07\x02\0\0\x06\x02\0\0\0\0P\0\0\0\x07\x02\0\0\x07\x02\x07\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\x02\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\0\0\x8d\0\x8e\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\x02\0\0\xc0\x01\x07\x02\0\0\0\0\x07\x02\x07\x02\x07\x02\0\0\x8f\0\0\0\0\0\x07\x02\x07\x02\0\0\0\0\x07\x02\x90\0\x91\0\x07\x02\x07\x02\xe2\x02\x0b\x02\0\0\x07\x02\x92\0f\0\0\0\0\0\x07\x02\0\0\0\0\x07\x02\0\0\0\0\x07\x02\x07\x02\x93\0\x94\0f\0\x05\x02\0\0\x07\x02\0\0\x07\x02\x07\x02\0\0\0\0\x07\x02\0\0\0\0\x07\x02f\0\0\0f\0f\0\0\0\x07\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\x02\0\0\0\0\x07\x02\xb1\x01\0\0\x07\x02\x07\x02\x07\x02\0\0f\0\0\0\0\0\x07\x02\x07\x02\0\0\0\0\xd5\x01f\0\0\0\xd5\x01\x07\x02\0\0\0\0f\0\xd5\x01\0\0\0\0\0\0\0\0\xd5\x01f\0\0\0\x07\x02\0\0\0\0\xd5\x01\x07\x02\0\0\0\0\0\0\x07\x02\0\0\xd5\x01\0\0\xd5\x01\xd5\x01f\0\0\0\x07\x02\0\0\0\0\x07\x02\0\0\0\0\0\0\0\0\0\0\xd5\x01f\0\0\0\0\0f\0\xb2\x01\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd5\x01\0\0\xe0\x02\xd5\x01\0\0\0\0\xd5\x01\xd5\x01\xd5\x01\0\0\0\0\0\0\0\0\xb1\x01\xd5\x01\xe0\x02\xb1\x01\xe0\x02\xe0\x02\0\0\0\0\xd5\x01\0\0\0\0\0\0\0\0\xb1\x01\0\0\0\0\0\0\xe0\x02\0\0\xb1\x01\xd5\x01\0\0\0\0\0\0\xd5\x01\xd5\x01\xb1\x01\0\0\xb1\x01\xb1\x01\0\0\xb4\x01\0\0\0\0\0\0a\0\xd5\x01\xe0\x02\0\0\xd5\x01\0\0\xb1\x01\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\0\0P\0\xe0\x02\0\0P\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\0\0\xb1\x01\0\0P\0\xb1\x01\0\0\0\0\0\0\xb1\x01\xb1\x01\0\0\0\0\0\0\0\0\xe0\x02\xb1\x01P\0P\0P\0P\0\0\0\0\0\xb1\x01\0\0\0\0\0\0\xe0\x02\0\0y\x02\xe0\x02\xb3\x01P\0\0\0\0\0\xb1\x01\0\0\0\0\0\0\xb1\x01\xb1\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\xb1\x01P\0\xe2\x02\xb1\x01P\0\0\0\0\0\xe2\x02P\0P\0\0\0\0\0\xe2\x02\0\0\0\0P\0\0\0\0\0\xe2\x02\0\0\0\0\0\0P\0\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\0\0e\0\0\0\0\0\0\0P\0\0\0P\0\0\0P\0P\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\xb5\x01\0\0\0\0P\0\0\0\0\0P\0\0\0\0\0\0\0\0\0\0\0\xb1\x01\xe2\x02\0\0\xb1\x01\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\0\0\0\0\xb1\x01\0\0\xe2\x02\0\0\0\0\0\0\xb1\x01\0\0\0\0\xe2\x02\0\0\0\0\0\0\xb1\x01\0\0\xb1\x01\xb1\x01\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\xb1\x01\0\0\0\0\0\0\0\0\0\0\xb8\x01\0\0\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\xb2\x01\0\0\xb1\x01\xb2\x01\0\0\xb1\x01\0\0\0\0\0\0\xb1\x01\xb1\x01\0\0\0\0\xb2\x01\0\0\0\0\xb1\x01\0\0\0\0\xb2\x01\0\0\0\0\0\0\xb1\x01\0\0\0\0\xb2\x01\0\0\xb2\x01\xb2\x01\0\0\0\0\0\0\0\0\0\0\xb1\x01\0\0\0\0\xe2\x02\xb1\x01\xb1\x01\xb2\x01\0\0\0\0\0\0\0\0\0\0u\0\0\0\0\0\0\0\xb1\x01\0\0\0\0\xb1\x01\0\0\0\0\0\0\0\0\xb4\x01\0\0\xb2\x01\xb4\x01a\0\xb2\x01\0\0\0\0\0\0\xb2\x01\xb2\x01\0\0\0\0\xb4\x01\0\0\0\0\xb2\x01a\0\0\0\xb4\x01\0\0\0\0\0\0\xb2\x01\0\0\0\0\xb4\x01\0\0\xb4\x01\xb4\x01a\0\0\0a\0a\0\0\0\xb2\x01\0\0\0\0\xa8\x01\xb2\x01\xb2\x01\xb4\x01\0\0\0\0\0\0a\0\0\0\0\0\0\0\0\0\0\0\xb2\x01\0\0\0\0\xb2\x01\0\0\0\0\0\0\0\0\xb3\x01\0\0\xb4\x01\xb3\x01\0\0\xb4\x01a\0\0\0\0\0\xb4\x01\xb4\x01\0\0\0\0\xb3\x01a\0\0\0\xb4\x01\0\0\0\0\xb3\x01a\0\0\0\0\0\xb4\x01\0\0\0\0\xb3\x01a\0\xb3\x01\xb3\x01\0\0\0\0\0\0\0\0\0\0\xb4\x01\0\0\0\0\xe0\x02\xb4\x01\xb4\x01\xb3\x01\0\0a\0\0\0\0\0\0\0\0\0\0\0\0\0e\0\xb4\x01\0\0\0\0\xb4\x01a\0\0\0\0\0a\0\0\0\0\0\xb3\x01\0\0e\0\xb3\x01\0\0\0\0\xb5\x01\xb3\x01\xb3\x01\xb5\x01\0\0\0\0\0\0\0\0\xb3\x01e\0\0\0e\0e\0\xb5\x01\0\0\xb3\x01\xe0\x02\0\0\0\0\xb5\x01\0\0\0\0\0\0\0\0e\0\0\0\xb5\x01\xb3\x01\xb5\x01\xb5\x01\0\0\xb3\x01\xb3\x01\0\0\0\0\0\0\0\0\0\0E\0\0\0\0\0\xb5\x01\0\0\xb3\x01e\0\0\0\xb3\x01\0\0\0\0\0\0\0\0\0\0e\0\0\0\0\0\0\0\0\0\0\0e\0\xb8\x01\0\0\xb5\x01\xb8\x01\0\0\xb5\x01e\0\0\0\0\0\xb5\x01\xb5\x01\0\0\0\0\xb8\x01\0\0\0\0\xb5\x01\0\0\0\0\xb8\x01\0\0\0\0e\0\xb5\x01F\0\0\0\xb8\x01\0\0\xb8\x01\xb8\x01\0\0\0\0\0\0\0\0e\0\xb5\x01\0\0e\0\0\0\xb5\x01\xb5\x01\xb8\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\xb5\x01\0\0\0\0\xb5\x01\0\0\0\0\0\0\xe2\x02u\0\0\0\xb8\x01\0\0\xe2\x02\xb8\x01\0\0\0\0\0\0\xb8\x01\xb8\x01\0\0\0\0u\0\0\0\xd5\x01\xb8\x01\xe2\x02\0\0\xe2\x02\xe2\x02\0\0\0\0\xb8\x01\xd5\x01\0\0u\0\0\0u\0u\0\0\0\0\0\xe2\x02\0\0\0\0\xb8\x01\0\0\0\0\0\0\xb8\x01\xb8\x01u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa8\x01\xb8\x01\xe2\x02\0\0\xb8\x01\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02u\0\0\0\xa8\x01u\0\0\0\xe2\x02\0\0u\0u\0\0\0\0\0\0\0\xe2\x02\0\0u\0\xa8\x01\0\0\xa8\x01\xa8\x01\0\0\0\0u\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\xa8\x01\0\0\0\0u\0\0\0\0\0\0\0u\0u\0\0\0\xe2\x02\xe0\x02\0\0\xe2\x02\0\0\0\0\0\0\0\0\xe0\x02u\0\xa8\x01\xe0\x02u\0\xa8\x01\0\0\0\0\0\0\xa8\x01\xa8\x01\0\0\0\0\xe0\x02\0\0{\0\xa8\x01\0\0\0\0\0\0\0\0\0\0\0\0\xa8\x01\0\0\0\0\xe0\x02\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\xa8\x01\0\0|\0\0\0\xa8\x01\xa8\x01\xe0\x02\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\xa8\x01\0\0\0\0\xa8\x01\0\0\0\0\0\0\xe0\x02\0\0\0\0\xe0\x02\0\0\0\0\xe0\x02\0\0\0\0E\0\0\0\xe0\x02E\0\xe0\x02\0\0\xe0\x02\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0E\0\0\0\xe0\x02\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0E\0\xe0\x02E\0E\0\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x02E\0E\0\xe0\x02\xe0\x02\0\0F\0\xe0\x02\xe0\x02F\0\xe2\x02\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\0\0F\0\xe2\x02\xe0\x02E\0\0\0\0\0E\0\0\0\0\0\0\0E\0E\0\0\0F\0\xe0\x02F\0F\0E\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0E\0\0\0\0\0F\0F\0\0\0\xe0\x02\0\0\0\0\xe0\x02\0\0\0\0E\0\xd5\x01\0\0\0\0E\0E\0\0\0\0\0\0\0\xd5\x01\xd5\x01\0\0F\0\0\0\xd5\x01F\0E\0\0\0\0\0F\0F\0\0\0\0\0\xd5\x01\0\0\0\0F\0\xd5\x01\0\0\xd5\x01\xd5\x01\0\0\xe0\x02F\0\0\0\0\0\xd5\x01\0\0\xd5\x01\xd5\x01\0\0\0\0\xd5\x01\0\0\0\0F\0\0\0\0\0\0\0F\0F\0\xd5\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0F\0\xd5\x01\0\0\0\0\xd5\x01\0\0\0\0\xd5\x01\xd5\x01\xd5\x01\xd5\x01\0\0\0\0\xd5\x01\0\0\xd5\x01\xd5\x01\xd5\x01\xd5\x01\0\0\0\x006\0\xd5\x01\0\0\xd5\x01\0\0\0\0\xe0\x02\0\0\0\0\xe0\x02\xd5\x01\0\0\0\0\xd5\x01\0\0\0\0\0\0\xd5\x01\xd5\x01\xe0\x02\0\0\0\0\xd5\x01\0\0\0\0\0\0\xd5\x01\xd5\x01{\0\xd5\x01\0\0{\0\xe0\x02\0\0\xe0\x02\xe0\x02\0\0\0\0\xd5\x018\0\0\0{\0\0\0\0\0\0\0\0\0\xe0\x02\xe0\x02\0\0\0\0|\0\0\0\0\0|\0{\0\0\0{\0{\0\0\0\0\0\0\0\0\0\0\0|\0\0\0\0\0\0\0\xe0\x02\0\0{\0\xe0\x02\0\0\0\0\0\0\0\0\xe0\x02|\0\0\0|\0|\0\0\0\xe0\x02\0\0<\0\0\0\0\0\0\0\0\0\xe0\x02{\0\0\0|\0{\0\0\0\0\0\0\0{\0{\0\0\0\0\0\xe0\x02\0\0\0\0{\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0{\0|\0\0\0\0\0|\0\0\0\xe0\x02\0\0|\0|\0\0\0\0\0{\0\0\0\0\0|\0{\0{\0?\0\xe2\x02\0\0\0\0|\0\0\0\0\0\0\0\0\0\xe2\x02{\0\xe2\x02\0\0\0\0\xe2\x02\0\0|\0\0\0\0\0\0\0|\0|\0@\0\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe0\x02|\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\0\0\xe0\x02\xe2\x02\xe2\x02\xe0\x02\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\xe0\x02\0\0\xe2\x02\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\0\0\0\0\xe0\x02\xe2\x02\xe0\x02\xe0\x02\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\xe2\x02\0\0'\x02\0\0'\x02'\x02'\x026\0'\x02\0\0\0\0'\x02'\x02\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\x006\0\xe0\x02\0\0\0\0\0\0\0\0\xe0\x02\0\0\0\0'\x02\0\0\0\0\xe0\x026\0\0\x006\x006\0'\x02'\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0'\x028\0\0\x006\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\xe0\x02\xe0\x02'\x02'\x028\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x026\0\0\0\0\x006\x008\0\0\x008\x008\x006\0\0\0\0\0\0\0\0\0\0\x006\0\0\0\0\0\0\0\0\x008\0\0\x006\0<\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x006\0\0\0<\0\0\x006\x006\x008\0\0\0\0\x008\0\0\0\0\0\0\0\0\x008\0<\x006\0<\0<\0\0\x008\0\0\0\0\0\0\0\0\0\0\0\0\x008\0\0\0\0\0<\0\0\0\0\0\0\0?\0\0\0\0\0\0\0\0\x008\0\0\0\0\0\0\x008\x008\0\0\0\0\0?\0\0\0\0\0<\0\0\0\0\0<\0\0\x008\0@\0\0\0<\0\0\0?\0\0\0?\0?\0<\0\xe0\x02\0\0\0\0\0\0@\0\0\0<\0\0\0\0\0\0\0?\0\0\0\0\0\xe0\x02\0\0\0\0\0\0@\0<\0@\0@\0\0\0<\0<\0\0\0\0\0\xe0\x02\0\0\xe0\x02\xe0\x02?\0\0\0@\0?\0<\0\0\0\0\0\0\0?\0\0\0\0\0\xe0\x02\0\0\0\0?\0\0\0\0\0\0\0\0\0\0\0\0\0?\0@\0\0\0\0\0@\0\0\0\0\0\0\0\0\0@\0\xe0\x02\0\0?\0\xe0\x02\0\0@\0?\0?\0\xe0\x02\0\0\0\0\0\0@\0\0\0\xe0\x02\0\0\0\0\0\0?\0\0\0\0\0\xe0\x02\0\0\0\0@\0\0\0\0\0\0\0@\0@\0\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\xe0\x02\xe0\x02\xdb\x02@\0\0\0\0\0\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\xe0\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\0\0\0\0\0\0\xdb\x02\0\0\0\0\0\0\0\0\0\0\0\0\xdb\x02\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\0\0\0\0\0\0\xdb\x02\0\0\xdb\x02\0\0\0\0\0\0\0\0\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\0\0\xdb\x02\xdb\x02\0\0\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\xdb\x02\0\0\xdb\x02\xdb\x02\0\0\xdb\x02\0\0\xdb\x02\xdb\x02\0\0\0\0\xdb\x02\xdb\x02\0\0\xdb\x02\0\0\xdb\x02\0\0\0\0\xdb\x02\xdb\x02\0\0\0\0\xdb\x02\xdb\x02\0\0\0\0\0\0\xdb\x02\0\0\0\0\xdb\x02\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\0\0\xdb\x02#\x01$\x01%\x01\0\0\0\0\t\0\n\0&\x01\0\0'\x01\0\0\f\0\r\0\0\0\0\0(\x01)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\0\0\0\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0+\x01\0\0\0\0\x16\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\x001\x01\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\x002\x013\x01\0\x004\x01\0\0*\0+\0\0\0,\0\0\0\0\0\0\x005\x016\x017\x018\x019\x01:\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\0\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0#\x01$\x01%\x01\0\x007\0\t\0\n\0&\x01\0\0'\x01\0\0\f\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\0\0\0\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0+\x01\0\0\0\0\x16\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\x001\x01\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\x002\x013\x01\0\x004\x01\0\0*\0+\0\0\0,\0\0\0\0\0\0\x005\x016\x017\x018\x019\x01:\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\0\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0#\x01$\x01%\x01\0\x007\0\t\0\n\0&\x01\0\0'\x01\0\0\f\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\0\0\0\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0+\x01\0\0\0\0\x16\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\x001\x01\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\x002\x013\x01\0\0Z\x03\0\0*\0+\0\0\0,\0\0\0\0\0\0\x005\x016\x017\x018\x019\x01:\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0<\x01\0\0=\x012\0\0\0\0\0\0\0\xe2\x023\x004\0\0\x006\0\xe2\x02\xe2\x02\xe2\x02\xe2\x027\0\0\0\xe2\x02\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02^\x02\0\0\xe2\x02\0\0\0\0\xa5\x02\xa5\x02\xa5\x02\0\0\0\0\0\0\xa5\x02\xa5\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa5\x02\xa5\x02\xa5\x02\xa5\x02\xa5\x02\0\0\0\0\0\0\0\0\xa5\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa5\x02\xa5\x02\xa5\x02\0\0\xa5\x02\xa5\x02\xa5\x02\xa5\x02\xa5\x02\0\0\0\0\xa5\x02\0\0\0\0\0\0\xa5\x02\xa5\x02\xa5\x02\0\0\0\0\0\0\xa5\x02\0\0\xa5\x02\xa5\x02\0\0\0\0\0\0\xa5\x02\xa5\x02\0\0\xa5\x02\0\0\0\0\0\0\0\0\0\0\xa5\x02\xa5\x02_\x02\xa5\x02\0\0\0\0\0\0\xa6\x02\xa6\x02\xa6\x02^\x02\0\0\0\0\xa6\x02\xa6\x02\0\0\0\0\xa5\x02\0\0\0\0\0\0\0\0\xa5\x02\xa5\x02\0\0\xa5\x02\0\0\0\0\0\0\0\0\xa5\x02\0\0\xa6\x02\xa6\x02\xa6\x02\xa6\x02\xa6\x02\0\0\0\0\0\0\0\0\xa6\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa6\x02\xa6\x02\xa6\x02\0\0\xa6\x02\xa6\x02\xa6\x02\xa6\x02\xa6\x02\0\0\0\0\xa6\x02\0\0\0\0\0\0\xa6\x02\xa6\x02\xa6\x02\0\0\0\0\0\0\xa6\x02\0\0\xa6\x02\xa6\x02\0\0\0\0\0\0\xa6\x02\xa6\x02\0\0\xa6\x02\0\0\0\0\0\0\0\0\0\0\xa6\x02\xa6\x02\\\x02\xa6\x02\0\0\0\0\0\0\xa7\x02\xa7\x02\xa7\x02_\x02\0\0\0\0\xa7\x02\xa7\x02\0\0\0\0\xa6\x02\0\0\0\0\0\0\0\0\xa6\x02\xa6\x02\0\0\xa6\x02\0\0\0\0\0\0\0\0\xa6\x02\0\0\xa7\x02\xa7\x02\xa7\x02\xa7\x02\xa7\x02\0\0\0\0\0\0\0\0\xa7\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa7\x02\xa7\x02\xa7\x02\0\0\xa7\x02\xa7\x02\xa7\x02\xa7\x02\xa7\x02\0\0\0\0\xa7\x02\0\0\0\0\0\0\xa7\x02\xa7\x02\xa7\x02\0\0\0\0\0\0\xa7\x02\0\0\xa7\x02\xa7\x02\0\0\0\0\0\0\xa7\x02\xa7\x02\0\0\xa7\x02\0\0\0\0\0\0\0\0\0\0\xa7\x02\xa7\x02]\x02\xa7\x02\0\0\0\0\0\0\xa8\x02\xa8\x02\xa8\x02\\\x02\0\0\0\0\xa8\x02\xa8\x02\0\0\0\0\xa7\x02\0\0\0\0\0\0\0\0\xa7\x02\xa7\x02\0\0\xa7\x02\0\0\0\0\0\0\0\0\xa7\x02\0\0\xa8\x02\xa8\x02\xa8\x02\xa8\x02\xa8\x02\0\0\0\0\0\0\0\0\xa8\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa8\x02\xa8\x02\xa8\x02\0\0\xa8\x02\xa8\x02\xa8\x02\xa8\x02\xa8\x02\0\0\0\0\xa8\x02\0\0\0\0\0\0\xa8\x02\xa8\x02\xa8\x02\0\0\0\0\0\0\xa8\x02\0\0\xa8\x02\xa8\x02\0\0\0\0\0\0\xa8\x02\xa8\x02\0\0\xa8\x02\0\0\0\0\0\0\0\0\0\0\xa8\x02\xa8\x02\0\0\xa8\x02\0\0\0\0\0\0\0\0\0\0\0\0]\x02\xeb\0\xec\0\xed\0\0\0\0\0\0\0\xa8\x02\0\0\xee\0\0\0\xef\0\xa8\x02\xa8\x02\0\0\xa8\x02\0\0\xf0\0\xf1\0\xf2\0\xa8\x02\0\0\xf3\0\xf4\0\xf5\0\0\0\xf6\0\xf7\0\xf8\0\0\0\xf9\0\xfa\0\xfb\0\xfc\0\0\0\0\0\0\0\xfd\0\xfe\0\xff\0\0\0\0\0\0\0\0\0\0\0\0\x01\x01\x01\0\0\0\0\0\0\0\0\x02\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\x01\x04\x01\0\0\0\0\0\0\0\0\x05\x01\x06\x01\0\0\0\0\0\0\x07\x01\b\x01\0\0\t\x01\0\0\n\x01\x0b\x01\f\x01\0\0\r\x01\0\0\0\0\0\0\0\0\0\0\x0e\x01\0\0\0\0\0\0\0\0\x0f\x01\0\0\0\0\0\0\0\0\0\0\x10\x01\b\x02\0\0\x11\x01\x12\x01\b\x02\x13\x01\x14\x01\x15\x01\x16\x01\x17\x01\0\0\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\0\0\b\x02\0\0\b\x02\0\0\0\0\xf5\x01\0\0\0\0\0\0\b\x02\b\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\b\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\b\x02\b\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\b\x02\0\0\0\0\0\0\b\x02\0\0\b\x02\b\x02\b\x02\0\0\b\x02\0\0\0\0\b\x02\0\0\0\0\0\0\0\0#\x01$\x01%\x01\0\0\0\0\0\0\n\0\xe1\x01\0\0'\x01\0\0\0\0\r\0\xf5\x01\b\x02\xe2\x01)\x01\0\0\b\x02\0\0\b\x02\0\0\0\0\b\x02\0\0\0\0\0\0*\x01\xa2\0\0\0\x11\0\x12\0\b\x02\0\0\b\x02\0\0+\x01\0\0\0\0\0\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\x001\x01\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xe3\x01\xe4\x01\0\0\xe5\x01\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\x005\x016\x01\xe6\x01\xe7\x019\x01\xe8\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\xab\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0#\x01$\x01%\x01\0\0\0\0\0\0\n\0\xe1\x01\0\0'\x01\0\0\0\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0+\x01\0\0\0\0\0\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\x001\x01\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xe3\x01\xe4\x01\0\0\xe5\x01\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\x005\x016\x01\xe6\x01\xe7\x019\x01\xe8\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\xab\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\0\0\0\x01\x036\0\xac\0#\x01$\x01%\x01\0\0\0\0\0\0\n\0\xe1\x01\0\0'\x01\0\0\0\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0+\x01\0\0\0\0\0\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\x001\x01\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xe3\x01\xe4\x01\0\0\xe5\x01\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\x005\x016\x01\xe6\x01\xe7\x019\x01\xe8\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\xab\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\0\0\0\xca\x036\0\xac\0#\x01$\x01%\x01\0\0\0\0\0\0\n\0\xe1\x01\0\0'\x01\0\0\0\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0+\x01\0\0\0\0\0\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\x001\x01\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xe3\x01\xe4\x01\0\0\xe5\x01\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\x005\x016\x01\xe6\x01\xe7\x019\x01\xe8\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\xab\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\0\0\0\b\x046\0\xac\0#\x01$\x01%\x01\0\0\0\0\0\0\n\0\xe1\x01\0\0'\x01\0\0\0\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0+\x01\0\0\0\0\0\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\x001\x01\0\0\xdd\x02\xa7\0\xa8\0\0\0\0\0\0\0\n\0\0\0\xe3\x01\xe4\x01\0\0\xe5\x01\r\0*\0\0\0\0\0\0\0\0\0\0\0\0\x005\x016\x01\xe6\x01\xe7\x019\x01\xe8\x01\0\0\0\0\xa2\0\0\0\x11\0\x12\0;\x01\0\0\0\0\xab\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\xdf\x02\xa7\0\xa8\0\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0\0\0\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\xe1\x02\xa7\0\xa8\0\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0\0\0\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xa9\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\t\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\x0e\x005\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0f\0\x10\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\x17\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0!\0\0\0\0\0\"\0#\0$\0\0\0\0\0%\0&\0\0\0'\0(\0\0\0)\0\0\0*\0+\0\0\0,\0\0\0-\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\x006\x02\0\0\0\0\t\0\n\0\x0b\0\0\x001\0\0\0\f\0\r\0\x0e\x002\0\0\0\0\0\0\0\0\x003\x004\x005\x006\0\0\0\0\0\0\0\0\x007\0\x0f\0\x10\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\x17\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0!\0\0\0\0\0\"\0#\0$\0\0\0\0\0%\0&\0\0\0'\0(\0\0\0)\0\0\0*\0+\0\0\0,\0\0\0-\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\0\0\t\0\n\0\x0b\0\0\0\0\x001\0\f\0\r\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\x005\x006\0\0\0\0\0\0\0\0\x007\0\0\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\0'\0(\0\0\0\0\0\0\0*\0+\0\0\0,\0\0\0\0\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\0\0\0\0\xe6\0\t\0\n\0\x0b\0\0\0\0\0\xe9\0\f\0\r\x002\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0\0\0\0\0\0\0\0\x007\0\0\0\0\0\0\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\0'\0(\0\0\0\0\0\0\0*\0+\0\0\0,\0\0\0\0\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\t\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0\0\0\x06\x02\0\0\0\x007\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\0'\0(\0\0\0\0\0\0\0*\0+\0\0\0,\0\0\0\0\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0\0\0\xe4\x02\0\0\0\x007\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0\t\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\0'\0(\0\0\0\0\0\0\0*\0+\0\0\0,\0\0\0\0\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0\0\0\0\0\0\0\0\x007\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0\0\0\n\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0^\x03\0\0\xe4\x02C\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0_\x03\0\0\xe4\x02\x11\0\x12\0\xf3\x01\0\0\xf3\x01\xf3\x01\xf3\x01\0\0\xf3\x01\0\0\0\0\xf3\x01\xf3\x01\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\xf3\x01 \0\0\0\0\0\0\0\0\0\xa7\0`\x03\xf3\x01\xf3\x01\0\0\0\0\0\0\xa9\0\n\0\0\0\xf3\x01\0\0*\0\0\0\r\0\0\0B\x02\0\0\x17\x02C\x02\0\0\xaa\0\xf3\x01\xf3\x01\0\0\0\0\x18\x02\0\0\0\0_\x03\0\0\0\0\x11\0\x12\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0`\x03\0\0\0\0\0\0\0\0\0\0\xa9\0\n\0\0\0\0\0\0\0*\0\0\0\r\0\0\0\xb9\x03\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\xba\x03\0\0\0\0\x11\0\x12\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xd4\x01\0\0\0\0\0\0\0\0\0\0\xa9\0\n\0\0\0\0\0\0\0*\0\0\0\r\0\0\0\x92\x05\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0_\x03\0\0\0\0\x11\0\x12\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0`\x03\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0\0\0\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\x0b\x03\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0\f\x03\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xd4\x01\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0E\x05\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\x16\x02\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0\0\0\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xd4\x01\0\0\0\0\0\0\xe4\x02\0\0\xa9\0\0\0\0\0\0\0\xe4\x02*\0\0\0\0\0\0\0\0\0\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\n\0\0\0\xe4\x02\0\0\0\0\0\0\r\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\0\0\xe4\x02\0\0\xe4\x02\0\0\0\0\xe4\x02\xe4\x02\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xa9\0\0\0\0\0\0\0\n\0*\0\0\0\0\0\xdf\x01\0\0\r\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe6\0\0\0\0\0\0\0\xa2\0\xab\0\x11\0\x12\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xa9\0\xe4\x02\0\0\xe4\x02\0\0*\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\n\0\xe4\x02\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\xa2\0\xe4\x02\x11\0\x12\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\xe4\x02\0\0\xa9\0\0\0\0\0\0\0\xe4\x02*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xa1\x02\0\0\xe4\x02\0\0\0\0\0\0\xa1\x02\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\xa1\x02\0\0\xa1\x02\xa1\x02\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\xe4\x02\xe4\x02\xa1\x02\xa1\x02\xa1\x02\0\0\xa1\x02\xa1\x02\0\0\xa1\x02\xa1\x02\0\0\0\0\xa1\x02\0\0\0\0\0\0\0\0\xa1\x02\xa1\x02\0\0\0\0\0\0\x8e\x02\0\0\xa1\x02\0\0\0\0\0\0\x8e\x02\xa1\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\x02\0\0\0\0\0\0\0\0\0\0\x8e\x02\0\0\x8e\x02\x8e\x02\0\0\0\0\0\0\xa1\x02\0\0\0\0\0\0\xa1\x02\0\0\0\0\0\0\0\0\xa1\x02\0\0\0\0\xa1\x02\xa1\x02\x8e\x02\x8e\x02\x8e\x02\0\0\x8e\x02\x8e\x02\0\0\x8e\x02\x8e\x02\0\0\0\0\x8e\x02\0\0\0\0\0\0\0\0\x8e\x02\x8e\x02\0\0\0\0\0\0\n\0\0\0\x8e\x02\0\0\0\0\0\0\r\0\x8e\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8e\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\x8e\x02\0\0\0\0\0\0\x8e\x02\0\0\0\0\0\0\0\0\x8e\x02\0\0\0\0\x8e\x02\x8e\x02\x18\0\x19\0\x1a\0\0\0\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xd4\x01\0\0\0\0\0\0\0\0\0\0\xa9\0\n\0\x0b\0\0\0\0\0*\0\f\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0|\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\0\x12\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0}\x01\0\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xc0\0\0\0\0\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\0\0*\0+\0\0\0\0\0\0\0\0\0~\x01\0\0\0\0\0\0\0\0\0\x000\0\0\0\x7f\x01\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0\x80\x01\x81\x01\0\0\0\x002\0\0\0\0\0\x82\x01\0\x003\0\0\0\0\x006\0\x18\0\x19\0\x1a\0}\x01\0\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xc0\0\0\0\0\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\0\0*\0+\0\0\0\0\0\0\0\0\0~\x01\0\0\0\0\0\0\0\0\0\x000\0\0\0\x7f\x01\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x002\0\0\0\0\0\x82\x01\0\x003\0\0\0\0\x006\0\x18\0\x19\0\x1a\0\0\0\0\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xc0\0\0\0\0\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\0\0*\0+\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x000\0\0\0\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\x18\0\x19\0\x1a\0\0\0\0\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xdb\0\xc0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0*\0+\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x04\0\0\0\0\0\x000\0\0\0\0\0\xc8\0\xe4\x02\xe4\x02\x89\0\0\0\x8a\0\x8b\0 \0\x91\x04\x8c\0\0\x002\0\x8d\0\x8e\0\0\0\xc9\x003\0\0\0\0\x006\0\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\x8f\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\x90\0\x90\x03\0\0\x89\0\0\0\x8a\0\x8b\0 \0\x92\0\x8c\0\xe4\x02\xe4\x02\x8d\0\x92\x04\0\0\0\0\0\0\0\0\x90\x04\xb7\x05\x93\0\x94\0\xe4\x02\0\0\0\0\xc8\0\0\0\0\0\0\0\0\0\x8f\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\x93\x04\x90\0\x91\0\xc9\0\xe4\x02\0\0\0\0\xe4\x02\0\0\x92\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcb\0\0\0\0\0\x94\x04\x94\0\0\0\0\0\0\0\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\0\0\x8d\0\x92\x04\0\0\0\0\0\0\0\0\xd3\x03W\x01X\x01\0\0\0\0\0\0\0\0\0\0\0\0Y\x01\0\0\0\0\x8f\0\0\0\xd4\x03Z\x01[\x01\xd5\x03\\\x01\0\0\x90\0\x91\0\0\0\0\0\0\0\0\0\0\0]\x01\x92\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\x01\xcb\0\0\0\0\0\x94\x04\x94\0_\x01`\x01a\x01b\x01c\x01#\x01$\x01%\x01\0\0\0\0\0\0\0\0\xe1\x01\0\0'\x01\0\0\0\0\0\0\0\0\0\0d\x01)\x01\0\0\0\0\0\0\xb9\0\0\0\0\0\0\0\0\0e\x01f\x01*\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0+\x01g\x01h\x01i\x01j\x01k\x01,\x01-\x01.\x01/\x010\x01\0\0\0\0\xd6\x03\0\0\0\0\0\0\0\0\0\0m\x01\0\0\0\0\0\0\0\0\0\0\0\x001\x01\0\0\0\0\0\0W\x01X\x01\0\0\0\0\0\0\0\0\x10\x02\xe4\x01Y\x01\x11\x02\0\0\0\0\0\0\0\0Z\x01[\x01\0\0\\\x015\x016\x01\x12\x02\xe7\x019\x01\xe8\x01\0\0\0\0]\x01\0\0\0\0\0\0\0\0\0\0W\x01X\x01<\x01^\x01=\x01\0\0\0\0\0\0Y\x01_\x01`\x01a\x01b\x01c\x01Z\x01[\x01\0\0\\\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0]\x01\0\0\0\0d\x01\0\0\0\0\0\0\0\0\xb9\0^\x01\0\0\0\0\0\0e\x01f\x01_\x01`\x01a\x01b\x01c\x01\0\0\0\0\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01\0\0\0\0\0\0\0\0\0\0d\x01W\x01X\x01l\x01\0\0\xb9\0\0\0\0\0m\x01Y\x01e\x01f\x01\0\0\0\0\0\0Z\x01[\x01\0\0\\\x01\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01]\x01\0\0\0\0\0\0\x10\x04\0\0W\x01X\x01\0\0^\x01\0\0\0\0\0\0m\x01Y\x01_\x01`\x01a\x01b\x01c\x01Z\x01[\x01\0\0\\\x01\0\0\0\0\0\0\0\0\0\0\0\0r\x04\0\0]\x01\0\0\0\0d\x01\0\0\0\0\0\0\0\0\xb9\0^\x01\0\0\0\0\0\0e\x01f\x01_\x01`\x01a\x01b\x01c\x01\0\0\0\0\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01\0\0\0\0\0\0\0\0?\x04d\x01W\x01X\x01\0\0\0\0\xb9\0\0\0\0\0m\x01Y\x01e\x01f\x01\0\0\0\0\0\0Z\x01[\x01\0\0\\\x01\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01]\x01\0\0\0\0\0\0\0\0\0\0W\x01X\x01\0\0^\x01\0\0\0\0\0\0m\x01Y\x01_\x01`\x01a\x01b\x01c\x01Z\x01[\x01\0\0~\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0]\x01\0\0\0\0d\x01\0\0\0\0\0\0\0\0\xb9\0^\x01\0\0\0\0\0\0e\x01f\x01_\x01`\x01a\x01b\x01c\x01\0\0\0\0\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01\0\0\0\0\0\0\0\0\0\0d\x01\xea\0\xea\0\0\0\0\0\xb9\0\0\0\0\0m\x01\xea\0e\x01f\x01\0\0\0\0\0\0\xea\0\xea\0\0\0\0\0\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01\xea\0\0\0\0\0\0\0\0\0\0\0W\x01X\x01\0\0\xea\0\0\0\0\0\0\0m\x01Y\x01\xea\0\xea\0\xea\0\xea\0\xea\0Z\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0]\x01\0\0\0\0\xea\0\0\0\0\0\0\0\0\0\xea\0^\x01\0\0\0\0\0\0\xea\0\xea\0_\x01`\x01a\x01b\x01c\x01\0\0\0\0\0\0\0\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\xea\0d\x01W\x01X\x01\0\0\0\0\xb9\0\0\0\0\0\xea\0Y\x01e\x01f\x01\0\0\0\0\0\0Z\x01\0\0\0\0\0\0\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01]\x01\0\0\0\0\0\0\0\0\0\0\0\0R\x05\0\0^\x01\0\0\0\0\0\0m\x01\0\0_\x01`\x01a\x01b\x01c\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0W\x01X\x01\0\0\0\0\0\0\0\0\0\0\0\0d\x01\0\0\0\0\0\0\0\0\xb9\0Z\x01\0\0\0\0\0\0e\x01f\x01\0\0\0\0\0\0\0\0\0\0\0\0]\x01\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01^\x01\0\0\0\0\0\0\0\0\0\0_\x01`\x01a\x01b\x01c\x01\0\0\0\0m\x01\0\0\0\0\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\0\0\x8c\0d\x01\0\0\x8d\0\x8e\0\0\0\xb9\0\0\0\0\0\0\0\0\0e\x01f\x01\xc0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8f\0\0\0\0\0h\x01i\x01j\x01k\x01\0\0\x90\0\x91\0\0\0\0\0\0\0\0\0\0\0\0\0\x92\0\0\0\0\0\0\0m\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x93\0\x94\0",
  check: "\x03\0\x04\0^\0\x06\0\x02\0\x92\0\x02\0>\x01\x0f\0\x83\x01\xa3\0\x89\0\x0e\x02\x8f\0\xa4\0!\x01\n\0\x89\0\xba\x02\xc0\x01\x1d\0\x9e\0\r\x03\x8b\0\t\x02\xd1\0\t\0\xb2\x01\xd5\0\f\0a\x03\x7f\x03\x1f\0$\0\xab\0\x8f\x01\x13\0\x14\0\x15\0\x16\0V\x02\x0b\x007\x03\xf3\x02\x1b\0\xba\x02\f\x02\xd4\0\x0e\x02\xa6\x04\x01\0\"\0\x03\0\x04\0\x02\0&\0\xd1\0\f\x04\x1c\0!\0+\0,\0\xe8\0%\0\xea\0\x03\0\x04\0o\x01\x02\x004\0\x07\0\0\x007\0;\0\0\0\x93\x04\0\0\x02\x000\0\f\x02\x84\0\x0e\x02\x86\0I\x04\x1f\x01b\0\x8a\x04\x8b\x04_\0\x03\0\x02\0\x8c\x01\xbc\x04\x01\0\xd2\0B\x04\x11\x01n\x001\0\x02\0b\0\x02\0b\0U\x04C\x01\xc5\0\x01\x02\x02\x02;\0A\x01\0\0\x0f\x01n\0S\0n\0U\0V\0@\x01\0\x01%\x01\x0f\x02\xf8\x03\0\x014\x01\x07\x01\x04\x01C\x01\x82\0z\0\b\x01\x97\x04\x8c\0\n\x01`\x01Z\x01\0\x01\x0f\x01\x17\x04\x9a\x04\x12\x01\x05\x001\0\xb7\x01\0\x01\xb9\x01\0\x01\x89\0A\x01\0\x01\x07\x01b\0\x91\0\x86\x04\0\x01u\x01`\x01\0\x01\0\x01r\x01\xac\x03\0\x01\0\x01n\0C\x01b\0$\x04\0\x01\x96\0J\x02\0\x01\x11\x01\n\x01N\x02b\0\0\x01`\x01n\0\x80\0\x12\x05\x82\0\b\x01\x84\0^\x03\x86\0E\x01n\0b\0\0\x01C\x01\xc0\0\x80\0\xae\0\x82\0\xc4\0\x84\0b\0\x86\0b\0n\0\xd4\x03\xd5\x03\0\x01\0\x01\xae\x04\xbb\0\0\x01.\x05n\0\xd3\0n\0C\x01\xb9\0\xba\0A\x01`\x01\b\x02\x82\0\0\x01\xbc\0\0\x01\xd2\x04A\x01A\x01\0\x01L\x02\xa2\0\x84\x02C\x01\xa5\0\xa6\0|\x01r\x01\xd7\0\x8e\x01A\x01\xd9\x04s\x01\x0e\x01]\x01`\x01\t\0\xb2\0\xb3\0\f\0\t\x05\xe3\x04o\x01\x07\x05\xda\0`\x01\x13\0\x14\0\x15\0\x16\0\x8b\x03^\x01`\x01\x11\x05\x1b\0o\x01u\x01\0\x01`\x01\xd6\0O\x01\x88\x04^\x01o\x01o\x01&\0`\x01\xd0\0C\x01=\x02+\0,\0\xbe\x01u\x01^\x05\x04\x01o\x01^\x01v\x014\0x\x01-\x057\0\x18\x01\0\x01\x04\x01C\x01A\x01B\x01\b\x01]\x01]\x01\0\0\0\x01a\x01a\x01\x0f\x01`\x01\x16\x01\x12\x01\xbe\x04 \x01\xd6\0\x9f\x02\xde\x01\0\x02\xe0\x01\x0e\x01]\x01`\x01\x11\x01\x03\x01a\x01\xbf\x01A\x01`\x01\0\x01\x16\x01\xb7\x05\xd0\x01&\x01\0\x01\xa2\x01\0\x01K\x01C\x01@\x05N\x01\xce\x01\xdb\x04\x04\x01\x1e\x01\x1f\x01o\x01\b\x01\0\x01\x85\x02\x86\x02f\x05E\x05:\x01\x0f\x01\0\x01\0\x01\x12\x01J\x01\0\x01Q\x01C\x01\x1a\x01]\x01\xfa\x02S\x01u\x05a\x01J\x01\n\x01l\x01P\x01$\x02\0\x01p\x01\0\x01\x05\x02g\x04@\x01k\x01D\x01\x0f\x01\xa6\x02\xaa\x01\x80\x01\xac\x01\xad\x05\xae\x01 \x02\x15\x02E\x04^\x01G\x04\xff\x04\x1a\x02Q\x01\x1e\x01\x91\x01\x9a\x05w\x03\\\x01\x1a\x01`\x017\x03\n\x05T\x04C\x01\xb7\x02C\x01s\x013\x03]\x02\x91\x01M\x02\x91\x01\0\x01\0\x01\xa5\x04\0\x01C\x01}\x01~\x01]\x01\x81\x05\x81\x01s\x05\x83\x01/\x04^\x01\x93\x01^\x01\x16\x01B\x01\0\x01\0\x01\0\x01\x1b\x01\0\x01\x12\x01o\x01\x1b\x03]\x01?\x05\n\x01\0\x01\n\x01\0\x01\0\x01`\x01]\x01\xb0\x01`\x01I\x05^\x01\x11\x01\0\x01a\x01\xb7\x01\x03\x01\xb9\x01\xb2\x01\xb5\x03\x91\x01\xf4\x03\b\x01\x80\x02\0\x01\0\x01+\x05`\x01\x12\x01%\x01\x11\x01Y\x02l\x01\xc1\x01\x91\x01o\x01A\x03#\x01\b\x01\xcf\x01\x1c\x05%\x01\xaa\x01\x91\x01\xac\x01\x0f\x01\xae\x01\xbe\x03\xbf\x03\b\x01$\x01\xd3\x01\x88\x02\xf3\x04\x80\x02\xaa\x01\x91\x01\xac\x01\0\x01\xae\x01\x1e\x01\xdd\x01<\x01~\x05\x96\x02\x91\x01]\x01\x91\x01B\x01\0\x01`\x01\xef\x04`\x01\xe9\x01\x92\x03\xb9\x03\0\x01\0\x01\xac\x03\n\x01\xbe\x03\xbf\x03\xcb\x04p\x036\x01^\x01 \x01^\x01a\x01a\x01a\x01`\x01\xfc\x01\xfd\x01\0\x01|\x03B\x01\x01\x02\x02\x02^\x01\f\x02a\x01\x0e\x02\x84\x03^\x01\xa3\x02h\x01\0\x01^\x01`\x01\0\x01\x0f\x02\b\x01o\x01\xb1\x05\x16\x01\x14\x02/\x02\xd4\x03\xd5\x03`\x01`\x01\x1c\x04\0\x01\b\x01\x0f\x01\x12\x01\x0e\x01\0\x02\xbf\x04\"\x02\x0f\x01\xf6\x01\xf7\x01\xf8\x01^\x01\xc2\x02\xf2\x02l\x01\xd2\x02\xfe\x01o\x01B\x01C\x01\xc3\x02\xc4\x02\x1e\x01\xbc\x03\xe8\x02\x1b\x01\x06\x01\b\x01^\x01\x12\x01\\\x01;\x02B\x014\x02\b\x01\x1b\x01@\x02A\x01B\x01^\x01J\x01b\x05a\x01a\x02\xf2\x02\x17\x04\x1c\x02^\x01`\x01\x17\x03p\x01\0\x01d\x02C\x01b\x02c\x02\xd1\x03\x10\x01B\x01\x12\x01\x12\x01\x16\x01$\x01]\x01\xf6\x02C\x01\0\x01\x12\x01c\x01d\x01\x12\x01\r\x036\x02\x16\x01^\x01\x16\x01]\x01\xae\x02\x1b\x01=\x02`\x01`\x02`\x01\x13\x01\b\x01`\x01u\x01\x0e\x01\x16\x01\x89\x02\x8a\x02\x0f\x01]\x01\x1b\x01\0\x01I\x04\x99\x05]\x02~\x02Q\x02l\x01\x1e\x01*\x04o\x01`\x01\x0e\x04\x1e\x01`\x01\x0e\x01\x13\x02(\x05/\x01*\x05^\x01^\x01u\x01Z\x03\x12\x01\x9d\x02\0\0^\x01\x0e\x01\x12\x01\x97\x02a\x03=\x01\x12\x018\x01W\x03X\x03Y\x03\\\x01\x12\x01E\x01\xbc\x02G\x01^\x01B\x01#\x04B\x01C\x01s\x03B\x015\x02]\x01`\x01^\x01\xb7\x02a\x01\x16\x01c\x01d\x01c\x01d\x01\x04\x01a\x03B\x02C\x02?\x03]\x01B\x01C\x01\xc9\x02a\x01\x16\x01c\x01d\x01\x1b\x01u\x01`\x01\x17\x01L\x03\xeb\x03\xdc\x04\xed\x03\xee\x03\x1b\x01q\x01\xae\x02l\x01\x03\x01\x1b\x01o\x01u\x01l\x01\xe9\x02\xea\x02o\x01Q\x01\x16\x01`\x01\xae\x02\0\x01^\x01\xde\x02`\x01\xe0\x02\x1b\x01\xe2\x02\xe3\x02`\x01\x1b\x01^\x01\xa5\x04`\x01\xa4\x03\b\x01\xff\x02B\x01\xdc\x04`\x01\x13\x01\xbe\x04\x0f\x01\x17\x01\xbc\x03C\x01C\x01\x1a\x01\\\x01\f\x03\x88\x03\xfa\x02\x99\x03\x1b\x01\xcf\x02\xfe\x02\b\x01\x1e\x01\xd3\x02\x95\x03\x13\x01\xd2\x04B\x01\x0f\x01\xc0\x05`\x01Z\x01`\x01/\x010\x01\xdb\x04\xdc\x04\x0f\x03\x11\x01;\x02\xbc\x03\x1b\x01\x03\x01\x1e\x01`\x01\b\x016\x01=\x01\xa4\x02\0\x01A\x01\xe7\x03B\x01\x02\x01 \x03E\x01\xc0\x05G\x01B\x01\0\x01`\x01n\x01\x04\x01\x03\x01`\x01r\x01\b\x01\x13\x01$\x01/\x030\x03\x03\x03\x0e\x01\x0f\x01D\x01\xf3\x04\x12\x01\xc1\x02\x13\x01B\x01:\x03J\x03<\x03J\x03\b\x01\x1a\x01T\x03`\x01C\x01C\x03D\x03\x0e\x04Q\x03G\x03\\\x03/\x010\x01_\x03\x0e\x01q\x01l\x01\xd9\x02w\x03o\x01\x0e\x01D\x01/\x010\x01C\x01=\x01`\x01\x1b\x01\xe5\x04\x0e\x01A\x01B\x01?\x01E\x01C\x01G\x01=\x01l\x01\x0e\x04\r\x05o\x01C\x01\x1b\x01D\x01E\x01a\x01G\x01C\x01D\x01\0\0\0\x01?\x05@\x05\x0e\x01\x04\x01A\x01\x1d\x04\0\0\b\x01\x03\x01D\x01I\x05\x0e\x01}\x03\x0e\x01\x0f\x01\x88\x03#\x01\x12\x01\x83\x03`\x01\x90\x03B\x01C\x01u\x01\x1b\x01S\x04q\x013\x04b\x01\xb5\x03Q\x01\x03\x01]\x01\x92\x03\0\x01A\x01B\x01q\x01\x04\x01\x98\x03\xa1\x03<\x01\b\x01A\x01\n\x01Q\x01u\x01B\x01\x0e\x01\x0f\x01\xa3\x037\x04\x12\x01\xa6\x03B\x01\x0f\x01S\x04r\x01\x12\x01\xb7\x03\x1b\x01\x1b\x01\xaf\x03~\x05b\x01\x16\x01C\x01\\\x05\0\0E\x04\xbf\x03R\x04\xcd\x03\xce\x03\f\x01E\x04g\x04\x0e\x01Q\x01h\x05-\x01.\x01p\x01^\x04\xc5\x03h\x01\xdb\x03\xb5\x05\xb6\x05o\x01\x1b\x01\b\x01o\x01\x1f\x01q\x01`\x01A\x01\xd2\x03\x9b\x01^\x03C\x01C\x01\xd7\x03\xec\x03\xab\x03\xba\x03e\x03C\x01J\x01B\x01\r\x011\x012\x013\x01\xb1\x05\0\x01\xe5\x03A\x01]\x01\x03\x01U\x01A\x01a\x01\\\x01\xda\x05\x1c\x01\x1d\x01]\x01^\x01B\x01`\x01a\x01L\x01\n\x04H\x01\xa0\x05\xa1\x05f\x01)\x01M\x01\xcf\x03\x1a\x01o\x01\x04\x01\x01\x04\0\0\x1d\x04\b\x01V\x01s\x01\x0e\x01c\x01\x1b\x01\x05\0\x0b\x04\x07\0(\x01\x12\x01=\x01C\x01\xe3\x03@\x01[\x05o\x01\xde\x04g\x01E\x01\x18\x04\x19\x04\xc2\x05r\x01\x17\0K\x01\x04\x01\0\x01 \x04\xf3\x03\b\x01A\x01R\x010\x04&\x04`\x01A\x01\x0f\x01*\x04#\x01\x12\x01`\x01\0\x01\x16\x01\xd8\x05C\x01\x13\x018\x01\xde\x04\x1b\x01o\x01<\x01\n\x01\x1a\x01\x1b\x01;\x04A\x01E\x04\xe6\x05C\x01n\x01\0\0u\x01\\\x01<\x01\xef\x04J\x01\x0e\x01A\x01Z\x01B\x01P\x01A\x01M\x04/\x010\x01A\x01o\x01f\x04\x1c\x05\x1b\x01i\x04o\x01p\x01\xe2\x03Y\x04^\x01B\x01=\x01C\x01\xe8\x03A\x01\xea\x03r\x01A\x01D\x01E\x01`\0G\x01Z\x04|\x04}\x04o\x01A\x01\xf6\x03A\x01\0\0\0\x01h\x01\x16\x01\x1c\x05s\x04\x1f\x01U\x04o\x01o\x01\x90\x04\x1b\x01o\x01B\x01\r\x01\\\x01o\x01p\x01\x80\x04c\x01\x82\x04\x83\x04\x84\x04\x9d\x041\x012\x013\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01o\x01\x89\0X\x05q\x01p\x01A\x01\x8e\0\x8f\0\x95\x04\0\x01\xab\x04)\x01o\x018\x01o\x01\x1b\x01A\x01\x16\x01D\x01:\x05C\x01M\x01A\x01\xbc\x04A\x01\x86\x04\xa2\0\xa3\0G\x05\xa5\0\xa6\0=\x01\xa8\0X\x05@\x01\x1a\x01A\x01C\x01D\x01E\x01\0\x01\0\x01\xb2\0\xb3\0\x04\x01K\x01\xbb\x04A\x01\b\x01\x04\x01\n\x01o\x01R\x01\b\x01\x0e\x01C\x01\x1f\x01A\x01\x12\x01\x0e\x01\x0f\x01B\x01o\x01\x12\x01^\x01\xce\x04`\x01\x1b\x01b\x01c\x01o\x01\xdc\x04\xd0\0\xd1\x001\x012\x013\x01\xd5\0%\x01\xf0\x04n\x01h\x04o\x01q\x01\xe1\x04l\x04A\x01u\x01f\x01\0\x05\x1b\x01#\x01\x03\x05\xea\x04\x05\x05\x04\x01\x04\x01\xee\x04\x1b\x01\b\x01\b\x01\xe5\x04M\x01o\x01\x16\x01\xc8\x04\x0f\x01\x10\x05\xd9\x04\x12\x01\x12\x01\xfc\x04C\x01A\x01J\x01A\x01<\x01\0\x01\xe3\x04A\x01B\x01\x04\x01B\x01\b\x05\x93\x04\b\x01H\x01\n\x01\r\x05\x1b\x01C\x01\x0e\x01o\x01]\x01^\x01,\x05`\x01a\x01C\x01\x04\x01V\x01\0\0\x1b\x05\b\x01\x1b\x01\xa8\x04\\\x01 \x05B\x01\0\x01\x0f\x01\0\x01`\x01\x12\x01A\x01s\x01\x16\x01#\x01C\x01o\x01h\x01o\x01>\x05r\x01>\x05o\x01p\x01o\x015\x05C\x01\0\x01K\x014\x01N\x05;\x05V\x05W\x05\x1a\x01\xac\x05Z\x05A\x05\x03\x01<\x016\x01_\x058\x01%\x01A\x01B\x01\xd4\x04C\x01J\x01M\x05\r\x01A\x01B\x01\x1a\x01K\x01S\x05C\x01o\x01\x12\x01C\x01\0\x01Q\x01n\x05n\x01\\\x05\x1c\x01\x1d\x01]\x01^\x01H\x01`\x01a\x01d\x05E\x05U\x01(\x01h\x05\x83\x05)\x01\x13\x01e\x01m\x05\0\0V\x01\xfa\x04\0\x01\x1a\x01\x1b\x01o\x01s\x01o\x01\x16\x01\0\x01y\x05\\\x01\r\x01\x1b\x01o\x01=\x01\0\x01o\x01@\x01\x96\x05Z\x01\x0e\x05C\x01E\x01/\x010\x01\x89\x05\x1c\x01\x1d\x01K\x01\x17\x01p\x01\xa3\x05\x1a\x05\xab\x05\x1a\x01R\x01\x8f\x01=\x01%\x01)\x01\0\x01\x1a\x01$\x01r\x01D\x01E\x01\x17\x01G\x01\xa0\x05\xa1\x05\x04\x01b\x01c\x018\x01\b\x01`\x01\xa8\x053\x05\xbe\x05=\x01!\x01\x0f\x01@\x01n\x01\x12\x01\xcb\x05\xcc\x05E\x01\0\x01\xb0\x01C\x01A\x01\xb8\x05K\x01\x0e\x01\xbb\x05\xb7\x01%\x01\xb9\x01\xd3\x05R\x01\xc1\x05\xc2\x058\x01\xbf\x01\0\x01B\x01<\x01U\x01q\x01\0\x01@\x01A\x01B\x01\x1a\x01A\x01b\x01c\x01\0\x01\xce\x01\xcf\x01\xd5\x05\xea\x05\xe3\x03\xd8\x05\xd4\x01L\x01P\x01n\x01\xdd\x05\x16\x01\x1a\x01\xe0\x05C\x01\0\0a\x01\x1a\x01\xe5\x05\xe6\x05\xf3\x03\xe8\x05\xe9\x05B\x01]\x01\x1a\x01c\x01d\x01\x1b\x01H\x01a\x01\0\x01B\x01\x1b\x016\x01\x80\x058\x01\0\x01H\x01o\x01\xf6\x01\xf7\x01\xf8\x01V\x01u\x01A\x01B\x01\x04\x01\xfe\x01\x12\x01!\x01\b\x01V\x01\x92\x05\x0e\x01\x94\x05\x13\x01\x11\x01\x0f\x01a\x01\0\0\x12\x01\f\x02\x1a\x01\x0e\x02\x9e\x05\x16\x01\x1b\x01A\x01\x13\x02\x1b\x01\x15\x02\x16\x028\x01\x16\x01\0\x01\x1a\x02<\x01\x1c\x02L\x01_\x01@\x01A\x01B\x01/\x010\x01$\x02o\x01\xb5\x05\xb6\x05\0\x01o\x01(\x01`\x01\x13\x01\xbc\x05\x10\x01P\x01=\x01_\x01\n\x01\x1a\x01B\x015\x026\x02D\x01E\x01\x1b\x01G\x01o\x01C\x01=\x02\xcd\x05B\x01n\x01o\x01B\x02C\x02\x03\x01\xd4\x05\0\x01J\x01/\x010\x01C\x01\xda\x05L\x02M\x02o\x01\xde\x05\n\x01Q\x02K\x01o\x01\xe3\x05\xe4\x05=\x01\x04\x01`\x01R\x01n\x01\b\x01U\x01D\x01E\x01)\x02G\x01A\x01\x0f\x01-\x02q\x01\x12\x01A\x01o\x01p\x01\0\x01\x01\x01\x02\x01\x03\x01\0\x01\x1b\x01A\x01B\x01\b\x01\t\x01\n\x01o\x01\b\x01\r\x01\x0e\x01\x0e\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\0\0\x80\x02\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01B\x01C\x01D\x01q\x01_\x01o\x01$\x01%\x01A\x01B\x01(\x01)\x01*\x01+\x01^\x01C\x01\b\x01/\x010\x01n\x01o\x01B\x01C\x01\0\x01\x9f\x02C\x01D\x01\0\x01\x0e\x01\xa4\x02$\x01=\x01>\x01a\x01@\x01\x18\x02\x19\x02C\x01D\x01E\x01J\x01G\x01\x13\x01\x0e\x01J\x01K\x01\x13\x01\x16\x01\xb7\x02\x1a\x01o\x01\xba\x02R\x01\x1a\x01T\x01\\\x01\x16\x01\x1b\x01\xc1\x02\0\x01\xc3\x02\xc4\x02a\x01]\x01^\x01a\x01`\x01a\x01b\x01c\x01/\x010\x01\xcf\x02`\x01/\x01i\x01\xd3\x02k\x01\x13\x01\0\x01n\x01A\x01\xd9\x02q\x01=\x01\x1a\x01\0\x01u\x01=\x01\x03\x01\0\0D\x01E\x01o\x01G\x01D\x01E\x01i\x01G\x01\r\x01\x0e\x01^\x01o\x01^\x01B\x01^\x01/\x01\xf2\x02\xf3\x02`\x01u\x01\x1b\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01u\x01\x14\x01.\x01\x0e\x01=\x01A\x01\x16\x01?\x01\x03\x03Q\x01(\x01)\x01E\x01A\x01G\x01\0\x01\x0b\x03\x0e\x01\r\x03\x04\x01q\x01\x0e\x01\x16\x01\b\x01q\x01\n\x01\x02\x01J\x01\x17\x03\x0e\x01\x0f\x01=\x01\x1b\x03\x12\x01@\x01L\0B\x01C\x01D\x01E\x01u\x01`\x01\x1b\x01J\x01f\x01K\x016\x017\x018\x019\x01\x0f\x01\0\0R\x01B\x01^\x01A\x01q\x01A\x01B\x01\\\x01J\x01f\x01`\x01A\x01^\x01^\x01`\x01l\0b\x01c\x01A\x03A\x01\b\x01\x0e\x01\0\x01\x1b\x01X\x01\x1b\x01\x1b\x01\x1e\x01n\x01A\x01C\x01q\x01A\x01~\0\x0e\x01u\x01^\x01J\x01o\x01\x03\x01\x85\0\x13\x01\0\0Z\x03\x0e\x01X\x011\x01^\x03\x1a\x01`\x03a\x03o\x01A\x01\x06\x01e\x03n\x01]\x01^\x01J\x01`\x01a\x01o\x01A\x01B\x01\x1b\x01p\x03a\x01`\x01s\x03/\x010\x01g\x01\x1b\x01\x0e\x01`\x01A\x01`\x01|\x03s\x01(\x01\0\x01Z\x01\x15\x01=\x01\x04\x01\x84\x03A\x01\x1b\x01\b\x01\x88\x03\n\x01E\x01\x8b\x03G\x01\x0e\x01\x0f\x01A\x01?\x01?\x01\x10\x01g\x01\r\x01\x95\x03?\x01\x0e\x01l\x01\x03\x01\x1b\x01o\x016\x017\x018\x019\x01\x0e\x01\xa1\x03B\x01\x1c\x01\x1d\x01A\x01\x1b\x01A\x01B\x01\xd7\0`\x01\xab\x03J\x01f\x016\x01`\x01)\x01J\x01\b\x01\x16\x01\0\0`\x01q\x01\x10\x01`\x01\xb9\x03\xba\x03L\x01\xbc\x03L\x01\xbe\x03\xbf\x03\x1b\x01`\x01C\x01\x07\0=\x01J\x01\x1b\x01\x0e\x01\x14\x01J\x01Z\x01\0\x01E\x01r\x01`\x01\xcf\x03J\x01\xd1\x03K\x01\x17\0`\x01o\x01A\x01r\x01\x1c\0R\x01\x0e\x01]\x01]\x01^\x01\x13\x01`\x01a\x01\0\x01\xe2\x03\xe3\x03\x03\x01\x1a\x01J\x01\xe7\x03\xe8\x03b\x01\xea\x03\x15\x01\x0e\x01\x0e\x01\r\x01\x0e\x01\x0e\x01\x0e\x01s\x01\xf3\x03\x1b\x01n\x01\xf6\x03\x13\x01q\x01Z\x01/\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x01\0\x02\0\x03\0\x04\0\x05\0\x06\0\x07\0r\x01\x0e\x01=\x01(\x01)\x01\x1b\x01]\x01\x0e\x01\x0e\x04D\x01E\x01\x16\x01G\x01\x0f\x01\x0e\x01\0\0\x0e\x01\x17\x04a\x01\0\0\0\0o\x01b\x01b\x01=\x01^\x01o\x01@\x01\b\x01#\x04R\x01D\x01E\x01A\x01^\x01$\x01\\\x01$\x01K\x01^\x01\0\x01/\x04,\x01-\x01.\x01R\x01`\x01J\x01\b\x017\x046\x01A\x01\x16\x01\r\x01q\x01A\x01A\x01^\x016\x01`\x01B\x04b\x01c\x01E\x04]\x01G\x04\x1a\x01I\x04\x1c\x01\x1d\x01H\x01I\x01\x92\0n\x01A\x01A\x01q\x01S\x04T\x04U\x04u\x01)\x01A\x01U\x01V\x01W\x01X\x01A\x01\xa2\0\xa3\0\xa4\0\xa5\0\xa6\0A\x01\xa8\0\x93\x01\r\x01g\x04h\x04\x80\0f\x01=\x01l\x04\x1c\x04\xb2\0\xb3\0\xde\x04C\x01D\x01E\x01Z\x04\x1c\x01\x1d\x01V\x04\x8e\x01K\x01\x80\x05X\x058\x05\xab\x01\xc7\x03\t\x03R\x018\x01)\x01:\x01;\x01<\x01\x86\x04>\x01`\x02\xa4\x01A\x01B\x01\xd0\0\xd1\0\x82\x01\xff\x01b\x01\xd5\0\x92\x04\x93\x04a\x02\xcf\x03=\x01=\x02\xd2\x02@\x01\xa6\0b\x04n\x01c\0E\x01q\x01f\x03\xc0\x05\xbc\x04\x1f\x04K\x01\\\x01\x12\x05\xcf\x01\xa8\x04\xff\xff\0\0R\x01c\x01\xc6\x04\xae\x04\x07\0\xbc\x02\xff\xff\xff\xff\x0b\0\0\x01\xff\xff\xff\xff\x03\x01o\x01p\x01\xff\xffb\x01c\x01\xff\xff\xbe\x04\xbf\x04\xff\xff\r\x01\xff\xff\xff\xff\x1c\0\x11\x01\xff\xffn\x01\xc8\x04\xff\xff\x16\x01\xcb\x04\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xd2\x04\xff\xff\xd4\x04\xff\xff\xff\xff\xff\xff0\0\xd9\x04\xff\xff\xdb\x04\xdc\x04)\x01\xde\x04\xff\xff\xff\xff\xff\xff\xff\xff\xe3\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xef\x044\x01=\x01\xff\xff\xff\xff@\x01\xff\xffB\x01C\x01D\x01E\x01\xfa\x04S\0\xff\xffU\0V\0K\x01\xff\xffE\x01\xff\xff\xff\xffH\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x0e\x05\xff\xff\xff\xff\xff\xff^\x01\xff\xff`\x01\0\x01b\x01c\x01\xff\xff\x04\x01\x1a\x05\xff\xff\x1c\x05\b\x01\xff\xff\n\x01\xff\xffO\x02n\x01\x0e\x01\0\x01q\x01T\x02\x12\x01(\x05u\x01*\x05o\x01\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff3\x05\xff\xff\xff\xff\xff\xff\x13\x01|\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff\x1a\x01?\x05@\x05\xff\xff\xff\xff\xff\xff\xff\xffE\x05\xff\xff\xff\xff\xff\xffI\x05\xa2\0\xa3\0\xff\xff\xa5\0\xa6\0\xff\xff\xa8\0\x7f\x02\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xffX\x05\xff\xff\xb2\0\xb3\0\xff\xff\xff\xff\xff\xffJ\x01\xa4\x01=\x01\xff\xff\xff\xff\xbc\0\xff\xff\xff\xff\xff\xff\xff\xffE\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xa2\x02`\x01a\x01\xff\xff\xd0\0\xd1\0\xff\xff\xff\xff\xff\xff\xff\xff~\x05\xff\xff\x80\x05\x81\x05\xda\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffs\x01\xff\xff\xff\xff\xff\xff\xd0\x01\xff\xff\xff\xff\xff\xff\xd4\x01\xff\xff\x92\x05\xff\xff\x94\x05q\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9e\x05\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\xff\xff\xff\xff\xff\xff\xb1\x05\xf6\x01\xf7\x01\xf8\x01\xb5\x05\xb6\x05\r\x01\xff\xff\xff\xff\xfe\x01\xff\xff\xbc\x05\0\x01\xff\xff\xff\xff\xc0\x05\x05\x02\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\r\x02\xff\xff\xff\xff\0\0\xcd\x05&\x01\xfd\x02\x13\x01\x15\x02\x16\x02)\x01\xd4\x05\xff\xff\x1a\x02\x1a\x01\x1c\x02\xff\xff\xda\x05\xff\xff\xff\xff\xff\xff\xde\x05\xff\xff$\x02\xff\xff:\x01\xe3\x05\xe4\x05)\x02\xff\xff=\x01\xff\xff-\x02\xff\xff\xff\xff/\x01\xff\xffD\x01E\x01\xff\xff\xff\xff6\x02\0\0\xff\xffK\x01\xff\xff\xff\xff\xff\xff=\x02=\x01\x06\x01R\x01\b\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xff5\x03\xff\xffM\x02`\x01\xff\xffb\x01Q\x02\xff\xff\xff\xff\xff\xff\xff\xff@\x03\xff\xffB\x03\xff\xff\xff\xffo\x01n\x01\xff\xff\xff\xffq\x01`\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff}\x01~\x01\xff\xff\xff\xff\x81\x01\xff\xff\x83\x01\xff\xff8\x01q\x01:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xffg\x03\0\x01\xff\xff\x80\x02\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\xff\xff\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01~\x03\\\x01\x18\x01\x19\x01\x1a\x01\x83\x03\x1c\x01\x1d\x01c\x01\xff\xff\xff\xff\xff\xff\xa0\x02\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01o\x01p\x01\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xd4\x01\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xcf\x02R\x01\xbb\x03\xd2\x02\xd3\x02\xff\xff\xff\xff\xc0\x03\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xf6\x01\xf7\x01\xf8\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xfe\x01\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xf2\x02u\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\r\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x15\x02\x16\x02\x03\x03\xff\xff\xef\x03\x1a\x02\xff\xff\x1c\x02\xff\xff\xff\xff\x0b\x03\xff\xff\r\x03\xff\xff\xff\xff\0\x01\0\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x17\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\0\x006\x02\xff\xff\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff=\x02\x1a\x01\x1a\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff4\x03\xff\xff \x04\0\x01\xff\xff)\x01\xff\xff\x04\x01&\x04Q\x02\xff\xff\b\x01/\x01\n\x01\xff\xff\xff\xff\xff\xff\x0e\x01\xff\xff\xff\xff\xff\xff\x12\x01\xff\xff\xff\xff`\x02=\x01=\x01\xff\xff@\x01\xff\xff\x1b\x01\xff\xff\xff\xffE\x01E\x01\xff\xffG\x01\xff\xffZ\x03K\x01\xff\xff\xff\xff\xff\xff\xff\xff`\x03a\x03R\x01\xff\xff\xff\xff\xff\xff\x07\0\xff\xff\xff\xff\xff\xff\x0b\0\xff\xff\x80\x02\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01s\x03\xff\xff\xff\xffv\x03\xff\xff\xff\xffc\x04C\x01\x1c\0\xff\xff\xff\xffn\x01\xff\xff\xff\xffJ\x01q\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff0\0\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01\x99\x03\xff\xff\x85\x04\xff\xff\x87\x04\xff\xff\x89\x04\xff\xff\xff\xff\x8c\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffs\x01\xab\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9b\x04S\0\xff\xffU\0V\0\xff\xff\xff\xff\0\x01\xff\xff\xba\x03\xcf\x02\xbc\x03\xff\xff\xff\xff\xd3\x02\xff\xff\xff\xff\xac\x04\xad\x04\xff\xff\r\x01\xff\xff8\x01\xb2\x04:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xcf\x03A\x01B\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xf2\x02P\x01\xff\xff)\x01S\x01\xe3\x03\xce\x04\xff\xff\xff\xff\xe7\x03\x89\0\xff\xff[\x01\\\x01\xff\xff\xff\xff\xff\xff\x03\x03\xff\xff\xff\xffc\x01\xf3\x03\xff\xff=\x01\xff\xff\x0b\x03\xff\xff\r\x03\xff\xffC\x01D\x01E\x01o\x01p\x01\xff\xff\xa2\0\xa3\0K\x01\xa5\0\xa6\0\xff\xff\xa8\0\xff\xff\xff\xffR\x01\x07\0\xff\xff\xff\xff\x0e\x04\xff\xff\xff\xff\xb2\0\xb3\0\xff\xff\x10\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffb\x01\xbc\0\xff\xff\x1d\x04\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\xff\xffn\x01\xff\xff\x12\x05q\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xd0\0\xd1\0\xff\xff\x11\x013\x04\xff\xff\xff\xff \x05\x16\x01\xff\xff\xda\0\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff.\x05\xff\xff\xff\xff1\x05\xff\xff\xff\xff)\x01\xff\xff`\x03a\x03\xff\xff\xff\xff\xff\xff\xff\xff\0\x01S\x04\xff\xffU\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xffB\x01C\x01D\x01E\x01g\x04d\0\xff\xff\xff\xffU\x05K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0^\x01\xff\xff`\x01\xff\xffb\x01c\x01&\x01\x86\x04\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01n\x01>\x01`\0q\x01A\x01B\x01\xff\xffu\x01\xab\x03\xff\xff:\x01\x84\x05\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xa2\0\xa3\0\xbc\x03\xa5\0\xa6\0\xff\xff\xa8\0[\x01\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xb2\0\xb3\0\xff\xff\xff\xff\xff\xff\xcf\x03\xff\xff\xa7\x05\xa8\x05\xff\xffn\x01o\x01p\x01\x07\0\xff\xff\xaf\x05\0\x01\xff\xff\xc8\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffo\x01\xe3\x03\xff\xff\xff\xff\xff\xff\xff\xff\xd0\0\xd1\0\r\x01\xff\xff\xff\xff\xd9\x04\0\x01\xff\xff}\x01~\x01\xde\x04\xf3\x03\x81\x01\xff\xff\x83\x01\xe3\x04\xff\xff\x1c\x01\x1d\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xef\x04\xff\xff\xff\xff)\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xe2\x05\xff\xff\x0e\x04\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01)\x01>\x01\xff\xff=\x01A\x01B\x01@\x01\xff\xff\0\0\xff\xff\xff\xffE\x01\xb0\x01\xff\xff\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xb7\x01=\x01\xb9\x01S\x01@\x01R\x01\x1c\x05\xff\xffD\x01E\x01\xff\xff[\x01\\\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xffb\x01R\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xd4\x01\xff\xffo\x01p\x01n\x01^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xffS\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffE\x05Z\x04G\x05n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffg\x04\xff\xff\xf6\x01\xf7\x01\xf8\x01X\x05\xff\xffV\x01\x1c\x01\x1d\x01\xfe\x01\xa2\0\xa3\0\xff\xff\xa5\0\xa6\0\xff\xff\xa8\0\xff\xff\xff\xffg\x05)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xb2\0\xb3\0\xff\xff\xff\xff\0\0o\x01\x15\x02\x16\x02\xff\xff\xff\xff\xff\xff\x1a\x02\xff\xff\x1c\x02=\x01\x06\x01\0\x01@\x01\xff\xff\x03\x01\xff\xff\xff\xffE\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\r\x01\xd0\0\xd1\0\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff6\x02\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01=\x02\xff\xff\xff\xff\x9f\x05\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff8\x01Q\x02:\x01;\x01<\x01\xc8\x04>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff=\x01\xff\xff\xff\xff@\x01`\x02\x8f\x01C\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\xde\x04\xff\xff\x0f\x01\xff\xff\xff\xff\xff\xffR\x01\xe5\x04\xff\xff\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xd4\x01\xff\xffc\x01\xef\x04^\x01\xff\xff`\x01\x80\x02b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xffo\x01p\x01+\x01,\x01-\x01.\x01n\x01\xff\xff\xff\xffq\x01\xff\xff\xc0\x01\xff\xffu\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf5\x01\xf6\x01\xf7\x01\xf8\x01\xcc\x01\xff\xff\xff\xffC\x01\xff\xff\xfe\x01\xff\xff\0\x01H\x01I\x01\xff\xff\x1c\x05\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\xff\xff\xff\xff\xff\xffU\x01V\x01W\x01X\x01\xb7\x02\0\0\r\x01\x15\x02\x16\x02\xff\xff\xff\xff\xff\xff\x1a\x02\xff\xff\x1c\x02\xff\xff\xff\xfff\x01\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xffo\x01(\x02\xff\xff\xcf\x02\xff\xff\xff\xff\xff\xff\xd3\x02\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff6\x02\xff\xff8\x01\xff\xff:\x01;\x01<\x01=\x02>\x01\xff\xffX\x05A\x01B\x01\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xf2\x02\xff\xffg\x05\xff\xffQ\x02K\x01S\x01\xff\xff\xff\xff\0\0\xff\xff\xff\xffR\x01\xff\xff[\x01\\\x01\xff\xff\x03\x03\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xff\xff^\x01\x0b\x03`\x01\r\x03b\x01c\x01\xff\xff\x06\x01\xff\xff\0\x01o\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01L\x02\xff\xff\r\x01u\x01\xff\xff\xff\xff\xff\xff\x80\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9f\x05\x1a\x01\xff\xff\x1c\x01\x1d\x01\xd4\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\0\0>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff=\x01\xff\xff\xff\xff\xf6\x01\xf7\x01\xf8\x01\xff\xffD\x01E\x01\xff\xff\xff\xff\xfe\x01\xff\x01\xff\xffK\x01\xff\xff`\x03a\x03\xff\xff\xff\xff\xff\xffR\x01\xff\xff\\\x01\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xffc\x01\xff\xff\xff\xff\x9f\x02\x15\x02\x16\x02\xcf\x02b\x01\xff\xff\x1a\x02\xd3\x02\x1c\x02o\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\x88\x03\xff\xff\xff\xff\xff\xff\xff\xff\x8d\x03\xff\xff\xff\xff\x1e\0\x1f\0\xff\xff6\x02\xff\xff\xff\xff\xff\xff\xf2\x02\xff\xff\xff\xff=\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\x03\x03>\x01\xff\xff\xab\x03A\x01B\x01Q\x02\xff\xff\x0b\x03\xff\xff\r\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\xbc\x03\xff\xffS\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\r\x01[\x01\\\x01\xff\xffW\0X\0\xff\xff\xff\xff\xff\xffc\x01\xcf\x03\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xffo\x01p\x01\xff\xff\x80\x02\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xe3\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf3\x03\0\0=\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xffE\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xffK\x01\xff\xff`\x03a\x03\xff\xff\r\x017\x03R\x01\xff\xff\xff\xff\xff\xff\x0e\x04\xff\xff\xff\xff\xff\xff\xff\xffA\x03\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xffb\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\x86\x03\xcf\x02-\x04\xff\xff\xff\xff\xd3\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffp\x03\xff\xff\xff\xffE\x04K\x01\x06\x01\0\x01\b\x01\xff\xff\xff\xff\xff\xffR\x01|\x03\xf2\x02\xab\x03\xff\xff\xff\xffS\x04\xff\xff\r\x01\x84\x03\xff\xff\xff\xff^\x01Z\x04`\x01\xff\xffb\x01c\x01\xff\xff\x03\x03\xbc\x03\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xffg\x04\x0b\x03n\x01\r\x03\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01)\x01\xff\xff\xff\xff\xcf\x03\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\xac\x03>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff=\x01\xff\xff\xff\xff\xe3\x03\xff\xff\xff\xff\xb9\x03\xff\xffE\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01S\x01\xff\xff\xff\xff\xff\xff\xf3\x03\xff\xffR\x01\xff\xff[\x01\\\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xd1\x03c\x01\xff\xff\xd4\x03\xd5\x03\xff\xff\xff\xffb\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffo\x01p\x01\xff\xff\x0e\x04\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff`\x03a\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xc8\x04W\x01X\x01Y\x01Z\x01[\x01\\\x01]\x01^\x01_\x01`\x01a\x01b\x01c\x01d\x01e\x01f\x01g\x01h\x01i\x01j\x01k\x01\xde\x04m\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe5\x04\xff\xff\xff\xff\xff\xff\x17\x04\xff\xff\xff\xff\xff\xff{\x01\xff\xff\xef\x04\xff\xff\xff\xff\xff\xff\xff\xff\0\x01#\x04\x02\x01\x03\x01S\x04\x87\x01\xff\xff\xff\xff\b\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\x11\x01\x12\x01\x13\x01\xab\x03\xff\xff\xff\xff\xff\xffg\x04\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xffB\x04\xff\xff\xff\xff\xff\xff$\x01\xbc\x03\xff\xff\xff\xff\x1c\x05)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xcf\x03\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xffK\x01\xe3\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf3\x03]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01X\x05\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\x0e\x04\xff\xff\xc8\x04\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\xa5\x04>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xae\x04\xff\xff\xff\xff\xde\x04\xff\xff\xb3\x04\xb4\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xff\xbe\x04\xff\xff\xff\xff!\x02\xef\x04[\x01\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x02c\x01\0\x01\xff\xff.\x02\x03\x01\xff\xff1\x02\xff\xff\xff\xff\b\x01\xff\xff\n\x01o\x01p\x01\r\x01\x0e\x01\xdb\x04\xff\xff\x11\x01S\x04\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\0\0\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x05\xff\xff%\x01g\x04\xf3\x04(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffb\x02c\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x88\x02]\x01^\x01X\x05`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x018\x05\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff?\x05\xff\xffu\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffI\x05\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xc8\x04:\x01;\x01<\x01\0\x01>\x01\xff\xff\x03\x01A\x01B\x01\xff\xff\xff\xff\b\x01\xff\xff\n\x01\xff\xff\0\0\r\x01\x0e\x01\xff\xff\xff\xff\x11\x01\xde\x04\x13\x01\x14\x01\x15\x01S\x01\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01[\x01\\\x01\xff\xff\xff\xff\xff\xff\xef\x04\xff\xff%\x01c\x01~\x05(\x01)\x01\x81\x05\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xe8\x02o\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x05\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xb1\x05\x12\x03\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff6\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffX\x05\xff\xff\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xffn\x03(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01?\x01@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\xff\xfff\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\0\0n\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\x04\x01\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xda\x03\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\xff\xfff\x01g\x01\0\0i\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xffr\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01~\x04\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xaf\x04\xb0\x04\xb1\x04u\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\x04\x01\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\x04\x01\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\xff\xff\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\x04\x01\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\0\0\xff\xff\xff\xfff\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\x04\x01\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\0\0\xff\xff\xff\xfff\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff4\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01\xff\xff\xff\xffi\x01j\x01k\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff4\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01\xff\xff\xff\xffi\x01j\x01k\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\0\0\xff\xff\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\0\0\xff\xff\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01\xff\xff\xff\xffX\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xff\0\0D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\t\x01\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\0\0D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\0\x01\xff\xffq\x01\x03\x01\xff\xff\xff\xffu\x01\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\0\0\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\xff\xff\x03\x01i\x01\xff\xffk\x01\xff\xff\b\x01n\x01\n\x01\xff\xffq\x01\r\x01\x0e\x01\xff\xffu\x01\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\xff\xff\x03\x01i\x01\xff\xffk\x01\xff\xff\b\x01n\x01\n\x01\xff\xffq\x01\r\x01\x0e\x01\xff\xffu\x01\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\xff\xff\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\xff\xff\x03\x01i\x01\xff\xffk\x01\xff\xff\b\x01n\x01\n\x01\xff\xffq\x01\r\x01\x0e\x01\xff\xffu\x01\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\0\0@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\0\0\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\xff\xff\x03\x01i\x01\xff\xffk\x01\xff\xff\b\x01n\x01\n\x01\xff\xffq\x01\r\x01\x0e\x01\xff\xffu\x01\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\xff\xff\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\0\x01q\x01\x02\x01\x03\x01\x04\x01u\x01\xff\xff\xff\xff\b\x01\0\x01\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01$\x01\x1c\x01\x1d\x01\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x018\x01)\x01:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff=\x01\xff\xff\xff\xff@\x01A\x01\xff\xffC\x01D\x01E\x01=\x01G\x01\0\0@\x01J\x01K\x01\xff\xffD\x01E\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xffK\x01\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01c\x01]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xfff\x01^\x01o\x01p\x01\xff\xffb\x01c\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\0\x01\xff\xffu\x01\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\xff\xff\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\0\x01q\x01\x02\x01\x03\x01\x04\x01u\x01\xff\xff\xff\xff\b\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xff\xff\xff\b\x01n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xffu\x01\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\xff\xff\0\x01f\x01\x02\x01\x03\x01\x04\x01\xff\xff\xff\xff\xff\xff\b\x01n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xffu\x01\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\xff\xff\xff\xfff\x01\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xffn\x01\b\x01\xff\xffq\x01\xff\xff\xff\xff\r\x01u\x01\xff\xff\xff\xff\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xff\xff\xff\b\x01n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xffu\x01\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xff\0\0\b\x01n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xffu\x01\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xffn\x01\b\x01\xff\xffq\x01\xff\xff\xff\xff\r\x01u\x01\xff\xff\xff\xff\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\0\0G\x01\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xff\xff\xff\b\x01n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xffu\x01\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\r\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\0\0R\x01\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01\xff\xff\x03\x01q\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01=\x01\xff\xffq\x01@\x01\xff\xff\xff\xffu\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\0\x01u\x01\xff\xff\x03\x01\xff\xff\x05\x01\x06\x01\x07\x01\b\x01\xff\xff\xff\xff\x0b\x01\f\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff$\x01\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x011\x012\x013\x014\x015\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xffD\x01E\x01F\x01G\x01H\x01I\x01\xff\xffK\x01L\x01M\x01N\x01\0\0P\x01\xff\xffR\x01S\x01\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff[\x01\xff\xff]\x01^\x01_\x01\xff\xffa\x01b\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01m\x01n\x01o\x01p\x01q\x01\xff\xff\xff\xfft\x01\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\0\0R\x01\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01n\x01o\x01\x05\x01\x06\x01\x07\x01\xff\xfft\x01\xff\xff\x0b\x01\f\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xffV\x01W\x01\0\0Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01n\x01o\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x001\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\0\0l\x01m\x01n\x01o\x01\xff\xff\xff\xff\0\x01\xff\xfft\x01\xff\xff\x04\x01\xff\xff\x06\x01\xff\xff\b\x01\xff\xff\n\x01\xff\xff\f\x01\r\x01\x0e\x01\x0f\x01\xff\xff\x11\x01\x12\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x015\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xff\0\0H\x01\xff\xffJ\x01K\x01\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xffR\x01S\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xffn\x01o\x01p\x01\xff\xff\0\x01s\x01\xff\xff\xff\xff\x04\x01\xff\xff\x06\x01\xff\xff\b\x01\xff\xff\n\x01\xff\xff\f\x01\xff\xff\x0e\x01\x0f\x01\0\0\x11\x01\x12\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01C\x01\xff\xff\xff\xff\xff\xff\xff\xffH\x01\xff\xffJ\x01\0\0\0\x01M\x01\xff\xff\x03\x01\x04\x01\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\r\x01\x0e\x01[\x01\xff\xff]\x01^\x01\x13\x01`\x01a\x01\xff\xffc\x01\xff\xff\xff\xff\x1a\x01g\x01\x1c\x01\x1d\x01j\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xffs\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\x04\x01@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\r\x01\x0e\x01\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01R\x01\xff\xff\xff\xff\xff\xff\b\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff^\x01\xff\xff`\x01\x13\x01b\x01c\x01\x16\x01\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\0\0\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff8\x01)\x01:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\x04\x01@\x01\xff\xffB\x01C\x01D\x01E\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xffK\x01\\\x01\xff\xff\x13\x01\xff\xff\xff\xffQ\x01R\x01c\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff^\x01o\x01p\x01\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\x04\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\r\x01\x0e\x01\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\0\0\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\0\x01n\x01\xff\xff\x03\x01q\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xffK\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01=\x01\x03\x01q\x01\xff\xffA\x01\xff\xffC\x01D\x01E\x01\0\0\xff\xff\r\x01\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xffb\x01c\x01)\x01\xff\xfff\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\xff\xff\xff\xffA\x01\xff\xffC\x01D\x01E\x01\xff\xff\xff\xff\r\x01\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xffb\x01c\x01)\x01\xff\xfff\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01=\x01\xff\xff\x03\x01\xff\xffA\x01\xff\xffC\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\r\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\x13\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xffb\x01c\x01(\x01)\x01f\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\xff\xff\xff\xff=\x01\0\0\b\x01@\x01\xff\xff\xff\xff\xff\xff\r\x01E\x01\xff\xffG\x01\0\0\xff\xff\x13\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01R\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff)\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xffJ\x01K\x01\0\x01\xff\xff\xff\xff\x03\x01\xff\xff\xff\xffR\x01\xff\xff\b\x01\0\0\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\0\x01^\x01\x13\x01\x03\x01\xff\xffb\x01c\x01\xff\xff\b\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\r\x01\xff\xff\xff\xff\xff\xffn\x01\xff\xff\x13\x01q\x01\xff\xff\xff\xff\xff\xff)\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\0\0\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01R\x01\0\0C\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xffJ\x01K\x01\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01R\x01\xff\xff\xff\xfff\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01^\x01\x03\x01q\x01\xff\xffb\x01\xff\xff\b\x01\xff\xfff\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\xff\xffn\x01\x13\x01\xff\xffq\x01\xff\xff\xff\xff\0\0\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xffK\x01@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffS\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\0\x01[\x01\\\x01\x03\x01R\x01\0\0`\x01\xff\xff\b\x01c\x01\0\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\x13\x01b\x01o\x01p\x01\r\x01f\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\0\0\xff\xffC\x01D\x01E\x01\xff\xff=\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\0\x01E\x01\xff\xff\x03\x01R\x01\xff\xff\xff\xffK\x01\b\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01R\x01\xff\xff^\x01\xff\xff\xff\xff\x13\x01b\x01\xff\xff\xff\xff\xff\xfff\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01b\x01\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01n\x01\xff\xff\xff\xffq\x01\0\0\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01K\x01\x1a\x01\x03\x01\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff)\x01\xff\xff\x13\x01^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff\0\0n\x01=\x01\xff\xffq\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xffE\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01K\x01\xff\xff\x03\x01\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xffb\x01K\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xffn\x01\xff\xffX\x01q\x01\0\0)\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01=\x01\x03\x01q\x01@\x01\xff\xff\xff\xff\b\x01D\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01=\x01\xff\xff\x03\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\xff\xff\r\x01\xff\xffK\x01\xff\xff\xff\xff\xff\xff\x13\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\0\0b\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\0\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xffK\x01\r\x01\xff\xff\x13\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff^\x01\xff\xff\xff\xff\0\0b\x01c\x01)\x01\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\xff\xff@\x01=\x01\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01E\x01\xff\xffK\x01\xff\xff\xff\xff\x13\x01K\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01R\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\0\0b\x01c\x01)\x01\xff\xffb\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01\xff\xff\xff\xffq\x01n\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\0\x01D\x01E\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xffK\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\r\x01\xff\xffR\x01\0\0\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\x1a\x01^\x01\x1c\x01\x1d\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff)\x01\xff\xffn\x01=\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffE\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\0\x01\xff\xff=\x01\x03\x01\xff\xff@\x01R\x01\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xffb\x01R\x01\0\0\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xffn\x01^\x01\xff\xffq\x01\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\b\x01\0\x01\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\0\0K\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\0\0\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff)\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01=\x01\xff\xffq\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01=\x01\xff\xff\r\x01@\x01\xff\xffK\x01\xff\xffD\x01E\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xffK\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xffn\x01\0\0\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01=\x01\x03\x01q\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\0\0K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\0\0\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\0\x01\xff\xffE\x01\x03\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01^\x01\x1c\x01\x1d\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01(\x01)\x01@\x01n\x01\xff\xff\0\x01q\x01E\x01\x03\x01\0\0\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\0\0R\x01=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\x1a\x01^\x01\x1c\x01\x1d\x01K\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff(\x01)\x01\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff^\x01\0\x01\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\b\x01\0\x01\xff\xff=\x01\xff\xff\r\x01@\x01n\x01\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xffK\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\0\0R\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff)\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01=\x01\xff\xff\xff\xff@\x01\xff\xffK\x01C\x01D\x01E\x01\xff\xff\xff\xff\0\0R\x01\xff\xffK\x01\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01R\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\r\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\0\x01n\x01\xff\xff\x03\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xffn\x01\0\0\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff=\x01\xff\xff)\x01@\x01\xff\xff\xff\xff\xff\xff\xff\xffE\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xffK\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xffR\x01=\x01\xff\xff)\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xffK\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xffR\x01=\x01\xff\xff\xff\xff@\x01\xff\xffn\x01\xff\xffD\x01E\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xffK\x01b\x01c\x01\0\0\0\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01n\x01\0\x01\xff\xff\xff\xff\r\x01\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\0\0\xff\xff\r\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\0\0n\x01\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff=\x01\xff\xff\xff\xff@\x01K\x01\xff\xff\0\x01D\x01E\x01\x03\x01\xff\xffR\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xffR\x01\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\x1a\x01^\x01\x1c\x01\x1d\x01\xff\xffb\x01c\x01n\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xffn\x01\xff\xff8\x01\xff\xff:\x01;\x01<\x01\0\x01>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\xff\xff\xff\xffE\x01\xff\xff\xff\xffS\x01\xff\xff\xff\xffK\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01[\x01\\\x01R\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\0\x01\xff\xff)\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01o\x01p\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01=\x01\xff\xff\xff\xff@\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xffR\x01\0\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\r\x01\xff\xffb\x01c\x01=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xff\xff\xffE\x01\x1a\x01n\x01\x1c\x01\x1d\x01\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xffn\x01\0\x01\xff\xffE\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01K\x01\0\x01\xff\xff\xff\xff\xff\xff\r\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\x1a\x01^\x01\x1c\x01\x1d\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01=\x01\xff\xff)\x01@\x01n\x01\xff\xff\xff\xff\xff\xffE\x01\xff\xff\xff\xff)\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xff\xff\xffE\x01=\x01\xff\xff^\x01@\x01\xff\xffK\x01b\x01c\x01E\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xffK\x01\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\0\x01n\x01\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\b\x01\xff\xffn\x01\x0b\x01\f\x01\r\x01\x0e\x01\xff\xff\xff\xff\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x011\x012\x013\x014\x015\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01C\x01\xff\xffE\x01F\x01G\x01H\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xffR\x01S\x01\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff[\x01\xff\xff\xff\xff^\x01_\x01\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01m\x01n\x01o\x01p\x01q\x01\xff\xff\xff\xfft\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\x0f\x01\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff$\x01\xff\xff\xff\xff'\x01\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xff\xff\xffd\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\0\x01\x01\x01\x02\x01\xff\xfft\x01\x05\x01\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff$\x01\xff\xff\xff\xff'\x01\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xff\xff\xffd\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\0\x01\x01\x01\x02\x01\xff\xfft\x01\x05\x01\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff$\x01\xff\xff\xff\xff'\x01\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffd\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\0\x01l\x01m\x01\xff\xffo\x01\x05\x01\x06\x01\x07\x01\b\x01t\x01\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x011\x012\x013\x014\x015\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01G\x01H\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff[\x01\xff\xff\xff\xff\xff\xff_\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01m\x01\xff\xffo\x01p\x01q\x01\0\x01\xff\xfft\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\0\x01Y\x01\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01`\x01\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\0\x01Y\x01\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01`\x01\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\0\x01Y\x01\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01`\x01\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\x03\x01\x04\x01\x05\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\x0b\x01\xff\xff\r\x01l\x01m\x01\xff\xffo\x01\xff\xff\x13\x01\x14\x01\x15\x01t\x01\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\x1e\x01\xff\xff \x01!\x01\"\x01#\x01\xff\xff\xff\xff\xff\xff'\x01(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff5\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff@\x01A\x01\xff\xff\xff\xff\xff\xff\xff\xffF\x01G\x01\xff\xff\xff\xff\xff\xffK\x01L\x01\xff\xffN\x01\xff\xffP\x01Q\x01R\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffZ\x01\xff\xff\xff\xff\xff\xff\xff\xff_\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffe\x01\0\x01\xff\xffh\x01i\x01\x04\x01k\x01l\x01m\x01n\x01o\x01\xff\xffq\x01r\x01s\x01t\x01u\x01\xff\xff\x11\x01\xff\xff\x13\x01\xff\xff\xff\xff\x16\x01\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff\xff\xffA\x01\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\f\x01\\\x01]\x01\x0f\x01\x10\x01\xff\xffa\x01\xff\xffc\x01\xff\xff\xff\xfff\x01\xff\xff\xff\xff\xff\xff\x1b\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01o\x01\xff\xffq\x01\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xffc\x01d\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xffc\x01d\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xffn\x01o\x01p\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xffc\x01d\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xffn\x01o\x01p\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xffc\x01d\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xffn\x01o\x01p\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff\0\x01A\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01I\x01\xff\xffK\x01\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01`\x01\xff\xff\xff\xffc\x01d\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\0\x01A\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\0\x01A\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\xff\xff\xff\xff\xff\xff\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\r\x01\x0e\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff[\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xffb\x01\xff\xff\x0b\x01\f\x01\r\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01n\x01o\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xffb\x01\x0b\x01\f\x01\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01n\x01o\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\xff\xff^\x01\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\n\x01\x0b\x01\f\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\xff\xff\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\x1a\x01\xff\xff\xff\xfft\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\x1a\x01\xff\xff\xff\xfft\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\f\x01\xff\xff\x0e\x01\xff\xffg\x01\x11\x01\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\x1b\x01\xff\xfft\x01\x1e\x01\x1f\x018\x01\xff\xff:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xffS\x01<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01[\x01\\\x01\xff\xff\xff\xff\xff\xffH\x01\x06\x01\xff\xffc\x01\xff\xffM\x01\xff\xff\f\x01\xff\xff\x0e\x01\xff\xffS\x01\x11\x01\xff\xffV\x01o\x01p\x01\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\x06\x01\xff\xff\xff\xff\xff\xffM\x01\xff\xff\f\x01\xff\xff\x0e\x01\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\x06\x01\xff\xff\xff\xff\xff\xffM\x01\xff\xff\f\x01\xff\xff\x0e\x01\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xffJ\x01\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xffJ\x01\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\xff\xff\xff\xff\xff\xff\x06\x01M\x01\xff\xff\xff\xff\n\x01\xff\xff\f\x01\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xff\x1c\x01c\x01\x1e\x01\x1f\x01\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\x06\x01\xff\xff\b\x01\xff\xffM\x01\xff\xff\f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\xff\xff\xff\xff\xff\xff\x06\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\f\x01\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff_\x01\xff\xff\xff\xff\x1c\x01c\x01\x1e\x01\x1f\x01\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\x06\x01\x07\x01\xff\xff\xff\xffM\x01\x0b\x01\f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\x16\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1e\x01\x1f\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffY\x01\xff\xff[\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xffc\x01d\x01\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffY\x01\xff\xff[\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x011\x012\x013\x01\xff\xff\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffY\x01\xff\xff\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x011\x012\x013\x01\xff\xff\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\xff\xff\xff\xff\xff\xffY\x01\xff\xff\xff\xff\x0f\x01\x1e\x01\x1f\x018\x01\xff\xff:\x01;\x01<\x01\x17\x01>\x01\xff\xffg\x01A\x01B\x01\xff\xff\x1e\x01l\x01\xff\xff\xff\xffo\x011\x012\x013\x01\xff\xff\xff\xff6\x017\x018\x019\x01\xff\xffS\x01<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01[\x01\\\x01\xff\xff8\x01\xff\xff:\x01;\x01<\x01c\x01>\x01M\x01N\x01A\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01n\x01o\x01p\x01Y\x01\xff\xff\xff\xff\x0f\x01\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffg\x01Z\x01[\x01\\\x01\x1e\x01l\x01\xff\xff\xff\xffo\x01\xff\xffc\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\t\x01\xff\xff\xff\xffS\x01\xff\xff\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\xff\xff[\x01\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01l\x01\xff\xff\xff\xffo\x01p\x01*\x01+\x01,\x01-\x01.\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\xff\xff\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\x01\x10\x01\xff\xff\xff\xff\xff\xffC\x01\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01T\x01U\x01V\x01W\x01X\x01*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff`\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfff\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\t\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\x0f\x01\x10\x01\xff\xff\x12\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x01\x02\x01d\x01$\x01f\x01\xff\xff\xff\xff\xff\xff\t\x01*\x01+\x01,\x01-\x01.\x01\x0f\x01\x10\x01\xff\xff\x12\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01$\x01\xff\xff\xff\xff\xff\xffH\x01I\x01*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\x01\x01\x01\x02\x01a\x01\xff\xffC\x01\xff\xff\xff\xfff\x01\t\x01H\x01I\x01\xff\xff\xff\xff\xff\xff\x0f\x01\x10\x01\xff\xff\x12\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\x1b\x01\xff\xff\xff\xff\xff\xff]\x01\xff\xff\x01\x01\x02\x01\xff\xff$\x01\xff\xff\xff\xff\xff\xfff\x01\t\x01*\x01+\x01,\x01-\x01.\x01\x0f\x01\x10\x01\xff\xff\x12\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x19\x01\xff\xff\x1b\x01\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01$\x01\xff\xff\xff\xff\xff\xffH\x01I\x01*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01>\x01\x01\x01\x02\x01\xff\xff\xff\xffC\x01\xff\xff\xff\xfff\x01\t\x01H\x01I\x01\xff\xff\xff\xff\xff\xff\x0f\x01\x10\x01\xff\xff\x12\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x01\x02\x01\xff\xff$\x01\xff\xff\xff\xff\xff\xfff\x01\t\x01*\x01+\x01,\x01-\x01.\x01\x0f\x01\x10\x01\xff\xff\x12\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01$\x01\xff\xff\xff\xff\xff\xffH\x01I\x01*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\x01\x01\x01\x02\x01\xff\xff\xff\xffC\x01\xff\xff\xff\xfff\x01\t\x01H\x01I\x01\xff\xff\xff\xff\xff\xff\x0f\x01\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x01\x02\x01\xff\xff$\x01\xff\xff\xff\xff\xff\xfff\x01\t\x01*\x01+\x01,\x01-\x01.\x01\x0f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01$\x01\xff\xff\xff\xff\xff\xffH\x01I\x01*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01>\x01\x01\x01\x02\x01\xff\xff\xff\xffC\x01\xff\xff\xff\xfff\x01\t\x01H\x01I\x01\xff\xff\xff\xff\xff\xff\x0f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff$\x01\xff\xff\xff\xff\xff\xfff\x01\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01\x0f\x01\xff\xff\xff\xff\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xfff\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\xff\xff>\x01>\x01\xff\xffA\x01B\x01\xff\xffC\x01\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffU\x01V\x01W\x01X\x01\xff\xff[\x01\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xfff\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffo\x01p\x01",
  error_function: Parsing.parse_error,
  names_const: "AMPERAMPER\0AMPERSAND\0AND\0AS\0ASSERT\0BACKQUOTE\0BANG\0BAR\0BARBAR\0BARRBRACKET\0BEGIN\0CLASS\0COLON\0COLONCOLON\0COLONEQUAL\0COLONGREATER\0COMMA\0CONSTRAINT\0DO\0DONE\0DOT\0DOTDOT\0DOWNTO\0ELSE\0END\0EOF\0EQUAL\0EXCEPTION\0EXTERNAL\0FALSE\0FOR\0FUN\0FUNCTION\0FUNCTOR\0GREATER\0GREATERRBRACE\0GREATERRBRACKET\0IF\0IN\0INCLUDE\0INHERIT\0INITIALIZER\0LAZY\0LBRACE\0LBRACELESS\0LBRACKET\0LBRACKETBAR\0LBRACKETLESS\0LBRACKETGREATER\0LBRACKETPERCENT\0LBRACKETPERCENTPERCENT\0LESS\0LESSMINUS\0LET\0LPAREN\0LBRACKETAT\0LBRACKETATAT\0LBRACKETATATAT\0MATCH\0METHOD\0MINUS\0MINUSDOT\0MINUSGREATER\0MODULE\0MUTABLE\0NEW\0NONREC\0OBJECT\0OF\0OPEN\0OR\0PERCENT\0PLUS\0PLUSDOT\0PLUSEQ\0PRIVATE\0QUESTION\0QUOTE\0RBRACE\0RBRACKET\0REC\0RPAREN\0SEMI\0SEMISEMI\0SHARP\0SIG\0STAR\0STRUCT\0THEN\0TILDE\0TO\0TRUE\0TRY\0TYPE\0UNDERSCORE\0VAL\0VIRTUAL\0WHEN\0WHILE\0WITH\0EOL\0",
  names_block: "CHAR\0FLOAT\0INFIXOP0\0INFIXOP1\0INFIXOP2\0INFIXOP3\0INFIXOP4\0INT\0INT32\0INT64\0LABEL\0LIDENT\0NATIVEINT\0OPTLABEL\0PREFIXOP\0SHARPOP\0STRING\0UIDENT\0COMMENT\0DOCSTRING\0"
end;

function implementation(lexfun, lexbuf) do
  return Parsing.yyparse(yytables, 1, lexfun, lexbuf);
end end

function type_of_directive(x) do
  if (typeof x == "number") then do
    return --[[ Dir_type_null ]]4;
  end else do
    local ___conditional___=(x.tag | 0);
    do
       if ___conditional___ == 0--[[ Dir_bool ]] then do
          return --[[ Dir_type_bool ]]0; end end 
       if ___conditional___ == 1--[[ Dir_float ]] then do
          return --[[ Dir_type_float ]]1; end end 
       if ___conditional___ == 2--[[ Dir_int ]] then do
          return --[[ Dir_type_int ]]2; end end 
       if ___conditional___ == 3--[[ Dir_string ]] then do
          return --[[ Dir_type_string ]]3; end end 
      
    end
  end end 
end end

function string_of_type_directive(x) do
  local ___conditional___=(x);
  do
     if ___conditional___ == 0--[[ Dir_type_bool ]] then do
        return "bool"; end end 
     if ___conditional___ == 1--[[ Dir_type_float ]] then do
        return "float"; end end 
     if ___conditional___ == 2--[[ Dir_type_int ]] then do
        return "int"; end end 
     if ___conditional___ == 3--[[ Dir_type_string ]] then do
        return "string"; end end 
     if ___conditional___ == 4--[[ Dir_type_null ]] then do
        return "nil"; end end 
    
  end
end end

__Error_4 = Caml_exceptions.create("Ocaml_typedtree_test.Lexer.Error");

function assert_same_type(lexbuf, x, y) do
  lhs = type_of_directive(x);
  rhs = type_of_directive(y);
  if (lhs ~= rhs) then do
    error({
      __Error_4,
      --[[ Conditional_expr_expected_type ]]Block.__(7, {
          lhs,
          rhs
        }),
      curr(lexbuf)
    })
  end
   end 
  return y;
end end

directive_built_in_values = Hashtbl.create(undefined, 51);

Hashtbl.replace(directive_built_in_values, "OCAML_VERSION", --[[ Dir_string ]]Block.__(3, {Sys.ocaml_version}));

tmp;

exit = 0;

i;

xpcall(function() do
  i = __String.rindex(Sys.ocaml_version, --[[ "+" ]]43);
  exit = 1;
end end,function(exn_1) do
  if (exn_1 == Caml_builtin_exceptions.not_found) then do
    tmp = "";
  end else do
    error(exn_1)
  end end 
end end)

if (exit == 1) then do
  tmp = __String.sub(Sys.ocaml_version, i + 1 | 0, (#Sys.ocaml_version - i | 0) - 1 | 0);
end
 end 

v = --[[ Dir_string ]]Block.__(3, {tmp});

Hashtbl.replace(directive_built_in_values, "OCAML_PATCH", v);

Hashtbl.replace(directive_built_in_values, "OS_TYPE", --[[ Dir_string ]]Block.__(3, {Sys.os_type}));

Hashtbl.replace(directive_built_in_values, "BIG_ENDIAN", --[[ Dir_bool ]]Block.__(0, {Sys.big_endian}));

Hashtbl.replace(directive_built_in_values, "WORD_SIZE", --[[ Dir_int ]]Block.__(2, {Sys.word_size}));

function semantic_version_parse(str, start, last_index) do
  aux = function(_start, _acc, last_index) do
    while(true) do
      acc = _acc;
      start = _start;
      if (start <= last_index) then do
        c = str.charCodeAt(start);
        if (c == --[[ "." ]]46) then do
          return --[[ tuple ]]{
                  acc,
                  start + 1 | 0
                };
        end else do
          v = c - --[[ "0" ]]48 | 0;
          if (v >= 0 and v <= 9) then do
            _acc = Caml_int32.imul(acc, 10) + v | 0;
            _start = start + 1 | 0;
            ::continue:: ;
          end else do
            return --[[ tuple ]]{
                    acc,
                    start
                  };
          end end 
        end end 
      end else do
        return --[[ tuple ]]{
                acc,
                start
              };
      end end 
    end;
  end end;
  match = aux(start, 0, last_index);
  match_1 = aux(match[1], 0, last_index);
  match_2 = aux(match_1[1], 0, last_index);
  patch_end = match_2[1];
  additional = __String.sub(str, patch_end, (last_index - patch_end | 0) + 1 | 0);
  return --[[ tuple ]]{
          --[[ tuple ]]{
            match[0],
            match_1[0],
            match_2[0]
          },
          additional
        };
end end

function defined(str) do
  val;
  xpcall(function() do
    val = Hashtbl.find(directive_built_in_values, str);
  end end,function(exn) do
    xpcall(function() do
      Caml_sys.caml_sys_getenv(str);
      return true;
    end end,function(exn_1) do
      return false;
    end end)
  end end)
  if (typeof val == "number") then do
    return false;
  end else do
    return true;
  end end 
end end

function query(loc, str) do
  v;
  xpcall(function() do
    v = Hashtbl.find(directive_built_in_values, str);
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      exit = 0;
      v_1;
      xpcall(function() do
        v_1 = Caml_sys.caml_sys_getenv(str);
        exit = 2;
      end end,function(exn_1) do
        if (exn_1 == Caml_builtin_exceptions.not_found) then do
          return --[[ Dir_bool ]]Block.__(0, {false});
        end else do
          error(exn_1)
        end end 
      end end)
      if (exit == 2) then do
        xpcall(function() do
          return --[[ Dir_bool ]]Block.__(0, {Pervasives.bool_of_string(v_1)});
        end end,function(exn_2) do
          xpcall(function() do
            return --[[ Dir_int ]]Block.__(2, {Caml_format.caml_int_of_string(v_1)});
          end end,function(exn_3) do
            xpcall(function() do
              return --[[ Dir_float ]]Block.__(1, {Caml_format.caml_float_of_string(v_1)});
            end end,function(exn_4) do
              return --[[ Dir_string ]]Block.__(3, {v_1});
            end end)
          end end)
        end end)
      end
       end 
    end else do
      error(exn)
    end end 
  end end)
  if (typeof v == "number") then do
    return --[[ Dir_bool ]]Block.__(0, {false});
  end else do
    return v;
  end end 
end end

function value_of_token(loc, t) do
  if (typeof t == "number") then do
    local ___conditional___=(t);
    do
       if ___conditional___ == 29--[[ FALSE ]] then do
          return --[[ Dir_bool ]]Block.__(0, {false}); end end 
       if ___conditional___ == 91--[[ TRUE ]] then do
          return --[[ Dir_bool ]]Block.__(0, {true}); end end 
      error({
          __Error_4,
          --[[ Unexpected_token_in_conditional ]]4,
          loc
        })
        
    end
  end else do
    local ___conditional___=(t.tag | 0);
    do
       if ___conditional___ == 1--[[ FLOAT ]] then do
          return --[[ Dir_float ]]Block.__(1, {Caml_format.caml_float_of_string(t[0])}); end end 
       if ___conditional___ == 7--[[ INT ]] then do
          return --[[ Dir_int ]]Block.__(2, {t[0]}); end end 
       if ___conditional___ == 16--[[ STRING ]] then do
          return --[[ Dir_string ]]Block.__(3, {t[0][0]}); end end 
       if ___conditional___ == 17--[[ UIDENT ]] then do
          return query(loc, t[0]); end end 
      error({
          __Error_4,
          --[[ Unexpected_token_in_conditional ]]4,
          loc
        })
        
    end
  end end 
end end

function directive_parse(token_with_comments, lexbuf) do
  look_ahead = do
    contents: undefined
  end;
  token = function(param) do
    v = look_ahead.contents;
    if (v ~= undefined) then do
      look_ahead.contents = undefined;
      return v;
    end else do
      _param = --[[ () ]]0;
      while(true) do
        t = Curry._1(token_with_comments, lexbuf);
        if (typeof t == "number") then do
          local ___conditional___=(t);
          do
             if ___conditional___ == 25--[[ EOF ]] then do
                error({
                  __Error_4,
                  --[[ Unterminated_if ]]2,
                  curr(lexbuf)
                }) end end 
             if ___conditional___ == 100--[[ EOL ]] then do
                _param = --[[ () ]]0;
                ::continue:: ; end end 
            return t;
              
          end
        end else do
          local ___conditional___=(t.tag | 0);
          do
             if ___conditional___ == 18--[[ COMMENT ]]
             or ___conditional___ == 19--[[ DOCSTRING ]] then do
                _param = --[[ () ]]0;
                ::continue:: ; end end 
            return t;
              
          end
        end end 
      end;
    end end 
  end end;
  push = function(e) do
    if (look_ahead.contents ~= undefined) then do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "lexer.mll",
          312,
          4
        }
      })
    end
     end 
    look_ahead.contents = e;
    return --[[ () ]]0;
  end end;
  token_op = function(calc, no, lhs) do
    op = token(--[[ () ]]0);
    exit = 0;
    if (typeof op == "number") then do
      local ___conditional___=(op);
      do
         if ___conditional___ == 26--[[ EQUAL ]]
         or ___conditional___ == 34--[[ GREATER ]]
         or ___conditional___ == 51--[[ LESS ]] then do
            exit = 1; end else 
         end end
        return Curry._1(no, op);
          
      end
    end else if (op.tag == --[[ INFIXOP0 ]]2) then do
      local ___conditional___=(op[0]);
      do
         if ___conditional___ == "=~" then do
            if (calc) then do
              if (typeof lhs ~= "number" and lhs.tag == --[[ Dir_string ]]3) then do
                curr_loc = curr(lexbuf);
                rhs = value_of_token(curr_loc, token(--[[ () ]]0));
                exit_1 = 0;
                if (typeof rhs == "number" or rhs.tag ~= --[[ Dir_string ]]3) then do
                  exit_1 = 3;
                end else do
                  loc = curr_loc;
                  lhs_1 = lhs[0];
                  str = rhs[0];
                  last_index = #str - 1 | 0;
                  if (last_index < 0) then do
                    error({
                      __Error_4,
                      --[[ Illegal_semver ]]Block.__(6, {str}),
                      loc
                    })
                  end
                   end 
                  v = str.charCodeAt(0);
                  match;
                  exit_2 = 0;
                  if (v ~= 94) then do
                    if (v >= 63) then do
                      if (v ~= 126) then do
                        exit_2 = 1;
                      end else do
                        match = --[[ tuple ]]{
                          --[[ Approximate ]]-617782220,
                          semantic_version_parse(str, 1, last_index)
                        };
                      end end 
                    end else if (v >= 60) then do
                      local ___conditional___=(v - 60 | 0);
                      do
                         if ___conditional___ == 0 then do
                            if (last_index == 0) then do
                              error({
                                __Error_4,
                                --[[ Illegal_semver ]]Block.__(6, {str}),
                                loc
                              })
                            end
                             end 
                            match = str[1] == "=" and --[[ tuple ]]{
                                --[[ Le ]]17049,
                                semantic_version_parse(str, 2, last_index)
                              } or --[[ tuple ]]{
                                --[[ Lt ]]17064,
                                semantic_version_parse(str, 1, last_index)
                              }; end else 
                         if ___conditional___ == 1 then do
                            exit_2 = 1; end else 
                         if ___conditional___ == 2 then do
                            if (last_index == 0) then do
                              error({
                                __Error_4,
                                --[[ Illegal_semver ]]Block.__(6, {str}),
                                loc
                              })
                            end
                             end 
                            match = str[1] == "=" and --[[ tuple ]]{
                                --[[ Ge ]]15934,
                                semantic_version_parse(str, 2, last_index)
                              } or --[[ tuple ]]{
                                --[[ Gt ]]15949,
                                semantic_version_parse(str, 1, last_index)
                              }; end else 
                         end end end end end end
                        
                      end
                    end else do
                      exit_2 = 1;
                    end end  end 
                  end else do
                    match = --[[ tuple ]]{
                      --[[ Compatible ]]785637236,
                      semantic_version_parse(str, 1, last_index)
                    };
                  end end 
                  if (exit_2 == 1) then do
                    match = --[[ tuple ]]{
                      --[[ Exact ]]172069535,
                      semantic_version_parse(str, 0, last_index)
                    };
                  end
                   end 
                  version = match[1][0];
                  major = version[0];
                  pred = match[0];
                  match_1 = semantic_version_parse(lhs_1, 0, #lhs_1 - 1 | 0);
                  lversion = match_1[0];
                  l_major = lversion[0];
                  if (pred >= 17049) then do
                    if (pred >= 172069535) then do
                      if (pred >= 785637236) then do
                        return major == l_major;
                      end else do
                        return Caml_obj.caml_equal(lversion, version);
                      end end 
                    end else if (pred >= 17064) then do
                      return Caml_obj.caml_lessthan(lversion, version);
                    end else do
                      return Caml_obj.caml_lessequal(lversion, version);
                    end end  end 
                  end else if (pred ~= 15934) then do
                    if (pred >= 15949) then do
                      return Caml_obj.caml_greaterthan(lversion, version);
                    end else if (major == l_major) then do
                      return version[1] == lversion[1];
                    end else do
                      return false;
                    end end  end 
                  end else do
                    return Caml_obj.caml_greaterequal(lversion, version);
                  end end  end 
                end end 
                if (exit_1 == 3) then do
                  error({
                    __Error_4,
                    --[[ Conditional_expr_expected_type ]]Block.__(7, {
                        --[[ Dir_type_string ]]3,
                        type_of_directive(lhs)
                      }),
                    curr(lexbuf)
                  })
                end
                 end 
              end
               end 
              error({
                __Error_4,
                --[[ Conditional_expr_expected_type ]]Block.__(7, {
                    --[[ Dir_type_string ]]3,
                    type_of_directive(lhs)
                  }),
                curr(lexbuf)
              })
            end else do
              return true;
            end end  end else 
         if ___conditional___ == "<="
         or ___conditional___ == "<>"
         or ___conditional___ == ">=" then do
            exit = 1; end else 
         end end end end
        return Curry._1(no, op);
          
      end
    end else do
      return Curry._1(no, op);
    end end  end 
    if (exit == 1) then do
      f;
      exit_3 = 0;
      if (typeof op == "number") then do
        local ___conditional___=(op);
        do
           if ___conditional___ == 26--[[ EQUAL ]] then do
              f = Caml_obj.caml_equal; end else 
           if ___conditional___ == 34--[[ GREATER ]] then do
              f = Caml_obj.caml_greaterthan; end else 
           if ___conditional___ == 51--[[ LESS ]] then do
              f = Caml_obj.caml_lessthan; end else 
           end end end end end end
          exit_3 = 2;
            
        end
      end else if (op.tag == --[[ INFIXOP0 ]]2) then do
        local ___conditional___=(op[0]);
        do
           if ___conditional___ == "<=" then do
              f = Caml_obj.caml_lessequal; end else 
           if ___conditional___ == "<>" then do
              f = Caml_obj.caml_notequal; end else 
           end end end end
          exit_3 = 2;
            
        end
      end else do
        exit_3 = 2;
      end end  end 
      if (exit_3 == 2) then do
        error({
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "lexer.mll",
            331,
            17
          }
        })
      end
       end 
      curr_loc_1 = curr(lexbuf);
      rhs_1 = value_of_token(curr_loc_1, token(--[[ () ]]0));
      if (calc) then do
        return Curry._2(f, lhs, assert_same_type(lexbuf, lhs, rhs_1));
      end else do
        return true;
      end end 
    end
     end 
  end end;
  parse_and_aux = function(calc, v) do
    e = token(--[[ () ]]0);
    if (typeof e == "number" and e == 0) then do
      calc_1 = calc and v;
      b = parse_and_aux(calc_1, parse_relation(calc_1));
      if (v) then do
        return b;
      end else do
        return false;
      end end 
    end else do
      push(e);
      return v;
    end end 
  end end;
  parse_relation = function(calc) do
    curr_token = token(--[[ () ]]0);
    curr_loc = curr(lexbuf);
    if (typeof curr_token == "number") then do
      local ___conditional___=(curr_token);
      do
         if ___conditional___ == 29--[[ FALSE ]] then do
            return false; end end 
         if ___conditional___ == 54--[[ LPAREN ]] then do
            v = parse_or_aux(calc, parse_and_aux(calc, parse_relation(calc)));
            match = token(--[[ () ]]0);
            if (typeof match == "number") then do
              if (match ~= 81) then do
                error({
                  __Error_4,
                  --[[ Unterminated_paren_in_conditional ]]1,
                  curr(lexbuf)
                })
              end
               end 
              return v;
            end else do
              error({
                __Error_4,
                --[[ Unterminated_paren_in_conditional ]]1,
                curr(lexbuf)
              })
            end end  end end 
         if ___conditional___ == 91--[[ TRUE ]] then do
            return true; end end 
        error({
            __Error_4,
            --[[ Unexpected_token_in_conditional ]]4,
            curr_loc
          })
          
      end
    end else do
      local ___conditional___=(curr_token.tag | 0);
      do
         if ___conditional___ == 1--[[ FLOAT ]] then do
            return token_op(calc, (function(e) do
                          error({
                            __Error_4,
                            --[[ Conditional_expr_expected_type ]]Block.__(7, {
                                --[[ Dir_type_bool ]]0,
                                --[[ Dir_type_float ]]1
                              }),
                            curr_loc
                          })
                        end end), --[[ Dir_float ]]Block.__(1, {Caml_format.caml_float_of_string(curr_token[0])})); end end 
         if ___conditional___ == 7--[[ INT ]] then do
            return token_op(calc, (function(e) do
                          error({
                            __Error_4,
                            --[[ Conditional_expr_expected_type ]]Block.__(7, {
                                --[[ Dir_type_bool ]]0,
                                --[[ Dir_type_int ]]2
                              }),
                            curr_loc
                          })
                        end end), --[[ Dir_int ]]Block.__(2, {curr_token[0]})); end end 
         if ___conditional___ == 11--[[ LIDENT ]] then do
            r = curr_token[0];
            local ___conditional___=(r);
            do
               if ___conditional___ == "defined"
               or ___conditional___ == "undefined"
               end
              error({
                  __Error_4,
                  --[[ Unexpected_token_in_conditional ]]4,
                  curr_loc
                })
                
            end
            t = token(--[[ () ]]0);
            loc = curr(lexbuf);
            if (typeof t == "number") then do
              error({
                __Error_4,
                --[[ Unexpected_token_in_conditional ]]4,
                loc
              })
            end else if (t.tag == --[[ UIDENT ]]17) then do
              s = t[0];
              if (calc) then do
                if (Caml_string.get(r, 0) == --[[ "u" ]]117) then do
                  return not defined(s);
                end else do
                  return defined(s);
                end end 
              end else do
                return true;
              end end 
            end else do
              error({
                __Error_4,
                --[[ Unexpected_token_in_conditional ]]4,
                loc
              })
            end end  end  end else 
         if ___conditional___ == 16--[[ STRING ]] then do
            return token_op(calc, (function(e) do
                          error({
                            __Error_4,
                            --[[ Conditional_expr_expected_type ]]Block.__(7, {
                                --[[ Dir_type_bool ]]0,
                                --[[ Dir_type_string ]]3
                              }),
                            curr_loc
                          })
                        end end), --[[ Dir_string ]]Block.__(3, {curr_token[0][0]})); end end end end 
         if ___conditional___ == 17--[[ UIDENT ]] then do
            value_v = query(curr_loc, curr_token[0]);
            return token_op(calc, (function(e) do
                          push(e);
                          if (typeof value_v ~= "number" and not value_v.tag) then do
                            return value_v[0];
                          end
                           end 
                          ty = type_of_directive(value_v);
                          error({
                            __Error_4,
                            --[[ Conditional_expr_expected_type ]]Block.__(7, {
                                --[[ Dir_type_bool ]]0,
                                ty
                              }),
                            curr_loc
                          })
                        end end), value_v); end end 
        error({
            __Error_4,
            --[[ Unexpected_token_in_conditional ]]4,
            curr_loc
          })
          
      end
    end end 
  end end;
  parse_or_aux = function(calc, v) do
    e = token(--[[ () ]]0);
    if (typeof e == "number" and e == 8) then do
      calc_1 = calc and not v;
      b = parse_or_aux(calc_1, parse_and_aux(calc_1, parse_relation(calc_1)));
      if (v) then do
        return true;
      end else do
        return b;
      end end 
    end else do
      push(e);
      return v;
    end end 
  end end;
  v = parse_or_aux(true, parse_and_aux(true, parse_relation(true)));
  match = token(--[[ () ]]0);
  if (typeof match == "number") then do
    if (match ~= 88) then do
      error({
        __Error_4,
        --[[ Expect_hash_then_in_conditional ]]5,
        curr(lexbuf)
      })
    end
     end 
    return v;
  end else do
    error({
      __Error_4,
      --[[ Expect_hash_then_in_conditional ]]5,
      curr(lexbuf)
    })
  end end 
end end

function is_elif(i) do
  if (typeof i == "number" or not (i.tag == --[[ LIDENT ]]11 and i[0] == "elif")) then do
    return false;
  end else do
    return true;
  end end 
end end

keyword_table = create_hashtable(149, --[[ :: ]]{
      --[[ tuple ]]{
        "and",
        --[[ AND ]]2
      },
      --[[ :: ]]{
        --[[ tuple ]]{
          "as",
          --[[ AS ]]3
        },
        --[[ :: ]]{
          --[[ tuple ]]{
            "assert",
            --[[ ASSERT ]]4
          },
          --[[ :: ]]{
            --[[ tuple ]]{
              "begin",
              --[[ BEGIN ]]10
            },
            --[[ :: ]]{
              --[[ tuple ]]{
                "class",
                --[[ CLASS ]]11
              },
              --[[ :: ]]{
                --[[ tuple ]]{
                  "constraint",
                  --[[ CONSTRAINT ]]17
                },
                --[[ :: ]]{
                  --[[ tuple ]]{
                    "do",
                    --[[ DO ]]18
                  },
                  --[[ :: ]]{
                    --[[ tuple ]]{
                      "done",
                      --[[ DONE ]]19
                    },
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        "downto",
                        --[[ DOWNTO ]]22
                      },
                      --[[ :: ]]{
                        --[[ tuple ]]{
                          "else",
                          --[[ ELSE ]]23
                        },
                        --[[ :: ]]{
                          --[[ tuple ]]{
                            "end",
                            --[[ END ]]24
                          },
                          --[[ :: ]]{
                            --[[ tuple ]]{
                              "exception",
                              --[[ EXCEPTION ]]27
                            },
                            --[[ :: ]]{
                              --[[ tuple ]]{
                                "external",
                                --[[ EXTERNAL ]]28
                              },
                              --[[ :: ]]{
                                --[[ tuple ]]{
                                  "false",
                                  --[[ FALSE ]]29
                                },
                                --[[ :: ]]{
                                  --[[ tuple ]]{
                                    "for",
                                    --[[ FOR ]]30
                                  },
                                  --[[ :: ]]{
                                    --[[ tuple ]]{
                                      "fun",
                                      --[[ FUN ]]31
                                    },
                                    --[[ :: ]]{
                                      --[[ tuple ]]{
                                        "function",
                                        --[[ FUNCTION ]]32
                                      },
                                      --[[ :: ]]{
                                        --[[ tuple ]]{
                                          "functor",
                                          --[[ FUNCTOR ]]33
                                        },
                                        --[[ :: ]]{
                                          --[[ tuple ]]{
                                            "if",
                                            --[[ IF ]]37
                                          },
                                          --[[ :: ]]{
                                            --[[ tuple ]]{
                                              "in",
                                              --[[ IN ]]38
                                            },
                                            --[[ :: ]]{
                                              --[[ tuple ]]{
                                                "include",
                                                --[[ INCLUDE ]]39
                                              },
                                              --[[ :: ]]{
                                                --[[ tuple ]]{
                                                  "inherit",
                                                  --[[ INHERIT ]]40
                                                },
                                                --[[ :: ]]{
                                                  --[[ tuple ]]{
                                                    "initializer",
                                                    --[[ INITIALIZER ]]41
                                                  },
                                                  --[[ :: ]]{
                                                    --[[ tuple ]]{
                                                      "lazy",
                                                      --[[ LAZY ]]42
                                                    },
                                                    --[[ :: ]]{
                                                      --[[ tuple ]]{
                                                        "let",
                                                        --[[ LET ]]53
                                                      },
                                                      --[[ :: ]]{
                                                        --[[ tuple ]]{
                                                          "match",
                                                          --[[ MATCH ]]58
                                                        },
                                                        --[[ :: ]]{
                                                          --[[ tuple ]]{
                                                            "method",
                                                            --[[ METHOD ]]59
                                                          },
                                                          --[[ :: ]]{
                                                            --[[ tuple ]]{
                                                              "module",
                                                              --[[ MODULE ]]63
                                                            },
                                                            --[[ :: ]]{
                                                              --[[ tuple ]]{
                                                                "mutable",
                                                                --[[ MUTABLE ]]64
                                                              },
                                                              --[[ :: ]]{
                                                                --[[ tuple ]]{
                                                                  "new",
                                                                  --[[ NEW ]]65
                                                                },
                                                                --[[ :: ]]{
                                                                  --[[ tuple ]]{
                                                                    "nonrec",
                                                                    --[[ NONREC ]]66
                                                                  },
                                                                  --[[ :: ]]{
                                                                    --[[ tuple ]]{
                                                                      "object",
                                                                      --[[ OBJECT ]]67
                                                                    },
                                                                    --[[ :: ]]{
                                                                      --[[ tuple ]]{
                                                                        "of",
                                                                        --[[ OF ]]68
                                                                      },
                                                                      --[[ :: ]]{
                                                                        --[[ tuple ]]{
                                                                          "open",
                                                                          --[[ OPEN ]]69
                                                                        },
                                                                        --[[ :: ]]{
                                                                          --[[ tuple ]]{
                                                                            "or",
                                                                            --[[ OR ]]70
                                                                          },
                                                                          --[[ :: ]]{
                                                                            --[[ tuple ]]{
                                                                              "private",
                                                                              --[[ PRIVATE ]]75
                                                                            },
                                                                            --[[ :: ]]{
                                                                              --[[ tuple ]]{
                                                                                "rec",
                                                                                --[[ REC ]]80
                                                                              },
                                                                              --[[ :: ]]{
                                                                                --[[ tuple ]]{
                                                                                  "sig",
                                                                                  --[[ SIG ]]85
                                                                                },
                                                                                --[[ :: ]]{
                                                                                  --[[ tuple ]]{
                                                                                    "struct",
                                                                                    --[[ STRUCT ]]87
                                                                                  },
                                                                                  --[[ :: ]]{
                                                                                    --[[ tuple ]]{
                                                                                      "then",
                                                                                      --[[ THEN ]]88
                                                                                    },
                                                                                    --[[ :: ]]{
                                                                                      --[[ tuple ]]{
                                                                                        "to",
                                                                                        --[[ TO ]]90
                                                                                      },
                                                                                      --[[ :: ]]{
                                                                                        --[[ tuple ]]{
                                                                                          "true",
                                                                                          --[[ TRUE ]]91
                                                                                        },
                                                                                        --[[ :: ]]{
                                                                                          --[[ tuple ]]{
                                                                                            "try",
                                                                                            --[[ TRY ]]92
                                                                                          },
                                                                                          --[[ :: ]]{
                                                                                            --[[ tuple ]]{
                                                                                              "type",
                                                                                              --[[ TYPE ]]93
                                                                                            },
                                                                                            --[[ :: ]]{
                                                                                              --[[ tuple ]]{
                                                                                                "val",
                                                                                                --[[ VAL ]]95
                                                                                              },
                                                                                              --[[ :: ]]{
                                                                                                --[[ tuple ]]{
                                                                                                  "virtual",
                                                                                                  --[[ VIRTUAL ]]96
                                                                                                },
                                                                                                --[[ :: ]]{
                                                                                                  --[[ tuple ]]{
                                                                                                    "when",
                                                                                                    --[[ WHEN ]]97
                                                                                                  },
                                                                                                  --[[ :: ]]{
                                                                                                    --[[ tuple ]]{
                                                                                                      "while",
                                                                                                      --[[ WHILE ]]98
                                                                                                    },
                                                                                                    --[[ :: ]]{
                                                                                                      --[[ tuple ]]{
                                                                                                        "with",
                                                                                                        --[[ WITH ]]99
                                                                                                      },
                                                                                                      --[[ :: ]]{
                                                                                                        --[[ tuple ]]{
                                                                                                          "mod",
                                                                                                          --[[ INFIXOP3 ]]Block.__(5, {"mod"})
                                                                                                        },
                                                                                                        --[[ :: ]]{
                                                                                                          --[[ tuple ]]{
                                                                                                            "land",
                                                                                                            --[[ INFIXOP3 ]]Block.__(5, {"land"})
                                                                                                          },
                                                                                                          --[[ :: ]]{
                                                                                                            --[[ tuple ]]{
                                                                                                              "lor",
                                                                                                              --[[ INFIXOP3 ]]Block.__(5, {"lor"})
                                                                                                            },
                                                                                                            --[[ :: ]]{
                                                                                                              --[[ tuple ]]{
                                                                                                                "lxor",
                                                                                                                --[[ INFIXOP3 ]]Block.__(5, {"lxor"})
                                                                                                              },
                                                                                                              --[[ :: ]]{
                                                                                                                --[[ tuple ]]{
                                                                                                                  "lsl",
                                                                                                                  --[[ INFIXOP4 ]]Block.__(6, {"lsl"})
                                                                                                                },
                                                                                                                --[[ :: ]]{
                                                                                                                  --[[ tuple ]]{
                                                                                                                    "lsr",
                                                                                                                    --[[ INFIXOP4 ]]Block.__(6, {"lsr"})
                                                                                                                  },
                                                                                                                  --[[ :: ]]{
                                                                                                                    --[[ tuple ]]{
                                                                                                                      "asr",
                                                                                                                      --[[ INFIXOP4 ]]Block.__(6, {"asr"})
                                                                                                                    },
                                                                                                                    --[[ [] ]]0
                                                                                                                  }
                                                                                                                }
                                                                                                              }
                                                                                                            }
                                                                                                          }
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    });

initial_string_buffer = Caml_bytes.caml_create_bytes(256);

string_buff = do
  contents: initial_string_buffer
end;

string_index = do
  contents: 0
end;

function reset_string_buffer(param) do
  string_buff.contents = initial_string_buffer;
  string_index.contents = 0;
  return --[[ () ]]0;
end end

function store_string_char(c) do
  if (string_index.contents >= #string_buff.contents) then do
    new_buff = Caml_bytes.caml_create_bytes((#string_buff.contents << 1));
    Bytes.blit(string_buff.contents, 0, new_buff, 0, #string_buff.contents);
    string_buff.contents = new_buff;
  end
   end 
  string_buff.contents[string_index.contents] = c;
  string_index.contents = string_index.contents + 1 | 0;
  return --[[ () ]]0;
end end

function store_string(s) do
  for i = 0 , #s - 1 | 0 , 1 do
    store_string_char(Caml_string.get(s, i));
  end
  return --[[ () ]]0;
end end

function get_stored_string(param) do
  s = Bytes.sub_string(string_buff.contents, 0, string_index.contents);
  string_buff.contents = initial_string_buffer;
  return s;
end end

string_start_loc = do
  contents: none
end;

comment_start_loc = do
  contents: --[[ [] ]]0
end;

is_in_string = do
  contents: false
end;

print_warnings = do
  contents: true
end;

if_then_else = do
  contents: --[[ Dir_out ]]2
end;

sharp_look_ahead = do
  contents: undefined
end;

function with_comment_buffer(comment, lexbuf) do
  start_loc = curr(lexbuf);
  comment_start_loc.contents = --[[ :: ]]{
    start_loc,
    --[[ [] ]]0
  };
  reset_string_buffer(--[[ () ]]0);
  end_loc = Curry._1(comment, lexbuf);
  s = get_stored_string(--[[ () ]]0);
  reset_string_buffer(--[[ () ]]0);
  loc_loc_start = start_loc.loc_start;
  loc_loc_end = end_loc.loc_end;
  loc_loc_ghost = start_loc.loc_ghost;
  loc = do
    loc_start: loc_loc_start,
    loc_end: loc_loc_end,
    loc_ghost: loc_loc_ghost
  end;
  return --[[ tuple ]]{
          s,
          loc
        };
end end

function char_for_backslash(c) do
  if (c >= 110) then do
    if (c >= 117) then do
      return c;
    end else do
      local ___conditional___=(c - 110 | 0);
      do
         if ___conditional___ == 0 then do
            return --[[ "\n" ]]10; end end 
         if ___conditional___ == 4 then do
            return --[[ "\r" ]]13; end end 
         if ___conditional___ == 1
         or ___conditional___ == 2
         or ___conditional___ == 3
         or ___conditional___ == 5 then do
            return c; end end 
         if ___conditional___ == 6 then do
            return --[[ "\t" ]]9; end end 
        
      end
    end end 
  end else if (c ~= 98) then do
    return c;
  end else do
    return --[[ "\b" ]]8;
  end end  end 
end end

function char_for_decimal_code(lexbuf, i) do
  c = (Caml_int32.imul(100, Lexing.lexeme_char(lexbuf, i) - 48 | 0) + Caml_int32.imul(10, Lexing.lexeme_char(lexbuf, i + 1 | 0) - 48 | 0) | 0) + (Lexing.lexeme_char(lexbuf, i + 2 | 0) - 48 | 0) | 0;
  if (c < 0 or c > 255) then do
    if (comment_start_loc.contents ~= --[[ [] ]]0) then do
      return --[[ "x" ]]120;
    end else do
      error({
        __Error_4,
        --[[ Illegal_escape ]]Block.__(1, {Lexing.lexeme(lexbuf)}),
        curr(lexbuf)
      })
    end end 
  end else do
    return Char.chr(c);
  end end 
end end

function char_for_hexadecimal_code(lexbuf, i) do
  d1 = Lexing.lexeme_char(lexbuf, i);
  val1 = d1 >= 97 and d1 - 87 | 0 or (
      d1 >= 65 and d1 - 55 | 0 or d1 - 48 | 0
    );
  d2 = Lexing.lexeme_char(lexbuf, i + 1 | 0);
  val2 = d2 >= 97 and d2 - 87 | 0 or (
      d2 >= 65 and d2 - 55 | 0 or d2 - 48 | 0
    );
  return Char.chr((val1 << 4) + val2 | 0);
end end

function cvt_int_literal(s) do
  return -Caml_format.caml_int_of_string("-" .. s) | 0;
end end

function cvt_int32_literal(s) do
  return -Caml_format.caml_int32_of_string("-" .. __String.sub(s, 0, #s - 1 | 0)) | 0;
end end

function cvt_int64_literal(s) do
  return Caml_int64.neg(Caml_format.caml_int64_of_string("-" .. __String.sub(s, 0, #s - 1 | 0)));
end end

function cvt_nativeint_literal(s) do
  return -Caml_format.caml_nativeint_of_string("-" .. __String.sub(s, 0, #s - 1 | 0));
end end

function remove_underscores(s) do
  l = #s;
  b = Caml_bytes.caml_create_bytes(l);
  _src = 0;
  _dst = 0;
  while(true) do
    dst = _dst;
    src = _src;
    if (src >= l) then do
      if (dst >= l) then do
        return s;
      end else do
        return Bytes.sub_string(b, 0, dst);
      end end 
    end else do
      c = Caml_string.get(s, src);
      if (c ~= 95) then do
        b[dst] = c;
        _dst = dst + 1 | 0;
        _src = src + 1 | 0;
        ::continue:: ;
      end else do
        _src = src + 1 | 0;
        ::continue:: ;
      end end 
    end end 
  end;
end end

function get_label_name(lexbuf) do
  s = Lexing.lexeme(lexbuf);
  name = __String.sub(s, 1, #s - 2 | 0);
  if (Hashtbl.mem(keyword_table, name)) then do
    error({
      __Error_4,
      --[[ Keyword_as_label ]]Block.__(4, {name}),
      curr(lexbuf)
    })
  end
   end 
  return name;
end end

function update_loc(lexbuf, file, line, absolute, chars) do
  pos = lexbuf.lex_curr_p;
  new_file = file ~= undefined and file or pos.pos_fname;
  lexbuf.lex_curr_p = do
    pos_fname: new_file,
    pos_lnum: absolute and line or pos.pos_lnum + line | 0,
    pos_bol: pos.pos_cnum - chars | 0,
    pos_cnum: pos.pos_cnum
  end;
  return --[[ () ]]0;
end end

preprocessor = do
  contents: undefined
end;

escaped_newlines = do
  contents: false
end;

comment_list = do
  contents: --[[ [] ]]0
end;

function add_comment(com) do
  comment_list.contents = --[[ :: ]]{
    com,
    comment_list.contents
  };
  return --[[ () ]]0;
end end

function add_docstring_comment(ds) do
  return add_comment(--[[ tuple ]]{
              ds.ds_body,
              ds.ds_loc
            });
end end

function report_error_2(ppf, param) do
  if (typeof param == "number") then do
    local ___conditional___=(param);
    do
       if ___conditional___ == 0--[[ Unterminated_string ]] then do
          return Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "String literal not terminated",
                          --[[ End_of_format ]]0
                        }),
                      "String literal not terminated"
                    }); end end 
       if ___conditional___ == 1--[[ Unterminated_paren_in_conditional ]] then do
          return Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "Unterminated parens in conditional predicate",
                          --[[ End_of_format ]]0
                        }),
                      "Unterminated parens in conditional predicate"
                    }); end end 
       if ___conditional___ == 2--[[ Unterminated_if ]] then do
          return Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "#if not terminated",
                          --[[ End_of_format ]]0
                        }),
                      "#if not terminated"
                    }); end end 
       if ___conditional___ == 3--[[ Unterminated_else ]] then do
          return Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "#else not terminated",
                          --[[ End_of_format ]]0
                        }),
                      "#else not terminated"
                    }); end end 
       if ___conditional___ == 4--[[ Unexpected_token_in_conditional ]] then do
          return Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "Unexpected token in conditional predicate",
                          --[[ End_of_format ]]0
                        }),
                      "Unexpected token in conditional predicate"
                    }); end end 
       if ___conditional___ == 5--[[ Expect_hash_then_in_conditional ]] then do
          return Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "Expect `then` after conditional predicate",
                          --[[ End_of_format ]]0
                        }),
                      "Expect `then` after conditional predicate"
                    }); end end 
       if ___conditional___ == 6--[[ Unexpected_directive ]] then do
          return Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "Unexpected directive",
                          --[[ End_of_format ]]0
                        }),
                      "Unexpected directive"
                    }); end end 
      
    end
  end else do
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ == 0--[[ Illegal_character ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "Illegal character (",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ Char_literal ]]Block.__(12, {
                                      --[[ ")" ]]41,
                                      --[[ End_of_format ]]0
                                    })
                                })
                            }),
                          "Illegal character (%s)"
                        }), Char.escaped(param[0])); end end 
       if ___conditional___ == 1--[[ Illegal_escape ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "Illegal backslash escape in string or character (",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ Char_literal ]]Block.__(12, {
                                      --[[ ")" ]]41,
                                      --[[ End_of_format ]]0
                                    })
                                })
                            }),
                          "Illegal backslash escape in string or character (%s)"
                        }), param[0]); end end 
       if ___conditional___ == 2--[[ Unterminated_comment ]] then do
          return Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "Comment not terminated",
                          --[[ End_of_format ]]0
                        }),
                      "Comment not terminated"
                    }); end end 
       if ___conditional___ == 3--[[ Unterminated_string_in_comment ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "This comment contains an unterminated string literal",
                              --[[ Formatting_lit ]]Block.__(17, {
                                  --[[ Flush_newline ]]4,
                                  --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                          "String literal begins here",
                                          --[[ End_of_format ]]0
                                        })})
                                })
                            }),
                          "This comment contains an unterminated string literal@.%aString literal begins here"
                        }), print_error, param[1]); end end 
       if ___conditional___ == 4--[[ Keyword_as_label ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Char_literal ]]Block.__(12, {
                              --[[ "`" ]]96,
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ String_literal ]]Block.__(11, {
                                      "' is a keyword, it cannot be used as label name",
                                      --[[ End_of_format ]]0
                                    })
                                })
                            }),
                          "`%s' is a keyword, it cannot be used as label name"
                        }), param[0]); end end 
       if ___conditional___ == 5--[[ Literal_overflow ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "Integer literal exceeds the range of representable integers of type ",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ End_of_format ]]0
                                })
                            }),
                          "Integer literal exceeds the range of representable integers of type %s"
                        }), param[0]); end end 
       if ___conditional___ == 6--[[ Illegal_semver ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "Illegal semantic version string ",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ End_of_format ]]0
                                })
                            }),
                          "Illegal semantic version string %s"
                        }), param[0]); end end 
       if ___conditional___ == 7--[[ Conditional_expr_expected_type ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "Conditional expression type mismatch (",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ Char_literal ]]Block.__(12, {
                                      --[[ "," ]]44,
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ Char_literal ]]Block.__(12, {
                                              --[[ ")" ]]41,
                                              --[[ End_of_format ]]0
                                            })
                                        })
                                    })
                                })
                            }),
                          "Conditional expression type mismatch (%s,%s)"
                        }), string_of_type_directive(param[0]), string_of_type_directive(param[1])); end end 
      
    end
  end end 
end end

register_error_of_exn((function(param) do
        if (param[0] == __Error_4) then do
          return error_of_printer(param[2], report_error_2, param[1]);
        end
         end 
      end end));

__ocaml_lex_tables = do
  lex_base: "\0\0\xa4\xff\xa5\xff\xe0\0\x03\x01&\x01I\x01l\x01\x8f\x01\xbc\xff\xb2\x01\xd7\x01\xc4\xff[\0\xfc\x01\x1f\x02D\0G\0T\0B\x02\xd5\xff\xd7\xff\xda\xffe\x02\xc4\x02\xe7\x02Y\0\xff\0\x05\x03\xec\xffR\x03s\x03\xbc\x03\x8c\x04\\\x05,\x06\x0b\x07g\x077\b}\0\xfe\xff\x01\0\x05\0\xff\xff\x06\0\x07\0\x16\t4\t\x04\n\xfa\xff\xf9\xff\xd4\n\xa4\x0b\xf7\xff\xf6\xff\xed\xff\xee\xff\xef\xff]\0v\x02[\0n\0\xe7\x02\x07\x04\xd7\x04e\x02\xfe\x02v\0\xc2\xff\xeb\xffx\x05\x84\f`\0q\0\x0b\0\xea\xff\xe9\xff\xe5\xff\xe5\x04\x80\0s\0\xe8\xff\xe0\0u\0\xe7\xffw\x06\x93\0\xe6\xff\x92\0\xe1\xff\x94\0\xe0\xff\xd9\0\x84\f\xdf\xff\xab\f\xaf\b\xae\x06\xde\xff\f\0\x18\x01,\x01P\x01-\x01\xde\xff\r\0\xd9\f\0\r#\rI\r\xd2\xff\xce\xff\xcf\xff\xd0\xff\xcc\xffl\r\x9a\0\xb7\0\xc5\xff\xc6\xff\xc7\xff\xc7\0\xb6\xff\xb8\xff\xbf\xff\x8f\r\xbb\xff\xbd\xff\xb2\r\xd5\r\xf8\r\x1b\x0e\xeb\x05\xf3\xff\xf4\xff\x11\0\xf5\xff>\x02\xac\x07\xfd\xff\xdf\0\xf1\0\xff\xff\xfe\xff\xfc\xff\xc8\x07-\x0e\xfa\0\xfc\0\x12\0\xfb\xff\xfa\xff\xf9\xff\x80\t\x1e\x03\x03\x01\xf8\xff\\\x03\x04\x01\xf7\xffO\n\x05\x01\xf6\xff+\x01\xc7\x01\xf7\xff\xf8\xff\xf9\xff;\x01v\x0e\xff\xff\xfa\xff\x1f\x0b$\x04\xfd\xff&\x01E\x01^\x01\xfc\x04\xfc\xff\xef\x0b\xfb\xff_\x01\xb5\x01\xfc\xff\xee\x06\xfe\xff\xff\xffo\x01p\x01\xfd\xffJ\x07\x10\x01\x13\x012\x01?\x01\x1a\x01k\x01!\x01\x13\0\xff\xff",
  lex_backtrk: "\xff\xff\xff\xff\xff\xffX\0W\0T\0S\0L\0J\0\xff\xffA\0>\0\xff\xff7\x006\x004\x002\0.\0,\0O\0\xff\xff\xff\xff\xff\xff#\0\"\0)\0'\0&\0<\0\xff\xff\x0e\0\x0e\0\r\0\f\0\x0b\0\n\0\x07\0\x04\0\x03\0\x02\0\xff\xff[\0[\0\xff\xff\xff\xff\xff\xffR\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x0f\0\xff\xff\xff\xff\xff\xff\x0e\0\x0e\0\x0e\0\x0f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\0\x1a\0\x1a\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\0\xff\xff\x1c\0\xff\xff\x1d\0V\0\xff\xffY\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\0U\0P\0+\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff5\0F\0E\0\xff\xff\xff\xff\xff\xffH\0\xff\xff\xff\xff\xff\xff?\0\xff\xff\xff\xffQ\0K\0N\0M\0\xff\xff\xff\xff\xff\xff\f\0\xff\xff\f\0\f\0\xff\xff\f\0\f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\b\0\b\0\xff\xff\xff\xff\x05\0\x05\0\xff\xff\x01\0\x05\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x03\0\xff\xff\xff\xff\x03\0\xff\xff\xff\xff\xff\xff\x02\0\xff\xff\xff\xff\x01\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
  lex_default: "\x01\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xffH\0\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xffM\0\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\0\0\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xffd\0\xff\xff\0\0\xff\xffd\0e\0d\0g\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\xff\xff\0\0\0\0\0\0\xff\xff\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\x85\0\0\0\0\0\xff\xff\0\0\x93\0\xff\xff\0\0\xff\xff\xff\xff\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\xa5\0\0\0\0\0\0\0\xff\xff\xab\0\0\0\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\0\0\xff\xff\xb8\0\0\0\xff\xff\0\0\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xc2\0\xc5\0\xff\xff\xc5\0\xff\xff\xff\xff\0\0",
  lex_trans: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\0(\0(\0'\0)\0-\0+\0+\0(\0,\0,\0-\0I\0b\0h\0J\0c\0i\0\x86\0\x94\0\xc8\0\xa3\0\x95\0'\0\b\0\x1d\0\x18\0\x06\0\x04\0\x17\0\x1b\0\x1a\0\x15\0\x19\0\x07\0\x14\0\x13\0\x12\0\x03\0\x1f\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x11\0\x10\0\x0f\0\x0e\0\n\0$\0\x05\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\r\0*\0\f\0\x05\0&\0\x16\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\x1c\0\x0b\0\t\0%\0r\0t\0q\0n\0X\0p\0o\0'\0L\0C\0'\0C\0A\0A\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0w\0K\0v\0Q\0u\0T\0'\0@\0@\0@\0@\0@\0@\0@\0@\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0W\0Y\0Z\0[\0\\\0{\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0x\0 \0 \0 \0 \0 \0 \0 \0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0y\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\x02\0\x03\0[\0\\\0\x03\0\x03\0\x03\0z\0\x8f\0I\0\x03\0\x03\0J\0\x03\0\x03\0\x03\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\x03\0\x8e\0\x03\0\x03\0\x03\0\x03\0\x03\0\x98\0b\0\x97\0\x03\0c\0\xff\xff\x03\0\x03\0\x03\0\x9c\0\x9f\0\xa2\0\x03\0\x03\0\xaf\0\x03\0\x03\0\x03\0\xc1\0\xc2\0\x86\0b\0h\0\xa3\0c\0i\0\xc6\0\xc3\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\xc7\0\xa7\0\xaf\0\x05\0\xb6\0\xc4\0\x05\0\x05\0\x05\0\0\0g\0\xaf\0\x05\0\x05\0\xb1\0\x05\0\x05\0\x05\0\0\0\0\0\0\0f\0b\0G\0\x03\0c\0\x03\0\0\0\x05\0\x03\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\xaf\0\xa7\0\x06\0\xb1\0\xb6\0\x06\0\x06\0\x06\0f\0\0\0e\0\x06\0\x06\0\xc4\0\x06\0\x06\0\x06\0\xbb\0\xbb\0\0\0\xbd\0\xbd\0\0\0\x03\0\0\0\x03\0\0\0\x06\0\x05\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0k\0\0\0k\0\x83\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\0\0\0\x05\0\0\0k\0\x06\0k\0\x82\0k\0k\0k\0\0\0\0\0\0\0\x80\0\0\0\0\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\x80\0\x80\0\0\0\x80\0\x80\0\x80\0\xbb\0\0\0\0\0\xbc\0\0\0\0\0\x06\0\0\0\x06\0\0\0\x80\0k\0\x80\0\x81\0\x80\0\x80\0\x80\0\0\0\xa7\0\0\0\x06\0\xa8\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\xaa\0k\0\0\0\x06\0\x80\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\0\0\x06\0\x06\0\x06\0\0\0\xff\xff\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\0\0\x80\0\0\0\x80\0\0\0\x7f\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\0\0\0\0\0\0\0\0\x06\0\0\0\0\0\x06\0\x06\0\x06\0\xa9\0\0\0\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\x06\0~\0\x06\0\xb9\0\xff\xff\0\0|\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\xff\xff\x06\0\0\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\x94\0\x06\0\x06\0\x95\0s\0\x06\0\x06\0\0\0\xff\xff\0\0\0\0}\0\0\0\x06\0\0\0\0\0\0\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0k\0\0\0\x96\0k\0k\0k\0\0\0\0\0\xff\xffk\0k\0\0\0k\0l\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\x06\0\0\0k\0\x06\0k\0k\0m\0k\0k\0\0\0\0\0\0\0\x06\0\0\0\0\0\x06\0\x06\0j\0\0\0\0\0\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0A\0A\0\0\0\0\0\0\0\x92\0\x06\0\0\0\x06\0\0\0\x06\0k\0\x06\0\x06\0\x06\0\x06\0\x06\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0\0\x008\0\0\0\0\0\0\0\xba\0\0\0\0\0\0\0\0\0\0\0:\0\0\0\0\0k\0\0\0k\0\0\0\0\0\x06\0A\0\0\0\0\0\xa6\0\0\0\0\0\0\0\0\0\0\0a\0\0\0\0\0\0\x009\0\0\x007\0\0\0;\0\0\0\0\0\0\0\0\0\0\0:\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\x06\0a\0_\0\0\0_\0_\0_\0_\0\0\0\0\0\0\0_\0_\0\0\0_\0_\0_\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0_\0\0\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\x03\0\0\0\0\0\x03\0\x03\0\x03\0\0\0\0\0^\0]\0\x03\0\0\0\x03\0\x03\0\x03\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0\x03\0_\0\x03\0\x03\0\x03\0\x03\0\x03\0?\0?\0?\0?\0?\0?\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\0\0_\0D\0_\0\0\0\0\0\x03\0\0\0\0\0?\0?\0?\0?\0?\0?\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\0\0\0\0\0\0\0\0\0\0B\0\0\0\0\0\0\0\0\0\0\0\x03\0F\0\x03\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0;\0E\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\0\0:\0\0\0\0\0\0\0\0\0\0\0\0\x008\0\0\0\0\0;\0\0\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\0\0\0\0\0\0\0\0\x1e\0\0\0\0\0\0\0<\0\0\0:\0:\0\0\0\0\0\0\0\0\0\0\x009\x008\x007\0\0\0=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0>\0\0\0\0\0\0\0\0\0\0\0\0\0\x1e\0\0\0\0\0<\0\0\0\0\0:\0\0\0\0\0\0\0\0\0\0\0\0\x009\0\0\x007\0=\0 \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0>\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\0\0\0\0\0\0\0\0 \0\0\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0?\0?\0?\0?\0?\0?\0\0\0\0\0\0\0\0\0\0\x008\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0?\0\0\0?\0?\0?\0?\0?\0?\0\0\0\0\0\0\0\0\0\0\x009\0\0\x007\0\0\0\0\0\0\0\0\0\0\0\0\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\0\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0!\0 \0 \0 \0 \0 \0 \0 \0 \0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\0\0\0\0\0\0\0\0!\0\0\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0@\0@\0@\0@\0@\0@\0@\0@\0\0\0\0\0\0\0\0\0\0\0\0\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0\0\0\0\0\0\0\0\x008\0\0\0\0\0U\0U\0U\0U\0U\0U\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0@\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x009\0\0\x007\0U\0U\0U\0U\0U\0U\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\0\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\"\0 \0 \0 \0 \0 \0 \0 \0 \0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\0\0\0\0\0\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0F\0\0\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0\0\0E\0\x86\0\0\0\0\0\x87\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8b\0\0\0\0\0\0\0\0\0\x89\0\x8d\0\0\0\x8c\0\0\0\0\0\0\0\0\0\0\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0#\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\x8a\0\0\0\0\0\0\0\0\0\0\0\0\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\0\0\0\0\0\0\0\0#\0\0\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0\0\0\0\0\0\0\0\0\0\0\0\0a\0V\0V\0V\0V\0V\0V\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0V\0V\0V\0V\0V\0V\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0\0\0\0\0\0\0\x88\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0.\0\0\0\0\0.\0.\0.\0\0\0\0\0\0\0.\0.\0\0\0.\0.\0.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0.\0\0\0.\0.\0.\0.\0.\0\0\0\xbf\0\0\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0.\x004\0\xbe\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\0\0.\0.\0.\0\0\0.\0.\0.\0\0\0\0\0\0\0.\0.\0\0\0.\0.\0.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0.\0\0\0.\0.\0.\0.\0.\0\0\0\xbf\0\0\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0.\x000\0\xbe\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\0\0.\0\0\0.\0\0\0\0\0\0\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\0\x003\x003\x003\x003\x003\x003\x003\x003\0\x91\0\0\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x90\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\0\0\x90\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0#\0/\0/\0/\0/\0/\0/\0/\0/\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\0\0\0\0\0\0\0\0#\0\0\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\0\0\0\0\0\0\0\0\0\0\0\0f\0b\0\0\0\0\0c\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0f\0\0\0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0.\0\0\0\0\0.\0.\0.\0\0\0\0\0\0\0.\0.\0\0\0.\0.\0.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0.\0\0\0.\0.\0.\0.\0.\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\x002\0\0\0\0\0\0\0\0\0\0\0.\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\0\0\0\0\0\0.\0/\0.\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\x000\0/\0/\0/\0/\0/\0/\0/\0/\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x001\0\0\0\0\0\0\0\0\0\0\0\0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\0\0\0\0\0\0\0\x000\0\0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\x003\0/\0/\0/\0/\0/\0/\0/\0/\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x006\0\0\0\0\0\0\0\0\0\0\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\0\0\0\0\0\0\0\x003\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x004\x003\x003\x003\x003\x003\x003\x003\x003\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x005\0\0\0\0\0\0\0\0\0\0\0\0\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\0\0\0\0\0\0\0\x004\0\0\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\0\x003\x003\x003\x003\x003\x003\x003\x003\0P\0]\0P\0\0\0]\0]\0]\0P\0\0\0\0\0]\0]\0\0\0]\0]\0]\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0]\0\0\0]\0]\0]\0]\0]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\0\0\0_\0_\0_\0_\0\0\0\0\0\0\0_\0_\0\0\0_\0_\0_\0\0\0\0\0\0\0\0\0\0\0P\0\0\0]\0\0\0\0\0_\0P\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\0\0\0\0\0\0P\0\0\0\0\0\0\0P\0\0\0P\0\0\0\x06\0\0\0N\0\x06\0\x06\0\x06\0]\0\0\0]\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0_\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0_\0\0\0_\0k\0k\0\0\0k\0k\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\0\0k\0\0\0k\0k\0k\0k\0k\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0k\0\0\0k\0k\0k\0\0\0\0\0\x06\0\0\0\x06\0\0\0\0\0\0\0\0\0\0\0k\0k\0k\0k\0k\0k\0k\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0k\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0\0\0k\0\0\0\0\0k\0\0\0k\0\xff\xffk\0k\0k\0k\0k\0\0\0\0\0\0\0\x06\0\0\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0k\0\0\0k\0\0\0\0\0\0\0\0\0\x06\0k\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\x06\0\0\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\0\0k\0\0\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\x80\0\0\0\0\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\x80\0\x80\0\0\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\x06\0\0\0\x80\0\x06\0\x80\0\x80\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\x80\0\0\0\0\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\x80\0\x80\0\0\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\x06\0\0\0\x80\0\x80\0\x80\0\x80\0\x80\0\x80\0\x80\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0k\0\0\0k\0k\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x80\0\0\0\x80\0\0\0k\0\x80\0k\0k\0k\0k\0k\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0k\0\0\0k\0k\0k\0\0\0\0\0\x9b\0\0\0\x9b\0\0\0\x80\0\0\0\x80\0\x9b\0k\0k\0k\0k\0k\0k\0k\0\0\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\0\0k\0\0\0\0\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\xaf\0\0\0\0\0\xb0\0\0\0\0\0\0\0\0\0\0\0\x9b\0\0\0\0\0\0\0\0\0\0\0\x9b\0\0\0\0\0\0\0\0\0\0\0\0\0\xae\0k\0\xae\0k\0\0\0\x9b\0\0\0\xae\0\0\0\x9b\0\0\0\x9b\0\0\0\0\0\0\0\x99\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xae\0\0\0\0\0\0\0\0\0\0\0\xae\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xae\0\0\0\0\0\0\0\xae\0\0\0\xae\0\0\0\0\0\0\0\xac\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff",
  lex_check: "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0)\0\0\0\0\0)\0*\0,\0-\0*\0,\0-\0J\0c\0i\0J\0c\0i\0\x87\0\x95\0\xc7\0\x87\0\x95\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x10\0\r\0\x11\0\x12\0\x1a\0\x11\0\x11\0'\0H\0:\0'\0:\0<\0<\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0\r\0I\0\r\0P\0\r\0S\0'\0=\0=\0=\0=\0=\0=\0=\0=\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0V\0X\0X\0Z\0Z\0t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\0\\\0\\\0\x03\0\x03\0\x03\0y\0\x8c\0\x1b\0\x03\0\x03\0\x1b\0\x03\0\x03\0\x03\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0\x03\0\x8d\0\x03\0\x03\0\x03\0\x03\0\x03\0\x93\0d\0\x94\0\x04\0d\0\x1b\0\x04\0\x04\0\x04\0\x9b\0\x9e\0\xa1\0\x04\0\x04\0\xaf\0\x04\0\x04\0\x04\0\xc0\0\xc1\0\xa3\0e\0g\0\xa3\0e\0g\0\xc4\0\xc2\0\x04\0\x03\0\x04\0\x04\0\x04\0\x04\0\x04\0\xc6\0\xa8\0\xaf\0\x05\0\xa8\0\xc3\0\x05\0\x05\0\x05\0\xff\xffe\0\xb0\0\x05\0\x05\0\xb0\0\x05\0\x05\0\x05\0\xff\xff\xff\xff\xff\xfff\0f\0\x1b\0\x03\0f\0\x03\0\xff\xff\x05\0\x04\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\xb1\0\xb6\0\x06\0\xb1\0\xb6\0\x06\0\x06\0\x06\0f\0\xff\xfff\0\x06\0\x06\0\xc5\0\x06\0\x06\0\x06\0\xbc\0\xbd\0\xff\xff\xbc\0\xbd\0\xff\xff\x04\0\xff\xff\x04\0\xff\xff\x06\0\x05\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\xff\xff\x07\0\xff\xff\xff\xff\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\x07\0\x07\0\xff\xff\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x05\0\xff\xff\x05\0\xff\xff\x07\0\x06\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\b\0\xff\xff\xff\xff\b\0\b\0\b\0\xff\xff\xff\xff\xff\xff\b\0\b\0\xff\xff\b\0\b\0\b\0\xb7\0\xff\xff\xff\xff\xb7\0\xff\xff\xff\xff\x06\0\xff\xff\x06\0\xff\xff\b\0\x07\0\b\0\b\0\b\0\b\0\b\0\xff\xff\xa4\0\xff\xff\n\0\xa4\0\xff\xff\n\0\n\0\n\0\xff\xff\xff\xff\xff\xff\n\0\n\0\xff\xff\n\0\n\0\n\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x07\0\xa4\0\x07\0\xff\xff\n\0\b\0\n\0\n\0\n\0\n\0\n\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x0b\0\xff\xff\xff\xff\x0b\0\x0b\0\x0b\0\xff\xff\x1b\0\xff\xff\x0b\0\x0b\0\xff\xff\x0b\0\x0b\0\x0b\0\xff\xff\xff\xff\xff\xff\xff\xff\b\0\xff\xff\b\0\xff\xff\n\0\n\0\x0b\0\xff\xff\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0d\0\xff\xff\xff\xff\xff\xff\xff\xff\x0e\0\xff\xff\xff\xff\x0e\0\x0e\0\x0e\0\xa4\0\xff\xff\xff\xff\x0e\0\x0e\0\xff\xff\x0e\0\x0e\0\x0e\0e\0g\0\n\0\n\0\n\0\xb7\0\xc2\0\xff\xff\x0b\0\x0b\0\x0e\0\xff\xff\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\xff\xff\xff\xff\xc3\0\x0f\0\xff\xff\xff\xff\x0f\0\x0f\0\x0f\0\xff\xff\xff\xff\x89\0\x0f\0\x0f\0\x89\0\x0f\0\x0f\0\x0f\0\xff\xfff\0\xff\xff\xff\xff\x0b\0\xff\xff\x0b\0\xff\xff\xff\xff\xff\xff\x0f\0\x0e\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\xff\xff\xff\xff\xff\xff\x13\0\xff\xff\x89\0\x13\0\x13\0\x13\0\xff\xff\xff\xff\xc5\0\x13\0\x13\0\xff\xff\x13\0\x13\0\x13\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x0e\0\xff\xff\x0e\0\xff\xff\x13\0\x0f\0\x13\0\x13\0\x13\0\x13\0\x13\0\xff\xff\xff\xff\xff\xff\x17\0\xff\xff\xff\xff\x17\0\x17\0\x17\0\xff\xff\xff\xff\xff\xff\x17\0\x17\0\xff\xff\x17\0\x17\0\x17\0A\0A\0\xff\xff\xff\xff\xff\xff\x89\0\x0f\0\xff\xff\x0f\0\xff\xff\x17\0\x13\0\x17\0\x17\0\x17\0\x17\0\x17\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0\xff\xffA\0\xff\xff\xff\xff\xff\xff\xb7\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff;\0\xff\xff\xff\xff\x13\0\xff\xff\x13\0\xff\xff\xff\xff\x17\0A\0\xff\xff\xff\xff\xa4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x18\0\xff\xff\xff\xff\xff\xffA\0\xff\xffA\0\xff\xff;\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff;\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x17\0\xff\xff\x17\0\x18\0\x18\0\xff\xff\x18\0\x18\0\x18\0\x18\0\xff\xff\xff\xff\xff\xff\x18\0\x18\0\xff\xff\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\xff\xff\x18\0\x18\0\x18\0\x18\0\x18\0\xff\xff\xff\xff\xff\xff\x19\0\xff\xff\xff\xff\x19\0\x19\0\x19\0\xff\xff\xff\xff\x19\0\x19\0\x19\0\xff\xff\x19\0\x19\0\x19\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0\x19\0\x18\0\x19\0\x19\0\x19\0\x19\0\x19\0>\0>\0>\0>\0>\0>\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x89\0\xff\xff\x18\0\x1c\0\x18\0\xff\xff\xff\xff\x19\0\xff\xff\xff\xff>\0>\0>\0>\0>\0>\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffB\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x19\0\x1c\0\x19\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1e\0\x1c\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\xff\xff\x1e\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1e\0\xff\xff\xff\xff\x1f\0\xff\xff\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\xff\xff\xff\xff\xff\xff\xff\xff\x1e\0\xff\xff\xff\xff\xff\xff\x1f\0\xff\xff\x1e\0\x1f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1e\0\x1f\0\x1e\0\xff\xff\x1f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1f\0\xff\xff\xff\xff\x1f\0\xff\xff\xff\xff\x1f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1f\0\xff\xff\x1f\0\x1f\0 \0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1f\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\xff\xff\xff\xff\xff\xff\xff\xff \0\xff\xff \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff?\0?\0?\0?\0?\0?\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff?\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff?\0\xff\xff?\0?\0?\0?\0?\0?\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff?\0\xff\xff?\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\xff\xff \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0!\0 \0 \0 \0 \0 \0 \0 \0 \0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\xff\xff\xff\xff\xff\xff\xff\xff!\0\xff\xff!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0@\0@\0@\0@\0@\0@\0@\0@\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffN\0N\0N\0N\0N\0N\0N\0N\0N\0N\0\xff\xff\xff\xff\xff\xff\xff\xff@\0\xff\xff\xff\xffN\0N\0N\0N\0N\0N\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0@\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff@\0\xff\xff@\0N\0N\0N\0N\0N\0N\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\xff\xff!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\"\0!\0!\0!\0!\0!\0!\0!\0!\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\xff\xff\xff\xff\xff\xff\xff\xff\"\0\xff\xff\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0F\0\xff\xffF\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0\xff\xffF\0\x84\0\xff\xff\xff\xff\x84\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x84\0\xff\xff\xff\xff\xff\xff\xff\xff\x84\0\x84\0\xff\xff\x84\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\xff\xff\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0#\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\x84\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\xff\xff\xff\xff\xff\xff\xff\xff#\0\xff\xff#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffa\0U\0U\0U\0U\0U\0U\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffa\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffU\0U\0U\0U\0U\0U\0a\0a\0a\0a\0a\0a\0a\0a\0a\0a\0\xff\xff\xff\xff\xff\xff\x84\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\xff\xff#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\xff\xff#\0#\0#\0#\0#\0#\0#\0#\0$\0\xff\xff\xff\xff$\0$\0$\0\xff\xff\xff\xff\xff\xff$\0$\0\xff\xff$\0$\0$\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\0\xff\xff$\0$\0$\0$\0$\0\xff\xff\xb9\0\xff\xff\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0$\0$\0\xb9\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0\xff\xff$\0%\0$\0\xff\xff%\0%\0%\0\xff\xff\xff\xff\xff\xff%\0%\0\xff\xff%\0%\0%\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\0\xff\xff%\0%\0%\0%\0%\0\xff\xff\xbf\0\xff\xff\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0%\0%\0\xbf\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0\xff\xff%\0\xff\xff%\0\xff\xff\xff\xff\xff\xff\xff\xff$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0\xff\xff$\0$\0$\0$\0$\0$\0$\0$\0\x8a\0\xff\xff\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x91\0\x8a\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\xff\xff\x91\0\xff\xff%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0&\0%\0%\0%\0%\0%\0%\0%\0%\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0\xff\xff\xff\xff\xff\xff\xff\xff&\0\xff\xff&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\0`\0\xff\xff\xff\xff`\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\0\xff\xff`\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0\xff\xff&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0\xff\xff&\0&\0&\0&\0&\0&\0&\0&\0.\0\xff\xff\xff\xff.\0.\0.\0\xff\xff\xff\xff\xff\xff.\0.\0\xff\xff.\0.\0.\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff.\0\xff\xff.\0.\0.\0.\0.\0\xff\xff\xff\xff\xff\xff\xff\xff/\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff.\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff\xff\xff\xff\xff.\0/\0.\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0`\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\x000\0/\0/\0/\0/\0/\0/\0/\0/\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xff\xff\xff\xff\xff\xff\xff\xff0\0\xff\xff0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xff\xff0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x003\x000\x000\x000\x000\x000\x000\x000\x000\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff3\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xff\xff\xff\xff\xff\xff\xff\xff3\0\xff\xff3\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff3\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xff\xff3\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x004\x003\x003\x003\x003\x003\x003\x003\x003\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xff\xff\xff\xff\xff\xff\xff\xff4\0\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xff\xff4\x004\x004\x004\x004\x004\x004\x004\0G\0]\0G\0\xff\xff]\0]\0]\0G\0\xff\xff\xff\xff]\0]\0\xff\xff]\0]\0]\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0]\0\xff\xff]\0]\0]\0]\0]\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff_\0\xff\xff_\0_\0_\0_\0\xff\xff\xff\xff\xff\xff_\0_\0\xff\xff_\0_\0_\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffG\0\xff\xff]\0\xff\xff\xff\xff_\0G\0_\0_\0_\0_\0_\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffG\0\xff\xff\xff\xff\xff\xffG\0\xff\xffG\0\xff\xffj\0\xff\xffG\0j\0j\0j\0]\0\xff\xff]\0j\0j\0\xff\xffj\0j\0j\0_\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffj\0\xff\xffj\0j\0j\0j\0j\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffk\0\xff\xff\xff\xffk\0k\0k\0_\0\xff\xff_\0k\0k\0\xff\xffk\0k\0k\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffj\0\xff\xff\xff\xffk\0\xff\xffk\0k\0k\0k\0k\0\xff\xff\xff\xff\xff\xffl\0\xff\xff\xff\xffl\0l\0l\0\xff\xff\xff\xff\xff\xffl\0l\0\xff\xffl\0l\0l\0\xff\xff\xff\xffj\0\xff\xffj\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffl\0k\0l\0l\0l\0l\0l\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffm\0\xff\xff\xff\xffm\0m\0m\0\xff\xff\xff\xff\xff\xffm\0m\0\xff\xffm\0m\0m\0\xff\xff\xff\xff\xff\xffk\0\xff\xffk\0\xff\xff\xff\xffl\0\xff\xffm\0G\0m\0m\0m\0m\0m\0\xff\xff\xff\xff\xff\xffs\0\xff\xff\xff\xffs\0s\0s\0\xff\xff\xff\xff\xff\xffs\0s\0\xff\xffs\0s\0s\0\xff\xff\xff\xff\xff\xffl\0\xff\xffl\0\xff\xff\xff\xff\xff\xff\xff\xffs\0m\0s\0s\0s\0s\0s\0\xff\xff\xff\xff\xff\xff}\0\xff\xff\xff\xff}\0}\0}\0\xff\xff\xff\xff\xff\xff}\0}\0\xff\xff}\0}\0}\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffm\0\xff\xffm\0\xff\xff}\0s\0}\0}\0}\0}\0}\0\xff\xff\xff\xff\xff\xff\x80\0\xff\xff\xff\xff\x80\0\x80\0\x80\0\xff\xff\xff\xff\xff\xff\x80\0\x80\0\xff\xff\x80\0\x80\0\x80\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffs\0\xff\xffs\0\xff\xff\x80\0}\0\x80\0\x80\0\x80\0\x80\0\x80\0\xff\xff\xff\xff\xff\xff\x81\0\xff\xff\xff\xff\x81\0\x81\0\x81\0\xff\xff\xff\xff\xff\xff\x81\0\x81\0\xff\xff\x81\0\x81\0\x81\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff}\0\xff\xff}\0\xff\xff\x81\0\x80\0\x81\0\x81\0\x81\0\x81\0\x81\0\xff\xff\xff\xff\xff\xff\x82\0\xff\xff\xff\xff\x82\0\x82\0\x82\0\xff\xff\xff\xff\xff\xff\x82\0\x82\0\xff\xff\x82\0\x82\0\x82\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x80\0\xff\xff\x80\0\xff\xff\x82\0\x81\0\x82\0\x82\0\x82\0\x82\0\x82\0\xff\xff\xff\xff\xff\xff\x83\0\xff\xff\xff\xff\x83\0\x83\0\x83\0\xff\xff\xff\xff\xff\xff\x83\0\x83\0\xff\xff\x83\0\x83\0\x83\0\xff\xff\xff\xff\x92\0\xff\xff\x92\0\xff\xff\x81\0\xff\xff\x81\0\x92\0\x83\0\x82\0\x83\0\x83\0\x83\0\x83\0\x83\0\xff\xff\x92\0\x92\0\x92\0\x92\0\x92\0\x92\0\x92\0\x92\0\x92\0\x92\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x82\0\xff\xff\x82\0\xff\xff\xff\xff\x83\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x92\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x92\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0\x83\0\xa9\0\x83\0\xff\xff\x92\0\xff\xff\xa9\0\xff\xff\x92\0\xff\xff\x92\0\xff\xff\xff\xff\xff\xff\x92\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0",
  lex_base_code: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\0$\0\f\0\0\0\0\0\0\0\x02\0\0\0\x1b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
  lex_backtrk_code: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
  lex_default_code: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
  lex_trans_code: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0$\0$\0\0\0$\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\x01\0\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\x01\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
  lex_check_code: "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x18\0e\0\xa9\0\xb0\0e\0\xb1\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x18\0\xff\xffe\0\0\0f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\0a\0\xff\xff\xff\xff\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0a\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffa\0a\0a\0a\0a\0a\0a\0a\0a\0a\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffe\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
  lex_code: "\xff\x04\xff\xff\x05\xff\xff\x07\xff\x06\xff\xff\x03\xff\0\x04\x01\x05\xff\x07\xff\xff\x06\xff\x07\xff\xff\0\x04\x01\x05\x03\x06\x02\x07\xff\x01\xff\xff\0\x01\xff"
end;

function token(lexbuf) do
  lexbuf.lex_mem = Caml_array.caml_make_vect(8, -1);
  lexbuf_1 = lexbuf;
  ___ocaml_lex_state = 0;
  while(true) do
    __ocaml_lex_state = ___ocaml_lex_state;
    __ocaml_lex_state_1 = Lexing.new_engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf_1);
    local ___conditional___=(__ocaml_lex_state_1);
    do
       if ___conditional___ == 0 then do
          if (not escaped_newlines.contents) then do
            error({
              __Error_4,
              --[[ Illegal_character ]]Block.__(0, {Lexing.lexeme_char(lexbuf_1, 0)}),
              curr(lexbuf_1)
            })
          end
           end 
          update_loc(lexbuf_1, undefined, 1, false, 0);
          return token(lexbuf_1); end end 
       if ___conditional___ == 1 then do
          update_loc(lexbuf_1, undefined, 1, false, 0);
          return --[[ EOL ]]100; end end 
       if ___conditional___ == 2 then do
          return token(lexbuf_1); end end 
       if ___conditional___ == 3 then do
          return --[[ UNDERSCORE ]]94; end end 
       if ___conditional___ == 4 then do
          return --[[ TILDE ]]89; end end 
       if ___conditional___ == 5 then do
          return --[[ LABEL ]]Block.__(10, {get_label_name(lexbuf_1)}); end end 
       if ___conditional___ == 6 then do
          prerr_warning(curr(lexbuf_1), --[[ Deprecated ]]Block.__(0, {"ISO-Latin1 characters in identifiers"}));
          return --[[ LABEL ]]Block.__(10, {get_label_name(lexbuf_1)}); end end 
       if ___conditional___ == 7 then do
          return --[[ QUESTION ]]76; end end 
       if ___conditional___ == 8 then do
          return --[[ OPTLABEL ]]Block.__(13, {get_label_name(lexbuf_1)}); end end 
       if ___conditional___ == 9 then do
          prerr_warning(curr(lexbuf_1), --[[ Deprecated ]]Block.__(0, {"ISO-Latin1 characters in identifiers"}));
          return --[[ OPTLABEL ]]Block.__(13, {get_label_name(lexbuf_1)}); end end 
       if ___conditional___ == 10 then do
          s = Lexing.lexeme(lexbuf_1);
          xpcall(function() do
            return Hashtbl.find(keyword_table, s);
          end end,function(exn) do
            if (exn == Caml_builtin_exceptions.not_found) then do
              return --[[ LIDENT ]]Block.__(11, {s});
            end else do
              error(exn)
            end end 
          end end) end end 
       if ___conditional___ == 11 then do
          prerr_warning(curr(lexbuf_1), --[[ Deprecated ]]Block.__(0, {"ISO-Latin1 characters in identifiers"}));
          return --[[ LIDENT ]]Block.__(11, {Lexing.lexeme(lexbuf_1)}); end end 
       if ___conditional___ == 12 then do
          return --[[ UIDENT ]]Block.__(17, {Lexing.lexeme(lexbuf_1)}); end end 
       if ___conditional___ == 13 then do
          prerr_warning(curr(lexbuf_1), --[[ Deprecated ]]Block.__(0, {"ISO-Latin1 characters in identifiers"}));
          return --[[ UIDENT ]]Block.__(17, {Lexing.lexeme(lexbuf_1)}); end end 
       if ___conditional___ == 14 then do
          xpcall(function() do
            return --[[ INT ]]Block.__(7, {cvt_int_literal(Lexing.lexeme(lexbuf_1))});
          end end,function(raw_exn) do
            exn_1 = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn_1[0] == Caml_builtin_exceptions.failure) then do
              error({
                __Error_4,
                --[[ Literal_overflow ]]Block.__(5, {"int"}),
                curr(lexbuf_1)
              })
            end
             end 
            error(exn_1)
          end end) end end 
       if ___conditional___ == 15 then do
          return --[[ FLOAT ]]Block.__(1, {remove_underscores(Lexing.lexeme(lexbuf_1))}); end end 
       if ___conditional___ == 16 then do
          xpcall(function() do
            return --[[ INT32 ]]Block.__(8, {cvt_int32_literal(Lexing.lexeme(lexbuf_1))});
          end end,function(raw_exn_1) do
            exn_2 = Caml_js_exceptions.internalToOCamlException(raw_exn_1);
            if (exn_2[0] == Caml_builtin_exceptions.failure) then do
              error({
                __Error_4,
                --[[ Literal_overflow ]]Block.__(5, {"int32"}),
                curr(lexbuf_1)
              })
            end
             end 
            error(exn_2)
          end end) end end 
       if ___conditional___ == 17 then do
          xpcall(function() do
            return --[[ INT64 ]]Block.__(9, {cvt_int64_literal(Lexing.lexeme(lexbuf_1))});
          end end,function(raw_exn_2) do
            exn_3 = Caml_js_exceptions.internalToOCamlException(raw_exn_2);
            if (exn_3[0] == Caml_builtin_exceptions.failure) then do
              error({
                __Error_4,
                --[[ Literal_overflow ]]Block.__(5, {"int64"}),
                curr(lexbuf_1)
              })
            end
             end 
            error(exn_3)
          end end) end end 
       if ___conditional___ == 18 then do
          xpcall(function() do
            return --[[ NATIVEINT ]]Block.__(12, {cvt_nativeint_literal(Lexing.lexeme(lexbuf_1))});
          end end,function(raw_exn_3) do
            exn_4 = Caml_js_exceptions.internalToOCamlException(raw_exn_3);
            if (exn_4[0] == Caml_builtin_exceptions.failure) then do
              error({
                __Error_4,
                --[[ Literal_overflow ]]Block.__(5, {"nativeint"}),
                curr(lexbuf_1)
              })
            end
             end 
            error(exn_4)
          end end) end end 
       if ___conditional___ == 19 then do
          reset_string_buffer(--[[ () ]]0);
          is_in_string.contents = true;
          string_start = lexbuf_1.lex_start_p;
          string_start_loc.contents = curr(lexbuf_1);
          string(lexbuf_1);
          is_in_string.contents = false;
          lexbuf_1.lex_start_p = string_start;
          return --[[ STRING ]]Block.__(16, {--[[ tuple ]]{
                      get_stored_string(--[[ () ]]0),
                      undefined
                    }}); end end 
       if ___conditional___ == 20 then do
          reset_string_buffer(--[[ () ]]0);
          delim = Lexing.lexeme(lexbuf_1);
          delim_1 = __String.sub(delim, 1, #delim - 2 | 0);
          is_in_string.contents = true;
          string_start_1 = lexbuf_1.lex_start_p;
          string_start_loc.contents = curr(lexbuf_1);
          __ocaml_lex_quoted_string_rec(delim_1, lexbuf_1, 183);
          is_in_string.contents = false;
          lexbuf_1.lex_start_p = string_start_1;
          return --[[ STRING ]]Block.__(16, {--[[ tuple ]]{
                      get_stored_string(--[[ () ]]0),
                      delim_1
                    }}); end end 
       if ___conditional___ == 21 then do
          update_loc(lexbuf_1, undefined, 1, false, 1);
          return --[[ CHAR ]]Block.__(0, {Lexing.lexeme_char(lexbuf_1, 1)}); end end 
       if ___conditional___ == 22 then do
          return --[[ CHAR ]]Block.__(0, {Lexing.lexeme_char(lexbuf_1, 1)}); end end 
       if ___conditional___ == 23 then do
          return --[[ CHAR ]]Block.__(0, {char_for_backslash(Lexing.lexeme_char(lexbuf_1, 2))}); end end 
       if ___conditional___ == 24 then do
          return --[[ CHAR ]]Block.__(0, {char_for_decimal_code(lexbuf_1, 2)}); end end 
       if ___conditional___ == 25 then do
          return --[[ CHAR ]]Block.__(0, {char_for_hexadecimal_code(lexbuf_1, 3)}); end end 
       if ___conditional___ == 26 then do
          l = Lexing.lexeme(lexbuf_1);
          esc = __String.sub(l, 1, #l - 1 | 0);
          error({
            __Error_4,
            --[[ Illegal_escape ]]Block.__(1, {esc}),
            curr(lexbuf_1)
          }) end end 
       if ___conditional___ == 27 then do
          match = with_comment_buffer(comment, lexbuf_1);
          return --[[ COMMENT ]]Block.__(18, {--[[ tuple ]]{
                      match[0],
                      match[1]
                    }}); end end 
       if ___conditional___ == 28 then do
          match_1 = with_comment_buffer(comment, lexbuf_1);
          return --[[ DOCSTRING ]]Block.__(19, {docstring(match_1[0], match_1[1])}); end end 
       if ___conditional___ == 29 then do
          stars = Lexing.sub_lexeme(lexbuf_1, lexbuf_1.lex_start_pos, lexbuf_1.lex_curr_pos);
          match_2 = with_comment_buffer((function(stars)do
              return function (lexbuf) do
                store_string("*" .. stars);
                return __ocaml_lex_comment_rec(lexbuf, 132);
              end end
              end end)(stars), lexbuf_1);
          return --[[ COMMENT ]]Block.__(18, {--[[ tuple ]]{
                      match_2[0],
                      match_2[1]
                    }}); end end 
       if ___conditional___ == 30 then do
          if (print_warnings.contents) then do
            prerr_warning(curr(lexbuf_1), --[[ Comment_start ]]0);
          end
           end 
          match_3 = with_comment_buffer(comment, lexbuf_1);
          return --[[ COMMENT ]]Block.__(18, {--[[ tuple ]]{
                      match_3[0],
                      match_3[1]
                    }}); end end 
       if ___conditional___ == 31 then do
          stars_1 = Lexing.sub_lexeme(lexbuf_1, lexbuf_1.lex_start_pos, lexbuf_1.lex_curr_pos - 2 | 0);
          return --[[ COMMENT ]]Block.__(18, {--[[ tuple ]]{
                      stars_1,
                      curr(lexbuf_1)
                    }}); end end 
       if ___conditional___ == 32 then do
          loc = curr(lexbuf_1);
          prerr_warning(loc, --[[ Comment_not_end ]]1);
          lexbuf_1.lex_curr_pos = lexbuf_1.lex_curr_pos - 1 | 0;
          curpos = lexbuf_1.lex_curr_p;
          lexbuf_1.lex_curr_p = do
            pos_fname: curpos.pos_fname,
            pos_lnum: curpos.pos_lnum,
            pos_bol: curpos.pos_bol,
            pos_cnum: curpos.pos_cnum - 1 | 0
          end;
          return --[[ STAR ]]86; end end 
       if ___conditional___ == 33 then do
          num = Lexing.sub_lexeme(lexbuf_1, Caml_array.caml_array_get(lexbuf_1.lex_mem, 0), Caml_array.caml_array_get(lexbuf_1.lex_mem, 1));
          name = Lexing.sub_lexeme_opt(lexbuf_1, Caml_array.caml_array_get(lexbuf_1.lex_mem, 3), Caml_array.caml_array_get(lexbuf_1.lex_mem, 2));
          update_loc(lexbuf_1, name, Caml_format.caml_int_of_string(num), true, 0);
          return token(lexbuf_1); end end 
       if ___conditional___ == 34 then do
          return --[[ SHARP ]]84; end end 
       if ___conditional___ == 35 then do
          return --[[ AMPERSAND ]]1; end end 
       if ___conditional___ == 36 then do
          return --[[ AMPERAMPER ]]0; end end 
       if ___conditional___ == 37 then do
          return --[[ BACKQUOTE ]]5; end end 
       if ___conditional___ == 38 then do
          return --[[ QUOTE ]]77; end end 
       if ___conditional___ == 39 then do
          return --[[ LPAREN ]]54; end end 
       if ___conditional___ == 40 then do
          return --[[ RPAREN ]]81; end end 
       if ___conditional___ == 41 then do
          return --[[ STAR ]]86; end end 
       if ___conditional___ == 42 then do
          return --[[ COMMA ]]16; end end 
       if ___conditional___ == 43 then do
          return --[[ MINUSGREATER ]]62; end end 
       if ___conditional___ == 44 then do
          return --[[ DOT ]]20; end end 
       if ___conditional___ == 45 then do
          return --[[ DOTDOT ]]21; end end 
       if ___conditional___ == 46 then do
          return --[[ COLON ]]12; end end 
       if ___conditional___ == 47 then do
          return --[[ COLONCOLON ]]13; end end 
       if ___conditional___ == 48 then do
          return --[[ COLONEQUAL ]]14; end end 
       if ___conditional___ == 49 then do
          return --[[ COLONGREATER ]]15; end end 
       if ___conditional___ == 50 then do
          return --[[ SEMI ]]82; end end 
       if ___conditional___ == 51 then do
          return --[[ SEMISEMI ]]83; end end 
       if ___conditional___ == 52 then do
          return --[[ LESS ]]51; end end 
       if ___conditional___ == 53 then do
          return --[[ LESSMINUS ]]52; end end 
       if ___conditional___ == 54 then do
          return --[[ EQUAL ]]26; end end 
       if ___conditional___ == 55 then do
          return --[[ LBRACKET ]]45; end end 
       if ___conditional___ == 56 then do
          return --[[ LBRACKETBAR ]]46; end end 
       if ___conditional___ == 57 then do
          return --[[ LBRACKETLESS ]]47; end end 
       if ___conditional___ == 58 then do
          return --[[ LBRACKETGREATER ]]48; end end 
       if ___conditional___ == 59 then do
          return --[[ RBRACKET ]]79; end end 
       if ___conditional___ == 60 then do
          return --[[ LBRACE ]]43; end end 
       if ___conditional___ == 61 then do
          return --[[ LBRACELESS ]]44; end end 
       if ___conditional___ == 62 then do
          return --[[ BAR ]]7; end end 
       if ___conditional___ == 63 then do
          return --[[ BARBAR ]]8; end end 
       if ___conditional___ == 64 then do
          return --[[ BARRBRACKET ]]9; end end 
       if ___conditional___ == 65 then do
          return --[[ GREATER ]]34; end end 
       if ___conditional___ == 66 then do
          return --[[ GREATERRBRACKET ]]36; end end 
       if ___conditional___ == 67 then do
          return --[[ RBRACE ]]78; end end 
       if ___conditional___ == 68 then do
          return --[[ GREATERRBRACE ]]35; end end 
       if ___conditional___ == 69 then do
          return --[[ LBRACKETAT ]]55; end end 
       if ___conditional___ == 70 then do
          return --[[ LBRACKETPERCENT ]]49; end end 
       if ___conditional___ == 71 then do
          return --[[ LBRACKETPERCENTPERCENT ]]50; end end 
       if ___conditional___ == 72 then do
          return --[[ LBRACKETATAT ]]56; end end 
       if ___conditional___ == 73 then do
          return --[[ LBRACKETATATAT ]]57; end end 
       if ___conditional___ == 74 then do
          return --[[ BANG ]]6; end end 
       if ___conditional___ == 75 then do
          return --[[ INFIXOP0 ]]Block.__(2, {"!="}); end end 
       if ___conditional___ == 76 then do
          return --[[ PLUS ]]72; end end 
       if ___conditional___ == 77 then do
          return --[[ PLUSDOT ]]73; end end 
       if ___conditional___ == 78 then do
          return --[[ PLUSEQ ]]74; end end 
       if ___conditional___ == 79 then do
          return --[[ MINUS ]]60; end end 
       if ___conditional___ == 80 then do
          return --[[ MINUSDOT ]]61; end end 
       if ___conditional___ == 81
       or ___conditional___ == 82 then do
          return --[[ PREFIXOP ]]Block.__(14, {Lexing.lexeme(lexbuf_1)}); end end 
       if ___conditional___ == 83 then do
          return --[[ INFIXOP0 ]]Block.__(2, {Lexing.lexeme(lexbuf_1)}); end end 
       if ___conditional___ == 84 then do
          return --[[ INFIXOP1 ]]Block.__(3, {Lexing.lexeme(lexbuf_1)}); end end 
       if ___conditional___ == 85 then do
          return --[[ INFIXOP2 ]]Block.__(4, {Lexing.lexeme(lexbuf_1)}); end end 
       if ___conditional___ == 86 then do
          return --[[ INFIXOP4 ]]Block.__(6, {Lexing.lexeme(lexbuf_1)}); end end 
       if ___conditional___ == 87 then do
          return --[[ PERCENT ]]71; end end 
       if ___conditional___ == 88 then do
          return --[[ INFIXOP3 ]]Block.__(5, {Lexing.lexeme(lexbuf_1)}); end end 
       if ___conditional___ == 89 then do
          return --[[ SHARPOP ]]Block.__(15, {Lexing.lexeme(lexbuf_1)}); end end 
       if ___conditional___ == 90 then do
          if (if_then_else.contents ~= --[[ Dir_out ]]2) then do
            if (if_then_else.contents == --[[ Dir_if_true ]]0) then do
              error({
                __Error_4,
                --[[ Unterminated_if ]]2,
                curr(lexbuf_1)
              })
            end
             end 
            error({
              __Error_4,
              --[[ Unterminated_else ]]3,
              curr(lexbuf_1)
            })
          end else do
            return --[[ EOF ]]25;
          end end  end end 
       if ___conditional___ == 91 then do
          error({
            __Error_4,
            --[[ Illegal_character ]]Block.__(0, {Lexing.lexeme_char(lexbuf_1, 0)}),
            curr(lexbuf_1)
          }) end end 
      Curry._1(lexbuf_1.refill_buff, lexbuf_1);
        ___ocaml_lex_state = __ocaml_lex_state_1;
        ::continue:: ;
        
    end
  end;
end end

function __ocaml_lex_quoted_string_rec(delim, lexbuf, ___ocaml_lex_state) do
  while(true) do
    __ocaml_lex_state = ___ocaml_lex_state;
    __ocaml_lex_state_1 = Lexing.engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf);
    local ___conditional___=(__ocaml_lex_state_1);
    do
       if ___conditional___ == 0 then do
          update_loc(lexbuf, undefined, 1, false, 0);
          store_string(Lexing.lexeme(lexbuf));
          ___ocaml_lex_state = 183;
          ::continue:: ; end end 
       if ___conditional___ == 1 then do
          is_in_string.contents = false;
          error({
            __Error_4,
            --[[ Unterminated_string ]]0,
            string_start_loc.contents
          }) end end 
       if ___conditional___ == 2 then do
          edelim = Lexing.lexeme(lexbuf);
          edelim_1 = __String.sub(edelim, 1, #edelim - 2 | 0);
          if (delim == edelim_1) then do
            return --[[ () ]]0;
          end else do
            store_string(Lexing.lexeme(lexbuf));
            ___ocaml_lex_state = 183;
            ::continue:: ;
          end end  end end 
       if ___conditional___ == 3 then do
          store_string_char(Lexing.lexeme_char(lexbuf, 0));
          ___ocaml_lex_state = 183;
          ::continue:: ; end end 
      Curry._1(lexbuf.refill_buff, lexbuf);
        ___ocaml_lex_state = __ocaml_lex_state_1;
        ::continue:: ;
        
    end
  end;
end end

function __ocaml_lex_comment_rec(lexbuf, ___ocaml_lex_state) do
  while(true) do
    __ocaml_lex_state = ___ocaml_lex_state;
    __ocaml_lex_state_1 = Lexing.engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf);
    local ___conditional___=(__ocaml_lex_state_1);
    do
       if ___conditional___ == 0 then do
          comment_start_loc.contents = --[[ :: ]]{
            curr(lexbuf),
            comment_start_loc.contents
          };
          store_string(Lexing.lexeme(lexbuf));
          ___ocaml_lex_state = 132;
          ::continue:: ; end end 
       if ___conditional___ == 1 then do
          match = comment_start_loc.contents;
          if (match) then do
            l = match[1];
            if (l) then do
              comment_start_loc.contents = l;
              store_string(Lexing.lexeme(lexbuf));
              ___ocaml_lex_state = 132;
              ::continue:: ;
            end else do
              comment_start_loc.contents = --[[ [] ]]0;
              return curr(lexbuf);
            end end 
          end else do
            error({
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "lexer.mll",
                989,
                16
              }
            })
          end end  end end 
       if ___conditional___ == 2 then do
          string_start_loc.contents = curr(lexbuf);
          store_string_char(--[[ "\"" ]]34);
          is_in_string.contents = true;
          xpcall(function() do
            string(lexbuf);
          end end,function(raw_exn) do
            exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn[0] == __Error_4) then do
              match_1 = exn[1];
              if (typeof match_1 == "number") then do
                if (match_1 ~= 0) then do
                  error(exn)
                end
                 end 
                match_2 = comment_start_loc.contents;
                if (match_2) then do
                  start = List.hd(List.rev(comment_start_loc.contents));
                  comment_start_loc.contents = --[[ [] ]]0;
                  error({
                    __Error_4,
                    --[[ Unterminated_string_in_comment ]]Block.__(3, {
                        start,
                        exn[2]
                      }),
                    match_2[0]
                  })
                end else do
                  error({
                    Caml_builtin_exceptions.assert_failure,
                    --[[ tuple ]]{
                      "lexer.mll",
                      1003,
                      18
                    }
                  })
                end end 
              end else do
                error(exn)
              end end 
            end else do
              error(exn)
            end end 
          end end)
          is_in_string.contents = false;
          store_string_char(--[[ "\"" ]]34);
          ___ocaml_lex_state = 132;
          ::continue:: ; end end 
       if ___conditional___ == 3 then do
          delim = Lexing.lexeme(lexbuf);
          delim_1 = __String.sub(delim, 1, #delim - 2 | 0);
          string_start_loc.contents = curr(lexbuf);
          store_string(Lexing.lexeme(lexbuf));
          is_in_string.contents = true;
          xpcall(function() do
            __ocaml_lex_quoted_string_rec(delim_1, lexbuf, 183);
          end end,function(raw_exn_1) do
            exn_1 = Caml_js_exceptions.internalToOCamlException(raw_exn_1);
            if (exn_1[0] == __Error_4) then do
              match_3 = exn_1[1];
              if (typeof match_3 == "number") then do
                if (match_3 ~= 0) then do
                  error(exn_1)
                end
                 end 
                match_4 = comment_start_loc.contents;
                if (match_4) then do
                  start_1 = List.hd(List.rev(comment_start_loc.contents));
                  comment_start_loc.contents = --[[ [] ]]0;
                  error({
                    __Error_4,
                    --[[ Unterminated_string_in_comment ]]Block.__(3, {
                        start_1,
                        exn_1[2]
                      }),
                    match_4[0]
                  })
                end else do
                  error({
                    Caml_builtin_exceptions.assert_failure,
                    --[[ tuple ]]{
                      "lexer.mll",
                      1023,
                      18
                    }
                  })
                end end 
              end else do
                error(exn_1)
              end end 
            end else do
              error(exn_1)
            end end 
          end end)
          is_in_string.contents = false;
          store_string_char(--[[ "|" ]]124);
          store_string(delim_1);
          store_string_char(--[[ "}" ]]125);
          ___ocaml_lex_state = 132;
          ::continue:: ; end end 
       if ___conditional___ == 5 then do
          update_loc(lexbuf, undefined, 1, false, 1);
          store_string(Lexing.lexeme(lexbuf));
          ___ocaml_lex_state = 132;
          ::continue:: ; end end 
       if ___conditional___ == 10 then do
          match_5 = comment_start_loc.contents;
          if (match_5) then do
            start_2 = List.hd(List.rev(comment_start_loc.contents));
            comment_start_loc.contents = --[[ [] ]]0;
            error({
              __Error_4,
              --[[ Unterminated_comment ]]Block.__(2, {start_2}),
              match_5[0]
            })
          end else do
            error({
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "lexer.mll",
                1053,
                16
              }
            })
          end end  end end 
       if ___conditional___ == 11 then do
          update_loc(lexbuf, undefined, 1, false, 0);
          store_string(Lexing.lexeme(lexbuf));
          ___ocaml_lex_state = 132;
          ::continue:: ; end end 
       if ___conditional___ == 4
       or ___conditional___ == 6
       or ___conditional___ == 7
       or ___conditional___ == 8
       or ___conditional___ == 9
       or ___conditional___ == 12 then do
          store_string(Lexing.lexeme(lexbuf));
          ___ocaml_lex_state = 132;
          ::continue:: ; end end 
      Curry._1(lexbuf.refill_buff, lexbuf);
        ___ocaml_lex_state = __ocaml_lex_state_1;
        ::continue:: ;
        
    end
  end;
end end

function string(lexbuf) do
  lexbuf.lex_mem = Caml_array.caml_make_vect(2, -1);
  lexbuf_1 = lexbuf;
  ___ocaml_lex_state = 164;
  while(true) do
    __ocaml_lex_state = ___ocaml_lex_state;
    __ocaml_lex_state_1 = Lexing.new_engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf_1);
    local ___conditional___=(__ocaml_lex_state_1);
    do
       if ___conditional___ == 0 then do
          return --[[ () ]]0; end end 
       if ___conditional___ == 1 then do
          space = Lexing.sub_lexeme(lexbuf_1, Caml_array.caml_array_get(lexbuf_1.lex_mem, 0), lexbuf_1.lex_curr_pos);
          update_loc(lexbuf_1, undefined, 1, false, #space);
          return string(lexbuf_1); end end 
       if ___conditional___ == 2 then do
          store_string_char(char_for_backslash(Lexing.lexeme_char(lexbuf_1, 1)));
          return string(lexbuf_1); end end 
       if ___conditional___ == 3 then do
          store_string_char(char_for_decimal_code(lexbuf_1, 1));
          return string(lexbuf_1); end end 
       if ___conditional___ == 4 then do
          store_string_char(char_for_hexadecimal_code(lexbuf_1, 2));
          return string(lexbuf_1); end end 
       if ___conditional___ == 5 then do
          if (comment_start_loc.contents ~= --[[ [] ]]0) then do
            return string(lexbuf_1);
          end else do
            loc = curr(lexbuf_1);
            prerr_warning(loc, --[[ Illegal_backslash ]]7);
            store_string_char(Lexing.lexeme_char(lexbuf_1, 0));
            store_string_char(Lexing.lexeme_char(lexbuf_1, 1));
            return string(lexbuf_1);
          end end  end end 
       if ___conditional___ == 6 then do
          if (comment_start_loc.contents == --[[ [] ]]0) then do
            prerr_warning(curr(lexbuf_1), --[[ Eol_in_string ]]14);
          end
           end 
          update_loc(lexbuf_1, undefined, 1, false, 0);
          store_string(Lexing.lexeme(lexbuf_1));
          return string(lexbuf_1); end end 
       if ___conditional___ == 7 then do
          is_in_string.contents = false;
          error({
            __Error_4,
            --[[ Unterminated_string ]]0,
            string_start_loc.contents
          }) end end 
       if ___conditional___ == 8 then do
          store_string_char(Lexing.lexeme_char(lexbuf_1, 0));
          return string(lexbuf_1); end end 
      Curry._1(lexbuf_1.refill_buff, lexbuf_1);
        ___ocaml_lex_state = __ocaml_lex_state_1;
        ::continue:: ;
        
    end
  end;
end end

function comment(lexbuf) do
  return __ocaml_lex_comment_rec(lexbuf, 132);
end end

function at_bol(lexbuf) do
  pos = lexbuf.lex_start_p;
  return pos.pos_cnum == pos.pos_bol;
end end

function token_with_comments(lexbuf) do
  match = preprocessor.contents;
  if (match ~= undefined) then do
    return Curry._2(match[1], token, lexbuf);
  end else do
    return token(lexbuf);
  end end 
end end

function token_1(lexbuf) do
  post_pos = lexbuf.lex_curr_p;
  attach = function(lines, docs, pre_pos) do
    if (typeof docs == "number") then do
      return --[[ () ]]0;
    end else if (docs.tag) then do
      b = docs[2];
      f = docs[1];
      a = docs[0];
      if (lines >= 2) then do
        set_post_docstrings(post_pos, List.rev(a));
        set_post_extra_docstrings(post_pos, List.rev_append(f, List.rev(b)));
        set_floating_docstrings(pre_pos, List.rev_append(f, List.rev(b)));
        return set_pre_extra_docstrings(pre_pos, List.rev(a));
      end else do
        set_post_docstrings(post_pos, List.rev(a));
        set_post_extra_docstrings(post_pos, List.rev_append(f, List.rev(b)));
        set_floating_docstrings(pre_pos, List.rev(f));
        set_pre_extra_docstrings(pre_pos, List.rev(a));
        return set_pre_docstrings(pre_pos, b);
      end end 
    end else do
      a_1 = docs[0];
      if (lines >= 2) then do
        set_post_docstrings(post_pos, List.rev(a_1));
        return set_pre_extra_docstrings(pre_pos, List.rev(a_1));
      end else do
        set_post_docstrings(post_pos, List.rev(a_1));
        return set_pre_docstrings(pre_pos, a_1);
      end end 
    end end  end 
  end end;
  loop = function(_lines, _docs, lexbuf) do
    while(true) do
      docs = _docs;
      lines = _lines;
      tok = token_with_comments(lexbuf);
      if (typeof tok == "number") then do
        local ___conditional___=(tok);
        do
           if ___conditional___ == 84--[[ SHARP ]] then do
              if (at_bol(lexbuf)) then do
                lexbuf_1 = lexbuf;
                cont = (function(lines,docs)do
                return function cont(lexbuf) do
                  return loop(lines, docs, lexbuf);
                end end
                end end)(lines,docs);
                look_ahead = function(token) do
                  sharp_look_ahead.contents = token;
                  return --[[ SHARP ]]84;
                end end;
                if_then_else_1 = if_then_else.contents;
                match = token_with_comments(lexbuf_1);
                if (typeof match == "number") then do
                  local ___conditional___=(match);
                  do
                     if ___conditional___ == 23--[[ ELSE ]] then do
                        if (if_then_else_1 ~= 0) then do
                          error({
                            __Error_4,
                            --[[ Unexpected_directive ]]6,
                            curr(lexbuf_1)
                          })
                        end
                         end  end else 
                     if ___conditional___ == 24--[[ END ]] then do
                        if (if_then_else_1 >= 2) then do
                          error({
                            __Error_4,
                            --[[ Unexpected_directive ]]6,
                            curr(lexbuf_1)
                          })
                        end
                         end 
                        if_then_else.contents = --[[ Dir_out ]]2;
                        return Curry._1(cont, lexbuf_1); end end end end 
                     if ___conditional___ == 37--[[ IF ]] then do
                        if (if_then_else_1 >= 2) then do
                          if (directive_parse(token_with_comments, lexbuf_1)) then do
                            if_then_else.contents = --[[ Dir_if_true ]]0;
                            return Curry._1(cont, lexbuf_1);
                          end else do
                            _param = --[[ () ]]0;
                            while(true) do
                              token = token_with_comments(lexbuf_1);
                              if (token == --[[ EOF ]]25) then do
                                error({
                                  __Error_4,
                                  --[[ Unterminated_if ]]2,
                                  curr(lexbuf_1)
                                })
                              end
                               end 
                              if (token == --[[ SHARP ]]84 and at_bol(lexbuf_1)) then do
                                token_1 = token_with_comments(lexbuf_1);
                                if (typeof token_1 == "number") then do
                                  switcher = token_1 - 23 | 0;
                                  if (switcher == 0 or switcher == 1) then do
                                    if (switcher ~= 0) then do
                                      if_then_else.contents = --[[ Dir_out ]]2;
                                      return Curry._1(cont, lexbuf_1);
                                    end else do
                                      if_then_else.contents = --[[ Dir_if_false ]]1;
                                      return Curry._1(cont, lexbuf_1);
                                    end end 
                                  end else if (switcher == 14) then do
                                    error({
                                      __Error_4,
                                      --[[ Unexpected_directive ]]6,
                                      curr(lexbuf_1)
                                    })
                                  end
                                   end  end 
                                end
                                 end 
                                if (is_elif(token_1) and directive_parse(token_with_comments, lexbuf_1)) then do
                                  if_then_else.contents = --[[ Dir_if_true ]]0;
                                  return Curry._1(cont, lexbuf_1);
                                end else do
                                  _param = --[[ () ]]0;
                                  ::continue:: ;
                                end end 
                              end else do
                                _param = --[[ () ]]0;
                                ::continue:: ;
                              end end 
                            end;
                          end end 
                        end else do
                          error({
                            __Error_4,
                            --[[ Unexpected_directive ]]6,
                            curr(lexbuf_1)
                          })
                        end end  end end 
                    return Curry._1(look_ahead, match);
                      
                  end
                end else if (match.tag == --[[ LIDENT ]]11 and match[0] == "elif") then do
                  if (if_then_else_1 ~= 0) then do
                    error({
                      __Error_4,
                      --[[ Unexpected_directive ]]6,
                      curr(lexbuf_1)
                    })
                  end
                   end 
                end else do
                  return Curry._1(look_ahead, match);
                end end  end 
                if (if_then_else_1 ~= 0) then do
                  return Curry._1(look_ahead, match);
                end else do
                  _else_seen = match == --[[ ELSE ]]23;
                  while(true) do
                    else_seen = _else_seen;
                    token_2 = token_with_comments(lexbuf_1);
                    if (token_2 == --[[ EOF ]]25) then do
                      error({
                        __Error_4,
                        --[[ Unterminated_else ]]3,
                        curr(lexbuf_1)
                      })
                    end
                     end 
                    if (token_2 == --[[ SHARP ]]84 and at_bol(lexbuf_1)) then do
                      token_3 = token_with_comments(lexbuf_1);
                      if (typeof token_3 == "number") then do
                        switcher_1 = token_3 - 23 | 0;
                        if (switcher_1 == 0 or switcher_1 == 1) then do
                          if (switcher_1 ~= 0) then do
                            if_then_else.contents = --[[ Dir_out ]]2;
                            return Curry._1(cont, lexbuf_1);
                          end else do
                            if (else_seen) then do
                              error({
                                __Error_4,
                                --[[ Unexpected_directive ]]6,
                                curr(lexbuf_1)
                              })
                            end
                             end 
                            _else_seen = true;
                            ::continue:: ;
                          end end 
                        end else if (switcher_1 == 14) then do
                          error({
                            __Error_4,
                            --[[ Unexpected_directive ]]6,
                            curr(lexbuf_1)
                          })
                        end
                         end  end 
                      end
                       end 
                      if (else_seen and is_elif(token_3)) then do
                        error({
                          __Error_4,
                          --[[ Unexpected_directive ]]6,
                          curr(lexbuf_1)
                        })
                      end
                       end 
                      ::continue:: ;
                    end else do
                      ::continue:: ;
                    end end 
                  end;
                end end 
              end
               end  end else 
           if ___conditional___ == 100--[[ EOL ]] then do
              lines$prime = lines ~= 0 and --[[ BlankLine ]]2 or --[[ NewLine ]]1;
              _lines = lines$prime;
              ::continue:: ; end end end end 
          
        end
      end else do
        local ___conditional___=(tok.tag | 0);
        do
           if ___conditional___ == 18--[[ COMMENT ]] then do
              match_1 = tok[0];
              add_comment(--[[ tuple ]]{
                    match_1[0],
                    match_1[1]
                  });
              lines$prime_1 = lines >= 2 and --[[ BlankLine ]]2 or --[[ NoLine ]]0;
              _lines = lines$prime_1;
              ::continue:: ; end end 
           if ___conditional___ == 19--[[ DOCSTRING ]] then do
              doc = tok[0];
              add_docstring_comment(doc);
              docs$prime;
              if (typeof docs == "number") then do
                docs$prime = lines >= 2 and --[[ Before ]]Block.__(1, {
                      --[[ [] ]]0,
                      --[[ [] ]]0,
                      --[[ :: ]]{
                        doc,
                        --[[ [] ]]0
                      }
                    }) or --[[ After ]]Block.__(0, {--[[ :: ]]{
                        doc,
                        --[[ [] ]]0
                      }});
              end else if (docs.tag) then do
                b = docs[2];
                f = docs[1];
                a = docs[0];
                docs$prime = lines >= 2 and --[[ Before ]]Block.__(1, {
                      a,
                      Pervasives.$at(b, f),
                      --[[ :: ]]{
                        doc,
                        --[[ [] ]]0
                      }
                    }) or --[[ Before ]]Block.__(1, {
                      a,
                      f,
                      --[[ :: ]]{
                        doc,
                        b
                      }
                    });
              end else do
                a_1 = docs[0];
                docs$prime = lines >= 2 and --[[ Before ]]Block.__(1, {
                      a_1,
                      --[[ [] ]]0,
                      --[[ :: ]]{
                        doc,
                        --[[ [] ]]0
                      }
                    }) or --[[ After ]]Block.__(0, {--[[ :: ]]{
                        doc,
                        a_1
                      }});
              end end  end 
              _docs = docs$prime;
              _lines = --[[ NoLine ]]0;
              ::continue:: ; end end 
          
        end
      end end 
      attach(lines, docs, lexbuf.lex_start_p);
      return tok;
    end;
  end end;
  match = sharp_look_ahead.contents;
  if (match ~= undefined) then do
    sharp_look_ahead.contents = undefined;
    return match;
  end else do
    return loop(--[[ NoLine ]]0, --[[ Initial ]]0, lexbuf);
  end end 
end end

function init_1(param) do
  sharp_look_ahead.contents = undefined;
  if_then_else.contents = --[[ Dir_out ]]2;
  is_in_string.contents = false;
  comment_start_loc.contents = --[[ [] ]]0;
  comment_list.contents = --[[ [] ]]0;
  match = preprocessor.contents;
  if (match ~= undefined) then do
    return Curry._1(match[0], --[[ () ]]0);
  end else do
    return --[[ () ]]0;
  end end 
end end

function skip_phrase(lexbuf) do
  while(true) do
    xpcall(function() do
      match = token_1(lexbuf);
      if (typeof match == "number" and not (match ~= 25 and match ~= 83)) then do
        return --[[ () ]]0;
      end else do
        return skip_phrase(lexbuf);
      end end 
    end end,function(raw_exn) do
      exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] == __Error_4) then do
        tmp = exn[1];
        if (typeof tmp == "number") then do
          if (tmp == --[[ Unterminated_string ]]0) then do
            ::continue:: ;
          end else do
            error(exn)
          end end 
        end else do
          local ___conditional___=(tmp.tag | 0);
          do
             if ___conditional___ == 0--[[ Illegal_character ]]
             or ___conditional___ == 2--[[ Unterminated_comment ]]
             or ___conditional___ == 3--[[ Unterminated_string_in_comment ]] then do
                ::continue:: ; end end 
            error(exn)
              
          end
        end end 
      end else do
        error(exn)
      end end 
    end end)
  end;
end end

function maybe_skip_phrase(lexbuf) do
  if (Parsing.is_current_lookahead(--[[ SEMISEMI ]]83) or Parsing.is_current_lookahead(--[[ EOF ]]25)) then do
    return --[[ () ]]0;
  end else do
    return skip_phrase(lexbuf);
  end end 
end end

function wrap_1(parsing_fun, lexbuf) do
  xpcall(function() do
    init(--[[ () ]]0);
    init_1(--[[ () ]]0);
    ast = Curry._2(parsing_fun, token_1, lexbuf);
    Parsing.clear_parser(--[[ () ]]0);
    warn_bad_docstrings(--[[ () ]]0);
    return ast;
  end end,function(raw_err) do
    err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err[0] == __Error_4) then do
      tmp = err[1];
      if (typeof tmp == "number") then do
        error(err)
      end else if (tmp.tag) then do
        error(err)
      end else if (input_name.contents == "//toplevel//") then do
        skip_phrase(lexbuf);
        error(err)
      end else do
        error(err)
      end end  end  end 
    end else if (err[0] == __Error_3) then do
      if (input_name.contents == "//toplevel//") then do
        maybe_skip_phrase(lexbuf);
        error(err)
      end else do
        error(err)
      end end 
    end else if (err ~= Parsing.Parse_error and err ~= Escape_error) then do
      error(err)
    end
     end  end  end 
    loc = curr(lexbuf);
    if (input_name.contents == "//toplevel//") then do
      maybe_skip_phrase(lexbuf);
    end
     end 
    error({
      __Error_3,
      --[[ Other ]]Block.__(5, {loc})
    })
  end end)
end end

function iter_pattern_desc(f, param) do
  if (typeof param == "number") then do
    return --[[ () ]]0;
  end else do
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ == 4--[[ Tpat_construct ]] then do
          return List.iter(f, param[2]); end end 
       if ___conditional___ == 5--[[ Tpat_variant ]] then do
          return may(f, param[1]); end end 
       if ___conditional___ == 6--[[ Tpat_record ]] then do
          return List.iter((function(param) do
                        return Curry._1(f, param[2]);
                      end end), param[0]); end end 
       if ___conditional___ == 3--[[ Tpat_tuple ]]
       or ___conditional___ == 7--[[ Tpat_array ]] then do
          return List.iter(f, param[0]); end end 
       if ___conditional___ == 8--[[ Tpat_or ]] then do
          Curry._1(f, param[0]);
          return Curry._1(f, param[1]); end end 
       if ___conditional___ == 1--[[ Tpat_alias ]]
       or ___conditional___ == 9--[[ Tpat_lazy ]] then do
          return Curry._1(f, param[0]); end end 
      return --[[ () ]]0;
        
    end
  end end 
end end

function map_pattern_desc(f, d) do
  if (typeof d == "number") then do
    return d;
  end else do
    local ___conditional___=(d.tag | 0);
    do
       if ___conditional___ == 1--[[ Tpat_alias ]] then do
          return --[[ Tpat_alias ]]Block.__(1, {
                    Curry._1(f, d[0]),
                    d[1],
                    d[2]
                  }); end end 
       if ___conditional___ == 3--[[ Tpat_tuple ]] then do
          return --[[ Tpat_tuple ]]Block.__(3, {List.map(f, d[0])}); end end 
       if ___conditional___ == 4--[[ Tpat_construct ]] then do
          return --[[ Tpat_construct ]]Block.__(4, {
                    d[0],
                    d[1],
                    List.map(f, d[2])
                  }); end end 
       if ___conditional___ == 5--[[ Tpat_variant ]] then do
          match = d[1];
          if (match ~= undefined) then do
            return --[[ Tpat_variant ]]Block.__(5, {
                      d[0],
                      Curry._1(f, match),
                      d[2]
                    });
          end else do
            return d;
          end end  end end 
       if ___conditional___ == 6--[[ Tpat_record ]] then do
          return --[[ Tpat_record ]]Block.__(6, {
                    List.map((function(param) do
                            return --[[ tuple ]]{
                                    param[0],
                                    param[1],
                                    Curry._1(f, param[2])
                                  };
                          end end), d[0]),
                    d[1]
                  }); end end 
       if ___conditional___ == 7--[[ Tpat_array ]] then do
          return --[[ Tpat_array ]]Block.__(7, {List.map(f, d[0])}); end end 
       if ___conditional___ == 8--[[ Tpat_or ]] then do
          return --[[ Tpat_or ]]Block.__(8, {
                    Curry._1(f, d[0]),
                    Curry._1(f, d[1]),
                    d[2]
                  }); end end 
       if ___conditional___ == 9--[[ Tpat_lazy ]] then do
          return --[[ Tpat_lazy ]]Block.__(9, {Curry._1(f, d[0])}); end end 
      return d;
        
    end
  end end 
end end

idents = do
  contents: --[[ [] ]]0
end;

function bound_idents(_pat) do
  while(true) do
    pat = _pat;
    d = pat.pat_desc;
    if (typeof d == "number") then do
      return iter_pattern_desc(bound_idents, d);
    end else do
      local ___conditional___=(d.tag | 0);
      do
         if ___conditional___ == 0--[[ Tpat_var ]] then do
            idents.contents = --[[ :: ]]{
              --[[ tuple ]]{
                d[0],
                d[1]
              },
              idents.contents
            };
            return --[[ () ]]0; end end 
         if ___conditional___ == 1--[[ Tpat_alias ]] then do
            bound_idents(d[0]);
            idents.contents = --[[ :: ]]{
              --[[ tuple ]]{
                d[1],
                d[2]
              },
              idents.contents
            };
            return --[[ () ]]0; end end 
         if ___conditional___ == 8--[[ Tpat_or ]] then do
            _pat = d[0];
            ::continue:: ; end end 
        return iter_pattern_desc(bound_idents, d);
          
      end
    end end 
  end;
end end

function pat_bound_idents(pat) do
  idents.contents = --[[ [] ]]0;
  bound_idents(pat);
  res = idents.contents;
  idents.contents = --[[ [] ]]0;
  return res;
end end

function rev_let_bound_idents_with_loc(bindings) do
  idents.contents = --[[ [] ]]0;
  List.iter((function(vb) do
          return bound_idents(vb.vb_pat);
        end end), bindings);
  res = idents.contents;
  idents.contents = --[[ [] ]]0;
  return res;
end end

function let_bound_idents(pat) do
  return List.map((function(prim) do
                return prim[0];
              end end), List.rev(rev_let_bound_idents_with_loc(pat)));
end end

function alpha_pat(env, p) do
  d = p.pat_desc;
  if (typeof d ~= "number") then do
    local ___conditional___=(d.tag | 0);
    do
       if ___conditional___ == 0--[[ Tpat_var ]] then do
          tmp;
          xpcall(function() do
            tmp = --[[ Tpat_var ]]Block.__(0, {
                List.assoc(d[0], env),
                d[1]
              });
          end end,function(exn) do
            if (exn == Caml_builtin_exceptions.not_found) then do
              tmp = --[[ Tpat_any ]]0;
            end else do
              error(exn)
            end end 
          end end)
          return do
                  pat_desc: tmp,
                  pat_loc: p.pat_loc,
                  pat_extra: p.pat_extra,
                  pat_type: p.pat_type,
                  pat_env: p.pat_env,
                  pat_attributes: p.pat_attributes
                end; end end 
       if ___conditional___ == 1--[[ Tpat_alias ]] then do
          new_p = alpha_pat(env, d[0]);
          xpcall(function() do
            return do
                    pat_desc: --[[ Tpat_alias ]]Block.__(1, {
                        new_p,
                        List.assoc(d[1], env),
                        d[2]
                      }),
                    pat_loc: p.pat_loc,
                    pat_extra: p.pat_extra,
                    pat_type: p.pat_type,
                    pat_env: p.pat_env,
                    pat_attributes: p.pat_attributes
                  end;
          end end,function(exn_1) do
            if (exn_1 == Caml_builtin_exceptions.not_found) then do
              return new_p;
            end else do
              error(exn_1)
            end end 
          end end) end end 
      
    end
  end
   end 
  return do
          pat_desc: map_pattern_desc((function(param) do
                  return alpha_pat(env, param);
                end end), d),
          pat_loc: p.pat_loc,
          pat_extra: p.pat_extra,
          pat_type: p.pat_type,
          pat_env: p.pat_env,
          pat_attributes: p.pat_attributes
        end;
end end

function enter_structure(t) do
  return t;
end end

function enter_value_description(t) do
  return t;
end end

function enter_type_declaration(t) do
  return t;
end end

function enter_type_extension(t) do
  return t;
end end

function enter_extension_constructor(t) do
  return t;
end end

function enter_pattern(t) do
  return t;
end end

function enter_expression(t) do
  return t;
end end

function enter_package_type(t) do
  return t;
end end

function enter_signature(t) do
  return t;
end end

function enter_signature_item(t) do
  return t;
end end

function enter_module_type_declaration(t) do
  return t;
end end

function enter_module_type(t) do
  return t;
end end

function enter_module_expr(t) do
  return t;
end end

function enter_with_constraint(t) do
  return t;
end end

function enter_class_expr(t) do
  return t;
end end

function enter_class_signature(t) do
  return t;
end end

function enter_class_declaration(t) do
  return t;
end end

function enter_class_description(t) do
  return t;
end end

function enter_class_type_declaration(t) do
  return t;
end end

function enter_class_type(t) do
  return t;
end end

function enter_class_type_field(t) do
  return t;
end end

function enter_core_type(t) do
  return t;
end end

function enter_class_structure(t) do
  return t;
end end

function enter_class_field(t) do
  return t;
end end

function enter_structure_item(t) do
  return t;
end end

function leave_value_description(t) do
  return t;
end end

function leave_type_declaration(t) do
  return t;
end end

function leave_type_extension(t) do
  return t;
end end

function leave_extension_constructor(t) do
  return t;
end end

function leave_package_type(t) do
  return t;
end end

function leave_module_type_declaration(t) do
  return t;
end end

function leave_with_constraint(t) do
  return t;
end end

function leave_class_signature(t) do
  return t;
end end

function leave_class_declaration(t) do
  return t;
end end

function leave_class_description(t) do
  return t;
end end

function leave_class_type_declaration(t) do
  return t;
end end

function leave_class_type_field(t) do
  return t;
end end

function leave_class_structure(t) do
  return t;
end end

function leave_class_field(t) do
  return t;
end end

function TypedtreeMap_MakeMap(funarg) do
  map_structure = function(str) do
    str_1 = Curry._1(funarg.enter_structure, str);
    str_items = List.map(map_structure_item, str_1.str_items);
    return Curry._1(funarg.leave_structure, do
                str_items: str_items,
                str_type: str_1.str_type,
                str_final_env: str_1.str_final_env
              end);
  end end;
  map_class_type = function(ct) do
    ct_1 = Curry._1(funarg.enter_class_type, ct);
    match = ct_1.cltyp_desc;
    cltyp_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 0--[[ Tcty_constr ]] then do
          cltyp_desc = --[[ Tcty_constr ]]Block.__(0, {
              match[0],
              match[1],
              List.map(map_core_type, match[2])
            }); end else 
       if ___conditional___ == 1--[[ Tcty_signature ]] then do
          cltyp_desc = --[[ Tcty_signature ]]Block.__(1, {map_class_signature(match[0])}); end else 
       if ___conditional___ == 2--[[ Tcty_arrow ]] then do
          cltyp_desc = --[[ Tcty_arrow ]]Block.__(2, {
              match[0],
              map_core_type(match[1]),
              map_class_type(match[2])
            }); end else 
       end end end end end end
      
    end
    return Curry._1(funarg.leave_class_type, do
                cltyp_desc: cltyp_desc,
                cltyp_type: ct_1.cltyp_type,
                cltyp_env: ct_1.cltyp_env,
                cltyp_loc: ct_1.cltyp_loc,
                cltyp_attributes: ct_1.cltyp_attributes
              end);
  end end;
  map_core_type = function(ct) do
    ct_1 = Curry._1(funarg.enter_core_type, ct);
    match = ct_1.ctyp_desc;
    ctyp_desc;
    if (typeof match == "number") then do
      ctyp_desc = ct_1.ctyp_desc;
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 0--[[ Ttyp_var ]] then do
            ctyp_desc = ct_1.ctyp_desc; end else 
         if ___conditional___ == 1--[[ Ttyp_arrow ]] then do
            ctyp_desc = --[[ Ttyp_arrow ]]Block.__(1, {
                match[0],
                map_core_type(match[1]),
                map_core_type(match[2])
              }); end else 
         if ___conditional___ == 2--[[ Ttyp_tuple ]] then do
            ctyp_desc = --[[ Ttyp_tuple ]]Block.__(2, {List.map(map_core_type, match[0])}); end else 
         if ___conditional___ == 3--[[ Ttyp_constr ]] then do
            ctyp_desc = --[[ Ttyp_constr ]]Block.__(3, {
                match[0],
                match[1],
                List.map(map_core_type, match[2])
              }); end else 
         if ___conditional___ == 4--[[ Ttyp_object ]] then do
            ctyp_desc = --[[ Ttyp_object ]]Block.__(4, {
                List.map((function(param) do
                        return --[[ tuple ]]{
                                param[0],
                                param[1],
                                map_core_type(param[2])
                              };
                      end end), match[0]),
                match[1]
              }); end else 
         if ___conditional___ == 5--[[ Ttyp_class ]] then do
            ctyp_desc = --[[ Ttyp_class ]]Block.__(5, {
                match[0],
                match[1],
                List.map(map_core_type, match[2])
              }); end else 
         if ___conditional___ == 6--[[ Ttyp_alias ]] then do
            ctyp_desc = --[[ Ttyp_alias ]]Block.__(6, {
                map_core_type(match[0]),
                match[1]
              }); end else 
         if ___conditional___ == 7--[[ Ttyp_variant ]] then do
            ctyp_desc = --[[ Ttyp_variant ]]Block.__(7, {
                List.map(map_row_field, match[0]),
                match[1],
                match[2]
              }); end else 
         if ___conditional___ == 8--[[ Ttyp_poly ]] then do
            ctyp_desc = --[[ Ttyp_poly ]]Block.__(8, {
                match[0],
                map_core_type(match[1])
              }); end else 
         if ___conditional___ == 9--[[ Ttyp_package ]] then do
            ctyp_desc = --[[ Ttyp_package ]]Block.__(9, {map_package_type(match[0])}); end else 
         end end end end end end end end end end end end end end end end end end end end
        
      end
    end end 
    return Curry._1(funarg.leave_core_type, do
                ctyp_desc: ctyp_desc,
                ctyp_type: ct_1.ctyp_type,
                ctyp_env: ct_1.ctyp_env,
                ctyp_loc: ct_1.ctyp_loc,
                ctyp_attributes: ct_1.ctyp_attributes
              end);
  end end;
  map_type_declaration = function(decl) do
    decl_1 = Curry._1(funarg.enter_type_declaration, decl);
    typ_params = List.map(map_type_parameter, decl_1.typ_params);
    typ_cstrs = List.map((function(param) do
            return --[[ tuple ]]{
                    map_core_type(param[0]),
                    map_core_type(param[1]),
                    param[2]
                  };
          end end), decl_1.typ_cstrs);
    match = decl_1.typ_kind;
    typ_kind;
    if (typeof match == "number") then do
      typ_kind = match == --[[ Ttype_abstract ]]0 and --[[ Ttype_abstract ]]0 or --[[ Ttype_open ]]1;
    end else if (match.tag) then do
      list = List.map((function(ld) do
              return do
                      ld_id: ld.ld_id,
                      ld_name: ld.ld_name,
                      ld_mutable: ld.ld_mutable,
                      ld_type: map_core_type(ld.ld_type),
                      ld_loc: ld.ld_loc,
                      ld_attributes: ld.ld_attributes
                    end;
            end end), match[0]);
      typ_kind = --[[ Ttype_record ]]Block.__(1, {list});
    end else do
      list_1 = List.map(map_constructor_declaration, match[0]);
      typ_kind = --[[ Ttype_variant ]]Block.__(0, {list_1});
    end end  end 
    typ_manifest = may_map(map_core_type, decl_1.typ_manifest);
    return Curry._1(funarg.leave_type_declaration, do
                typ_id: decl_1.typ_id,
                typ_name: decl_1.typ_name,
                typ_params: typ_params,
                typ_type: decl_1.typ_type,
                typ_cstrs: typ_cstrs,
                typ_kind: typ_kind,
                typ_private: decl_1.typ_private,
                typ_manifest: typ_manifest,
                typ_loc: decl_1.typ_loc,
                typ_attributes: decl_1.typ_attributes
              end);
  end end;
  map_module_type = function(mty) do
    mty_1 = Curry._1(funarg.enter_module_type, mty);
    match = mty_1.mty_desc;
    mty_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 1--[[ Tmty_signature ]] then do
          mty_desc = --[[ Tmty_signature ]]Block.__(1, {map_signature(match[0])}); end else 
       if ___conditional___ == 2--[[ Tmty_functor ]] then do
          mty_desc = --[[ Tmty_functor ]]Block.__(2, {
              match[0],
              match[1],
              may_map(map_module_type, match[2]),
              map_module_type(match[3])
            }); end else 
       if ___conditional___ == 3--[[ Tmty_with ]] then do
          mty_desc = --[[ Tmty_with ]]Block.__(3, {
              map_module_type(match[0]),
              List.map((function(param) do
                      return --[[ tuple ]]{
                              param[0],
                              param[1],
                              map_with_constraint(param[2])
                            };
                    end end), match[1])
            }); end else 
       if ___conditional___ == 4--[[ Tmty_typeof ]] then do
          mty_desc = --[[ Tmty_typeof ]]Block.__(4, {map_module_expr(match[0])}); end else 
       if ___conditional___ == 0--[[ Tmty_ident ]]
       or ___conditional___ == 5--[[ Tmty_alias ]] then do
          mty_desc = mty_1.mty_desc; end else 
       end end end end end end end end end end
      
    end
    return Curry._1(funarg.leave_module_type, do
                mty_desc: mty_desc,
                mty_type: mty_1.mty_type,
                mty_env: mty_1.mty_env,
                mty_loc: mty_1.mty_loc,
                mty_attributes: mty_1.mty_attributes
              end);
  end end;
  map_module_expr = function(mexpr) do
    mexpr_1 = Curry._1(funarg.enter_module_expr, mexpr);
    match = mexpr_1.mod_desc;
    mod_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 0--[[ Tmod_ident ]] then do
          mod_desc = mexpr_1.mod_desc; end else 
       if ___conditional___ == 1--[[ Tmod_structure ]] then do
          mod_desc = --[[ Tmod_structure ]]Block.__(1, {map_structure(match[0])}); end else 
       if ___conditional___ == 2--[[ Tmod_functor ]] then do
          mod_desc = --[[ Tmod_functor ]]Block.__(2, {
              match[0],
              match[1],
              may_map(map_module_type, match[2]),
              map_module_expr(match[3])
            }); end else 
       if ___conditional___ == 3--[[ Tmod_apply ]] then do
          mod_desc = --[[ Tmod_apply ]]Block.__(3, {
              map_module_expr(match[0]),
              map_module_expr(match[1]),
              match[2]
            }); end else 
       if ___conditional___ == 4--[[ Tmod_constraint ]] then do
          match_1 = match[2];
          mod_type = match[1];
          mexpr_2 = match[0];
          mod_desc = match_1 and --[[ Tmod_constraint ]]Block.__(4, {
                map_module_expr(mexpr_2),
                mod_type,
                --[[ Tmodtype_explicit ]]{map_module_type(match_1[0])},
                match[3]
              }) or --[[ Tmod_constraint ]]Block.__(4, {
                map_module_expr(mexpr_2),
                mod_type,
                --[[ Tmodtype_implicit ]]0,
                match[3]
              }); end else 
       if ___conditional___ == 5--[[ Tmod_unpack ]] then do
          mod_desc = --[[ Tmod_unpack ]]Block.__(5, {
              map_expression(match[0]),
              match[1]
            }); end else 
       end end end end end end end end end end end end
      
    end
    return Curry._1(funarg.leave_module_expr, do
                mod_desc: mod_desc,
                mod_loc: mexpr_1.mod_loc,
                mod_type: mexpr_1.mod_type,
                mod_env: mexpr_1.mod_env,
                mod_attributes: mexpr_1.mod_attributes
              end);
  end end;
  map_with_constraint = function(cstr) do
    cstr_1 = Curry._1(funarg.enter_with_constraint, cstr);
    tmp;
    local ___conditional___=(cstr_1.tag | 0);
    do
       if ___conditional___ == 0--[[ Twith_type ]] then do
          tmp = --[[ Twith_type ]]Block.__(0, {map_type_declaration(cstr_1[0])}); end else 
       if ___conditional___ == 2--[[ Twith_typesubst ]] then do
          tmp = --[[ Twith_typesubst ]]Block.__(2, {map_type_declaration(cstr_1[0])}); end else 
       if ___conditional___ == 1--[[ Twith_module ]]
       or ___conditional___ == 3--[[ Twith_modsubst ]] then do
          tmp = cstr_1; end else 
       end end end end end end
      
    end
    return Curry._1(funarg.leave_with_constraint, tmp);
  end end;
  map_signature = function(sg) do
    sg_1 = Curry._1(funarg.enter_signature, sg);
    sig_items = List.map(map_signature_item, sg_1.sig_items);
    return Curry._1(funarg.leave_signature, do
                sig_items: sig_items,
                sig_type: sg_1.sig_type,
                sig_final_env: sg_1.sig_final_env
              end);
  end end;
  map_value_description = function(v) do
    v_1 = Curry._1(funarg.enter_value_description, v);
    val_desc = map_core_type(v_1.val_desc);
    return Curry._1(funarg.leave_value_description, do
                val_id: v_1.val_id,
                val_name: v_1.val_name,
                val_desc: val_desc,
                val_val: v_1.val_val,
                val_prim: v_1.val_prim,
                val_loc: v_1.val_loc,
                val_attributes: v_1.val_attributes
              end);
  end end;
  map_extension_constructor = function(ext) do
    ext_1 = Curry._1(funarg.enter_extension_constructor, ext);
    match = ext_1.ext_kind;
    ext_kind;
    if (match.tag) then do
      ext_kind = --[[ Text_rebind ]]Block.__(1, {
          match[0],
          match[1]
        });
    end else do
      args = List.map(map_core_type, match[0]);
      ret = may_map(map_core_type, match[1]);
      ext_kind = --[[ Text_decl ]]Block.__(0, {
          args,
          ret
        });
    end end 
    return Curry._1(funarg.leave_extension_constructor, do
                ext_id: ext_1.ext_id,
                ext_name: ext_1.ext_name,
                ext_type: ext_1.ext_type,
                ext_kind: ext_kind,
                ext_loc: ext_1.ext_loc,
                ext_attributes: ext_1.ext_attributes
              end);
  end end;
  map_type_extension = function(tyext) do
    tyext_1 = Curry._1(funarg.enter_type_extension, tyext);
    tyext_params = List.map(map_type_parameter, tyext_1.tyext_params);
    tyext_constructors = List.map(map_extension_constructor, tyext_1.tyext_constructors);
    return Curry._1(funarg.leave_type_extension, do
                tyext_path: tyext_1.tyext_path,
                tyext_txt: tyext_1.tyext_txt,
                tyext_params: tyext_params,
                tyext_constructors: tyext_constructors,
                tyext_private: tyext_1.tyext_private,
                tyext_attributes: tyext_1.tyext_attributes
              end);
  end end;
  map_class_type_declaration = function(cd) do
    cd_1 = Curry._1(funarg.enter_class_type_declaration, cd);
    ci_params = List.map(map_type_parameter, cd_1.ci_params);
    ci_expr = map_class_type(cd_1.ci_expr);
    return Curry._1(funarg.leave_class_type_declaration, do
                ci_virt: cd_1.ci_virt,
                ci_params: ci_params,
                ci_id_name: cd_1.ci_id_name,
                ci_id_class: cd_1.ci_id_class,
                ci_id_class_type: cd_1.ci_id_class_type,
                ci_id_object: cd_1.ci_id_object,
                ci_id_typesharp: cd_1.ci_id_typesharp,
                ci_expr: ci_expr,
                ci_decl: cd_1.ci_decl,
                ci_type_decl: cd_1.ci_type_decl,
                ci_loc: cd_1.ci_loc,
                ci_attributes: cd_1.ci_attributes
              end);
  end end;
  map_module_type_declaration = function(mtd) do
    mtd_1 = Curry._1(funarg.enter_module_type_declaration, mtd);
    return Curry._1(funarg.leave_module_type_declaration, do
                mtd_id: mtd_1.mtd_id,
                mtd_name: mtd_1.mtd_name,
                mtd_type: may_map(map_module_type, mtd_1.mtd_type),
                mtd_attributes: mtd_1.mtd_attributes,
                mtd_loc: mtd_1.mtd_loc
              end);
  end end;
  map_class_description = function(cd) do
    cd_1 = Curry._1(funarg.enter_class_description, cd);
    ci_params = List.map(map_type_parameter, cd_1.ci_params);
    ci_expr = map_class_type(cd_1.ci_expr);
    return Curry._1(funarg.leave_class_description, do
                ci_virt: cd_1.ci_virt,
                ci_params: ci_params,
                ci_id_name: cd_1.ci_id_name,
                ci_id_class: cd_1.ci_id_class,
                ci_id_class_type: cd_1.ci_id_class_type,
                ci_id_object: cd_1.ci_id_object,
                ci_id_typesharp: cd_1.ci_id_typesharp,
                ci_expr: ci_expr,
                ci_decl: cd_1.ci_decl,
                ci_type_decl: cd_1.ci_type_decl,
                ci_loc: cd_1.ci_loc,
                ci_attributes: cd_1.ci_attributes
              end);
  end end;
  map_type_parameter = function(param) do
    return --[[ tuple ]]{
            map_core_type(param[0]),
            param[1]
          };
  end end;
  map_class_expr = function(cexpr) do
    cexpr_1 = Curry._1(funarg.enter_class_expr, cexpr);
    match = cexpr_1.cl_desc;
    cl_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 0--[[ Tcl_ident ]] then do
          cl_desc = --[[ Tcl_ident ]]Block.__(0, {
              match[0],
              match[1],
              List.map(map_core_type, match[2])
            }); end else 
       if ___conditional___ == 1--[[ Tcl_structure ]] then do
          cl_desc = --[[ Tcl_structure ]]Block.__(1, {map_class_structure(match[0])}); end else 
       if ___conditional___ == 2--[[ Tcl_fun ]] then do
          cl_desc = --[[ Tcl_fun ]]Block.__(2, {
              match[0],
              map_pattern(match[1]),
              List.map((function(param) do
                      return --[[ tuple ]]{
                              param[0],
                              param[1],
                              map_expression(param[2])
                            };
                    end end), match[2]),
              map_class_expr(match[3]),
              match[4]
            }); end else 
       if ___conditional___ == 3--[[ Tcl_apply ]] then do
          cl_desc = --[[ Tcl_apply ]]Block.__(3, {
              map_class_expr(match[0]),
              List.map((function(param) do
                      return --[[ tuple ]]{
                              param[0],
                              may_map(map_expression, param[1]),
                              param[2]
                            };
                    end end), match[1])
            }); end else 
       if ___conditional___ == 4--[[ Tcl_let ]] then do
          cl_desc = --[[ Tcl_let ]]Block.__(4, {
              match[0],
              List.map(map_binding, match[1]),
              List.map((function(param) do
                      return --[[ tuple ]]{
                              param[0],
                              param[1],
                              map_expression(param[2])
                            };
                    end end), match[2]),
              map_class_expr(match[3])
            }); end else 
       if ___conditional___ == 5--[[ Tcl_constraint ]] then do
          match_1 = match[1];
          cl = match[0];
          cl_desc = match_1 ~= undefined and --[[ Tcl_constraint ]]Block.__(5, {
                map_class_expr(cl),
                map_class_type(match_1),
                match[2],
                match[3],
                match[4]
              }) or --[[ Tcl_constraint ]]Block.__(5, {
                map_class_expr(cl),
                undefined,
                match[2],
                match[3],
                match[4]
              }); end else 
       end end end end end end end end end end end end
      
    end
    return Curry._1(funarg.leave_class_expr, do
                cl_desc: cl_desc,
                cl_loc: cexpr_1.cl_loc,
                cl_type: cexpr_1.cl_type,
                cl_env: cexpr_1.cl_env,
                cl_attributes: cexpr_1.cl_attributes
              end);
  end end;
  map_pattern = function(pat) do
    pat_1 = Curry._1(funarg.enter_pattern, pat);
    match = pat_1.pat_desc;
    pat_desc;
    if (typeof match == "number") then do
      pat_desc = pat_1.pat_desc;
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 1--[[ Tpat_alias ]] then do
            pat1 = map_pattern(match[0]);
            pat_desc = --[[ Tpat_alias ]]Block.__(1, {
                pat1,
                match[1],
                match[2]
              }); end else 
         if ___conditional___ == 3--[[ Tpat_tuple ]] then do
            pat_desc = --[[ Tpat_tuple ]]Block.__(3, {List.map(map_pattern, match[0])}); end else 
         if ___conditional___ == 4--[[ Tpat_construct ]] then do
            pat_desc = --[[ Tpat_construct ]]Block.__(4, {
                match[0],
                match[1],
                List.map(map_pattern, match[2])
              }); end else 
         if ___conditional___ == 5--[[ Tpat_variant ]] then do
            pato = match[1];
            pato_1 = pato ~= undefined and map_pattern(pato) or pato;
            pat_desc = --[[ Tpat_variant ]]Block.__(5, {
                match[0],
                pato_1,
                match[2]
              }); end else 
         if ___conditional___ == 6--[[ Tpat_record ]] then do
            pat_desc = --[[ Tpat_record ]]Block.__(6, {
                List.map((function(param) do
                        return --[[ tuple ]]{
                                param[0],
                                param[1],
                                map_pattern(param[2])
                              };
                      end end), match[0]),
                match[1]
              }); end else 
         if ___conditional___ == 7--[[ Tpat_array ]] then do
            pat_desc = --[[ Tpat_array ]]Block.__(7, {List.map(map_pattern, match[0])}); end else 
         if ___conditional___ == 8--[[ Tpat_or ]] then do
            pat_desc = --[[ Tpat_or ]]Block.__(8, {
                map_pattern(match[0]),
                map_pattern(match[1]),
                match[2]
              }); end else 
         if ___conditional___ == 9--[[ Tpat_lazy ]] then do
            pat_desc = --[[ Tpat_lazy ]]Block.__(9, {map_pattern(match[0])}); end else 
         end end end end end end end end end end end end end end end end
        pat_desc = pat_1.pat_desc;
          
      end
    end end 
    pat_extra = List.map(map_pat_extra, pat_1.pat_extra);
    return Curry._1(funarg.leave_pattern, do
                pat_desc: pat_desc,
                pat_loc: pat_1.pat_loc,
                pat_extra: pat_extra,
                pat_type: pat_1.pat_type,
                pat_env: pat_1.pat_env,
                pat_attributes: pat_1.pat_attributes
              end);
  end end;
  map_pat_extra = function(pat_extra) do
    match = pat_extra[0];
    if (typeof match == "number" or match.tag) then do
      return pat_extra;
    end else do
      return --[[ tuple ]]{
              --[[ Tpat_constraint ]]Block.__(0, {map_core_type(match[0])}),
              pat_extra[1],
              pat_extra[2]
            };
    end end 
  end end;
  map_expression = function(exp) do
    exp_1 = Curry._1(funarg.enter_expression, exp);
    match = exp_1.exp_desc;
    exp_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 2--[[ Texp_let ]] then do
          exp_desc = --[[ Texp_let ]]Block.__(2, {
              match[0],
              List.map(map_binding, match[1]),
              map_expression(match[2])
            }); end else 
       if ___conditional___ == 3--[[ Texp_function ]] then do
          exp_desc = --[[ Texp_function ]]Block.__(3, {
              match[0],
              List.map(map_case, match[1]),
              match[2]
            }); end else 
       if ___conditional___ == 4--[[ Texp_apply ]] then do
          exp_desc = --[[ Texp_apply ]]Block.__(4, {
              map_expression(match[0]),
              List.map((function(param) do
                      expo = param[1];
                      expo_1 = expo ~= undefined and map_expression(expo) or expo;
                      return --[[ tuple ]]{
                              param[0],
                              expo_1,
                              param[2]
                            };
                    end end), match[1])
            }); end else 
       if ___conditional___ == 5--[[ Texp_match ]] then do
          exp_desc = --[[ Texp_match ]]Block.__(5, {
              map_expression(match[0]),
              List.map(map_case, match[1]),
              List.map(map_case, match[2]),
              match[3]
            }); end else 
       if ___conditional___ == 6--[[ Texp_try ]] then do
          exp_desc = --[[ Texp_try ]]Block.__(6, {
              map_expression(match[0]),
              List.map(map_case, match[1])
            }); end else 
       if ___conditional___ == 7--[[ Texp_tuple ]] then do
          exp_desc = --[[ Texp_tuple ]]Block.__(7, {List.map(map_expression, match[0])}); end else 
       if ___conditional___ == 8--[[ Texp_construct ]] then do
          exp_desc = --[[ Texp_construct ]]Block.__(8, {
              match[0],
              match[1],
              List.map(map_expression, match[2])
            }); end else 
       if ___conditional___ == 9--[[ Texp_variant ]] then do
          expo = match[1];
          expo_1 = expo ~= undefined and map_expression(expo) or expo;
          exp_desc = --[[ Texp_variant ]]Block.__(9, {
              match[0],
              expo_1
            }); end else 
       if ___conditional___ == 10--[[ Texp_record ]] then do
          expo_2 = match[1];
          list = List.map((function(param) do
                  return --[[ tuple ]]{
                          param[0],
                          param[1],
                          map_expression(param[2])
                        };
                end end), match[0]);
          expo_3 = expo_2 ~= undefined and map_expression(expo_2) or expo_2;
          exp_desc = --[[ Texp_record ]]Block.__(10, {
              list,
              expo_3
            }); end else 
       if ___conditional___ == 11--[[ Texp_field ]] then do
          exp_desc = --[[ Texp_field ]]Block.__(11, {
              map_expression(match[0]),
              match[1],
              match[2]
            }); end else 
       if ___conditional___ == 12--[[ Texp_setfield ]] then do
          exp_desc = --[[ Texp_setfield ]]Block.__(12, {
              map_expression(match[0]),
              match[1],
              match[2],
              map_expression(match[3])
            }); end else 
       if ___conditional___ == 13--[[ Texp_array ]] then do
          exp_desc = --[[ Texp_array ]]Block.__(13, {List.map(map_expression, match[0])}); end else 
       if ___conditional___ == 14--[[ Texp_ifthenelse ]] then do
          expo_4 = match[2];
          exp_desc = --[[ Texp_ifthenelse ]]Block.__(14, {
              map_expression(match[0]),
              map_expression(match[1]),
              expo_4 ~= undefined and map_expression(expo_4) or expo_4
            }); end else 
       if ___conditional___ == 15--[[ Texp_sequence ]] then do
          exp_desc = --[[ Texp_sequence ]]Block.__(15, {
              map_expression(match[0]),
              map_expression(match[1])
            }); end else 
       if ___conditional___ == 16--[[ Texp_while ]] then do
          exp_desc = --[[ Texp_while ]]Block.__(16, {
              map_expression(match[0]),
              map_expression(match[1])
            }); end else 
       if ___conditional___ == 17--[[ Texp_for ]] then do
          exp_desc = --[[ Texp_for ]]Block.__(17, {
              match[0],
              match[1],
              map_expression(match[2]),
              map_expression(match[3]),
              match[4],
              map_expression(match[5])
            }); end else 
       if ___conditional___ == 18--[[ Texp_send ]] then do
          exp_desc = --[[ Texp_send ]]Block.__(18, {
              map_expression(match[0]),
              match[1],
              may_map(map_expression, match[2])
            }); end else 
       if ___conditional___ == 0--[[ Texp_ident ]]
       or ___conditional___ == 1--[[ Texp_constant ]]
       or ___conditional___ == 19--[[ Texp_new ]]
       or ___conditional___ == 20--[[ Texp_instvar ]] then do
          exp_desc = exp_1.exp_desc; end else 
       if ___conditional___ == 21--[[ Texp_setinstvar ]] then do
          exp_desc = --[[ Texp_setinstvar ]]Block.__(21, {
              match[0],
              match[1],
              match[2],
              map_expression(match[3])
            }); end else 
       if ___conditional___ == 22--[[ Texp_override ]] then do
          exp_desc = --[[ Texp_override ]]Block.__(22, {
              match[0],
              List.map((function(param) do
                      return --[[ tuple ]]{
                              param[0],
                              param[1],
                              map_expression(param[2])
                            };
                    end end), match[1])
            }); end else 
       if ___conditional___ == 23--[[ Texp_letmodule ]] then do
          exp_desc = --[[ Texp_letmodule ]]Block.__(23, {
              match[0],
              match[1],
              map_module_expr(match[2]),
              map_expression(match[3])
            }); end else 
       if ___conditional___ == 24--[[ Texp_assert ]] then do
          exp_desc = --[[ Texp_assert ]]Block.__(24, {map_expression(match[0])}); end else 
       if ___conditional___ == 25--[[ Texp_lazy ]] then do
          exp_desc = --[[ Texp_lazy ]]Block.__(25, {map_expression(match[0])}); end else 
       if ___conditional___ == 26--[[ Texp_object ]] then do
          exp_desc = --[[ Texp_object ]]Block.__(26, {
              map_class_structure(match[0]),
              match[1]
            }); end else 
       if ___conditional___ == 27--[[ Texp_pack ]] then do
          exp_desc = --[[ Texp_pack ]]Block.__(27, {map_module_expr(match[0])}); end else 
       end end end end end end end end end end end end end end end end end end end end end end end end end end end end end end end end end end end end end end end end end end end end end end end end end end
      
    end
    exp_extra = List.map(map_exp_extra, exp_1.exp_extra);
    return Curry._1(funarg.leave_expression, do
                exp_desc: exp_desc,
                exp_loc: exp_1.exp_loc,
                exp_extra: exp_extra,
                exp_type: exp_1.exp_type,
                exp_env: exp_1.exp_env,
                exp_attributes: exp_1.exp_attributes
              end);
  end end;
  map_structure_item = function(item) do
    item_1 = Curry._1(funarg.enter_structure_item, item);
    match = item_1.str_desc;
    str_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 0--[[ Tstr_eval ]] then do
          str_desc = --[[ Tstr_eval ]]Block.__(0, {
              map_expression(match[0]),
              match[1]
            }); end else 
       if ___conditional___ == 1--[[ Tstr_value ]] then do
          str_desc = --[[ Tstr_value ]]Block.__(1, {
              match[0],
              List.map(map_binding, match[1])
            }); end else 
       if ___conditional___ == 2--[[ Tstr_primitive ]] then do
          str_desc = --[[ Tstr_primitive ]]Block.__(2, {map_value_description(match[0])}); end else 
       if ___conditional___ == 3--[[ Tstr_type ]] then do
          str_desc = --[[ Tstr_type ]]Block.__(3, {List.map(map_type_declaration, match[0])}); end else 
       if ___conditional___ == 4--[[ Tstr_typext ]] then do
          str_desc = --[[ Tstr_typext ]]Block.__(4, {map_type_extension(match[0])}); end else 
       if ___conditional___ == 5--[[ Tstr_exception ]] then do
          str_desc = --[[ Tstr_exception ]]Block.__(5, {map_extension_constructor(match[0])}); end else 
       if ___conditional___ == 6--[[ Tstr_module ]] then do
          str_desc = --[[ Tstr_module ]]Block.__(6, {map_module_binding(match[0])}); end else 
       if ___conditional___ == 7--[[ Tstr_recmodule ]] then do
          list = List.map(map_module_binding, match[0]);
          str_desc = --[[ Tstr_recmodule ]]Block.__(7, {list}); end else 
       if ___conditional___ == 8--[[ Tstr_modtype ]] then do
          str_desc = --[[ Tstr_modtype ]]Block.__(8, {map_module_type_declaration(match[0])}); end else 
       if ___conditional___ == 9--[[ Tstr_open ]] then do
          str_desc = --[[ Tstr_open ]]Block.__(9, {match[0]}); end else 
       if ___conditional___ == 10--[[ Tstr_class ]] then do
          list_1 = List.map((function(param) do
                  return --[[ tuple ]]{
                          map_class_declaration(param[0]),
                          param[1],
                          param[2]
                        };
                end end), match[0]);
          str_desc = --[[ Tstr_class ]]Block.__(10, {list_1}); end else 
       if ___conditional___ == 11--[[ Tstr_class_type ]] then do
          list_2 = List.map((function(param) do
                  return --[[ tuple ]]{
                          param[0],
                          param[1],
                          map_class_type_declaration(param[2])
                        };
                end end), match[0]);
          str_desc = --[[ Tstr_class_type ]]Block.__(11, {list_2}); end else 
       if ___conditional___ == 12--[[ Tstr_include ]] then do
          incl = match[0];
          str_desc = --[[ Tstr_include ]]Block.__(12, {do
                incl_mod: map_module_expr(incl.incl_mod),
                incl_type: incl.incl_type,
                incl_loc: incl.incl_loc,
                incl_attributes: incl.incl_attributes
              end}); end else 
       if ___conditional___ == 13--[[ Tstr_attribute ]] then do
          str_desc = --[[ Tstr_attribute ]]Block.__(13, {match[0]}); end else 
       end end end end end end end end end end end end end end end end end end end end end end end end end end end end
      
    end
    return Curry._1(funarg.leave_structure_item, do
                str_desc: str_desc,
                str_loc: item_1.str_loc,
                str_env: item_1.str_env
              end);
  end end;
  map_class_structure = function(cs) do
    cs_1 = Curry._1(funarg.enter_class_structure, cs);
    cstr_self = map_pattern(cs_1.cstr_self);
    cstr_fields = List.map(map_class_field, cs_1.cstr_fields);
    return Curry._1(funarg.leave_class_structure, do
                cstr_self: cstr_self,
                cstr_fields: cstr_fields,
                cstr_type: cs_1.cstr_type,
                cstr_meths: cs_1.cstr_meths
              end);
  end end;
  map_binding = function(vb) do
    return do
            vb_pat: map_pattern(vb.vb_pat),
            vb_expr: map_expression(vb.vb_expr),
            vb_attributes: vb.vb_attributes,
            vb_loc: vb.vb_loc
          end;
  end end;
  map_class_field = function(cf) do
    cf_1 = Curry._1(funarg.enter_class_field, cf);
    x = cf_1.cf_desc;
    cf_desc;
    local ___conditional___=(x.tag | 0);
    do
       if ___conditional___ == 0--[[ Tcf_inherit ]] then do
          cf_desc = --[[ Tcf_inherit ]]Block.__(0, {
              x[0],
              map_class_expr(x[1]),
              x[2],
              x[3],
              x[4]
            }); end else 
       if ___conditional___ == 1--[[ Tcf_val ]] then do
          match = x[3];
          ident = x[2];
          mut = x[1];
          lab = x[0];
          cf_desc = match.tag and --[[ Tcf_val ]]Block.__(1, {
                lab,
                mut,
                ident,
                --[[ Tcfk_concrete ]]Block.__(1, {
                    match[0],
                    map_expression(match[1])
                  }),
                x[4]
              }) or --[[ Tcf_val ]]Block.__(1, {
                lab,
                mut,
                ident,
                --[[ Tcfk_virtual ]]Block.__(0, {map_core_type(match[0])}),
                x[4]
              }); end else 
       if ___conditional___ == 2--[[ Tcf_method ]] then do
          match_1 = x[2];
          priv = x[1];
          lab_1 = x[0];
          cf_desc = match_1.tag and --[[ Tcf_method ]]Block.__(2, {
                lab_1,
                priv,
                --[[ Tcfk_concrete ]]Block.__(1, {
                    match_1[0],
                    map_expression(match_1[1])
                  })
              }) or --[[ Tcf_method ]]Block.__(2, {
                lab_1,
                priv,
                --[[ Tcfk_virtual ]]Block.__(0, {map_core_type(match_1[0])})
              }); end else 
       if ___conditional___ == 3--[[ Tcf_constraint ]] then do
          cf_desc = --[[ Tcf_constraint ]]Block.__(3, {
              map_core_type(x[0]),
              map_core_type(x[1])
            }); end else 
       if ___conditional___ == 4--[[ Tcf_initializer ]] then do
          cf_desc = --[[ Tcf_initializer ]]Block.__(4, {map_expression(x[0])}); end else 
       if ___conditional___ == 5--[[ Tcf_attribute ]] then do
          cf_desc = x; end else 
       end end end end end end end end end end end end
      
    end
    return Curry._1(funarg.leave_class_field, do
                cf_desc: cf_desc,
                cf_loc: cf_1.cf_loc,
                cf_attributes: cf_1.cf_attributes
              end);
  end end;
  map_constructor_declaration = function(cd) do
    return do
            cd_id: cd.cd_id,
            cd_name: cd.cd_name,
            cd_args: List.map(map_core_type, cd.cd_args),
            cd_res: may_map(map_core_type, cd.cd_res),
            cd_loc: cd.cd_loc,
            cd_attributes: cd.cd_attributes
          end;
  end end;
  map_class_signature = function(cs) do
    cs_1 = Curry._1(funarg.enter_class_signature, cs);
    csig_self = map_core_type(cs_1.csig_self);
    csig_fields = List.map(map_class_type_field, cs_1.csig_fields);
    return Curry._1(funarg.leave_class_signature, do
                csig_self: csig_self,
                csig_fields: csig_fields,
                csig_type: cs_1.csig_type
              end);
  end end;
  map_case = function(param) do
    return do
            c_lhs: map_pattern(param.c_lhs),
            c_guard: may_map(map_expression, param.c_guard),
            c_rhs: map_expression(param.c_rhs)
          end;
  end end;
  map_exp_extra = function(exp_extra) do
    attrs = exp_extra[2];
    loc = exp_extra[1];
    desc = exp_extra[0];
    local ___conditional___=(desc.tag | 0);
    do
       if ___conditional___ == 0--[[ Texp_constraint ]] then do
          return --[[ tuple ]]{
                  --[[ Texp_constraint ]]Block.__(0, {map_core_type(desc[0])}),
                  loc,
                  attrs
                }; end end 
       if ___conditional___ == 1--[[ Texp_coerce ]] then do
          match = desc[0];
          if (match ~= undefined) then do
            return --[[ tuple ]]{
                    --[[ Texp_coerce ]]Block.__(1, {
                        map_core_type(match),
                        map_core_type(desc[1])
                      }),
                    loc,
                    attrs
                  };
          end else do
            return --[[ tuple ]]{
                    --[[ Texp_coerce ]]Block.__(1, {
                        undefined,
                        map_core_type(desc[1])
                      }),
                    loc,
                    attrs
                  };
          end end  end end 
       if ___conditional___ == 3--[[ Texp_poly ]] then do
          match_1 = desc[0];
          if (match_1 ~= undefined) then do
            return --[[ tuple ]]{
                    --[[ Texp_poly ]]Block.__(3, {map_core_type(match_1)}),
                    loc,
                    attrs
                  };
          end else do
            return exp_extra;
          end end  end end 
       if ___conditional___ == 2--[[ Texp_open ]]
       or ___conditional___ == 4--[[ Texp_newtype ]] then do
          return exp_extra; end end 
      
    end
  end end;
  map_row_field = function(rf) do
    if (rf.tag) then do
      return --[[ Tinherit ]]Block.__(1, {map_core_type(rf[0])});
    end else do
      return --[[ Ttag ]]Block.__(0, {
                rf[0],
                rf[1],
                rf[2],
                List.map(map_core_type, rf[3])
              });
    end end 
  end end;
  map_package_type = function(pack) do
    pack_1 = Curry._1(funarg.enter_package_type, pack);
    pack_fields = List.map((function(param) do
            return --[[ tuple ]]{
                    param[0],
                    map_core_type(param[1])
                  };
          end end), pack_1.pack_fields);
    return Curry._1(funarg.leave_package_type, do
                pack_path: pack_1.pack_path,
                pack_fields: pack_fields,
                pack_type: pack_1.pack_type,
                pack_txt: pack_1.pack_txt
              end);
  end end;
  map_class_type_field = function(ctf) do
    ctf_1 = Curry._1(funarg.enter_class_type_field, ctf);
    x = ctf_1.ctf_desc;
    ctf_desc;
    local ___conditional___=(x.tag | 0);
    do
       if ___conditional___ == 0--[[ Tctf_inherit ]] then do
          ctf_desc = --[[ Tctf_inherit ]]Block.__(0, {map_class_type(x[0])}); end else 
       if ___conditional___ == 1--[[ Tctf_val ]] then do
          match = x[0];
          ctf_desc = --[[ Tctf_val ]]Block.__(1, {--[[ tuple ]]{
                match[0],
                match[1],
                match[2],
                map_core_type(match[3])
              }}); end else 
       if ___conditional___ == 2--[[ Tctf_method ]] then do
          match_1 = x[0];
          ctf_desc = --[[ Tctf_method ]]Block.__(2, {--[[ tuple ]]{
                match_1[0],
                match_1[1],
                match_1[2],
                map_core_type(match_1[3])
              }}); end else 
       if ___conditional___ == 3--[[ Tctf_constraint ]] then do
          match_2 = x[0];
          ctf_desc = --[[ Tctf_constraint ]]Block.__(3, {--[[ tuple ]]{
                map_core_type(match_2[0]),
                map_core_type(match_2[1])
              }}); end else 
       if ___conditional___ == 4--[[ Tctf_attribute ]] then do
          ctf_desc = x; end else 
       end end end end end end end end end end
      
    end
    return Curry._1(funarg.leave_class_type_field, do
                ctf_desc: ctf_desc,
                ctf_loc: ctf_1.ctf_loc,
                ctf_attributes: ctf_1.ctf_attributes
              end);
  end end;
  map_signature_item = function(item) do
    item_1 = Curry._1(funarg.enter_signature_item, item);
    x = item_1.sig_desc;
    sig_desc;
    local ___conditional___=(x.tag | 0);
    do
       if ___conditional___ == 0--[[ Tsig_value ]] then do
          sig_desc = --[[ Tsig_value ]]Block.__(0, {map_value_description(x[0])}); end else 
       if ___conditional___ == 1--[[ Tsig_type ]] then do
          sig_desc = --[[ Tsig_type ]]Block.__(1, {List.map(map_type_declaration, x[0])}); end else 
       if ___conditional___ == 2--[[ Tsig_typext ]] then do
          sig_desc = --[[ Tsig_typext ]]Block.__(2, {map_type_extension(x[0])}); end else 
       if ___conditional___ == 3--[[ Tsig_exception ]] then do
          sig_desc = --[[ Tsig_exception ]]Block.__(3, {map_extension_constructor(x[0])}); end else 
       if ___conditional___ == 4--[[ Tsig_module ]] then do
          md = x[0];
          sig_desc = --[[ Tsig_module ]]Block.__(4, {do
                md_id: md.md_id,
                md_name: md.md_name,
                md_type: map_module_type(md.md_type),
                md_attributes: md.md_attributes,
                md_loc: md.md_loc
              end}); end else 
       if ___conditional___ == 5--[[ Tsig_recmodule ]] then do
          sig_desc = --[[ Tsig_recmodule ]]Block.__(5, {List.map((function(md) do
                      return do
                              md_id: md.md_id,
                              md_name: md.md_name,
                              md_type: map_module_type(md.md_type),
                              md_attributes: md.md_attributes,
                              md_loc: md.md_loc
                            end;
                    end end), x[0])}); end else 
       if ___conditional___ == 6--[[ Tsig_modtype ]] then do
          sig_desc = --[[ Tsig_modtype ]]Block.__(6, {map_module_type_declaration(x[0])}); end else 
       if ___conditional___ == 7--[[ Tsig_open ]] then do
          sig_desc = item_1.sig_desc; end else 
       if ___conditional___ == 8--[[ Tsig_include ]] then do
          incl = x[0];
          sig_desc = --[[ Tsig_include ]]Block.__(8, {do
                incl_mod: map_module_type(incl.incl_mod),
                incl_type: incl.incl_type,
                incl_loc: incl.incl_loc,
                incl_attributes: incl.incl_attributes
              end}); end else 
       if ___conditional___ == 9--[[ Tsig_class ]] then do
          sig_desc = --[[ Tsig_class ]]Block.__(9, {List.map(map_class_description, x[0])}); end else 
       if ___conditional___ == 10--[[ Tsig_class_type ]] then do
          sig_desc = --[[ Tsig_class_type ]]Block.__(10, {List.map(map_class_type_declaration, x[0])}); end else 
       if ___conditional___ == 11--[[ Tsig_attribute ]] then do
          sig_desc = x; end else 
       end end end end end end end end end end end end end end end end end end end end end end end end
      
    end
    return Curry._1(funarg.leave_signature_item, do
                sig_desc: sig_desc,
                sig_env: item_1.sig_env,
                sig_loc: item_1.sig_loc
              end);
  end end;
  map_class_declaration = function(cd) do
    cd_1 = Curry._1(funarg.enter_class_declaration, cd);
    ci_params = List.map(map_type_parameter, cd_1.ci_params);
    ci_expr = map_class_expr(cd_1.ci_expr);
    return Curry._1(funarg.leave_class_declaration, do
                ci_virt: cd_1.ci_virt,
                ci_params: ci_params,
                ci_id_name: cd_1.ci_id_name,
                ci_id_class: cd_1.ci_id_class,
                ci_id_class_type: cd_1.ci_id_class_type,
                ci_id_object: cd_1.ci_id_object,
                ci_id_typesharp: cd_1.ci_id_typesharp,
                ci_expr: ci_expr,
                ci_decl: cd_1.ci_decl,
                ci_type_decl: cd_1.ci_type_decl,
                ci_loc: cd_1.ci_loc,
                ci_attributes: cd_1.ci_attributes
              end);
  end end;
  map_module_binding = function(x) do
    return do
            mb_id: x.mb_id,
            mb_name: x.mb_name,
            mb_expr: map_module_expr(x.mb_expr),
            mb_attributes: x.mb_attributes,
            mb_loc: x.mb_loc
          end;
  end end;
  return do
          map_structure: map_structure,
          map_pattern: map_pattern,
          map_structure_item: map_structure_item,
          map_expression: map_expression,
          map_class_expr: map_class_expr,
          map_signature: map_signature,
          map_signature_item: map_signature_item,
          map_module_type: map_module_type
        end;
end end

need_to_clear_env;

xpcall(function() do
  Caml_sys.caml_sys_getenv("OCAML_BINANNOT_WITHENV");
  need_to_clear_env = false;
end end,function(exn_2) do
  if (exn_2 == Caml_builtin_exceptions.not_found) then do
    need_to_clear_env = true;
  end else do
    error(exn_2)
  end end 
end end)

function leave_pattern(p) do
  return do
          pat_desc: p.pat_desc,
          pat_loc: p.pat_loc,
          pat_extra: p.pat_extra,
          pat_type: p.pat_type,
          pat_env: keep_only_summary(p.pat_env),
          pat_attributes: p.pat_attributes
        end;
end end

function leave_expression(e) do
  exp_extra = List.map((function(exp_extra) do
          match = exp_extra[0];
          if (match.tag == --[[ Texp_open ]]2) then do
            return --[[ tuple ]]{
                    --[[ Texp_open ]]Block.__(2, {
                        match[0],
                        match[1],
                        match[2],
                        keep_only_summary(match[3])
                      }),
                    exp_extra[1],
                    exp_extra[2]
                  };
          end else do
            return exp_extra;
          end end 
        end end), e.exp_extra);
  return do
          exp_desc: e.exp_desc,
          exp_loc: e.exp_loc,
          exp_extra: exp_extra,
          exp_type: e.exp_type,
          exp_env: keep_only_summary(e.exp_env),
          exp_attributes: e.exp_attributes
        end;
end end

function leave_class_expr(c) do
  return do
          cl_desc: c.cl_desc,
          cl_loc: c.cl_loc,
          cl_type: c.cl_type,
          cl_env: keep_only_summary(c.cl_env),
          cl_attributes: c.cl_attributes
        end;
end end

function leave_module_expr(m) do
  return do
          mod_desc: m.mod_desc,
          mod_loc: m.mod_loc,
          mod_type: m.mod_type,
          mod_env: keep_only_summary(m.mod_env),
          mod_attributes: m.mod_attributes
        end;
end end

function leave_structure(s) do
  return do
          str_items: s.str_items,
          str_type: s.str_type,
          str_final_env: keep_only_summary(s.str_final_env)
        end;
end end

function leave_structure_item(str) do
  return do
          str_desc: str.str_desc,
          str_loc: str.str_loc,
          str_env: keep_only_summary(str.str_env)
        end;
end end

function leave_module_type(m) do
  return do
          mty_desc: m.mty_desc,
          mty_type: m.mty_type,
          mty_env: keep_only_summary(m.mty_env),
          mty_loc: m.mty_loc,
          mty_attributes: m.mty_attributes
        end;
end end

function leave_signature(s) do
  return do
          sig_items: s.sig_items,
          sig_type: s.sig_type,
          sig_final_env: keep_only_summary(s.sig_final_env)
        end;
end end

function leave_signature_item(s) do
  return do
          sig_desc: s.sig_desc,
          sig_env: keep_only_summary(s.sig_env),
          sig_loc: s.sig_loc
        end;
end end

function leave_core_type(c) do
  return do
          ctyp_desc: c.ctyp_desc,
          ctyp_type: c.ctyp_type,
          ctyp_env: keep_only_summary(c.ctyp_env),
          ctyp_loc: c.ctyp_loc,
          ctyp_attributes: c.ctyp_attributes
        end;
end end

function leave_class_type(c) do
  return do
          cltyp_desc: c.cltyp_desc,
          cltyp_type: c.cltyp_type,
          cltyp_env: keep_only_summary(c.cltyp_env),
          cltyp_loc: c.cltyp_loc,
          cltyp_attributes: c.cltyp_attributes
        end;
end end

ClearEnv = Curry._1(TypedtreeMap_MakeMap, do
      enter_structure: enter_structure,
      enter_value_description: enter_value_description,
      enter_type_declaration: enter_type_declaration,
      enter_type_extension: enter_type_extension,
      enter_extension_constructor: enter_extension_constructor,
      enter_pattern: enter_pattern,
      enter_expression: enter_expression,
      enter_package_type: enter_package_type,
      enter_signature: enter_signature,
      enter_signature_item: enter_signature_item,
      enter_module_type_declaration: enter_module_type_declaration,
      enter_module_type: enter_module_type,
      enter_module_expr: enter_module_expr,
      enter_with_constraint: enter_with_constraint,
      enter_class_expr: enter_class_expr,
      enter_class_signature: enter_class_signature,
      enter_class_declaration: enter_class_declaration,
      enter_class_description: enter_class_description,
      enter_class_type_declaration: enter_class_type_declaration,
      enter_class_type: enter_class_type,
      enter_class_type_field: enter_class_type_field,
      enter_core_type: enter_core_type,
      enter_class_structure: enter_class_structure,
      enter_class_field: enter_class_field,
      enter_structure_item: enter_structure_item,
      leave_structure: leave_structure,
      leave_value_description: leave_value_description,
      leave_type_declaration: leave_type_declaration,
      leave_type_extension: leave_type_extension,
      leave_extension_constructor: leave_extension_constructor,
      leave_pattern: leave_pattern,
      leave_expression: leave_expression,
      leave_package_type: leave_package_type,
      leave_signature: leave_signature,
      leave_signature_item: leave_signature_item,
      leave_module_type_declaration: leave_module_type_declaration,
      leave_module_type: leave_module_type,
      leave_module_expr: leave_module_expr,
      leave_with_constraint: leave_with_constraint,
      leave_class_expr: leave_class_expr,
      leave_class_signature: leave_class_signature,
      leave_class_declaration: leave_class_declaration,
      leave_class_description: leave_class_description,
      leave_class_type_declaration: leave_class_type_declaration,
      leave_class_type: leave_class_type,
      leave_class_type_field: leave_class_type_field,
      leave_core_type: leave_core_type,
      leave_class_structure: leave_class_structure,
      leave_class_field: leave_class_field,
      leave_structure_item: leave_structure_item
    end);

function clear_part(p) do
  local ___conditional___=(p.tag | 0);
  do
     if ___conditional___ == 0--[[ Partial_structure ]] then do
        return --[[ Partial_structure ]]Block.__(0, {Curry._1(ClearEnv.map_structure, p[0])}); end end 
     if ___conditional___ == 1--[[ Partial_structure_item ]] then do
        return --[[ Partial_structure_item ]]Block.__(1, {Curry._1(ClearEnv.map_structure_item, p[0])}); end end 
     if ___conditional___ == 2--[[ Partial_expression ]] then do
        return --[[ Partial_expression ]]Block.__(2, {Curry._1(ClearEnv.map_expression, p[0])}); end end 
     if ___conditional___ == 3--[[ Partial_pattern ]] then do
        return --[[ Partial_pattern ]]Block.__(3, {Curry._1(ClearEnv.map_pattern, p[0])}); end end 
     if ___conditional___ == 4--[[ Partial_class_expr ]] then do
        return --[[ Partial_class_expr ]]Block.__(4, {Curry._1(ClearEnv.map_class_expr, p[0])}); end end 
     if ___conditional___ == 5--[[ Partial_signature ]] then do
        return --[[ Partial_signature ]]Block.__(5, {Curry._1(ClearEnv.map_signature, p[0])}); end end 
     if ___conditional___ == 6--[[ Partial_signature_item ]] then do
        return --[[ Partial_signature_item ]]Block.__(6, {Curry._1(ClearEnv.map_signature_item, p[0])}); end end 
     if ___conditional___ == 7--[[ Partial_module_type ]] then do
        return --[[ Partial_module_type ]]Block.__(7, {Curry._1(ClearEnv.map_module_type, p[0])}); end end 
    
  end
end end

function clear_env(binary_annots) do
  if (need_to_clear_env) then do
    local ___conditional___=(binary_annots.tag | 0);
    do
       if ___conditional___ == 0--[[ Packed ]] then do
          return binary_annots; end end 
       if ___conditional___ == 1--[[ Implementation ]] then do
          return --[[ Implementation ]]Block.__(1, {Curry._1(ClearEnv.map_structure, binary_annots[0])}); end end 
       if ___conditional___ == 2--[[ Interface ]] then do
          return --[[ Interface ]]Block.__(2, {Curry._1(ClearEnv.map_signature, binary_annots[0])}); end end 
       if ___conditional___ == 3--[[ Partial_implementation ]] then do
          return --[[ Partial_implementation ]]Block.__(3, {__Array.map(clear_part, binary_annots[0])}); end end 
       if ___conditional___ == 4--[[ Partial_interface ]] then do
          return --[[ Partial_interface ]]Block.__(4, {__Array.map(clear_part, binary_annots[0])}); end end 
      
    end
  end else do
    return binary_annots;
  end end 
end end

function output_cmt(oc, cmt) do
  Pervasives.output_string(oc, "Caml2012T004");
  return Caml_external_polyfill.resolve("caml_output_value")(oc, cmt, --[[ [] ]]0);
end end

saved_types = do
  contents: --[[ [] ]]0
end;

value_deps = do
  contents: --[[ [] ]]0
end;

function clear(param) do
  saved_types.contents = --[[ [] ]]0;
  value_deps.contents = --[[ [] ]]0;
  return --[[ () ]]0;
end end

function add_saved_type(b) do
  saved_types.contents = --[[ :: ]]{
    b,
    saved_types.contents
  };
  return --[[ () ]]0;
end end

function record_value_dependency(vd1, vd2) do
  if (Caml_obj.caml_notequal(vd1.val_loc, vd2.val_loc)) then do
    value_deps.contents = --[[ :: ]]{
      --[[ tuple ]]{
        vd1,
        vd2
      },
      value_deps.contents
    };
    return --[[ () ]]0;
  end else do
    return 0;
  end end 
end end

function save_cmt(filename, modname, binary_annots, sourcefile, initial_env, sg) do
  if (binary_annotations.contents and not print_types.contents) then do
    imports_1 = imports(--[[ () ]]0);
    oc = Pervasives.open_out_bin(filename);
    this_crc;
    if (sg ~= undefined) then do
      cmi_cmi_flags = recursive_types.contents and --[[ :: ]]{
          --[[ Rectypes ]]0,
          --[[ [] ]]0
        } or --[[ [] ]]0;
      cmi = do
        cmi_name: modname,
        cmi_sign: sg,
        cmi_crcs: imports_1,
        cmi_flags: cmi_cmi_flags
      end;
      this_crc = output_cmi(filename, oc, cmi);
    end else do
      this_crc = undefined;
    end end 
    source_digest = may_map(Digest.file, sourcefile);
    cmt_cmt_annots = clear_env(binary_annots);
    cmt_cmt_value_dependencies = value_deps.contents;
    cmt_cmt_comments = List.rev(comment_list.contents);
    cmt_cmt_builddir = Caml_sys.caml_sys_getcwd(--[[ () ]]0);
    cmt_cmt_loadpath = load_path.contents;
    cmt_cmt_initial_env = need_to_clear_env and keep_only_summary(initial_env) or initial_env;
    cmt_cmt_imports = List.sort(Caml_obj.caml_compare, imports_1);
    cmt = do
      cmt_modname: modname,
      cmt_annots: cmt_cmt_annots,
      cmt_value_dependencies: cmt_cmt_value_dependencies,
      cmt_comments: cmt_cmt_comments,
      cmt_args: Sys.argv,
      cmt_sourcefile: sourcefile,
      cmt_builddir: cmt_cmt_builddir,
      cmt_loadpath: cmt_cmt_loadpath,
      cmt_source_digest: source_digest,
      cmt_initial_env: cmt_cmt_initial_env,
      cmt_imports: cmt_cmt_imports,
      cmt_interface_digest: this_crc,
      cmt_use_summaries: need_to_clear_env
    end;
    output_cmt(oc, cmt);
    Caml_io.caml_ml_flush(oc);
    Caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
    exit = 0;
    cmd;
    xpcall(function() do
      cmd = Caml_sys.caml_sys_getenv("BS_CMT_POST_PROCESS_CMD");
      exit = 1;
    end end,function(exn) do
      
    end end)
    if (exit == 1) then do
      Caml_sys.caml_sys_system_command(cmd .. (" -cmt-add " .. (filename .. (
                sourcefile ~= undefined and ":" .. sourcefile or ""
              ))));
    end
     end 
  end
   end 
  return clear(--[[ () ]]0);
end end

Unify = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Unify");

Tags = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Tags");

register_error_of_exn((function(param) do
        if (param[0] == Tags) then do
          return Curry._2(errorf(in_file(input_name.contents), undefined, undefined, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "In this program,",
                              --[[ Formatting_lit ]]Block.__(17, {
                                  --[[ Break ]]Block.__(0, {
                                      "@ ",
                                      1,
                                      0
                                    }),
                                  --[[ String_literal ]]Block.__(11, {
                                      "variant constructors",
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ Char_literal ]]Block.__(12, {
                                              --[[ "`" ]]96,
                                              --[[ String ]]Block.__(2, {
                                                  --[[ No_padding ]]0,
                                                  --[[ String_literal ]]Block.__(11, {
                                                      " and `",
                                                      --[[ String ]]Block.__(2, {
                                                          --[[ No_padding ]]0,
                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Break ]]Block.__(0, {
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                }),
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "have the same hash value.",
                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Break ]]Block.__(0, {
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        }),
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          "Change one of them.",
                                                                          --[[ End_of_format ]]0
                                                                        })
                                                                    })
                                                                })
                                                            })
                                                        })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            }),
                          "In this program,@ variant constructors@ `%s and `%s@ have the same hash value.@ Change one of them."
                        }), param[1], param[2]);
        end
         end 
      end end));

Subtype = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Subtype");

Cannot_expand = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Cannot_expand");

Recursive_abbrev = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Recursive_abbrev");

Unification_recursive_abbrev = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Unification_recursive_abbrev");

current_level = do
  contents: 0
end;

nongen_level = do
  contents: 0
end;

global_level = do
  contents: 1
end;

saved_level = do
  contents: --[[ [] ]]0
end;

function init_def(level) do
  current_level.contents = level;
  nongen_level.contents = level;
  return --[[ () ]]0;
end end

function begin_def(param) do
  saved_level.contents = --[[ :: ]]{
    --[[ tuple ]]{
      current_level.contents,
      nongen_level.contents
    },
    saved_level.contents
  };
  current_level.contents = current_level.contents + 1 | 0;
  nongen_level.contents = current_level.contents;
  return --[[ () ]]0;
end end

function begin_class_def(param) do
  saved_level.contents = --[[ :: ]]{
    --[[ tuple ]]{
      current_level.contents,
      nongen_level.contents
    },
    saved_level.contents
  };
  current_level.contents = current_level.contents + 1 | 0;
  return --[[ () ]]0;
end end

function raise_nongen_level(param) do
  saved_level.contents = --[[ :: ]]{
    --[[ tuple ]]{
      current_level.contents,
      nongen_level.contents
    },
    saved_level.contents
  };
  nongen_level.contents = current_level.contents;
  return --[[ () ]]0;
end end

function end_def(param) do
  match = List.hd(saved_level.contents);
  saved_level.contents = List.tl(saved_level.contents);
  current_level.contents = match[0];
  nongen_level.contents = match[1];
  return --[[ () ]]0;
end end

function reset_global_level(param) do
  global_level.contents = current_level.contents + 1 | 0;
  return --[[ () ]]0;
end end

function increase_global_level(param) do
  gl = global_level.contents;
  global_level.contents = current_level.contents;
  return gl;
end end

function is_object_type(path) do
  name;
  local ___conditional___=(path.tag | 0);
  do
     if ___conditional___ == 0--[[ Pident ]] then do
        name = path[0].name; end else 
     if ___conditional___ == 1--[[ Pdot ]] then do
        name = path[1]; end else 
     if ___conditional___ == 2--[[ Papply ]] then do
        error({
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ctype.ml",
            149,
            23
          }
        }) end end end end end end 
    
  end
  return Caml_string.get(name, 0) == --[[ "#" ]]35;
end end

trace_gadt_instances = do
  contents: false
end;

function check_trace_gadt_instances(env) do
  if (not trace_gadt_instances.contents and env.local_constraints) then do
    trace_gadt_instances.contents = true;
    cleanup_abbrev(--[[ () ]]0);
    return true;
  end else do
    return false;
  end end 
end end

function reset_trace_gadt_instances(b) do
  if (b) then do
    trace_gadt_instances.contents = false;
    return --[[ () ]]0;
  end else do
    return 0;
  end end 
end end

function wrap_trace_gadt_instances(env, f, x) do
  b = check_trace_gadt_instances(env);
  y = Curry._1(f, x);
  reset_trace_gadt_instances(b);
  return y;
end end

simple_abbrevs = do
  contents: --[[ Mnil ]]0
end;

function proper_abbrevs(path, tl, abbrev) do
  if (tl ~= --[[ [] ]]0 or trace_gadt_instances.contents or principal.contents or is_object_type(path)) then do
    return abbrev;
  end else do
    return simple_abbrevs;
  end end 
end end

function newvar(name, param) do
  return newty2(current_level.contents, --[[ Tvar ]]Block.__(0, {name}));
end end

function new_global_var(name, param) do
  return newty2(global_level.contents, --[[ Tvar ]]Block.__(0, {name}));
end end

function newobj(fields) do
  return newty2(current_level.contents, --[[ Tobject ]]Block.__(4, {
                fields,
                do
                  contents: undefined
                end
              }));
end end

function newconstr(path, tyl) do
  return newty2(current_level.contents, --[[ Tconstr ]]Block.__(3, {
                path,
                tyl,
                do
                  contents: --[[ Mnil ]]0
                end
              }));
end end

none_2 = newty2(current_level.contents, --[[ Ttuple ]]Block.__(2, {--[[ [] ]]0}));

function equal_3(param, param_1) do
  if (param[0] == param_1[0]) then do
    return param[1] == param_1[1];
  end else do
    return false;
  end end 
end end

function hash_1(param) do
  return param[0].id + Caml_int32.imul(93, param[1].id) | 0;
end end

TypePairs = Hashtbl.Make(do
      equal: equal_3,
      hash: hash_1
    end);

umode = do
  contents: --[[ Expression ]]0
end;

generate_equations = do
  contents: false
end;

assume_injective = do
  contents: false
end;

function set_mode_pattern(generate, injective, f) do
  old_unification_mode = umode.contents;
  old_gen = generate_equations.contents;
  old_inj = assume_injective.contents;
  xpcall(function() do
    umode.contents = --[[ Pattern ]]1;
    generate_equations.contents = generate;
    assume_injective.contents = injective;
    ret = Curry._1(f, --[[ () ]]0);
    umode.contents = old_unification_mode;
    generate_equations.contents = old_gen;
    assume_injective.contents = old_inj;
    return ret;
  end end,function(e) do
    umode.contents = old_unification_mode;
    generate_equations.contents = old_gen;
    assume_injective.contents = old_inj;
    error(e)
  end end)
end end

function in_current_module(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Pident ]] then do
        return true; end end 
     if ___conditional___ == 1--[[ Pdot ]]
     or ___conditional___ == 2--[[ Papply ]] then do
        return false; end end 
    
  end
end end

function in_pervasives(p) do
  if (in_current_module(p)) then do
    xpcall(function() do
      find_type_full(p, initial_safe_string)[0];
      return true;
    end end,function(exn) do
      if (exn == Caml_builtin_exceptions.not_found) then do
        return false;
      end else do
        error(exn)
      end end 
    end end)
  end else do
    return false;
  end end 
end end

function is_datatype(decl) do
  match = decl.type_kind;
  if (typeof match == "number") then do
    return match ~= 0;
  end else do
    return true;
  end end 
end end

function object_fields(ty) do
  match = repr(ty).desc;
  if (typeof match == "number") then do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "ctype.ml",
        284,
        27
      }
    })
  end else if (match.tag == --[[ Tobject ]]4) then do
    return match[0];
  end else do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "ctype.ml",
        284,
        27
      }
    })
  end end  end 
end end

function flatten_fields(ty) do
  flatten = function(_l, _ty) do
    while(true) do
      ty = _ty;
      l = _l;
      ty_1 = repr(ty);
      match = ty_1.desc;
      if (typeof match == "number" or match.tag ~= --[[ Tfield ]]5) then do
        return --[[ tuple ]]{
                l,
                ty_1
              };
      end else do
        _ty = match[3];
        _l = --[[ :: ]]{
          --[[ tuple ]]{
            match[0],
            match[1],
            match[2]
          },
          l
        };
        ::continue:: ;
      end end 
    end;
  end end;
  match = flatten(--[[ [] ]]0, ty);
  return --[[ tuple ]]{
          List.sort((function(param, param_1) do
                  return Caml_primitive.caml_string_compare(param[0], param_1[0]);
                end end), match[0]),
          match[1]
        };
end end

function build_fields(level) do
  return (function(param, param_1) do
      return List.fold_right((function(param, ty2) do
                    return newty2(level, --[[ Tfield ]]Block.__(5, {
                                  param[0],
                                  param[1],
                                  param[2],
                                  ty2
                                }));
                  end end), param, param_1);
    end end);
end end

function associate_fields(fields1, fields2) do
  _p = --[[ [] ]]0;
  _s = --[[ [] ]]0;
  _s$prime = --[[ [] ]]0;
  _param = --[[ tuple ]]{
    fields1,
    fields2
  };
  while(true) do
    param = _param;
    s$prime = _s$prime;
    s = _s;
    p = _p;
    l = param[0];
    if (param[1]) then do
      if (l) then do
        l$prime = param[1];
        r$prime = l$prime[1];
        match = l$prime[0];
        t$prime = match[2];
        k$prime = match[1];
        n$prime = match[0];
        r = l[1];
        match_1 = l[0];
        t = match_1[2];
        k = match_1[1];
        n = match_1[0];
        if (Caml_obj.caml_equal(n, n$prime)) then do
          _param = --[[ tuple ]]{
            r,
            r$prime
          };
          _p = --[[ :: ]]{
            --[[ tuple ]]{
              n,
              k,
              t,
              k$prime,
              t$prime
            },
            p
          };
          ::continue:: ;
        end else if (Caml_obj.caml_lessthan(n, n$prime)) then do
          _param = --[[ tuple ]]{
            r,
            l$prime
          };
          _s = --[[ :: ]]{
            --[[ tuple ]]{
              n,
              k,
              t
            },
            s
          };
          ::continue:: ;
        end else do
          _param = --[[ tuple ]]{
            l,
            r$prime
          };
          _s$prime = --[[ :: ]]{
            --[[ tuple ]]{
              n$prime,
              k$prime,
              t$prime
            },
            s$prime
          };
          ::continue:: ;
        end end  end 
      end else do
        return --[[ tuple ]]{
                List.rev(p),
                List.rev(s),
                Pervasives.$at(List.rev(s$prime), param[1])
              };
      end end 
    end else do
      return --[[ tuple ]]{
              List.rev(p),
              Pervasives.$at(List.rev(s), l),
              List.rev(s$prime)
            };
    end end 
  end;
end end

function object_row(_ty) do
  while(true) do
    ty = _ty;
    ty_1 = repr(ty);
    match = ty_1.desc;
    if (typeof match == "number") then do
      return ty_1;
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 4--[[ Tobject ]] then do
            _ty = match[0];
            ::continue:: ; end end 
         if ___conditional___ == 5--[[ Tfield ]] then do
            _ty = match[3];
            ::continue:: ; end end 
        return ty_1;
          
      end
    end end 
  end;
end end

function opened_object(ty) do
  match = object_row(ty).desc;
  if (typeof match == "number") then do
    return false;
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 0--[[ Tvar ]]
       or ___conditional___ == 3--[[ Tconstr ]]
       or ___conditional___ == 9--[[ Tunivar ]] then do
          return true; end end 
      return false;
        
    end
  end end 
end end

function concrete_object(ty) do
  match = object_row(ty).desc;
  if (typeof match == "number" or match.tag) then do
    return true;
  end else do
    return false;
  end end 
end end

function close_object(ty) do
  match = repr(ty).desc;
  if (typeof match == "number") then do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "ctype.ml",
        351,
        25
      }
    })
  end else if (match.tag == --[[ Tobject ]]4) then do
    _ty = match[0];
    while(true) do
      ty_1 = _ty;
      ty_2 = repr(ty_1);
      match_1 = ty_2.desc;
      if (typeof match_1 == "number") then do
        error({
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ctype.ml",
            347,
            30
          }
        })
      end else do
        local ___conditional___=(match_1.tag | 0);
        do
           if ___conditional___ == 0--[[ Tvar ]] then do
              return link_type(ty_2, newty2(ty_2.level, --[[ Tnil ]]0)); end end 
           if ___conditional___ == 5--[[ Tfield ]] then do
              _ty = match_1[3];
              ::continue:: ; end end 
          error({
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "ctype.ml",
                347,
                30
              }
            })
            
        end
      end end 
    end;
  end else do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "ctype.ml",
        351,
        25
      }
    })
  end end  end 
end end

function row_variable(ty) do
  match = repr(ty).desc;
  if (typeof match == "number") then do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "ctype.ml",
        365,
        23
      }
    })
  end else if (match.tag == --[[ Tobject ]]4) then do
    _ty = match[0];
    while(true) do
      ty_1 = _ty;
      ty_2 = repr(ty_1);
      match_1 = ty_2.desc;
      if (typeof match_1 == "number") then do
        error({
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ctype.ml",
            361,
            30
          }
        })
      end else do
        local ___conditional___=(match_1.tag | 0);
        do
           if ___conditional___ == 0--[[ Tvar ]] then do
              return ty_2; end end 
           if ___conditional___ == 5--[[ Tfield ]] then do
              _ty = match_1[3];
              ::continue:: ; end end 
          error({
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "ctype.ml",
                361,
                30
              }
            })
            
        end
      end end 
    end;
  end else do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "ctype.ml",
        365,
        23
      }
    })
  end end  end 
end end

function set_object_name(id, rv, params, ty) do
  match = repr(ty).desc;
  if (typeof match == "number") then do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "ctype.ml",
        375,
        6
      }
    })
  end else if (match.tag == --[[ Tobject ]]4) then do
    return set_name(match[1], --[[ tuple ]]{
                --[[ Pident ]]Block.__(0, {id}),
                --[[ :: ]]{
                  rv,
                  params
                }
              });
  end else do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "ctype.ml",
        375,
        6
      }
    })
  end end  end 
end end

function hide_private_methods(ty) do
  match = repr(ty).desc;
  if (typeof match == "number") then do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "ctype.ml",
        397,
        6
      }
    })
  end else if (match.tag == --[[ Tobject ]]4) then do
    match[1].contents = undefined;
    match_1 = flatten_fields(match[0]);
    return List.iter((function(param) do
                  match = field_kind_repr(param[1]);
                  if (typeof match == "number") then do
                    return --[[ () ]]0;
                  end else do
                    return set_kind(match[0], --[[ Fabsent ]]1);
                  end end 
                end end), match_1[0]);
  end else do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "ctype.ml",
        397,
        6
      }
    })
  end end  end 
end end

function signature_of_class_type(_param) do
  while(true) do
    param = _param;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ == 1--[[ Cty_signature ]] then do
          return param[0]; end end 
       if ___conditional___ == 0--[[ Cty_constr ]]
       or ___conditional___ == 2--[[ Cty_arrow ]] then do
          _param = param[2];
          ::continue:: ; end end 
      
    end
  end;
end end

function class_type_arity(_param) do
  while(true) do
    param = _param;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ == 0--[[ Cty_constr ]] then do
          _param = param[2];
          ::continue:: ; end end 
       if ___conditional___ == 1--[[ Cty_signature ]] then do
          return 0; end end 
       if ___conditional___ == 2--[[ Cty_arrow ]] then do
          return 1 + class_type_arity(param[2]) | 0; end end 
      
    end
  end;
end end

function sort_row_fields(param) do
  return List.sort((function(param, param_1) do
                return Caml_primitive.caml_string_compare(param[0], param_1[0]);
              end end), param);
end end

function merge_row_fields(fi1, fi2) do
  exit = 0;
  if (fi1 and fi2 and (fi1[1] or List.mem_assoc(fi1[0][0], fi2))) then do
    exit = 2;
  end else do
    return --[[ tuple ]]{
            fi1,
            fi2,
            --[[ [] ]]0
          };
  end end 
  if (exit == 2 and not fi2[1] and not List.mem_assoc(fi2[0][0], fi1)) then do
    return --[[ tuple ]]{
            fi1,
            fi2,
            --[[ [] ]]0
          };
  end
   end 
  _r1 = --[[ [] ]]0;
  _r2 = --[[ [] ]]0;
  _pairs = --[[ [] ]]0;
  _fi1 = sort_row_fields(fi1);
  _fi2 = sort_row_fields(fi2);
  while(true) do
    fi2_1 = _fi2;
    fi1_1 = _fi1;
    pairs = _pairs;
    r2 = _r2;
    r1 = _r1;
    if (fi1_1) then do
      if (fi2_1) then do
        fi2$prime = fi2_1[1];
        p2 = fi2_1[0];
        l2 = p2[0];
        fi1$prime = fi1_1[1];
        p1 = fi1_1[0];
        l1 = p1[0];
        if (Caml_obj.caml_equal(l1, l2)) then do
          _fi2 = fi2$prime;
          _fi1 = fi1$prime;
          _pairs = --[[ :: ]]{
            --[[ tuple ]]{
              l1,
              p1[1],
              p2[1]
            },
            pairs
          };
          ::continue:: ;
        end else if (Caml_obj.caml_lessthan(l1, l2)) then do
          _fi1 = fi1$prime;
          _r1 = --[[ :: ]]{
            p1,
            r1
          };
          ::continue:: ;
        end else do
          _fi2 = fi2$prime;
          _r2 = --[[ :: ]]{
            p2,
            r2
          };
          ::continue:: ;
        end end  end 
      end else do
        return --[[ tuple ]]{
                List.rev_append(r1, fi1_1),
                List.rev(r2),
                pairs
              };
      end end 
    end else do
      return --[[ tuple ]]{
              List.rev(r1),
              List.rev_append(r2, fi2_1),
              pairs
            };
    end end 
  end;
end end

function filter_row_fields(erase, param) do
  if (param) then do
    p = param[0];
    fi = filter_row_fields(erase, param[1]);
    match = row_field_repr_aux(--[[ [] ]]0, p[1]);
    if (typeof match == "number") then do
      return fi;
    end else if (match.tag and not (match[2] or not erase)) then do
      set_row_field(match[3], --[[ Rabsent ]]0);
      return fi;
    end else do
      return --[[ :: ]]{
              p,
              fi
            };
    end end  end 
  end else do
    return --[[ [] ]]0;
  end end 
end end

Non_closed0 = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Non_closed0");

function closed_schema_rec(_ty) do
  while(true) do
    ty = _ty;
    ty_1 = repr(ty);
    if (ty_1.level >= 0) then do
      level = ty_1.level;
      ty_1.level = pivot_level - level | 0;
      match = ty_1.desc;
      if (typeof match == "number") then do
        return iter_type_expr(closed_schema_rec, ty_1);
      end else do
        local ___conditional___=(match.tag | 0);
        do
           if ___conditional___ == 0--[[ Tvar ]] then do
              if (level ~= 100000000) then do
                error(Non_closed0)
              end
               end 
              return iter_type_expr(closed_schema_rec, ty_1); end end 
           if ___conditional___ == 5--[[ Tfield ]] then do
              if (field_kind_repr(match[1]) == --[[ Fpresent ]]0) then do
                closed_schema_rec(match[2]);
              end
               end 
              _ty = match[3];
              ::continue:: ; end end 
           if ___conditional___ == 8--[[ Tvariant ]] then do
              row = row_repr_aux(--[[ [] ]]0, match[0]);
              iter_row(closed_schema_rec, row);
              if (static_row(row)) then do
                return 0;
              end else do
                _ty = row.row_more;
                ::continue:: ;
              end end  end end 
          return iter_type_expr(closed_schema_rec, ty_1);
            
        end
      end end 
    end else do
      return 0;
    end end 
  end;
end end

function closed_schema(ty) do
  xpcall(function() do
    closed_schema_rec(ty);
    unmark_type(ty);
    return true;
  end end,function(exn) do
    if (exn == Non_closed0) then do
      unmark_type(ty);
      return false;
    end else do
      error(exn)
    end end 
  end end)
end end

Non_closed = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Non_closed");

free_variables = do
  contents: --[[ [] ]]0
end;

really_closed = do
  contents: undefined
end;

function free_vars_rec(_real, _ty) do
  while(true) do
    ty = _ty;
    real = _real;
    ty_1 = repr(ty);
    if (ty_1.level >= 0) then do
      ty_1.level = pivot_level - ty_1.level | 0;
      match = ty_1.desc;
      match_1 = really_closed.contents;
      if (typeof match == "number") then do
        return iter_type_expr((function(param) do
                      return free_vars_rec(true, param);
                    end end), ty_1);
      end else do
        local ___conditional___=(match.tag | 0);
        do
           if ___conditional___ == 0--[[ Tvar ]] then do
              free_variables.contents = --[[ :: ]]{
                --[[ tuple ]]{
                  ty_1,
                  real
                },
                free_variables.contents
              };
              return --[[ () ]]0; end end 
           if ___conditional___ == 3--[[ Tconstr ]] then do
              if (match_1 ~= undefined) then do
                xpcall(function() do
                  match_2 = find_type_expansion(match[0], Caml_option.valFromOption(match_1));
                  if (repr(match_2[1]).level ~= 100000000) then do
                    free_variables.contents = --[[ :: ]]{
                      --[[ tuple ]]{
                        ty_1,
                        real
                      },
                      free_variables.contents
                    };
                  end
                   end 
                end end,function(exn) do
                  if (exn ~= Caml_builtin_exceptions.not_found) then do
                    error(exn)
                  end
                   end 
                end end)
                return List.iter((function(param) do
                              return free_vars_rec(true, param);
                            end end), match[1]);
              end else do
                return iter_type_expr((function(param) do
                              return free_vars_rec(true, param);
                            end end), ty_1);
              end end  end end 
           if ___conditional___ == 4--[[ Tobject ]] then do
              _ty = match[0];
              _real = false;
              ::continue:: ; end end 
           if ___conditional___ == 5--[[ Tfield ]] then do
              free_vars_rec(true, match[2]);
              _ty = match[3];
              _real = false;
              ::continue:: ; end end 
           if ___conditional___ == 8--[[ Tvariant ]] then do
              row = row_repr_aux(--[[ [] ]]0, match[0]);
              iter_row((function(param) do
                      return free_vars_rec(true, param);
                    end end), row);
              if (static_row(row)) then do
                return 0;
              end else do
                _ty = row.row_more;
                _real = false;
                ::continue:: ;
              end end  end end 
          return iter_type_expr((function(param) do
                          return free_vars_rec(true, param);
                        end end), ty_1);
            
        end
      end end 
    end else do
      return 0;
    end end 
  end;
end end

function free_vars_1(env, ty) do
  free_variables.contents = --[[ [] ]]0;
  really_closed.contents = env;
  free_vars_rec(true, ty);
  res = free_variables.contents;
  free_variables.contents = --[[ [] ]]0;
  really_closed.contents = undefined;
  return res;
end end

function free_variables_1(env, ty) do
  tl = List.map((function(prim) do
          return prim[0];
        end end), free_vars_1(env, ty));
  unmark_type(ty);
  return tl;
end end

function closed_type(ty) do
  match = free_vars_1(undefined, ty);
  if (match) then do
    match_1 = match[0];
    error({
      Non_closed,
      match_1[0],
      match_1[1]
    })
  end else do
    return --[[ () ]]0;
  end end 
end end

function closed_parameterized_type(params, ty) do
  List.iter(mark_type, params);
  ok;
  xpcall(function() do
    closed_type(ty);
    ok = true;
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Non_closed) then do
      ok = false;
    end else do
      error(exn)
    end end 
  end end)
  List.iter(unmark_type, params);
  unmark_type(ty);
  return ok;
end end

function closed_type_decl(decl) do
  xpcall(function() do
    List.iter(mark_type, decl.type_params);
    match = decl.type_kind;
    if (typeof match == "number") then do
      match == --[[ Type_abstract ]]0;
    end else if (match.tag) then do
      List.iter((function(param) do
              if (param.cd_res ~= undefined) then do
                return --[[ () ]]0;
              end else do
                return List.iter(closed_type, param.cd_args);
              end end 
            end end), match[0]);
    end else do
      List.iter((function(l) do
              return closed_type(l.ld_type);
            end end), match[0]);
    end end  end 
    match_1 = decl.type_manifest;
    if (match_1 ~= undefined) then do
      closed_type(match_1);
    end
     end 
    it_type_declaration(unmark_iterators, decl);
    return ;
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Non_closed) then do
      it_type_declaration(unmark_iterators, decl);
      return exn[1];
    end else do
      error(exn)
    end end 
  end end)
end end

function closed_extension_constructor(ext) do
  xpcall(function() do
    List.iter(mark_type, ext.ext_type_params);
    match = ext.ext_ret_type;
    if (match == undefined) then do
      List.iter(closed_type, ext.ext_args);
    end
     end 
    unmark_extension_constructor(ext);
    return ;
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Non_closed) then do
      unmark_extension_constructor(ext);
      return exn[1];
    end else do
      error(exn)
    end end 
  end end)
end end

CCFailure = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.CCFailure");

function closed_class(params, sign) do
  ty = object_fields(repr(sign.csig_self));
  match = flatten_fields(ty);
  fields = match[0];
  List.iter(mark_type, params);
  mark_type(match[1]);
  List.iter((function(param) do
          if (param[0] == dummy_method) then do
            return mark_type(param[2]);
          end else do
            return 0;
          end end 
        end end), fields);
  xpcall(function() do
    mark_type_node(repr(sign.csig_self));
    List.iter((function(param) do
            ty = param[2];
            if (field_kind_repr(param[1]) == --[[ Fpresent ]]0) then do
              xpcall(function() do
                return closed_type(ty);
              end end,function(raw_exn) do
                exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                if (exn[0] == Non_closed) then do
                  error({
                    CCFailure,
                    --[[ CC_Method ]]Block.__(0, {
                        exn[1],
                        exn[2],
                        param[0],
                        ty
                      })
                  })
                end
                 end 
                error(exn)
              end end)
            end else do
              return 0;
            end end 
          end end), fields);
    iter_type_expr(mark_type, repr(sign.csig_self));
    List.iter(unmark_type, params);
    unmark_class_signature(sign);
    return ;
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == CCFailure) then do
      iter_type_expr(mark_type, repr(sign.csig_self));
      List.iter(unmark_type, params);
      unmark_class_signature(sign);
      return exn[1];
    end else do
      error(exn)
    end end 
  end end)
end end

function iter_generalize(tyl, ty) do
  ty_1 = repr(ty);
  if (ty_1.level > current_level.contents and ty_1.level ~= 100000000) then do
    set_level(ty_1, 100000000);
    match = ty_1.desc;
    if (typeof match ~= "number" and match.tag == --[[ Tconstr ]]3) then do
      iter_abbrev((function(param) do
              return iter_generalize(tyl, param);
            end end), match[2].contents);
    end
     end 
    return iter_type_expr((function(param) do
                  return iter_generalize(tyl, param);
                end end), ty_1);
  end else do
    tyl.contents = --[[ :: ]]{
      ty_1,
      tyl.contents
    };
    return --[[ () ]]0;
  end end 
end end

function iter_generalize_1(tyl, ty) do
  simple_abbrevs.contents = --[[ Mnil ]]0;
  return iter_generalize(tyl, ty);
end end

function generalize(ty) do
  return iter_generalize_1(do
              contents: --[[ [] ]]0
            end, ty);
end end

function generalize_structure(var_level, ty) do
  ty_1 = repr(ty);
  if (ty_1.level ~= 100000000) then do
    if (is_Tvar(ty_1) and ty_1.level > var_level) then do
      return set_level(ty_1, var_level);
    end else do
      tmp = false;
      if (ty_1.level > current_level.contents) then do
        match = ty_1.desc;
        tmp_1;
        tmp_1 = typeof match == "number" or match.tag ~= --[[ Tconstr ]]3 and true or not is_object_type(match[0]) and (match[2].contents = --[[ Mnil ]]0, true);
        tmp = tmp_1;
      end
       end 
      if (tmp) then do
        set_level(ty_1, 100000000);
        return iter_type_expr((function(param) do
                      return generalize_structure(var_level, param);
                    end end), ty_1);
      end else do
        return 0;
      end end 
    end end 
  end else do
    return 0;
  end end 
end end

function generalize_structure_1(var_level, ty) do
  simple_abbrevs.contents = --[[ Mnil ]]0;
  return generalize_structure(var_level, ty);
end end

function generalize_spine(_ty) do
  while(true) do
    ty = _ty;
    ty_1 = repr(ty);
    if (ty_1.level < current_level.contents or ty_1.level == 100000000) then do
      return --[[ () ]]0;
    end else do
      match = ty_1.desc;
      if (typeof match == "number") then do
        return --[[ () ]]0;
      end else do
        local ___conditional___=(match.tag | 0);
        do
           if ___conditional___ == 1--[[ Tarrow ]] then do
              set_level(ty_1, 100000000);
              generalize_spine(match[1]);
              _ty = match[2];
              ::continue:: ; end end 
           if ___conditional___ == 2--[[ Ttuple ]] then do
              set_level(ty_1, 100000000);
              return List.iter(generalize_spine, match[0]); end end 
           if ___conditional___ == 3--[[ Tconstr ]] then do
              if (is_object_type(match[0])) then do
                return --[[ () ]]0;
              end else do
                set_level(ty_1, 100000000);
                match[2].contents = --[[ Mnil ]]0;
                return List.iter(generalize_spine, match[1]);
              end end  end end 
           if ___conditional___ == 10--[[ Tpoly ]] then do
              set_level(ty_1, 100000000);
              _ty = match[0];
              ::continue:: ; end end 
           if ___conditional___ == 11--[[ Tpackage ]] then do
              set_level(ty_1, 100000000);
              return List.iter(generalize_spine, match[2]); end end 
          return --[[ () ]]0;
            
        end
      end end 
    end end 
  end;
end end

forward_try_expand_once = do
  contents: (function(env, ty) do
      error(Cannot_expand)
    end end)
end;

function get_level(env, p) do
  xpcall(function() do
    match = find_type_full(p, env)[0].type_newtype_level;
    if (match ~= undefined) then do
      return match[0];
    end else do
      return binding_time(p);
    end end 
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return binding_time(p);
    end else do
      error(exn)
    end end 
  end end)
end end

function normalize_package_path(env, _p) do
  while(true) do
    p = _p;
    t;
    xpcall(function() do
      t = find_modtype(p, env).mtd_type;
    end end,function(exn) do
      if (exn == Caml_builtin_exceptions.not_found) then do
        t = undefined;
      end else do
        error(exn)
      end end 
    end end)
    if (t ~= undefined) then do
      match = t;
      if (match.tag) then do
        return p;
      end else do
        _p = match[0];
        ::continue:: ;
      end end 
    end else do
      return p;
    end end 
  end;
end end

function update_level(env, level, _ty) do
  while(true) do
    ty = _ty;
    ty_1 = repr(ty);
    if (ty_1.level > level) then do
      match = gadt_instance_level(env, ty_1);
      if (match ~= undefined and level < match) then do
        error({
          Unify,
          --[[ :: ]]{
            --[[ tuple ]]{
              ty_1,
              newty2(level, --[[ Tvar ]]Block.__(0, {undefined}))
            },
            --[[ [] ]]0
          }
        })
      end
       end 
      match_1 = ty_1.desc;
      if (typeof match_1 ~= "number") then do
        local ___conditional___=(match_1.tag | 0);
        do
           if ___conditional___ == 3--[[ Tconstr ]] then do
              p = match_1[0];
              if (level < get_level(env, p)) then do
                xpcall(function() do
                  link_type(ty_1, Curry._2(forward_try_expand_once.contents, env, ty_1));
                  return update_level(env, level, ty_1);
                end end,function(exn) do
                  if (exn == Cannot_expand) then do
                    if (level < get_level(env, p)) then do
                      error({
                        Unify,
                        --[[ :: ]]{
                          --[[ tuple ]]{
                            ty_1,
                            newty2(level, --[[ Tvar ]]Block.__(0, {undefined}))
                          },
                          --[[ [] ]]0
                        }
                      })
                    end
                     end 
                    return iter_type_expr((function(param) do
                                  return update_level(env, level, param);
                                end end), ty_1);
                  end else do
                    error(exn)
                  end end 
                end end)
              end
               end  end else 
           if ___conditional___ == 4--[[ Tobject ]] then do
              nm = match_1[1];
              match_2 = nm.contents;
              if (match_2 ~= undefined and level < get_level(env, match_2[0])) then do
                set_name(nm, undefined);
                _ty = ty_1;
                ::continue:: ;
              end
               end  end else 
           if ___conditional___ == 5--[[ Tfield ]] then do
              ty1 = match_1[2];
              if (match_1[0] == dummy_method and repr(ty1).level > level) then do
                error({
                  Unify,
                  --[[ :: ]]{
                    --[[ tuple ]]{
                      ty1,
                      newty2(level, --[[ Tvar ]]Block.__(0, {undefined}))
                    },
                    --[[ [] ]]0
                  }
                })
              end
               end  end else 
           if ___conditional___ == 8--[[ Tvariant ]] then do
              row = row_repr_aux(--[[ [] ]]0, match_1[0]);
              match_3 = row.row_name;
              if (match_3 ~= undefined) then do
                if (level < get_level(env, match_3[0])) then do
                  log_type(ty_1);
                  ty_1.desc = --[[ Tvariant ]]Block.__(8, {do
                        row_fields: row.row_fields,
                        row_more: row.row_more,
                        row_bound: row.row_bound,
                        row_closed: row.row_closed,
                        row_fixed: row.row_fixed,
                        row_name: undefined
                      end});
                end
                 end 
              end
               end 
              set_level(ty_1, level);
              return iter_type_expr((function(param) do
                            return update_level(env, level, param);
                          end end), ty_1); end end end end end end end end 
           if ___conditional___ == 11--[[ Tpackage ]] then do
              p_1 = match_1[0];
              if (level < get_level(env, p_1)) then do
                p$prime = normalize_package_path(env, p_1);
                if (same(p_1, p$prime)) then do
                  error({
                    Unify,
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        ty_1,
                        newty2(level, --[[ Tvar ]]Block.__(0, {undefined}))
                      },
                      --[[ [] ]]0
                    }
                  })
                end
                 end 
                log_type(ty_1);
                ty_1.desc = --[[ Tpackage ]]Block.__(11, {
                    p$prime,
                    match_1[1],
                    match_1[2]
                  });
                _ty = ty_1;
                ::continue:: ;
              end
               end  end else 
           end end
          
        end
      end
       end 
      set_level(ty_1, level);
      return iter_type_expr((function(param) do
                    return update_level(env, level, param);
                  end end), ty_1);
    end else do
      return 0;
    end end 
  end;
end end

function generalize_contravariant(env) do
  if (principal.contents) then do
    return generalize_structure_1;
  end else do
    return (function(param, param_1) do
        return update_level(env, param, param_1);
      end end);
  end end 
end end

function generalize_expansive(env, var_level, _ty) do
  while(true) do
    ty = _ty;
    ty_1 = repr(ty);
    if (ty_1.level ~= 100000000 and ty_1.level > var_level) then do
      set_level(ty_1, 100000000);
      match = ty_1.desc;
      if (typeof match == "number") then do
        return iter_type_expr((function(param) do
                      return generalize_expansive(env, var_level, param);
                    end end), ty_1);
      end else do
        local ___conditional___=(match.tag | 0);
        do
           if ___conditional___ == 1--[[ Tarrow ]] then do
              generalize_contravariant(env)(var_level, match[1]);
              _ty = match[2];
              ::continue:: ; end end 
           if ___conditional___ == 3--[[ Tconstr ]] then do
              tyl = match[1];
              variance;
              xpcall(function() do
                variance = find_type_full(match[0], env)[0].type_variance;
              end end,function(exn) do
                if (exn == Caml_builtin_exceptions.not_found) then do
                  variance = List.map((function(param) do
                          return Types_Variance.may_inv;
                        end end), tyl);
                end else do
                  error(exn)
                end end 
              end end)
              match[2].contents = --[[ Mnil ]]0;
              return List.iter2((function(v, t) do
                            if (Curry._2(Types_Variance.mem, --[[ May_weak ]]2, v)) then do
                              return generalize_contravariant(env)(var_level, t);
                            end else do
                              return generalize_expansive(env, var_level, t);
                            end end 
                          end end), variance, tyl); end end 
           if ___conditional___ == 11--[[ Tpackage ]] then do
              partial_arg = generalize_contravariant(env);
              return List.iter((function(partial_arg)do
                        return function (param) do
                          return partial_arg(var_level, param);
                        end end
                        end end)(partial_arg), match[2]); end end 
          return iter_type_expr((function(param) do
                          return generalize_expansive(env, var_level, param);
                        end end), ty_1);
            
        end
      end end 
    end else do
      return 0;
    end end 
  end;
end end

function generalize_expansive_1(env, ty) do
  simple_abbrevs.contents = --[[ Mnil ]]0;
  xpcall(function() do
    return generalize_expansive(env, nongen_level.contents, ty);
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      tr = exn[1];
      if (tr) then do
        if (tr[1]) then do
          error(exn)
        end
         end 
        error({
          Unify,
          --[[ :: ]]{
            --[[ tuple ]]{
              ty,
              tr[0][1]
            },
            tr
          }
        })
      end else do
        error(exn)
      end end 
    end else do
      error(exn)
    end end 
  end end)
end end

function generalize_structure_2(ty) do
  return generalize_structure_1(current_level.contents, ty);
end end

function limited_generalize(ty0, ty) do
  ty0_1 = repr(ty0);
  graph = Hashtbl.create(undefined, 17);
  idx = do
    contents: 0
  end;
  roots = do
    contents: --[[ [] ]]0
  end;
  inverse = function(pty, ty) do
    ty_1 = repr(ty);
    if (ty_1.level > current_level.contents or ty_1.level == 100000000) then do
      idx.contents = idx.contents - 1 | 0;
      Hashtbl.add(graph, idx.contents, --[[ tuple ]]{
            ty_1,
            do
              contents: pty
            end
          });
      if (ty_1.level == 100000000 or ty_1 == ty0_1) then do
        roots.contents = --[[ :: ]]{
          ty_1,
          roots.contents
        };
      end
       end 
      set_level(ty_1, idx.contents);
      partial_arg = --[[ :: ]]{
        ty_1,
        --[[ [] ]]0
      };
      return iter_type_expr((function(param) do
                    return inverse(partial_arg, param);
                  end end), ty_1);
    end else if (ty_1.level < 0) then do
      match = Hashtbl.find(graph, ty_1.level);
      parents = match[1];
      parents.contents = Pervasives.$at(pty, parents.contents);
      return --[[ () ]]0;
    end else do
      return 0;
    end end  end 
  end end;
  generalize_parents = function(ty) do
    idx = ty.level;
    if (idx ~= 100000000) then do
      set_level(ty, 100000000);
      List.iter(generalize_parents, Hashtbl.find(graph, idx)[1].contents);
      match = ty.desc;
      if (typeof match == "number" or match.tag ~= --[[ Tvariant ]]8) then do
        return --[[ () ]]0;
      end else do
        more = row_more(match[0]);
        lv = more.level;
        if ((lv < 0 or lv > current_level.contents) and lv ~= 100000000) then do
          return set_level(more, 100000000);
        end else do
          return 0;
        end end 
      end end 
    end else do
      return 0;
    end end 
  end end;
  inverse(--[[ [] ]]0, ty);
  if (ty0_1.level < 0) then do
    iter_type_expr((function(param) do
            return inverse(--[[ [] ]]0, param);
          end end), ty0_1);
  end
   end 
  List.iter(generalize_parents, roots.contents);
  return Hashtbl.iter((function(param, param_1) do
                ty = param_1[0];
                if (ty.level ~= 100000000) then do
                  return set_level(ty, current_level.contents);
                end else do
                  return 0;
                end end 
              end end), graph);
end end

function inv_type(hash, pty, ty) do
  ty_1 = repr(ty);
  xpcall(function() do
    inv = Curry._2(TypeHash.find, hash, ty_1);
    inv.inv_parents = Pervasives.$at(pty, inv.inv_parents);
    return --[[ () ]]0;
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      inv_1 = do
        inv_type: ty_1,
        inv_parents: pty
      end;
      Curry._3(TypeHash.add, hash, ty_1, inv_1);
      partial_arg = --[[ :: ]]{
        inv_1,
        --[[ [] ]]0
      };
      return iter_type_expr((function(param) do
                    return inv_type(hash, partial_arg, param);
                  end end), ty_1);
    end else do
      error(exn)
    end end 
  end end)
end end

function compute_univars(ty) do
  inverted = Curry._1(TypeHash.create, 17);
  inv_type(inverted, --[[ [] ]]0, ty);
  node_univars = Curry._1(TypeHash.create, 17);
  add_univar = function(univ, inv) do
    match = inv.inv_type.desc;
    if (typeof match ~= "number" and match.tag == --[[ Tpoly ]]10 and List.memq(univ, List.map(repr, match[1]))) then do
      return --[[ () ]]0;
    end
     end 
    xpcall(function() do
      univs = Curry._2(TypeHash.find, node_univars, inv.inv_type);
      if (mem_3(univ, univs.contents)) then do
        return 0;
      end else do
        univs.contents = add_3(univ, univs.contents);
        return List.iter((function(param) do
                      return add_univar(univ, param);
                    end end), inv.inv_parents);
      end end 
    end end,function(exn) do
      if (exn == Caml_builtin_exceptions.not_found) then do
        Curry._3(TypeHash.add, node_univars, inv.inv_type, do
              contents: singleton_1(univ)
            end);
        return List.iter((function(param) do
                      return add_univar(univ, param);
                    end end), inv.inv_parents);
      end else do
        error(exn)
      end end 
    end end)
  end end;
  Curry._2(TypeHash.iter, (function(ty, inv) do
          if (is_Tunivar(ty)) then do
            return add_univar(ty, inv);
          end else do
            return 0;
          end end 
        end end), inverted);
  return (function(ty) do
      xpcall(function() do
        return Curry._2(TypeHash.find, node_univars, ty).contents;
      end end,function(exn) do
        if (exn == Caml_builtin_exceptions.not_found) then do
          return --[[ Empty ]]0;
        end else do
          error(exn)
        end end 
      end end)
    end end);
end end

function find_repr(p1, _param) do
  while(true) do
    param = _param;
    if (typeof param == "number") then do
      return ;
    end else if (param.tag) then do
      rem = param[0].contents;
      _param = rem;
      ::continue:: ;
    end else if (param[0]) then do
      if (same(p1, param[1])) then do
        return param[2];
      end else do
        _param = param[4];
        ::continue:: ;
      end end 
    end else do
      _param = param[4];
      ::continue:: ;
    end end  end  end 
  end;
end end

abbreviations = do
  contents: do
    contents: --[[ Mnil ]]0
  end
end;

function copy(env, partial, keep_names, ty) do
  copy_1 = function(param) do
    return copy(env, partial, keep_names, param);
  end end;
  ty_1 = repr(ty);
  match = ty_1.desc;
  exit = 0;
  if (typeof match == "number" or match.tag ~= --[[ Tsubst ]]7) then do
    exit = 1;
  end else do
    return match[0];
  end end 
  if (exit == 1) then do
    if (ty_1.level ~= 100000000 and partial == undefined) then do
      return ty_1;
    end else do
      forget;
      if (ty_1.level == 100000000) then do
        forget = 100000000;
      end else if (partial ~= undefined) then do
        match_1 = partial;
        param = Curry._1(match_1[0], ty_1);
        forget = (
          param and false or true
        ) and (
            match_1[1] and ty_1.level or current_level.contents
          ) or 100000000;
      end else do
        error({
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ctype.ml",
            984,
            16
          }
        })
      end end  end 
      if (forget ~= 100000000) then do
        return newty2(forget, --[[ Tvar ]]Block.__(0, {undefined}));
      end else do
        desc = ty_1.desc;
        save_desc(ty_1, desc);
        t = newvar(undefined, --[[ () ]]0);
        if (env ~= undefined) then do
          env_1 = Caml_option.valFromOption(env);
          if (env_1.local_constraints) then do
            match_2 = gadt_instance_level(env_1, ty_1);
            if (match_2 ~= undefined) then do
              add_gadt_instances(env_1, match_2, --[[ :: ]]{
                    t,
                    --[[ [] ]]0
                  });
            end
             end 
          end
           end 
        end
         end 
        ty_1.desc = --[[ Tsubst ]]Block.__(7, {t});
        tmp;
        if (typeof desc == "number") then do
          tmp = copy_type_desc(keep_names, copy_1, desc);
        end else do
          local ___conditional___=(desc.tag | 0);
          do
             if ___conditional___ == 3--[[ Tconstr ]] then do
                tl = desc[1];
                p = desc[0];
                abbrevs = proper_abbrevs(p, tl, abbreviations.contents);
                match_3 = find_repr(p, abbrevs.contents);
                exit_1 = 0;
                if (match_3 ~= undefined) then do
                  ty_2 = match_3;
                  if (repr(ty_2) ~= t) then do
                    tmp = --[[ Tlink ]]Block.__(6, {ty_2});
                  end else do
                    exit_1 = 2;
                  end end 
                end else do
                  exit_1 = 2;
                end end 
                if (exit_1 == 2) then do
                  abbrev = abbreviations.contents.contents;
                  tmp_1;
                  tmp_1 = typeof abbrev == "number" or abbrev.tag and abbrev or --[[ Mlink ]]Block.__(1, {abbreviations.contents});
                  tmp = --[[ Tconstr ]]Block.__(3, {
                      p,
                      List.map(copy_1, tl),
                      do
                        contents: tmp_1
                      end
                    });
                end
                 end  end else 
             if ___conditional___ == 4--[[ Tobject ]] then do
                tmp = partial ~= undefined and --[[ Tobject ]]Block.__(4, {
                      copy_1(desc[0]),
                      do
                        contents: undefined
                      end
                    }) or copy_type_desc(keep_names, copy_1, desc); end else 
             if ___conditional___ == 5--[[ Tfield ]] then do
                match_4 = field_kind_repr(desc[1]);
                if (typeof match_4 == "number") then do
                  tmp = match_4 ~= 0 and --[[ Tlink ]]Block.__(6, {copy_1(desc[3])}) or copy_type_desc(undefined, copy_1, desc);
                end else do
                  dup_kind(match_4[0]);
                  tmp = copy_type_desc(undefined, copy_1, desc);
                end end  end else 
             if ___conditional___ == 8--[[ Tvariant ]] then do
                row = row_repr_aux(--[[ [] ]]0, desc[0]);
                more = repr(row.row_more);
                match_5 = more.desc;
                exit_2 = 0;
                if (typeof match_5 == "number" or match_5.tag ~= --[[ Tsubst ]]7) then do
                  exit_2 = 2;
                end else do
                  match_6 = match_5[0].desc;
                  if (typeof match_6 == "number" or match_6.tag ~= --[[ Ttuple ]]2) then do
                    exit_2 = 2;
                  end else do
                    match_7 = match_6[0];
                    if (match_7) then do
                      match_8 = match_7[1];
                      if (match_8 and not match_8[1]) then do
                        ty2 = match_8[0];
                        ty_1.desc = --[[ Tsubst ]]Block.__(7, {ty2});
                        tmp = --[[ Tlink ]]Block.__(6, {ty2});
                      end else do
                        exit_2 = 2;
                      end end 
                    end else do
                      exit_2 = 2;
                    end end 
                  end end 
                end end 
                if (exit_2 == 2) then do
                  keep = more.level ~= 100000000;
                  match_9 = more.desc;
                  more$prime;
                  exit_3 = 0;
                  if (typeof match_9 == "number") then do
                    exit_3 = 3;
                  end else do
                    local ___conditional___=(match_9.tag | 0);
                    do
                       if ___conditional___ == 3--[[ Tconstr ]] then do
                          exit_3 = 3; end else 
                       if ___conditional___ == 7--[[ Tsubst ]] then do
                          more$prime = match_9[0]; end else 
                       if ___conditional___ == 0--[[ Tvar ]]
                       or ___conditional___ == 9--[[ Tunivar ]] then do
                          exit_3 = 4; end else 
                       end end end end end end
                      error({
                          Caml_builtin_exceptions.assert_failure,
                          --[[ tuple ]]{
                            "ctype.ml",
                            1047,
                            24
                          }
                        })
                        
                    end
                  end end 
                  local ___conditional___=(exit_3);
                  do
                     if ___conditional___ == 3 then do
                        if (keep) then do
                          save_desc(more, more.desc);
                        end
                         end 
                        more$prime = copy_1(more); end else 
                     if ___conditional___ == 4 then do
                        save_desc(more, more.desc);
                        more$prime = keep and more or newty2(current_level.contents, more.desc); end else 
                     end end end end
                    
                  end
                  match_10 = repr(more$prime);
                  match_11 = match_10.desc;
                  row_1;
                  row_1 = typeof match_11 == "number" or not (match_11.tag == --[[ Tconstr ]]3 and not row.row_fixed) and row or (do
                        row_fields: row.row_fields,
                        row_more: row.row_more,
                        row_bound: row.row_bound,
                        row_closed: row.row_closed,
                        row_fixed: true,
                        row_name: row.row_name
                      end);
                  match_12;
                  if (partial ~= undefined) then do
                    match_13 = partial;
                    if (match_13[1]) then do
                      match_12 = --[[ tuple ]]{
                        more$prime,
                        row_1
                      };
                    end else do
                      more$prime_1;
                      if (more.id ~= more$prime.id) then do
                        more$prime_1 = more$prime;
                      end else do
                        lv = keep and more.level or current_level.contents;
                        more$prime_1 = newty2(lv, --[[ Tvar ]]Block.__(0, {undefined}));
                      end end 
                      not_reither = function(param) do
                        match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                        if (typeof match == "number" or not match.tag) then do
                          return true;
                        end else do
                          return false;
                        end end 
                      end end;
                      tmp_2 = false;
                      if (row_1.row_closed) then do
                        tmp_3 = false;
                        if (not row_1.row_fixed) then do
                          param_1 = Curry._1(match_13[0], ty_1);
                          tmp_3 = (
                            param_1 and false or true
                          ) and not List.for_all(not_reither, row_1.row_fields);
                        end
                         end 
                        tmp_2 = tmp_3;
                      end
                       end 
                      match_12 = tmp_2 and --[[ tuple ]]{
                          more$prime_1,
                          do
                            row_fields: List.filter(not_reither)(row_1.row_fields),
                            row_more: more$prime_1,
                            row_bound: --[[ () ]]0,
                            row_closed: false,
                            row_fixed: false,
                            row_name: undefined
                          end
                        } or --[[ tuple ]]{
                          more$prime_1,
                          row_1
                        };
                    end end 
                  end else do
                    match_12 = --[[ tuple ]]{
                      more$prime,
                      row_1
                    };
                  end end 
                  more$prime_2 = match_12[0];
                  more.desc = --[[ Tsubst ]]Block.__(7, {newty2(100000000, --[[ Ttuple ]]Block.__(2, {--[[ :: ]]{
                                more$prime_2,
                                --[[ :: ]]{
                                  t,
                                  --[[ [] ]]0
                                }
                              }}))});
                  tmp = --[[ Tvariant ]]Block.__(8, {copy_row(copy_1, true, match_12[1], keep, more$prime_2)});
                end
                 end  end else 
             end end end end end end end end
            tmp = copy_type_desc(keep_names, copy_1, desc);
              
          end
        end end 
        t.desc = tmp;
        return t;
      end end 
    end end 
  end
   end 
end end

function simple_copy(t) do
  return copy(undefined, undefined, undefined, t);
end end

function gadt_env(env) do
  if (env.local_constraints) then do
    return Caml_option.some(env);
  end
   end 
end end

function instance(partial, env, sch) do
  env_1 = gadt_env(env);
  partial_1 = partial ~= undefined and --[[ tuple ]]{
      compute_univars(sch),
      partial
    } or undefined;
  ty = copy(env_1, partial_1, undefined, sch);
  cleanup_types(--[[ () ]]0);
  return ty;
end end

function instance_def(sch) do
  ty = copy(undefined, undefined, undefined, sch);
  cleanup_types(--[[ () ]]0);
  return ty;
end end

function instance_list(env, schl) do
  env_1 = gadt_env(env);
  tyl = List.map((function(t) do
          return copy(env_1, undefined, undefined, t);
        end end), schl);
  cleanup_types(--[[ () ]]0);
  return tyl;
end end

reified_var_counter = do
  contents: --[[ Empty ]]0
end;

function get_new_abstract_name(s) do
  index;
  xpcall(function() do
    index = find(s, reified_var_counter.contents) + 1 | 0;
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      index = 0;
    end else do
      error(exn)
    end end 
  end end)
  reified_var_counter.contents = add_1(s, index, reified_var_counter.contents);
  return Curry._2(Printf.sprintf(--[[ Format ]]{
                  --[[ String ]]Block.__(2, {
                      --[[ No_padding ]]0,
                      --[[ Char_literal ]]Block.__(12, {
                          --[[ "#" ]]35,
                          --[[ Int ]]Block.__(4, {
                              --[[ Int_d ]]0,
                              --[[ No_padding ]]0,
                              --[[ No_precision ]]0,
                              --[[ End_of_format ]]0
                            })
                        })
                    }),
                  "%s#%d"
                }), s, index);
end end

function new_declaration(newtype, manifest) do
  return do
          type_params: --[[ [] ]]0,
          type_arity: 0,
          type_kind: --[[ Type_abstract ]]0,
          type_private: --[[ Public ]]1,
          type_manifest: manifest,
          type_variance: --[[ [] ]]0,
          type_newtype_level: newtype,
          type_loc: none,
          type_attributes: --[[ [] ]]0
        end;
end end

function instance_constructor(in_pattern, cstr) do
  if (in_pattern ~= undefined) then do
    match = in_pattern;
    newtype_lev = match[1];
    env = match[0];
    __process = function(existential) do
      decl = new_declaration(--[[ tuple ]]{
            newtype_lev,
            newtype_lev
          }, undefined);
      match = repr(existential);
      match_1 = match.desc;
      name;
      if (typeof match_1 == "number" or match_1.tag) then do
        name = "ex";
      end else do
        match_2 = match_1[0];
        name = match_2 ~= undefined and match_2 or "ex";
      end end 
      match_3 = enter_type(get_new_abstract_name(name), decl, env.contents);
      env.contents = match_3[1];
      to_unify = newty2(current_level.contents, --[[ Tconstr ]]Block.__(3, {
              --[[ Pident ]]Block.__(0, {match_3[0]}),
              --[[ [] ]]0,
              do
                contents: --[[ Mnil ]]0
              end
            }));
      tv = copy(undefined, undefined, undefined, existential);
      if (not is_Tvar(tv)) then do
        error({
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ctype.ml",
            1170,
            8
          }
        })
      end
       end 
      return link_type(tv, to_unify);
    end end;
    List.iter(__process, cstr.cstr_existentials);
  end
   end 
  ty_res = copy(undefined, undefined, undefined, cstr.cstr_res);
  ty_args = List.map(simple_copy, cstr.cstr_args);
  cleanup_types(--[[ () ]]0);
  return --[[ tuple ]]{
          ty_args,
          ty_res
        };
end end

function instance_parameterized_type(keep_names, sch_args, sch) do
  ty_args = List.map((function(t) do
          return copy(undefined, undefined, keep_names, t);
        end end), sch_args);
  ty = copy(undefined, undefined, undefined, sch);
  cleanup_types(--[[ () ]]0);
  return --[[ tuple ]]{
          ty_args,
          ty
        };
end end

function instance_declaration(decl) do
  match = decl.type_kind;
  tmp;
  tmp = typeof match == "number" and (
      match == --[[ Type_abstract ]]0 and --[[ Type_abstract ]]0 or --[[ Type_open ]]1
    ) or (
      match.tag and --[[ Type_variant ]]Block.__(1, {List.map((function(c) do
                    return do
                            cd_id: c.cd_id,
                            cd_args: List.map(simple_copy, c.cd_args),
                            cd_res: may_map(simple_copy, c.cd_res),
                            cd_loc: c.cd_loc,
                            cd_attributes: c.cd_attributes
                          end;
                  end end), match[0])}) or --[[ Type_record ]]Block.__(0, {
            List.map((function(l) do
                    return do
                            ld_id: l.ld_id,
                            ld_mutable: l.ld_mutable,
                            ld_type: copy(undefined, undefined, undefined, l.ld_type),
                            ld_loc: l.ld_loc,
                            ld_attributes: l.ld_attributes
                          end;
                  end end), match[0]),
            match[1]
          })
    );
  decl_type_params = List.map(simple_copy, decl.type_params);
  decl_type_arity = decl.type_arity;
  decl_type_private = decl.type_private;
  decl_type_manifest = may_map(simple_copy, decl.type_manifest);
  decl_type_variance = decl.type_variance;
  decl_type_newtype_level = decl.type_newtype_level;
  decl_type_loc = decl.type_loc;
  decl_type_attributes = decl.type_attributes;
  decl_1 = do
    type_params: decl_type_params,
    type_arity: decl_type_arity,
    type_kind: tmp,
    type_private: decl_type_private,
    type_manifest: decl_type_manifest,
    type_variance: decl_type_variance,
    type_newtype_level: decl_type_newtype_level,
    type_loc: decl_type_loc,
    type_attributes: decl_type_attributes
  end;
  cleanup_types(--[[ () ]]0);
  return decl_1;
end end

function instance_class(params, cty) do
  copy_class_type = function(param) do
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ == 0--[[ Cty_constr ]] then do
          return --[[ Cty_constr ]]Block.__(0, {
                    param[0],
                    List.map(simple_copy, param[1]),
                    copy_class_type(param[2])
                  }); end end 
       if ___conditional___ == 1--[[ Cty_signature ]] then do
          sign = param[0];
          return --[[ Cty_signature ]]Block.__(1, {do
                      csig_self: copy(undefined, undefined, undefined, sign.csig_self),
                      csig_vars: map((function(param) do
                              return --[[ tuple ]]{
                                      param[0],
                                      param[1],
                                      copy(undefined, undefined, undefined, param[2])
                                    };
                            end end), sign.csig_vars),
                      csig_concr: sign.csig_concr,
                      csig_inher: List.map((function(param) do
                              return --[[ tuple ]]{
                                      param[0],
                                      List.map(simple_copy, param[1])
                                    };
                            end end), sign.csig_inher)
                    end}); end end 
       if ___conditional___ == 2--[[ Cty_arrow ]] then do
          return --[[ Cty_arrow ]]Block.__(2, {
                    param[0],
                    copy(undefined, undefined, undefined, param[1]),
                    copy_class_type(param[2])
                  }); end end 
      
    end
  end end;
  params$prime = List.map(simple_copy, params);
  cty$prime = copy_class_type(cty);
  cleanup_types(--[[ () ]]0);
  return --[[ tuple ]]{
          params$prime,
          cty$prime
        };
end end

function diff_list(l1, l2) do
  if (l1 == l2) then do
    return --[[ [] ]]0;
  end else if (l1) then do
    return --[[ :: ]]{
            l1[0],
            diff_list(l1[1], l2)
          };
  end else do
    error({
      Caml_builtin_exceptions.invalid_argument,
      "Ctype.diff_list"
    })
  end end  end 
end end

function conflicts(free, bound) do
  bound_1 = List.map(repr, bound);
  return exists((function(t) do
                return List.memq(repr(t), bound_1);
              end end), free);
end end

delayed_copy = do
  contents: --[[ [] ]]0
end;

function copy_sep(fixed, free, bound, visited, ty) do
  ty_1 = repr(ty);
  univars = Curry._1(free, ty_1);
  if (univars and false or true) then do
    if (ty_1.level ~= 100000000) then do
      return ty_1;
    end else do
      t = newvar(undefined, --[[ () ]]0);
      delayed_copy.contents = --[[ :: ]]{
        Caml_obj.caml_lazy_make((function(param) do
                t.desc = --[[ Tlink ]]Block.__(6, {copy(undefined, undefined, undefined, ty_1)});
                return --[[ () ]]0;
              end end)),
        delayed_copy.contents
      };
      return t;
    end end 
  end else do
    xpcall(function() do
      match = List.assq(ty_1, visited);
      dl = is_Tunivar(ty_1) and --[[ [] ]]0 or diff_list(bound, match[1]);
      if (dl ~= --[[ [] ]]0 and conflicts(univars, dl)) then do
        error(Caml_builtin_exceptions.not_found)
      end
       end 
      return match[0];
    end end,function(exn) do
      if (exn == Caml_builtin_exceptions.not_found) then do
        t_1 = newvar(undefined, --[[ () ]]0);
        match_1 = ty_1.desc;
        visited_1;
        exit = 0;
        if (typeof match_1 == "number") then do
          visited_1 = visited;
        end else do
          local ___conditional___=(match_1.tag | 0);
          do
             if ___conditional___ == 1--[[ Tarrow ]]
             or ___conditional___ == 2--[[ Ttuple ]]
             or ___conditional___ == 3--[[ Tconstr ]]
             or ___conditional___ == 4--[[ Tobject ]]
             or ___conditional___ == 8--[[ Tvariant ]]
             or ___conditional___ == 11--[[ Tpackage ]] then do
                exit = 1; end else 
             end end
            visited_1 = visited;
              
          end
        end end 
        if (exit == 1) then do
          visited_1 = --[[ :: ]]{
            --[[ tuple ]]{
              ty_1,
              --[[ tuple ]]{
                t_1,
                bound
              }
            },
            visited
          };
        end
         end 
        copy_rec = function(param) do
          return copy_sep(fixed, free, bound, visited_1, param);
        end end;
        match_2 = ty_1.desc;
        tmp;
        if (typeof match_2 == "number") then do
          tmp = copy_type_desc(undefined, copy_rec, ty_1.desc);
        end else do
          local ___conditional___=(match_2.tag | 0);
          do
             if ___conditional___ == 8--[[ Tvariant ]] then do
                row = row_repr_aux(--[[ [] ]]0, match_2[0]);
                more = repr(row.row_more);
                keep = is_Tvar(more) and more.level ~= 100000000;
                more$prime = copy_rec(more);
                fixed$prime = fixed and is_Tvar(repr(more$prime));
                row_1 = copy_row(copy_rec, fixed$prime, row, keep, more$prime);
                tmp = --[[ Tvariant ]]Block.__(8, {row_1}); end else 
             if ___conditional___ == 10--[[ Tpoly ]] then do
                tl = List.map(repr, match_2[1]);
                tl$prime = List.map((function(t) do
                        return newty2(current_level.contents, t.desc);
                      end end), tl);
                bound_1 = Pervasives.$at(tl, bound);
                visited_2 = Pervasives.$at(List.map2((function(ty, t) do
                            return --[[ tuple ]]{
                                    ty,
                                    --[[ tuple ]]{
                                      t,
                                      bound_1
                                    }
                                  };
                          end end), tl, tl$prime), visited_1);
                tmp = --[[ Tpoly ]]Block.__(10, {
                    copy_sep(fixed, free, bound_1, visited_2, match_2[0]),
                    tl$prime
                  }); end else 
             end end end end
            tmp = copy_type_desc(undefined, copy_rec, ty_1.desc);
              
          end
        end end 
        t_1.desc = tmp;
        return t_1;
      end else do
        error(exn)
      end end 
    end end)
  end end 
end end

function instance_poly(keep_namesOpt, fixed, univars, sch) do
  keep_names = keep_namesOpt ~= undefined and keep_namesOpt or false;
  univars_1 = List.map(repr, univars);
  copy_var = function(ty) do
    match = ty.desc;
    if (typeof match == "number") then do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "ctype.ml",
          1307,
          11
        }
      })
    end else if (match.tag == --[[ Tunivar ]]9) then do
      if (keep_names) then do
        return newty2(current_level.contents, --[[ Tvar ]]Block.__(0, {match[0]}));
      end else do
        return newvar(undefined, --[[ () ]]0);
      end end 
    end else do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "ctype.ml",
          1307,
          11
        }
      })
    end end  end 
  end end;
  vars = List.map(copy_var, univars_1);
  pairs = List.map2((function(u, v) do
          return --[[ tuple ]]{
                  u,
                  --[[ tuple ]]{
                    v,
                    --[[ [] ]]0
                  }
                };
        end end), univars_1, vars);
  delayed_copy.contents = --[[ [] ]]0;
  ty = copy_sep(fixed, compute_univars(sch), --[[ [] ]]0, pairs, sch);
  List.iter(CamlinternalLazy.force, delayed_copy.contents);
  delayed_copy.contents = --[[ [] ]]0;
  cleanup_types(--[[ () ]]0);
  return --[[ tuple ]]{
          vars,
          ty
        };
end end

function instance_label(fixed, lbl) do
  ty_res = copy(undefined, undefined, undefined, lbl.lbl_res);
  ty = repr(lbl.lbl_arg);
  match = ty.desc;
  match_1;
  exit = 0;
  if (typeof match == "number" or match.tag ~= --[[ Tpoly ]]10) then do
    exit = 1;
  end else do
    match_1 = instance_poly(undefined, fixed, match[1], match[0]);
  end end 
  if (exit == 1) then do
    match_1 = --[[ tuple ]]{
      --[[ [] ]]0,
      copy(undefined, undefined, undefined, lbl.lbl_arg)
    };
  end
   end 
  cleanup_types(--[[ () ]]0);
  return --[[ tuple ]]{
          match_1[0],
          match_1[1],
          ty_res
        };
end end

unify$prime = do
  contents: (function(env, ty1, ty2) do
      error({
        Unify,
        --[[ [] ]]0
      })
    end end)
end;

function subst(env, level, priv, abbrev, ty, params, args, body) do
  if (List.length(params) ~= List.length(args)) then do
    error({
      Unify,
      --[[ [] ]]0
    })
  end
   end 
  old_level = current_level.contents;
  current_level.contents = level;
  xpcall(function() do
    body0 = newvar(undefined, --[[ () ]]0);
    if (ty ~= undefined) then do
      ty_1 = ty;
      match = ty_1.desc;
      if (typeof match == "number") then do
        error({
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ctype.ml",
            1347,
            8
          }
        })
      end else if (match.tag == --[[ Tconstr ]]3) then do
        path = match[0];
        abbrev_1 = proper_abbrevs(path, match[1], abbrev);
        memorize_abbrev(abbrev_1, priv, path, ty_1, body0);
      end else do
        error({
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ctype.ml",
            1347,
            8
          }
        })
      end end  end 
    end
     end 
    abbreviations.contents = abbrev;
    match_1 = instance_parameterized_type(undefined, params, body);
    body$prime = match_1[1];
    abbreviations.contents = do
      contents: --[[ Mnil ]]0
    end;
    Curry._3(unify$prime.contents, env, body0, body$prime);
    List.iter2(Curry._1(unify$prime.contents, env), match_1[0], args);
    current_level.contents = old_level;
    return body$prime;
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      current_level.contents = old_level;
      error(exn)
    end else do
      error(exn)
    end end 
  end end)
end end

previous_env = do
  contents: empty
end;

function check_abbrev_env(env) do
  if (env ~= previous_env.contents) then do
    cleanup_abbrev(--[[ () ]]0);
    previous_env.contents = env;
    return --[[ () ]]0;
  end else do
    return 0;
  end end 
end end

function expand_abbrev_gen(kind, find_type_expansion, env, ty) do
  check_abbrev_env(env);
  match = ty.desc;
  if (typeof match == "number") then do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "ctype.ml",
        1456,
        6
      }
    })
  end else if (match.tag == --[[ Tconstr ]]3) then do
    abbrev = match[2];
    args = match[1];
    path = match[0];
    level = ty.level;
    lookup_abbrev = proper_abbrevs(path, args, abbrev);
    match_1 = find_expans(kind, path, lookup_abbrev.contents);
    if (match_1 ~= undefined) then do
      ty_1 = match_1;
      if (level ~= 100000000) then do
        xpcall(function() do
          update_level(env, level, ty_1);
        end end,function(raw_exn) do
          exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn[0] ~= Unify) then do
            error(exn)
          end
           end 
        end end)
      end
       end 
      return ty_1;
    end else do
      match_2;
      xpcall(function() do
        match_2 = Curry._2(find_type_expansion, path, env);
      end end,function(exn_1) do
        if (exn_1 == Caml_builtin_exceptions.not_found) then do
          error(Cannot_expand)
        end
         end 
        error(exn_1)
      end end)
      ty$prime = subst(env, level, kind, abbrev, ty, match_2[0], args, match_2[1]);
      ty_2 = repr(ty$prime);
      match_3 = ty_2.desc;
      if (typeof match_3 ~= "number" and match_3.tag == --[[ Tvariant ]]8) then do
        row = match_3[0];
        if (static_row(row)) then do
          ty_2.desc = --[[ Tvariant ]]Block.__(8, {do
                row_fields: row.row_fields,
                row_more: row.row_more,
                row_bound: row.row_bound,
                row_closed: row.row_closed,
                row_fixed: row.row_fixed,
                row_name: --[[ tuple ]]{
                  path,
                  args
                }
              end});
        end
         end 
      end
       end 
      if (trace_gadt_instances.contents) then do
        match_4 = Caml_obj.caml_max(match_2[2], gadt_instance_level(env, ty));
        if (match_4 ~= undefined) then do
          lv = match_4;
          if (level < lv) then do
            error({
              Unify,
              --[[ :: ]]{
                --[[ tuple ]]{
                  ty,
                  newty2(level, --[[ Tvar ]]Block.__(0, {undefined}))
                },
                --[[ [] ]]0
              }
            })
          end
           end 
          add_gadt_instances(env, lv, --[[ :: ]]{
                ty,
                --[[ :: ]]{
                  ty$prime,
                  --[[ [] ]]0
                }
              });
        end
         end 
      end
       end 
      return ty$prime;
    end end 
  end else do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "ctype.ml",
        1456,
        6
      }
    })
  end end  end 
end end

function expand_abbrev(ty) do
  return (function(param) do
      return expand_abbrev_gen(--[[ Public ]]1, find_type_expansion, ty, param);
    end end);
end end

function expand_head_once(env, ty) do
  xpcall(function() do
    return expand_abbrev(env)(repr(ty));
  end end,function(exn) do
    if (exn == Cannot_expand) then do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "ctype.ml",
          1464,
          56
        }
      })
    end
     end 
    error(exn)
  end end)
end end

function safe_abbrev(env, ty) do
  snap = snapshot(--[[ () ]]0);
  xpcall(function() do
    expand_abbrev(env)(ty);
    return true;
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn == Cannot_expand or exn[0] == Unify) then do
      backtrack(snap);
      return false;
    end else do
      error(exn)
    end end 
  end end)
end end

function try_expand_once(env, ty) do
  ty_1 = repr(ty);
  match = ty_1.desc;
  if (typeof match == "number") then do
    error(Cannot_expand)
  end else if (match.tag == --[[ Tconstr ]]3) then do
    return repr(expand_abbrev(env)(ty_1));
  end else do
    error(Cannot_expand)
  end end  end 
end end

function try_expand_safe(env, ty) do
  snap = snapshot(--[[ () ]]0);
  xpcall(function() do
    return try_expand_once(env, ty);
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      backtrack(snap);
      error(Cannot_expand)
    end else do
      error(exn)
    end end 
  end end)
end end

function try_expand_head(try_once, env, ty) do
  ty$prime = Curry._2(try_once, env, ty);
  xpcall(function() do
    return try_expand_head(try_once, env, ty$prime);
  end end,function(exn) do
    if (exn == Cannot_expand) then do
      return ty$prime;
    end else do
      error(exn)
    end end 
  end end)
end end

function try_expand_head_1(try_once, env, ty) do
  ty$prime = try_expand_head(try_once, env, ty);
  match = gadt_instance_level(env, ty$prime);
  if (match ~= undefined) then do
    add_gadt_instance_chain(env, match, ty);
  end
   end 
  return ty$prime;
end end

function expand_head_unif(env, ty) do
  xpcall(function() do
    return try_expand_head_1(try_expand_once, env, ty);
  end end,function(exn) do
    if (exn == Cannot_expand) then do
      return repr(ty);
    end else do
      error(exn)
    end end 
  end end)
end end

function expand_head(env, ty) do
  xpcall(function() do
    return try_expand_head_1(try_expand_safe, env, ty);
  end end,function(exn) do
    if (exn == Cannot_expand) then do
      return repr(ty);
    end else do
      error(exn)
    end end 
  end end)
end end

forward_try_expand_once.contents = try_expand_safe;

function extract_concrete_typedecl(env, ty) do
  ty_1 = repr(ty);
  match = ty_1.desc;
  if (typeof match == "number") then do
    error(Caml_builtin_exceptions.not_found)
  end else if (match.tag == --[[ Tconstr ]]3) then do
    p = match[0];
    decl = find_type_full(p, env)[0];
    if (decl.type_kind ~= --[[ Type_abstract ]]0) then do
      return --[[ tuple ]]{
              p,
              p,
              decl
            };
    end else do
      ty_2;
      xpcall(function() do
        ty_2 = try_expand_once(env, ty_1);
      end end,function(exn) do
        if (exn == Cannot_expand) then do
          error(Caml_builtin_exceptions.not_found)
        end
         end 
        error(exn)
      end end)
      match_1 = extract_concrete_typedecl(env, ty_2);
      return --[[ tuple ]]{
              p,
              match_1[1],
              match_1[2]
            };
    end end 
  end else do
    error(Caml_builtin_exceptions.not_found)
  end end  end 
end end

function expand_abbrev_opt(param, param_1) do
  return expand_abbrev_gen(--[[ Private ]]0, find_type_expansion_opt, param, param_1);
end end

function try_expand_once_opt(env, ty) do
  ty_1 = repr(ty);
  match = ty_1.desc;
  if (typeof match == "number") then do
    error(Cannot_expand)
  end else if (match.tag == --[[ Tconstr ]]3) then do
    return repr(expand_abbrev_opt(env, ty_1));
  end else do
    error(Cannot_expand)
  end end  end 
end end

function try_expand_head_opt(env, ty) do
  ty$prime = try_expand_once_opt(env, ty);
  xpcall(function() do
    return try_expand_head_opt(env, ty$prime);
  end end,function(exn) do
    if (exn == Cannot_expand) then do
      return ty$prime;
    end else do
      error(exn)
    end end 
  end end)
end end

function expand_head_opt(env, ty) do
  snap = snapshot(--[[ () ]]0);
  xpcall(function() do
    return try_expand_head_opt(env, ty);
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn == Cannot_expand or exn[0] == Unify) then do
      backtrack(snap);
      return repr(ty);
    end else do
      error(exn)
    end end 
  end end)
end end

function enforce_constraints(env, ty) do
  match = ty.desc;
  if (typeof match == "number") then do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "ctype.ml",
        1574,
        6
      }
    })
  end else if (match.tag == --[[ Tconstr ]]3) then do
    level = ty.level;
    xpcall(function() do
      decl = find_type_full(match[0], env)[0];
      subst(env, level, --[[ Public ]]1, do
            contents: --[[ Mnil ]]0
          end, undefined, decl.type_params, match[1], newty2(level, --[[ Tvar ]]Block.__(0, {undefined})));
      return --[[ () ]]0;
    end end,function(exn) do
      if (exn == Caml_builtin_exceptions.not_found) then do
        return --[[ () ]]0;
      end else do
        error(exn)
      end end 
    end end)
  end else do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "ctype.ml",
        1574,
        6
      }
    })
  end end  end 
end end

function full_expand(env, ty) do
  ty_1 = repr(expand_head(env, ty));
  match = ty_1.desc;
  if (typeof match == "number" or match.tag ~= --[[ Tobject ]]4) then do
    return ty_1;
  end else do
    match_1 = match[1].contents;
    if (match_1 ~= undefined) then do
      match_2 = match_1[1];
      if (match_2 and is_Tvar(repr(match_2[0]))) then do
        return newty2(ty_1.level, --[[ Tobject ]]Block.__(4, {
                      match[0],
                      do
                        contents: undefined
                      end
                    }));
      end else do
        return ty_1;
      end end 
    end else do
      return ty_1;
    end end 
  end end 
end end

function generic_abbrev(env, path) do
  xpcall(function() do
    match = find_type_expansion(path, env);
    return repr(match[1]).level == 100000000;
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return false;
    end else do
      error(exn)
    end end 
  end end)
end end

function generic_private_abbrev(env, path) do
  xpcall(function() do
    match = find_type_full(path, env)[0];
    match_1 = match.type_kind;
    if (typeof match_1 == "number" and not (match_1 ~= 0 or match.type_private)) then do
      match_2 = match.type_manifest;
      if (match_2 ~= undefined) then do
        return repr(match_2).level == 100000000;
      end else do
        return false;
      end end 
    end else do
      return false;
    end end 
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return false;
    end else do
      error(exn)
    end end 
  end end)
end end

function is_contractive(env, ty) do
  match = repr(ty).desc;
  if (typeof match == "number" or match.tag ~= --[[ Tconstr ]]3) then do
    return true;
  end else do
    p = match[0];
    if (in_pervasives(p)) then do
      return true;
    end else do
      xpcall(function() do
        return is_datatype(find_type_full(p, env)[0]);
      end end,function(exn) do
        if (exn == Caml_builtin_exceptions.not_found) then do
          return false;
        end else do
          error(exn)
        end end 
      end end)
    end end 
  end end 
end end

Occur = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Occur");

function occur_rec(env, visited, ty0, ty) do
  if (ty == ty0) then do
    error(Occur)
  end
   end 
  occur_ok = recursive_types.contents and is_contractive(env, ty);
  match = ty.desc;
  if (typeof match ~= "number") then do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 3--[[ Tconstr ]] then do
          xpcall(function() do
            if (occur_ok or List.memq(ty, visited)) then do
              error(Occur)
            end
             end 
            partial_arg = --[[ :: ]]{
              ty,
              visited
            };
            return iter_type_expr((function(param) do
                          return occur_rec(env, partial_arg, ty0, param);
                        end end), ty);
          end end,function(exn) do
            if (exn == Occur) then do
              xpcall(function() do
                ty$prime = try_expand_head_1(try_expand_once, env, ty);
                if (ty$prime == ty0 or List.memq(ty$prime, visited)) then do
                  error(Occur)
                end
                 end 
                match_1 = ty$prime.desc;
                exit = 0;
                if (typeof match_1 == "number") then do
                  exit = 2;
                end else do
                  local ___conditional___=(match_1.tag | 0);
                  do
                     if ___conditional___ == 4--[[ Tobject ]]
                     or ___conditional___ == 8--[[ Tvariant ]] then do
                        return --[[ () ]]0; end end 
                    exit = 2;
                      
                  end
                end end 
                if (exit == 2) then do
                  if (recursive_types.contents and is_contractive(env, ty$prime)) then do
                    return 0;
                  end else do
                    partial_arg_1 = --[[ :: ]]{
                      ty$prime,
                      visited
                    };
                    return iter_type_expr((function(param) do
                                  return occur_rec(env, partial_arg_1, ty0, param);
                                end end), ty$prime);
                  end end 
                end
                 end 
              end end,function(exn_1) do
                if (exn_1 == Cannot_expand) then do
                  if (occur_ok) then do
                    return 0;
                  end else do
                    error(Occur)
                  end end 
                end else do
                  error(exn_1)
                end end 
              end end)
            end else do
              error(exn)
            end end 
          end end) end else 
       if ___conditional___ == 4--[[ Tobject ]]
       or ___conditional___ == 8--[[ Tvariant ]] then do
          return --[[ () ]]0; end end end end 
      
    end
  end
   end 
  if (occur_ok) then do
    return 0;
  end else do
    return iter_type_expr((function(param) do
                  return occur_rec(env, visited, ty0, param);
                end end), ty);
  end end 
end end

type_changed = do
  contents: false
end;

function merge(r, b) do
  if (b) then do
    r.contents = true;
    return --[[ () ]]0;
  end else do
    return 0;
  end end 
end end

function occur(env, ty0, ty) do
  old = type_changed.contents;
  xpcall(function() do
    while(type_changed.contents = false, occur_rec(env, --[[ [] ]]0, ty0, ty), type_changed.contents) do
      
    end;
    return merge(type_changed, old);
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    merge(type_changed, old);
    error(exn == Occur and {
        Unify,
        --[[ [] ]]0
      } or exn)
  end end)
end end

function occur_in(env, ty0, t) do
  xpcall(function() do
    occur(env, ty0, t);
    return false;
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      return true;
    end else do
      error(exn)
    end end 
  end end)
end end

function unify_univar(t1, t2, _param) do
  while(true) do
    param = _param;
    if (param) then do
      match = param[0];
      find_univ = function(t, cl) do
        xpcall(function() do
          match = List.find((function(param) do
                  return t == repr(param[0]);
                end end), cl);
          return Caml_option.some(match[1]);
        end end,function(exn) do
          if (exn == Caml_builtin_exceptions.not_found) then do
            return ;
          end else do
            error(exn)
          end end 
        end end)
      end end;
      match_1 = find_univ(t1, match[0]);
      match_2 = find_univ(t2, match[1]);
      if (match_1 ~= undefined) then do
        r1 = match_1;
        match_3 = r1.contents;
        if (match_3 ~= undefined) then do
          if (match_2 ~= undefined) then do
            if (t2 == repr(match_3)) then do
              return --[[ () ]]0;
            end else do
              error({
                Unify,
                --[[ [] ]]0
              })
            end end 
          end else do
            error({
              Unify,
              --[[ [] ]]0
            })
          end end 
        end else if (match_2 ~= undefined) then do
          r2 = match_2;
          match_4 = r2.contents;
          if (match_4 ~= undefined) then do
            error({
              Unify,
              --[[ [] ]]0
            })
          end
           end 
          set_univar(r1, t2);
          return set_univar(r2, t1);
        end else do
          error({
            Unify,
            --[[ [] ]]0
          })
        end end  end 
      end else do
        if (match_2 ~= undefined) then do
          error({
            Unify,
            --[[ [] ]]0
          })
        end
         end 
        _param = param[1];
        ::continue:: ;
      end end 
    end else do
      error({
        Unify,
        --[[ [] ]]0
      })
    end end 
  end;
end end

function occur_univar(env, ty) do
  visited = do
    contents: --[[ Empty ]]0
  end;
  occur_rec = function(_bound, _ty) do
    while(true) do
      ty = _ty;
      bound = _bound;
      ty_1 = repr(ty);
      tmp = false;
      if (ty_1.level >= 0) then do
        tmp_1;
        if (bound and false or true) then do
          ty_1.level = pivot_level - ty_1.level | 0;
          tmp_1 = true;
        end else do
          xpcall(function() do
            bound$prime = find_1(ty_1, visited.contents);
            if (exists((function(bound)do
                  return function (x) do
                    return not mem_3(x, bound);
                  end end
                  end end)(bound), bound$prime)) then do
              visited.contents = add_4(ty_1, inter_2(bound, bound$prime), visited.contents);
              tmp_1 = true;
            end else do
              tmp_1 = false;
            end end 
          end end,function(exn) do
            if (exn == Caml_builtin_exceptions.not_found) then do
              visited.contents = add_4(ty_1, bound, visited.contents);
              tmp_1 = true;
            end else do
              error(exn)
            end end 
          end end)
        end end 
        tmp = tmp_1;
      end
       end 
      if (tmp) then do
        match = ty_1.desc;
        if (typeof match == "number") then do
          return iter_type_expr((function(bound)do
                    return function (param) do
                      return occur_rec(bound, param);
                    end end
                    end end)(bound), ty_1);
        end else do
          local ___conditional___=(match.tag | 0);
          do
             if ___conditional___ == 3--[[ Tconstr ]] then do
                tl = match[1];
                if (tl) then do
                  xpcall(function() do
                    td = find_type_full(match[0], env)[0];
                    return List.iter2((function(bound)do
                              return function (t, v) do
                                if (Curry._2(Types_Variance.mem, --[[ May_pos ]]0, v) or Curry._2(Types_Variance.mem, --[[ May_neg ]]1, v)) then do
                                  return occur_rec(bound, t);
                                end else do
                                  return 0;
                                end end 
                              end end
                              end end)(bound), tl, td.type_variance);
                  end end,function(exn_1) do
                    if (exn_1 == Caml_builtin_exceptions.not_found) then do
                      return List.iter((function(bound)do
                                return function (param) do
                                  return occur_rec(bound, param);
                                end end
                                end end)(bound), tl);
                    end else do
                      error(exn_1)
                    end end 
                  end end)
                end else do
                  return --[[ () ]]0;
                end end  end end 
             if ___conditional___ == 9--[[ Tunivar ]] then do
                if (mem_3(ty_1, bound)) then do
                  return 0;
                end else do
                  error({
                    Unify,
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        ty_1,
                        newty2(100000000, --[[ Tvar ]]Block.__(0, {undefined}))
                      },
                      --[[ [] ]]0
                    }
                  })
                end end  end end 
             if ___conditional___ == 10--[[ Tpoly ]] then do
                bound_1 = List.fold_right(add_3, List.map(repr, match[1]), bound);
                _ty = match[0];
                _bound = bound_1;
                ::continue:: ; end end 
            return iter_type_expr((function(bound)do
                        return function (param) do
                          return occur_rec(bound, param);
                        end end
                        end end)(bound), ty_1);
              
          end
        end end 
      end else do
        return 0;
      end end 
    end;
  end end;
  xpcall(function() do
    occur_rec(--[[ Empty ]]0, ty);
    return unmark_type(ty);
  end end,function(exn) do
    unmark_type(ty);
    error(exn)
  end end)
end end

function add_univars(param, param_1) do
  return List.fold_left((function(s, param) do
                return add_3(repr(param[0]), s);
              end end), param, param_1);
end end

function get_univar_family(univar_pairs, univars) do
  if (univars == --[[ [] ]]0) then do
    return --[[ Empty ]]0;
  end else do
    insert = function(s, param) do
      cl2 = param[1];
      if (cl2 and List.exists((function(param) do
                return mem_3(repr(param[0]), s);
              end end), param[0])) then do
        return add_univars(s, cl2);
      end else do
        return s;
      end end 
    end end;
    s = List.fold_right(add_3, univars, --[[ Empty ]]0);
    return List.fold_left(insert, s, univar_pairs);
  end end 
end end

function univars_escape(env, univar_pairs, vl, ty) do
  family = get_univar_family(univar_pairs, vl);
  visited = do
    contents: --[[ Empty ]]0
  end;
  occur = function(_t) do
    while(true) do
      t = _t;
      t_1 = repr(t);
      if (mem_3(t_1, visited.contents)) then do
        return --[[ () ]]0;
      end else do
        visited.contents = add_3(t_1, visited.contents);
        match = t_1.desc;
        if (typeof match == "number") then do
          return iter_type_expr(occur, t_1);
        end else do
          local ___conditional___=(match.tag | 0);
          do
             if ___conditional___ == 3--[[ Tconstr ]] then do
                tl = match[1];
                if (tl) then do
                  xpcall(function() do
                    td = find_type_full(match[0], env)[0];
                    return List.iter2((function(t, v) do
                                  if (Curry._2(Types_Variance.mem, --[[ May_pos ]]0, v) or Curry._2(Types_Variance.mem, --[[ May_neg ]]1, v)) then do
                                    return occur(t);
                                  end else do
                                    return 0;
                                  end end 
                                end end), tl, td.type_variance);
                  end end,function(exn) do
                    if (exn == Caml_builtin_exceptions.not_found) then do
                      return List.iter(occur, tl);
                    end else do
                      error(exn)
                    end end 
                  end end)
                end else do
                  return --[[ () ]]0;
                end end  end end 
             if ___conditional___ == 9--[[ Tunivar ]] then do
                if (mem_3(t_1, family)) then do
                  error(Occur)
                end else do
                  return 0;
                end end  end end 
             if ___conditional___ == 10--[[ Tpoly ]] then do
                if (List.exists((function(t) do
                          return mem_3(repr(t), family);
                        end end), match[1])) then do
                  return --[[ () ]]0;
                end else do
                  _t = match[0];
                  ::continue:: ;
                end end  end end 
            return iter_type_expr(occur, t_1);
              
          end
        end end 
      end end 
    end;
  end end;
  xpcall(function() do
    occur(ty);
    return false;
  end end,function(exn) do
    if (exn == Occur) then do
      return true;
    end else do
      error(exn)
    end end 
  end end)
end end

function enter_poly(env, univar_pairs, t1, tl1, t2, tl2, f) do
  old_univars = univar_pairs.contents;
  known_univars = List.fold_left((function(s, param) do
          return add_univars(s, param[0]);
        end end), --[[ Empty ]]0, old_univars);
  tl1_1 = List.map(repr, tl1);
  tl2_1 = List.map(repr, tl2);
  if (List.exists((function(t) do
            return mem_3(t, known_univars);
          end end), tl1_1) and univars_escape(env, old_univars, tl1_1, newty2(current_level.contents, --[[ Tpoly ]]Block.__(10, {
                t2,
                tl2_1
              }))) or List.exists((function(t) do
            return mem_3(t, known_univars);
          end end), tl2_1) and univars_escape(env, old_univars, tl2_1, newty2(current_level.contents, --[[ Tpoly ]]Block.__(10, {
                t1,
                tl1_1
              })))) then do
    error({
      Unify,
      --[[ [] ]]0
    })
  end
   end 
  cl1 = List.map((function(t) do
          return --[[ tuple ]]{
                  t,
                  do
                    contents: undefined
                  end
                };
        end end), tl1_1);
  cl2 = List.map((function(t) do
          return --[[ tuple ]]{
                  t,
                  do
                    contents: undefined
                  end
                };
        end end), tl2_1);
  univar_pairs.contents = --[[ :: ]]{
    --[[ tuple ]]{
      cl1,
      cl2
    },
    --[[ :: ]]{
      --[[ tuple ]]{
        cl2,
        cl1
      },
      old_univars
    }
  };
  xpcall(function() do
    res = Curry._2(f, t1, t2);
    univar_pairs.contents = old_univars;
    return res;
  end end,function(exn) do
    univar_pairs.contents = old_univars;
    error(exn)
  end end)
end end

univar_pairs = do
  contents: --[[ [] ]]0
end;

function has_cached_expansion(p, _abbrev) do
  while(true) do
    abbrev = _abbrev;
    if (typeof abbrev == "number") then do
      return false;
    end else if (abbrev.tag) then do
      _abbrev = abbrev[0].contents;
      ::continue:: ;
    end else if (same(p, abbrev[1])) then do
      return true;
    end else do
      _abbrev = abbrev[4];
      ::continue:: ;
    end end  end  end 
  end;
end end

function expand_trace(env, trace) do
  return List.fold_right((function(param, rem) do
                t2 = param[1];
                t1 = param[0];
                return --[[ :: ]]{
                        --[[ tuple ]]{
                          repr(t1),
                          full_expand(env, t1)
                        },
                        --[[ :: ]]{
                          --[[ tuple ]]{
                            repr(t2),
                            full_expand(env, t2)
                          },
                          rem
                        }
                      };
              end end), trace, --[[ [] ]]0);
end end

function mkvariant(fields, closed) do
  return newty2(100000000, --[[ Tvariant ]]Block.__(8, {do
                  row_fields: fields,
                  row_more: newvar(undefined, --[[ () ]]0),
                  row_bound: --[[ () ]]0,
                  row_closed: closed,
                  row_fixed: false,
                  row_name: undefined
                end}));
end end

rigid_variants = do
  contents: false
end;

function deep_occur(t0, ty) do
  occur_rec = function(ty) do
    ty_1 = repr(ty);
    if (ty_1.level >= 0) then do
      if (ty_1 == t0) then do
        error(Occur)
      end
       end 
      ty_1.level = pivot_level - ty_1.level | 0;
      return iter_type_expr(occur_rec, ty_1);
    end else do
      return 0;
    end end 
  end end;
  xpcall(function() do
    occur_rec(ty);
    unmark_type(ty);
    return false;
  end end,function(exn) do
    if (exn == Occur) then do
      unmark_type(ty);
      return true;
    end else do
      error(exn)
    end end 
  end end)
end end

newtype_level = do
  contents: undefined
end;

function get_newtype_level(param) do
  match = newtype_level.contents;
  if (match ~= undefined) then do
    return match;
  end else do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "ctype.ml",
        1949,
        12
      }
    })
  end end 
end end

function reify(env, t) do
  newtype_level = get_newtype_level(--[[ () ]]0);
  create_fresh_constr = function(lev, name) do
    decl = new_declaration(--[[ tuple ]]{
          newtype_level,
          newtype_level
        }, undefined);
    name_1 = get_new_abstract_name(name);
    match = enter_type(name_1, decl, env.contents);
    t = newty2(lev, --[[ Tconstr ]]Block.__(3, {
            --[[ Pident ]]Block.__(0, {match[0]}),
            --[[ [] ]]0,
            do
              contents: --[[ Mnil ]]0
            end
          }));
    env.contents = match[1];
    return t;
  end end;
  visited = do
    contents: --[[ Empty ]]0
  end;
  iterator = function(ty) do
    ty_1 = repr(ty);
    if (mem_3(ty_1, visited.contents)) then do
      return --[[ () ]]0;
    end else do
      visited.contents = add_3(ty_1, visited.contents);
      match = ty_1.desc;
      if (typeof match == "number") then do
        return iter_type_expr(iterator, ty_1);
      end else do
        local ___conditional___=(match.tag | 0);
        do
           if ___conditional___ == 0--[[ Tvar ]] then do
              o = match[0];
              name = o ~= undefined and o or "ex";
              t = create_fresh_constr(ty_1.level, name);
              return link_type(ty_1, t); end end 
           if ___conditional___ == 3--[[ Tconstr ]] then do
              if (is_object_type(match[0])) then do
                return iter_type_expr(iterator, full_expand(env.contents, ty_1));
              end else do
                return iter_type_expr(iterator, ty_1);
              end end  end end 
           if ___conditional___ == 8--[[ Tvariant ]] then do
              r = row_repr_aux(--[[ [] ]]0, match[0]);
              if (not static_row(r)) then do
                if (r.row_fixed) then do
                  iterator(row_more(r));
                end else do
                  m = r.row_more;
                  match_1 = m.desc;
                  if (typeof match_1 == "number") then do
                    error({
                      Caml_builtin_exceptions.assert_failure,
                      --[[ tuple ]]{
                        "ctype.ml",
                        1987,
                        19
                      }
                    })
                  end else if (match_1.tag) then do
                    error({
                      Caml_builtin_exceptions.assert_failure,
                      --[[ tuple ]]{
                        "ctype.ml",
                        1987,
                        19
                      }
                    })
                  end else do
                    o_1 = match_1[0];
                    name_1 = o_1 ~= undefined and o_1 or "ex";
                    t_1 = create_fresh_constr(m.level, name_1);
                    row_row_bound = r.row_bound;
                    row_row_closed = r.row_closed;
                    row_row_name = r.row_name;
                    row = do
                      row_fields: --[[ [] ]]0,
                      row_more: t_1,
                      row_bound: row_row_bound,
                      row_closed: row_row_closed,
                      row_fixed: true,
                      row_name: row_row_name
                    end;
                    link_type(m, newty2(m.level, --[[ Tvariant ]]Block.__(8, {row})));
                  end end  end 
                end end 
              end
               end 
              return iter_row(iterator, r); end end 
          return iter_type_expr(iterator, ty_1);
            
        end
      end end 
    end end 
  end end;
  return iterator(t);
end end

function is_newtype(env, p) do
  xpcall(function() do
    decl = find_type_full(p, env)[0];
    if (decl.type_newtype_level ~= undefined and decl.type_kind == --[[ Type_abstract ]]0) then do
      return decl.type_private == --[[ Public ]]1;
    end else do
      return false;
    end end 
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return false;
    end else do
      error(exn)
    end end 
  end end)
end end

function non_aliasable(p, decl) do
  if (in_current_module(p)) then do
    return decl.type_newtype_level == undefined;
  end else do
    return false;
  end end 
end end

function expands_to_datatype(env, ty) do
  ty_1 = repr(ty);
  match = ty_1.desc;
  if (typeof match == "number" or match.tag ~= --[[ Tconstr ]]3) then do
    return false;
  end else do
    xpcall(function() do
      if (is_datatype(find_type_full(match[0], env)[0])) then do
        return true;
      end else do
        return expands_to_datatype(env, try_expand_once(env, ty_1));
      end end 
    end end,function(exn) do
      if (exn == Caml_builtin_exceptions.not_found or exn == Cannot_expand) then do
        return false;
      end else do
        error(exn)
      end end 
    end end)
  end end 
end end

function mcomp(type_pairs, env, _t1, _t2) do
  while(true) do
    t2 = _t2;
    t1 = _t1;
    if (t1 == t2) then do
      return --[[ () ]]0;
    end else do
      t1_1 = repr(t1);
      t2_1 = repr(t2);
      if (t1_1 == t2_1) then do
        return --[[ () ]]0;
      end else do
        match = t1_1.desc;
        match_1 = t2_1.desc;
        exit = 0;
        exit_1 = 0;
        if (typeof match == "number") then do
          exit_1 = 2;
        end else do
          local ___conditional___=(match.tag | 0);
          do
             if ___conditional___ == 0--[[ Tvar ]] then do
                return --[[ () ]]0; end end 
             if ___conditional___ == 3--[[ Tconstr ]] then do
                if (match[1]) then do
                  exit_1 = 2;
                end else if (typeof match_1 == "number") then do
                  exit = 1;
                end else do
                  local ___conditional___=(match_1.tag | 0);
                  do
                     if ___conditional___ == 0--[[ Tvar ]] then do
                        exit_1 = 2; end else 
                     if ___conditional___ == 3--[[ Tconstr ]] then do
                        if (match_1[1] or not same(match[0], match_1[0])) then do
                          exit = 1;
                        end else do
                          return --[[ () ]]0;
                        end end  end else 
                     end end end end
                    exit = 1;
                      
                  end
                end end  end  end else 
             end end
            exit_1 = 2;
              
          end
        end end 
        if (exit_1 == 2) then do
          if (typeof match_1 == "number" or match_1.tag) then do
            exit = 1;
          end else do
            return --[[ () ]]0;
          end end 
        end
         end 
        if (exit == 1) then do
          t1$prime = expand_head_opt(env, t1_1);
          t2$prime = expand_head_opt(env, t2_1);
          t1$prime_1 = repr(t1$prime);
          t2$prime_1 = repr(t2$prime);
          if (t1$prime_1 == t2$prime_1) then do
            return --[[ () ]]0;
          end else do
            xpcall(function() do
              return Curry._2(TypePairs.find, type_pairs, --[[ tuple ]]{
                          t1$prime_1,
                          t2$prime_1
                        });
            end end,function(exn) do
              if (exn == Caml_builtin_exceptions.not_found) then do
                Curry._3(TypePairs.add, type_pairs, --[[ tuple ]]{
                      t1$prime_1,
                      t2$prime_1
                    }, --[[ () ]]0);
                match_2 = t1$prime_1.desc;
                match_3 = t2$prime_1.desc;
                p;
                exit_2 = 0;
                if (typeof match_2 == "number") then do
                  if (typeof match_3 == "number") then do
                    return --[[ () ]]0;
                  end else if (match_3.tag == --[[ Tconstr ]]3) then do
                    exit_2 = 3;
                  end else do
                    error({
                      Unify,
                      --[[ [] ]]0
                    })
                  end end  end 
                end else do
                  local ___conditional___=(match_2.tag | 0);
                  do
                     if ___conditional___ == 0--[[ Tvar ]] then do
                        if (typeof match_3 == "number") then do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end else do
                          local ___conditional___=(match_3.tag | 0);
                          do
                             if ___conditional___ == 0--[[ Tvar ]] then do
                                error({
                                  Caml_builtin_exceptions.assert_failure,
                                  --[[ tuple ]]{
                                    "ctype.ml",
                                    2051,
                                    30
                                  }
                                }) end end 
                             if ___conditional___ == 3--[[ Tconstr ]] then do
                                exit_2 = 3; end else 
                             end end
                            error({
                                Unify,
                                --[[ [] ]]0
                              })
                              
                          end
                        end end  end else 
                     if ___conditional___ == 1--[[ Tarrow ]] then do
                        l1 = match_2[0];
                        if (typeof match_3 == "number") then do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end else do
                          local ___conditional___=(match_3.tag | 0);
                          do
                             if ___conditional___ == 1--[[ Tarrow ]] then do
                                l2 = match_3[0];
                                if (l1 == l2 or not (is_optional(l1) or is_optional(l2))) then do
                                  mcomp(type_pairs, env, match_2[1], match_3[1]);
                                  _t2 = match_3[2];
                                  _t1 = match_2[2];
                                  ::continue:: ;
                                end else do
                                  error({
                                    Unify,
                                    --[[ [] ]]0
                                  })
                                end end  end end 
                             if ___conditional___ == 3--[[ Tconstr ]] then do
                                exit_2 = 3; end else 
                             end end
                            error({
                                Unify,
                                --[[ [] ]]0
                              })
                              
                          end
                        end end  end else 
                     if ___conditional___ == 2--[[ Ttuple ]] then do
                        if (typeof match_3 == "number") then do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end else do
                          local ___conditional___=(match_3.tag | 0);
                          do
                             if ___conditional___ == 2--[[ Ttuple ]] then do
                                return mcomp_list(type_pairs, env, match_2[0], match_3[0]); end end 
                             if ___conditional___ == 3--[[ Tconstr ]] then do
                                exit_2 = 3; end else 
                             end end
                            error({
                                Unify,
                                --[[ [] ]]0
                              })
                              
                          end
                        end end  end else 
                     if ___conditional___ == 3--[[ Tconstr ]] then do
                        p1 = match_2[0];
                        if (typeof match_3 == "number" or match_3.tag ~= --[[ Tconstr ]]3) then do
                          p = p1;
                        end else do
                          type_pairs_1 = type_pairs;
                          env_1 = env;
                          p1_1 = p1;
                          p2 = match_3[0];
                          tl1 = match_2[1];
                          tl2 = match_3[1];
                          xpcall(function() do
                            decl = find_type_full(p1_1, env_1)[0];
                            decl$prime = find_type_full(p2, env_1)[0];
                            if (same(p1_1, p2)) then do
                              inj;
                              xpcall(function() do
                                inj = List.map(Curry._1(Types_Variance.mem, --[[ Inj ]]3), find_type_full(p1_1, env_1)[0].type_variance);
                              end end,function(exn_1) do
                                if (exn_1 == Caml_builtin_exceptions.not_found) then do
                                  inj = List.map((function(param) do
                                          return false;
                                        end end), tl1);
                                end else do
                                  error(exn_1)
                                end end 
                              end end)
                              return List.iter2((function(type_pairs_1,env_1)do
                                        return function (i, param) do
                                          if (i) then do
                                            return mcomp(type_pairs_1, env_1, param[0], param[1]);
                                          end else do
                                            return 0;
                                          end end 
                                        end end
                                        end end)(type_pairs_1,env_1), inj, List.combine(tl1, tl2));
                            end else do
                              if (non_aliasable(p1_1, decl) and non_aliasable(p2, decl$prime)) then do
                                error({
                                  Unify,
                                  --[[ [] ]]0
                                })
                              end
                               end 
                              match_4 = decl.type_kind;
                              match_5 = decl$prime.type_kind;
                              exit_3 = 0;
                              if (typeof match_4 == "number") then do
                                if (match_4 == --[[ Type_abstract ]]0) then do
                                  exit_4 = 0;
                                  if (typeof match_5 == "number" and match_5 == 0) then do
                                    return --[[ () ]]0;
                                  end else do
                                    exit_4 = 2;
                                  end end 
                                  if (exit_4 == 2) then do
                                    if (non_aliasable(p1_1, decl)) then do
                                      exit_3 = 1;
                                    end else do
                                      return --[[ () ]]0;
                                    end end 
                                  end
                                   end 
                                end else if (typeof match_5 == "number") then do
                                  if (match_5 ~= 0) then do
                                    return mcomp_list(type_pairs_1, env_1, tl1, tl2);
                                  end else do
                                    exit_3 = 1;
                                  end end 
                                end else do
                                  error({
                                    Unify,
                                    --[[ [] ]]0
                                  })
                                end end  end 
                              end else if (match_4.tag) then do
                                if (typeof match_5 == "number") then do
                                  if (match_5 == --[[ Type_abstract ]]0) then do
                                    exit_3 = 1;
                                  end else do
                                    error({
                                      Unify,
                                      --[[ [] ]]0
                                    })
                                  end end 
                                end else if (match_5.tag) then do
                                  mcomp_list(type_pairs_1, env_1, tl1, tl2);
                                  type_pairs_2 = type_pairs_1;
                                  env_2 = env_1;
                                  xs = match_4[0];
                                  ys = match_5[0];
                                  _x = xs;
                                  _y = ys;
                                  while(true) do
                                    y = _y;
                                    x = _x;
                                    if (x) then do
                                      if (y) then do
                                        c2 = y[0];
                                        c1 = x[0];
                                        mcomp_type_option(type_pairs_2, env_2, c1.cd_res, c2.cd_res);
                                        mcomp_list(type_pairs_2, env_2, c1.cd_args, c2.cd_args);
                                        if (c1.cd_id.name == c2.cd_id.name) then do
                                          _y = y[1];
                                          _x = x[1];
                                          ::continue:: ;
                                        end else do
                                          error({
                                            Unify,
                                            --[[ [] ]]0
                                          })
                                        end end 
                                      end else do
                                        error({
                                          Unify,
                                          --[[ [] ]]0
                                        })
                                      end end 
                                    end else if (y) then do
                                      error({
                                        Unify,
                                        --[[ [] ]]0
                                      })
                                    end else do
                                      return --[[ () ]]0;
                                    end end  end 
                                  end;
                                end else do
                                  error({
                                    Unify,
                                    --[[ [] ]]0
                                  })
                                end end  end 
                              end else if (typeof match_5 == "number") then do
                                if (match_5 == --[[ Type_abstract ]]0) then do
                                  exit_3 = 1;
                                end else do
                                  error({
                                    Unify,
                                    --[[ [] ]]0
                                  })
                                end end 
                              end else if (match_5.tag) then do
                                error({
                                  Unify,
                                  --[[ [] ]]0
                                })
                              end else if (match_4[1] == match_5[1]) then do
                                mcomp_list(type_pairs_1, env_1, tl1, tl2);
                                return mcomp_record_description(type_pairs_1, env_1)(match_4[0], match_5[0]);
                              end else do
                                error({
                                  Unify,
                                  --[[ [] ]]0
                                })
                              end end  end  end  end  end 
                              if (exit_3 == 1) then do
                                if (typeof match_5 == "number") then do
                                  if (match_5 ~= 0) then do
                                    error({
                                      Unify,
                                      --[[ [] ]]0
                                    })
                                  end
                                   end 
                                  if (non_aliasable(p2, decl$prime)) then do
                                    error({
                                      Unify,
                                      --[[ [] ]]0
                                    })
                                  end else do
                                    return --[[ () ]]0;
                                  end end 
                                end else do
                                  error({
                                    Unify,
                                    --[[ [] ]]0
                                  })
                                end end 
                              end
                               end 
                            end end 
                          end end,function(exn_2) do
                            if (exn_2 == Caml_builtin_exceptions.not_found) then do
                              return --[[ () ]]0;
                            end else do
                              error(exn_2)
                            end end 
                          end end)
                        end end  end else 
                     if ___conditional___ == 4--[[ Tobject ]] then do
                        if (typeof match_3 == "number") then do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end else do
                          local ___conditional___=(match_3.tag | 0);
                          do
                             if ___conditional___ == 3--[[ Tconstr ]] then do
                                exit_2 = 3; end else 
                             if ___conditional___ == 4--[[ Tobject ]] then do
                                return mcomp_fields(type_pairs, env, match_2[0], match_3[0]); end end end end 
                            error({
                                Unify,
                                --[[ [] ]]0
                              })
                              
                          end
                        end end  end else 
                     if ___conditional___ == 5--[[ Tfield ]] then do
                        if (typeof match_3 == "number") then do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end else do
                          local ___conditional___=(match_3.tag | 0);
                          do
                             if ___conditional___ == 3--[[ Tconstr ]] then do
                                exit_2 = 3; end else 
                             if ___conditional___ == 5--[[ Tfield ]] then do
                                return mcomp_fields(type_pairs, env, t1$prime_1, t2$prime_1); end end end end 
                            error({
                                Unify,
                                --[[ [] ]]0
                              })
                              
                          end
                        end end  end else 
                     if ___conditional___ == 6--[[ Tlink ]]
                     or ___conditional___ == 7--[[ Tsubst ]] then do
                        exit_2 = 3; end else 
                     if ___conditional___ == 8--[[ Tvariant ]] then do
                        if (typeof match_3 == "number") then do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end else do
                          local ___conditional___=(match_3.tag | 0);
                          do
                             if ___conditional___ == 3--[[ Tconstr ]] then do
                                exit_2 = 3; end else 
                             if ___conditional___ == 8--[[ Tvariant ]] then do
                                type_pairs_3 = type_pairs;
                                env_3 = env;
                                row1 = match_2[0];
                                row2 = match_3[0];
                                row1_1 = row_repr_aux(--[[ [] ]]0, row1);
                                row2_1 = row_repr_aux(--[[ [] ]]0, row2);
                                match_6 = merge_row_fields(row1_1.row_fields, row2_1.row_fields);
                                cannot_erase = function(param) do
                                  match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                                  if (typeof match == "number" or match.tag) then do
                                    return false;
                                  end else do
                                    return true;
                                  end end 
                                end end;
                                if (row1_1.row_closed and List.exists(cannot_erase, match_6[1]) or row2_1.row_closed and List.exists(cannot_erase, match_6[0])) then do
                                  error({
                                    Unify,
                                    --[[ [] ]]0
                                  })
                                end
                                 end 
                                return List.iter((function(type_pairs_3,env_3)do
                                          return function (param) do
                                            match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                                            match_1 = row_field_repr_aux(--[[ [] ]]0, param[2]);
                                            exit = 0;
                                            exit_1 = 0;
                                            if (typeof match == "number") then do
                                              exit_1 = 2;
                                            end else if (match.tag) then do
                                              exit_2 = 0;
                                              if (match[0] or typeof match_1 == "number" or match_1.tag) then do
                                                exit_2 = 3;
                                              end else do
                                                match_2 = match_1[0];
                                                if (match_2 ~= undefined) then do
                                                  t2 = match_2;
                                                  return List.iter((function(param) do
                                                                return mcomp(type_pairs_3, env_3, t2, param);
                                                              end end), match[1]);
                                                end else do
                                                  exit_2 = 3;
                                                end end 
                                              end end 
                                              if (exit_2 == 3) then do
                                                if (match[1]) then do
                                                  exit_1 = 2;
                                                end else do
                                                  exit = 1;
                                                end end 
                                              end
                                               end 
                                            end else do
                                              match_3 = match[0];
                                              if (match_3 ~= undefined) then do
                                                t1 = match_3;
                                                if (typeof match_1 == "number") then do
                                                  error({
                                                    Unify,
                                                    --[[ [] ]]0
                                                  })
                                                end else if (match_1.tag) then do
                                                  if (match_1[0]) then do
                                                    error({
                                                      Unify,
                                                      --[[ [] ]]0
                                                    })
                                                  end
                                                   end 
                                                  return List.iter((function(param) do
                                                                return mcomp(type_pairs_3, env_3, t1, param);
                                                              end end), match_1[1]);
                                                end else do
                                                  match_4 = match_1[0];
                                                  if (match_4 ~= undefined) then do
                                                    return mcomp(type_pairs_3, env_3, t1, match_4);
                                                  end else do
                                                    error({
                                                      Unify,
                                                      --[[ [] ]]0
                                                    })
                                                  end end 
                                                end end  end 
                                              end else if (typeof match_1 == "number") then do
                                                error({
                                                  Unify,
                                                  --[[ [] ]]0
                                                })
                                              end else if (match_1.tag) then do
                                                if (match_1[1]) then do
                                                  error({
                                                    Unify,
                                                    --[[ [] ]]0
                                                  })
                                                end else do
                                                  return --[[ () ]]0;
                                                end end 
                                              end else if (match_1[0] ~= undefined) then do
                                                error({
                                                  Unify,
                                                  --[[ [] ]]0
                                                })
                                              end else do
                                                return --[[ () ]]0;
                                              end end  end  end  end 
                                            end end  end 
                                            if (exit_1 == 2) then do
                                              if (typeof match_1 == "number" or match_1.tag) then do
                                                return --[[ () ]]0;
                                              end else if (match_1[0] ~= undefined) then do
                                                exit = 1;
                                              end else do
                                                error({
                                                  Unify,
                                                  --[[ [] ]]0
                                                })
                                              end end  end 
                                            end
                                             end 
                                            if (exit == 1) then do
                                              if (typeof match ~= "number" and not match[0]) then do
                                                return --[[ () ]]0;
                                              end
                                               end 
                                              if (typeof match_1 == "number" or match_1.tag or match_1[0] == undefined) then do
                                                return --[[ () ]]0;
                                              end else do
                                                error({
                                                  Unify,
                                                  --[[ [] ]]0
                                                })
                                              end end 
                                            end
                                             end 
                                          end end
                                          end end)(type_pairs_3,env_3), match_6[2]); end end end end 
                            error({
                                Unify,
                                --[[ [] ]]0
                              })
                              
                          end
                        end end  end else 
                     if ___conditional___ == 9--[[ Tunivar ]] then do
                        if (typeof match_3 == "number") then do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end else do
                          local ___conditional___=(match_3.tag | 0);
                          do
                             if ___conditional___ == 3--[[ Tconstr ]] then do
                                exit_2 = 3; end else 
                             if ___conditional___ == 9--[[ Tunivar ]] then do
                                return unify_univar(t1$prime_1, t2$prime_1, univar_pairs.contents); end end end end 
                            error({
                                Unify,
                                --[[ [] ]]0
                              })
                              
                          end
                        end end  end else 
                     if ___conditional___ == 10--[[ Tpoly ]] then do
                        tl1_1 = match_2[1];
                        t1_2 = match_2[0];
                        exit_5 = 0;
                        if (tl1_1) then do
                          exit_5 = 4;
                        end else if (typeof match_3 == "number") then do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end else do
                          local ___conditional___=(match_3.tag | 0);
                          do
                             if ___conditional___ == 3--[[ Tconstr ]] then do
                                exit_2 = 3; end else 
                             if ___conditional___ == 10--[[ Tpoly ]] then do
                                if (match_3[1]) then do
                                  exit_5 = 4;
                                end else do
                                  _t2 = match_3[0];
                                  _t1 = t1_2;
                                  ::continue:: ;
                                end end  end else 
                             end end end end
                            error({
                                Unify,
                                --[[ [] ]]0
                              })
                              
                          end
                        end end  end 
                        if (exit_5 == 4) then do
                          if (typeof match_3 == "number") then do
                            error({
                              Unify,
                              --[[ [] ]]0
                            })
                          end else do
                            local ___conditional___=(match_3.tag | 0);
                            do
                               if ___conditional___ == 3--[[ Tconstr ]] then do
                                  exit_2 = 3; end else 
                               if ___conditional___ == 10--[[ Tpoly ]] then do
                                  return enter_poly(env, univar_pairs, t1_2, tl1_1, match_3[0], match_3[1], (function(param, param_1) do
                                                return mcomp(type_pairs, env, param, param_1);
                                              end end)); end end end end 
                              error({
                                  Unify,
                                  --[[ [] ]]0
                                })
                                
                            end
                          end end 
                        end
                         end  end else 
                     if ___conditional___ == 11--[[ Tpackage ]] then do
                        if (typeof match_3 == "number") then do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end else do
                          local ___conditional___=(match_3.tag | 0);
                          do
                             if ___conditional___ == 3--[[ Tconstr ]] then do
                                exit_2 = 3; end else 
                             if ___conditional___ == 11--[[ Tpackage ]] then do
                                return --[[ () ]]0; end end end end 
                            error({
                                Unify,
                                --[[ [] ]]0
                              })
                              
                          end
                        end end  end else 
                     end end end end end end end end end end end end end end end end end end end end end end
                    
                  end
                end end 
                if (exit_2 == 3) then do
                  if (typeof match_3 == "number") then do
                    error({
                      Unify,
                      --[[ [] ]]0
                    })
                  end else if (match_3.tag == --[[ Tconstr ]]3) then do
                    p = match_3[0];
                  end else do
                    error({
                      Unify,
                      --[[ [] ]]0
                    })
                  end end  end 
                end
                 end 
                xpcall(function() do
                  decl_1 = find_type_full(p, env)[0];
                  if (non_aliasable(p, decl_1) or is_datatype(decl_1)) then do
                    error({
                      Unify,
                      --[[ [] ]]0
                    })
                  end else do
                    return 0;
                  end end 
                end end,function(exn_3) do
                  if (exn_3 == Caml_builtin_exceptions.not_found) then do
                    return --[[ () ]]0;
                  end else do
                    error(exn_3)
                  end end 
                end end)
              end else do
                error(exn)
              end end 
            end end)
          end end 
        end
         end 
      end end 
    end end 
  end;
end end

function mcomp_list(type_pairs, env, tl1, tl2) do
  if (List.length(tl1) ~= List.length(tl2)) then do
    error({
      Unify,
      --[[ [] ]]0
    })
  end
   end 
  return List.iter2((function(param, param_1) do
                return mcomp(type_pairs, env, param, param_1);
              end end), tl1, tl2);
end end

function mcomp_fields(type_pairs, env, ty1, ty2) do
  if (not (concrete_object(ty1) and concrete_object(ty2))) then do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "ctype.ml",
        2096,
        59
      }
    })
  end
   end 
  match = flatten_fields(ty2);
  match_1 = flatten_fields(ty1);
  match_2 = associate_fields(match_1[0], match[0]);
  mcomp(type_pairs, env, match_1[1], match[1]);
  if (match_2[1] ~= --[[ [] ]]0 and object_row(ty1).desc == --[[ Tnil ]]0 or match_2[2] ~= --[[ [] ]]0 and object_row(ty2).desc == --[[ Tnil ]]0) then do
    error({
      Unify,
      --[[ [] ]]0
    })
  end
   end 
  return List.iter((function(param) do
                mcomp_kind(param[1], param[3]);
                return mcomp(type_pairs, env, param[2], param[4]);
              end end), match_2[0]);
end end

function mcomp_kind(k1, k2) do
  k1_1 = field_kind_repr(k1);
  k2_1 = field_kind_repr(k2);
  if (typeof k1_1 == "number") then do
    if (k1_1 ~= 0) then do
      error({
        Unify,
        --[[ [] ]]0
      })
    end
     end 
    if (typeof k2_1 == "number") then do
      if (k2_1 ~= 0) then do
        error({
          Unify,
          --[[ [] ]]0
        })
      end else do
        return --[[ () ]]0;
      end end 
    end else do
      error({
        Unify,
        --[[ [] ]]0
      })
    end end 
  end else do
    if (typeof k2_1 == "number") then do
      error({
        Unify,
        --[[ [] ]]0
      })
    end
     end 
    return --[[ () ]]0;
  end end 
end end

function mcomp_type_option(type_pairs, env, t, t$prime) do
  if (t ~= undefined) then do
    if (t$prime ~= undefined) then do
      return mcomp(type_pairs, env, t, t$prime);
    end else do
      error({
        Unify,
        --[[ [] ]]0
      })
    end end 
  end else if (t$prime ~= undefined) then do
    error({
      Unify,
      --[[ [] ]]0
    })
  end else do
    return --[[ () ]]0;
  end end  end 
end end

function mcomp_record_description(type_pairs, env) do
  iter = function(_x, _y) do
    while(true) do
      y = _y;
      x = _x;
      if (x) then do
        if (y) then do
          l2 = y[0];
          l1 = x[0];
          mcomp(type_pairs, env, l1.ld_type, l2.ld_type);
          if (l1.ld_id.name == l2.ld_id.name and l1.ld_mutable == l2.ld_mutable) then do
            _y = y[1];
            _x = x[1];
            ::continue:: ;
          end else do
            error({
              Unify,
              --[[ [] ]]0
            })
          end end 
        end else do
          error({
            Unify,
            --[[ [] ]]0
          })
        end end 
      end else if (y) then do
        error({
          Unify,
          --[[ [] ]]0
        })
      end else do
        return --[[ () ]]0;
      end end  end 
    end;
  end end;
  return iter;
end end

function mcomp_1(env, t1, t2) do
  return mcomp(Curry._1(TypePairs.create, 4), env, t1, t2);
end end

function find_lowest_level(ty) do
  lowest = do
    contents: 100000000
  end;
  find = function(ty) do
    ty_1 = repr(ty);
    if (ty_1.level >= 0) then do
      if (ty_1.level < lowest.contents) then do
        lowest.contents = ty_1.level;
      end
       end 
      ty_1.level = pivot_level - ty_1.level | 0;
      return iter_type_expr(find, ty_1);
    end else do
      return 0;
    end end 
  end end;
  find(ty);
  unmark_type(ty);
  return lowest.contents;
end end

function find_newtype_level(env, path) do
  xpcall(function() do
    match = find_type_full(path, env)[0].type_newtype_level;
    if (match ~= undefined) then do
      return match;
    end else do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "ctype.ml",
          2227,
          12
        }
      })
    end end 
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "ctype.ml",
          2228,
          20
        }
      })
    end
     end 
    error(exn)
  end end)
end end

function add_gadt_equation(env, source, destination) do
  destination_1 = type_expr(identity, destination);
  source_lev = find_newtype_level(env.contents, --[[ Pident ]]Block.__(0, {source}));
  decl = new_declaration(source_lev, destination_1);
  newtype_level = get_newtype_level(--[[ () ]]0);
  env.contents = add_local_constraint(source, decl, newtype_level, env.contents);
  return cleanup_abbrev(--[[ () ]]0);
end end

unify_eq_set = Curry._1(TypePairs.create, 11);

function order_type_pair(t1, t2) do
  if (t1.id <= t2.id) then do
    return --[[ tuple ]]{
            t1,
            t2
          };
  end else do
    return --[[ tuple ]]{
            t2,
            t1
          };
  end end 
end end

function add_type_equality(t1, t2) do
  return Curry._3(TypePairs.add, unify_eq_set, order_type_pair(t1, t2), --[[ () ]]0);
end end

function eq_package_path(env, p1, p2) do
  if (same(p1, p2)) then do
    return true;
  end else do
    return same(normalize_package_path(env, p1), normalize_package_path(env, p2));
  end end 
end end

nondep_type$prime = do
  contents: (function(param, param_1, param_2) do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "ctype.ml",
          2250,
          37
        }
      })
    end end)
end;

package_subtype = do
  contents: (function(param, param_1, param_2, param_3, param_4, param_5, param_6) do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "ctype.ml",
          2251,
          48
        }
      })
    end end)
end;

function concat_longident(lid1, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Lident ]] then do
        return --[[ Ldot ]]Block.__(1, {
                  lid1,
                  param[0]
                }); end end 
     if ___conditional___ == 1--[[ Ldot ]] then do
        return --[[ Ldot ]]Block.__(1, {
                  concat_longident(lid1, param[0]),
                  param[1]
                }); end end 
     if ___conditional___ == 2--[[ Lapply ]] then do
        return --[[ Lapply ]]Block.__(2, {
                  concat_longident(lid1, param[0]),
                  param[1]
                }); end end 
    
  end
end end

function nondep_instance(env, level, id, ty) do
  ty_1 = Curry._3(nondep_type$prime.contents, env, id, ty);
  if (level == 100000000) then do
    return type_expr(identity, ty_1);
  end else do
    old = current_level.contents;
    current_level.contents = level;
    ty_2 = instance(undefined, env, ty_1);
    current_level.contents = old;
    return ty_2;
  end end 
end end

function complete_type_list(allow_absentOpt, env, nl1, lv2, mty2, nl2, tl2) do
  allow_absent = allow_absentOpt ~= undefined and allow_absentOpt or false;
  id2 = create("Pkg");
  env$prime = add_module_1(undefined, id2, mty2, env);
  complete = function(_nl1, ntl2) do
    while(true) do
      nl1 = _nl1;
      if (nl1) then do
        nl = nl1[1];
        n = nl1[0];
        exit = 0;
        if (ntl2) then do
          nt2 = ntl2[0];
          n2 = nt2[0];
          if (Caml_obj.caml_greaterequal(n, n2)) then do
            return --[[ :: ]]{
                    nt2,
                    complete(Caml_obj.caml_equal(n, n2) and nl or nl1, ntl2[1])
                  };
          end else do
            exit = 1;
          end end 
        end else do
          exit = 1;
        end end 
        if (exit == 1) then do
          xpcall(function() do
            match = lookup_type_1(concat_longident(--[[ Lident ]]Block.__(0, {"Pkg"}), n), env$prime);
            decl = match[1];
            if (decl.type_arity ~= 0) then do
              error(Pervasives.Exit)
            end
             end 
            match_1 = decl.type_kind;
            if (typeof match_1 == "number") then do
              if (match_1 ~= 0) then do
                error(Pervasives.Exit)
              end
               end 
              if (decl.type_private) then do
                match_2 = decl.type_manifest;
                if (match_2 ~= undefined) then do
                  return --[[ :: ]]{
                          --[[ tuple ]]{
                            n,
                            nondep_instance(env$prime, lv2, id2, match_2)
                          },
                          complete(nl, ntl2)
                        };
                end else if (allow_absent) then do
                  return complete(nl, ntl2);
                end else do
                  error(Pervasives.Exit)
                end end  end 
              end else do
                error(Pervasives.Exit)
              end end 
            end else do
              error(Pervasives.Exit)
            end end 
          end end,function(exn) do
            if (exn == Caml_builtin_exceptions.not_found and allow_absent) then do
              _nl1 = nl;
              ::continue:: ;
            end
             end 
            if (exn == Pervasives.Exit) then do
              error(Caml_builtin_exceptions.not_found)
            end
             end 
            error(exn)
          end end)
        end
         end 
      end else do
        return ntl2;
      end end 
    end;
  end end;
  return complete(nl1, List.combine(nl2, tl2));
end end

function unify_package(env, unify_list, lv1, p1, n1, tl1, lv2, p2, n2, tl2) do
  ntl2 = complete_type_list(undefined, env, n1, lv2, --[[ Mty_ident ]]Block.__(0, {p2}), n2, tl2);
  ntl1 = complete_type_list(undefined, env, n2, lv2, --[[ Mty_ident ]]Block.__(0, {p1}), n1, tl1);
  Curry._2(unify_list, List.map((function(prim) do
              return prim[1];
            end end), ntl1), List.map((function(prim) do
              return prim[1];
            end end), ntl2));
  if (eq_package_path(env, p1, p2) or Curry._7(package_subtype.contents, env, p1, n1, tl1, p2, n2, tl2) and Curry._7(package_subtype.contents, env, p2, n2, tl2, p1, n1, tl1)) then do
    return --[[ () ]]0;
  end else do
    error(Caml_builtin_exceptions.not_found)
  end end 
end end

function unify_eq(env, t1, t2) do
  if (t1 == t2) then do
    return true;
  end else do
    match = umode.contents;
    if (match) then do
      xpcall(function() do
        Curry._2(TypePairs.find, unify_eq_set, order_type_pair(t1, t2));
        return true;
      end end,function(exn) do
        if (exn == Caml_builtin_exceptions.not_found) then do
          return false;
        end else do
          error(exn)
        end end 
      end end)
    end else do
      return false;
    end end 
  end end 
end end

function unify(env, t1, t2) do
  if (t1 == t2) then do
    return --[[ () ]]0;
  end else do
    t1_1 = repr(t1);
    t2_1 = repr(t2);
    if (unify_eq(env.contents, t1_1, t2_1)) then do
      return --[[ () ]]0;
    end else do
      reset_tracing = check_trace_gadt_instances(env.contents);
      xpcall(function() do
        type_changed.contents = true;
        match = t1_1.desc;
        match_1 = t2_1.desc;
        exit = 0;
        if (typeof match == "number") then do
          exit = 1;
        end else do
          local ___conditional___=(match.tag | 0);
          do
             if ___conditional___ == 0--[[ Tvar ]] then do
                exit_1 = 0;
                if (typeof match_1 == "number" or not (match_1.tag == --[[ Tconstr ]]3 and deep_occur(t1_1, t2_1))) then do
                  exit_1 = 2;
                end else do
                  unify2(env, t1_1, t2_1);
                end end 
                if (exit_1 == 2) then do
                  occur(env.contents, t1_1, t2_1);
                  occur_univar(env.contents, t2_1);
                  link_type(t1_1, t2_1);
                  update_level(env.contents, t1_1.level, t2_1);
                end
                 end  end else 
             if ___conditional___ == 3--[[ Tconstr ]] then do
                p1 = match[0];
                if (typeof match_1 == "number") then do
                  unify2(env, t1_1, t2_1);
                end else do
                  local ___conditional___=(match_1.tag | 0);
                  do
                     if ___conditional___ == 0--[[ Tvar ]] then do
                        if (deep_occur(t2_1, t1_1)) then do
                          unify2(env, t1_1, t2_1);
                        end else do
                          exit = 1;
                        end end  end else 
                     if ___conditional___ == 3--[[ Tconstr ]] then do
                        if (match[1] or match_1[1]) then do
                          unify2(env, t1_1, t2_1);
                        end else do
                          p2 = match_1[0];
                          if (same(p1, p2) and not (has_cached_expansion(p1, match[2].contents) or has_cached_expansion(p2, match_1[2].contents))) then do
                            update_level(env.contents, t1_1.level, t2_1);
                            link_type(t1_1, t2_1);
                          end else if (env.contents.local_constraints and is_newtype(env.contents, p1) and is_newtype(env.contents, p2)) then do
                            xpcall(function() do
                              if (Caml_obj.caml_lessthan(find_newtype_level(env.contents, p1), find_newtype_level(env.contents, p2))) then do
                                unify(env, t1_1, try_expand_once(env.contents, t2_1));
                              end else do
                                unify(env, try_expand_once(env.contents, t1_1), t2_1);
                              end end 
                            end end,function(exn) do
                              if (exn == Cannot_expand) then do
                                unify2(env, t1_1, t2_1);
                              end else do
                                error(exn)
                              end end 
                            end end)
                          end else do
                            unify2(env, t1_1, t2_1);
                          end end  end 
                        end end  end else 
                     end end end end
                    unify2(env, t1_1, t2_1);
                      
                  end
                end end  end else 
             if ___conditional___ == 9--[[ Tunivar ]] then do
                if (typeof match_1 == "number") then do
                  unify2(env, t1_1, t2_1);
                end else do
                  local ___conditional___=(match_1.tag | 0);
                  do
                     if ___conditional___ == 0--[[ Tvar ]] then do
                        exit = 1; end else 
                     if ___conditional___ == 9--[[ Tunivar ]] then do
                        unify_univar(t1_1, t2_1, univar_pairs.contents);
                        update_level(env.contents, t1_1.level, t2_1);
                        link_type(t1_1, t2_1); end else 
                     end end end end
                    unify2(env, t1_1, t2_1);
                      
                  end
                end end  end else 
             end end end end end end
            exit = 1;
              
          end
        end end 
        if (exit == 1) then do
          if (typeof match_1 == "number" or match_1.tag) then do
            unify2(env, t1_1, t2_1);
          end else do
            occur(env.contents, t2_1, t1_1);
            occur_univar(env.contents, t1_1);
            link_type(t2_1, t1_1);
            update_level(env.contents, t2_1.level, t1_1);
          end end 
        end
         end 
        return reset_trace_gadt_instances(reset_tracing);
      end end,function(raw_exn) do
        exn_1 = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn_1[0] == Unify) then do
          reset_trace_gadt_instances(reset_tracing);
          error({
            Unify,
            --[[ :: ]]{
              --[[ tuple ]]{
                t1_1,
                t2_1
              },
              exn_1[1]
            }
          })
        end else do
          error(exn_1)
        end end 
      end end)
    end end 
  end end 
end end

function unify_kind(k1, k2) do
  k1_1 = field_kind_repr(k1);
  k2_1 = field_kind_repr(k2);
  if (k1_1 == k2_1) then do
    return --[[ () ]]0;
  end else do
    if (typeof k1_1 == "number") then do
      if (k1_1 == 0) then do
        if (typeof k2_1 == "number") then do
          if (k2_1 == 0) then do
            return --[[ () ]]0;
          end
           end 
        end else do
          return set_kind(k2_1[0], k1_1);
        end end 
      end
       end 
    end else do
      r = k1_1[0];
      if (not (typeof k2_1 == "number" and k2_1 ~= 0)) then do
        return set_kind(r, k2_1);
      end
       end 
    end end 
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "ctype.ml",
        2624,
        37
      }
    })
  end end 
end end

function make_rowvar(level, use1, rest1, use2, rest2) do
  set_name = function(ty, name) do
    match = ty.desc;
    if (typeof match == "number" or match.tag or match[0] ~= undefined) then do
      return --[[ () ]]0;
    end else do
      log_type(ty);
      ty.desc = --[[ Tvar ]]Block.__(0, {name});
      return --[[ () ]]0;
    end end 
  end end;
  match = rest1.desc;
  match_1 = rest2.desc;
  name;
  exit = 0;
  if (typeof match == "number" or match.tag) then do
    exit = 1;
  end else do
    name1 = match[0];
    if (name1 ~= undefined) then do
      exit_1 = 0;
      if (typeof match_1 == "number" or match_1.tag) then do
        exit_1 = 2;
      end else do
        name2 = match_1[0];
        if (name2 ~= undefined) then do
          name = rest1.level <= rest2.level and name1 or name2;
        end else do
          exit_1 = 2;
        end end 
      end end 
      if (exit_1 == 2) then do
        if (use2) then do
          set_name(rest2, name1);
        end
         end 
        name = name1;
      end
       end 
    end else do
      exit = 1;
    end end 
  end end 
  if (exit == 1) then do
    if (typeof match_1 == "number" or match_1.tag) then do
      name = undefined;
    end else do
      name_1 = match_1[0];
      if (name_1 ~= undefined) then do
        if (use1) then do
          set_name(rest2, name_1);
        end
         end 
        name = name_1;
      end else do
        name = undefined;
      end end 
    end end 
  end
   end 
  if (use1) then do
    return rest1;
  end else if (use2) then do
    return rest2;
  end else do
    return newty2(level, --[[ Tvar ]]Block.__(0, {name}));
  end end  end 
end end

function unify_fields(env, ty1, ty2) do
  match = flatten_fields(ty1);
  rest1 = match[1];
  match_1 = flatten_fields(ty2);
  rest2 = match_1[1];
  match_2 = associate_fields(match[0], match_1[0]);
  miss2 = match_2[2];
  miss1 = match_2[1];
  l1 = repr(ty1).level;
  l2 = repr(ty2).level;
  va = make_rowvar(l1 < l2 and l1 or l2, miss2 == --[[ [] ]]0, rest1, miss1 == --[[ [] ]]0, rest2);
  d1 = rest1.desc;
  d2 = rest2.desc;
  xpcall(function() do
    unify(env, build_fields(l1)(miss1, va), rest2);
    unify(env, rest1, build_fields(l2)(miss2, va));
    return List.iter((function(param) do
                  t2 = param[4];
                  k2 = param[3];
                  t1 = param[2];
                  k1 = param[1];
                  n = param[0];
                  unify_kind(k1, k2);
                  xpcall(function() do
                    if (trace_gadt_instances.contents) then do
                      update_level(env.contents, va.level, t1);
                    end
                     end 
                    return unify(env, t1, t2);
                  end end,function(raw_exn) do
                    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn[0] == Unify) then do
                      desc_003 = newty2(current_level.contents, --[[ Tnil ]]0);
                      desc = --[[ Tfield ]]Block.__(5, {
                          n,
                          k1,
                          t1,
                          desc_003
                        });
                      desc_003_1 = newty2(current_level.contents, --[[ Tnil ]]0);
                      desc_1 = --[[ Tfield ]]Block.__(5, {
                          n,
                          k2,
                          t2,
                          desc_003_1
                        });
                      error({
                        Unify,
                        --[[ :: ]]{
                          --[[ tuple ]]{
                            newty2(current_level.contents, desc),
                            newty2(current_level.contents, desc_1)
                          },
                          exn[1]
                        }
                      })
                    end
                     end 
                    error(exn)
                  end end)
                end end), match_2[0]);
  end end,function(exn) do
    log_type(rest1);
    rest1.desc = d1;
    log_type(rest2);
    rest2.desc = d2;
    error(exn)
  end end)
end end

function unify_list(env, tl1, tl2) do
  if (List.length(tl1) ~= List.length(tl2)) then do
    error({
      Unify,
      --[[ [] ]]0
    })
  end
   end 
  return List.iter2((function(param, param_1) do
                return unify(env, param, param_1);
              end end), tl1, tl2);
end end

function unify_row(env, row1, row2) do
  row1_1 = row_repr_aux(--[[ [] ]]0, row1);
  row2_1 = row_repr_aux(--[[ [] ]]0, row2);
  rm1 = row_more(row1_1);
  rm2 = row_more(row2_1);
  if (unify_eq(env.contents, rm1, rm2)) then do
    return --[[ () ]]0;
  end else do
    match = merge_row_fields(row1_1.row_fields, row2_1.row_fields);
    pairs = match[2];
    r2 = match[1];
    r1 = match[0];
    if (r1 ~= --[[ [] ]]0 and r2 ~= --[[ [] ]]0) then do
      ht = Hashtbl.create(undefined, List.length(r1));
      List.iter((function(param) do
              l = param[0];
              return Hashtbl.add(ht, hash_variant(l), l);
            end end), r1);
      List.iter((function(param) do
              l = param[0];
              xpcall(function() do
                error({
                  Tags,
                  l,
                  Hashtbl.find(ht, hash_variant(l))
                })
              end end,function(exn) do
                if (exn == Caml_builtin_exceptions.not_found) then do
                  return --[[ () ]]0;
                end else do
                  error(exn)
                end end 
              end end)
            end end), r2);
    end
     end 
    fixed1 = row_fixed(row1_1);
    fixed2 = row_fixed(row2_1);
    more = fixed1 and rm1 or (
        fixed2 and rm2 or newty2(rm1.level < rm2.level and rm1.level or rm2.level, --[[ Tvar ]]Block.__(0, {undefined}))
      );
    fixed = fixed1 or fixed2;
    closed = row1_1.row_closed or row2_1.row_closed;
    keep = function(__switch) do
      return List.for_all((function(param) do
                    match = Curry._2(__switch, param[1], param[2]);
                    if (row_field_repr_aux(--[[ [] ]]0, match[0]) == --[[ Rabsent ]]0) then do
                      return true;
                    end else do
                      return row_field_repr_aux(--[[ [] ]]0, match[1]) ~= --[[ Rabsent ]]0;
                    end end 
                  end end), pairs);
    end end;
    empty = function(fields) do
      return List.for_all((function(param) do
                    return row_field_repr_aux(--[[ [] ]]0, param[1]) == --[[ Rabsent ]]0;
                  end end), fields);
    end end;
    if (closed and (empty(r1) or row2_1.row_closed) and (empty(r2) or row1_1.row_closed) and List.for_all((function(param) do
              if (row_field_repr_aux(--[[ [] ]]0, param[1]) == --[[ Rabsent ]]0) then do
                return true;
              end else do
                return row_field_repr_aux(--[[ [] ]]0, param[2]) == --[[ Rabsent ]]0;
              end end 
            end end), pairs)) then do
      error({
        Unify,
        --[[ :: ]]{
          --[[ tuple ]]{
            mkvariant(--[[ [] ]]0, true),
            mkvariant(--[[ [] ]]0, true)
          },
          --[[ [] ]]0
        }
      })
    end
     end 
    name = row1_1.row_name ~= undefined and (row1_1.row_closed or empty(r2)) and (not row2_1.row_closed or keep((function(f1, f2) do
              return --[[ tuple ]]{
                      f1,
                      f2
                    };
            end end)) and empty(r1)) and row1_1.row_name or (
        row2_1.row_name ~= undefined and (row2_1.row_closed or empty(r1)) and (not row1_1.row_closed or keep((function(f1, f2) do
                  return --[[ tuple ]]{
                          f2,
                          f1
                        };
                end end)) and empty(r2)) and row2_1.row_name or undefined
      );
    set_more = function(row, rest) do
      rest_1 = closed and filter_row_fields(row.row_closed, rest) or rest;
      if (rest_1 ~= --[[ [] ]]0 and (row.row_closed or row_fixed(row)) or closed and row_fixed(row) and not row.row_closed) then do
        t1 = mkvariant(--[[ [] ]]0, true);
        t2 = mkvariant(rest_1, false);
        error({
          Unify,
          --[[ :: ]]{
            row == row1_1 and --[[ tuple ]]{
                t1,
                t2
              } or --[[ tuple ]]{
                t2,
                t1
              },
            --[[ [] ]]0
          }
        })
      end
       end 
      rm = row_more(row);
      if (not (trace_gadt_instances.contents and rm.desc == --[[ Tnil ]]0)) then do
        if (trace_gadt_instances.contents) then do
          update_level(env.contents, rm.level, newty2(100000000, --[[ Tvariant ]]Block.__(8, {row})));
        end
         end 
      end
       end 
      if (row_fixed(row)) then do
        if (more == rm) then do
          return --[[ () ]]0;
        end else if (is_Tvar(rm)) then do
          return link_type(rm, more);
        end else do
          return unify(env, rm, more);
        end end  end 
      end else do
        ty = newty2(100000000, --[[ Tvariant ]]Block.__(8, {do
                  row_fields: rest_1,
                  row_more: more,
                  row_bound: --[[ () ]]0,
                  row_closed: closed,
                  row_fixed: fixed,
                  row_name: name
                end}));
        update_level(env.contents, rm.level, ty);
        return link_type(rm, ty);
      end end 
    end end;
    md1 = rm1.desc;
    md2 = rm2.desc;
    xpcall(function() do
      set_more(row2_1, r1);
      set_more(row1_1, r2);
      return List.iter((function(param) do
                    f2 = param[2];
                    f1 = param[1];
                    l = param[0];
                    xpcall(function() do
                      env_1 = env;
                      fixed1_1 = fixed1;
                      fixed2_1 = fixed2;
                      more_1 = more;
                      _f1 = f1;
                      _f2 = f2;
                      while(true) do
                        f2_1 = _f2;
                        f1_1 = _f1;
                        f1_2 = row_field_repr_aux(--[[ [] ]]0, f1_1);
                        f2_2 = row_field_repr_aux(--[[ [] ]]0, f2_1);
                        if (f1_2 == f2_2) then do
                          return --[[ () ]]0;
                        end else if (typeof f1_2 == "number") then do
                          if (typeof f2_2 == "number") then do
                            return --[[ () ]]0;
                          end else if (f2_2.tag) then do
                            if (f2_2[2]) then do
                              error({
                                Unify,
                                --[[ [] ]]0
                              })
                            end
                             end 
                            if (fixed2_1) then do
                              error({
                                Unify,
                                --[[ [] ]]0
                              })
                            end else do
                              return set_row_field(f2_2[3], f1_2);
                            end end 
                          end else do
                            error({
                              Unify,
                              --[[ [] ]]0
                            })
                          end end  end 
                        end else if (f1_2.tag) then do
                          c1 = f1_2[0];
                          m1 = f1_2[2];
                          tl1 = f1_2[1];
                          e1 = f1_2[3];
                          if (typeof f2_2 == "number") then do
                            if (m1) then do
                              error({
                                Unify,
                                --[[ [] ]]0
                              })
                            end
                             end 
                            if (fixed1_1) then do
                              error({
                                Unify,
                                --[[ [] ]]0
                              })
                            end else do
                              return set_row_field(f1_2[3], f2_2);
                            end end 
                          end else if (f2_2.tag) then do
                            e2 = f2_2[3];
                            if (e1 == e2) then do
                              return --[[ () ]]0;
                            end else do
                              m2 = f2_2[2];
                              tl2 = f2_2[1];
                              c2 = f2_2[0];
                              redo = false;
                              if (m1 or m2 or fixed1_1 or fixed2_1 or rigid_variants.contents and (List.length(tl1) == 1 or List.length(tl2) == 1)) then do
                                match = Pervasives.$at(tl1, tl2);
                                tmp;
                                if (match) then do
                                  t1 = match[0];
                                  if (c1 or c2) then do
                                    error({
                                      Unify,
                                      --[[ [] ]]0
                                    })
                                  end
                                   end 
                                  List.iter((function(t1)do
                                      return function (param) do
                                        return unify(env_1, t1, param);
                                      end end
                                      end end)(t1), match[1]);
                                  tmp = e1.contents ~= undefined or e2.contents ~= undefined;
                                end else do
                                  tmp = false;
                                end end 
                                redo = tmp;
                              end
                               end 
                              if (redo) then do
                                _f2 = f2_2;
                                _f1 = f1_2;
                                ::continue:: ;
                              end else do
                                tl1_1 = List.map(repr, tl1);
                                tl2_1 = List.map(repr, tl2);
                                remq = function(tl, _param) do
                                  while(true) do
                                    param = _param;
                                    if (param) then do
                                      tl$prime = param[1];
                                      ty = param[0];
                                      if (List.memq(ty, tl)) then do
                                        _param = tl$prime;
                                        ::continue:: ;
                                      end else do
                                        return --[[ :: ]]{
                                                ty,
                                                remq(tl, tl$prime)
                                              };
                                      end end 
                                    end else do
                                      return --[[ [] ]]0;
                                    end end 
                                  end;
                                end end;
                                tl2$prime = remq(tl2_1, tl1_1);
                                tl1$prime = remq(tl1_1, tl2_1);
                                partial_arg = repr(more_1).level;
                                partial_arg_1 = env_1.contents;
                                List.iter((function(partial_arg,partial_arg_1)do
                                    return function (param) do
                                      return update_level(partial_arg_1, partial_arg, param);
                                    end end
                                    end end)(partial_arg,partial_arg_1), Pervasives.$at(tl1$prime, tl2$prime));
                                e = do
                                  contents: undefined
                                end;
                                f1$prime_000 = c1 or c2;
                                f1$prime_002 = m1 or m2;
                                f1$prime = --[[ Reither ]]Block.__(1, {
                                    f1$prime_000,
                                    tl1$prime,
                                    f1$prime_002,
                                    e
                                  });
                                f2$prime_000 = c1 or c2;
                                f2$prime_002 = m1 or m2;
                                f2$prime = --[[ Reither ]]Block.__(1, {
                                    f2$prime_000,
                                    tl2$prime,
                                    f2$prime_002,
                                    e
                                  });
                                set_row_field(e1, f1$prime);
                                return set_row_field(e2, f2$prime);
                              end end 
                            end end 
                          end else if (c1) then do
                            if (f1_2[1]) then do
                              error({
                                Unify,
                                --[[ [] ]]0
                              })
                            end
                             end 
                            if (f2_2[0] ~= undefined) then do
                              error({
                                Unify,
                                --[[ [] ]]0
                              })
                            end
                             end 
                            if (fixed1_1) then do
                              error({
                                Unify,
                                --[[ [] ]]0
                              })
                            end else do
                              return set_row_field(f1_2[3], f2_2);
                            end end 
                          end else do
                            match_1 = f2_2[0];
                            if (match_1 ~= undefined) then do
                              if (fixed1_1) then do
                                error({
                                  Unify,
                                  --[[ [] ]]0
                                })
                              end else do
                                t2 = match_1;
                                e1_1 = f1_2[3];
                                set_row_field(e1_1, f2_2);
                                update_level(env_1.contents, repr(more_1).level, t2);
                                xpcall(function() do
                                  return List.iter((function(t2)do
                                            return function (t1) do
                                              return unify(env_1, t1, t2);
                                            end end
                                            end end)(t2), f1_2[1]);
                                end end,function(exn) do
                                  e1_1.contents = undefined;
                                  error(exn)
                                end end)
                              end end 
                            end else do
                              error({
                                Unify,
                                --[[ [] ]]0
                              })
                            end end 
                          end end  end  end 
                        end else do
                          match_2 = f1_2[0];
                          if (match_2 ~= undefined) then do
                            t1_1 = match_2;
                            if (typeof f2_2 == "number") then do
                              error({
                                Unify,
                                --[[ [] ]]0
                              })
                            end else if (f2_2.tag) then do
                              if (f2_2[0]) then do
                                error({
                                  Unify,
                                  --[[ [] ]]0
                                })
                              end
                               end 
                              if (fixed2_1) then do
                                error({
                                  Unify,
                                  --[[ [] ]]0
                                })
                              end else do
                                e2_1 = f2_2[3];
                                set_row_field(e2_1, f1_2);
                                update_level(env_1.contents, repr(more_1).level, t1_1);
                                xpcall(function() do
                                  return List.iter((function(t1_1)do
                                            return function (param) do
                                              return unify(env_1, t1_1, param);
                                            end end
                                            end end)(t1_1), f2_2[1]);
                                end end,function(exn_1) do
                                  e2_1.contents = undefined;
                                  error(exn_1)
                                end end)
                              end end 
                            end else do
                              match_3 = f2_2[0];
                              if (match_3 ~= undefined) then do
                                return unify(env_1, t1_1, match_3);
                              end else do
                                error({
                                  Unify,
                                  --[[ [] ]]0
                                })
                              end end 
                            end end  end 
                          end else if (typeof f2_2 == "number") then do
                            error({
                              Unify,
                              --[[ [] ]]0
                            })
                          end else if (f2_2.tag) then do
                            if (f2_2[0]) then do
                              if (f2_2[1]) then do
                                error({
                                  Unify,
                                  --[[ [] ]]0
                                })
                              end
                               end 
                              if (fixed2_1) then do
                                error({
                                  Unify,
                                  --[[ [] ]]0
                                })
                              end else do
                                return set_row_field(f2_2[3], f1_2);
                              end end 
                            end else do
                              error({
                                Unify,
                                --[[ [] ]]0
                              })
                            end end 
                          end else if (f2_2[0] ~= undefined) then do
                            error({
                              Unify,
                              --[[ [] ]]0
                            })
                          end else do
                            return --[[ () ]]0;
                          end end  end  end  end 
                        end end  end  end 
                      end;
                    end end,function(raw_exn) do
                      exn_2 = Caml_js_exceptions.internalToOCamlException(raw_exn);
                      if (exn_2[0] == Unify) then do
                        error({
                          Unify,
                          --[[ :: ]]{
                            --[[ tuple ]]{
                              mkvariant(--[[ :: ]]{
                                    --[[ tuple ]]{
                                      l,
                                      f1
                                    },
                                    --[[ [] ]]0
                                  }, true),
                              mkvariant(--[[ :: ]]{
                                    --[[ tuple ]]{
                                      l,
                                      f2
                                    },
                                    --[[ [] ]]0
                                  }, true)
                            },
                            exn_2[1]
                          }
                        })
                      end
                       end 
                      error(exn_2)
                    end end)
                  end end), pairs);
    end end,function(exn) do
      log_type(rm1);
      rm1.desc = md1;
      log_type(rm2);
      rm2.desc = md2;
      error(exn)
    end end)
  end end 
end end

function unify3(env, t1, t1$prime, t2, t2$prime) do
  d1 = t1$prime.desc;
  d2 = t2$prime.desc;
  create_recursion = t2 ~= t2$prime and deep_occur(t1$prime, t2);
  exit = 0;
  exit_1 = 0;
  if (typeof d1 == "number") then do
    exit_1 = 2;
  end else do
    local ___conditional___=(d1.tag | 0);
    do
       if ___conditional___ == 0--[[ Tvar ]] then do
          occur(env.contents, t1$prime, t2);
          occur_univar(env.contents, t2);
          return link_type(t1$prime, t2); end end 
       if ___conditional___ == 5--[[ Tfield ]] then do
          if (typeof d2 == "number") then do
            exit = 1;
          end else do
            local ___conditional___=(d2.tag | 0);
            do
               if ___conditional___ == 0--[[ Tvar ]] then do
                  exit_1 = 2; end else 
               if ___conditional___ == 5--[[ Tfield ]] then do
                  return unify_fields(env, t1$prime, t2$prime); end end end end 
              exit = 1;
                
            end
          end end  end else 
       if ___conditional___ == 9--[[ Tunivar ]] then do
          if (typeof d2 == "number") then do
            exit = 1;
          end else do
            local ___conditional___=(d2.tag | 0);
            do
               if ___conditional___ == 0--[[ Tvar ]] then do
                  exit_1 = 2; end else 
               if ___conditional___ == 9--[[ Tunivar ]] then do
                  unify_univar(t1$prime, t2$prime, univar_pairs.contents);
                  return link_type(t1$prime, t2$prime); end end end end 
              exit = 1;
                
            end
          end end  end else 
       end end end end
      exit_1 = 2;
        
    end
  end end 
  if (exit_1 == 2) then do
    if (typeof d2 == "number" or d2.tag) then do
      exit = 1;
    end else do
      occur(env.contents, t2$prime, t1);
      occur_univar(env.contents, t1);
      return link_type(t2$prime, t1);
    end end 
  end
   end 
  if (exit == 1) then do
    match = umode.contents;
    if (match) then do
      add_type_equality(t1$prime, t2$prime);
    end else do
      occur(env.contents, t1$prime, t2$prime);
      link_type(t1$prime, t2);
    end end 
    xpcall(function() do
      exit_2 = 0;
      f;
      kind;
      rem;
      exit_3 = 0;
      exit_4 = 0;
      if (typeof d1 == "number") then do
        if (typeof d2 ~= "number") then do
          local ___conditional___=(d2.tag | 0);
          do
             if ___conditional___ == 3--[[ Tconstr ]] then do
                exit_4 = 5; end else 
             if ___conditional___ == 5--[[ Tfield ]] then do
                f = d2[0];
                kind = d2[1];
                rem = d2[3];
                exit_2 = 3; end else 
             end end end end
            error({
                Unify,
                --[[ [] ]]0
              })
              
          end
        end
         end 
      end else do
        local ___conditional___=(d1.tag | 0);
        do
           if ___conditional___ == 1--[[ Tarrow ]] then do
              l1 = d1[0];
              if (typeof d2 == "number") then do
                error({
                  Unify,
                  --[[ [] ]]0
                })
              end else do
                local ___conditional___=(d2.tag | 0);
                do
                   if ___conditional___ == 1--[[ Tarrow ]] then do
                      l2 = d2[0];
                      if (l1 == l2 or classic.contents and not (is_optional(l1) or is_optional(l2))) then do
                        unify(env, d1[1], d2[1]);
                        unify(env, d1[2], d2[2]);
                        match_1 = commu_repr(d1[3]);
                        match_2 = commu_repr(d2[3]);
                        if (typeof match_1 == "number") then do
                          if (typeof match_2 == "number") then do
                            
                          end else do
                            set_commu(match_2[0], match_1);
                          end end 
                        end else do
                          set_commu(match_1[0], match_2);
                        end end 
                      end else do
                        error({
                          Unify,
                          --[[ [] ]]0
                        })
                      end end  end else 
                   if ___conditional___ == 3--[[ Tconstr ]] then do
                      exit_4 = 5; end else 
                   end end end end
                  error({
                      Unify,
                      --[[ [] ]]0
                    })
                    
                end
              end end  end else 
           if ___conditional___ == 2--[[ Ttuple ]] then do
              if (typeof d2 == "number") then do
                error({
                  Unify,
                  --[[ [] ]]0
                })
              end else do
                local ___conditional___=(d2.tag | 0);
                do
                   if ___conditional___ == 2--[[ Ttuple ]] then do
                      unify_list(env, d1[0], d2[0]); end else 
                   if ___conditional___ == 3--[[ Tconstr ]] then do
                      exit_4 = 5; end else 
                   end end end end
                  error({
                      Unify,
                      --[[ [] ]]0
                    })
                    
                end
              end end  end else 
           if ___conditional___ == 3--[[ Tconstr ]] then do
              p1 = d1[0];
              exit_5 = 0;
              if (typeof d2 == "number" or d2.tag ~= --[[ Tconstr ]]3) then do
                exit_5 = 6;
              end else do
                tl2 = d2[1];
                tl1 = d1[1];
                if (same(p1, d2[0])) then do
                  if (umode.contents == --[[ Expression ]]0 or not generate_equations.contents) then do
                    unify_list(env, tl1, tl2);
                  end else if (assume_injective.contents) then do
                    set_mode_pattern(true, false, (function(param) do
                            return unify_list(env, tl1, tl2);
                          end end));
                  end else do
                    tmp = true;
                    if (not in_current_module(p1)) then do
                      partial_arg = env.contents;
                      tmp = List.exists((function(param) do
                              return expands_to_datatype(partial_arg, param);
                            end end), --[[ :: ]]{
                            t1$prime,
                            --[[ :: ]]{
                              t1,
                              --[[ :: ]]{
                                t2,
                                --[[ [] ]]0
                              }
                            }
                          });
                    end
                     end 
                    if (tmp) then do
                      unify_list(env, tl1, tl2);
                    end else do
                      inj;
                      xpcall(function() do
                        inj = List.map(Curry._1(Types_Variance.mem, --[[ Inj ]]3), find_type_full(p1, env.contents)[0].type_variance);
                      end end,function(exn) do
                        if (exn == Caml_builtin_exceptions.not_found) then do
                          inj = List.map((function(param) do
                                  return false;
                                end end), tl1);
                        end else do
                          error(exn)
                        end end 
                      end end)
                      List.iter2((function(i, param) do
                              t2 = param[1];
                              t1 = param[0];
                              if (i) then do
                                return unify(env, t1, t2);
                              end else do
                                return set_mode_pattern(false, false, (function(param) do
                                              snap = snapshot(--[[ () ]]0);
                                              xpcall(function() do
                                                return unify(env, t1, t2);
                                              end end,function(raw_exn) do
                                                exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                                                if (exn[0] == Unify) then do
                                                  backtrack(snap);
                                                  reify(env, t1);
                                                  return reify(env, t2);
                                                end else do
                                                  error(exn)
                                                end end 
                                              end end)
                                            end end));
                              end end 
                            end end), inj, List.combine(tl1, tl2));
                    end end 
                  end end  end 
                end else do
                  exit_5 = 6;
                end end 
              end end 
              if (exit_5 == 6) then do
                local ___conditional___=(p1.tag | 0);
                do
                   if ___conditional___ == 0--[[ Pident ]] then do
                      if (d1[1]) then do
                        exit_4 = 5;
                      end else do
                        p = p1[0];
                        exit_6 = 0;
                        if (typeof d2 == "number" or d2.tag ~= --[[ Tconstr ]]3) then do
                          exit_6 = 7;
                        end else do
                          path$prime = d2[0];
                          local ___conditional___=(path$prime.tag | 0);
                          do
                             if ___conditional___ == 0--[[ Pident ]] then do
                                if (d2[1] or not (is_newtype(env.contents, p1) and is_newtype(env.contents, path$prime) and generate_equations.contents)) then do
                                  exit_6 = 7;
                                end else do
                                  match_3 = Caml_obj.caml_greaterthan(find_newtype_level(env.contents, p1), find_newtype_level(env.contents, path$prime)) and --[[ tuple ]]{
                                      p,
                                      t2$prime
                                    } or --[[ tuple ]]{
                                      path$prime[0],
                                      t1$prime
                                    };
                                  add_gadt_equation(env, match_3[0], match_3[1]);
                                end end  end else 
                             if ___conditional___ == 1--[[ Pdot ]]
                             or ___conditional___ == 2--[[ Papply ]] then do
                                exit_6 = 7; end else 
                             end end end end
                            
                          end
                        end end 
                        if (exit_6 == 7) then do
                          if (is_newtype(env.contents, p1) and generate_equations.contents) then do
                            reify(env, t2$prime);
                            add_gadt_equation(env, p, t2$prime);
                          end else do
                            exit_4 = 5;
                          end end 
                        end
                         end 
                      end end  end else 
                   if ___conditional___ == 1--[[ Pdot ]]
                   or ___conditional___ == 2--[[ Papply ]] then do
                      exit_4 = 5; end else 
                   end end end end
                  
                end
              end
               end  end else 
           if ___conditional___ == 4--[[ Tobject ]] then do
              nm1 = d1[1];
              if (typeof d2 == "number") then do
                error({
                  Unify,
                  --[[ [] ]]0
                })
              end else do
                local ___conditional___=(d2.tag | 0);
                do
                   if ___conditional___ == 3--[[ Tconstr ]] then do
                      exit_4 = 5; end else 
                   if ___conditional___ == 4--[[ Tobject ]] then do
                      unify_fields(env, d1[0], d2[0]);
                      match_4 = repr(t2$prime).desc;
                      if (typeof match_4 ~= "number" and match_4.tag == --[[ Tobject ]]4) then do
                        nm2 = match_4[1];
                        match_5 = nm2.contents;
                        if (match_5 ~= undefined) then do
                          match_6 = match_5[1];
                          if (match_6) then do
                            match_7 = repr(match_6[0]).desc;
                            tmp_1;
                            if (typeof match_7 == "number") then do
                              tmp_1 = true;
                            end else do
                              local ___conditional___=(match_7.tag | 0);
                              do
                                 if ___conditional___ == 0--[[ Tvar ]]
                                 or ___conditional___ == 9--[[ Tunivar ]] then do
                                    tmp_1 = true; end else 
                                 end end
                                tmp_1 = false;
                                  
                              end
                            end end 
                            if (not tmp_1) then do
                              set_name(nm2, nm1.contents);
                            end
                             end 
                          end else do
                            set_name(nm2, nm1.contents);
                          end end 
                        end else do
                          set_name(nm2, nm1.contents);
                        end end 
                      end
                       end  end else 
                   end end end end
                  error({
                      Unify,
                      --[[ [] ]]0
                    })
                    
                end
              end end  end else 
           if ___conditional___ == 5--[[ Tfield ]] then do
              if (typeof d2 == "number") then do
                f = d1[0];
                kind = d1[1];
                rem = d1[3];
                exit_2 = 3;
              end else if (d2.tag == --[[ Tconstr ]]3) then do
                exit_4 = 5;
              end else do
                error({
                  Unify,
                  --[[ [] ]]0
                })
              end end  end  end else 
           if ___conditional___ == 8--[[ Tvariant ]] then do
              row1 = d1[0];
              if (typeof d2 == "number") then do
                error({
                  Unify,
                  --[[ [] ]]0
                })
              end else do
                local ___conditional___=(d2.tag | 0);
                do
                   if ___conditional___ == 3--[[ Tconstr ]] then do
                      exit_4 = 5; end else 
                   if ___conditional___ == 8--[[ Tvariant ]] then do
                      row2 = d2[0];
                      if (umode.contents == --[[ Expression ]]0) then do
                        unify_row(env, row1, row2);
                      end else do
                        snap = snapshot(--[[ () ]]0);
                        xpcall(function() do
                          unify_row(env, row1, row2);
                        end end,function(raw_exn) do
                          exn_1 = Caml_js_exceptions.internalToOCamlException(raw_exn);
                          if (exn_1[0] == Unify) then do
                            backtrack(snap);
                            reify(env, t1$prime);
                            reify(env, t2$prime);
                            if (generate_equations.contents) then do
                              mcomp_1(env.contents, t1$prime, t2$prime);
                            end
                             end 
                          end else do
                            error(exn_1)
                          end end 
                        end end)
                      end end  end else 
                   end end end end
                  error({
                      Unify,
                      --[[ [] ]]0
                    })
                    
                end
              end end  end else 
           if ___conditional___ == 10--[[ Tpoly ]] then do
              tl1_1 = d1[1];
              t1_1 = d1[0];
              exit_7 = 0;
              if (tl1_1) then do
                exit_7 = 6;
              end else if (typeof d2 == "number") then do
                error({
                  Unify,
                  --[[ [] ]]0
                })
              end else do
                local ___conditional___=(d2.tag | 0);
                do
                   if ___conditional___ == 3--[[ Tconstr ]] then do
                      exit_4 = 5; end else 
                   if ___conditional___ == 10--[[ Tpoly ]] then do
                      if (d2[1]) then do
                        exit_7 = 6;
                      end else do
                        unify(env, t1_1, d2[0]);
                      end end  end else 
                   end end end end
                  error({
                      Unify,
                      --[[ [] ]]0
                    })
                    
                end
              end end  end 
              if (exit_7 == 6) then do
                if (typeof d2 == "number") then do
                  error({
                    Unify,
                    --[[ [] ]]0
                  })
                end else do
                  local ___conditional___=(d2.tag | 0);
                  do
                     if ___conditional___ == 3--[[ Tconstr ]] then do
                        exit_4 = 5; end else 
                     if ___conditional___ == 10--[[ Tpoly ]] then do
                        enter_poly(env.contents, univar_pairs, t1_1, tl1_1, d2[0], d2[1], (function(param, param_1) do
                                return unify(env, param, param_1);
                              end end)); end else 
                     end end end end
                    error({
                        Unify,
                        --[[ [] ]]0
                      })
                      
                  end
                end end 
              end
               end  end else 
           if ___conditional___ == 11--[[ Tpackage ]] then do
              tl1_2 = d1[2];
              if (typeof d2 == "number") then do
                error({
                  Unify,
                  --[[ [] ]]0
                })
              end else do
                local ___conditional___=(d2.tag | 0);
                do
                   if ___conditional___ == 3--[[ Tconstr ]] then do
                      exit_4 = 5; end else 
                   if ___conditional___ == 11--[[ Tpackage ]] then do
                      tl2_1 = d2[2];
                      xpcall(function() do
                        unify_package(env.contents, (function(param, param_1) do
                                return unify_list(env, param, param_1);
                              end end), t1.level, d1[0], d1[1], tl1_2, t2.level, d2[0], d2[1], tl2_1);
                      end end,function(exn_2) do
                        if (exn_2 == Caml_builtin_exceptions.not_found) then do
                          if (umode.contents == --[[ Expression ]]0) then do
                            error({
                              Unify,
                              --[[ [] ]]0
                            })
                          end
                           end 
                          List.iter((function(param) do
                                  return reify(env, param);
                                end end), Pervasives.$at(tl1_2, tl2_1));
                        end else do
                          error(exn_2)
                        end end 
                      end end) end else 
                   end end end end
                  error({
                      Unify,
                      --[[ [] ]]0
                    })
                    
                end
              end end  end else 
           end end end end end end end end end end end end end end end end
          exit_4 = 5;
            
        end
      end end 
      if (exit_4 == 5) then do
        if (typeof d2 == "number" or d2.tag ~= --[[ Tconstr ]]3) then do
          exit_3 = 4;
        end else do
          path = d2[0];
          local ___conditional___=(path.tag | 0);
          do
             if ___conditional___ == 0--[[ Pident ]] then do
                if (d2[1] or not (is_newtype(env.contents, path) and generate_equations.contents)) then do
                  exit_2 = 2;
                end else do
                  reify(env, t1$prime);
                  add_gadt_equation(env, path[0], t1$prime);
                end end  end else 
             if ___conditional___ == 1--[[ Pdot ]]
             or ___conditional___ == 2--[[ Papply ]] then do
                exit_2 = 2; end else 
             end end end end
            
          end
        end end 
      end
       end 
      if (exit_3 == 4) then do
        if (typeof d1 == "number") then do
          error({
            Unify,
            --[[ [] ]]0
          })
        end else if (d1.tag == --[[ Tconstr ]]3) then do
          exit_2 = 2;
        end else do
          error({
            Unify,
            --[[ [] ]]0
          })
        end end  end 
      end
       end 
      local ___conditional___=(exit_2);
      do
         if ___conditional___ == 2 then do
            if (umode.contents == --[[ Pattern ]]1) then do
              reify(env, t1$prime);
              reify(env, t2$prime);
              if (generate_equations.contents) then do
                mcomp_1(env.contents, t1$prime, t2$prime);
              end
               end 
            end else do
              error({
                Unify,
                --[[ [] ]]0
              })
            end end  end else 
         if ___conditional___ == 3 then do
            match_8 = field_kind_repr(kind);
            if (typeof match_8 == "number") then do
              error({
                Unify,
                --[[ [] ]]0
              })
            end
             end 
            if (f ~= dummy_method) then do
              set_kind(match_8[0], --[[ Fabsent ]]1);
              if (d2 == --[[ Tnil ]]0) then do
                unify(env, rem, t2$prime);
              end else do
                unify(env, newty2(rem.level, --[[ Tnil ]]0), rem);
              end end 
            end else do
              error({
                Unify,
                --[[ [] ]]0
              })
            end end  end else 
         end end end end
        
      end
      if (create_recursion) then do
        match_9 = t2.desc;
        if (typeof match_9 == "number" or match_9.tag ~= --[[ Tconstr ]]3) then do
          return --[[ () ]]0;
        end else do
          forget_abbrev(match_9[2], match_9[0]);
          t2$prime$prime = expand_head_unif(env.contents, t2);
          if (closed_parameterized_type(match_9[1], t2$prime$prime)) then do
            return 0;
          end else do
            return link_type(repr(t2), repr(t2$prime));
          end end 
        end end 
      end else do
        return 0;
      end end 
    end end,function(raw_exn_1) do
      exn_3 = Caml_js_exceptions.internalToOCamlException(raw_exn_1);
      if (exn_3[0] == Unify) then do
        t1$prime.desc = d1;
        error({
          Unify,
          exn_3[1]
        })
      end else do
        error(exn_3)
      end end 
    end end)
  end
   end 
end end

function unify2(env, t1, t2) do
  expand_both = function(_t1$prime$prime, _t2$prime$prime) do
    while(true) do
      t2$prime$prime = _t2$prime$prime;
      t1$prime$prime = _t1$prime$prime;
      t1$prime = expand_head_unif(env.contents, t1);
      t2$prime = expand_head_unif(env.contents, t2);
      if (unify_eq(env.contents, t1$prime, t1$prime$prime) and unify_eq(env.contents, t2$prime, t2$prime$prime)) then do
        return --[[ tuple ]]{
                t1$prime,
                t2$prime
              };
      end else do
        _t2$prime$prime = t2$prime;
        _t1$prime$prime = t1$prime;
        ::continue:: ;
      end end 
    end;
  end end;
  match = expand_both(t1, t2);
  t2$prime = match[1];
  t1$prime = match[0];
  lv = t1$prime.level < t2$prime.level and t1$prime.level or t2$prime.level;
  update_level(env.contents, lv, t2);
  update_level(env.contents, lv, t1);
  if (unify_eq(env.contents, t1$prime, t2$prime)) then do
    return --[[ () ]]0;
  end else do
    t1_1 = repr(t1);
    t2_1 = repr(t2);
    if (trace_gadt_instances.contents) then do
      ilevel = function(t) do
        match = gadt_instance_level(env.contents, t);
        if (match ~= undefined) then do
          return match;
        end else do
          return 0;
        end end 
      end end;
      lv1 = ilevel(t1_1);
      lv2 = ilevel(t2_1);
      if (lv1 > lv2) then do
        add_gadt_instance_chain(env.contents, lv1, t2_1);
      end else if (lv2 > lv1) then do
        add_gadt_instance_chain(env.contents, lv2, t1_1);
      end
       end  end 
    end
     end 
    match_1;
    if (principal.contents and (find_lowest_level(t1$prime) < lv or find_lowest_level(t2$prime) < lv)) then do
      match_2 = t1_1.desc;
      tmp;
      tmp = typeof match_2 == "number" or not (match_2.tag == --[[ Tconstr ]]3 and not match_2[1]) and t1_1 or t1$prime;
      match_3 = t2_1.desc;
      tmp_1;
      tmp_1 = typeof match_3 == "number" or not (match_3.tag == --[[ Tconstr ]]3 and not match_3[1]) and t2_1 or t2$prime;
      match_1 = --[[ tuple ]]{
        tmp,
        tmp_1
      };
    end else do
      match_1 = --[[ tuple ]]{
        t1_1,
        t2_1
      };
    end end 
    t2_2 = match_1[1];
    t1_2 = match_1[0];
    if (unify_eq(env.contents, t1_2, t1$prime) or not unify_eq(env.contents, t2_2, t2$prime)) then do
      return unify3(env, t1_2, t1$prime, t2_2, t2$prime);
    end else do
      xpcall(function() do
        return unify3(env, t2_2, t2$prime, t1_2, t1$prime);
      end end,function(raw_exn) do
        exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn[0] == Unify) then do
          error({
            Unify,
            List.map((function(param) do
                    return --[[ tuple ]]{
                            param[1],
                            param[0]
                          };
                  end end), exn[1])
          })
        end
         end 
        error(exn)
      end end)
    end end 
  end end 
end end

function unify_1(env, ty1, ty2) do
  xpcall(function() do
    return unify(env, ty1, ty2);
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      error({
        Unify,
        expand_trace(env.contents, exn[1])
      })
    end
     end 
    if (exn == Recursive_abbrev) then do
      error({
        Unification_recursive_abbrev,
        expand_trace(env.contents, --[[ :: ]]{
              --[[ tuple ]]{
                ty1,
                ty2
              },
              --[[ [] ]]0
            })
      })
    end
     end 
    error(exn)
  end end)
end end

function unify_var(env, t1, t2) do
  t1_1 = repr(t1);
  t2_1 = repr(t2);
  if (t1_1 == t2_1) then do
    return --[[ () ]]0;
  end else do
    match = t1_1.desc;
    if (typeof match == "number" or match.tag) then do
      return unify_1(do
                  contents: env
                end, t1_1, t2_1);
    end else do
      reset_tracing = check_trace_gadt_instances(env);
      xpcall(function() do
        occur(env, t1_1, t2_1);
        update_level(env, t1_1.level, t2_1);
        link_type(t1_1, t2_1);
        return reset_trace_gadt_instances(reset_tracing);
      end end,function(raw_exn) do
        exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn[0] == Unify) then do
          reset_trace_gadt_instances(reset_tracing);
          expanded_trace = expand_trace(env, --[[ :: ]]{
                --[[ tuple ]]{
                  t1_1,
                  t2_1
                },
                exn[1]
              });
          error({
            Unify,
            expanded_trace
          })
        end else do
          error(exn)
        end end 
      end end)
    end end 
  end end 
end end

unify$prime.contents = unify_var;

function unify_pairs(env, ty1, ty2, pairs) do
  univar_pairs.contents = pairs;
  return unify_1(env, ty1, ty2);
end end

function unify_2(env, ty1, ty2) do
  return unify_pairs(do
              contents: env
            end, ty1, ty2, --[[ [] ]]0);
end end

function expand_head_trace(env, t) do
  reset_tracing = check_trace_gadt_instances(env);
  t_1 = expand_head_unif(env, t);
  reset_trace_gadt_instances(reset_tracing);
  return t_1;
end end

function filter_arrow(env, t, l) do
  t_1 = expand_head_trace(env, t);
  match = t_1.desc;
  if (typeof match == "number") then do
    error({
      Unify,
      --[[ [] ]]0
    })
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 0--[[ Tvar ]] then do
          lv = t_1.level;
          t1 = newty2(lv, --[[ Tvar ]]Block.__(0, {undefined}));
          t2 = newty2(lv, --[[ Tvar ]]Block.__(0, {undefined}));
          t$prime = newty2(lv, --[[ Tarrow ]]Block.__(1, {
                  l,
                  t1,
                  t2,
                  --[[ Cok ]]0
                }));
          link_type(t_1, t$prime);
          return --[[ tuple ]]{
                  t1,
                  t2
                }; end end 
       if ___conditional___ == 1--[[ Tarrow ]] then do
          l$prime = match[0];
          if (l == l$prime or classic.contents and l == "" and not is_optional(l$prime)) then do
            return --[[ tuple ]]{
                    match[1],
                    match[2]
                  };
          end else do
            error({
              Unify,
              --[[ [] ]]0
            })
          end end  end end 
      error({
          Unify,
          --[[ [] ]]0
        })
        
    end
  end end 
end end

function filter_method_field(env, name, priv, _ty) do
  while(true) do
    ty = _ty;
    ty_1 = expand_head_trace(env, ty);
    match = ty_1.desc;
    if (typeof match == "number") then do
      error({
        Unify,
        --[[ [] ]]0
      })
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 0--[[ Tvar ]] then do
            level = ty_1.level;
            ty1 = newty2(level, --[[ Tvar ]]Block.__(0, {undefined}));
            ty2 = newty2(level, --[[ Tvar ]]Block.__(0, {undefined}));
            ty$prime = newty2(level, --[[ Tfield ]]Block.__(5, {
                    name,
                    priv and --[[ Fpresent ]]0 or --[[ Fvar ]]{do
                          contents: undefined
                        end},
                    ty1,
                    ty2
                  }));
            link_type(ty_1, ty$prime);
            return ty1; end end 
         if ___conditional___ == 5--[[ Tfield ]] then do
            kind = field_kind_repr(match[1]);
            if (match[0] == name and kind ~= --[[ Fabsent ]]1) then do
              if (priv == --[[ Public ]]1) then do
                unify_kind(kind, --[[ Fpresent ]]0);
              end
               end 
              return match[2];
            end else do
              _ty = match[3];
              ::continue:: ;
            end end  end end 
        error({
            Unify,
            --[[ [] ]]0
          })
          
      end
    end end 
  end;
end end

function filter_method(env, name, priv, ty) do
  ty_1 = expand_head_trace(env, ty);
  match = ty_1.desc;
  if (typeof match == "number") then do
    error({
      Unify,
      --[[ [] ]]0
    })
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 0--[[ Tvar ]] then do
          ty1 = newvar(undefined, --[[ () ]]0);
          ty$prime = newobj(ty1);
          update_level(env, ty_1.level, ty$prime);
          link_type(ty_1, ty$prime);
          return filter_method_field(env, name, priv, ty1); end end 
       if ___conditional___ == 4--[[ Tobject ]] then do
          return filter_method_field(env, name, priv, match[0]); end end 
      error({
          Unify,
          --[[ [] ]]0
        })
        
    end
  end end 
end end

function filter_self_method(env, lab, priv, meths, ty) do
  ty$prime = filter_method(env, lab, priv, ty);
  xpcall(function() do
    return find(lab, meths.contents);
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      pair_000 = create(lab);
      pair = --[[ tuple ]]{
        pair_000,
        ty$prime
      };
      meths.contents = add_1(lab, pair, meths.contents);
      return pair;
    end else do
      error(exn)
    end end 
  end end)
end end

function moregen_occur(env, level, ty) do
  occur = function(ty) do
    ty_1 = repr(ty);
    if (ty_1.level > level) then do
      if (is_Tvar(ty_1) and ty_1.level >= 99999999) then do
        error(Occur)
      end
       end 
      ty_1.level = pivot_level - ty_1.level | 0;
      match = ty_1.desc;
      if (typeof match == "number" or match.tag ~= --[[ Tvariant ]]8) then do
        return iter_type_expr(occur, ty_1);
      end else do
        row = match[0];
        if (static_row(row)) then do
          return iter_row(occur, row);
        end else do
          return iter_type_expr(occur, ty_1);
        end end 
      end end 
    end else do
      return 0;
    end end 
  end end;
  xpcall(function() do
    occur(ty);
    unmark_type(ty);
  end end,function(exn) do
    if (exn == Occur) then do
      unmark_type(ty);
      error({
        Unify,
        --[[ [] ]]0
      })
    end else do
      error(exn)
    end end 
  end end)
  occur_univar(env, ty);
  return update_level(env, level, ty);
end end

function may_instantiate(inst_nongen, t1) do
  if (inst_nongen) then do
    return t1.level ~= 99999999;
  end else do
    return t1.level == 100000000;
  end end 
end end

function moregen(inst_nongen, type_pairs, env, t1, t2) do
  if (t1 == t2) then do
    return --[[ () ]]0;
  end else do
    t1_1 = repr(t1);
    t2_1 = repr(t2);
    if (t1_1 == t2_1) then do
      return --[[ () ]]0;
    end else do
      xpcall(function() do
        match = t1_1.desc;
        match_1 = t2_1.desc;
        exit = 0;
        if (typeof match == "number") then do
          exit = 1;
        end else do
          local ___conditional___=(match.tag | 0);
          do
             if ___conditional___ == 0--[[ Tvar ]] then do
                if (may_instantiate(inst_nongen, t1_1)) then do
                  moregen_occur(env, t1_1.level, t2_1);
                  occur(env, t1_1, t2_1);
                  return link_type(t1_1, t2_1);
                end else do
                  exit = 1;
                end end  end else 
             if ___conditional___ == 3--[[ Tconstr ]] then do
                if (match[1] or typeof match_1 == "number" or not (match_1.tag == --[[ Tconstr ]]3 and not (match_1[1] or not same(match[0], match_1[0])))) then do
                  exit = 1;
                end else do
                  return --[[ () ]]0;
                end end  end else 
             end end end end
            exit = 1;
              
          end
        end end 
        if (exit == 1) then do
          t1$prime = expand_head(env, t1_1);
          t2$prime = expand_head(env, t2_1);
          t1$prime_1 = repr(t1$prime);
          t2$prime_1 = repr(t2$prime);
          if (t1$prime_1 == t2$prime_1) then do
            return --[[ () ]]0;
          end else do
            xpcall(function() do
              return Curry._2(TypePairs.find, type_pairs, --[[ tuple ]]{
                          t1$prime_1,
                          t2$prime_1
                        });
            end end,function(exn) do
              if (exn == Caml_builtin_exceptions.not_found) then do
                Curry._3(TypePairs.add, type_pairs, --[[ tuple ]]{
                      t1$prime_1,
                      t2$prime_1
                    }, --[[ () ]]0);
                match_2 = t1$prime_1.desc;
                match_3 = t2$prime_1.desc;
                if (typeof match_2 == "number") then do
                  if (typeof match_3 == "number") then do
                    return --[[ () ]]0;
                  end else do
                    error({
                      Unify,
                      --[[ [] ]]0
                    })
                  end end 
                end else do
                  local ___conditional___=(match_2.tag | 0);
                  do
                     if ___conditional___ == 0--[[ Tvar ]] then do
                        if (may_instantiate(inst_nongen, t1$prime_1)) then do
                          moregen_occur(env, t1$prime_1.level, t2_1);
                          return link_type(t1$prime_1, t2_1);
                        end else do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end end  end end 
                     if ___conditional___ == 1--[[ Tarrow ]] then do
                        if (typeof match_3 == "number") then do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end else if (match_3.tag == --[[ Tarrow ]]1) then do
                          l2 = match_3[0];
                          l1 = match_2[0];
                          if (l1 == l2 or classic.contents and not (is_optional(l1) or is_optional(l2))) then do
                            moregen(inst_nongen, type_pairs, env, match_2[1], match_3[1]);
                            return moregen(inst_nongen, type_pairs, env, match_2[2], match_3[2]);
                          end else do
                            error({
                              Unify,
                              --[[ [] ]]0
                            })
                          end end 
                        end else do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end end  end  end end 
                     if ___conditional___ == 2--[[ Ttuple ]] then do
                        if (typeof match_3 == "number") then do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end else if (match_3.tag == --[[ Ttuple ]]2) then do
                          return moregen_list(inst_nongen, type_pairs, env, match_2[0], match_3[0]);
                        end else do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end end  end  end end 
                     if ___conditional___ == 3--[[ Tconstr ]] then do
                        if (typeof match_3 == "number") then do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end else if (match_3.tag == --[[ Tconstr ]]3) then do
                          if (same(match_2[0], match_3[0])) then do
                            return moregen_list(inst_nongen, type_pairs, env, match_2[1], match_3[1]);
                          end else do
                            error({
                              Unify,
                              --[[ [] ]]0
                            })
                          end end 
                        end else do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end end  end  end end 
                     if ___conditional___ == 4--[[ Tobject ]] then do
                        if (typeof match_3 == "number") then do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end else if (match_3.tag == --[[ Tobject ]]4) then do
                          return moregen_fields(inst_nongen, type_pairs, env, match_2[0], match_3[0]);
                        end else do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end end  end  end end 
                     if ___conditional___ == 5--[[ Tfield ]] then do
                        if (typeof match_3 == "number") then do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end else if (match_3.tag == --[[ Tfield ]]5) then do
                          return moregen_fields(inst_nongen, type_pairs, env, t1$prime_1, t2$prime_1);
                        end else do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end end  end  end end 
                     if ___conditional___ == 6--[[ Tlink ]]
                     or ___conditional___ == 7--[[ Tsubst ]] then do
                        error({
                          Unify,
                          --[[ [] ]]0
                        }) end end 
                     if ___conditional___ == 8--[[ Tvariant ]] then do
                        if (typeof match_3 == "number") then do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end else if (match_3.tag == --[[ Tvariant ]]8) then do
                          inst_nongen_1 = inst_nongen;
                          type_pairs_1 = type_pairs;
                          env_1 = env;
                          row1 = match_2[0];
                          row2 = match_3[0];
                          row1_1 = row_repr_aux(--[[ [] ]]0, row1);
                          row2_1 = row_repr_aux(--[[ [] ]]0, row2);
                          rm1 = repr(row1_1.row_more);
                          rm2 = repr(row2_1.row_more);
                          if (rm1 == rm2) then do
                            return --[[ () ]]0;
                          end else do
                            may_inst = is_Tvar(rm1) and may_instantiate(inst_nongen_1, rm1) or rm1.desc == --[[ Tnil ]]0;
                            match_4 = merge_row_fields(row1_1.row_fields, row2_1.row_fields);
                            r2 = match_4[1];
                            r1 = match_4[0];
                            match_5 = row2_1.row_closed and --[[ tuple ]]{
                                filter_row_fields(may_inst, r1),
                                filter_row_fields(false, r2)
                              } or --[[ tuple ]]{
                                r1,
                                r2
                              };
                            r2_1 = match_5[1];
                            if (match_5[0] ~= --[[ [] ]]0 or row1_1.row_closed and (not row2_1.row_closed or r2_1 ~= --[[ [] ]]0)) then do
                              error({
                                Unify,
                                --[[ [] ]]0
                              })
                            end
                             end 
                            match_6 = rm1.desc;
                            match_7 = rm2.desc;
                            exit_1 = 0;
                            exit_2 = 0;
                            if (typeof match_6 == "number" or match_6.tag ~= --[[ Tunivar ]]9) then do
                              exit_2 = 2;
                            end else if (typeof match_7 == "number") then do
                              error({
                                Unify,
                                --[[ [] ]]0
                              })
                            end else if (match_7.tag == --[[ Tunivar ]]9) then do
                              unify_univar(rm1, rm2, univar_pairs.contents);
                            end else do
                              error({
                                Unify,
                                --[[ [] ]]0
                              })
                            end end  end  end 
                            if (exit_2 == 2) then do
                              if (typeof match_7 == "number" or match_7.tag ~= --[[ Tunivar ]]9) then do
                                exit_1 = 1;
                              end else do
                                error({
                                  Unify,
                                  --[[ [] ]]0
                                })
                              end end 
                            end
                             end 
                            if (exit_1 == 1 and not static_row(row1_1)) then do
                              if (may_inst) then do
                                ext = newty2(100000000, --[[ Tvariant ]]Block.__(8, {do
                                          row_fields: r2_1,
                                          row_more: row2_1.row_more,
                                          row_bound: row2_1.row_bound,
                                          row_closed: row2_1.row_closed,
                                          row_fixed: row2_1.row_fixed,
                                          row_name: row2_1.row_name
                                        end}));
                                moregen_occur(env_1, rm1.level, ext);
                                link_type(rm1, ext);
                              end else if (typeof match_6 == "number") then do
                                error({
                                  Unify,
                                  --[[ [] ]]0
                                })
                              end else if (match_6.tag == --[[ Tconstr ]]3) then do
                                if (typeof match_7 == "number") then do
                                  error({
                                    Unify,
                                    --[[ [] ]]0
                                  })
                                end else if (match_7.tag == --[[ Tconstr ]]3) then do
                                  moregen(inst_nongen_1, type_pairs_1, env_1, rm1, rm2);
                                end else do
                                  error({
                                    Unify,
                                    --[[ [] ]]0
                                  })
                                end end  end 
                              end else do
                                error({
                                  Unify,
                                  --[[ [] ]]0
                                })
                              end end  end  end 
                            end
                             end 
                            return List.iter((function(param) do
                                          f1 = row_field_repr_aux(--[[ [] ]]0, param[1]);
                                          f2 = row_field_repr_aux(--[[ [] ]]0, param[2]);
                                          if (f1 == f2) then do
                                            return --[[ () ]]0;
                                          end else if (typeof f1 == "number") then do
                                            if (typeof f2 == "number") then do
                                              return --[[ () ]]0;
                                            end else do
                                              error({
                                                Unify,
                                                --[[ [] ]]0
                                              })
                                            end end 
                                          end else if (f1.tag) then do
                                            c1 = f1[0];
                                            if (c1) then do
                                              if (not f1[1] and typeof f2 ~= "number" and not f2.tag) then do
                                                if (f2[0] ~= undefined) then do
                                                  error({
                                                    Unify,
                                                    --[[ [] ]]0
                                                  })
                                                end
                                                 end 
                                                if (may_inst) then do
                                                  return set_row_field(f1[3], f2);
                                                end else do
                                                  error({
                                                    Unify,
                                                    --[[ [] ]]0
                                                  })
                                                end end 
                                              end
                                               end 
                                            end else if (typeof f2 ~= "number" and not f2.tag) then do
                                              match = f2[0];
                                              if (match ~= undefined) then do
                                                if (may_inst) then do
                                                  t2 = match;
                                                  set_row_field(f1[3], f2);
                                                  return List.iter((function(t1) do
                                                                return moregen(inst_nongen_1, type_pairs_1, env_1, t1, t2);
                                                              end end), f1[1]);
                                                end else do
                                                  error({
                                                    Unify,
                                                    --[[ [] ]]0
                                                  })
                                                end end 
                                              end else do
                                                error({
                                                  Unify,
                                                  --[[ [] ]]0
                                                })
                                              end end 
                                            end
                                             end  end 
                                            e1 = f1[3];
                                            tl1 = f1[1];
                                            if (typeof f2 == "number") then do
                                              if (may_inst) then do
                                                return set_row_field(e1, f2);
                                              end else do
                                                error({
                                                  Unify,
                                                  --[[ [] ]]0
                                                })
                                              end end 
                                            end else if (f2.tag) then do
                                              e2 = f2[3];
                                              if (e1 ~= e2) then do
                                                tl2 = f2[1];
                                                c2 = f2[0];
                                                if (c1 and not c2) then do
                                                  error({
                                                    Unify,
                                                    --[[ [] ]]0
                                                  })
                                                end
                                                 end 
                                                set_row_field(e1, --[[ Reither ]]Block.__(1, {
                                                        c2,
                                                        --[[ [] ]]0,
                                                        f2[2],
                                                        e2
                                                      }));
                                                if (List.length(tl1) == List.length(tl2)) then do
                                                  return List.iter2((function(param, param_1) do
                                                                return moregen(inst_nongen_1, type_pairs_1, env_1, param, param_1);
                                                              end end), tl1, tl2);
                                                end else if (tl2) then do
                                                  t2_1 = tl2[0];
                                                  return List.iter((function(t1) do
                                                                return moregen(inst_nongen_1, type_pairs_1, env_1, t1, t2_1);
                                                              end end), tl1);
                                                end else if (tl1 ~= --[[ [] ]]0) then do
                                                  error({
                                                    Unify,
                                                    --[[ [] ]]0
                                                  })
                                                end else do
                                                  return 0;
                                                end end  end  end 
                                              end else do
                                                return 0;
                                              end end 
                                            end else do
                                              error({
                                                Unify,
                                                --[[ [] ]]0
                                              })
                                            end end  end 
                                          end else do
                                            match_1 = f1[0];
                                            if (match_1 ~= undefined) then do
                                              if (typeof f2 == "number") then do
                                                error({
                                                  Unify,
                                                  --[[ [] ]]0
                                                })
                                              end else if (f2.tag) then do
                                                error({
                                                  Unify,
                                                  --[[ [] ]]0
                                                })
                                              end else do
                                                match_2 = f2[0];
                                                if (match_2 ~= undefined) then do
                                                  return moregen(inst_nongen_1, type_pairs_1, env_1, match_1, match_2);
                                                end else do
                                                  error({
                                                    Unify,
                                                    --[[ [] ]]0
                                                  })
                                                end end 
                                              end end  end 
                                            end else if (typeof f2 == "number") then do
                                              error({
                                                Unify,
                                                --[[ [] ]]0
                                              })
                                            end else if (f2.tag) then do
                                              error({
                                                Unify,
                                                --[[ [] ]]0
                                              })
                                            end else if (f2[0] ~= undefined) then do
                                              error({
                                                Unify,
                                                --[[ [] ]]0
                                              })
                                            end else do
                                              return --[[ () ]]0;
                                            end end  end  end  end 
                                          end end  end  end 
                                        end end), match_4[2]);
                          end end 
                        end else do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end end  end  end end 
                     if ___conditional___ == 9--[[ Tunivar ]] then do
                        if (typeof match_3 == "number") then do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end else if (match_3.tag == --[[ Tunivar ]]9) then do
                          return unify_univar(t1$prime_1, t2$prime_1, univar_pairs.contents);
                        end else do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end end  end  end end 
                     if ___conditional___ == 10--[[ Tpoly ]] then do
                        tl1 = match_2[1];
                        t1_2 = match_2[0];
                        exit_3 = 0;
                        if (tl1) then do
                          exit_3 = 2;
                        end else if (typeof match_3 == "number") then do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end else if (match_3.tag == --[[ Tpoly ]]10) then do
                          if (match_3[1]) then do
                            exit_3 = 2;
                          end else do
                            return moregen(inst_nongen, type_pairs, env, t1_2, match_3[0]);
                          end end 
                        end else do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end end  end  end 
                        if (exit_3 == 2) then do
                          if (typeof match_3 == "number") then do
                            error({
                              Unify,
                              --[[ [] ]]0
                            })
                          end else if (match_3.tag == --[[ Tpoly ]]10) then do
                            return enter_poly(env, univar_pairs, t1_2, tl1, match_3[0], match_3[1], (function(param, param_1) do
                                          return moregen(inst_nongen, type_pairs, env, param, param_1);
                                        end end));
                          end else do
                            error({
                              Unify,
                              --[[ [] ]]0
                            })
                          end end  end 
                        end
                         end  end else 
                     if ___conditional___ == 11--[[ Tpackage ]] then do
                        if (typeof match_3 == "number") then do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end else if (match_3.tag == --[[ Tpackage ]]11) then do
                          xpcall(function() do
                            return unify_package(env, (function(param, param_1) do
                                          return moregen_list(inst_nongen, type_pairs, env, param, param_1);
                                        end end), t1$prime_1.level, match_2[0], match_2[1], match_2[2], t2$prime_1.level, match_3[0], match_3[1], match_3[2]);
                          end end,function(exn_1) do
                            if (exn_1 == Caml_builtin_exceptions.not_found) then do
                              error({
                                Unify,
                                --[[ [] ]]0
                              })
                            end
                             end 
                            error(exn_1)
                          end end)
                        end else do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end end  end  end end end end 
                    
                  end
                end end 
              end else do
                error(exn)
              end end 
            end end)
          end end 
        end
         end 
      end end,function(raw_exn) do
        exn_2 = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn_2[0] == Unify) then do
          error({
            Unify,
            --[[ :: ]]{
              --[[ tuple ]]{
                t1_1,
                t2_1
              },
              exn_2[1]
            }
          })
        end
         end 
        error(exn_2)
      end end)
    end end 
  end end 
end end

function moregen_list(inst_nongen, type_pairs, env, tl1, tl2) do
  if (List.length(tl1) ~= List.length(tl2)) then do
    error({
      Unify,
      --[[ [] ]]0
    })
  end
   end 
  return List.iter2((function(param, param_1) do
                return moregen(inst_nongen, type_pairs, env, param, param_1);
              end end), tl1, tl2);
end end

function moregen_fields(inst_nongen, type_pairs, env, ty1, ty2) do
  match = flatten_fields(ty1);
  match_1 = flatten_fields(ty2);
  rest2 = match_1[1];
  match_2 = associate_fields(match[0], match_1[0]);
  if (match_2[1] ~= --[[ [] ]]0) then do
    error({
      Unify,
      --[[ [] ]]0
    })
  end
   end 
  moregen(inst_nongen, type_pairs, env, match[1], build_fields(repr(ty2).level)(match_2[2], rest2));
  return List.iter((function(param) do
                t2 = param[4];
                k2 = param[3];
                t1 = param[2];
                k1 = param[1];
                n = param[0];
                moregen_kind(k1, k2);
                xpcall(function() do
                  return moregen(inst_nongen, type_pairs, env, t1, t2);
                end end,function(raw_exn) do
                  exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                  if (exn[0] == Unify) then do
                    error({
                      Unify,
                      --[[ :: ]]{
                        --[[ tuple ]]{
                          newty2(current_level.contents, --[[ Tfield ]]Block.__(5, {
                                  n,
                                  k1,
                                  t1,
                                  rest2
                                })),
                          newty2(current_level.contents, --[[ Tfield ]]Block.__(5, {
                                  n,
                                  k2,
                                  t2,
                                  rest2
                                }))
                        },
                        exn[1]
                      }
                    })
                  end
                   end 
                  error(exn)
                end end)
              end end), match_2[0]);
end end

function moregen_kind(k1, k2) do
  k1_1 = field_kind_repr(k1);
  k2_1 = field_kind_repr(k2);
  if (k1_1 == k2_1) then do
    return --[[ () ]]0;
  end else if (typeof k1_1 == "number") then do
    if (k1_1 ~= 0) then do
      error({
        Unify,
        --[[ [] ]]0
      })
    end
     end 
    if (typeof k2_1 == "number") then do
      if (k2_1 ~= 0) then do
        error({
          Unify,
          --[[ [] ]]0
        })
      end else do
        return --[[ () ]]0;
      end end 
    end else do
      error({
        Unify,
        --[[ [] ]]0
      })
    end end 
  end else do
    r = k1_1[0];
    if (typeof k2_1 == "number") then do
      if (k2_1 ~= 0) then do
        error({
          Unify,
          --[[ [] ]]0
        })
      end
       end 
      return set_kind(r, k2_1);
    end else do
      return set_kind(r, k2_1);
    end end 
  end end  end 
end end

function moregen_1(inst_nongen, type_pairs, env, patt, subj) do
  univar_pairs.contents = --[[ [] ]]0;
  return moregen(inst_nongen, type_pairs, env, patt, subj);
end end

function moregeneral(env, inst_nongen, pat_sch, subj_sch) do
  old_level = current_level.contents;
  current_level.contents = 99999999;
  ty = instance(undefined, env, subj_sch);
  subj = type_expr(identity, ty);
  current_level.contents = 100000000;
  patt = instance(undefined, env, pat_sch);
  res;
  xpcall(function() do
    moregen_1(inst_nongen, Curry._1(TypePairs.create, 13), env, patt, subj);
    res = true;
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      res = false;
    end else do
      error(exn)
    end end 
  end end)
  current_level.contents = old_level;
  return res;
end end

function rigidify_rec(vars, _ty) do
  while(true) do
    ty = _ty;
    ty_1 = repr(ty);
    if (ty_1.level >= 0) then do
      ty_1.level = pivot_level - ty_1.level | 0;
      match = ty_1.desc;
      if (typeof match == "number") then do
        return iter_type_expr((function(param) do
                      return rigidify_rec(vars, param);
                    end end), ty_1);
      end else do
        local ___conditional___=(match.tag | 0);
        do
           if ___conditional___ == 0--[[ Tvar ]] then do
              if (List.memq(ty_1, vars.contents)) then do
                return 0;
              end else do
                vars.contents = --[[ :: ]]{
                  ty_1,
                  vars.contents
                };
                return --[[ () ]]0;
              end end  end end 
           if ___conditional___ == 8--[[ Tvariant ]] then do
              row = row_repr_aux(--[[ [] ]]0, match[0]);
              more = repr(row.row_more);
              if (is_Tvar(more) and not row_fixed(row)) then do
                more$prime = newty2(more.level, more.desc);
                row$prime_row_bound = row.row_bound;
                row$prime_row_closed = row.row_closed;
                row$prime_row_name = row.row_name;
                row$prime = do
                  row_fields: --[[ [] ]]0,
                  row_more: more$prime,
                  row_bound: row$prime_row_bound,
                  row_closed: row$prime_row_closed,
                  row_fixed: true,
                  row_name: row$prime_row_name
                end;
                link_type(more, newty2(ty_1.level, --[[ Tvariant ]]Block.__(8, {row$prime})));
              end
               end 
              iter_row((function(param) do
                      return rigidify_rec(vars, param);
                    end end), row);
              if (static_row(row)) then do
                return 0;
              end else do
                _ty = row_more(row);
                ::continue:: ;
              end end  end end 
          return iter_type_expr((function(param) do
                          return rigidify_rec(vars, param);
                        end end), ty_1);
            
        end
      end end 
    end else do
      return 0;
    end end 
  end;
end end

function rigidify(ty) do
  vars = do
    contents: --[[ [] ]]0
  end;
  rigidify_rec(vars, ty);
  unmark_type(ty);
  return vars.contents;
end end

function all_distinct_vars(env, vars) do
  tyl = do
    contents: --[[ [] ]]0
  end;
  return List.for_all((function(ty) do
                ty_1 = expand_head(env, ty);
                if (List.memq(ty_1, tyl.contents)) then do
                  return false;
                end else do
                  tyl.contents = --[[ :: ]]{
                    ty_1,
                    tyl.contents
                  };
                  return is_Tvar(ty_1);
                end end 
              end end), vars);
end end

function matches(env, ty, ty$prime) do
  snap = snapshot(--[[ () ]]0);
  vars = rigidify(ty);
  cleanup_abbrev(--[[ () ]]0);
  ok;
  xpcall(function() do
    unify_2(env, ty, ty$prime);
    ok = all_distinct_vars(env, vars);
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      ok = false;
    end else do
      error(exn)
    end end 
  end end)
  backtrack(snap);
  return ok;
end end

function expand_head_rigid(env, ty) do
  old = rigid_variants.contents;
  rigid_variants.contents = true;
  ty$prime = expand_head(env, ty);
  rigid_variants.contents = old;
  return ty$prime;
end end

function normalize_subst(subst) do
  if (List.exists((function(param) do
            match = param[0].desc;
            if (typeof match ~= "number" and match.tag == --[[ Tlink ]]6) then do
              return true;
            end
             end 
            match_1 = param[1].desc;
            return typeof match_1 == "number" or match_1.tag ~= --[[ Tlink ]]6 and false or true;
          end end), subst.contents)) then do
    subst.contents = List.map((function(param) do
            return --[[ tuple ]]{
                    repr(param[0]),
                    repr(param[1])
                  };
          end end), subst.contents);
    return --[[ () ]]0;
  end else do
    return 0;
  end end 
end end

function eqtype(rename, type_pairs, subst, env, t1, t2) do
  if (t1 == t2) then do
    return --[[ () ]]0;
  end else do
    t1_1 = repr(t1);
    t2_1 = repr(t2);
    if (t1_1 == t2_1) then do
      return --[[ () ]]0;
    end else do
      xpcall(function() do
        match = t1_1.desc;
        match_1 = t2_1.desc;
        exit = 0;
        if (typeof match == "number") then do
          exit = 1;
        end else do
          local ___conditional___=(match.tag | 0);
          do
             if ___conditional___ == 0--[[ Tvar ]] then do
                if (typeof match_1 == "number" or match_1.tag or not rename) then do
                  exit = 1;
                end else do
                  xpcall(function() do
                    normalize_subst(subst);
                    if (List.assq(t1_1, subst.contents) ~= t2_1) then do
                      error({
                        Unify,
                        --[[ [] ]]0
                      })
                    end else do
                      return 0;
                    end end 
                  end end,function(exn) do
                    if (exn == Caml_builtin_exceptions.not_found) then do
                      if (List.exists((function(param) do
                                return param[1] == t2_1;
                              end end), subst.contents)) then do
                        error({
                          Unify,
                          --[[ [] ]]0
                        })
                      end
                       end 
                      subst.contents = --[[ :: ]]{
                        --[[ tuple ]]{
                          t1_1,
                          t2_1
                        },
                        subst.contents
                      };
                      return --[[ () ]]0;
                    end else do
                      error(exn)
                    end end 
                  end end)
                end end  end else 
             if ___conditional___ == 3--[[ Tconstr ]] then do
                if (match[1] or typeof match_1 == "number" or not (match_1.tag == --[[ Tconstr ]]3 and not (match_1[1] or not same(match[0], match_1[0])))) then do
                  exit = 1;
                end else do
                  return --[[ () ]]0;
                end end  end else 
             end end end end
            exit = 1;
              
          end
        end end 
        if (exit == 1) then do
          t1$prime = expand_head_rigid(env, t1_1);
          t2$prime = expand_head_rigid(env, t2_1);
          t1$prime_1 = repr(t1$prime);
          t2$prime_1 = repr(t2$prime);
          if (t1$prime_1 == t2$prime_1) then do
            return --[[ () ]]0;
          end else do
            xpcall(function() do
              return Curry._2(TypePairs.find, type_pairs, --[[ tuple ]]{
                          t1$prime_1,
                          t2$prime_1
                        });
            end end,function(exn_1) do
              if (exn_1 == Caml_builtin_exceptions.not_found) then do
                Curry._3(TypePairs.add, type_pairs, --[[ tuple ]]{
                      t1$prime_1,
                      t2$prime_1
                    }, --[[ () ]]0);
                match_2 = t1$prime_1.desc;
                match_3 = t2$prime_1.desc;
                if (typeof match_2 == "number") then do
                  if (typeof match_3 == "number") then do
                    return --[[ () ]]0;
                  end else do
                    error({
                      Unify,
                      --[[ [] ]]0
                    })
                  end end 
                end else do
                  local ___conditional___=(match_2.tag | 0);
                  do
                     if ___conditional___ == 0--[[ Tvar ]] then do
                        if (typeof match_3 == "number") then do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end else if (match_3.tag) then do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end else if (rename) then do
                          xpcall(function() do
                            normalize_subst(subst);
                            if (List.assq(t1$prime_1, subst.contents) ~= t2$prime_1) then do
                              error({
                                Unify,
                                --[[ [] ]]0
                              })
                            end else do
                              return 0;
                            end end 
                          end end,function(exn_2) do
                            if (exn_2 == Caml_builtin_exceptions.not_found) then do
                              if (List.exists((function(param) do
                                        return param[1] == t2$prime_1;
                                      end end), subst.contents)) then do
                                error({
                                  Unify,
                                  --[[ [] ]]0
                                })
                              end
                               end 
                              subst.contents = --[[ :: ]]{
                                --[[ tuple ]]{
                                  t1$prime_1,
                                  t2$prime_1
                                },
                                subst.contents
                              };
                              return --[[ () ]]0;
                            end else do
                              error(exn_2)
                            end end 
                          end end)
                        end else do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end end  end  end  end end 
                     if ___conditional___ == 1--[[ Tarrow ]] then do
                        if (typeof match_3 == "number") then do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end else if (match_3.tag == --[[ Tarrow ]]1) then do
                          l2 = match_3[0];
                          l1 = match_2[0];
                          if (l1 == l2 or classic.contents and not (is_optional(l1) or is_optional(l2))) then do
                            eqtype(rename, type_pairs, subst, env, match_2[1], match_3[1]);
                            return eqtype(rename, type_pairs, subst, env, match_2[2], match_3[2]);
                          end else do
                            error({
                              Unify,
                              --[[ [] ]]0
                            })
                          end end 
                        end else do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end end  end  end end 
                     if ___conditional___ == 2--[[ Ttuple ]] then do
                        if (typeof match_3 == "number") then do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end else if (match_3.tag == --[[ Ttuple ]]2) then do
                          return eqtype_list(rename, type_pairs, subst, env, match_2[0], match_3[0]);
                        end else do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end end  end  end end 
                     if ___conditional___ == 3--[[ Tconstr ]] then do
                        if (typeof match_3 == "number") then do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end else if (match_3.tag == --[[ Tconstr ]]3) then do
                          if (same(match_2[0], match_3[0])) then do
                            return eqtype_list(rename, type_pairs, subst, env, match_2[1], match_3[1]);
                          end else do
                            error({
                              Unify,
                              --[[ [] ]]0
                            })
                          end end 
                        end else do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end end  end  end end 
                     if ___conditional___ == 4--[[ Tobject ]] then do
                        if (typeof match_3 == "number") then do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end else if (match_3.tag == --[[ Tobject ]]4) then do
                          return eqtype_fields(rename, type_pairs, subst, env, match_2[0], match_3[0]);
                        end else do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end end  end  end end 
                     if ___conditional___ == 5--[[ Tfield ]] then do
                        if (typeof match_3 == "number") then do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end else if (match_3.tag == --[[ Tfield ]]5) then do
                          return eqtype_fields(rename, type_pairs, subst, env, t1$prime_1, t2$prime_1);
                        end else do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end end  end  end end 
                     if ___conditional___ == 6--[[ Tlink ]]
                     or ___conditional___ == 7--[[ Tsubst ]] then do
                        error({
                          Unify,
                          --[[ [] ]]0
                        }) end end 
                     if ___conditional___ == 8--[[ Tvariant ]] then do
                        if (typeof match_3 == "number") then do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end else if (match_3.tag == --[[ Tvariant ]]8) then do
                          rename_1 = rename;
                          type_pairs_1 = type_pairs;
                          subst_1 = subst;
                          env_1 = env;
                          row1 = match_2[0];
                          _row2 = match_3[0];
                          while(true) do
                            row2 = _row2;
                            match_4 = expand_head_rigid(env_1, row_more(row2));
                            match_5 = match_4.desc;
                            if (typeof match_5 ~= "number" and match_5.tag == --[[ Tvariant ]]8) then do
                              _row2 = match_5[0];
                              ::continue:: ;
                            end
                             end 
                            row1_1 = row_repr_aux(--[[ [] ]]0, row1);
                            row2_1 = row_repr_aux(--[[ [] ]]0, row2);
                            match_6 = merge_row_fields(row1_1.row_fields, row2_1.row_fields);
                            r2 = match_6[1];
                            r1 = match_6[0];
                            if (row1_1.row_closed ~= row2_1.row_closed or not row1_1.row_closed and (r1 ~= --[[ [] ]]0 or r2 ~= --[[ [] ]]0) or filter_row_fields(false, Pervasives.$at(r1, r2)) ~= --[[ [] ]]0) then do
                              error({
                                Unify,
                                --[[ [] ]]0
                              })
                            end
                             end 
                            if (not static_row(row1_1)) then do
                              eqtype(rename_1, type_pairs_1, subst_1, env_1, row1_1.row_more, row2_1.row_more);
                            end
                             end 
                            return List.iter((function(param) do
                                          match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                                          match_1 = row_field_repr_aux(--[[ [] ]]0, param[2]);
                                          if (typeof match == "number") then do
                                            if (typeof match_1 == "number") then do
                                              return --[[ () ]]0;
                                            end else do
                                              error({
                                                Unify,
                                                --[[ [] ]]0
                                              })
                                            end end 
                                          end else if (match.tag) then do
                                            if (match[0]) then do
                                              if (match[1]) then do
                                                error({
                                                  Unify,
                                                  --[[ [] ]]0
                                                })
                                              end
                                               end 
                                              if (typeof match_1 == "number") then do
                                                error({
                                                  Unify,
                                                  --[[ [] ]]0
                                                })
                                              end else if (match_1.tag) then do
                                                if (match_1[0]) then do
                                                  if (match_1[1]) then do
                                                    error({
                                                      Unify,
                                                      --[[ [] ]]0
                                                    })
                                                  end
                                                   end 
                                                  return --[[ () ]]0;
                                                end else do
                                                  error({
                                                    Unify,
                                                    --[[ [] ]]0
                                                  })
                                                end end 
                                              end else do
                                                error({
                                                  Unify,
                                                  --[[ [] ]]0
                                                })
                                              end end  end 
                                            end else do
                                              match_2 = match[1];
                                              if (match_2) then do
                                                tl1 = match_2[1];
                                                t1 = match_2[0];
                                                if (typeof match_1 == "number") then do
                                                  error({
                                                    Unify,
                                                    --[[ [] ]]0
                                                  })
                                                end else if (match_1.tag) then do
                                                  if (match_1[0]) then do
                                                    error({
                                                      Unify,
                                                      --[[ [] ]]0
                                                    })
                                                  end
                                                   end 
                                                  match_3 = match_1[1];
                                                  if (match_3) then do
                                                    tl2 = match_3[1];
                                                    t2 = match_3[0];
                                                    eqtype(rename_1, type_pairs_1, subst_1, env_1, t1, t2);
                                                    if (List.length(tl1) == List.length(tl2)) then do
                                                      return List.iter2((function(param, param_1) do
                                                                    return eqtype(rename_1, type_pairs_1, subst_1, env_1, param, param_1);
                                                                  end end), tl1, tl2);
                                                    end else do
                                                      List.iter((function(param) do
                                                              return eqtype(rename_1, type_pairs_1, subst_1, env_1, t1, param);
                                                            end end), tl2);
                                                      return List.iter((function(t1) do
                                                                    return eqtype(rename_1, type_pairs_1, subst_1, env_1, t1, t2);
                                                                  end end), tl1);
                                                    end end 
                                                  end else do
                                                    error({
                                                      Unify,
                                                      --[[ [] ]]0
                                                    })
                                                  end end 
                                                end else do
                                                  error({
                                                    Unify,
                                                    --[[ [] ]]0
                                                  })
                                                end end  end 
                                              end else do
                                                error({
                                                  Unify,
                                                  --[[ [] ]]0
                                                })
                                              end end 
                                            end end 
                                          end else do
                                            match_4 = match[0];
                                            if (match_4 ~= undefined) then do
                                              if (typeof match_1 == "number") then do
                                                error({
                                                  Unify,
                                                  --[[ [] ]]0
                                                })
                                              end else if (match_1.tag) then do
                                                error({
                                                  Unify,
                                                  --[[ [] ]]0
                                                })
                                              end else do
                                                match_5 = match_1[0];
                                                if (match_5 ~= undefined) then do
                                                  return eqtype(rename_1, type_pairs_1, subst_1, env_1, match_4, match_5);
                                                end else do
                                                  error({
                                                    Unify,
                                                    --[[ [] ]]0
                                                  })
                                                end end 
                                              end end  end 
                                            end else if (typeof match_1 == "number") then do
                                              error({
                                                Unify,
                                                --[[ [] ]]0
                                              })
                                            end else if (match_1.tag) then do
                                              error({
                                                Unify,
                                                --[[ [] ]]0
                                              })
                                            end else if (match_1[0] ~= undefined) then do
                                              error({
                                                Unify,
                                                --[[ [] ]]0
                                              })
                                            end else do
                                              return --[[ () ]]0;
                                            end end  end  end  end 
                                          end end  end 
                                        end end), match_6[2]);
                          end;
                        end else do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end end  end  end end 
                     if ___conditional___ == 9--[[ Tunivar ]] then do
                        if (typeof match_3 == "number") then do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end else if (match_3.tag == --[[ Tunivar ]]9) then do
                          return unify_univar(t1$prime_1, t2$prime_1, univar_pairs.contents);
                        end else do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end end  end  end end 
                     if ___conditional___ == 10--[[ Tpoly ]] then do
                        tl1 = match_2[1];
                        t1_2 = match_2[0];
                        exit_1 = 0;
                        if (tl1) then do
                          exit_1 = 2;
                        end else if (typeof match_3 == "number") then do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end else if (match_3.tag == --[[ Tpoly ]]10) then do
                          if (match_3[1]) then do
                            exit_1 = 2;
                          end else do
                            return eqtype(rename, type_pairs, subst, env, t1_2, match_3[0]);
                          end end 
                        end else do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end end  end  end 
                        if (exit_1 == 2) then do
                          if (typeof match_3 == "number") then do
                            error({
                              Unify,
                              --[[ [] ]]0
                            })
                          end else if (match_3.tag == --[[ Tpoly ]]10) then do
                            return enter_poly(env, univar_pairs, t1_2, tl1, match_3[0], match_3[1], (function(param, param_1) do
                                          return eqtype(rename, type_pairs, subst, env, param, param_1);
                                        end end));
                          end else do
                            error({
                              Unify,
                              --[[ [] ]]0
                            })
                          end end  end 
                        end
                         end  end else 
                     if ___conditional___ == 11--[[ Tpackage ]] then do
                        if (typeof match_3 == "number") then do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end else if (match_3.tag == --[[ Tpackage ]]11) then do
                          xpcall(function() do
                            return unify_package(env, (function(param, param_1) do
                                          return eqtype_list(rename, type_pairs, subst, env, param, param_1);
                                        end end), t1$prime_1.level, match_2[0], match_2[1], match_2[2], t2$prime_1.level, match_3[0], match_3[1], match_3[2]);
                          end end,function(exn_3) do
                            if (exn_3 == Caml_builtin_exceptions.not_found) then do
                              error({
                                Unify,
                                --[[ [] ]]0
                              })
                            end
                             end 
                            error(exn_3)
                          end end)
                        end else do
                          error({
                            Unify,
                            --[[ [] ]]0
                          })
                        end end  end  end end end end 
                    
                  end
                end end 
              end else do
                error(exn_1)
              end end 
            end end)
          end end 
        end
         end 
      end end,function(raw_exn) do
        exn_4 = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn_4[0] == Unify) then do
          error({
            Unify,
            --[[ :: ]]{
              --[[ tuple ]]{
                t1_1,
                t2_1
              },
              exn_4[1]
            }
          })
        end
         end 
        error(exn_4)
      end end)
    end end 
  end end 
end end

function eqtype_list(rename, type_pairs, subst, env, tl1, tl2) do
  if (List.length(tl1) ~= List.length(tl2)) then do
    error({
      Unify,
      --[[ [] ]]0
    })
  end
   end 
  return List.iter2((function(param, param_1) do
                return eqtype(rename, type_pairs, subst, env, param, param_1);
              end end), tl1, tl2);
end end

function eqtype_fields(rename, type_pairs, subst, env, ty1, _ty2) do
  while(true) do
    ty2 = _ty2;
    match = flatten_fields(ty1);
    rest1 = match[1];
    match_1 = flatten_fields(ty2);
    rest2 = match_1[1];
    same_row = rest1 == rest2 or Curry._2(TypePairs.mem, type_pairs, --[[ tuple ]]{
          rest1,
          rest2
        }) or rename and List.mem(--[[ tuple ]]{
          rest1,
          rest2
        }, subst.contents);
    if (same_row) then do
      return --[[ () ]]0;
    end else do
      match_2 = expand_head_rigid(env, rest2);
      match_3 = match_2.desc;
      if (typeof match_3 ~= "number" and match_3.tag == --[[ Tobject ]]4) then do
        _ty2 = match_3[0];
        ::continue:: ;
      end
       end 
      match_4 = associate_fields(match[0], match_1[0]);
      eqtype(rename, type_pairs, subst, env, rest1, rest2);
      if (match_4[1] ~= --[[ [] ]]0 or match_4[2] ~= --[[ [] ]]0) then do
        error({
          Unify,
          --[[ [] ]]0
        })
      end
       end 
      return List.iter((function(rest2)do
                return function (param) do
                  t2 = param[4];
                  k2 = param[3];
                  t1 = param[2];
                  k1 = param[1];
                  n = param[0];
                  eqtype_kind(k1, k2);
                  xpcall(function() do
                    return eqtype(rename, type_pairs, subst, env, t1, t2);
                  end end,function(raw_exn) do
                    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn[0] == Unify) then do
                      error({
                        Unify,
                        --[[ :: ]]{
                          --[[ tuple ]]{
                            newty2(current_level.contents, --[[ Tfield ]]Block.__(5, {
                                    n,
                                    k1,
                                    t1,
                                    rest2
                                  })),
                            newty2(current_level.contents, --[[ Tfield ]]Block.__(5, {
                                    n,
                                    k2,
                                    t2,
                                    rest2
                                  }))
                          },
                          exn[1]
                        }
                      })
                    end
                     end 
                    error(exn)
                  end end)
                end end
                end end)(rest2), match_4[0]);
    end end 
  end;
end end

function eqtype_kind(k1, k2) do
  k1_1 = field_kind_repr(k1);
  k2_1 = field_kind_repr(k2);
  if (typeof k1_1 == "number") then do
    if (k1_1 ~= 0) then do
      error({
        Unify,
        --[[ [] ]]0
      })
    end
     end 
    if (typeof k2_1 == "number") then do
      if (k2_1 ~= 0) then do
        error({
          Unify,
          --[[ [] ]]0
        })
      end else do
        return --[[ () ]]0;
      end end 
    end else do
      error({
        Unify,
        --[[ [] ]]0
      })
    end end 
  end else do
    if (typeof k2_1 == "number") then do
      error({
        Unify,
        --[[ [] ]]0
      })
    end
     end 
    return --[[ () ]]0;
  end end 
end end

function equal_4(env, rename, tyl1, tyl2) do
  xpcall(function() do
    univar_pairs.contents = --[[ [] ]]0;
    eqtype_list(rename, Curry._1(TypePairs.create, 11), do
          contents: --[[ [] ]]0
        end, env, tyl1, tyl2);
    return true;
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      return false;
    end else do
      error(exn)
    end end 
  end end)
end end

function eqtype_1(rename, type_pairs, subst, env, t1, t2) do
  univar_pairs.contents = --[[ [] ]]0;
  return eqtype(rename, type_pairs, subst, env, t1, t2);
end end

Failure = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Failure");

function moregen_clty(trace, type_pairs, env, cty1, cty2) do
  xpcall(function() do
    exit = 0;
    local ___conditional___=(cty1.tag | 0);
    do
       if ___conditional___ == 0--[[ Cty_constr ]] then do
          return moregen_clty(true, type_pairs, env, cty1[2], cty2); end end 
       if ___conditional___ == 1--[[ Cty_signature ]] then do
          sign1 = cty1[0];
          local ___conditional___=(cty2.tag | 0);
          do
             if ___conditional___ == 0--[[ Cty_constr ]] then do
                exit = 1; end else 
             if ___conditional___ == 1--[[ Cty_signature ]] then do
                sign2 = cty2[0];
                ty1 = object_fields(repr(sign1.csig_self));
                ty2 = object_fields(repr(sign2.csig_self));
                match = flatten_fields(ty1);
                match_1 = flatten_fields(ty2);
                match_2 = associate_fields(match[0], match_1[0]);
                List.iter((function(param) do
                        xpcall(function() do
                          return moregen_1(true, type_pairs, env, param[2], param[4]);
                        end end,function(raw_exn) do
                          exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                          if (exn[0] == Unify) then do
                            error({
                              Failure,
                              --[[ :: ]]{
                                --[[ CM_Meth_type_mismatch ]]Block.__(5, {
                                    param[0],
                                    env,
                                    expand_trace(env, exn[1])
                                  }),
                                --[[ [] ]]0
                              }
                            })
                          end
                           end 
                          error(exn)
                        end end)
                      end end), match_2[0]);
                return iter_1((function(lab, param) do
                              match = find(lab, sign1.csig_vars);
                              xpcall(function() do
                                return moregen_1(true, type_pairs, env, match[2], param[2]);
                              end end,function(raw_exn) do
                                exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                                if (exn[0] == Unify) then do
                                  error({
                                    Failure,
                                    --[[ :: ]]{
                                      --[[ CM_Val_type_mismatch ]]Block.__(4, {
                                          lab,
                                          env,
                                          expand_trace(env, exn[1])
                                        }),
                                      --[[ [] ]]0
                                    }
                                  })
                                end
                                 end 
                                error(exn)
                              end end)
                            end end), sign2.csig_vars); end end end end 
             if ___conditional___ == 2--[[ Cty_arrow ]] then do
                error({
                  Failure,
                  --[[ [] ]]0
                }) end end 
            
          end end else 
       if ___conditional___ == 2--[[ Cty_arrow ]] then do
          local ___conditional___=(cty2.tag | 0);
          do
             if ___conditional___ == 0--[[ Cty_constr ]] then do
                exit = 1; end else 
             if ___conditional___ == 1--[[ Cty_signature ]] then do
                error({
                  Failure,
                  --[[ [] ]]0
                }) end end end end 
             if ___conditional___ == 2--[[ Cty_arrow ]] then do
                if (cty1[0] == cty2[0]) then do
                  xpcall(function() do
                    moregen_1(true, type_pairs, env, cty1[1], cty2[1]);
                  end end,function(raw_exn) do
                    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn[0] == Unify) then do
                      error({
                        Failure,
                        --[[ :: ]]{
                          --[[ CM_Parameter_mismatch ]]Block.__(3, {
                              env,
                              expand_trace(env, exn[1])
                            }),
                          --[[ [] ]]0
                        }
                      })
                    end
                     end 
                    error(exn)
                  end end)
                  return moregen_clty(false, type_pairs, env, cty1[2], cty2[2]);
                end else do
                  error({
                    Failure,
                    --[[ [] ]]0
                  })
                end end  end end 
            
          end end else 
       end end end end
      
    end
    if (exit == 1) then do
      return moregen_clty(true, type_pairs, env, cty1, cty2[2]);
    end
     end 
  end end,function(raw_exn_1) do
    exn_1 = Caml_js_exceptions.internalToOCamlException(raw_exn_1);
    if (exn_1[0] == Failure) then do
      error = exn_1[1];
      if (trace or error == --[[ [] ]]0) then do
        error({
          Failure,
          --[[ :: ]]{
            --[[ CM_Class_type_mismatch ]]Block.__(2, {
                env,
                cty1,
                cty2
              }),
            error
          }
        })
      end
       end 
      error(exn_1)
    end else do
      error(exn_1)
    end end 
  end end)
end end

function match_class_types(traceOpt, env, pat_sch, subj_sch) do
  trace = traceOpt ~= undefined and traceOpt or true;
  type_pairs = Curry._1(TypePairs.create, 53);
  old_level = current_level.contents;
  current_level.contents = 99999999;
  match = instance_class(--[[ [] ]]0, subj_sch);
  subj = class_type_1(identity, match[1]);
  current_level.contents = 100000000;
  match_1 = instance_class(--[[ [] ]]0, pat_sch);
  patt = match_1[1];
  sign1 = signature_of_class_type(patt);
  sign2 = signature_of_class_type(subj);
  t1 = repr(sign1.csig_self);
  t2 = repr(sign2.csig_self);
  Curry._3(TypePairs.add, type_pairs, --[[ tuple ]]{
        t1,
        t2
      }, --[[ () ]]0);
  match_2 = flatten_fields(object_fields(t1));
  match_3 = flatten_fields(object_fields(t2));
  match_4 = associate_fields(match_2[0], match_3[0]);
  error = List.fold_right((function(param, err) do
          lab = param[0];
          k = field_kind_repr(param[1]);
          err_1 = typeof k == "number" and --[[ :: ]]{
              --[[ CM_Hide_public ]]Block.__(10, {lab}),
              err
            } or (set_kind(k[0], --[[ Fabsent ]]1), err);
          if (mem_2(lab, sign1.csig_concr)) then do
            return err_1;
          end else do
            return --[[ :: ]]{
                    --[[ CM_Hide_virtual ]]Block.__(11, {
                        "method",
                        lab
                      }),
                    err_1
                  };
          end end 
        end end), match_4[1], --[[ [] ]]0);
  missing_method = List.map((function(param) do
          return param[0];
        end end), match_4[2]);
  error_1 = Pervasives.$at(List.map((function(m) do
              return --[[ CM_Missing_method ]]Block.__(9, {m});
            end end), missing_method), error);
  moregen_1(true, type_pairs, env, match_2[1], match_3[1]);
  error_2 = List.fold_right((function(param, err) do
          xpcall(function() do
            moregen_kind(param[1], param[3]);
            return err;
          end end,function(raw_exn) do
            exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn[0] == Unify) then do
              return --[[ :: ]]{
                      --[[ CM_Public_method ]]Block.__(12, {param[0]}),
                      err
                    };
            end else do
              error(exn)
            end end 
          end end)
        end end), match_4[0], error_1);
  error_3 = fold((function(lab, param, err) do
          xpcall(function() do
            match = find(lab, sign1.csig_vars);
            if (param[0] == --[[ Mutable ]]1 and match[0] ~= --[[ Mutable ]]1) then do
              return --[[ :: ]]{
                      --[[ CM_Non_mutable_value ]]Block.__(6, {lab}),
                      err
                    };
            end else if (param[1] == --[[ Concrete ]]1 and match[1] ~= --[[ Concrete ]]1) then do
              return --[[ :: ]]{
                      --[[ CM_Non_concrete_value ]]Block.__(7, {lab}),
                      err
                    };
            end else do
              return err;
            end end  end 
          end end,function(exn) do
            if (exn == Caml_builtin_exceptions.not_found) then do
              return --[[ :: ]]{
                      --[[ CM_Missing_value ]]Block.__(8, {lab}),
                      err
                    };
            end else do
              error(exn)
            end end 
          end end)
        end end), sign2.csig_vars, error_2);
  error_4 = fold((function(lab, param, err) do
          if (param[1] == --[[ Virtual ]]0 and not mem(lab, sign2.csig_vars)) then do
            return --[[ :: ]]{
                    --[[ CM_Hide_virtual ]]Block.__(11, {
                        "instance variable",
                        lab
                      }),
                    err
                  };
          end else do
            return err;
          end end 
        end end), sign1.csig_vars, error_3);
  error_5 = List.fold_right((function(e, l) do
          if (List.mem(e, missing_method)) then do
            return l;
          end else do
            return --[[ :: ]]{
                    --[[ CM_Virtual_method ]]Block.__(14, {e}),
                    l
                  };
          end end 
        end end), elements_aux(--[[ [] ]]0, diff(sign2.csig_concr, sign1.csig_concr)), error_4);
  res;
  if (error_5) then do
    res = --[[ :: ]]{
      --[[ CM_Class_type_mismatch ]]Block.__(2, {
          env,
          patt,
          subj
        }),
      error_5
    };
  end else do
    xpcall(function() do
      moregen_clty(trace, type_pairs, env, patt, subj);
      res = --[[ [] ]]0;
    end end,function(raw_exn) do
      exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] == Failure) then do
        res = exn[1];
      end else do
        error(exn)
      end end 
    end end)
  end end 
  current_level.contents = old_level;
  return res;
end end

function equal_clty(trace, type_pairs, subst, env, cty1, cty2) do
  xpcall(function() do
    exit = 0;
    local ___conditional___=(cty1.tag | 0);
    do
       if ___conditional___ == 0--[[ Cty_constr ]] then do
          cty1_1 = cty1[2];
          exit_1 = 0;
          local ___conditional___=(cty2.tag | 0);
          do
             if ___conditional___ == 0--[[ Cty_constr ]] then do
                return equal_clty(true, type_pairs, subst, env, cty1_1, cty2[2]); end end 
             if ___conditional___ == 1--[[ Cty_signature ]]
             or ___conditional___ == 2--[[ Cty_arrow ]] then do
                exit_1 = 3; end else 
             end end
            
          end
          if (exit_1 == 3) then do
            return equal_clty(true, type_pairs, subst, env, cty1_1, cty2);
          end
           end  end else 
       if ___conditional___ == 1--[[ Cty_signature ]] then do
          sign1 = cty1[0];
          local ___conditional___=(cty2.tag | 0);
          do
             if ___conditional___ == 0--[[ Cty_constr ]] then do
                exit = 1; end else 
             if ___conditional___ == 1--[[ Cty_signature ]] then do
                sign2 = cty2[0];
                ty1 = object_fields(repr(sign1.csig_self));
                ty2 = object_fields(repr(sign2.csig_self));
                match = flatten_fields(ty1);
                match_1 = flatten_fields(ty2);
                match_2 = associate_fields(match[0], match_1[0]);
                List.iter((function(param) do
                        xpcall(function() do
                          return eqtype_1(true, type_pairs, subst, env, param[2], param[4]);
                        end end,function(raw_exn) do
                          exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                          if (exn[0] == Unify) then do
                            error({
                              Failure,
                              --[[ :: ]]{
                                --[[ CM_Meth_type_mismatch ]]Block.__(5, {
                                    param[0],
                                    env,
                                    expand_trace(env, exn[1])
                                  }),
                                --[[ [] ]]0
                              }
                            })
                          end
                           end 
                          error(exn)
                        end end)
                      end end), match_2[0]);
                return iter_1((function(lab, param) do
                              match = find(lab, sign1.csig_vars);
                              xpcall(function() do
                                return eqtype_1(true, type_pairs, subst, env, match[2], param[2]);
                              end end,function(raw_exn) do
                                exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                                if (exn[0] == Unify) then do
                                  error({
                                    Failure,
                                    --[[ :: ]]{
                                      --[[ CM_Val_type_mismatch ]]Block.__(4, {
                                          lab,
                                          env,
                                          expand_trace(env, exn[1])
                                        }),
                                      --[[ [] ]]0
                                    }
                                  })
                                end
                                 end 
                                error(exn)
                              end end)
                            end end), sign2.csig_vars); end end end end 
             if ___conditional___ == 2--[[ Cty_arrow ]] then do
                exit = 2; end else 
             end end
            
          end end else 
       if ___conditional___ == 2--[[ Cty_arrow ]] then do
          local ___conditional___=(cty2.tag | 0);
          do
             if ___conditional___ == 0--[[ Cty_constr ]] then do
                exit = 1; end else 
             if ___conditional___ == 1--[[ Cty_signature ]] then do
                exit = 2; end else 
             if ___conditional___ == 2--[[ Cty_arrow ]] then do
                if (cty1[0] == cty2[0]) then do
                  xpcall(function() do
                    eqtype_1(true, type_pairs, subst, env, cty1[1], cty2[1]);
                  end end,function(raw_exn) do
                    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn[0] == Unify) then do
                      error({
                        Failure,
                        --[[ :: ]]{
                          --[[ CM_Parameter_mismatch ]]Block.__(3, {
                              env,
                              expand_trace(env, exn[1])
                            }),
                          --[[ [] ]]0
                        }
                      })
                    end
                     end 
                    error(exn)
                  end end)
                  return equal_clty(false, type_pairs, subst, env, cty1[2], cty2[2]);
                end else do
                  exit = 2;
                end end  end else 
             end end end end end end
            
          end end else 
       end end end end end end
      
    end
    local ___conditional___=(exit);
    do
       if ___conditional___ == 1 then do
          return equal_clty(true, type_pairs, subst, env, cty1, cty2[2]); end end 
       if ___conditional___ == 2 then do
          error({
            Failure,
            trace and --[[ [] ]]0 or --[[ :: ]]{
                --[[ CM_Class_type_mismatch ]]Block.__(2, {
                    env,
                    cty1,
                    cty2
                  }),
                --[[ [] ]]0
              }
          }) end end 
      
    end
  end end,function(raw_exn_1) do
    exn_1 = Caml_js_exceptions.internalToOCamlException(raw_exn_1);
    if (exn_1[0] == Failure) then do
      if (trace) then do
        error({
          Failure,
          --[[ :: ]]{
            --[[ CM_Class_type_mismatch ]]Block.__(2, {
                env,
                cty1,
                cty2
              }),
            exn_1[1]
          }
        })
      end
       end 
      error(exn_1)
    end else do
      error(exn_1)
    end end 
  end end)
end end

function match_class_declarations(env, patt_params, patt_type, subj_params, subj_type) do
  type_pairs = Curry._1(TypePairs.create, 53);
  subst = do
    contents: --[[ [] ]]0
  end;
  sign1 = signature_of_class_type(patt_type);
  sign2 = signature_of_class_type(subj_type);
  t1 = repr(sign1.csig_self);
  t2 = repr(sign2.csig_self);
  Curry._3(TypePairs.add, type_pairs, --[[ tuple ]]{
        t1,
        t2
      }, --[[ () ]]0);
  match = flatten_fields(object_fields(t1));
  match_1 = flatten_fields(object_fields(t2));
  match_2 = associate_fields(match[0], match_1[0]);
  error = List.fold_right((function(param, err) do
          lab = param[0];
          k = field_kind_repr(param[1]);
          err_1 = typeof k == "number" and --[[ :: ]]{
              --[[ CM_Hide_public ]]Block.__(10, {lab}),
              err
            } or err;
          if (mem_2(lab, sign1.csig_concr)) then do
            return err_1;
          end else do
            return --[[ :: ]]{
                    --[[ CM_Hide_virtual ]]Block.__(11, {
                        "method",
                        lab
                      }),
                    err_1
                  };
          end end 
        end end), match_2[1], --[[ [] ]]0);
  missing_method = List.map((function(param) do
          return param[0];
        end end), match_2[2]);
  error_1 = Pervasives.$at(List.map((function(m) do
              return --[[ CM_Missing_method ]]Block.__(9, {m});
            end end), missing_method), error);
  eqtype_1(true, type_pairs, subst, env, match[1], match_1[1]);
  error_2 = List.fold_right((function(param, err) do
          lab = param[0];
          k1 = field_kind_repr(param[1]);
          k2 = field_kind_repr(param[3]);
          if (typeof k1 == "number") then do
            if (k1 == 0) then do
              if (typeof k2 == "number") then do
                if (k2 == 0) then do
                  return err;
                end
                 end 
              end else do
                return --[[ :: ]]{
                        --[[ CM_Public_method ]]Block.__(12, {lab}),
                        err
                      };
              end end 
            end
             end 
          end else if (typeof k2 == "number") then do
            if (k2 == 0) then do
              return --[[ :: ]]{
                      --[[ CM_Private_method ]]Block.__(13, {lab}),
                      err
                    };
            end
             end 
          end else do
            return err;
          end end  end 
          error({
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "ctype.ml",
              3600,
              34
            }
          })
        end end), match_2[0], error_1);
  error_3 = fold((function(lab, param, err) do
          xpcall(function() do
            match = find(lab, sign1.csig_vars);
            if (param[0] == --[[ Mutable ]]1 and match[0] ~= --[[ Mutable ]]1) then do
              return --[[ :: ]]{
                      --[[ CM_Non_mutable_value ]]Block.__(6, {lab}),
                      err
                    };
            end else if (param[1] == --[[ Concrete ]]1 and match[1] ~= --[[ Concrete ]]1) then do
              return --[[ :: ]]{
                      --[[ CM_Non_concrete_value ]]Block.__(7, {lab}),
                      err
                    };
            end else do
              return err;
            end end  end 
          end end,function(exn) do
            if (exn == Caml_builtin_exceptions.not_found) then do
              return --[[ :: ]]{
                      --[[ CM_Missing_value ]]Block.__(8, {lab}),
                      err
                    };
            end else do
              error(exn)
            end end 
          end end)
        end end), sign2.csig_vars, error_2);
  error_4 = fold((function(lab, param, err) do
          if (param[1] == --[[ Virtual ]]0 and not mem(lab, sign2.csig_vars)) then do
            return --[[ :: ]]{
                    --[[ CM_Hide_virtual ]]Block.__(11, {
                        "instance variable",
                        lab
                      }),
                    err
                  };
          end else do
            return err;
          end end 
        end end), sign1.csig_vars, error_3);
  error_5 = List.fold_right((function(e, l) do
          if (List.mem(e, missing_method)) then do
            return l;
          end else do
            return --[[ :: ]]{
                    --[[ CM_Virtual_method ]]Block.__(14, {e}),
                    l
                  };
          end end 
        end end), elements_aux(--[[ [] ]]0, diff(sign2.csig_concr, sign1.csig_concr)), error_4);
  if (error_5) then do
    return error_5;
  end else do
    xpcall(function() do
      lp = List.length(patt_params);
      ls = List.length(subj_params);
      if (lp ~= ls) then do
        error({
          Failure,
          --[[ :: ]]{
            --[[ CM_Parameter_arity_mismatch ]]Block.__(0, {
                lp,
                ls
              }),
            --[[ [] ]]0
          }
        })
      end
       end 
      List.iter2((function(p, s) do
              xpcall(function() do
                return eqtype_1(true, type_pairs, subst, env, p, s);
              end end,function(raw_exn) do
                exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                if (exn[0] == Unify) then do
                  error({
                    Failure,
                    --[[ :: ]]{
                      --[[ CM_Type_parameter_mismatch ]]Block.__(1, {
                          env,
                          expand_trace(env, exn[1])
                        }),
                      --[[ [] ]]0
                    }
                  })
                end
                 end 
                error(exn)
              end end)
            end end), patt_params, subj_params);
      equal_clty(false, type_pairs, subst, env, --[[ Cty_signature ]]Block.__(1, {sign1}), --[[ Cty_signature ]]Block.__(1, {sign2}));
      clty_params = function(param, param_1) do
        return List.fold_right((function(ty, cty) do
                      return --[[ Cty_arrow ]]Block.__(2, {
                                "*",
                                ty,
                                cty
                              });
                    end end), param, param_1);
      end end;
      return match_class_types(false, env, clty_params(patt_params, patt_type), clty_params(subj_params, subj_type));
    end end,function(raw_exn) do
      exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] == Failure) then do
        return exn[1];
      end else do
        error(exn)
      end end 
    end end)
  end end 
end end

warn = do
  contents: false
end;

function pred_expand(n) do
  if (n % 2 == 0 and n > 0) then do
    return n - 1 | 0;
  end else do
    return n;
  end end 
end end

function pred_enlarge(n) do
  if (n % 2 == 1) then do
    return n - 1 | 0;
  end else do
    return n;
  end end 
end end

function collect(l) do
  return List.fold_left((function(c1, param) do
                return Caml_primitive.caml_int_max(c1, param[1]);
              end end), --[[ Unchanged ]]0, l);
end end

function filter_visited(_l) do
  while(true) do
    l = _l;
    if (l) then do
      match = l[0].desc;
      if (typeof match == "number") then do
        _l = l[1];
        ::continue:: ;
      end else do
        local ___conditional___=(match.tag | 0);
        do
           if ___conditional___ == 4--[[ Tobject ]]
           or ___conditional___ == 8--[[ Tvariant ]] then do
              return l; end end 
          _l = l[1];
            ::continue:: ;
            
        end
      end end 
    end else do
      return --[[ [] ]]0;
    end end 
  end;
end end

function memq_warn(t, visited) do
  if (List.memq(t, visited)) then do
    warn.contents = true;
    return true;
  end else do
    return false;
  end end 
end end

function lid_of_path($staropt$star, param) do
  sharp = $staropt$star ~= undefined and $staropt$star or "";
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Pident ]] then do
        return --[[ Lident ]]Block.__(0, {sharp .. param[0].name}); end end 
     if ___conditional___ == 1--[[ Pdot ]] then do
        return --[[ Ldot ]]Block.__(1, {
                  lid_of_path(undefined, param[0]),
                  sharp .. param[1]
                }); end end 
     if ___conditional___ == 2--[[ Papply ]] then do
        return --[[ Lapply ]]Block.__(2, {
                  lid_of_path(sharp, param[0]),
                  lid_of_path(undefined, param[1])
                }); end end 
    
  end
end end

function find_cltype_for_path(env, p) do
  match = lookup_type_1(lid_of_path("#", p), env);
  cl_abbr = match[1];
  match_1 = cl_abbr.type_manifest;
  if (match_1 ~= undefined) then do
    ty = match_1;
    match_2 = repr(ty).desc;
    if (typeof match_2 == "number") then do
      error(Caml_builtin_exceptions.not_found)
    end else if (match_2.tag == --[[ Tobject ]]4) then do
      match_3 = match_2[1].contents;
      if (match_3 ~= undefined) then do
        if (same(p, match_3[0])) then do
          return --[[ tuple ]]{
                  cl_abbr,
                  ty
                };
        end else do
          error(Caml_builtin_exceptions.not_found)
        end end 
      end else do
        error(Caml_builtin_exceptions.not_found)
      end end 
    end else do
      error(Caml_builtin_exceptions.not_found)
    end end  end 
  end else do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "ctype.ml",
        3707,
        12
      }
    })
  end end 
end end

function build_subtype(env, visited, loops, posi, level, t) do
  t_1 = repr(t);
  match = t_1.desc;
  if (typeof match == "number") then do
    if (posi) then do
      v = newvar(undefined, --[[ () ]]0);
      return --[[ tuple ]]{
              v,
              --[[ Changed ]]2
            };
    end else do
      warn.contents = true;
      return --[[ tuple ]]{
              t_1,
              --[[ Unchanged ]]0
            };
    end end 
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 0--[[ Tvar ]] then do
          if (posi) then do
            xpcall(function() do
              t$prime = List.assq(t_1, loops);
              warn.contents = true;
              return --[[ tuple ]]{
                      t$prime,
                      --[[ Equiv ]]1
                    };
            end end,function(exn) do
              if (exn == Caml_builtin_exceptions.not_found) then do
                return --[[ tuple ]]{
                        t_1,
                        --[[ Unchanged ]]0
                      };
              end else do
                error(exn)
              end end 
            end end)
          end else do
            return --[[ tuple ]]{
                    t_1,
                    --[[ Unchanged ]]0
                  };
          end end  end end 
       if ___conditional___ == 1--[[ Tarrow ]] then do
          if (memq_warn(t_1, visited)) then do
            return --[[ tuple ]]{
                    t_1,
                    --[[ Unchanged ]]0
                  };
          end else do
            visited_1 = --[[ :: ]]{
              t_1,
              visited
            };
            match_1 = build_subtype(env, visited_1, loops, not posi, level, match[1]);
            match_2 = build_subtype(env, visited_1, loops, posi, level, match[2]);
            c = Caml_primitive.caml_int_max(match_1[1], match_2[1]);
            if (c > --[[ Unchanged ]]0) then do
              return --[[ tuple ]]{
                      newty2(current_level.contents, --[[ Tarrow ]]Block.__(1, {
                              match[0],
                              match_1[0],
                              match_2[0],
                              --[[ Cok ]]0
                            })),
                      c
                    };
            end else do
              return --[[ tuple ]]{
                      t_1,
                      --[[ Unchanged ]]0
                    };
            end end 
          end end  end end 
       if ___conditional___ == 2--[[ Ttuple ]] then do
          if (memq_warn(t_1, visited)) then do
            return --[[ tuple ]]{
                    t_1,
                    --[[ Unchanged ]]0
                  };
          end else do
            visited_2 = --[[ :: ]]{
              t_1,
              visited
            };
            tlist$prime = List.map((function(param) do
                    return build_subtype(env, visited_2, loops, posi, level, param);
                  end end), match[0]);
            c_1 = collect(tlist$prime);
            if (c_1 > --[[ Unchanged ]]0) then do
              desc = --[[ Ttuple ]]Block.__(2, {List.map((function(prim) do
                          return prim[0];
                        end end), tlist$prime)});
              return --[[ tuple ]]{
                      newty2(current_level.contents, desc),
                      c_1
                    };
            end else do
              return --[[ tuple ]]{
                      t_1,
                      --[[ Unchanged ]]0
                    };
            end end 
          end end  end end 
       if ___conditional___ == 3--[[ Tconstr ]] then do
          tl = match[1];
          p = match[0];
          if (level > 0 and generic_abbrev(env, p) and safe_abbrev(env, t_1) and not has_constr_row(expand_abbrev(env)(t_1))) then do
            t$prime_1 = repr(expand_abbrev(env)(t_1));
            level$prime = pred_expand(level);
            xpcall(function() do
              match_3 = t$prime_1.desc;
              if (typeof match_3 == "number") then do
                error(Caml_builtin_exceptions.not_found)
              end else if (match_3.tag == --[[ Tobject ]]4) then do
                if (posi and not opened_object(t$prime_1)) then do
                  match_4 = find_cltype_for_path(env, p);
                  ty = subst(env, current_level.contents, --[[ Public ]]1, match[2], undefined, match_4[0].type_params, tl, match_4[1]);
                  ty_1 = repr(ty);
                  match_5 = ty_1.desc;
                  match_6;
                  if (typeof match_5 == "number") then do
                    error(Caml_builtin_exceptions.not_found)
                  end else if (match_5.tag == --[[ Tobject ]]4) then do
                    match_7 = match_5[1].contents;
                    if (match_7 ~= undefined) then do
                      match_8 = match_7;
                      if (same(p, match_8[0])) then do
                        match_6 = --[[ tuple ]]{
                          match_5[0],
                          match_8[1]
                        };
                      end else do
                        error(Caml_builtin_exceptions.not_found)
                      end end 
                    end else do
                      error(Caml_builtin_exceptions.not_found)
                    end end 
                  end else do
                    error(Caml_builtin_exceptions.not_found)
                  end end  end 
                  tl1 = match_6[1];
                  if (List.exists((function(param) do
                            return deep_occur(ty_1, param);
                          end end), tl1)) then do
                    error(Caml_builtin_exceptions.not_found)
                  end
                   end 
                  ty_1.desc = --[[ Tvar ]]Block.__(0, {undefined});
                  t$prime$prime = newvar(undefined, --[[ () ]]0);
                  loops_000 = --[[ tuple ]]{
                    ty_1,
                    t$prime$prime
                  };
                  loops_1 = --[[ :: ]]{
                    loops_000,
                    loops
                  };
                  match_9 = build_subtype(env, --[[ :: ]]{
                        t$prime_1,
                        --[[ [] ]]0
                      }, loops_1, posi, pred_enlarge(level$prime), match_6[0]);
                  ty1$prime = match_9[0];
                  if (not is_Tvar(t$prime$prime)) then do
                    error({
                      Caml_builtin_exceptions.assert_failure,
                      --[[ tuple ]]{
                        "ctype.ml",
                        3770,
                        10
                      }
                    })
                  end
                   end 
                  nm = match_9[1] > --[[ Equiv ]]1 or deep_occur(ty_1, ty1$prime) and undefined or --[[ tuple ]]{
                      p,
                      tl1
                    };
                  t$prime$prime.desc = --[[ Tobject ]]Block.__(4, {
                      ty1$prime,
                      do
                        contents: nm
                      end
                    });
                  xpcall(function() do
                    unify_var(env, ty_1, t_1);
                  end end,function(raw_exn) do
                    exn_1 = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn_1[0] == Unify) then do
                      error({
                        Caml_builtin_exceptions.assert_failure,
                        --[[ tuple ]]{
                          "ctype.ml",
                          3774,
                          50
                        }
                      })
                    end
                     end 
                    error(exn_1)
                  end end)
                  return --[[ tuple ]]{
                          t$prime$prime,
                          --[[ Changed ]]2
                        };
                end else do
                  error(Caml_builtin_exceptions.not_found)
                end end 
              end else do
                error(Caml_builtin_exceptions.not_found)
              end end  end 
            end end,function(exn_2) do
              if (exn_2 == Caml_builtin_exceptions.not_found) then do
                match_10 = build_subtype(env, visited, loops, posi, level$prime, t$prime_1);
                c_2 = match_10[1];
                if (c_2 > --[[ Unchanged ]]0) then do
                  return --[[ tuple ]]{
                          match_10[0],
                          c_2
                        };
                end else do
                  return --[[ tuple ]]{
                          t_1,
                          --[[ Unchanged ]]0
                        };
                end end 
              end else do
                error(exn_2)
              end end 
            end end)
          end else if (memq_warn(t_1, visited)) then do
            return --[[ tuple ]]{
                    t_1,
                    --[[ Unchanged ]]0
                  };
          end else do
            visited_3 = --[[ :: ]]{
              t_1,
              visited
            };
            xpcall(function() do
              decl = find_type_full(p, env)[0];
              if (level == 0 and generic_abbrev(env, p) and safe_abbrev(env, t_1) and not has_constr_row(expand_abbrev(env)(t_1))) then do
                warn.contents = true;
              end
               end 
              tl$prime = List.map2((function(v, t) do
                      match = Curry._1(Types_Variance.get_upper, v);
                      co = match[0];
                      if (match[1]) then do
                        if (co) then do
                          return --[[ tuple ]]{
                                  t,
                                  --[[ Unchanged ]]0
                                };
                        end else do
                          return build_subtype(env, visited_3, loops, not posi, level, t);
                        end end 
                      end else if (co) then do
                        return build_subtype(env, visited_3, loops, posi, level, t);
                      end else do
                        return --[[ tuple ]]{
                                newvar(undefined, --[[ () ]]0),
                                --[[ Changed ]]2
                              };
                      end end  end 
                    end end), decl.type_variance, tl);
              c_3 = collect(tl$prime);
              if (c_3 > --[[ Unchanged ]]0) then do
                return --[[ tuple ]]{
                        newconstr(p, List.map((function(prim) do
                                    return prim[0];
                                  end end), tl$prime)),
                        c_3
                      };
              end else do
                return --[[ tuple ]]{
                        t_1,
                        --[[ Unchanged ]]0
                      };
              end end 
            end end,function(exn_3) do
              if (exn_3 == Caml_builtin_exceptions.not_found) then do
                return --[[ tuple ]]{
                        t_1,
                        --[[ Unchanged ]]0
                      };
              end else do
                error(exn_3)
              end end 
            end end)
          end end  end  end end 
       if ___conditional___ == 4--[[ Tobject ]] then do
          t1 = match[0];
          if (memq_warn(t_1, visited) or opened_object(t1)) then do
            return --[[ tuple ]]{
                    t_1,
                    --[[ Unchanged ]]0
                  };
          end else do
            level$prime_1 = pred_enlarge(level);
            visited_001 = level$prime_1 < level and --[[ [] ]]0 or filter_visited(visited);
            visited_4 = --[[ :: ]]{
              t_1,
              visited_001
            };
            match_11 = build_subtype(env, visited_4, loops, posi, level$prime_1, t1);
            c_4 = match_11[1];
            if (c_4 > --[[ Unchanged ]]0) then do
              return --[[ tuple ]]{
                      newty2(current_level.contents, --[[ Tobject ]]Block.__(4, {
                              match_11[0],
                              do
                                contents: undefined
                              end
                            })),
                      c_4
                    };
            end else do
              return --[[ tuple ]]{
                      t_1,
                      --[[ Unchanged ]]0
                    };
            end end 
          end end  end end 
       if ___conditional___ == 5--[[ Tfield ]] then do
          match_12 = build_subtype(env, visited, loops, posi, level, match[2]);
          match_13 = build_subtype(env, visited, loops, posi, level, match[3]);
          c_5 = Caml_primitive.caml_int_max(match_12[1], match_13[1]);
          if (c_5 > --[[ Unchanged ]]0) then do
            return --[[ tuple ]]{
                    newty2(current_level.contents, --[[ Tfield ]]Block.__(5, {
                            match[0],
                            --[[ Fpresent ]]0,
                            match_12[0],
                            match_13[0]
                          })),
                    c_5
                  };
          end else do
            return --[[ tuple ]]{
                    t_1,
                    --[[ Unchanged ]]0
                  };
          end end  end end 
       if ___conditional___ == 6--[[ Tlink ]]
       or ___conditional___ == 7--[[ Tsubst ]] then do
          error({
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "ctype.ml",
              3865,
              6
            }
          }) end end 
       if ___conditional___ == 8--[[ Tvariant ]] then do
          row = row_repr_aux(--[[ [] ]]0, match[0]);
          if (memq_warn(t_1, visited) or not static_row(row)) then do
            return --[[ tuple ]]{
                    t_1,
                    --[[ Unchanged ]]0
                  };
          end else do
            level$prime_2 = pred_enlarge(level);
            visited_001_1 = level$prime_2 < level and --[[ [] ]]0 or filter_visited(visited);
            visited_5 = --[[ :: ]]{
              t_1,
              visited_001_1
            };
            fields = filter_row_fields(false, row.row_fields);
            fields_1 = List.map((function(orig) do
                    l = orig[0];
                    match = row_field_repr_aux(--[[ [] ]]0, orig[1]);
                    if (typeof match == "number") then do
                      error({
                        Caml_builtin_exceptions.assert_failure,
                        --[[ tuple ]]{
                          "ctype.ml",
                          3832,
                          17
                        }
                      })
                    end else if (match.tag) then do
                      error({
                        Caml_builtin_exceptions.assert_failure,
                        --[[ tuple ]]{
                          "ctype.ml",
                          3832,
                          17
                        }
                      })
                    end else do
                      match_1 = match[0];
                      if (match_1 ~= undefined) then do
                        match_2 = build_subtype(env, visited_5, loops, posi, level$prime_2, match_1);
                        t$prime = match_2[0];
                        f = posi and level > 0 and --[[ Reither ]]Block.__(1, {
                              false,
                              --[[ :: ]]{
                                t$prime,
                                --[[ [] ]]0
                              },
                              false,
                              do
                                contents: undefined
                              end
                            }) or --[[ Rpresent ]]Block.__(0, {t$prime});
                        return --[[ tuple ]]{
                                --[[ tuple ]]{
                                  l,
                                  f
                                },
                                match_2[1]
                              };
                      end else if (posi) then do
                        return --[[ tuple ]]{
                                --[[ tuple ]]{
                                  l,
                                  --[[ Reither ]]Block.__(1, {
                                      true,
                                      --[[ [] ]]0,
                                      false,
                                      do
                                        contents: undefined
                                      end
                                    })
                                },
                                --[[ Unchanged ]]0
                              };
                      end else do
                        return --[[ tuple ]]{
                                orig,
                                --[[ Unchanged ]]0
                              };
                      end end  end 
                    end end  end 
                  end end), fields);
            c_6 = collect(fields_1);
            row_row_fields = List.map((function(prim) do
                    return prim[0];
                  end end), fields_1);
            row_row_more = newvar(undefined, --[[ () ]]0);
            row_row_name = c_6 > --[[ Unchanged ]]0 and undefined or row.row_name;
            row_1 = do
              row_fields: row_row_fields,
              row_more: row_row_more,
              row_bound: --[[ () ]]0,
              row_closed: posi,
              row_fixed: false,
              row_name: row_row_name
            end;
            return --[[ tuple ]]{
                    newty2(current_level.contents, --[[ Tvariant ]]Block.__(8, {row_1})),
                    --[[ Changed ]]2
                  };
          end end  end end 
       if ___conditional___ == 10--[[ Tpoly ]] then do
          match_14 = build_subtype(env, visited, loops, posi, level, match[0]);
          c_7 = match_14[1];
          if (c_7 > --[[ Unchanged ]]0) then do
            return --[[ tuple ]]{
                    newty2(current_level.contents, --[[ Tpoly ]]Block.__(10, {
                            match_14[0],
                            match[1]
                          })),
                    c_7
                  };
          end else do
            return --[[ tuple ]]{
                    t_1,
                    --[[ Unchanged ]]0
                  };
          end end  end end 
       if ___conditional___ == 9--[[ Tunivar ]]
       or ___conditional___ == 11--[[ Tpackage ]] then do
          return --[[ tuple ]]{
                  t_1,
                  --[[ Unchanged ]]0
                }; end end 
      
    end
  end end 
end end

function enlarge_type(env, ty) do
  warn.contents = false;
  match = build_subtype(env, --[[ [] ]]0, --[[ [] ]]0, true, 4, ty);
  return --[[ tuple ]]{
          match[0],
          warn.contents
        };
end end

subtypes = Curry._1(TypePairs.create, 17);

function subtype_error(env, trace) do
  error({
    Subtype,
    expand_trace(env, List.rev(trace)),
    --[[ [] ]]0
  })
end end

function subtype_rec(env, _trace, _t1, _t2, _cstrs) do
  while(true) do
    cstrs = _cstrs;
    t2 = _t2;
    t1 = _t1;
    trace = _trace;
    t1_1 = repr(t1);
    t2_1 = repr(t2);
    if (t1_1 == t2_1) then do
      return cstrs;
    end else do
      xpcall(function() do
        Curry._2(TypePairs.find, subtypes, --[[ tuple ]]{
              t1_1,
              t2_1
            });
        return cstrs;
      end end,function(exn) do
        if (exn == Caml_builtin_exceptions.not_found) then do
          Curry._3(TypePairs.add, subtypes, --[[ tuple ]]{
                t1_1,
                t2_1
              }, --[[ () ]]0);
          match = t1_1.desc;
          match_1 = t2_1.desc;
          exit = 0;
          exit_1 = 0;
          exit_2 = 0;
          exit_3 = 0;
          exit_4 = 0;
          if (typeof match == "number") then do
            exit_4 = 6;
          end else do
            local ___conditional___=(match.tag | 0);
            do
               if ___conditional___ == 0--[[ Tvar ]] then do
                  exit = 2; end else 
               if ___conditional___ == 1--[[ Tarrow ]] then do
                  u1 = match[2];
                  t1_2 = match[1];
                  l1 = match[0];
                  if (typeof match_1 == "number") then do
                    exit = 1;
                  end else do
                    local ___conditional___=(match_1.tag | 0);
                    do
                       if ___conditional___ == 0--[[ Tvar ]] then do
                          exit_4 = 6; end else 
                       if ___conditional___ == 1--[[ Tarrow ]] then do
                          u2 = match_1[2];
                          t2_2 = match_1[1];
                          l2 = match_1[0];
                          if (l1 == l2 or classic.contents and not (is_optional(l1) or is_optional(l2))) then do
                            cstrs_1 = subtype_rec(env, --[[ :: ]]{
                                  --[[ tuple ]]{
                                    t2_2,
                                    t1_2
                                  },
                                  trace
                                }, t2_2, t1_2, cstrs);
                            _cstrs = cstrs_1;
                            _t2 = u2;
                            _t1 = u1;
                            _trace = --[[ :: ]]{
                              --[[ tuple ]]{
                                u1,
                                u2
                              },
                              trace
                            };
                            ::continue:: ;
                          end else do
                            exit = 1;
                          end end  end else 
                       if ___conditional___ == 3--[[ Tconstr ]] then do
                          exit_2 = 4; end else 
                       end end end end end end
                      exit = 1;
                        
                    end
                  end end  end else 
               if ___conditional___ == 2--[[ Ttuple ]] then do
                  if (typeof match_1 == "number") then do
                    exit = 1;
                  end else do
                    local ___conditional___=(match_1.tag | 0);
                    do
                       if ___conditional___ == 0--[[ Tvar ]] then do
                          exit_4 = 6; end else 
                       if ___conditional___ == 2--[[ Ttuple ]] then do
                          env_1 = env;
                          trace_1 = trace;
                          tl1 = match[0];
                          tl2 = match_1[0];
                          cstrs_2 = cstrs;
                          if (List.length(tl1) ~= List.length(tl2)) then do
                            subtype_error(env_1, trace_1);
                          end
                           end 
                          return List.fold_left2((function(env_1,trace_1)do
                                    return function (cstrs, t1, t2) do
                                      return subtype_rec(env_1, --[[ :: ]]{
                                                  --[[ tuple ]]{
                                                    t1,
                                                    t2
                                                  },
                                                  trace_1
                                                }, t1, t2, cstrs);
                                    end end
                                    end end)(env_1,trace_1), cstrs_2, tl1, tl2); end end end end 
                       if ___conditional___ == 3--[[ Tconstr ]] then do
                          exit_2 = 4; end else 
                       end end
                      exit = 1;
                        
                    end
                  end end  end else 
               if ___conditional___ == 3--[[ Tconstr ]] then do
                  if (match[1]) then do
                    exit_4 = 6;
                  end else if (typeof match_1 == "number") then do
                    exit_3 = 5;
                  end else do
                    local ___conditional___=(match_1.tag | 0);
                    do
                       if ___conditional___ == 0--[[ Tvar ]] then do
                          exit_4 = 6; end else 
                       if ___conditional___ == 3--[[ Tconstr ]] then do
                          if (match_1[1] or not same(match[0], match_1[0])) then do
                            exit_3 = 5;
                          end else do
                            return cstrs;
                          end end  end else 
                       end end end end
                      exit_3 = 5;
                        
                    end
                  end end  end  end else 
               if ___conditional___ == 4--[[ Tobject ]] then do
                  f1 = match[0];
                  if (typeof match_1 == "number") then do
                    exit = 1;
                  end else do
                    local ___conditional___=(match_1.tag | 0);
                    do
                       if ___conditional___ == 0--[[ Tvar ]] then do
                          exit_4 = 6; end else 
                       if ___conditional___ == 3--[[ Tconstr ]] then do
                          exit_2 = 4; end else 
                       if ___conditional___ == 4--[[ Tobject ]] then do
                          f2 = match_1[0];
                          if (is_Tvar(object_row(f1)) and is_Tvar(object_row(f2))) then do
                            return --[[ :: ]]{
                                    --[[ tuple ]]{
                                      trace,
                                      t1_1,
                                      t2_1,
                                      univar_pairs.contents
                                    },
                                    cstrs
                                  };
                          end else do
                            env_2 = env;
                            trace_2 = trace;
                            ty1 = f1;
                            ty2 = f2;
                            cstrs_3 = cstrs;
                            match_2 = flatten_fields(ty1);
                            rest1 = match_2[1];
                            match_3 = flatten_fields(ty2);
                            rest2 = match_3[1];
                            match_4 = associate_fields(match_2[0], match_3[0]);
                            miss2 = match_4[2];
                            miss1 = match_4[1];
                            cstrs_4 = rest2.desc == --[[ Tnil ]]0 and cstrs_3 or (
                                miss1 == --[[ [] ]]0 and subtype_rec(env_2, --[[ :: ]]{
                                        --[[ tuple ]]{
                                          rest1,
                                          rest2
                                        },
                                        trace_2
                                      }, rest1, rest2, cstrs_3) or --[[ :: ]]{
                                    --[[ tuple ]]{
                                      trace_2,
                                      build_fields(repr(ty1).level)(miss1, rest1),
                                      rest2,
                                      univar_pairs.contents
                                    },
                                    cstrs_3
                                  }
                              );
                            cstrs_5 = miss2 == --[[ [] ]]0 and cstrs_4 or --[[ :: ]]{
                                --[[ tuple ]]{
                                  trace_2,
                                  rest1,
                                  build_fields(repr(ty2).level)(miss2, newvar(undefined, --[[ () ]]0)),
                                  univar_pairs.contents
                                },
                                cstrs_4
                              };
                            return List.fold_left((function(env_2,trace_2)do
                                      return function (cstrs, param) do
                                        t2 = param[4];
                                        t1 = param[2];
                                        return subtype_rec(env_2, --[[ :: ]]{
                                                    --[[ tuple ]]{
                                                      t1,
                                                      t2
                                                    },
                                                    trace_2
                                                  }, t1, t2, cstrs);
                                      end end
                                      end end)(env_2,trace_2), cstrs_5, match_4[0]);
                          end end  end end end end end end 
                      exit = 1;
                        
                    end
                  end end  end else 
               if ___conditional___ == 8--[[ Tvariant ]] then do
                  if (typeof match_1 == "number") then do
                    exit = 1;
                  end else do
                    local ___conditional___=(match_1.tag | 0);
                    do
                       if ___conditional___ == 0--[[ Tvar ]] then do
                          exit_4 = 6; end else 
                       if ___conditional___ == 3--[[ Tconstr ]] then do
                          exit_2 = 4; end else 
                       if ___conditional___ == 8--[[ Tvariant ]] then do
                          xpcall(function() do
                            env_3 = env;
                            trace_3 = trace;
                            row1 = match[0];
                            row2 = match_1[0];
                            cstrs_6 = cstrs;
                            row1_1 = row_repr_aux(--[[ [] ]]0, row1);
                            row2_1 = row_repr_aux(--[[ [] ]]0, row2);
                            match_5 = merge_row_fields(row1_1.row_fields, row2_1.row_fields);
                            pairs = match_5[2];
                            r1 = match_5[0];
                            more1 = repr(row1_1.row_more);
                            more2 = repr(row2_1.row_more);
                            match_6 = more1.desc;
                            match_7 = more2.desc;
                            exit_5 = 0;
                            if (typeof match_6 == "number") then do
                              exit_5 = 1;
                            end else do
                              local ___conditional___=(match_6.tag | 0);
                              do
                                 if ___conditional___ == 0--[[ Tvar ]] then do
                                    exit_5 = 1; end else 
                                 if ___conditional___ == 3--[[ Tconstr ]] then do
                                    if (typeof match_7 == "number" or not (match_7.tag == --[[ Tconstr ]]3 and same(match_6[0], match_7[0]))) then do
                                      exit_5 = 1;
                                    end else do
                                      return subtype_rec(env_3, --[[ :: ]]{
                                                  --[[ tuple ]]{
                                                    more1,
                                                    more2
                                                  },
                                                  trace_3
                                                }, more1, more2, cstrs_6);
                                    end end  end else 
                                 if ___conditional___ == 9--[[ Tunivar ]] then do
                                    if (typeof match_7 == "number") then do
                                      error(Pervasives.Exit)
                                    end else if (match_7.tag == --[[ Tunivar ]]9) then do
                                      if (row1_1.row_closed == row2_1.row_closed and r1 == --[[ [] ]]0 and match_5[1] == --[[ [] ]]0) then do
                                        cstrs_7 = subtype_rec(env_3, --[[ :: ]]{
                                              --[[ tuple ]]{
                                                more1,
                                                more2
                                              },
                                              trace_3
                                            }, more1, more2, cstrs_6);
                                        return List.fold_left((function(env_3,trace_3)do
                                                  return function (cstrs, param) do
                                                    match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                                                    match_1 = row_field_repr_aux(--[[ [] ]]0, param[2]);
                                                    t1;
                                                    t2;
                                                    if (typeof match == "number") then do
                                                      if (typeof match_1 == "number") then do
                                                        return cstrs;
                                                      end else do
                                                        error(Pervasives.Exit)
                                                      end end 
                                                    end else if (match.tag) then do
                                                      if (match[0]) then do
                                                        if (match[1]) then do
                                                          error(Pervasives.Exit)
                                                        end
                                                         end 
                                                        if (typeof match_1 == "number") then do
                                                          error(Pervasives.Exit)
                                                        end else if (match_1.tag) then do
                                                          if (match_1[0]) then do
                                                            if (match_1[1]) then do
                                                              error(Pervasives.Exit)
                                                            end
                                                             end 
                                                            return cstrs;
                                                          end else do
                                                            error(Pervasives.Exit)
                                                          end end 
                                                        end else do
                                                          error(Pervasives.Exit)
                                                        end end  end 
                                                      end else do
                                                        match_2 = match[1];
                                                        if (match_2) then do
                                                          if (match_2[1]) then do
                                                            error(Pervasives.Exit)
                                                          end
                                                           end 
                                                          if (typeof match_1 == "number") then do
                                                            error(Pervasives.Exit)
                                                          end else if (match_1.tag) then do
                                                            if (match_1[0]) then do
                                                              error(Pervasives.Exit)
                                                            end
                                                             end 
                                                            match_3 = match_1[1];
                                                            if (match_3) then do
                                                              if (match_3[1]) then do
                                                                error(Pervasives.Exit)
                                                              end
                                                               end 
                                                              t1 = match_2[0];
                                                              t2 = match_3[0];
                                                            end else do
                                                              error(Pervasives.Exit)
                                                            end end 
                                                          end else do
                                                            error(Pervasives.Exit)
                                                          end end  end 
                                                        end else do
                                                          error(Pervasives.Exit)
                                                        end end 
                                                      end end 
                                                    end else do
                                                      match_4 = match[0];
                                                      if (match_4 ~= undefined) then do
                                                        if (typeof match_1 == "number") then do
                                                          error(Pervasives.Exit)
                                                        end else if (match_1.tag) then do
                                                          error(Pervasives.Exit)
                                                        end else do
                                                          match_5 = match_1[0];
                                                          if (match_5 ~= undefined) then do
                                                            t1 = match_4;
                                                            t2 = match_5;
                                                          end else do
                                                            error(Pervasives.Exit)
                                                          end end 
                                                        end end  end 
                                                      end else if (typeof match_1 == "number") then do
                                                        error(Pervasives.Exit)
                                                      end else if (match_1.tag) then do
                                                        error(Pervasives.Exit)
                                                      end else do
                                                        if (match_1[0] ~= undefined) then do
                                                          error(Pervasives.Exit)
                                                        end
                                                         end 
                                                        return cstrs;
                                                      end end  end  end 
                                                    end end  end 
                                                    return subtype_rec(env_3, --[[ :: ]]{
                                                                --[[ tuple ]]{
                                                                  t1,
                                                                  t2
                                                                },
                                                                trace_3
                                                              }, t1, t2, cstrs);
                                                  end end
                                                  end end)(env_3,trace_3), cstrs_7, pairs);
                                      end else do
                                        error(Pervasives.Exit)
                                      end end 
                                    end else do
                                      error(Pervasives.Exit)
                                    end end  end  end end end end end end 
                                error(Pervasives.Exit)
                                  
                              end
                            end end 
                            if (exit_5 == 1) then do
                              if (typeof match_7 ~= "number") then do
                                local ___conditional___=(match_7.tag | 0);
                                do
                                   if ___conditional___ == 0--[[ Tvar ]]
                                   or ___conditional___ == 3--[[ Tconstr ]]
                                   end
                                  error(Pervasives.Exit)
                                    
                                end
                              end
                               end 
                              if (row1_1.row_closed and r1 == --[[ [] ]]0) then do
                                return List.fold_left((function(env_3,trace_3)do
                                          return function (cstrs, param) do
                                            match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                                            match_1 = row_field_repr_aux(--[[ [] ]]0, param[2]);
                                            if (typeof match == "number") then do
                                              return cstrs;
                                            end else if (match.tag) then do
                                              if (not match[0]) then do
                                                match_2 = match[1];
                                                if (match_2) then do
                                                  t1 = match_2[0];
                                                  if (typeof match_1 == "number") then do
                                                    error(Pervasives.Exit)
                                                  end else if (match_1.tag) then do
                                                    error(Pervasives.Exit)
                                                  end else do
                                                    match_3 = match_1[0];
                                                    if (match_3 ~= undefined) then do
                                                      t2 = match_3;
                                                      return subtype_rec(env_3, --[[ :: ]]{
                                                                  --[[ tuple ]]{
                                                                    t1,
                                                                    t2
                                                                  },
                                                                  trace_3
                                                                }, t1, t2, cstrs);
                                                    end else do
                                                      error(Pervasives.Exit)
                                                    end end 
                                                  end end  end 
                                                end else do
                                                  error(Pervasives.Exit)
                                                end end 
                                              end
                                               end 
                                            end else do
                                              match_4 = match[0];
                                              if (match_4 ~= undefined) then do
                                                t1_1 = match_4;
                                                if (typeof match_1 == "number") then do
                                                  error(Pervasives.Exit)
                                                end else if (match_1.tag) then do
                                                  error(Pervasives.Exit)
                                                end else do
                                                  match_5 = match_1[0];
                                                  if (match_5 ~= undefined) then do
                                                    t2_1 = match_5;
                                                    return subtype_rec(env_3, --[[ :: ]]{
                                                                --[[ tuple ]]{
                                                                  t1_1,
                                                                  t2_1
                                                                },
                                                                trace_3
                                                              }, t1_1, t2_1, cstrs);
                                                  end else do
                                                    error(Pervasives.Exit)
                                                  end end 
                                                end end  end 
                                              end
                                               end 
                                            end end  end 
                                            if (typeof match_1 == "number") then do
                                              error(Pervasives.Exit)
                                            end else if (match_1.tag) then do
                                              error(Pervasives.Exit)
                                            end else do
                                              if (match_1[0] ~= undefined) then do
                                                error(Pervasives.Exit)
                                              end
                                               end 
                                              return cstrs;
                                            end end  end 
                                          end end
                                          end end)(env_3,trace_3), cstrs_6, pairs);
                              end else do
                                error(Pervasives.Exit)
                              end end 
                            end
                             end 
                          end end,function(exn_1) do
                            if (exn_1 == Pervasives.Exit) then do
                              return --[[ :: ]]{
                                      --[[ tuple ]]{
                                        trace,
                                        t1_1,
                                        t2_1,
                                        univar_pairs.contents
                                      },
                                      cstrs
                                    };
                            end else do
                              error(exn_1)
                            end end 
                          end end) end end end end end end 
                      exit = 1;
                        
                    end
                  end end  end else 
               if ___conditional___ == 10--[[ Tpoly ]] then do
                  tl1_1 = match[1];
                  u1_1 = match[0];
                  exit_6 = 0;
                  if (tl1_1) then do
                    exit_6 = 7;
                  end else if (typeof match_1 == "number") then do
                    exit = 1;
                  end else do
                    local ___conditional___=(match_1.tag | 0);
                    do
                       if ___conditional___ == 0--[[ Tvar ]] then do
                          exit_4 = 6; end else 
                       if ___conditional___ == 3--[[ Tconstr ]] then do
                          exit_2 = 4; end else 
                       if ___conditional___ == 10--[[ Tpoly ]] then do
                          if (match_1[1]) then do
                            exit_6 = 7;
                          end else do
                            _t2 = match_1[0];
                            _t1 = u1_1;
                            ::continue:: ;
                          end end  end else 
                       end end end end end end
                      exit = 1;
                        
                    end
                  end end  end 
                  if (exit_6 == 7) then do
                    if (typeof match_1 == "number") then do
                      exit = 1;
                    end else do
                      local ___conditional___=(match_1.tag | 0);
                      do
                         if ___conditional___ == 0--[[ Tvar ]] then do
                            exit_4 = 6; end else 
                         if ___conditional___ == 3--[[ Tconstr ]] then do
                            exit_2 = 4; end else 
                         if ___conditional___ == 10--[[ Tpoly ]] then do
                            tl2_1 = match_1[1];
                            u2_1 = match_1[0];
                            if (tl2_1) then do
                              xpcall(function() do
                                return enter_poly(env, univar_pairs, u1_1, tl1_1, u2_1, tl2_1, (function(trace,cstrs)do
                                          return function (t1, t2) do
                                            return subtype_rec(env, trace, t1, t2, cstrs);
                                          end end
                                          end end)(trace,cstrs));
                              end end,function(raw_exn) do
                                exn_2 = Caml_js_exceptions.internalToOCamlException(raw_exn);
                                if (exn_2[0] == Unify) then do
                                  return --[[ :: ]]{
                                          --[[ tuple ]]{
                                            trace,
                                            t1_1,
                                            t2_1,
                                            univar_pairs.contents
                                          },
                                          cstrs
                                        };
                                end else do
                                  error(exn_2)
                                end end 
                              end end)
                            end else do
                              match_8 = instance_poly(undefined, false, tl1_1, u1_1);
                              _t2 = u2_1;
                              _t1 = match_8[1];
                              ::continue:: ;
                            end end  end end end end end end 
                        exit = 1;
                          
                      end
                    end end 
                  end
                   end  end else 
               if ___conditional___ == 11--[[ Tpackage ]] then do
                  tl1_2 = match[2];
                  nl1 = match[1];
                  p1 = match[0];
                  if (typeof match_1 == "number") then do
                    exit = 1;
                  end else do
                    local ___conditional___=(match_1.tag | 0);
                    do
                       if ___conditional___ == 0--[[ Tvar ]] then do
                          exit_4 = 6; end else 
                       if ___conditional___ == 3--[[ Tconstr ]] then do
                          exit_2 = 4; end else 
                       if ___conditional___ == 11--[[ Tpackage ]] then do
                          tl2_2 = match_1[2];
                          nl2 = match_1[1];
                          p2 = match_1[0];
                          xpcall(function() do
                            ntl1 = complete_type_list(undefined, env, nl2, t1_1.level, --[[ Mty_ident ]]Block.__(0, {p1}), nl1, tl1_2);
                            ntl2 = complete_type_list(true, env, nl1, t2_1.level, --[[ Mty_ident ]]Block.__(0, {p2}), nl2, tl2_2);
                            cstrs$prime = List.map((function(trace,ntl1)do
                                return function (param) do
                                  return --[[ tuple ]]{
                                          trace,
                                          List.assoc(param[0], ntl1),
                                          param[1],
                                          univar_pairs.contents
                                        };
                                end end
                                end end)(trace,ntl1), ntl2);
                            if (eq_package_path(env, p1, p2)) then do
                              return Pervasives.$at(cstrs$prime, cstrs);
                            end else do
                              snap = snapshot(--[[ () ]]0);
                              xpcall(function() do
                                List.iter((function(param) do
                                        return unify_2(env, param[1], param[2]);
                                      end end), cstrs$prime);
                                if (Curry._7(package_subtype.contents, env, p1, nl1, tl1_2, p2, nl2, tl2_2)) then do
                                  backtrack(snap);
                                  return Pervasives.$at(cstrs$prime, cstrs);
                                end else do
                                  error({
                                    Unify,
                                    --[[ [] ]]0
                                  })
                                end end 
                              end end,function(raw_exn_1) do
                                exn_3 = Caml_js_exceptions.internalToOCamlException(raw_exn_1);
                                if (exn_3[0] == Unify) then do
                                  backtrack(snap);
                                  error(Caml_builtin_exceptions.not_found)
                                end else do
                                  error(exn_3)
                                end end 
                              end end)
                            end end 
                          end end,function(exn_4) do
                            if (exn_4 == Caml_builtin_exceptions.not_found) then do
                              return --[[ :: ]]{
                                      --[[ tuple ]]{
                                        trace,
                                        t1_1,
                                        t2_1,
                                        univar_pairs.contents
                                      },
                                      cstrs
                                    };
                            end else do
                              error(exn_4)
                            end end 
                          end end) end end end end end end 
                      exit = 1;
                        
                    end
                  end end  end else 
               end end end end end end end end end end end end end end end end
              exit_4 = 6;
                
            end
          end end 
          if (exit_4 == 6) then do
            if (typeof match_1 == "number" or match_1.tag) then do
              exit_3 = 5;
            end else do
              exit = 2;
            end end 
          end
           end 
          if (exit_3 == 5) then do
            if (typeof match == "number" or not (match.tag == --[[ Tconstr ]]3 and generic_abbrev(env, match[0]) and safe_abbrev(env, t1_1))) then do
              exit_2 = 4;
            end else do
              _t2 = t2_1;
              _t1 = expand_abbrev(env)(t1_1);
              ::continue:: ;
            end end 
          end
           end 
          if (exit_2 == 4) then do
            if (typeof match_1 == "number" or not (match_1.tag == --[[ Tconstr ]]3 and generic_abbrev(env, match_1[0]) and safe_abbrev(env, t2_1))) then do
              exit_1 = 3;
            end else do
              _t2 = expand_abbrev(env)(t2_1);
              _t1 = t1_1;
              ::continue:: ;
            end end 
          end
           end 
          if (exit_1 == 3) then do
            if (typeof match == "number" or match.tag ~= --[[ Tconstr ]]3) then do
              exit = 1;
            end else do
              p1_1 = match[0];
              exit_7 = 0;
              if (typeof match_1 == "number" or not (match_1.tag == --[[ Tconstr ]]3 and same(p1_1, match_1[0]))) then do
                exit_7 = 4;
              end else do
                xpcall(function() do
                  decl = find_type_full(p1_1, env)[0];
                  return List.fold_left2((function(trace)do
                            return function (cstrs, v, param) do
                              t2 = param[1];
                              t1 = param[0];
                              match = Curry._1(Types_Variance.get_upper, v);
                              cn = match[1];
                              if (match[0]) then do
                                if (cn) then do
                                  return --[[ :: ]]{
                                          --[[ tuple ]]{
                                            trace,
                                            newty2(t1.level, --[[ Ttuple ]]Block.__(2, {--[[ :: ]]{
                                                      t1,
                                                      --[[ [] ]]0
                                                    }})),
                                            newty2(t2.level, --[[ Ttuple ]]Block.__(2, {--[[ :: ]]{
                                                      t2,
                                                      --[[ [] ]]0
                                                    }})),
                                            univar_pairs.contents
                                          },
                                          cstrs
                                        };
                                end else do
                                  return subtype_rec(env, --[[ :: ]]{
                                              --[[ tuple ]]{
                                                t1,
                                                t2
                                              },
                                              trace
                                            }, t1, t2, cstrs);
                                end end 
                              end else if (cn) then do
                                return subtype_rec(env, --[[ :: ]]{
                                            --[[ tuple ]]{
                                              t2,
                                              t1
                                            },
                                            trace
                                          }, t2, t1, cstrs);
                              end else do
                                return cstrs;
                              end end  end 
                            end end
                            end end)(trace), cstrs, decl.type_variance, List.combine(match[1], match_1[1]));
                end end,function(exn_5) do
                  if (exn_5 == Caml_builtin_exceptions.not_found) then do
                    return --[[ :: ]]{
                            --[[ tuple ]]{
                              trace,
                              t1_1,
                              t2_1,
                              univar_pairs.contents
                            },
                            cstrs
                          };
                  end else do
                    error(exn_5)
                  end end 
                end end)
              end end 
              if (exit_7 == 4) then do
                if (generic_private_abbrev(env, p1_1)) then do
                  _t2 = t2_1;
                  _t1 = expand_abbrev_opt(env, t1_1);
                  ::continue:: ;
                end else do
                  exit = 1;
                end end 
              end
               end 
            end end 
          end
           end 
          local ___conditional___=(exit);
          do
             if ___conditional___ == 1
             or ___conditional___ == 2 then do
                return --[[ :: ]]{
                        --[[ tuple ]]{
                          trace,
                          t1_1,
                          t2_1,
                          univar_pairs.contents
                        },
                        cstrs
                      }; end end 
            
          end
        end else do
          error(exn)
        end end 
      end end)
    end end 
  end;
end end

function subtype(env, ty1, ty2) do
  Curry._1(TypePairs.clear, subtypes);
  univar_pairs.contents = --[[ [] ]]0;
  cstrs = subtype_rec(env, --[[ :: ]]{
        --[[ tuple ]]{
          ty1,
          ty2
        },
        --[[ [] ]]0
      }, ty1, ty2, --[[ [] ]]0);
  Curry._1(TypePairs.clear, subtypes);
  return (function(param) do
      return List.iter((function(param) do
                    xpcall(function() do
                      return unify_pairs(do
                                  contents: env
                                end, param[1], param[2], param[3]);
                    end end,function(raw_exn) do
                      exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                      if (exn[0] == Unify) then do
                        error({
                          Subtype,
                          expand_trace(env, List.rev(param[0])),
                          List.tl(List.tl(exn[1]))
                        })
                      end
                       end 
                      error(exn)
                    end end)
                  end end), List.rev(cstrs));
    end end);
end end

function unalias_object(ty) do
  ty_1 = repr(ty);
  match = ty_1.desc;
  if (typeof match == "number") then do
    return newty2(ty_1.level, ty_1.desc);
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 0--[[ Tvar ]] then do
          return newty2(ty_1.level, ty_1.desc); end end 
       if ___conditional___ == 3--[[ Tconstr ]] then do
          return newty2(ty_1.level, --[[ Tvar ]]Block.__(0, {undefined})); end end 
       if ___conditional___ == 5--[[ Tfield ]] then do
          return newty2(ty_1.level, --[[ Tfield ]]Block.__(5, {
                        match[0],
                        match[1],
                        match[2],
                        unalias_object(match[3])
                      })); end end 
       if ___conditional___ == 9--[[ Tunivar ]] then do
          return ty_1; end end 
      error({
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ctype.ml",
            4129,
            6
          }
        })
        
    end
  end end 
end end

function unalias(ty) do
  ty_1 = repr(ty);
  match = ty_1.desc;
  if (typeof match == "number") then do
    return newty2(ty_1.level, ty_1.desc);
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 4--[[ Tobject ]] then do
          ty_2 = match[0];
          return newty2(ty_2.level, --[[ Tobject ]]Block.__(4, {
                        unalias_object(ty_2),
                        match[1]
                      })); end end 
       if ___conditional___ == 8--[[ Tvariant ]] then do
          row = row_repr_aux(--[[ [] ]]0, match[0]);
          more = row.row_more;
          return newty2(ty_1.level, --[[ Tvariant ]]Block.__(8, {do
                          row_fields: row.row_fields,
                          row_more: newty2(more.level, more.desc),
                          row_bound: row.row_bound,
                          row_closed: row.row_closed,
                          row_fixed: row.row_fixed,
                          row_name: row.row_name
                        end})); end end 
       if ___conditional___ == 0--[[ Tvar ]]
       or ___conditional___ == 9--[[ Tunivar ]] then do
          return ty_1; end end 
      return newty2(ty_1.level, ty_1.desc);
        
    end
  end end 
end end

function arity(ty) do
  match = repr(ty).desc;
  if (typeof match == "number" or match.tag ~= --[[ Tarrow ]]1) then do
    return 0;
  end else do
    return 1 + arity(match[2]) | 0;
  end end 
end end

function cyclic_abbrev(env, id, ty) do
  check_cycle = function(seen, ty) do
    ty_1 = repr(ty);
    match = ty_1.desc;
    if (typeof match == "number" or match.tag ~= --[[ Tconstr ]]3) then do
      return false;
    end else if (Caml_obj.caml_equal(match[0], --[[ Pident ]]Block.__(0, {id})) or List.memq(ty_1, seen)) then do
      return true;
    end else do
      xpcall(function() do
        return check_cycle(--[[ :: ]]{
                    ty_1,
                    seen
                  }, expand_abbrev_opt(env, ty_1));
      end end,function(raw_exn) do
        exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn == Cannot_expand) then do
          return false;
        end else if (exn[0] == Unify) then do
          return true;
        end else do
          error(exn)
        end end  end 
      end end)
    end end  end 
  end end;
  return check_cycle(--[[ [] ]]0, ty);
end end

function normalize_type_rec(env, visited, ty) do
  ty_1 = repr(ty);
  if (mem_3(ty_1, visited.contents)) then do
    return 0;
  end else do
    visited.contents = add_3(ty_1, visited.contents);
    match = ty_1.desc;
    if (typeof match ~= "number") then do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 4--[[ Tobject ]] then do
            nm = match[1];
            match_1 = nm.contents;
            if (match_1 ~= undefined) then do
              match_2 = match_1;
              match_3 = match_2[1];
              if (match_3) then do
                l = match_3[1];
                v = match_3[0];
                n = match_2[0];
                if (deep_occur(ty_1, newty2(100000000, --[[ Ttuple ]]Block.__(2, {l})))) then do
                  set_name(nm, undefined);
                end else do
                  v$prime = repr(v);
                  match_4 = v$prime.desc;
                  exit = 0;
                  if (typeof match_4 == "number") then do
                    log_type(ty_1);
                    ty_1.desc = --[[ Tconstr ]]Block.__(3, {
                        n,
                        l,
                        do
                          contents: --[[ Mnil ]]0
                        end
                      });
                  end else do
                    local ___conditional___=(match_4.tag | 0);
                    do
                       if ___conditional___ == 0--[[ Tvar ]]
                       or ___conditional___ == 9--[[ Tunivar ]] then do
                          exit = 1; end else 
                       end end
                      set_name(nm, undefined);
                        
                    end
                  end end 
                  if (exit == 1 and v$prime ~= v) then do
                    set_name(nm, --[[ tuple ]]{
                          n,
                          --[[ :: ]]{
                            v$prime,
                            l
                          }
                        });
                  end
                   end 
                end end 
              end else do
                fatal_error("Ctype.normalize_type_rec");
              end end 
            end
             end 
            fi = repr(match[0]);
            if (fi.level >= 0) then do
              match_5 = flatten_fields(fi);
              fi$prime = build_fields(fi.level)(match_5[0], match_5[1]);
              log_type(ty_1);
              fi.desc = fi$prime.desc;
            end
             end  end else 
         if ___conditional___ == 8--[[ Tvariant ]] then do
            row = row_repr_aux(--[[ [] ]]0, match[0]);
            fields = List.map((function(param) do
                    f0 = param[1];
                    f = row_field_repr_aux(--[[ [] ]]0, f0);
                    tmp;
                    if (typeof f == "number" or not f.tag) then do
                      tmp = f;
                    end else do
                      match = f[1];
                      if (match) then do
                        tyl = match[1];
                        if (tyl) then do
                          tyl$prime = List.fold_left((function(tyl, ty) do
                                  if (List.exists((function(ty$prime) do
                                            return equal_4(env, false, --[[ :: ]]{
                                                        ty,
                                                        --[[ [] ]]0
                                                      }, --[[ :: ]]{
                                                        ty$prime,
                                                        --[[ [] ]]0
                                                      });
                                          end end), tyl)) then do
                                    return tyl;
                                  end else do
                                    return --[[ :: ]]{
                                            ty,
                                            tyl
                                          };
                                  end end 
                                end end), --[[ :: ]]{
                                match[0],
                                --[[ [] ]]0
                              }, tyl);
                          tmp = f ~= f0 or List.length(tyl$prime) < List.length(tyl) and --[[ Reither ]]Block.__(1, {
                                f[0],
                                List.rev(tyl$prime),
                                f[2],
                                f[3]
                              }) or f;
                        end else do
                          tmp = f;
                        end end 
                      end else do
                        tmp = f;
                      end end 
                    end end 
                    return --[[ tuple ]]{
                            param[0],
                            tmp
                          };
                  end end), row.row_fields);
            fields_1 = List.sort((function(param, param_1) do
                    return Caml_primitive.caml_string_compare(param[0], param_1[0]);
                  end end), List.filter((function(param) do
                          return param[1] ~= --[[ Rabsent ]]0;
                        end end))(fields));
            log_type(ty_1);
            ty_1.desc = --[[ Tvariant ]]Block.__(8, {do
                  row_fields: fields_1,
                  row_more: row.row_more,
                  row_bound: row.row_bound,
                  row_closed: row.row_closed,
                  row_fixed: row.row_fixed,
                  row_name: row.row_name
                end}); end else 
         end end end end
        
      end
    end
     end 
    return iter_type_expr((function(param) do
                  return normalize_type_rec(env, visited, param);
                end end), ty_1);
  end end 
end end

function normalize_type(env, ty) do
  return normalize_type_rec(env, do
              contents: --[[ Empty ]]0
            end, ty);
end end

nondep_hash = Curry._1(TypeHash.create, 47);

nondep_variants = Curry._1(TypeHash.create, 17);

function nondep_type_rec(env, id, _ty) do
  while(true) do
    ty = _ty;
    match = ty.desc;
    exit = 0;
    if (typeof match == "number") then do
      exit = 1;
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 6--[[ Tlink ]] then do
            _ty = match[0];
            ::continue:: ; end end 
         if ___conditional___ == 0--[[ Tvar ]]
         or ___conditional___ == 9--[[ Tunivar ]] then do
            return ty; end end 
        exit = 1;
          
      end
    end end 
    if (exit == 1) then do
      xpcall(function() do
        return Curry._2(TypeHash.find, nondep_hash, ty);
      end end,function(exn) do
        if (exn == Caml_builtin_exceptions.not_found) then do
          ty$prime = newty2(100000000, --[[ Tvar ]]Block.__(0, {undefined}));
          Curry._3(TypeHash.add, nondep_hash, ty, ty$prime);
          match_1 = ty.desc;
          tmp;
          exit_1 = 0;
          if (typeof match_1 == "number") then do
            exit_1 = 2;
          end else do
            local ___conditional___=(match_1.tag | 0);
            do
               if ___conditional___ == 3--[[ Tconstr ]] then do
                  p = match_1[0];
                  if (isfree(id, p)) then do
                    xpcall(function() do
                      tmp = --[[ Tlink ]]Block.__(6, {nondep_type_rec(env, id, expand_abbrev(env)(newty2(ty.level, ty.desc)))});
                    end end,function(raw_exn) do
                      exn_1 = Caml_js_exceptions.internalToOCamlException(raw_exn);
                      if (exn_1 == Cannot_expand) then do
                        error(Caml_builtin_exceptions.not_found)
                      end
                       end 
                      if (exn_1[0] == Unify) then do
                        error(Caml_builtin_exceptions.not_found)
                      end
                       end 
                      error(exn_1)
                    end end)
                  end else do
                    tmp = --[[ Tconstr ]]Block.__(3, {
                        p,
                        List.map((function(param) do
                                return nondep_type_rec(env, id, param);
                              end end), match_1[1]),
                        do
                          contents: --[[ Mnil ]]0
                        end
                      });
                  end end  end else 
               if ___conditional___ == 4--[[ Tobject ]] then do
                  match_2 = match_1[1].contents;
                  tmp_1;
                  if (match_2 ~= undefined) then do
                    match_3 = match_2;
                    p_1 = match_3[0];
                    tmp_1 = isfree(id, p_1) and undefined or --[[ tuple ]]{
                        p_1,
                        List.map((function(param) do
                                return nondep_type_rec(env, id, param);
                              end end), match_3[1])
                      };
                  end else do
                    tmp_1 = undefined;
                  end end 
                  tmp = --[[ Tobject ]]Block.__(4, {
                      nondep_type_rec(env, id, match_1[0]),
                      do
                        contents: tmp_1
                      end
                    }); end else 
               if ___conditional___ == 8--[[ Tvariant ]] then do
                  row = row_repr_aux(--[[ [] ]]0, match_1[0]);
                  more = repr(row.row_more);
                  xpcall(function() do
                    ty2 = Curry._2(TypeHash.find, nondep_variants, more);
                    Curry._3(TypeHash.add, nondep_hash, ty, ty2);
                    tmp = --[[ Tlink ]]Block.__(6, {ty2});
                  end end,function(exn_2) do
                    if (exn_2 == Caml_builtin_exceptions.not_found) then do
                      Curry._3(TypeHash.add, nondep_variants, more, ty$prime);
                      __static = static_row(row);
                      more$prime = __static and newty2(100000000, --[[ Tnil ]]0) or more;
                      row_1 = copy_row((function(param) do
                              return nondep_type_rec(env, id, param);
                            end end), true, row, true, more$prime);
                      match_4 = row_1.row_name;
                      tmp = match_4 ~= undefined and isfree(id, match_4[0]) and --[[ Tvariant ]]Block.__(8, {do
                              row_fields: row_1.row_fields,
                              row_more: row_1.row_more,
                              row_bound: row_1.row_bound,
                              row_closed: row_1.row_closed,
                              row_fixed: row_1.row_fixed,
                              row_name: undefined
                            end}) or --[[ Tvariant ]]Block.__(8, {row_1});
                    end else do
                      error(exn_2)
                    end end 
                  end end) end else 
               if ___conditional___ == 11--[[ Tpackage ]] then do
                  p_2 = match_1[0];
                  if (isfree(id, p_2)) then do
                    p$prime = normalize_package_path(env, p_2);
                    if (isfree(id, p$prime)) then do
                      error(Caml_builtin_exceptions.not_found)
                    end
                     end 
                    tmp = --[[ Tpackage ]]Block.__(11, {
                        p$prime,
                        match_1[1],
                        List.map((function(param) do
                                return nondep_type_rec(env, id, param);
                              end end), match_1[2])
                      });
                  end else do
                    exit_1 = 2;
                  end end  end else 
               end end end end end end end end
              exit_1 = 2;
                
            end
          end end 
          if (exit_1 == 2) then do
            tmp = copy_type_desc(undefined, (function(param) do
                    return nondep_type_rec(env, id, param);
                  end end), ty.desc);
          end
           end 
          ty$prime.desc = tmp;
          return ty$prime;
        end else do
          error(exn)
        end end 
      end end)
    end
     end 
  end;
end end

function nondep_type(env, id, ty) do
  xpcall(function() do
    ty$prime = nondep_type_rec(env, id, ty);
    Curry._1(TypeHash.clear, nondep_hash);
    Curry._1(TypeHash.clear, nondep_variants);
    return ty$prime;
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      Curry._1(TypeHash.clear, nondep_hash);
      Curry._1(TypeHash.clear, nondep_variants);
      error(Caml_builtin_exceptions.not_found)
    end else do
      error(exn)
    end end 
  end end)
end end

nondep_type$prime.contents = nondep_type;

function unroll_abbrev(id, tl, ty) do
  ty_1 = repr(ty);
  path = --[[ Pident ]]Block.__(0, {id});
  if (is_Tvar(ty_1) or List.exists((function(param) do
            return deep_occur(ty_1, param);
          end end), tl) or is_object_type(path)) then do
    return ty_1;
  end else do
    ty$prime = newty2(ty_1.level, ty_1.desc);
    link_type(ty_1, newty2(ty_1.level, --[[ Tconstr ]]Block.__(3, {
                path,
                tl,
                do
                  contents: --[[ Mnil ]]0
                end
              })));
    return ty$prime;
  end end 
end end

function nondep_type_decl(env, mid, id, is_covariant, decl) do
  xpcall(function() do
    params = List.map((function(param) do
            return nondep_type_rec(env, mid, param);
          end end), decl.type_params);
    tk;
    xpcall(function() do
      match = decl.type_kind;
      tk = typeof match == "number" and (
          match == --[[ Type_abstract ]]0 and --[[ Type_abstract ]]0 or --[[ Type_open ]]1
        ) or (
          match.tag and --[[ Type_variant ]]Block.__(1, {List.map((function(c) do
                        return do
                                cd_id: c.cd_id,
                                cd_args: List.map((function(param) do
                                        return nondep_type_rec(env, mid, param);
                                      end end), c.cd_args),
                                cd_res: may_map((function(param) do
                                        return nondep_type_rec(env, mid, param);
                                      end end), c.cd_res),
                                cd_loc: c.cd_loc,
                                cd_attributes: c.cd_attributes
                              end;
                      end end), match[0])}) or --[[ Type_record ]]Block.__(0, {
                List.map((function(l) do
                        return do
                                ld_id: l.ld_id,
                                ld_mutable: l.ld_mutable,
                                ld_type: nondep_type_rec(env, mid, l.ld_type),
                                ld_loc: l.ld_loc,
                                ld_attributes: l.ld_attributes
                              end;
                      end end), match[0]),
                match[1]
              })
        );
    end end,function(exn) do
      if (exn == Caml_builtin_exceptions.not_found) then do
        if (is_covariant) then do
          tk = --[[ Type_abstract ]]0;
        end else do
          error(exn)
        end end 
      end else do
        error(exn)
      end end 
    end end)
    tm;
    xpcall(function() do
      match_1 = decl.type_manifest;
      tm = match_1 ~= undefined and unroll_abbrev(id, params, nondep_type_rec(env, mid, match_1)) or undefined;
    end end,function(exn_1) do
      if (exn_1 == Caml_builtin_exceptions.not_found) then do
        if (is_covariant) then do
          tm = undefined;
        end else do
          error(exn_1)
        end end 
      end else do
        error(exn_1)
      end end 
    end end)
    Curry._1(TypeHash.clear, nondep_hash);
    Curry._1(TypeHash.clear, nondep_variants);
    priv = tm ~= undefined and has_constr_row(tm) and --[[ Private ]]0 or decl.type_private;
    return do
            type_params: params,
            type_arity: decl.type_arity,
            type_kind: tk,
            type_private: priv,
            type_manifest: tm,
            type_variance: decl.type_variance,
            type_newtype_level: undefined,
            type_loc: decl.type_loc,
            type_attributes: decl.type_attributes
          end;
  end end,function(exn_2) do
    if (exn_2 == Caml_builtin_exceptions.not_found) then do
      Curry._1(TypeHash.clear, nondep_hash);
      Curry._1(TypeHash.clear, nondep_variants);
      error(Caml_builtin_exceptions.not_found)
    end else do
      error(exn_2)
    end end 
  end end)
end end

function nondep_extension_constructor(env, mid, ext) do
  xpcall(function() do
    match;
    if (isfree(mid, ext.ext_type_path)) then do
      ty = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
              ext.ext_type_path,
              ext.ext_type_params,
              do
                contents: --[[ Mnil ]]0
              end
            }));
      ty$prime = nondep_type_rec(env, mid, ty);
      match_1 = repr(ty$prime).desc;
      if (typeof match_1 == "number") then do
        error(Caml_builtin_exceptions.not_found)
      end else if (match_1.tag == --[[ Tconstr ]]3) then do
        match = --[[ tuple ]]{
          match_1[0],
          match_1[1]
        };
      end else do
        error(Caml_builtin_exceptions.not_found)
      end end  end 
    end else do
      type_params = List.map((function(param) do
              return nondep_type_rec(env, mid, param);
            end end), ext.ext_type_params);
      match = --[[ tuple ]]{
        ext.ext_type_path,
        type_params
      };
    end end 
    args = List.map((function(param) do
            return nondep_type_rec(env, mid, param);
          end end), ext.ext_args);
    ret_type = may_map((function(param) do
            return nondep_type_rec(env, mid, param);
          end end), ext.ext_ret_type);
    Curry._1(TypeHash.clear, nondep_hash);
    Curry._1(TypeHash.clear, nondep_variants);
    return do
            ext_type_path: match[0],
            ext_type_params: match[1],
            ext_args: args,
            ext_ret_type: ret_type,
            ext_private: ext.ext_private,
            ext_loc: ext.ext_loc,
            ext_attributes: ext.ext_attributes
          end;
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      Curry._1(TypeHash.clear, nondep_hash);
      Curry._1(TypeHash.clear, nondep_variants);
      error(Caml_builtin_exceptions.not_found)
    end else do
      error(exn)
    end end 
  end end)
end end

function nondep_class_signature(env, id, sign) do
  return do
          csig_self: nondep_type_rec(env, id, sign.csig_self),
          csig_vars: map((function(param) do
                  return --[[ tuple ]]{
                          param[0],
                          param[1],
                          nondep_type_rec(env, id, param[2])
                        };
                end end), sign.csig_vars),
          csig_concr: sign.csig_concr,
          csig_inher: List.map((function(param) do
                  return --[[ tuple ]]{
                          param[0],
                          List.map((function(param) do
                                  return nondep_type_rec(env, id, param);
                                end end), param[1])
                        };
                end end), sign.csig_inher)
        end;
end end

function nondep_class_type(env, id, _param) do
  while(true) do
    param = _param;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ == 0--[[ Cty_constr ]] then do
          cty = param[2];
          p = param[0];
          if (isfree(id, p)) then do
            _param = cty;
            ::continue:: ;
          end else do
            return --[[ Cty_constr ]]Block.__(0, {
                      p,
                      List.map((function(param) do
                              return nondep_type_rec(env, id, param);
                            end end), param[1]),
                      nondep_class_type(env, id, cty)
                    });
          end end  end end 
       if ___conditional___ == 1--[[ Cty_signature ]] then do
          return --[[ Cty_signature ]]Block.__(1, {nondep_class_signature(env, id, param[0])}); end end 
       if ___conditional___ == 2--[[ Cty_arrow ]] then do
          return --[[ Cty_arrow ]]Block.__(2, {
                    param[0],
                    nondep_type_rec(env, id, param[1]),
                    nondep_class_type(env, id, param[2])
                  }); end end 
      
    end
  end;
end end

function nondep_class_declaration(env, id, decl) do
  if (isfree(id, decl.cty_path)) then do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "ctype.ml",
        4449,
        2
      }
    })
  end
   end 
  match = decl.cty_new;
  decl_1 = do
    cty_params: List.map((function(param) do
            return nondep_type_rec(env, id, param);
          end end), decl.cty_params),
    cty_type: nondep_class_type(env, id, decl.cty_type),
    cty_path: decl.cty_path,
    cty_new: match ~= undefined and nondep_type_rec(env, id, match) or undefined,
    cty_variance: decl.cty_variance,
    cty_loc: decl.cty_loc,
    cty_attributes: decl.cty_attributes
  end;
  Curry._1(TypeHash.clear, nondep_hash);
  Curry._1(TypeHash.clear, nondep_variants);
  return decl_1;
end end

function nondep_cltype_declaration(env, id, decl) do
  if (isfree(id, decl.clty_path)) then do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "ctype.ml",
        4468,
        2
      }
    })
  end
   end 
  decl_clty_params = List.map((function(param) do
          return nondep_type_rec(env, id, param);
        end end), decl.clty_params);
  decl_clty_type = nondep_class_type(env, id, decl.clty_type);
  decl_clty_path = decl.clty_path;
  decl_clty_variance = decl.clty_variance;
  decl_clty_loc = decl.clty_loc;
  decl_clty_attributes = decl.clty_attributes;
  decl_1 = do
    clty_params: decl_clty_params,
    clty_type: decl_clty_type,
    clty_path: decl_clty_path,
    clty_variance: decl_clty_variance,
    clty_loc: decl_clty_loc,
    clty_attributes: decl_clty_attributes
  end;
  Curry._1(TypeHash.clear, nondep_hash);
  Curry._1(TypeHash.clear, nondep_variants);
  return decl_1;
end end

function collapse_conj(env, visited, ty) do
  ty_1 = repr(ty);
  if (List.memq(ty_1, visited)) then do
    return --[[ () ]]0;
  end else do
    visited_1 = --[[ :: ]]{
      ty_1,
      visited
    };
    match = ty_1.desc;
    if (typeof match == "number") then do
      return iter_type_expr((function(param) do
                    return collapse_conj(env, visited_1, param);
                  end end), ty_1);
    end else if (match.tag == --[[ Tvariant ]]8) then do
      row = row_repr_aux(--[[ [] ]]0, match[0]);
      List.iter((function(param) do
              match = row_field_repr_aux(--[[ [] ]]0, param[1]);
              if (typeof match == "number" or not match.tag) then do
                return --[[ () ]]0;
              end else do
                match_1 = match[1];
                if (match_1) then do
                  tl = match_1[1];
                  if (tl) then do
                    t1 = match_1[0];
                    List.iter((function(param) do
                            return unify_2(env, t1, param);
                          end end), tl);
                    return set_row_field(match[3], --[[ Reither ]]Block.__(1, {
                                  match[0],
                                  --[[ :: ]]{
                                    t1,
                                    --[[ [] ]]0
                                  },
                                  match[2],
                                  do
                                    contents: undefined
                                  end
                                }));
                  end else do
                    return --[[ () ]]0;
                  end end 
                end else do
                  return --[[ () ]]0;
                end end 
              end end 
            end end), row.row_fields);
      return iter_row((function(param) do
                    return collapse_conj(env, visited_1, param);
                  end end), row);
    end else do
      return iter_type_expr((function(param) do
                    return collapse_conj(env, visited_1, param);
                  end end), ty_1);
    end end  end 
  end end 
end end

function collapse_conj_params(env, params) do
  return List.iter((function(param) do
                return collapse_conj(env, --[[ [] ]]0, param);
              end end), params);
end end

out_ident = do
  contents: Format.pp_print_string
end;

function print_ident(ppf, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Oide_apply ]] then do
        return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                --[[ "(" ]]40,
                                --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                        --[[ ")" ]]41,
                                        --[[ End_of_format ]]0
                                      })})
                              })}),
                        "%a(%a)"
                      }), print_ident, param[0], print_ident, param[1]); end end 
     if ___conditional___ == 1--[[ Oide_dot ]] then do
        print_ident(ppf, param[0]);
        Format.pp_print_char(ppf, --[[ "." ]]46);
        return Curry._2(out_ident.contents, ppf, param[1]); end end 
     if ___conditional___ == 2--[[ Oide_ident ]] then do
        return Curry._2(out_ident.contents, ppf, param[0]); end end 
    
  end
end end

function parenthesized_ident(name) do
  if (List.mem(name, --[[ :: ]]{
          "or",
          --[[ :: ]]{
            "mod",
            --[[ :: ]]{
              "land",
              --[[ :: ]]{
                "lor",
                --[[ :: ]]{
                  "lxor",
                  --[[ :: ]]{
                    "lsl",
                    --[[ :: ]]{
                      "lsr",
                      --[[ :: ]]{
                        "asr",
                        --[[ [] ]]0
                      }
                    }
                  }
                }
              }
            }
          }
        })) then do
    return true;
  end else do
    match = Caml_string.get(name, 0);
    if (match >= 97) then do
      if (match >= 223) then do
        return match == 247;
      end else do
        return match >= 123;
      end end 
    end else if (match >= 91) then do
      return match ~= 95;
    end else do
      return match < 65;
    end end  end 
  end end 
end end

function value_ident(ppf, name) do
  if (parenthesized_ident(name)) then do
    return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ String_literal ]]Block.__(11, {
                        "( ",
                        --[[ String ]]Block.__(2, {
                            --[[ No_padding ]]0,
                            --[[ String_literal ]]Block.__(11, {
                                " )",
                                --[[ End_of_format ]]0
                              })
                          })
                      }),
                    "( %s )"
                  }), name);
  end else do
    return Format.pp_print_string(ppf, name);
  end end 
end end

function print_list(pr, sep, ppf, _param) do
  while(true) do
    param = _param;
    if (param) then do
      l = param[1];
      a = param[0];
      if (l) then do
        Curry._2(pr, ppf, a);
        Curry._1(sep, ppf);
        _param = l;
        ::continue:: ;
      end else do
        return Curry._2(pr, ppf, a);
      end end 
    end else do
      return --[[ () ]]0;
    end end 
  end;
end end

function pr_present(param, param_1) do
  return print_list((function(ppf, s) do
                return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                --[[ Char_literal ]]Block.__(12, {
                                    --[[ "`" ]]96,
                                    --[[ String ]]Block.__(2, {
                                        --[[ No_padding ]]0,
                                        --[[ End_of_format ]]0
                                      })
                                  }),
                                "`%s"
                              }), s);
              end end), (function(ppf) do
                return Format.fprintf(ppf, --[[ Format ]]{
                            --[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@ ",
                                    1,
                                    0
                                  }),
                                --[[ End_of_format ]]0
                              }),
                            "@ "
                          });
              end end), param, param_1);
end end

function pr_vars(param, param_1) do
  return print_list((function(ppf, s) do
                return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                --[[ Char_literal ]]Block.__(12, {
                                    --[[ "'" ]]39,
                                    --[[ String ]]Block.__(2, {
                                        --[[ No_padding ]]0,
                                        --[[ End_of_format ]]0
                                      })
                                  }),
                                "'%s"
                              }), s);
              end end), (function(ppf) do
                return Format.fprintf(ppf, --[[ Format ]]{
                            --[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@ ",
                                    1,
                                    0
                                  }),
                                --[[ End_of_format ]]0
                              }),
                            "@ "
                          });
              end end), param, param_1);
end end

function print_out_type(ppf, ty) do
  if (typeof ty == "number") then do
    return print_out_type_1(ppf, ty);
  end else do
    local ___conditional___=(ty.tag | 0);
    do
       if ___conditional___ == 0--[[ Otyp_alias ]] then do
          return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ String_literal ]]Block.__(11, {
                                          "as '",
                                          --[[ String ]]Block.__(2, {
                                              --[[ No_padding ]]0,
                                              --[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Close_box ]]0,
                                                  --[[ End_of_format ]]0
                                                })
                                            })
                                        })
                                    })})
                            }),
                          "@[%a@ as '%s@]"
                        }), print_out_type, ty[0], ty[1]); end end 
       if ___conditional___ == 12--[[ Otyp_poly ]] then do
          return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hov 2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hov 2>"
                                  }}),
                              --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                      --[[ "." ]]46,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Close_box ]]0,
                                                  --[[ End_of_format ]]0
                                                })})
                                        })
                                    })})
                            }),
                          "@[<hov 2>%a.@ %a@]"
                        }), pr_vars, ty[0], print_out_type, ty[1]); end end 
      return print_out_type_1(ppf, ty);
        
    end
  end end 
end end

function print_out_type_1(ppf, ty) do
  if (typeof ty == "number" or ty.tag ~= --[[ Otyp_arrow ]]1) then do
    return print_out_type_2(ppf, ty);
  end else do
    lab = ty[0];
    Format.pp_open_box(ppf, 0);
    if (lab ~= "") then do
      Format.pp_print_string(ppf, lab);
      Format.pp_print_char(ppf, --[[ ":" ]]58);
    end
     end 
    print_out_type_2(ppf, ty[1]);
    Format.pp_print_string(ppf, " ->");
    Format.pp_print_space(ppf, --[[ () ]]0);
    print_out_type_1(ppf, ty[2]);
    return Format.pp_close_box(ppf, --[[ () ]]0);
  end end 
end end

function print_out_type_2(ppf, ty) do
  if (typeof ty == "number" or ty.tag ~= --[[ Otyp_tuple ]]9) then do
    return print_simple_out_type(ppf, ty);
  end else do
    return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<0>",
                                  --[[ End_of_format ]]0
                                }),
                              "<0>"
                            }}),
                        --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                --[[ Close_box ]]0,
                                --[[ End_of_format ]]0
                              })})
                      }),
                    "@[<0>%a@]"
                  }), (function(param, param_1) do
                  return print_typlist(print_simple_out_type, " *", param, param_1);
                end end), ty[0]);
  end end 
end end

function print_simple_out_type(ppf, ty) do
  if (typeof ty == "number") then do
    return --[[ () ]]0;
  end else do
    local ___conditional___=(ty.tag | 0);
    do
       if ___conditional___ == 2--[[ Otyp_class ]] then do
          return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ Alpha ]]Block.__(15, {--[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Char_literal ]]Block.__(12, {
                                          --[[ "#" ]]35,
                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Close_box ]]0,
                                                  --[[ End_of_format ]]0
                                                })})
                                        })
                                    })})
                            }),
                          "@[%a%s#%a@]"
                        }), print_typargs, ty[2], ty[0] and "_" or "", print_ident, ty[1]); end end 
       if ___conditional___ == 3--[[ Otyp_constr ]] then do
          id = ty[0];
          exit = 0;
          local ___conditional___=(id.tag | 0);
          do
             if ___conditional___ == 1--[[ Oide_dot ]] then do
                match = id[0];
                exit_1 = 0;
                local ___conditional___=(match.tag | 0);
                do
                   if ___conditional___ == 0--[[ Oide_apply ]] then do
                      exit = 2; end else 
                   if ___conditional___ == 1--[[ Oide_dot ]] then do
                      match_1 = match[0];
                      local ___conditional___=(match_1.tag | 0);
                      do
                         if ___conditional___ == 0--[[ Oide_apply ]]
                         or ___conditional___ == 1--[[ Oide_dot ]] then do
                            exit = 2; end else 
                         if ___conditional___ == 2--[[ Oide_ident ]] then do
                            if (match_1[0] == "Js" and match[1] == "Internal") then do
                              exit_1 = 3;
                            end else do
                              exit = 2;
                            end end  end else 
                         end end end end
                        
                      end end else 
                   if ___conditional___ == 2--[[ Oide_ident ]] then do
                      if (match[0] == "Js_internal") then do
                        exit_1 = 3;
                      end else do
                        exit = 2;
                      end end  end else 
                   end end end end end end
                  
                end
                if (exit_1 == 3) then do
                  name = id[1];
                  exit_2 = 0;
                  local ___conditional___=(name);
                  do
                     if ___conditional___ == "fn"
                     or ___conditional___ == "meth" then do
                        exit_2 = 4; end else 
                     if ___conditional___ == "meth_callback" then do
                        tyl = ty[1];
                        if (tyl) then do
                          match_2 = tyl[0];
                          if (typeof match_2 == "number" or match_2.tag ~= --[[ Otyp_variant ]]11) then do
                            exit = 2;
                          end else do
                            match_3 = match_2[1];
                            if (match_3.tag) then do
                              exit = 2;
                            end else do
                              match_4 = match_3[0];
                              if (match_4 and not match_4[1]) then do
                                match_5 = tyl[1];
                                if (match_5 and not match_5[1]) then do
                                  match_6 = match_4[0];
                                  variant = match_6[0];
                                  make = function(tys, result) do
                                    if (tys) then do
                                      single = tys[0];
                                      if (typeof single ~= "number" and single.tag == --[[ Otyp_tuple ]]9) then do
                                        if (tys[1]) then do
                                          error(Caml_builtin_exceptions.not_found)
                                        end
                                         end 
                                        if (variant == "Arity_1") then do
                                          return --[[ Otyp_arrow ]]Block.__(1, {
                                                    "",
                                                    single,
                                                    result
                                                  });
                                        end else do
                                          return List.fold_right((function(x, acc) do
                                                        return --[[ Otyp_arrow ]]Block.__(1, {
                                                                  "",
                                                                  x,
                                                                  acc
                                                                });
                                                      end end), single[0], result);
                                        end end 
                                      end
                                       end 
                                      if (tys[1]) then do
                                        error(Caml_builtin_exceptions.not_found)
                                      end
                                       end 
                                      return --[[ Otyp_arrow ]]Block.__(1, {
                                                "",
                                                single,
                                                result
                                              });
                                    end else do
                                      error(Caml_builtin_exceptions.not_found)
                                    end end 
                                  end end;
                                  exit_3 = 0;
                                  res;
                                  xpcall(function() do
                                    res = make(match_6[2], match_5[0]);
                                    exit_3 = 5;
                                  end end,function(exn) do
                                    Format.pp_open_box(ppf, 0);
                                    print_typargs(ppf, tyl);
                                    print_ident(ppf, id);
                                    return Format.pp_close_box(ppf, --[[ () ]]0);
                                  end end)
                                  if (exit_3 == 5) then do
                                    return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                    --[[ Formatting_gen ]]Block.__(18, {
                                                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "<0>",
                                                                  --[[ End_of_format ]]0
                                                                }),
                                                              "<0>"
                                                            }}),
                                                        --[[ Char_literal ]]Block.__(12, {
                                                            --[[ "(" ]]40,
                                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                    --[[ Break ]]Block.__(0, {
                                                                        "@ ",
                                                                        1,
                                                                        0
                                                                      }),
                                                                    --[[ Char_literal ]]Block.__(12, {
                                                                        --[[ "[" ]]91,
                                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                                            --[[ Scan_indic ]]Block.__(2, {--[[ "b" ]]98}),
                                                                            --[[ String_literal ]]Block.__(11, {
                                                                                "s.this])",
                                                                                --[[ Formatting_lit ]]Block.__(17, {
                                                                                    --[[ Close_box ]]0,
                                                                                    --[[ End_of_format ]]0
                                                                                  })
                                                                              })
                                                                          })
                                                                      })
                                                                  })})
                                                          })
                                                      }),
                                                    "@[<0>(%a@ [@bs.this])@]"
                                                  }), print_out_type_1, res);
                                  end
                                   end 
                                end else do
                                  exit = 2;
                                end end 
                              end else do
                                exit = 2;
                              end end 
                            end end 
                          end end 
                        end else do
                          exit = 2;
                        end end  end else 
                     end end end end
                    exit = 2;
                      
                  end
                  if (exit_2 == 4) then do
                    tyl_1 = ty[1];
                    if (tyl_1) then do
                      match_7 = tyl_1[0];
                      if (typeof match_7 == "number" or match_7.tag ~= --[[ Otyp_variant ]]11) then do
                        exit = 2;
                      end else do
                        match_8 = match_7[1];
                        if (match_8.tag) then do
                          exit = 2;
                        end else do
                          match_9 = match_8[0];
                          if (match_9 and not match_9[1]) then do
                            match_10 = tyl_1[1];
                            if (match_10 and not match_10[1]) then do
                              match_11 = match_9[0];
                              variant_1 = match_11[0];
                              make_1 = function(tys, result) do
                                if (tys == --[[ [] ]]0) then do
                                  return --[[ Otyp_arrow ]]Block.__(1, {
                                            "",
                                            --[[ Otyp_constr ]]Block.__(3, {
                                                --[[ Oide_ident ]]Block.__(2, {"unit"}),
                                                --[[ [] ]]0
                                              }),
                                            result
                                          });
                                end else if (tys) then do
                                  single = tys[0];
                                  if (typeof single ~= "number" and single.tag == --[[ Otyp_tuple ]]9) then do
                                    if (tys[1]) then do
                                      error(Caml_builtin_exceptions.not_found)
                                    end
                                     end 
                                    if (variant_1 == "Arity_1") then do
                                      return --[[ Otyp_arrow ]]Block.__(1, {
                                                "",
                                                single,
                                                result
                                              });
                                    end else do
                                      return List.fold_right((function(x, acc) do
                                                    return --[[ Otyp_arrow ]]Block.__(1, {
                                                              "",
                                                              x,
                                                              acc
                                                            });
                                                  end end), single[0], result);
                                    end end 
                                  end
                                   end 
                                  if (tys[1]) then do
                                    error(Caml_builtin_exceptions.not_found)
                                  end
                                   end 
                                  return --[[ Otyp_arrow ]]Block.__(1, {
                                            "",
                                            single,
                                            result
                                          });
                                end else do
                                  error(Caml_builtin_exceptions.not_found)
                                end end  end 
                              end end;
                              exit_4 = 0;
                              res_1;
                              xpcall(function() do
                                res_1 = make_1(match_11[2], match_10[0]);
                                exit_4 = 5;
                              end end,function(exn_1) do
                                Format.pp_open_box(ppf, 0);
                                print_typargs(ppf, tyl_1);
                                print_ident(ppf, id);
                                return Format.pp_close_box(ppf, --[[ () ]]0);
                              end end)
                              if (exit_4 == 5) then do
                                local ___conditional___=(name);
                                do
                                   if ___conditional___ == "fn" then do
                                      return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                      --[[ Formatting_gen ]]Block.__(18, {
                                                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "<0>",
                                                                    --[[ End_of_format ]]0
                                                                  }),
                                                                "<0>"
                                                              }}),
                                                          --[[ Char_literal ]]Block.__(12, {
                                                              --[[ "(" ]]40,
                                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Break ]]Block.__(0, {
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        }),
                                                                      --[[ Char_literal ]]Block.__(12, {
                                                                          --[[ "[" ]]91,
                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Scan_indic ]]Block.__(2, {--[[ "b" ]]98}),
                                                                              --[[ String_literal ]]Block.__(11, {
                                                                                  "s])",
                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Close_box ]]0,
                                                                                      --[[ End_of_format ]]0
                                                                                    })
                                                                                })
                                                                            })
                                                                        })
                                                                    })})
                                                            })
                                                        }),
                                                      "@[<0>(%a@ [@bs])@]"
                                                    }), print_out_type_1, res_1); end end 
                                   if ___conditional___ == "meth" then do
                                      return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                      --[[ Formatting_gen ]]Block.__(18, {
                                                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "<0>",
                                                                    --[[ End_of_format ]]0
                                                                  }),
                                                                "<0>"
                                                              }}),
                                                          --[[ Char_literal ]]Block.__(12, {
                                                              --[[ "(" ]]40,
                                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Break ]]Block.__(0, {
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        }),
                                                                      --[[ Char_literal ]]Block.__(12, {
                                                                          --[[ "[" ]]91,
                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Scan_indic ]]Block.__(2, {--[[ "b" ]]98}),
                                                                              --[[ String_literal ]]Block.__(11, {
                                                                                  "s.meth])",
                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Close_box ]]0,
                                                                                      --[[ End_of_format ]]0
                                                                                    })
                                                                                })
                                                                            })
                                                                        })
                                                                    })})
                                                            })
                                                        }),
                                                      "@[<0>(%a@ [@bs.meth])@]"
                                                    }), print_out_type_1, res_1); end end 
                                  error({
                                      Caml_builtin_exceptions.assert_failure,
                                      --[[ tuple ]]{
                                        "oprint.ml",
                                        229,
                                        17
                                      }
                                    })
                                    
                                end
                              end
                               end 
                            end else do
                              exit = 2;
                            end end 
                          end else do
                            exit = 2;
                          end end 
                        end end 
                      end end 
                    end else do
                      exit = 2;
                    end end 
                  end
                   end 
                end
                 end  end else 
             if ___conditional___ == 0--[[ Oide_apply ]]
             or ___conditional___ == 2--[[ Oide_ident ]] then do
                exit = 2; end else 
             end end end end
            
          end
          if (exit == 2) then do
            Format.pp_open_box(ppf, 0);
            print_typargs(ppf, ty[1]);
            print_ident(ppf, id);
            return Format.pp_close_box(ppf, --[[ () ]]0);
          end
           end  end else 
       if ___conditional___ == 5--[[ Otyp_object ]] then do
          rest = ty[1];
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<2>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "< ",
                                  --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                          " >",
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Close_box ]]0,
                                              --[[ End_of_format ]]0
                                            })
                                        })})
                                })
                            }),
                          "@[<2>< %a >@]"
                        }), (function(param, param_1) do
                        return print_fields(rest, param, param_1);
                      end end), ty[0]); end end end end 
       if ___conditional___ == 7--[[ Otyp_stuff ]] then do
          return Format.pp_print_string(ppf, ty[0]); end end 
       if ___conditional___ == 10--[[ Otyp_var ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Char_literal ]]Block.__(12, {
                              --[[ "'" ]]39,
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ End_of_format ]]0
                                    })
                                })
                            }),
                          "'%s%s"
                        }), ty[0] and "_" or "", ty[1]); end end 
       if ___conditional___ == 11--[[ Otyp_variant ]] then do
          tags = ty[3];
          print_present = function(ppf, param) do
            if (param ~= undefined) then do
              l = param;
              if (l) then do
                return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                --[[ Formatting_lit ]]Block.__(17, {
                                    --[[ Break ]]Block.__(0, {
                                        "@;<1 -2>",
                                        1,
                                        -2
                                      }),
                                    --[[ String_literal ]]Block.__(11, {
                                        "> ",
                                        --[[ Formatting_gen ]]Block.__(18, {
                                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                  --[[ String_literal ]]Block.__(11, {
                                                      "<hov>",
                                                      --[[ End_of_format ]]0
                                                    }),
                                                  "<hov>"
                                                }}),
                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Close_box ]]0,
                                                    --[[ End_of_format ]]0
                                                  })})
                                          })
                                      })
                                  }),
                                "@;<1 -2>> @[<hov>%a@]"
                              }), pr_present, l);
              end else do
                return --[[ () ]]0;
              end end 
            end else do
              return --[[ () ]]0;
            end end 
          end end;
          print_fields_1 = function(ppf, param) do
            if (param.tag) then do
              return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                              --[[ Formatting_gen ]]Block.__(18, {
                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                        --[[ End_of_format ]]0,
                                        ""
                                      }}),
                                  --[[ Alpha ]]Block.__(15, {--[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Close_box ]]0,
                                              --[[ End_of_format ]]0
                                            })})})
                                }),
                              "@[%a%a@]"
                            }), print_typargs, param[1], print_ident, param[0]);
            end else do
              return print_list(print_row_field, (function(ppf) do
                            return Format.fprintf(ppf, --[[ Format ]]{
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@;<1 -2>",
                                                1,
                                                -2
                                              }),
                                            --[[ String_literal ]]Block.__(11, {
                                                "| ",
                                                --[[ End_of_format ]]0
                                              })
                                          }),
                                        "@;<1 -2>| "
                                      });
                          end end), ppf, param[0]);
            end end 
          end end;
          return Curry._6(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String ]]Block.__(2, {
                              --[[ No_padding ]]0,
                              --[[ Char_literal ]]Block.__(12, {
                                  --[[ "[" ]]91,
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Formatting_gen ]]Block.__(18, {
                                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                --[[ String_literal ]]Block.__(11, {
                                                    "<hv>",
                                                    --[[ End_of_format ]]0
                                                  }),
                                                "<hv>"
                                              }}),
                                          --[[ Formatting_gen ]]Block.__(18, {
                                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "<hv>",
                                                        --[[ End_of_format ]]0
                                                      }),
                                                    "<hv>"
                                                  }}),
                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Close_box ]]0,
                                                      --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                                              " ]",
                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                  --[[ Close_box ]]0,
                                                                  --[[ End_of_format ]]0
                                                                })
                                                            })})
                                                    })})
                                            })
                                        })
                                    })
                                })
                            }),
                          "%s[%s@[<hv>@[<hv>%a@]%a ]@]"
                        }), ty[0] and "_" or "", ty[2] and (
                        tags == undefined and " " or "< "
                      ) or (
                        tags == undefined and "> " or "? "
                      ), print_fields_1, ty[1], print_present, tags); end end 
       if ___conditional___ == 0--[[ Otyp_alias ]]
       or ___conditional___ == 1--[[ Otyp_arrow ]]
       or ___conditional___ == 9--[[ Otyp_tuple ]]
       or ___conditional___ == 12--[[ Otyp_poly ]]
       or ___conditional___ == 13--[[ Otyp_module ]] then do
          Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<1>",
                                  --[[ End_of_format ]]0
                                }),
                              "<1>"
                            }}),
                        --[[ String_literal ]]Block.__(11, {
                            "(module ",
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ End_of_format ]]0
                              })
                          })
                      }),
                    "@[<1>(module %s"
                  }), ty[0]);
          first = do
            contents: true
          end;
          List.iter2((function(s, t) do
                  sep = first.contents and (first.contents = false, "with") or "and";
                  return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                                  --[[ Char_literal ]]Block.__(12, {
                                      --[[ " " ]]32,
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ String_literal ]]Block.__(11, {
                                              " type ",
                                              --[[ String ]]Block.__(2, {
                                                  --[[ No_padding ]]0,
                                                  --[[ String_literal ]]Block.__(11, {
                                                      " = ",
                                                      --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                    })
                                                })
                                            })
                                        })
                                    }),
                                  " %s type %s = %a"
                                }), sep, s, print_out_type, t);
                end end), ty[1], ty[2]);
          return Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Char_literal ]]Block.__(12, {
                          --[[ ")" ]]41,
                          --[[ Formatting_lit ]]Block.__(17, {
                              --[[ Close_box ]]0,
                              --[[ End_of_format ]]0
                            })
                        }),
                      ")@]"
                    }); end end 
      return --[[ () ]]0;
        
    end
  end end 
  Format.pp_open_box(ppf, 1);
  Format.pp_print_char(ppf, --[[ "(" ]]40);
  print_out_type(ppf, ty);
  Format.pp_print_char(ppf, --[[ ")" ]]41);
  return Format.pp_close_box(ppf, --[[ () ]]0);
end end

function print_fields(rest, ppf, _param) do
  while(true) do
    param = _param;
    if (param) then do
      l = param[1];
      match = param[0];
      t = match[1];
      s = match[0];
      if (l) then do
        return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ String ]]Block.__(2, {
                            --[[ No_padding ]]0,
                            --[[ String_literal ]]Block.__(11, {
                                " : ",
                                --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                        --[[ ";" ]]59,
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                          })
                                      })})
                              })
                          }),
                        "%s : %a;@ %a"
                      }), s, print_out_type, t, (function(param, param_1) do
                      return print_fields(rest, param, param_1);
                    end end), l);
      end else do
        Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                  --[[ String ]]Block.__(2, {
                      --[[ No_padding ]]0,
                      --[[ String_literal ]]Block.__(11, {
                          " : ",
                          --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                        })
                    }),
                  "%s : %a"
                }), s, print_out_type, t);
        if (rest ~= undefined) then do
          Format.fprintf(ppf, --[[ Format ]]{
                --[[ Char_literal ]]Block.__(12, {
                    --[[ ";" ]]59,
                    --[[ Formatting_lit ]]Block.__(17, {
                        --[[ Break ]]Block.__(0, {
                            "@ ",
                            1,
                            0
                          }),
                        --[[ End_of_format ]]0
                      })
                  }),
                ";@ "
              });
        end
         end 
        _param = --[[ [] ]]0;
        ::continue:: ;
      end end 
    end else if (rest ~= undefined) then do
      return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String ]]Block.__(2, {
                          --[[ No_padding ]]0,
                          --[[ String_literal ]]Block.__(11, {
                              "..",
                              --[[ End_of_format ]]0
                            })
                        }),
                      "%s.."
                    }), rest and "_" or "");
    end else do
      return --[[ () ]]0;
    end end  end 
  end;
end end

function print_row_field(ppf, param) do
  tyl = param[2];
  opt_amp = param[1];
  pr_of = function(ppf) do
    if (opt_amp) then do
      return Format.fprintf(ppf, --[[ Format ]]{
                  --[[ String_literal ]]Block.__(11, {
                      " of",
                      --[[ Formatting_lit ]]Block.__(17, {
                          --[[ Break ]]Block.__(0, {
                              "@ ",
                              1,
                              0
                            }),
                          --[[ Char_literal ]]Block.__(12, {
                              --[[ "&" ]]38,
                              --[[ Formatting_lit ]]Block.__(17, {
                                  --[[ Break ]]Block.__(0, {
                                      "@ ",
                                      1,
                                      0
                                    }),
                                  --[[ End_of_format ]]0
                                })
                            })
                        })
                    }),
                  " of@ &@ "
                });
    end else if (tyl ~= --[[ [] ]]0) then do
      return Format.fprintf(ppf, --[[ Format ]]{
                  --[[ String_literal ]]Block.__(11, {
                      " of",
                      --[[ Formatting_lit ]]Block.__(17, {
                          --[[ Break ]]Block.__(0, {
                              "@ ",
                              1,
                              0
                            }),
                          --[[ End_of_format ]]0
                        })
                    }),
                  " of@ "
                });
    end else do
      return Format.fprintf(ppf, --[[ Format ]]{
                  --[[ End_of_format ]]0,
                  ""
                });
    end end  end 
  end end;
  return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                  --[[ Formatting_gen ]]Block.__(18, {
                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                            --[[ String_literal ]]Block.__(11, {
                                "<hv 2>",
                                --[[ End_of_format ]]0
                              }),
                            "<hv 2>"
                          }}),
                      --[[ Char_literal ]]Block.__(12, {
                          --[[ "`" ]]96,
                          --[[ String ]]Block.__(2, {
                              --[[ No_padding ]]0,
                              --[[ Theta ]]Block.__(16, {--[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Close_box ]]0,
                                          --[[ End_of_format ]]0
                                        })})})
                            })
                        })
                    }),
                  "@[<hv 2>`%s%t%a@]"
                }), param[0], pr_of, (function(param, param_1) do
                return print_typlist(print_out_type, " &", param, param_1);
              end end), tyl);
end end

function print_typlist(print_elem, sep, ppf, _param) do
  while(true) do
    param = _param;
    if (param) then do
      tyl = param[1];
      ty = param[0];
      if (tyl) then do
        Curry._2(print_elem, ppf, ty);
        Format.pp_print_string(ppf, sep);
        Format.pp_print_space(ppf, --[[ () ]]0);
        _param = tyl;
        ::continue:: ;
      end else do
        return Curry._2(print_elem, ppf, ty);
      end end 
    end else do
      return --[[ () ]]0;
    end end 
  end;
end end

function print_typargs(ppf, tyl) do
  if (tyl) then do
    if (tyl[1]) then do
      Format.pp_open_box(ppf, 1);
      Format.pp_print_char(ppf, --[[ "(" ]]40);
      print_typlist(print_out_type, ",", ppf, tyl);
      Format.pp_print_char(ppf, --[[ ")" ]]41);
      Format.pp_close_box(ppf, --[[ () ]]0);
      return Format.pp_print_space(ppf, --[[ () ]]0);
    end else do
      print_simple_out_type(ppf, tyl[0]);
      return Format.pp_print_space(ppf, --[[ () ]]0);
    end end 
  end else do
    return --[[ () ]]0;
  end end 
end end

out_type = do
  contents: print_out_type
end;

function type_parameter(ppf, param) do
  match = param[1];
  ty = param[0];
  return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                  --[[ String ]]Block.__(2, {
                      --[[ No_padding ]]0,
                      --[[ String ]]Block.__(2, {
                          --[[ No_padding ]]0,
                          --[[ End_of_format ]]0
                        })
                    }),
                  "%s%s"
                }), match[1] and (
                match[0] and "" or "-"
              ) or "+", ty == "_" and ty or "'" .. ty);
end end

function print_out_class_params(ppf, tyl) do
  if (tyl) then do
    return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<1>",
                                  --[[ End_of_format ]]0
                                }),
                              "<1>"
                            }}),
                        --[[ Char_literal ]]Block.__(12, {
                            --[[ "[" ]]91,
                            --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                    --[[ "]" ]]93,
                                    --[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Close_box ]]0,
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ End_of_format ]]0
                                          })
                                      })
                                  })})
                          })
                      }),
                    "@[<1>[%a]@]@ "
                  }), (function(param, param_1) do
                  return print_list(type_parameter, (function(ppf) do
                                return Format.fprintf(ppf, --[[ Format ]]{
                                            --[[ String_literal ]]Block.__(11, {
                                                ", ",
                                                --[[ End_of_format ]]0
                                              }),
                                            ", "
                                          });
                              end end), param, param_1);
                end end), tyl);
  end else do
    return --[[ () ]]0;
  end end 
end end

function print_out_class_type(ppf, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Octy_constr ]] then do
        pr_tyl = function(ppf, tyl) do
          if (tyl) then do
            partial_arg = out_type.contents;
            return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                            --[[ Formatting_gen ]]Block.__(18, {
                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                      --[[ String_literal ]]Block.__(11, {
                                          "<1>",
                                          --[[ End_of_format ]]0
                                        }),
                                      "<1>"
                                    }}),
                                --[[ Char_literal ]]Block.__(12, {
                                    --[[ "[" ]]91,
                                    --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                            --[[ "]" ]]93,
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Close_box ]]0,
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ End_of_format ]]0
                                                  })
                                              })
                                          })})
                                  })
                              }),
                            "@[<1>[%a]@]@ "
                          }), (function(param, param_1) do
                          return print_typlist(partial_arg, ",", param, param_1);
                        end end), tyl);
          end else do
            return --[[ () ]]0;
          end end 
        end end;
        return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ End_of_format ]]0,
                                  ""
                                }}),
                            --[[ Alpha ]]Block.__(15, {--[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Close_box ]]0,
                                        --[[ End_of_format ]]0
                                      })})})
                          }),
                        "@[%a%a@]"
                      }), pr_tyl, param[1], print_ident, param[0]); end end 
     if ___conditional___ == 1--[[ Octy_arrow ]] then do
        lab = param[0];
        return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ End_of_format ]]0,
                                  ""
                                }}),
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                        " ->",
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Close_box ]]0,
                                                    --[[ End_of_format ]]0
                                                  })})
                                          })
                                      })})
                              })
                          }),
                        "@[%s%a ->@ %a@]"
                      }), lab ~= "" and lab .. ":" or "", print_out_type_2, param[1], print_out_class_type, param[2]); end end 
     if ___conditional___ == 2--[[ Octy_signature ]] then do
        pr_param = function(ppf, param) do
          if (param ~= undefined) then do
            return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                            --[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@ ",
                                    1,
                                    0
                                  }),
                                --[[ Formatting_gen ]]Block.__(18, {
                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                          --[[ End_of_format ]]0,
                                          ""
                                        }}),
                                    --[[ Char_literal ]]Block.__(12, {
                                        --[[ "(" ]]40,
                                        --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                --[[ ")" ]]41,
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Close_box ]]0,
                                                    --[[ End_of_format ]]0
                                                  })
                                              })})
                                      })
                                  })
                              }),
                            "@ @[(%a)@]"
                          }), out_type.contents, param);
          end else do
            return --[[ () ]]0;
          end end 
        end end;
        return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      "<hv 2>",
                                      --[[ End_of_format ]]0
                                    }),
                                  "<hv 2>"
                                }}),
                            --[[ Formatting_gen ]]Block.__(18, {
                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                      --[[ String_literal ]]Block.__(11, {
                                          "<2>",
                                          --[[ End_of_format ]]0
                                        }),
                                      "<2>"
                                    }}),
                                --[[ String_literal ]]Block.__(11, {
                                    "object",
                                    --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Close_box ]]0,
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Break ]]Block.__(0, {
                                                    "@ ",
                                                    1,
                                                    0
                                                  }),
                                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                        --[[ Break ]]Block.__(0, {
                                                            "@;<1 -2>",
                                                            1,
                                                            -2
                                                          }),
                                                        --[[ String_literal ]]Block.__(11, {
                                                            "end",
                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                --[[ Close_box ]]0,
                                                                --[[ End_of_format ]]0
                                                              })
                                                          })
                                                      })})
                                              })
                                          })})
                                  })
                              })
                          }),
                        "@[<hv 2>@[<2>object%a@]@ %a@;<1 -2>end@]"
                      }), pr_param, param[0], (function(param, param_1) do
                      return print_list(print_out_class_sig_item, (function(ppf) do
                                    return Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ End_of_format ]]0
                                                  }),
                                                "@ "
                                              });
                                  end end), param, param_1);
                    end end), param[1]); end end 
    
  end
end end

function print_out_class_sig_item(ppf, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Ocsg_constraint ]] then do
        return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      "<2>",
                                      --[[ End_of_format ]]0
                                    }),
                                  "<2>"
                                }}),
                            --[[ String_literal ]]Block.__(11, {
                                "constraint ",
                                --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                        " =",
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Close_box ]]0,
                                                    --[[ End_of_format ]]0
                                                  })})
                                          })
                                      })})
                              })
                          }),
                        "@[<2>constraint %a =@ %a@]"
                      }), out_type.contents, param[0], out_type.contents, param[1]); end end 
     if ___conditional___ == 1--[[ Ocsg_method ]] then do
        return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      "<2>",
                                      --[[ End_of_format ]]0
                                    }),
                                  "<2>"
                                }}),
                            --[[ String_literal ]]Block.__(11, {
                                "method ",
                                --[[ String ]]Block.__(2, {
                                    --[[ No_padding ]]0,
                                    --[[ String ]]Block.__(2, {
                                        --[[ No_padding ]]0,
                                        --[[ String ]]Block.__(2, {
                                            --[[ No_padding ]]0,
                                            --[[ String_literal ]]Block.__(11, {
                                                " :",
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Close_box ]]0,
                                                            --[[ End_of_format ]]0
                                                          })})
                                                  })
                                              })
                                          })
                                      })
                                  })
                              })
                          }),
                        "@[<2>method %s%s%s :@ %a@]"
                      }), param[1] and "private " or "", param[2] and "virtual " or "", param[0], out_type.contents, param[3]); end end 
     if ___conditional___ == 2--[[ Ocsg_value ]] then do
        return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      "<2>",
                                      --[[ End_of_format ]]0
                                    }),
                                  "<2>"
                                }}),
                            --[[ String_literal ]]Block.__(11, {
                                "val ",
                                --[[ String ]]Block.__(2, {
                                    --[[ No_padding ]]0,
                                    --[[ String ]]Block.__(2, {
                                        --[[ No_padding ]]0,
                                        --[[ String ]]Block.__(2, {
                                            --[[ No_padding ]]0,
                                            --[[ String_literal ]]Block.__(11, {
                                                " :",
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Close_box ]]0,
                                                            --[[ End_of_format ]]0
                                                          })})
                                                  })
                                              })
                                          })
                                      })
                                  })
                              })
                          }),
                        "@[<2>val %s%s%s :@ %a@]"
                      }), param[1] and "mutable " or "", param[2] and "virtual " or "", param[0], out_type.contents, param[3]); end end 
    
  end
end end

out_class_type = do
  contents: print_out_class_type
end;

out_module_type = do
  contents: (function(param) do
      error({
        Caml_builtin_exceptions.failure,
        "Oprint.out_module_type"
      })
    end end)
end;

out_sig_item = do
  contents: (function(param) do
      error({
        Caml_builtin_exceptions.failure,
        "Oprint.out_sig_item"
      })
    end end)
end;

out_signature = do
  contents: (function(param) do
      error({
        Caml_builtin_exceptions.failure,
        "Oprint.out_signature"
      })
    end end)
end;

out_type_extension = do
  contents: (function(param) do
      error({
        Caml_builtin_exceptions.failure,
        "Oprint.out_type_extension"
      })
    end end)
end;

function print_out_functor(ppf, m) do
  if (typeof m ~= "number" and not m.tag) then do
    match = m[1];
    if (match ~= undefined) then do
      return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Char_literal ]]Block.__(12, {
                          --[[ "(" ]]40,
                          --[[ String ]]Block.__(2, {
                              --[[ No_padding ]]0,
                              --[[ String_literal ]]Block.__(11, {
                                  " : ",
                                  --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                          ") ",
                                          --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                        })})
                                })
                            })
                        }),
                      "(%s : %a) %a"
                    }), m[0], print_out_module_type, match, print_out_functor, m[2]);
    end else do
      return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "() ",
                          --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                        }),
                      "() %a"
                    }), print_out_functor, m[2]);
    end end 
  end
   end 
  return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                  --[[ String_literal ]]Block.__(11, {
                      "->",
                      --[[ Formatting_lit ]]Block.__(17, {
                          --[[ Break ]]Block.__(0, {
                              "@ ",
                              1,
                              0
                            }),
                          --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                        })
                    }),
                  "->@ %a"
                }), print_out_module_type, m);
end end

function print_out_constr(ppf, param) do
  ret_type_opt = param[2];
  tyl = param[1];
  name = param[0];
  if (ret_type_opt ~= undefined) then do
    ret_type = ret_type_opt;
    if (tyl) then do
      return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Formatting_gen ]]Block.__(18, {
                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                --[[ String_literal ]]Block.__(11, {
                                    "<2>",
                                    --[[ End_of_format ]]0
                                  }),
                                "<2>"
                              }}),
                          --[[ String ]]Block.__(2, {
                              --[[ No_padding ]]0,
                              --[[ String_literal ]]Block.__(11, {
                                  " :",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                              " -> ",
                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Close_box ]]0,
                                                      --[[ End_of_format ]]0
                                                    })})
                                            })})
                                    })
                                })
                            })
                        }),
                      "@[<2>%s :@ %a -> %a@]"
                    }), name, (function(param, param_1) do
                    return print_typlist(print_simple_out_type, " *", param, param_1);
                  end end), tyl, print_simple_out_type, ret_type);
    end else do
      return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Formatting_gen ]]Block.__(18, {
                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                --[[ String_literal ]]Block.__(11, {
                                    "<2>",
                                    --[[ End_of_format ]]0
                                  }),
                                "<2>"
                              }}),
                          --[[ String ]]Block.__(2, {
                              --[[ No_padding ]]0,
                              --[[ String_literal ]]Block.__(11, {
                                  " :",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Close_box ]]0,
                                              --[[ End_of_format ]]0
                                            })})
                                    })
                                })
                            })
                        }),
                      "@[<2>%s :@ %a@]"
                    }), name, print_simple_out_type, ret_type);
    end end 
  end else if (tyl) then do
    return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<2>",
                                  --[[ End_of_format ]]0
                                }),
                              "<2>"
                            }}),
                        --[[ String ]]Block.__(2, {
                            --[[ No_padding ]]0,
                            --[[ String_literal ]]Block.__(11, {
                                " of",
                                --[[ Formatting_lit ]]Block.__(17, {
                                    --[[ Break ]]Block.__(0, {
                                        "@ ",
                                        1,
                                        0
                                      }),
                                    --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Close_box ]]0,
                                            --[[ End_of_format ]]0
                                          })})
                                  })
                              })
                          })
                      }),
                    "@[<2>%s of@ %a@]"
                  }), name, (function(param, param_1) do
                  return print_typlist(print_simple_out_type, " *", param, param_1);
                end end), tyl);
  end else do
    return Format.pp_print_string(ppf, name);
  end end  end 
end end

function print_out_label(ppf, param) do
  return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                  --[[ Formatting_gen ]]Block.__(18, {
                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                            --[[ String_literal ]]Block.__(11, {
                                "<2>",
                                --[[ End_of_format ]]0
                              }),
                            "<2>"
                          }}),
                      --[[ String ]]Block.__(2, {
                          --[[ No_padding ]]0,
                          --[[ String ]]Block.__(2, {
                              --[[ No_padding ]]0,
                              --[[ String_literal ]]Block.__(11, {
                                  " :",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Close_box ]]0,
                                              --[[ Char_literal ]]Block.__(12, {
                                                  --[[ ";" ]]59,
                                                  --[[ End_of_format ]]0
                                                })
                                            })})
                                    })
                                })
                            })
                        })
                    }),
                  "@[<2>%s%s :@ %a@];"
                }), param[1] and "mutable " or "", param[0], out_type.contents, param[2]);
end end

function print_out_signature(ppf, param) do
  if (param) then do
    item = param[0];
    if (param[1]) then do
      if (item.tag == --[[ Osig_typext ]]2 and item[1] == 0) then do
        ext = item[0];
        gather_extensions = function(_acc, _items) do
          while(true) do
            items = _items;
            acc = _acc;
            if (items) then do
              match = items[0];
              if (match.tag == --[[ Osig_typext ]]2 and match[1] == 1) then do
                ext = match[0];
                _items = items[1];
                _acc = --[[ :: ]]{
                  --[[ tuple ]]{
                    ext.oext_name,
                    ext.oext_args,
                    ext.oext_ret_type
                  },
                  acc
                };
                ::continue:: ;
              end else do
                return --[[ tuple ]]{
                        List.rev(acc),
                        items
                      };
              end end 
            end else do
              return --[[ tuple ]]{
                      List.rev(acc),
                      items
                    };
            end end 
          end;
        end end;
        match = gather_extensions(--[[ :: ]]{
              --[[ tuple ]]{
                ext.oext_name,
                ext.oext_args,
                ext.oext_ret_type
              },
              --[[ [] ]]0
            }, param[1]);
        te_otyext_name = ext.oext_type_name;
        te_otyext_params = ext.oext_type_params;
        te_otyext_constructors = match[0];
        te_otyext_private = ext.oext_private;
        te = do
          otyext_name: te_otyext_name,
          otyext_params: te_otyext_params,
          otyext_constructors: te_otyext_constructors,
          otyext_private: te_otyext_private
        end;
        return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@ ",
                                    1,
                                    0
                                  }),
                                --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                              })}),
                        "%a@ %a"
                      }), out_type_extension.contents, te, print_out_signature, match[1]);
      end
       end 
    end else do
      return Curry._2(out_sig_item.contents, ppf, item);
    end end 
    return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                            --[[ Break ]]Block.__(0, {
                                "@ ",
                                1,
                                0
                              }),
                            --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                          })}),
                    "%a@ %a"
                  }), out_sig_item.contents, item, print_out_signature, param[1]);
  end else do
    return --[[ () ]]0;
  end end 
end end

function print_out_module_type(ppf, t) do
  if (typeof t == "number") then do
    return --[[ () ]]0;
  end else do
    local ___conditional___=(t.tag | 0);
    do
       if ___conditional___ == 0--[[ Omty_functor ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<2>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "functor",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Close_box ]]0,
                                              --[[ End_of_format ]]0
                                            })})
                                    })
                                })
                            }),
                          "@[<2>functor@ %a@]"
                        }), print_out_functor, t); end end 
       if ___conditional___ == 1--[[ Omty_ident ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0}),
                          "%a"
                        }), print_ident, t[0]); end end 
       if ___conditional___ == 2--[[ Omty_signature ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hv 2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hv 2>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "sig",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@;<1 -2>",
                                                  1,
                                                  -2
                                                }),
                                              --[[ String_literal ]]Block.__(11, {
                                                  "end",
                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Close_box ]]0,
                                                      --[[ End_of_format ]]0
                                                    })
                                                })
                                            })})
                                    })
                                })
                            }),
                          "@[<hv 2>sig@ %a@;<1 -2>end@]"
                        }), out_signature.contents, t[0]); end end 
       if ___conditional___ == 3--[[ Omty_alias ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "(module ",
                              --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                      --[[ ")" ]]41,
                                      --[[ End_of_format ]]0
                                    })})
                            }),
                          "(module %a)"
                        }), print_ident, t[0]); end end 
      
    end
  end end 
end end

function print_out_sig_item(ppf, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Osig_class ]] then do
        return Curry._7(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      "<2>",
                                      --[[ End_of_format ]]0
                                    }),
                                  "<2>"
                                }}),
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ String ]]Block.__(2, {
                                    --[[ No_padding ]]0,
                                    --[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Break ]]Block.__(0, {
                                            "@ ",
                                            1,
                                            0
                                          }),
                                        --[[ Alpha ]]Block.__(15, {--[[ String ]]Block.__(2, {
                                                --[[ No_padding ]]0,
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ Char_literal ]]Block.__(12, {
                                                        --[[ ":" ]]58,
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Break ]]Block.__(0, {
                                                                "@ ",
                                                                1,
                                                                0
                                                              }),
                                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                    --[[ Close_box ]]0,
                                                                    --[[ End_of_format ]]0
                                                                  })})
                                                          })
                                                      })
                                                  })
                                              })})
                                      })
                                  })
                              })
                          }),
                        "@[<2>%s%s@ %a%s@ :@ %a@]"
                      }), param[4] == --[[ Orec_next ]]2 and "and" or "class", param[0] and " virtual" or "", print_out_class_params, param[2], param[1], out_class_type.contents, param[3]); end end 
     if ___conditional___ == 1--[[ Osig_class_type ]] then do
        return Curry._7(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      "<2>",
                                      --[[ End_of_format ]]0
                                    }),
                                  "<2>"
                                }}),
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ String ]]Block.__(2, {
                                    --[[ No_padding ]]0,
                                    --[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Break ]]Block.__(0, {
                                            "@ ",
                                            1,
                                            0
                                          }),
                                        --[[ Alpha ]]Block.__(15, {--[[ String ]]Block.__(2, {
                                                --[[ No_padding ]]0,
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ Char_literal ]]Block.__(12, {
                                                        --[[ "=" ]]61,
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Break ]]Block.__(0, {
                                                                "@ ",
                                                                1,
                                                                0
                                                              }),
                                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                    --[[ Close_box ]]0,
                                                                    --[[ End_of_format ]]0
                                                                  })})
                                                          })
                                                      })
                                                  })
                                              })})
                                      })
                                  })
                              })
                          }),
                        "@[<2>%s%s@ %a%s@ =@ %a@]"
                      }), param[4] == --[[ Orec_next ]]2 and "and" or "class type", param[0] and " virtual" or "", print_out_class_params, param[2], param[1], out_class_type.contents, param[3]); end end 
     if ___conditional___ == 2--[[ Osig_typext ]] then do
        ext = param[0];
        if (param[1] >= 2) then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<2>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "exception ",
                                  --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Close_box ]]0,
                                          --[[ End_of_format ]]0
                                        })})
                                })
                            }),
                          "@[<2>exception %a@]"
                        }), print_out_constr, --[[ tuple ]]{
                      ext.oext_name,
                      ext.oext_args,
                      ext.oext_ret_type
                    });
        end else do
          ppf_1 = ppf;
          ext_1 = ext;
          print_extended_type = function(ppf) do
            print_type_parameter = function(ppf, ty) do
              return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ End_of_format ]]0
                                }),
                              "%s"
                            }), ty == "_" and ty or "'" .. ty);
            end end;
            match = ext_1.oext_type_params;
            if (match) then do
              if (match[1]) then do
                return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                                --[[ Formatting_gen ]]Block.__(18, {
                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                          --[[ End_of_format ]]0,
                                          ""
                                        }}),
                                    --[[ Char_literal ]]Block.__(12, {
                                        --[[ "(" ]]40,
                                        --[[ Formatting_gen ]]Block.__(18, {
                                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                  --[[ End_of_format ]]0,
                                                  ""
                                                }}),
                                            --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                    --[[ ")" ]]41,
                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                        --[[ Close_box ]]0,
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Break ]]Block.__(0, {
                                                                "@ ",
                                                                1,
                                                                0
                                                              }),
                                                            --[[ String ]]Block.__(2, {
                                                                --[[ No_padding ]]0,
                                                                --[[ Formatting_lit ]]Block.__(17, {
                                                                    --[[ Close_box ]]0,
                                                                    --[[ End_of_format ]]0
                                                                  })
                                                              })
                                                          })
                                                      })
                                                  })})
                                          })
                                      })
                                  }),
                                "@[(@[%a)@]@ %s@]"
                              }), (function(param, param_1) do
                              return print_list(print_type_parameter, (function(ppf) do
                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                        --[[ Char_literal ]]Block.__(12, {
                                                            --[[ "," ]]44,
                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                --[[ Break ]]Block.__(0, {
                                                                    "@ ",
                                                                    1,
                                                                    0
                                                                  }),
                                                                --[[ End_of_format ]]0
                                                              })
                                                          }),
                                                        ",@ "
                                                      });
                                          end end), param, param_1);
                            end end), ext_1.oext_type_params, ext_1.oext_type_name);
              end else do
                return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                                --[[ Formatting_gen ]]Block.__(18, {
                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                          --[[ End_of_format ]]0,
                                          ""
                                        }}),
                                    --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ String ]]Block.__(2, {
                                                --[[ No_padding ]]0,
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Close_box ]]0,
                                                    --[[ End_of_format ]]0
                                                  })
                                              })
                                          })})
                                  }),
                                "@[%a@ %s@]"
                              }), print_type_parameter, match[0], ext_1.oext_type_name);
              end end 
            end else do
              return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ End_of_format ]]0
                                }),
                              "%s"
                            }), ext_1.oext_type_name);
            end end 
          end end;
          return Curry._4(Format.fprintf(ppf_1, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hv 2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hv 2>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "type ",
                                  --[[ Theta ]]Block.__(16, {--[[ String_literal ]]Block.__(11, {
                                          " +=",
                                          --[[ String ]]Block.__(2, {
                                              --[[ No_padding ]]0,
                                              --[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Break ]]Block.__(0, {
                                                      "@;<1 2>",
                                                      1,
                                                      2
                                                    }),
                                                  --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                          --[[ Close_box ]]0,
                                                          --[[ End_of_format ]]0
                                                        })})
                                                })
                                            })
                                        })})
                                })
                            }),
                          "@[<hv 2>type %t +=%s@;<1 2>%a@]"
                        }), print_extended_type, ext_1.oext_private == --[[ Private ]]0 and " private" or "", print_out_constr, --[[ tuple ]]{
                      ext_1.oext_name,
                      ext_1.oext_args,
                      ext_1.oext_ret_type
                    });
        end end  end end 
     if ___conditional___ == 3--[[ Osig_modtype ]] then do
        mty = param[1];
        name = param[0];
        if (typeof mty == "number") then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<2>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "module type ",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Close_box ]]0,
                                          --[[ End_of_format ]]0
                                        })
                                    })
                                })
                            }),
                          "@[<2>module type %s@]"
                        }), name);
        end else do
          return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<2>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "module type ",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ String_literal ]]Block.__(11, {
                                          " =",
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@ ",
                                                  1,
                                                  0
                                                }),
                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Close_box ]]0,
                                                      --[[ End_of_format ]]0
                                                    })})
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[<2>module type %s =@ %a@]"
                        }), name, out_module_type.contents, mty);
        end end  end end 
     if ___conditional___ == 4--[[ Osig_module ]] then do
        mty_1 = param[1];
        name_1 = param[0];
        if (typeof mty_1 ~= "number" and mty_1.tag == --[[ Omty_alias ]]3) then do
          return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<2>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "module ",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ String_literal ]]Block.__(11, {
                                          " =",
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@ ",
                                                  1,
                                                  0
                                                }),
                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Close_box ]]0,
                                                      --[[ End_of_format ]]0
                                                    })})
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[<2>module %s =@ %a@]"
                        }), name_1, print_ident, mty_1[0]);
        end
         end 
        tmp;
        local ___conditional___=(param[2]);
        do
           if ___conditional___ == 0--[[ Orec_not ]] then do
              tmp = "module"; end else 
           if ___conditional___ == 1--[[ Orec_first ]] then do
              tmp = "module rec"; end else 
           if ___conditional___ == 2--[[ Orec_next ]] then do
              tmp = "and"; end else 
           end end end end end end
          
        end
        return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      "<2>",
                                      --[[ End_of_format ]]0
                                    }),
                                  "<2>"
                                }}),
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ Char_literal ]]Block.__(12, {
                                    --[[ " " ]]32,
                                    --[[ String ]]Block.__(2, {
                                        --[[ No_padding ]]0,
                                        --[[ String_literal ]]Block.__(11, {
                                            " :",
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Break ]]Block.__(0, {
                                                    "@ ",
                                                    1,
                                                    0
                                                  }),
                                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                        --[[ Close_box ]]0,
                                                        --[[ End_of_format ]]0
                                                      })})
                                              })
                                          })
                                      })
                                  })
                              })
                          }),
                        "@[<2>%s %s :@ %a@]"
                      }), tmp, name_1, out_module_type.contents, mty_1); end end 
     if ___conditional___ == 5--[[ Osig_type ]] then do
        tmp_1;
        local ___conditional___=(param[1]);
        do
           if ___conditional___ == 0--[[ Orec_not ]] then do
              tmp_1 = "type nonrec"; end else 
           if ___conditional___ == 1--[[ Orec_first ]] then do
              tmp_1 = "type"; end else 
           if ___conditional___ == 2--[[ Orec_next ]] then do
              tmp_1 = "and"; end else 
           end end end end end end
          
        end
        kwd = tmp_1;
        ppf_2 = ppf;
        td = param[0];
        print_constraints = function(ppf) do
          return List.iter((function(param) do
                        return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ Formatting_gen ]]Block.__(18, {
                                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                      --[[ String_literal ]]Block.__(11, {
                                                          "<2>",
                                                          --[[ End_of_format ]]0
                                                        }),
                                                      "<2>"
                                                    }}),
                                                --[[ String_literal ]]Block.__(11, {
                                                    "constraint ",
                                                    --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                                            " =",
                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                --[[ Break ]]Block.__(0, {
                                                                    "@ ",
                                                                    1,
                                                                    0
                                                                  }),
                                                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                        --[[ Close_box ]]0,
                                                                        --[[ End_of_format ]]0
                                                                      })})
                                                              })
                                                          })})
                                                  })
                                              })
                                          }),
                                        "@ @[<2>constraint %a =@ %a@]"
                                      }), out_type.contents, param[0], out_type.contents, param[1]);
                      end end), td.otype_cstrs);
        end end;
        type_defined = function(ppf) do
          match = td.otype_params;
          if (match) then do
            if (match[1]) then do
              return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                              --[[ Formatting_gen ]]Block.__(18, {
                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                        --[[ End_of_format ]]0,
                                        ""
                                      }}),
                                  --[[ Char_literal ]]Block.__(12, {
                                      --[[ "(" ]]40,
                                      --[[ Formatting_gen ]]Block.__(18, {
                                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                --[[ End_of_format ]]0,
                                                ""
                                              }}),
                                          --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                  --[[ ")" ]]41,
                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Close_box ]]0,
                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                          --[[ Break ]]Block.__(0, {
                                                              "@ ",
                                                              1,
                                                              0
                                                            }),
                                                          --[[ String ]]Block.__(2, {
                                                              --[[ No_padding ]]0,
                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                  --[[ Close_box ]]0,
                                                                  --[[ End_of_format ]]0
                                                                })
                                                            })
                                                        })
                                                    })
                                                })})
                                        })
                                    })
                                }),
                              "@[(@[%a)@]@ %s@]"
                            }), (function(param, param_1) do
                            return print_list(type_parameter, (function(ppf) do
                                          return Format.fprintf(ppf, --[[ Format ]]{
                                                      --[[ Char_literal ]]Block.__(12, {
                                                          --[[ "," ]]44,
                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Break ]]Block.__(0, {
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                }),
                                                              --[[ End_of_format ]]0
                                                            })
                                                        }),
                                                      ",@ "
                                                    });
                                        end end), param, param_1);
                          end end), td.otype_params, td.otype_name);
            end else do
              return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                              --[[ Formatting_gen ]]Block.__(18, {
                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                        --[[ End_of_format ]]0,
                                        ""
                                      }}),
                                  --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ String ]]Block.__(2, {
                                              --[[ No_padding ]]0,
                                              --[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Close_box ]]0,
                                                  --[[ End_of_format ]]0
                                                })
                                            })
                                        })})
                                }),
                              "@[%a@ %s@]"
                            }), type_parameter, match[0], td.otype_name);
            end end 
          end else do
            return Format.pp_print_string(ppf, td.otype_name);
          end end 
        end end;
        print_manifest = function(ppf, param) do
          if (typeof param == "number" or param.tag ~= --[[ Otyp_manifest ]]4) then do
            return --[[ () ]]0;
          end else do
            return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                            --[[ String_literal ]]Block.__(11, {
                                " =",
                                --[[ Formatting_lit ]]Block.__(17, {
                                    --[[ Break ]]Block.__(0, {
                                        "@ ",
                                        1,
                                        0
                                      }),
                                    --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                  })
                              }),
                            " =@ %a"
                          }), out_type.contents, param[0]);
          end end 
        end end;
        print_name_params = function(ppf) do
          return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String ]]Block.__(2, {
                              --[[ No_padding ]]0,
                              --[[ Char_literal ]]Block.__(12, {
                                  --[[ " " ]]32,
                                  --[[ Theta ]]Block.__(16, {--[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})})
                                })
                            }),
                          "%s %t%a"
                        }), kwd, type_defined, print_manifest, td.otype_type);
        end end;
        match = td.otype_type;
        ty;
        ty = typeof match == "number" or match.tag ~= --[[ Otyp_manifest ]]4 and td.otype_type or match[1];
        print_private = function(ppf, param) do
          if (param) then do
            return --[[ () ]]0;
          end else do
            return Format.fprintf(ppf, --[[ Format ]]{
                        --[[ String_literal ]]Block.__(11, {
                            " private",
                            --[[ End_of_format ]]0
                          }),
                        " private"
                      });
          end end 
        end end;
        print_out_tkind = function(ppf, ty) do
          if (typeof ty == "number") then do
            if (ty == --[[ Otyp_abstract ]]0) then do
              return --[[ () ]]0;
            end else do
              return Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              " = ..",
                              --[[ End_of_format ]]0
                            }),
                          " = .."
                        });
            end end 
          end else do
            local ___conditional___=(ty.tag | 0);
            do
               if ___conditional___ == 6--[[ Otyp_record ]] then do
                  return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      " =",
                                      --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                              " {",
                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Break ]]Block.__(0, {
                                                          "@;<1 -2>",
                                                          1,
                                                          -2
                                                        }),
                                                      --[[ Char_literal ]]Block.__(12, {
                                                          --[[ "}" ]]125,
                                                          --[[ End_of_format ]]0
                                                        })
                                                    })})
                                            })})
                                    }),
                                  " =%a {%a@;<1 -2>}"
                                }), print_private, td.otype_private, (function(param, param_1) do
                                pr = print_out_label;
                                sep = function(ppf) do
                                  return Format.fprintf(ppf, --[[ Format ]]{
                                              --[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Break ]]Block.__(0, {
                                                      "@ ",
                                                      1,
                                                      0
                                                    }),
                                                  --[[ End_of_format ]]0
                                                }),
                                              "@ "
                                            });
                                end end;
                                ppf = param;
                                _param = param_1;
                                while(true) do
                                  param_2 = _param;
                                  if (param_2) then do
                                    Curry._1(sep, ppf);
                                    Curry._2(pr, ppf, param_2[0]);
                                    _param = param_2[1];
                                    ::continue:: ;
                                  end else do
                                    return --[[ () ]]0;
                                  end end 
                                end;
                              end end), ty[0]); end end 
               if ___conditional___ == 8--[[ Otyp_sum ]] then do
                  return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      " =",
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@;<1 2>",
                                                  1,
                                                  2
                                                }),
                                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                            })})
                                    }),
                                  " =%a@;<1 2>%a"
                                }), print_private, td.otype_private, (function(param, param_1) do
                                return print_list(print_out_constr, (function(ppf) do
                                              return Format.fprintf(ppf, --[[ Format ]]{
                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Break ]]Block.__(0, {
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                }),
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "| ",
                                                                  --[[ End_of_format ]]0
                                                                })
                                                            }),
                                                          "@ | "
                                                        });
                                            end end), param, param_1);
                              end end), ty[0]); end end 
              return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                                --[[ String_literal ]]Block.__(11, {
                                    " =",
                                    --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@;<1 2>",
                                                1,
                                                2
                                              }),
                                            --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                          })})
                                  }),
                                " =%a@;<1 2>%a"
                              }), print_private, td.otype_private, out_type.contents, ty);
                
            end
          end end 
        end end;
        return Curry._4(Format.fprintf(ppf_2, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      "<2>",
                                      --[[ End_of_format ]]0
                                    }),
                                  "<2>"
                                }}),
                            --[[ Formatting_gen ]]Block.__(18, {
                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                      --[[ String_literal ]]Block.__(11, {
                                          "<hv 2>",
                                          --[[ End_of_format ]]0
                                        }),
                                      "<hv 2>"
                                    }}),
                                --[[ Theta ]]Block.__(16, {--[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Close_box ]]0,
                                            --[[ Theta ]]Block.__(16, {--[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Close_box ]]0,
                                                    --[[ End_of_format ]]0
                                                  })})
                                          })})})
                              })
                          }),
                        "@[<2>@[<hv 2>%t%a@]%t@]"
                      }), print_name_params, print_out_tkind, ty, print_constraints); end end 
     if ___conditional___ == 6--[[ Osig_value ]] then do
        prims = param[2];
        kwd_1 = prims == --[[ [] ]]0 and "val" or "external";
        pr_prims = function(ppf, param) do
          if (param) then do
            Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Formatting_lit ]]Block.__(17, {
                          --[[ Break ]]Block.__(0, {
                              "@ ",
                              1,
                              0
                            }),
                          --[[ String_literal ]]Block.__(11, {
                              "= \"",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ Char_literal ]]Block.__(12, {
                                      --[[ "\"" ]]34,
                                      --[[ End_of_format ]]0
                                    })
                                })
                            })
                        }),
                      "@ = \"%s\""
                    }), param[0]);
            return List.iter((function(s) do
                          len = #s;
                          if (len >= 3 and Caml_string.get(s, 0) == --[[ "B" ]]66 and Caml_string.get(s, 1) == --[[ "S" ]]83 and Caml_string.get(s, 2) == --[[ ":" ]]58) then do
                            return Format.fprintf(ppf, --[[ Format ]]{
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ String_literal ]]Block.__(11, {
                                                "\"BS-EXTERNAL\"",
                                                --[[ End_of_format ]]0
                                              })
                                          }),
                                        "@ \"BS-EXTERNAL\""
                                      });
                          end else do
                            return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Break ]]Block.__(0, {
                                                    "@ ",
                                                    1,
                                                    0
                                                  }),
                                                --[[ Char_literal ]]Block.__(12, {
                                                    --[[ "\"" ]]34,
                                                    --[[ String ]]Block.__(2, {
                                                        --[[ No_padding ]]0,
                                                        --[[ Char_literal ]]Block.__(12, {
                                                            --[[ "\"" ]]34,
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })
                                                  })
                                              }),
                                            "@ \"%s\""
                                          }), s);
                          end end 
                        end end), param[1]);
          end else do
            return --[[ () ]]0;
          end end 
        end end;
        return Curry._7(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      "<2>",
                                      --[[ End_of_format ]]0
                                    }),
                                  "<2>"
                                }}),
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ Char_literal ]]Block.__(12, {
                                    --[[ " " ]]32,
                                    --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                            " :",
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Break ]]Block.__(0, {
                                                    "@ ",
                                                    1,
                                                    0
                                                  }),
                                                --[[ Alpha ]]Block.__(15, {--[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Close_box ]]0,
                                                            --[[ End_of_format ]]0
                                                          })})})
                                              })
                                          })})
                                  })
                              })
                          }),
                        "@[<2>%s %a :@ %a%a@]"
                      }), kwd_1, value_ident, param[0], out_type.contents, param[1], pr_prims, prims); end end 
    
  end
end end

function print_out_type_extension(ppf, te) do
  print_extended_type = function(ppf) do
    print_type_parameter = function(ppf, ty) do
      return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String ]]Block.__(2, {
                          --[[ No_padding ]]0,
                          --[[ End_of_format ]]0
                        }),
                      "%s"
                    }), ty == "_" and ty or "'" .. ty);
    end end;
    match = te.otyext_params;
    if (match) then do
      if (match[1]) then do
        return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ End_of_format ]]0,
                                  ""
                                }}),
                            --[[ Char_literal ]]Block.__(12, {
                                --[[ "(" ]]40,
                                --[[ Formatting_gen ]]Block.__(18, {
                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                          --[[ End_of_format ]]0,
                                          ""
                                        }}),
                                    --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                            --[[ ")" ]]41,
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Close_box ]]0,
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ String ]]Block.__(2, {
                                                        --[[ No_padding ]]0,
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Close_box ]]0,
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })
                                                  })
                                              })
                                          })})
                                  })
                              })
                          }),
                        "@[(@[%a)@]@ %s@]"
                      }), (function(param, param_1) do
                      return print_list(print_type_parameter, (function(ppf) do
                                    return Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ Char_literal ]]Block.__(12, {
                                                    --[[ "," ]]44,
                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                        --[[ Break ]]Block.__(0, {
                                                            "@ ",
                                                            1,
                                                            0
                                                          }),
                                                        --[[ End_of_format ]]0
                                                      })
                                                  }),
                                                ",@ "
                                              });
                                  end end), param, param_1);
                    end end), te.otyext_params, te.otyext_name);
      end else do
        return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ End_of_format ]]0,
                                  ""
                                }}),
                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                    --[[ Break ]]Block.__(0, {
                                        "@ ",
                                        1,
                                        0
                                      }),
                                    --[[ String ]]Block.__(2, {
                                        --[[ No_padding ]]0,
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Close_box ]]0,
                                            --[[ End_of_format ]]0
                                          })
                                      })
                                  })})
                          }),
                        "@[%a@ %s@]"
                      }), print_type_parameter, match[0], te.otyext_name);
      end end 
    end else do
      return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String ]]Block.__(2, {
                          --[[ No_padding ]]0,
                          --[[ End_of_format ]]0
                        }),
                      "%s"
                    }), te.otyext_name);
    end end 
  end end;
  return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                  --[[ Formatting_gen ]]Block.__(18, {
                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                            --[[ String_literal ]]Block.__(11, {
                                "<hv 2>",
                                --[[ End_of_format ]]0
                              }),
                            "<hv 2>"
                          }}),
                      --[[ String_literal ]]Block.__(11, {
                          "type ",
                          --[[ Theta ]]Block.__(16, {--[[ String_literal ]]Block.__(11, {
                                  " +=",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@;<1 2>",
                                              1,
                                              2
                                            }),
                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Close_box ]]0,
                                                  --[[ End_of_format ]]0
                                                })})
                                        })
                                    })
                                })})
                        })
                    }),
                  "@[<hv 2>type %t +=%s@;<1 2>%a@]"
                }), print_extended_type, te.otyext_private == --[[ Private ]]0 and " private" or "", (function(param, param_1) do
                return print_list(print_out_constr, (function(ppf) do
                              return Format.fprintf(ppf, --[[ Format ]]{
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@ ",
                                                  1,
                                                  0
                                                }),
                                              --[[ String_literal ]]Block.__(11, {
                                                  "| ",
                                                  --[[ End_of_format ]]0
                                                })
                                            }),
                                          "@ | "
                                        });
                            end end), param, param_1);
              end end), te.otyext_constructors);
end end

out_module_type.contents = print_out_module_type;

out_signature.contents = print_out_signature;

out_sig_item.contents = print_out_sig_item;

out_type_extension.contents = print_out_type_extension;

function longident(ppf, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Lident ]] then do
        return Format.pp_print_string(ppf, param[0]); end end 
     if ___conditional___ == 1--[[ Ldot ]] then do
        return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                --[[ "." ]]46,
                                --[[ String ]]Block.__(2, {
                                    --[[ No_padding ]]0,
                                    --[[ End_of_format ]]0
                                  })
                              })}),
                        "%a.%s"
                      }), longident, param[0], param[1]); end end 
     if ___conditional___ == 2--[[ Lapply ]] then do
        return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                --[[ "(" ]]40,
                                --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                        --[[ ")" ]]41,
                                        --[[ End_of_format ]]0
                                      })})
                              })}),
                        "%a(%a)"
                      }), longident, param[0], longident, param[1]); end end 
    
  end
end end

unique_names = do
  contents: --[[ Empty ]]0
end;

function ident_name(id) do
  xpcall(function() do
    return find_same(id, unique_names.contents);
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return id.name;
    end else do
      error(exn)
    end end 
  end end)
end end

function add_unique(id) do
  xpcall(function() do
    find_same(id, unique_names.contents);
    return --[[ () ]]0;
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      unique_names.contents = add(id, unique_toplevel_name(id), unique_names.contents);
      return --[[ () ]]0;
    end else do
      error(exn)
    end end 
  end end)
end end

function ident_3(ppf, id) do
  return Format.pp_print_string(ppf, ident_name(id));
end end

ident_pervasive = do
  stamp: 0,
  name: "Pervasives",
  flags: 1
end;

function tree_of_path(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Pident ]] then do
        return --[[ Oide_ident ]]Block.__(2, {ident_name(param[0])}); end end 
     if ___conditional___ == 1--[[ Pdot ]] then do
        p = param[0];
        local ___conditional___=(p.tag | 0);
        do
           if ___conditional___ == 0--[[ Pident ]] then do
              if (Caml_obj.caml_equal(p[0], ident_pervasive)) then do
                return --[[ Oide_ident ]]Block.__(2, {param[1]});
              end
               end  end else 
           if ___conditional___ == 1--[[ Pdot ]]
           or ___conditional___ == 2--[[ Papply ]]
           end end end
          
        end
        return --[[ Oide_dot ]]Block.__(1, {
                  tree_of_path(p),
                  param[1]
                }); end end 
     if ___conditional___ == 2--[[ Papply ]] then do
        return --[[ Oide_apply ]]Block.__(0, {
                  tree_of_path(param[0]),
                  tree_of_path(param[1])
                }); end end 
    
  end
end end

function path(ppf, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Pident ]] then do
        return Format.pp_print_string(ppf, ident_name(param[0])); end end 
     if ___conditional___ == 1--[[ Pdot ]] then do
        p = param[0];
        local ___conditional___=(p.tag | 0);
        do
           if ___conditional___ == 0--[[ Pident ]] then do
              if (Caml_obj.caml_equal(p[0], ident_pervasive)) then do
                return Format.pp_print_string(ppf, param[1]);
              end
               end  end else 
           if ___conditional___ == 1--[[ Pdot ]]
           or ___conditional___ == 2--[[ Papply ]]
           end end end
          
        end
        path(ppf, p);
        Format.pp_print_char(ppf, --[[ "." ]]46);
        return Format.pp_print_string(ppf, param[1]); end end 
     if ___conditional___ == 2--[[ Papply ]] then do
        return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                --[[ "(" ]]40,
                                --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                        --[[ ")" ]]41,
                                        --[[ End_of_format ]]0
                                      })})
                              })}),
                        "%a(%a)"
                      }), path, param[0], path, param[1]); end end 
    
  end
end end

function string_of_out_ident(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Oide_apply ]] then do
        return __String.concat("", --[[ :: ]]{
                    string_of_out_ident(param[0]),
                    --[[ :: ]]{
                      "(",
                      --[[ :: ]]{
                        string_of_out_ident(param[1]),
                        --[[ :: ]]{
                          ")",
                          --[[ [] ]]0
                        }
                      }
                    }
                  }); end end 
     if ___conditional___ == 1--[[ Oide_dot ]] then do
        return __String.concat(".", --[[ :: ]]{
                    string_of_out_ident(param[0]),
                    --[[ :: ]]{
                      param[1],
                      --[[ [] ]]0
                    }
                  }); end end 
     if ___conditional___ == 2--[[ Oide_ident ]] then do
        return param[0]; end end 
    
  end
end end

function string_of_path(p) do
  return string_of_out_ident(tree_of_path(p));
end end

function raw_list(pr, ppf, param) do
  if (param) then do
    l = param[1];
    return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<1>",
                                  --[[ End_of_format ]]0
                                }),
                              "<1>"
                            }}),
                        --[[ Char_literal ]]Block.__(12, {
                            --[[ "[" ]]91,
                            --[[ Alpha ]]Block.__(15, {--[[ Theta ]]Block.__(16, {--[[ Char_literal ]]Block.__(12, {
                                        --[[ "]" ]]93,
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Close_box ]]0,
                                            --[[ End_of_format ]]0
                                          })
                                      })})})
                          })
                      }),
                    "@[<1>[%a%t]@]"
                  }), pr, param[0], (function(ppf) do
                  return List.iter((function(x) do
                                return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ Char_literal ]]Block.__(12, {
                                                    --[[ ";" ]]59,
                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                        --[[ Break ]]Block.__(0, {
                                                            "@,",
                                                            0,
                                                            0
                                                          }),
                                                        --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                      })
                                                  }),
                                                ";@,%a"
                                              }), pr, x);
                              end end), l);
                end end));
  end else do
    return Format.fprintf(ppf, --[[ Format ]]{
                --[[ String_literal ]]Block.__(11, {
                    "[]",
                    --[[ End_of_format ]]0
                  }),
                "[]"
              });
  end end 
end end

function safe_kind_repr(_v, _param) do
  while(true) do
    param = _param;
    v = _v;
    if (typeof param == "number") then do
      if (param ~= 0) then do
        return "Fabsent";
      end else do
        return "Fpresent";
      end end 
    end else do
      match = param[0].contents;
      if (match ~= undefined) then do
        k = match;
        if (List.memq(k, v)) then do
          return "Fvar loop";
        end else do
          _param = k;
          _v = --[[ :: ]]{
            k,
            v
          };
          ::continue:: ;
        end end 
      end else do
        return "Fvar None";
      end end 
    end end 
  end;
end end

function safe_commu_repr(_v, _param) do
  while(true) do
    param = _param;
    v = _v;
    if (typeof param == "number") then do
      if (param ~= 0) then do
        return "Cunknown";
      end else do
        return "Cok";
      end end 
    end else do
      r = param[0];
      if (List.memq(r, v)) then do
        return "Clink loop";
      end else do
        _param = r.contents;
        _v = --[[ :: ]]{
          r,
          v
        };
        ::continue:: ;
      end end 
    end end 
  end;
end end

function safe_repr(_v, _t) do
  while(true) do
    t = _t;
    v = _v;
    match = t.desc;
    if (typeof match == "number" or match.tag ~= --[[ Tlink ]]6) then do
      return t;
    end else do
      t_1 = match[0];
      if (List.memq(t_1, v)) then do
        return t;
      end else do
        _t = t_1;
        _v = --[[ :: ]]{
          t_1,
          v
        };
        ::continue:: ;
      end end 
    end end 
  end;
end end

function list_of_memo(_param) do
  while(true) do
    param = _param;
    if (typeof param == "number") then do
      return --[[ [] ]]0;
    end else if (param.tag) then do
      _param = param[0].contents;
      ::continue:: ;
    end else do
      return --[[ :: ]]{
              param[1],
              list_of_memo(param[4])
            };
    end end  end 
  end;
end end

function print_name(ppf, param) do
  if (param ~= undefined) then do
    return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Char_literal ]]Block.__(12, {
                        --[[ "\"" ]]34,
                        --[[ String ]]Block.__(2, {
                            --[[ No_padding ]]0,
                            --[[ Char_literal ]]Block.__(12, {
                                --[[ "\"" ]]34,
                                --[[ End_of_format ]]0
                              })
                          })
                      }),
                    "\"%s\""
                  }), param);
  end else do
    return Format.fprintf(ppf, --[[ Format ]]{
                --[[ String_literal ]]Block.__(11, {
                    "None",
                    --[[ End_of_format ]]0
                  }),
                "None"
              });
  end end 
end end

visited = do
  contents: --[[ [] ]]0
end;

function raw_type(ppf, ty) do
  ty_1 = safe_repr(--[[ [] ]]0, ty);
  if (List.memq(ty_1, visited.contents)) then do
    return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ String_literal ]]Block.__(11, {
                        "{id=",
                        --[[ Int ]]Block.__(4, {
                            --[[ Int_d ]]0,
                            --[[ No_padding ]]0,
                            --[[ No_precision ]]0,
                            --[[ Char_literal ]]Block.__(12, {
                                --[[ "}" ]]125,
                                --[[ End_of_format ]]0
                              })
                          })
                      }),
                    "{id=%d}"
                  }), ty_1.id);
  end else do
    visited.contents = --[[ :: ]]{
      ty_1,
      visited.contents
    };
    return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<1>",
                                  --[[ End_of_format ]]0
                                }),
                              "<1>"
                            }}),
                        --[[ String_literal ]]Block.__(11, {
                            "{id=",
                            --[[ Int ]]Block.__(4, {
                                --[[ Int_d ]]0,
                                --[[ No_padding ]]0,
                                --[[ No_precision ]]0,
                                --[[ String_literal ]]Block.__(11, {
                                    ";level=",
                                    --[[ Int ]]Block.__(4, {
                                        --[[ Int_d ]]0,
                                        --[[ No_padding ]]0,
                                        --[[ No_precision ]]0,
                                        --[[ String_literal ]]Block.__(11, {
                                            ";desc=",
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Break ]]Block.__(0, {
                                                    "@,",
                                                    0,
                                                    0
                                                  }),
                                                --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                        --[[ "}" ]]125,
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Close_box ]]0,
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })})
                                              })
                                          })
                                      })
                                  })
                              })
                          })
                      }),
                    "@[<1>{id=%d;level=%d;desc=@,%a}@]"
                  }), ty_1.id, ty_1.level, raw_type_desc, ty_1.desc);
  end end 
end end

function raw_type_list(tl) do
  return (function(param) do
      return raw_list(raw_type, tl, param);
    end end);
end end

function raw_type_desc(ppf, param) do
  if (typeof param == "number") then do
    return Format.fprintf(ppf, --[[ Format ]]{
                --[[ String_literal ]]Block.__(11, {
                    "Tnil",
                    --[[ End_of_format ]]0
                  }),
                "Tnil"
              });
  end else do
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ == 0--[[ Tvar ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "Tvar ",
                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                            }),
                          "Tvar %a"
                        }), print_name, param[0]); end end 
       if ___conditional___ == 1--[[ Tarrow ]] then do
          return Curry._6(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hov1>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hov1>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "Tarrow(",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Char_literal ]]Block.__(12, {
                                          --[[ "," ]]44,
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@,",
                                                  0,
                                                  0
                                                }),
                                              --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                      --[[ "," ]]44,
                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                          --[[ Break ]]Block.__(0, {
                                                              "@,",
                                                              0,
                                                              0
                                                            }),
                                                          --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                                  --[[ "," ]]44,
                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Break ]]Block.__(0, {
                                                                          "@,",
                                                                          0,
                                                                          0
                                                                        }),
                                                                      --[[ String ]]Block.__(2, {
                                                                          --[[ No_padding ]]0,
                                                                          --[[ Char_literal ]]Block.__(12, {
                                                                              --[[ ")" ]]41,
                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Close_box ]]0,
                                                                                  --[[ End_of_format ]]0
                                                                                })
                                                                            })
                                                                        })
                                                                    })
                                                                })})
                                                        })
                                                    })})
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[<hov1>Tarrow(%s,@,%a,@,%a,@,%s)@]"
                        }), param[0], raw_type, param[1], raw_type, param[2], safe_commu_repr(--[[ [] ]]0, param[3])); end end 
       if ___conditional___ == 2--[[ Ttuple ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<1>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<1>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "Ttuple",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@,",
                                          0,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Close_box ]]0,
                                              --[[ End_of_format ]]0
                                            })})
                                    })
                                })
                            }),
                          "@[<1>Ttuple@,%a@]"
                        }), raw_type_list, param[0]); end end 
       if ___conditional___ == 3--[[ Tconstr ]] then do
          return Curry._6(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hov1>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hov1>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "Tconstr(",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@,",
                                          0,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                              --[[ "," ]]44,
                                              --[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Break ]]Block.__(0, {
                                                      "@,",
                                                      0,
                                                      0
                                                    }),
                                                  --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                          --[[ "," ]]44,
                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Break ]]Block.__(0, {
                                                                  "@,",
                                                                  0,
                                                                  0
                                                                }),
                                                              --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                                      --[[ ")" ]]41,
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Close_box ]]0,
                                                                          --[[ End_of_format ]]0
                                                                        })
                                                                    })})
                                                            })
                                                        })})
                                                })
                                            })})
                                    })
                                })
                            }),
                          "@[<hov1>Tconstr(@,%a,@,%a,@,%a)@]"
                        }), path, param[0], raw_type_list, param[1], (function(param, param_1) do
                        return raw_list(path, param, param_1);
                      end end), list_of_memo(param[2].contents)); end end 
       if ___conditional___ == 4--[[ Tobject ]] then do
          nm = param[1];
          return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hov1>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hov1>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "Tobject(",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@,",
                                          0,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                              --[[ "," ]]44,
                                              --[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Break ]]Block.__(0, {
                                                      "@,",
                                                      0,
                                                      0
                                                    }),
                                                  --[[ Formatting_gen ]]Block.__(18, {
                                                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                            --[[ String_literal ]]Block.__(11, {
                                                                "<1>",
                                                                --[[ End_of_format ]]0
                                                              }),
                                                            "<1>"
                                                          }}),
                                                      --[[ String_literal ]]Block.__(11, {
                                                          "ref",
                                                          --[[ Theta ]]Block.__(16, {--[[ Formatting_lit ]]Block.__(17, {
                                                                  --[[ Close_box ]]0,
                                                                  --[[ Char_literal ]]Block.__(12, {
                                                                      --[[ ")" ]]41,
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Close_box ]]0,
                                                                          --[[ End_of_format ]]0
                                                                        })
                                                                    })
                                                                })})
                                                        })
                                                    })
                                                })
                                            })})
                                    })
                                })
                            }),
                          "@[<hov1>Tobject(@,%a,@,@[<1>ref%t@])@]"
                        }), raw_type, param[0], (function(ppf) do
                        match = nm.contents;
                        if (match ~= undefined) then do
                          match_1 = match;
                          return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "(Some(",
                                              --[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Break ]]Block.__(0, {
                                                      "@,",
                                                      0,
                                                      0
                                                    }),
                                                  --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                          --[[ "," ]]44,
                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Break ]]Block.__(0, {
                                                                  "@,",
                                                                  0,
                                                                  0
                                                                }),
                                                              --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                                                      "))",
                                                                      --[[ End_of_format ]]0
                                                                    })})
                                                            })
                                                        })})
                                                })
                                            }),
                                          "(Some(@,%a,@,%a))"
                                        }), path, match_1[0], raw_type_list, match_1[1]);
                        end else do
                          return Format.fprintf(ppf, --[[ Format ]]{
                                      --[[ String_literal ]]Block.__(11, {
                                          " None",
                                          --[[ End_of_format ]]0
                                        }),
                                      " None"
                                    });
                        end end 
                      end end)); end end 
       if ___conditional___ == 5--[[ Tfield ]] then do
          return Curry._6(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hov1>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hov1>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "Tfield(",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@,",
                                          0,
                                          0
                                        }),
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ Char_literal ]]Block.__(12, {
                                              --[[ "," ]]44,
                                              --[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Break ]]Block.__(0, {
                                                      "@,",
                                                      0,
                                                      0
                                                    }),
                                                  --[[ String ]]Block.__(2, {
                                                      --[[ No_padding ]]0,
                                                      --[[ Char_literal ]]Block.__(12, {
                                                          --[[ "," ]]44,
                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Break ]]Block.__(0, {
                                                                  "@,",
                                                                  0,
                                                                  0
                                                                }),
                                                              --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                                      --[[ "," ]]44,
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@;<0 -1>",
                                                                              0,
                                                                              -1
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                                                  --[[ ")" ]]41,
                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Close_box ]]0,
                                                                                      --[[ End_of_format ]]0
                                                                                    })
                                                                                })})
                                                                        })
                                                                    })})
                                                            })
                                                        })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[<hov1>Tfield(@,%s,@,%s,@,%a,@;<0 -1>%a)@]"
                        }), param[0], safe_kind_repr(--[[ [] ]]0, param[1]), raw_type, param[2], raw_type, param[3]); end end 
       if ___conditional___ == 6--[[ Tlink ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<1>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<1>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "Tlink",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@,",
                                          0,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Close_box ]]0,
                                              --[[ End_of_format ]]0
                                            })})
                                    })
                                })
                            }),
                          "@[<1>Tlink@,%a@]"
                        }), raw_type, param[0]); end end 
       if ___conditional___ == 7--[[ Tsubst ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<1>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<1>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "Tsubst",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@,",
                                          0,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Close_box ]]0,
                                              --[[ End_of_format ]]0
                                            })})
                                    })
                                })
                            }),
                          "@[<1>Tsubst@,%a@]"
                        }), raw_type, param[0]); end end 
       if ___conditional___ == 8--[[ Tvariant ]] then do
          row = param[0];
          return Curry.app(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hov1>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hov1>"
                                  }}),
                              --[[ Char_literal ]]Block.__(12, {
                                  --[[ "{" ]]123,
                                  --[[ Formatting_gen ]]Block.__(18, {
                                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                            --[[ End_of_format ]]0,
                                            ""
                                          }}),
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@,",
                                                  0,
                                                  0
                                                }),
                                              --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                      --[[ ";" ]]59,
                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                          --[[ Close_box ]]0,
                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Break ]]Block.__(0, {
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                }),
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String ]]Block.__(2, {
                                                                      --[[ No_padding ]]0,
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@,",
                                                                              0,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                                                  --[[ ";" ]]59,
                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Close_box ]]0,
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Break ]]Block.__(0, {
                                                                                              "@ ",
                                                                                              1,
                                                                                              0
                                                                                            }),
                                                                                          --[[ String ]]Block.__(2, {
                                                                                              --[[ No_padding ]]0,
                                                                                              --[[ Bool ]]Block.__(9, {
                                                                                                  --[[ No_padding ]]0,
                                                                                                  --[[ Char_literal ]]Block.__(12, {
                                                                                                      --[[ ";" ]]59,
                                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                                          --[[ Break ]]Block.__(0, {
                                                                                                              "@ ",
                                                                                                              1,
                                                                                                              0
                                                                                                            }),
                                                                                                          --[[ String ]]Block.__(2, {
                                                                                                              --[[ No_padding ]]0,
                                                                                                              --[[ Bool ]]Block.__(9, {
                                                                                                                  --[[ No_padding ]]0,
                                                                                                                  --[[ Char_literal ]]Block.__(12, {
                                                                                                                      --[[ ";" ]]59,
                                                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                                                          --[[ Break ]]Block.__(0, {
                                                                                                                              "@ ",
                                                                                                                              1,
                                                                                                                              0
                                                                                                                            }),
                                                                                                                          --[[ Formatting_gen ]]Block.__(18, {
                                                                                                                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                                                                                    --[[ String_literal ]]Block.__(11, {
                                                                                                                                        "<1>",
                                                                                                                                        --[[ End_of_format ]]0
                                                                                                                                      }),
                                                                                                                                    "<1>"
                                                                                                                                  }}),
                                                                                                                              --[[ String ]]Block.__(2, {
                                                                                                                                  --[[ No_padding ]]0,
                                                                                                                                  --[[ Theta ]]Block.__(16, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                                                          --[[ Close_box ]]0,
                                                                                                                                          --[[ Char_literal ]]Block.__(12, {
                                                                                                                                              --[[ "}" ]]125,
                                                                                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                                                                                  --[[ Close_box ]]0,
                                                                                                                                                  --[[ End_of_format ]]0
                                                                                                                                                })
                                                                                                                                            })
                                                                                                                                        })})
                                                                                                                                })
                                                                                                                            })
                                                                                                                        })
                                                                                                                    })
                                                                                                                })
                                                                                                            })
                                                                                                        })
                                                                                                    })
                                                                                                })
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })})
                                                                        })
                                                                    })
                                                                })
                                                            })
                                                        })
                                                    })})
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[<hov1>{@[%s@,%a;@]@ @[%s@,%a;@]@ %s%b;@ %s%b;@ @[<1>%s%t@]}@]"
                        }), {
                      "row_fields=",
                      (function(param, param_1) do
                          return raw_list((function(ppf, param) do
                                        return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                                                        --[[ Formatting_gen ]]Block.__(18, {
                                                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                  --[[ End_of_format ]]0,
                                                                  ""
                                                                }}),
                                                            --[[ String ]]Block.__(2, {
                                                                --[[ No_padding ]]0,
                                                                --[[ Char_literal ]]Block.__(12, {
                                                                    --[[ "," ]]44,
                                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                                        --[[ Break ]]Block.__(0, {
                                                                            "@ ",
                                                                            1,
                                                                            0
                                                                          }),
                                                                        --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                --[[ Close_box ]]0,
                                                                                --[[ End_of_format ]]0
                                                                              })})
                                                                      })
                                                                  })
                                                              })
                                                          }),
                                                        "@[%s,@ %a@]"
                                                      }), param[0], raw_field, param[1]);
                                      end end), param, param_1);
                        end end),
                      row.row_fields,
                      "row_more=",
                      raw_type,
                      row.row_more,
                      "row_closed=",
                      row.row_closed,
                      "row_fixed=",
                      row.row_fixed,
                      "row_name=",
                      (function(ppf) do
                          match = row.row_name;
                          if (match ~= undefined) then do
                            match_1 = match;
                            return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                                            --[[ String_literal ]]Block.__(11, {
                                                "Some(",
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@,",
                                                        0,
                                                        0
                                                      }),
                                                    --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                            --[[ "," ]]44,
                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                --[[ Break ]]Block.__(0, {
                                                                    "@,",
                                                                    0,
                                                                    0
                                                                  }),
                                                                --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                                        --[[ ")" ]]41,
                                                                        --[[ End_of_format ]]0
                                                                      })})
                                                              })
                                                          })})
                                                  })
                                              }),
                                            "Some(@,%a,@,%a)"
                                          }), path, match_1[0], raw_type_list, match_1[1]);
                          end else do
                            return Format.fprintf(ppf, --[[ Format ]]{
                                        --[[ String_literal ]]Block.__(11, {
                                            "None",
                                            --[[ End_of_format ]]0
                                          }),
                                        "None"
                                      });
                          end end 
                        end end)
                    }); end end 
       if ___conditional___ == 9--[[ Tunivar ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "Tunivar ",
                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                            }),
                          "Tunivar %a"
                        }), print_name, param[0]); end end 
       if ___conditional___ == 10--[[ Tpoly ]] then do
          return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hov1>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hov1>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "Tpoly(",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@,",
                                          0,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                              --[[ "," ]]44,
                                              --[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Break ]]Block.__(0, {
                                                      "@,",
                                                      0,
                                                      0
                                                    }),
                                                  --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                          --[[ ")" ]]41,
                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Close_box ]]0,
                                                              --[[ End_of_format ]]0
                                                            })
                                                        })})
                                                })
                                            })})
                                    })
                                })
                            }),
                          "@[<hov1>Tpoly(@,%a,@,%a)@]"
                        }), raw_type, param[0], raw_type_list, param[1]); end end 
       if ___conditional___ == 11--[[ Tpackage ]] then do
          return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hov1>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hov1>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "Tpackage(",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@,",
                                          0,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@,",
                                                  0,
                                                  0
                                                }),
                                              --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                      --[[ ")" ]]41,
                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                          --[[ Close_box ]]0,
                                                          --[[ End_of_format ]]0
                                                        })
                                                    })})
                                            })})
                                    })
                                })
                            }),
                          "@[<hov1>Tpackage(@,%a@,%a)@]"
                        }), path, param[0], raw_type_list, param[2]); end end 
      
    end
  end end 
end end

function raw_field(ppf, param) do
  if (typeof param == "number") then do
    return Format.fprintf(ppf, --[[ Format ]]{
                --[[ String_literal ]]Block.__(11, {
                    "Rabsent",
                    --[[ End_of_format ]]0
                  }),
                "Rabsent"
              });
  end else if (param.tag) then do
    e = param[3];
    return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<hov1>",
                                  --[[ End_of_format ]]0
                                }),
                              "<hov1>"
                            }}),
                        --[[ String_literal ]]Block.__(11, {
                            "Reither(",
                            --[[ Bool ]]Block.__(9, {
                                --[[ No_padding ]]0,
                                --[[ Char_literal ]]Block.__(12, {
                                    --[[ "," ]]44,
                                    --[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Break ]]Block.__(0, {
                                            "@,",
                                            0,
                                            0
                                          }),
                                        --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                --[[ "," ]]44,
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@,",
                                                        0,
                                                        0
                                                      }),
                                                    --[[ Bool ]]Block.__(9, {
                                                        --[[ No_padding ]]0,
                                                        --[[ Char_literal ]]Block.__(12, {
                                                            --[[ "," ]]44,
                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                --[[ Break ]]Block.__(0, {
                                                                    "@,",
                                                                    0,
                                                                    0
                                                                  }),
                                                                --[[ Formatting_gen ]]Block.__(18, {
                                                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                          --[[ String_literal ]]Block.__(11, {
                                                                              "<1>",
                                                                              --[[ End_of_format ]]0
                                                                            }),
                                                                          "<1>"
                                                                        }}),
                                                                    --[[ String_literal ]]Block.__(11, {
                                                                        "ref",
                                                                        --[[ Theta ]]Block.__(16, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                --[[ Close_box ]]0,
                                                                                --[[ Char_literal ]]Block.__(12, {
                                                                                    --[[ ")" ]]41,
                                                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                                                        --[[ Close_box ]]0,
                                                                                        --[[ End_of_format ]]0
                                                                                      })
                                                                                  })
                                                                              })})
                                                                      })
                                                                  })
                                                              })
                                                          })
                                                      })
                                                  })
                                              })})
                                      })
                                  })
                              })
                          })
                      }),
                    "@[<hov1>Reither(%b,@,%a,@,%b,@,@[<1>ref%t@])@]"
                  }), param[0], raw_type_list, param[1], param[2], (function(ppf) do
                  match = e.contents;
                  if (match ~= undefined) then do
                    return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                    --[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Break ]]Block.__(0, {
                                            "@,",
                                            0,
                                            0
                                          }),
                                        --[[ Formatting_gen ]]Block.__(18, {
                                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                  --[[ String_literal ]]Block.__(11, {
                                                      "<1>",
                                                      --[[ End_of_format ]]0
                                                    }),
                                                  "<1>"
                                                }}),
                                            --[[ Char_literal ]]Block.__(12, {
                                                --[[ "(" ]]40,
                                                --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                        --[[ ")" ]]41,
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Close_box ]]0,
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })})
                                              })
                                          })
                                      }),
                                    "@,@[<1>(%a)@]"
                                  }), raw_field, match);
                  end else do
                    return Format.fprintf(ppf, --[[ Format ]]{
                                --[[ String_literal ]]Block.__(11, {
                                    " None",
                                    --[[ End_of_format ]]0
                                  }),
                                " None"
                              });
                  end end 
                end end));
  end else do
    match = param[0];
    if (match ~= undefined) then do
      return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Formatting_gen ]]Block.__(18, {
                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                --[[ String_literal ]]Block.__(11, {
                                    "<1>",
                                    --[[ End_of_format ]]0
                                  }),
                                "<1>"
                              }}),
                          --[[ String_literal ]]Block.__(11, {
                              "Rpresent(Some",
                              --[[ Formatting_lit ]]Block.__(17, {
                                  --[[ Break ]]Block.__(0, {
                                      "@,",
                                      0,
                                      0
                                    }),
                                  --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                          --[[ ")" ]]41,
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Close_box ]]0,
                                              --[[ End_of_format ]]0
                                            })
                                        })})
                                })
                            })
                        }),
                      "@[<1>Rpresent(Some@,%a)@]"
                    }), raw_type, match);
    end else do
      return Format.fprintf(ppf, --[[ Format ]]{
                  --[[ String_literal ]]Block.__(11, {
                      "Rpresent None",
                      --[[ End_of_format ]]0
                    }),
                  "Rpresent None"
                });
    end end 
  end end  end 
end end

function raw_type_expr(ppf, t) do
  visited.contents = --[[ [] ]]0;
  raw_type(ppf, t);
  visited.contents = --[[ [] ]]0;
  return --[[ () ]]0;
end end

print_raw = raw_type_expr;

function is_nth(param) do
  if (typeof param == "number" or param.tag) then do
    return false;
  end else do
    return true;
  end end 
end end

function compose(l1, param) do
  if (typeof param == "number") then do
    return --[[ Map ]]Block.__(1, {l1});
  end else if (param.tag) then do
    return --[[ Map ]]Block.__(1, {List.map((function(param) do
                      return List.nth(l1, param);
                    end end), param[0])});
  end else do
    return --[[ Nth ]]Block.__(0, {List.nth(l1, param[0])});
  end end  end 
end end

function apply_subst(s1, tyl) do
  if (typeof s1 == "number") then do
    return tyl;
  end else if (s1.tag) then do
    return List.map((function(param) do
                  return List.nth(tyl, param);
                end end), s1[0]);
  end else do
    return --[[ :: ]]{
            List.nth(tyl, s1[0]),
            --[[ [] ]]0
          };
  end end  end 
end end

printing_env = do
  contents: empty
end;

printing_depth = do
  contents: 0
end;

printing_cont = do
  contents: --[[ [] ]]0
end;

printing_old = do
  contents: empty
end;

printing_pers = do
  contents: --[[ Empty ]]0
end;

function compare_2(_p1, _p2) do
  while(true) do
    p2 = _p2;
    p1 = _p1;
    local ___conditional___=(p1.tag | 0);
    do
       if ___conditional___ == 0--[[ Pident ]] then do
          return Caml_obj.caml_compare(p1, p2); end end 
       if ___conditional___ == 1--[[ Pdot ]] then do
          local ___conditional___=(p2.tag | 0);
          do
             if ___conditional___ == 1--[[ Pdot ]] then do
                c = compare_2(p1[0], p2[0]);
                if (c ~= 0) then do
                  return c;
                end else do
                  return Caml_primitive.caml_string_compare(p1[1], p2[1]);
                end end  end end 
             if ___conditional___ == 0--[[ Pident ]]
             or ___conditional___ == 2--[[ Papply ]] then do
                return Caml_obj.caml_compare(p1, p2); end end 
            
          end end end 
       if ___conditional___ == 2--[[ Papply ]] then do
          local ___conditional___=(p2.tag | 0);
          do
             if ___conditional___ == 0--[[ Pident ]]
             or ___conditional___ == 1--[[ Pdot ]] then do
                return Caml_obj.caml_compare(p1, p2); end end 
             if ___conditional___ == 2--[[ Papply ]] then do
                c_1 = compare_2(p1[0], p2[0]);
                if (c_1 ~= 0) then do
                  return c_1;
                end else do
                  _p2 = p2[1];
                  _p1 = p1[1];
                  ::continue:: ;
                end end  end end 
            
          end end end 
      
    end
  end;
end end

function height_6(param) do
  if (param) then do
    return param[--[[ h ]]4];
  end else do
    return 0;
  end end 
end end

function create_7(l, x, d, r) do
  hl = height_6(l);
  hr = height_6(r);
  return --[[ Node ]]{
          --[[ l ]]l,
          --[[ v ]]x,
          --[[ d ]]d,
          --[[ r ]]r,
          --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
        };
end end

function bal_6(l, x, d, r) do
  hl = l and l[--[[ h ]]4] or 0;
  hr = r and r[--[[ h ]]4] or 0;
  if (hl > (hr + 2 | 0)) then do
    if (l) then do
      lr = l[--[[ r ]]3];
      ld = l[--[[ d ]]2];
      lv = l[--[[ v ]]1];
      ll = l[--[[ l ]]0];
      if (height_6(ll) >= height_6(lr)) then do
        return create_7(ll, lv, ld, create_7(lr, x, d, r));
      end else if (lr) then do
        return create_7(create_7(ll, lv, ld, lr[--[[ l ]]0]), lr[--[[ v ]]1], lr[--[[ d ]]2], create_7(lr[--[[ r ]]3], x, d, r));
      end else do
        error({
          Caml_builtin_exceptions.invalid_argument,
          "Map.bal"
        })
      end end  end 
    end else do
      error({
        Caml_builtin_exceptions.invalid_argument,
        "Map.bal"
      })
    end end 
  end else if (hr > (hl + 2 | 0)) then do
    if (r) then do
      rr = r[--[[ r ]]3];
      rd = r[--[[ d ]]2];
      rv = r[--[[ v ]]1];
      rl = r[--[[ l ]]0];
      if (height_6(rr) >= height_6(rl)) then do
        return create_7(create_7(l, x, d, rl), rv, rd, rr);
      end else if (rl) then do
        return create_7(create_7(l, x, d, rl[--[[ l ]]0]), rl[--[[ v ]]1], rl[--[[ d ]]2], create_7(rl[--[[ r ]]3], rv, rd, rr));
      end else do
        error({
          Caml_builtin_exceptions.invalid_argument,
          "Map.bal"
        })
      end end  end 
    end else do
      error({
        Caml_builtin_exceptions.invalid_argument,
        "Map.bal"
      })
    end end 
  end else do
    return --[[ Node ]]{
            --[[ l ]]l,
            --[[ v ]]x,
            --[[ d ]]d,
            --[[ r ]]r,
            --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
          };
  end end  end 
end end

function add_8(x, data, m) do
  if (m) then do
    r = m[--[[ r ]]3];
    d = m[--[[ d ]]2];
    v = m[--[[ v ]]1];
    l = m[--[[ l ]]0];
    c = compare_2(x, v);
    if (c == 0) then do
      if (d == data) then do
        return m;
      end else do
        return --[[ Node ]]{
                --[[ l ]]l,
                --[[ v ]]x,
                --[[ d ]]data,
                --[[ r ]]r,
                --[[ h ]]m[--[[ h ]]4]
              };
      end end 
    end else if (c < 0) then do
      ll = add_8(x, data, l);
      if (l == ll) then do
        return m;
      end else do
        return bal_6(ll, v, d, r);
      end end 
    end else do
      rr = add_8(x, data, r);
      if (r == rr) then do
        return m;
      end else do
        return bal_6(l, v, d, rr);
      end end 
    end end  end 
  end else do
    return --[[ Node ]]{
            --[[ l : Empty ]]0,
            --[[ v ]]x,
            --[[ d ]]data,
            --[[ r : Empty ]]0,
            --[[ h ]]1
          };
  end end 
end end

function find_4(x, _param) do
  while(true) do
    param = _param;
    if (param) then do
      c = compare_2(x, param[--[[ v ]]1]);
      if (c == 0) then do
        return param[--[[ d ]]2];
      end else do
        _param = c < 0 and param[--[[ l ]]0] or param[--[[ r ]]3];
        ::continue:: ;
      end end 
    end else do
      error(Caml_builtin_exceptions.not_found)
    end end 
  end;
end end

printing_map = do
  contents: --[[ Empty ]]0
end;

function same_type(t, t$prime) do
  return repr(t) == repr(t$prime);
end end

function index(l, x) do
  if (l) then do
    if (x == l[0]) then do
      return 0;
    end else do
      return 1 + index(l[1], x) | 0;
    end end 
  end else do
    error(Caml_builtin_exceptions.not_found)
  end end 
end end

function uniq(_param) do
  while(true) do
    param = _param;
    if (param) then do
      l = param[1];
      if (List.memq(param[0], l)) then do
        return false;
      end else do
        _param = l;
        ::continue:: ;
      end end 
    end else do
      return true;
    end end 
  end;
end end

function normalize_type_path(cacheOpt, env, p) do
  cache = cacheOpt ~= undefined and cacheOpt or false;
  xpcall(function() do
    match = find_type_expansion(p, env);
    params = List.map(repr, match[0]);
    ty = repr(match[1]);
    match_1 = ty.desc;
    if (typeof match_1 == "number" or match_1.tag ~= --[[ Tconstr ]]3) then do
      return --[[ tuple ]]{
              p,
              --[[ Nth ]]Block.__(0, {index(params, ty)})
            };
    end else do
      p1 = match_1[0];
      tyl = List.map(repr, match_1[1]);
      if (List.length(params) == List.length(tyl) and List.for_all2((function(prim, prim_1) do
                return prim == prim_1;
              end end), params, tyl)) then do
        return normalize_type_path(cache, env, p1);
      end else if (cache or List.length(params) <= List.length(tyl) or not uniq(tyl)) then do
        return --[[ tuple ]]{
                p,
                --[[ Id ]]0
              };
      end else do
        l1 = List.map((function(param) do
                return index(params, param);
              end end), tyl);
        match_2 = normalize_type_path(cache, env, p1);
        return --[[ tuple ]]{
                match_2[0],
                compose(l1, match_2[1])
              };
      end end  end 
    end end 
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return --[[ tuple ]]{
              p,
              --[[ Id ]]0
            };
    end else do
      error(exn)
    end end 
  end end)
end end

function path_size(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Pident ]] then do
        id = param[0];
        s = id.name;
        return --[[ tuple ]]{
                s ~= "" and Caml_string.get(s, 0) == --[[ "_" ]]95 and 10 or 1,
                -id.stamp | 0
              }; end end 
     if ___conditional___ == 1--[[ Pdot ]] then do
        match = path_size(param[0]);
        return --[[ tuple ]]{
                1 + match[0] | 0,
                match[1]
              }; end end 
     if ___conditional___ == 2--[[ Papply ]] then do
        match_1 = path_size(param[0]);
        return --[[ tuple ]]{
                match_1[0] + path_size(param[1])[0] | 0,
                match_1[1]
              }; end end 
    
  end
end end

function same_printing_env(env) do
  used_pers = used_persistent(--[[ () ]]0);
  if (same_types(printing_old.contents, env)) then do
    return equal_2(printing_pers.contents, used_pers);
  end else do
    return false;
  end end 
end end

function set_printing_env(env) do
  printing_env.contents = real_paths.contents and empty or env;
  if (printing_env.contents == empty or same_printing_env(env)) then do
    return --[[ () ]]0;
  end else do
    printing_old.contents = env;
    printing_pers.contents = used_persistent(--[[ () ]]0);
    printing_map.contents = --[[ Empty ]]0;
    printing_depth.contents = 0;
    partial_arg = iter_types((function(p, param) do
            match = normalize_type_path(true, env, param[0]);
            if (match[1] == --[[ Id ]]0) then do
              p1 = match[0];
              xpcall(function() do
                r = find_4(p1, printing_map.contents);
                match_1 = r.contents;
                if (match_1.tag) then do
                  r.contents = --[[ Paths ]]Block.__(0, {--[[ :: ]]{
                        p,
                        --[[ :: ]]{
                          match_1[0],
                          --[[ [] ]]0
                        }
                      }});
                  return --[[ () ]]0;
                end else do
                  r.contents = --[[ Paths ]]Block.__(0, {--[[ :: ]]{
                        p,
                        match_1[0]
                      }});
                  return --[[ () ]]0;
                end end 
              end end,function(exn) do
                if (exn == Caml_builtin_exceptions.not_found) then do
                  printing_map.contents = add_8(p1, do
                        contents: --[[ Paths ]]Block.__(0, {--[[ :: ]]{
                              p,
                              --[[ [] ]]0
                            }})
                      end, printing_map.contents);
                  return --[[ () ]]0;
                end else do
                  error(exn)
                end end 
              end end)
            end else do
              return 0;
            end end 
          end end));
    cont = function(param) do
      return partial_arg(env, param);
    end end;
    printing_cont.contents = --[[ :: ]]{
      cont,
      --[[ [] ]]0
    };
    return --[[ () ]]0;
  end end 
end end

function wrap_printing_env(env, f) do
  set_printing_env(env);
  return try_finally(f, (function(param) do
                return set_printing_env(empty);
              end end));
end end

function is_unambiguous(path, env) do
  l = find_shadowed_types(path, env);
  if (List.exists((function(param) do
            return same(path, param);
          end end), l) or not l) then do
    return true;
  end else do
    rem = l[1];
    p = l[0];
    normalize = function(p) do
      return normalize_type_path(true, env, p)[0];
    end end;
    p$prime = normalize(p);
    if (List.for_all((function(p) do
              return same(normalize(p), p$prime);
            end end), rem)) then do
      return true;
    end else do
      id = lid_of_path(undefined, p);
      if (List.for_all((function(p) do
                return Caml_obj.caml_equal(lid_of_path(undefined, p), id);
              end end), rem)) then do
        return same(p, lookup_type_1(id, env)[0]);
      end else do
        return false;
      end end 
    end end 
  end end 
end end

function best_type_path(p) do
  if (real_paths.contents or printing_env.contents == empty) then do
    return --[[ tuple ]]{
            p,
            --[[ Id ]]0
          };
  end else do
    match = normalize_type_path(undefined, printing_env.contents, p);
    p$prime = match[0];
    get_path = function(param) do
      r = find_4(p$prime, printing_map.contents);
      while(true) do
        match = r.contents;
        if (match.tag) then do
          return match[0];
        end else do
          l = match[0];
          if (l) then do
            r.contents = --[[ Paths ]]Block.__(0, {--[[ [] ]]0});
            List.iter((function(p) do
                    match = r.contents;
                    if (match.tag and Caml_obj.caml_greaterequal(path_size(p), path_size(match[0]))) then do
                      return --[[ () ]]0;
                    end
                     end 
                    if (is_unambiguous(p, printing_env.contents)) then do
                      r.contents = --[[ Best ]]Block.__(1, {p});
                      return --[[ () ]]0;
                    end else do
                      return 0;
                    end end 
                  end end), l);
            ::continue:: ;
          end else do
            error(Caml_builtin_exceptions.not_found)
          end end 
        end end 
      end;
    end end;
    while((function() do
            tmp = false;
            if (printing_cont.contents ~= --[[ [] ]]0) then do
              tmp_1;
              xpcall(function() do
                get_path(--[[ () ]]0);
                tmp_1 = false;
              end end,function(exn) do
                if (exn == Caml_builtin_exceptions.not_found) then do
                  tmp_1 = true;
                end else do
                  error(exn)
                end end 
              end end)
              tmp = tmp_1;
            end
             end 
            return tmp;
          end end)()) do
      printing_cont.contents = List.map((function(prim) do
              return prim[1];
            end end), run_iter_cont(printing_cont.contents));
      printing_depth.contents = printing_depth.contents + 1 | 0;
    end;
    p$prime$prime;
    xpcall(function() do
      p$prime$prime = get_path(--[[ () ]]0);
    end end,function(exn) do
      if (exn == Caml_builtin_exceptions.not_found) then do
        p$prime$prime = p$prime;
      end else do
        error(exn)
      end end 
    end end)
    return --[[ tuple ]]{
            p$prime$prime,
            match[1]
          };
  end end 
end end

names = do
  contents: --[[ [] ]]0
end;

name_counter = do
  contents: 0
end;

named_vars = do
  contents: --[[ [] ]]0
end;

function reset_names(param) do
  names.contents = --[[ [] ]]0;
  name_counter.contents = 0;
  named_vars.contents = --[[ [] ]]0;
  return --[[ () ]]0;
end end

function add_named_var(ty) do
  match = ty.desc;
  if (typeof match == "number") then do
    return --[[ () ]]0;
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 0--[[ Tvar ]]
       or ___conditional___ == 9--[[ Tunivar ]]
       end
      return --[[ () ]]0;
        
    end
  end end 
  match_1 = match[0];
  if (match_1 ~= undefined) then do
    name = match_1;
    if (List.mem(name, named_vars.contents)) then do
      return --[[ () ]]0;
    end else do
      named_vars.contents = --[[ :: ]]{
        name,
        named_vars.contents
      };
      return --[[ () ]]0;
    end end 
  end else do
    return --[[ () ]]0;
  end end 
end end

function new_name(_param) do
  while(true) do
    name;
    if (name_counter.contents < 26) then do
      c = Char.chr(97 + name_counter.contents | 0);
      name = Caml_bytes.bytes_to_string(Bytes.make(1, c));
    end else do
      c_1 = Char.chr(97 + name_counter.contents % 26 | 0);
      name = Caml_bytes.bytes_to_string(Bytes.make(1, c_1)) .. String(name_counter.contents / 26 | 0);
    end end 
    name_counter.contents = name_counter.contents + 1 | 0;
    if (List.mem(name, named_vars.contents) or List.exists((function(name)do
          return function (param) do
            return name == param[1];
          end end
          end end)(name), names.contents)) then do
      _param = --[[ () ]]0;
      ::continue:: ;
    end else do
      return name;
    end end 
  end;
end end

function name_of_type(t) do
  xpcall(function() do
    return List.assq(t, names.contents);
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      match = t.desc;
      name;
      exit = 0;
      if (typeof match == "number") then do
        name = new_name(--[[ () ]]0);
      end else do
        local ___conditional___=(match.tag | 0);
        do
           if ___conditional___ == 0--[[ Tvar ]]
           or ___conditional___ == 9--[[ Tunivar ]] then do
              exit = 1; end else 
           end end
          name = new_name(--[[ () ]]0);
            
        end
      end end 
      if (exit == 1) then do
        match_1 = match[0];
        if (match_1 ~= undefined) then do
          name_1 = match_1;
          current_name = do
            contents: name_1
          end;
          i = 0;
          while(List.exists((function(param) do
                    return current_name.contents == param[1];
                  end end), names.contents)) do
            current_name.contents = name_1 .. String(i);
            i = i + 1 | 0;
          end;
          name = current_name.contents;
        end else do
          name = new_name(--[[ () ]]0);
        end end 
      end
       end 
      if (name ~= "_") then do
        names.contents = --[[ :: ]]{
          --[[ tuple ]]{
            t,
            name
          },
          names.contents
        };
      end
       end 
      return name;
    end else do
      error(exn)
    end end 
  end end)
end end

function check_name_of_type(t) do
  name_of_type(t);
  return --[[ () ]]0;
end end

function remove_names(tyl) do
  tyl_1 = List.map(repr, tyl);
  names.contents = List.filter((function(param) do
            return not List.memq(param[0], tyl_1);
          end end))(names.contents);
  return --[[ () ]]0;
end end

visited_objects = do
  contents: --[[ [] ]]0
end;

aliased = do
  contents: --[[ [] ]]0
end;

delayed = do
  contents: --[[ [] ]]0
end;

function add_delayed(t) do
  if (List.memq(t, delayed.contents)) then do
    return 0;
  end else do
    delayed.contents = --[[ :: ]]{
      t,
      delayed.contents
    };
    return --[[ () ]]0;
  end end 
end end

function is_aliased(ty) do
  return List.memq(proxy(ty), aliased.contents);
end end

function add_alias(ty) do
  px = proxy(ty);
  if (is_aliased(px)) then do
    return 0;
  end else do
    aliased.contents = --[[ :: ]]{
      px,
      aliased.contents
    };
    return add_named_var(px);
  end end 
end end

function aliasable(ty) do
  match = ty.desc;
  if (typeof match == "number") then do
    return true;
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 3--[[ Tconstr ]] then do
          return not is_nth(best_type_path(match[0])[1]); end end 
       if ___conditional___ == 0--[[ Tvar ]]
       or ___conditional___ == 9--[[ Tunivar ]]
       or ___conditional___ == 10--[[ Tpoly ]] then do
          return false; end end 
      return true;
        
    end
  end end 
end end

function namable_row(row) do
  if (row.row_name ~= undefined) then do
    return List.for_all((function(param) do
                  match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                  if (typeof match == "number" or not match.tag) then do
                    return true;
                  end else do
                    l = match[1];
                    if (row.row_closed) then do
                      if (match[0]) then do
                        return l == --[[ [] ]]0;
                      end else do
                        return List.length(l) == 1;
                      end end 
                    end else do
                      return false;
                    end end 
                  end end 
                end end), row.row_fields);
  end else do
    return false;
  end end 
end end

function mark_loops_rec(_visited, _ty) do
  while(true) do
    ty = _ty;
    visited = _visited;
    ty_1 = repr(ty);
    px = proxy(ty_1);
    if (List.memq(px, visited) and aliasable(ty_1)) then do
      return add_alias(px);
    end else do
      visited_1 = --[[ :: ]]{
        px,
        visited
      };
      match = ty_1.desc;
      if (typeof match == "number") then do
        return --[[ () ]]0;
      end else do
        local ___conditional___=(match.tag | 0);
        do
           if ___conditional___ == 1--[[ Tarrow ]] then do
              mark_loops_rec(visited_1, match[1]);
              _ty = match[2];
              _visited = visited_1;
              ::continue:: ; end end 
           if ___conditional___ == 2--[[ Ttuple ]] then do
              return List.iter((function(visited_1)do
                        return function (param) do
                          return mark_loops_rec(visited_1, param);
                        end end
                        end end)(visited_1), match[0]); end end 
           if ___conditional___ == 3--[[ Tconstr ]] then do
              match_1 = best_type_path(match[0]);
              return List.iter((function(visited_1)do
                        return function (param) do
                          return mark_loops_rec(visited_1, param);
                        end end
                        end end)(visited_1), apply_subst(match_1[1], match[1])); end end 
           if ___conditional___ == 4--[[ Tobject ]] then do
              if (List.memq(px, visited_objects.contents)) then do
                return add_alias(px);
              end else do
                if (opened_object(ty_1)) then do
                  visited_objects.contents = --[[ :: ]]{
                    px,
                    visited_objects.contents
                  };
                end
                 end 
                match_2 = match[1].contents;
                if (match_2 ~= undefined) then do
                  return List.iter((function(visited_1)do
                            return function (param) do
                              return mark_loops_rec(visited_1, param);
                            end end
                            end end)(visited_1), List.tl(match_2[1]));
                end else do
                  match_3 = flatten_fields(match[0]);
                  return List.iter((function(visited_1)do
                            return function (param) do
                              if (field_kind_repr(param[1]) == --[[ Fpresent ]]0) then do
                                return mark_loops_rec(visited_1, param[2]);
                              end else do
                                return 0;
                              end end 
                            end end
                            end end)(visited_1), match_3[0]);
                end end 
              end end  end end 
           if ___conditional___ == 5--[[ Tfield ]] then do
              ty2 = match[3];
              if (field_kind_repr(match[1]) == --[[ Fpresent ]]0) then do
                mark_loops_rec(visited_1, match[2]);
                _ty = ty2;
                _visited = visited_1;
                ::continue:: ;
              end else do
                _ty = ty2;
                _visited = visited_1;
                ::continue:: ;
              end end  end end 
           if ___conditional___ == 6--[[ Tlink ]] then do
              return fatal_error("Printtyp.mark_loops_rec (2)"); end end 
           if ___conditional___ == 7--[[ Tsubst ]] then do
              _ty = match[0];
              _visited = visited_1;
              ::continue:: ; end end 
           if ___conditional___ == 8--[[ Tvariant ]] then do
              if (List.memq(px, visited_objects.contents)) then do
                return add_alias(px);
              end else do
                row = row_repr_aux(--[[ [] ]]0, match[0]);
                if (not static_row(row)) then do
                  visited_objects.contents = --[[ :: ]]{
                    px,
                    visited_objects.contents
                  };
                end
                 end 
                match_4 = row.row_name;
                if (match_4 ~= undefined) then do
                  if (namable_row(row)) then do
                    return List.iter((function(visited_1)do
                              return function (param) do
                                return mark_loops_rec(visited_1, param);
                              end end
                              end end)(visited_1), match_4[1]);
                  end else do
                    return iter_row((function(visited_1)do
                              return function (param) do
                                return mark_loops_rec(visited_1, param);
                              end end
                              end end)(visited_1), row);
                  end end 
                end else do
                  return iter_row((function(visited_1)do
                            return function (param) do
                              return mark_loops_rec(visited_1, param);
                            end end
                            end end)(visited_1), row);
                end end 
              end end  end end 
           if ___conditional___ == 0--[[ Tvar ]]
           or ___conditional___ == 9--[[ Tunivar ]] then do
              return add_named_var(ty_1); end end 
           if ___conditional___ == 10--[[ Tpoly ]] then do
              List.iter(add_alias, match[1]);
              _ty = match[0];
              _visited = visited_1;
              ::continue:: ; end end 
           if ___conditional___ == 11--[[ Tpackage ]] then do
              return List.iter((function(visited_1)do
                        return function (param) do
                          return mark_loops_rec(visited_1, param);
                        end end
                        end end)(visited_1), match[2]); end end 
          
        end
      end end 
    end end 
  end;
end end

function mark_loops(ty) do
  normalize_type(empty, ty);
  return mark_loops_rec(--[[ [] ]]0, ty);
end end

function reset(param) do
  unique_names.contents = --[[ Empty ]]0;
  reset_names(--[[ () ]]0);
  visited_objects.contents = --[[ [] ]]0;
  aliased.contents = --[[ [] ]]0;
  delayed.contents = --[[ [] ]]0;
  return --[[ () ]]0;
end end

function reset_and_mark_loops_list(tyl) do
  reset(--[[ () ]]0);
  return List.iter(mark_loops, tyl);
end end

print_labels = do
  contents: true
end;

function tree_of_typexp(sch, ty) do
  ty_1 = repr(ty);
  px = proxy(ty_1);
  if (List.mem_assq(px, names.contents) and not List.memq(px, delayed.contents)) then do
    mark = is_non_gen(sch, ty_1);
    return --[[ Otyp_var ]]Block.__(10, {
              mark,
              name_of_type(px)
            });
  end else do
    pr_typ = function(param) do
      match = ty_1.desc;
      if (typeof match == "number") then do
        return tree_of_typobject(sch, ty_1, undefined);
      end else do
        local ___conditional___=(match.tag | 0);
        do
           if ___conditional___ == 0--[[ Tvar ]] then do
              return --[[ Otyp_var ]]Block.__(10, {
                        is_non_gen(sch, ty_1),
                        name_of_type(ty_1)
                      }); end end 
           if ___conditional___ == 1--[[ Tarrow ]] then do
              l = match[0];
              ty1 = match[1];
              ty2 = match[2];
              lab = print_labels.contents and l ~= "" or is_optional(l) and l or "";
              t1;
              if (is_optional(l)) then do
                match_1 = repr(ty1).desc;
                if (typeof match_1 == "number" or match_1.tag ~= --[[ Tconstr ]]3) then do
                  t1 = --[[ Otyp_stuff ]]Block.__(7, {"<hidden>"});
                end else do
                  match_2 = match_1[1];
                  t1 = match_2 and not (match_2[1] or not same(match_1[0], path_option)) and tree_of_typexp(sch, match_2[0]) or --[[ Otyp_stuff ]]Block.__(7, {"<hidden>"});
                end end 
              end else do
                t1 = tree_of_typexp(sch, ty1);
              end end 
              return --[[ Otyp_arrow ]]Block.__(1, {
                        lab,
                        t1,
                        tree_of_typexp(sch, ty2)
                      }); end end 
           if ___conditional___ == 2--[[ Ttuple ]] then do
              return --[[ Otyp_tuple ]]Block.__(9, {List.map((function(param) do
                                return tree_of_typexp(sch, param);
                              end end), match[0])}); end end 
           if ___conditional___ == 3--[[ Tconstr ]] then do
              match_3 = best_type_path(match[0]);
              s = match_3[1];
              tyl$prime = apply_subst(s, match[1]);
              if (is_nth(s)) then do
                return tree_of_typexp(sch, List.hd(tyl$prime));
              end else do
                return --[[ Otyp_constr ]]Block.__(3, {
                          tree_of_path(match_3[0]),
                          List.map((function(param) do
                                  return tree_of_typexp(sch, param);
                                end end), tyl$prime)
                        });
              end end  end end 
           if ___conditional___ == 4--[[ Tobject ]] then do
              return tree_of_typobject(sch, match[0], match[1].contents); end end 
           if ___conditional___ == 5--[[ Tfield ]] then do
              return tree_of_typobject(sch, ty_1, undefined); end end 
           if ___conditional___ == 6--[[ Tlink ]] then do
              return fatal_error("Printtyp.tree_of_typexp"); end end 
           if ___conditional___ == 7--[[ Tsubst ]] then do
              return tree_of_typexp(sch, match[0]); end end 
           if ___conditional___ == 8--[[ Tvariant ]] then do
              row = row_repr_aux(--[[ [] ]]0, match[0]);
              fields = row.row_closed and List.filter((function(param) do
                          return row_field_repr_aux(--[[ [] ]]0, param[1]) ~= --[[ Rabsent ]]0;
                        end end))(row.row_fields) or row.row_fields;
              present = List.filter((function(param) do
                        match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                        if (typeof match == "number" or match.tag) then do
                          return false;
                        end else do
                          return true;
                        end end 
                      end end))(fields);
              all_present = List.length(present) == List.length(fields);
              match_4 = row.row_name;
              if (match_4 ~= undefined) then do
                match_5 = match_4;
                tyl = match_5[1];
                p = match_5[0];
                if (namable_row(row)) then do
                  match_6 = best_type_path(p);
                  s_1 = match_6[1];
                  id = tree_of_path(match_6[0]);
                  tyl_1 = apply_subst(s_1, tyl);
                  args = List.map((function(param) do
                          return tree_of_typexp(sch, param);
                        end end), tyl_1);
                  if (row.row_closed and all_present) then do
                    if (is_nth(s_1)) then do
                      return List.hd(args);
                    end else do
                      return --[[ Otyp_constr ]]Block.__(3, {
                                id,
                                args
                              });
                    end end 
                  end else do
                    non_gen = is_non_gen(sch, px);
                    tags = all_present and undefined or List.map((function(prim) do
                              return prim[0];
                            end end), present);
                    inh;
                    exit = 0;
                    if (args) then do
                      match_7 = args[0];
                      if (typeof match_7 == "number" or not (match_7.tag == --[[ Otyp_constr ]]3 and not (args[1] or not is_nth(s_1)))) then do
                        exit = 2;
                      end else do
                        inh = --[[ Ovar_name ]]Block.__(1, {
                            match_7[0],
                            match_7[1]
                          });
                      end end 
                    end else do
                      exit = 2;
                    end end 
                    if (exit == 2) then do
                      inh = --[[ Ovar_name ]]Block.__(1, {
                          tree_of_path(p),
                          List.map((function(param) do
                                  return tree_of_typexp(sch, param);
                                end end), tyl)
                        });
                    end
                     end 
                    return --[[ Otyp_variant ]]Block.__(11, {
                              non_gen,
                              inh,
                              row.row_closed,
                              tags
                            });
                  end end 
                end
                 end 
              end
               end 
              non_gen_1 = not (row.row_closed and all_present) and is_non_gen(sch, px);
              fields_1 = List.map((function(param) do
                      sch_1 = sch;
                      param_1 = param;
                      l = param_1[0];
                      match = row_field_repr_aux(--[[ [] ]]0, param_1[1]);
                      if (typeof match == "number") then do
                        return --[[ tuple ]]{
                                l,
                                false,
                                --[[ [] ]]0
                              };
                      end else if (match.tag) then do
                        c = match[0];
                        if (c and not match[1]) then do
                          return --[[ tuple ]]{
                                  l,
                                  false,
                                  --[[ [] ]]0
                                };
                        end
                         end 
                        tyl = match[1];
                        if (c) then do
                          return --[[ tuple ]]{
                                  l,
                                  true,
                                  List.map((function(param) do
                                          return tree_of_typexp(sch_1, param);
                                        end end), tyl)
                                };
                        end else do
                          return --[[ tuple ]]{
                                  l,
                                  false,
                                  List.map((function(param) do
                                          return tree_of_typexp(sch_1, param);
                                        end end), tyl)
                                };
                        end end 
                      end else do
                        match_1 = match[0];
                        if (match_1 ~= undefined) then do
                          return --[[ tuple ]]{
                                  l,
                                  false,
                                  --[[ :: ]]{
                                    tree_of_typexp(sch_1, match_1),
                                    --[[ [] ]]0
                                  }
                                };
                        end else do
                          return --[[ tuple ]]{
                                  l,
                                  false,
                                  --[[ [] ]]0
                                };
                        end end 
                      end end  end 
                    end end), fields);
              tags_1 = all_present and undefined or List.map((function(prim) do
                        return prim[0];
                      end end), present);
              return --[[ Otyp_variant ]]Block.__(11, {
                        non_gen_1,
                        --[[ Ovar_fields ]]Block.__(0, {fields_1}),
                        row.row_closed,
                        tags_1
                      }); end end 
           if ___conditional___ == 9--[[ Tunivar ]] then do
              return --[[ Otyp_var ]]Block.__(10, {
                        false,
                        name_of_type(ty_1)
                      }); end end 
           if ___conditional___ == 10--[[ Tpoly ]] then do
              tyl_2 = match[1];
              ty_2 = match[0];
              if (tyl_2) then do
                tyl_3 = List.map(repr, tyl_2);
                if (tyl_3 == --[[ [] ]]0) then do
                  return tree_of_typexp(sch, ty_2);
                end else do
                  old_delayed = delayed.contents;
                  List.iter(add_delayed, tyl_3);
                  tl = List.map(name_of_type, tyl_3);
                  tr_001 = tree_of_typexp(sch, ty_2);
                  tr = --[[ Otyp_poly ]]Block.__(12, {
                      tl,
                      tr_001
                    });
                  remove_names(tyl_3);
                  delayed.contents = old_delayed;
                  return tr;
                end end 
              end else do
                return tree_of_typexp(sch, ty_2);
              end end  end end 
           if ___conditional___ == 11--[[ Tpackage ]] then do
              n = List.map((function(li) do
                      return __String.concat(".", flat(--[[ [] ]]0, li));
                    end end), match[1]);
              return --[[ Otyp_module ]]Block.__(13, {
                        name(undefined, match[0]),
                        n,
                        List.map((function(param) do
                                return tree_of_typexp(sch, param);
                              end end), match[2])
                      }); end end 
          
        end
      end end 
    end end;
    if (List.memq(px, delayed.contents)) then do
      delayed.contents = List.filter((function(param) do
                return px ~= param;
              end end))(delayed.contents);
    end
     end 
    if (is_aliased(px) and aliasable(ty_1)) then do
      name_of_type(px);
      return --[[ Otyp_alias ]]Block.__(0, {
                pr_typ(--[[ () ]]0),
                name_of_type(px)
              });
    end else do
      return pr_typ(--[[ () ]]0);
    end end 
  end end 
end end

function tree_of_typobject(sch, fi, nm) do
  if (nm ~= undefined) then do
    match = nm;
    match_1 = match[1];
    if (match_1) then do
      non_gen = is_non_gen(sch, repr(match_1[0]));
      args = List.map((function(param) do
              return tree_of_typexp(sch, param);
            end end), match_1[1]);
      match_2 = best_type_path(match[0]);
      if (match_2[1] ~= --[[ Id ]]0) then do
        error({
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "printtyp.ml",
            688,
            6
          }
        })
      end
       end 
      return --[[ Otyp_class ]]Block.__(2, {
                non_gen,
                tree_of_path(match_2[0]),
                args
              });
    end else do
      return fatal_error("Printtyp.tree_of_typobject");
    end end 
  end else do
    pr_fields = function(fi) do
      match = flatten_fields(fi);
      present_fields = List.fold_right((function(param, l) do
              match = field_kind_repr(param[1]);
              if (typeof match == "number" and match == 0) then do
                return --[[ :: ]]{
                        --[[ tuple ]]{
                          param[0],
                          param[2]
                        },
                        l
                      };
              end else do
                return l;
              end end 
            end end), match[0], --[[ [] ]]0);
      sorted_fields = List.sort((function(param, param_1) do
              return Caml_primitive.caml_string_compare(param[0], param_1[0]);
            end end), present_fields);
      return tree_of_typfields(sch, match[1], sorted_fields);
    end end;
    match_3 = pr_fields(fi);
    return --[[ Otyp_object ]]Block.__(5, {
              match_3[0],
              match_3[1]
            });
  end end 
end end

function is_non_gen(sch, ty) do
  if (sch and is_Tvar(ty)) then do
    return ty.level ~= 100000000;
  end else do
    return false;
  end end 
end end

function tree_of_typfields(sch, rest, param) do
  if (param) then do
    match = param[0];
    field_000 = match[0];
    field_001 = tree_of_typexp(sch, match[1]);
    field = --[[ tuple ]]{
      field_000,
      field_001
    };
    match_1 = tree_of_typfields(sch, rest, param[1]);
    return --[[ tuple ]]{
            --[[ :: ]]{
              field,
              match_1[0]
            },
            match_1[1]
          };
  end else do
    match_2 = rest.desc;
    rest_1;
    if (typeof match_2 == "number") then do
      rest_1 = undefined;
    end else do
      local ___conditional___=(match_2.tag | 0);
      do
         if ___conditional___ == 3--[[ Tconstr ]] then do
            rest_1 = false; end else 
         if ___conditional___ == 0--[[ Tvar ]]
         or ___conditional___ == 9--[[ Tunivar ]] then do
            rest_1 = is_non_gen(sch, rest); end else 
         end end end end
        rest_1 = fatal_error("typfields (1)");
          
      end
    end end 
    return --[[ tuple ]]{
            --[[ [] ]]0,
            rest_1
          };
  end end 
end end

function typexp_1(sch, prio, ppf, ty) do
  return Curry._2(out_type.contents, ppf, tree_of_typexp(sch, ty));
end end

function type_expr_1(ppf, ty) do
  return typexp_1(false, 0, ppf, ty);
end end

function type_scheme(ppf, ty) do
  reset(--[[ () ]]0);
  mark_loops(ty);
  return typexp_1(true, 0, ppf, ty);
end end

function tree_of_type_scheme(ty) do
  reset(--[[ () ]]0);
  mark_loops(ty);
  return tree_of_typexp(true, ty);
end end

function tree_of_constraints(params) do
  return List.fold_right((function(ty, list) do
                ty$prime = unalias(ty);
                if (proxy(ty) ~= proxy(ty$prime)) then do
                  tr = tree_of_typexp(true, ty);
                  return --[[ :: ]]{
                          --[[ tuple ]]{
                            tr,
                            tree_of_typexp(true, ty$prime)
                          },
                          list
                        };
                end else do
                  return list;
                end end 
              end end), params, --[[ [] ]]0);
end end

function filter_params(tyl) do
  return List.rev(List.fold_left((function(tyl, ty) do
                    ty_1 = repr(ty);
                    if (List.memq(ty_1, tyl)) then do
                      return --[[ :: ]]{
                              newty2(100000000, --[[ Tsubst ]]Block.__(7, {ty_1})),
                              tyl
                            };
                    end else do
                      return --[[ :: ]]{
                              ty_1,
                              tyl
                            };
                    end end 
                  end end), --[[ [] ]]0, tyl));
end end

function tree_of_label(l) do
  return --[[ tuple ]]{
          l.ld_id.name,
          l.ld_mutable == --[[ Mutable ]]1,
          tree_of_typexp(false, l.ld_type)
        };
end end

function tree_of_constructor(cd) do
  name = cd.cd_id.name;
  match = cd.cd_res;
  if (match ~= undefined) then do
    nm = names.contents;
    names.contents = --[[ [] ]]0;
    ret = tree_of_typexp(false, match);
    args = List.map((function(param) do
            return tree_of_typexp(false, param);
          end end), cd.cd_args);
    names.contents = nm;
    return --[[ tuple ]]{
            name,
            args,
            ret
          };
  end else do
    return --[[ tuple ]]{
            name,
            List.map((function(param) do
                    return tree_of_typexp(false, param);
                  end end), cd.cd_args),
            undefined
          };
  end end 
end end

function tree_of_type_decl(id, decl) do
  reset(--[[ () ]]0);
  params = filter_params(decl.type_params);
  match = decl.type_manifest;
  if (match ~= undefined) then do
    vars = free_variables_1(undefined, match);
    List.iter((function(ty) do
            match = ty.desc;
            if (typeof match == "number" or match.tag) then do
              return --[[ () ]]0;
            end else do
              match_1 = match[0];
              if (match_1 ~= undefined and match_1 == "_" and List.memq(ty, vars)) then do
                ty.desc = --[[ Tvar ]]Block.__(0, {undefined});
                return --[[ () ]]0;
              end else do
                return --[[ () ]]0;
              end end 
            end end 
          end end), params);
  end
   end 
  List.iter(add_alias, params);
  List.iter(mark_loops, params);
  List.iter(check_name_of_type, List.map(proxy, params));
  match_1 = decl.type_manifest;
  ty_manifest;
  if (match_1 ~= undefined) then do
    ty = match_1;
    match_2 = repr(ty);
    match_3 = match_2.desc;
    ty_1;
    if (typeof match_3 == "number" or match_3.tag ~= --[[ Tvariant ]]8) then do
      ty_1 = ty;
    end else do
      row = row_repr_aux(--[[ [] ]]0, match_3[0]);
      match_4 = row.row_name;
      if (match_4 ~= undefined) then do
        match_5 = match_4[0];
        local ___conditional___=(match_5.tag | 0);
        do
           if ___conditional___ == 0--[[ Pident ]] then do
              ty_1 = Caml_obj.caml_equal(id, match_5[0]) and newty2(100000000, --[[ Tvariant ]]Block.__(8, {do
                          row_fields: row.row_fields,
                          row_more: row.row_more,
                          row_bound: row.row_bound,
                          row_closed: row.row_closed,
                          row_fixed: row.row_fixed,
                          row_name: undefined
                        end})) or ty; end else 
           if ___conditional___ == 1--[[ Pdot ]]
           or ___conditional___ == 2--[[ Papply ]] then do
              ty_1 = ty; end else 
           end end end end
          
        end
      end else do
        ty_1 = ty;
      end end 
    end end 
    mark_loops(ty_1);
    ty_manifest = ty_1;
  end else do
    ty_manifest = undefined;
  end end 
  match_6 = decl.type_kind;
  if (typeof match_6 == "number") then do
    match_6 == --[[ Type_abstract ]]0;
  end else if (match_6.tag) then do
    List.iter((function(c) do
            List.iter(mark_loops, c.cd_args);
            return may(mark_loops, c.cd_res);
          end end), match_6[0]);
  end else do
    List.iter((function(l) do
            return mark_loops(l.ld_type);
          end end), match_6[0]);
  end end  end 
  type_param = function(param) do
    if (typeof param == "number" or param.tag ~= --[[ Otyp_var ]]10) then do
      return "?";
    end else do
      return param[1];
    end end 
  end end;
  type_defined = function(decl) do
    match = decl.type_kind;
    abstr;
    abstr = typeof match == "number" and (
        match == --[[ Type_abstract ]]0 and decl.type_manifest == undefined or decl.type_private == --[[ Private ]]0 or decl.type_manifest == undefined
      ) or (
        match.tag and decl.type_private == --[[ Private ]]0 or List.exists((function(cd) do
                  return cd.cd_res ~= undefined;
                end end), match[0]) or decl.type_private == --[[ Private ]]0
      );
    vari = List.map2((function(ty, v) do
            if (abstr or not is_Tvar(repr(ty))) then do
              return Curry._1(Types_Variance.get_upper, v);
            end else do
              return --[[ tuple ]]{
                      true,
                      true
                    };
            end end 
          end end), decl.type_params, decl.type_variance);
    return --[[ tuple ]]{
            id.name,
            List.map2((function(ty, cocn) do
                    return --[[ tuple ]]{
                            type_param(tree_of_typexp(false, ty)),
                            cocn
                          };
                  end end), params, vari)
          };
  end end;
  tree_of_manifest = function(ty1) do
    if (ty_manifest ~= undefined) then do
      return --[[ Otyp_manifest ]]Block.__(4, {
                tree_of_typexp(false, ty_manifest),
                ty1
              });
    end else do
      return ty1;
    end end 
  end end;
  match_7 = type_defined(decl);
  constraints = tree_of_constraints(params);
  match_8 = decl.type_kind;
  match_9;
  match_9 = typeof match_8 == "number" and (
      match_8 == --[[ Type_abstract ]]0 and (
          ty_manifest ~= undefined and --[[ tuple ]]{
              tree_of_typexp(false, ty_manifest),
              decl.type_private
            } or --[[ tuple ]]{
              --[[ Otyp_abstract ]]0,
              --[[ Public ]]1
            }
        ) or --[[ tuple ]]{
          tree_of_manifest(--[[ Otyp_open ]]1),
          --[[ Public ]]1
        }
    ) or (
      match_8.tag and --[[ tuple ]]{
          tree_of_manifest(--[[ Otyp_sum ]]Block.__(8, {List.map(tree_of_constructor, match_8[0])})),
          decl.type_private
        } or --[[ tuple ]]{
          tree_of_manifest(--[[ Otyp_record ]]Block.__(6, {List.map(tree_of_label, match_8[0])})),
          decl.type_private
        }
    );
  return do
          otype_name: match_7[0],
          otype_params: match_7[1],
          otype_type: match_9[0],
          otype_private: match_9[1],
          otype_cstrs: constraints
        end;
end end

function tree_of_type_declaration(id, decl, rs) do
  return --[[ Osig_type ]]Block.__(5, {
            tree_of_type_decl(id, decl),
            rs
          });
end end

function type_declaration_1(id, ppf, decl) do
  return Curry._2(out_sig_item.contents, ppf, tree_of_type_declaration(id, decl, --[[ Trec_first ]]1));
end end

function tree_of_extension_constructor(id, ext, es) do
  reset(--[[ () ]]0);
  ty_name = name(undefined, ext.ext_type_path);
  ty_params = filter_params(ext.ext_type_params);
  List.iter(add_alias, ty_params);
  List.iter(mark_loops, ty_params);
  List.iter(check_name_of_type, List.map(proxy, ty_params));
  List.iter(mark_loops, ext.ext_args);
  may(mark_loops, ext.ext_ret_type);
  ty_params_1 = List.map((function(ty) do
          param = tree_of_typexp(false, ty);
          if (typeof param == "number" or param.tag ~= --[[ Otyp_var ]]10) then do
            return "?";
          end else do
            return param[1];
          end end 
        end end), ty_params);
  name_1 = id.name;
  match = ext.ext_ret_type;
  match_1;
  if (match ~= undefined) then do
    nm = names.contents;
    names.contents = --[[ [] ]]0;
    ret = tree_of_typexp(false, match);
    args = List.map((function(param) do
            return tree_of_typexp(false, param);
          end end), ext.ext_args);
    names.contents = nm;
    match_1 = --[[ tuple ]]{
      args,
      ret
    };
  end else do
    match_1 = --[[ tuple ]]{
      List.map((function(param) do
              return tree_of_typexp(false, param);
            end end), ext.ext_args),
      undefined
    };
  end end 
  ext_oext_args = match_1[0];
  ext_oext_ret_type = match_1[1];
  ext_oext_private = ext.ext_private;
  ext_1 = do
    oext_name: name_1,
    oext_type_name: ty_name,
    oext_type_params: ty_params_1,
    oext_args: ext_oext_args,
    oext_ret_type: ext_oext_ret_type,
    oext_private: ext_oext_private
  end;
  return --[[ Osig_typext ]]Block.__(2, {
            ext_1,
            es
          });
end end

function extension_constructor_1(id, ppf, ext) do
  return Curry._2(out_sig_item.contents, ppf, tree_of_extension_constructor(id, ext, --[[ Text_first ]]0));
end end

function tree_of_value_description(id, decl) do
  id_1 = id.name;
  ty = tree_of_type_scheme(decl.val_type);
  match = decl.val_kind;
  prims;
  prims = typeof match == "number" or match.tag and --[[ [] ]]0 or description_list(match[0]);
  return --[[ Osig_value ]]Block.__(6, {
            id_1,
            ty,
            prims
          });
end end

function value_description_1(id, ppf, decl) do
  return Curry._2(out_sig_item.contents, ppf, tree_of_value_description(id, decl));
end end

function method_type(param) do
  match = field_kind_repr(param[1]);
  match_1 = repr(param[2]);
  if (typeof match == "number" and match == 0) then do
    match_2 = match_1.desc;
    if (typeof match_2 == "number" or match_2.tag ~= --[[ Tpoly ]]10) then do
      return --[[ tuple ]]{
              match_1,
              --[[ [] ]]0
            };
    end else do
      return --[[ tuple ]]{
              match_2[0],
              match_2[1]
            };
    end end 
  end else do
    return --[[ tuple ]]{
            match_1,
            --[[ [] ]]0
          };
  end end 
end end

function prepare_class_type(params, _param) do
  while(true) do
    param = _param;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ == 0--[[ Cty_constr ]] then do
          cty = param[2];
          tyl = param[1];
          sty = repr(signature_of_class_type(cty).csig_self);
          if (List.memq(proxy(sty), visited_objects.contents) or not List.for_all(is_Tvar, params) or List.exists((function(sty)do
                return function (param) do
                  return deep_occur(sty, param);
                end end
                end end)(sty), tyl)) then do
            _param = cty;
            ::continue:: ;
          end else do
            return List.iter(mark_loops, tyl);
          end end  end end 
       if ___conditional___ == 1--[[ Cty_signature ]] then do
          sign = param[0];
          sty_1 = repr(sign.csig_self);
          px = proxy(sty_1);
          if (List.memq(px, visited_objects.contents)) then do
            add_alias(sty_1);
          end else do
            visited_objects.contents = --[[ :: ]]{
              px,
              visited_objects.contents
            };
          end end 
          match = flatten_fields(object_fields(sign.csig_self));
          List.iter((function(met) do
                  return mark_loops(method_type(met)[0]);
                end end), match[0]);
          return iter_1((function(param, param_1) do
                        return mark_loops(param_1[2]);
                      end end), sign.csig_vars); end end 
       if ___conditional___ == 2--[[ Cty_arrow ]] then do
          mark_loops(param[1]);
          _param = param[2];
          ::continue:: ; end end 
      
    end
  end;
end end

function tree_of_class_type(sch, params, _param) do
  while(true) do
    param = _param;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ == 0--[[ Cty_constr ]] then do
          cty = param[2];
          sty = repr(signature_of_class_type(cty).csig_self);
          if (List.memq(proxy(sty), visited_objects.contents) or not List.for_all(is_Tvar, params)) then do
            _param = cty;
            ::continue:: ;
          end else do
            return --[[ Octy_constr ]]Block.__(0, {
                      tree_of_path(param[0]),
                      List.map((function(param) do
                              return tree_of_typexp(true, param);
                            end end), param[1])
                    });
          end end  end end 
       if ___conditional___ == 1--[[ Cty_signature ]] then do
          sign = param[0];
          sty_1 = repr(sign.csig_self);
          self_ty = is_aliased(sty_1) and --[[ Otyp_var ]]Block.__(10, {
                false,
                name_of_type(proxy(sty_1))
              }) or undefined;
          match = flatten_fields(object_fields(sign.csig_self));
          csil = List.fold_left((function(csil, param) do
                  return --[[ :: ]]{
                          --[[ Ocsg_constraint ]]Block.__(0, {
                              param[0],
                              param[1]
                            }),
                          csil
                        };
                end end), --[[ [] ]]0, tree_of_constraints(params));
          all_vars = fold((function(l, param, all) do
                  return --[[ :: ]]{
                          --[[ tuple ]]{
                            l,
                            param[0],
                            param[1],
                            param[2]
                          },
                          all
                        };
                end end), sign.csig_vars, --[[ [] ]]0);
          all_vars_1 = List.rev(all_vars);
          csil_1 = List.fold_left((function(csil, param) do
                  return --[[ :: ]]{
                          --[[ Ocsg_value ]]Block.__(2, {
                              param[0],
                              param[1] == --[[ Mutable ]]1,
                              param[2] == --[[ Virtual ]]0,
                              tree_of_typexp(sch, param[3])
                            }),
                          csil
                        };
                end end), csil, all_vars_1);
          partial_arg = sign.csig_concr;
          csil_2 = List.fold_left((function(partial_arg)do
              return function (param, param_1) do
                sch_1 = sch;
                concrete = partial_arg;
                csil = param;
                param_2 = param_1;
                lab = param_2[0];
                if (lab ~= dummy_method) then do
                  kind = field_kind_repr(param_2[1]);
                  priv = kind ~= --[[ Fpresent ]]0;
                  virt = not mem_2(lab, concrete);
                  match = method_type(--[[ tuple ]]{
                        lab,
                        kind,
                        param_2[2]
                      });
                  tty = tree_of_typexp(sch_1, match[0]);
                  remove_names(match[1]);
                  return --[[ :: ]]{
                          --[[ Ocsg_method ]]Block.__(1, {
                              lab,
                              priv,
                              virt,
                              tty
                            }),
                          csil
                        };
                end else do
                  return csil;
                end end 
              end end
              end end)(partial_arg), csil_1, match[0]);
          return --[[ Octy_signature ]]Block.__(2, {
                    self_ty,
                    List.rev(csil_2)
                  }); end end 
       if ___conditional___ == 2--[[ Cty_arrow ]] then do
          ty = param[1];
          l = param[0];
          lab = print_labels.contents and l ~= "" or is_optional(l) and l or "";
          ty_1;
          if (is_optional(l)) then do
            match_1 = repr(ty).desc;
            exit = 0;
            if (typeof match_1 == "number" or match_1.tag ~= --[[ Tconstr ]]3) then do
              exit = 1;
            end else do
              match_2 = match_1[1];
              if (match_2 and not (match_2[1] or not same(match_1[0], path_option))) then do
                ty_1 = match_2[0];
              end else do
                exit = 1;
              end end 
            end end 
            if (exit == 1) then do
              ty_1 = newconstr(--[[ Pident ]]Block.__(0, {create("<hidden>")}), --[[ [] ]]0);
            end
             end 
          end else do
            ty_1 = ty;
          end end 
          tr = tree_of_typexp(sch, ty_1);
          return --[[ Octy_arrow ]]Block.__(1, {
                    lab,
                    tr,
                    tree_of_class_type(sch, params, param[2])
                  }); end end 
      
    end
  end;
end end

function class_type_2(ppf, cty) do
  reset(--[[ () ]]0);
  prepare_class_type(--[[ [] ]]0, cty);
  return Curry._2(out_class_type.contents, ppf, tree_of_class_type(false, --[[ [] ]]0, cty));
end end

function tree_of_class_param(param, variance) do
  match = tree_of_typexp(true, param);
  tmp;
  tmp = typeof match == "number" or match.tag ~= --[[ Otyp_var ]]10 and "?" or match[1];
  return --[[ tuple ]]{
          tmp,
          is_Tvar(repr(param)) and --[[ tuple ]]{
              true,
              true
            } or variance
        };
end end

function class_variance(param) do
  return List.map((function(v) do
                return --[[ tuple ]]{
                        Curry._2(Types_Variance.mem, --[[ May_pos ]]0, v),
                        Curry._2(Types_Variance.mem, --[[ May_neg ]]1, v)
                      };
              end end), param);
end end

function tree_of_class_declaration(id, cl, rs) do
  params = filter_params(cl.cty_params);
  reset(--[[ () ]]0);
  List.iter(add_alias, params);
  prepare_class_type(params, cl.cty_type);
  sty = repr(signature_of_class_type(cl.cty_type).csig_self);
  List.iter(mark_loops, params);
  List.iter(check_name_of_type, List.map(proxy, params));
  if (is_aliased(sty)) then do
    t = proxy(sty);
    name_of_type(t);
  end
   end 
  vir_flag = cl.cty_new == undefined;
  return --[[ Osig_class ]]Block.__(0, {
            vir_flag,
            id.name,
            List.map2(tree_of_class_param, params, class_variance(cl.cty_variance)),
            tree_of_class_type(true, params, cl.cty_type),
            rs
          });
end end

function class_declaration_1(id, ppf, cl) do
  return Curry._2(out_sig_item.contents, ppf, tree_of_class_declaration(id, cl, --[[ Trec_first ]]1));
end end

function tree_of_cltype_declaration(id, cl, rs) do
  params = List.map(repr, cl.clty_params);
  reset(--[[ () ]]0);
  List.iter(add_alias, params);
  prepare_class_type(params, cl.clty_type);
  sty = repr(signature_of_class_type(cl.clty_type).csig_self);
  List.iter(mark_loops, params);
  List.iter(check_name_of_type, List.map(proxy, params));
  if (is_aliased(sty)) then do
    t = proxy(sty);
    name_of_type(t);
  end
   end 
  sign = signature_of_class_type(cl.clty_type);
  match = flatten_fields(object_fields(sign.csig_self));
  virt = List.exists((function(param) do
          lab = param[0];
          return not (lab == dummy_method or mem_2(lab, sign.csig_concr));
        end end), match[0]) or fold((function(param, param_1, b) do
          if (param_1[1] == --[[ Virtual ]]0) then do
            return true;
          end else do
            return b;
          end end 
        end end), sign.csig_vars, false);
  return --[[ Osig_class_type ]]Block.__(1, {
            virt,
            id.name,
            List.map2(tree_of_class_param, params, class_variance(cl.clty_variance)),
            tree_of_class_type(true, params, cl.clty_type),
            rs
          });
end end

function cltype_declaration_1(id, ppf, cl) do
  return Curry._2(out_sig_item.contents, ppf, tree_of_cltype_declaration(id, cl, --[[ Trec_first ]]1));
end end

function wrap_env(fenv, ftree, arg) do
  env = printing_env.contents;
  set_printing_env(Curry._1(fenv, env));
  tree = Curry._1(ftree, arg);
  set_printing_env(env);
  return tree;
end end

function filter_rem_sig(item, rem) do
  local ___conditional___=(item.tag | 0);
  do
     if ___conditional___ == 5--[[ Sig_class ]] then do
        if (rem) then do
          match = rem[1];
          if (match) then do
            match_1 = match[1];
            if (match_1) then do
              return --[[ tuple ]]{
                      --[[ :: ]]{
                        rem[0],
                        --[[ :: ]]{
                          match[0],
                          --[[ :: ]]{
                            match_1[0],
                            --[[ [] ]]0
                          }
                        }
                      },
                      match_1[1]
                    };
            end else do
              return --[[ tuple ]]{
                      --[[ [] ]]0,
                      rem
                    };
            end end 
          end else do
            return --[[ tuple ]]{
                    --[[ [] ]]0,
                    rem
                  };
          end end 
        end else do
          return --[[ tuple ]]{
                  --[[ [] ]]0,
                  rem
                };
        end end  end end 
     if ___conditional___ == 6--[[ Sig_class_type ]] then do
        if (rem) then do
          match_2 = rem[1];
          if (match_2) then do
            return --[[ tuple ]]{
                    --[[ :: ]]{
                      rem[0],
                      --[[ :: ]]{
                        match_2[0],
                        --[[ [] ]]0
                      }
                    },
                    match_2[1]
                  };
          end else do
            return --[[ tuple ]]{
                    --[[ [] ]]0,
                    rem
                  };
          end end 
        end else do
          return --[[ tuple ]]{
                  --[[ [] ]]0,
                  rem
                };
        end end  end end 
    return --[[ tuple ]]{
              --[[ [] ]]0,
              rem
            };
      
  end
end end

dummy = do
  type_params: --[[ [] ]]0,
  type_arity: 0,
  type_kind: --[[ Type_abstract ]]0,
  type_private: --[[ Public ]]1,
  type_manifest: undefined,
  type_variance: --[[ [] ]]0,
  type_newtype_level: undefined,
  type_loc: none,
  type_attributes: --[[ [] ]]0
end;

function hide_rec_items(param) do
  if (param) then do
    match = param[0];
    if (match.tag == --[[ Sig_type ]]1 and match[2] == --[[ Trec_first ]]1 and not real_paths.contents) then do
      get_ids = function(param) do
        if (param) then do
          match = param[0];
          if (match.tag == --[[ Sig_type ]]1 and match[2] >= 2) then do
            return --[[ :: ]]{
                    match[0],
                    get_ids(param[1])
                  };
          end else do
            return --[[ [] ]]0;
          end end 
        end else do
          return --[[ [] ]]0;
        end end 
      end end;
      ids_000 = match[0];
      ids_001 = get_ids(param[1]);
      ids = --[[ :: ]]{
        ids_000,
        ids_001
      };
      return set_printing_env(List.fold_right((function(id) do
                        partial_arg = rename(id);
                        return (function(param) do
                            return add_type_1(false, partial_arg, dummy, param);
                          end end);
                      end end), ids, printing_env.contents));
    end else do
      return --[[ () ]]0;
    end end 
  end else do
    return --[[ () ]]0;
  end end 
end end

function tree_of_modtype(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Mty_ident ]] then do
        return --[[ Omty_ident ]]Block.__(1, {tree_of_path(param[0])}); end end 
     if ___conditional___ == 1--[[ Mty_signature ]] then do
        return --[[ Omty_signature ]]Block.__(2, {tree_of_signature(param[0])}); end end 
     if ___conditional___ == 2--[[ Mty_functor ]] then do
        ty_res = param[2];
        ty_arg = param[1];
        param_1 = param[0];
        res;
        if (ty_arg ~= undefined) then do
          mty = ty_arg;
          partial_arg = true;
          res = wrap_env((function(param_2) do
                  return add_module_1(partial_arg, param_1, mty, param_2);
                end end), tree_of_modtype, ty_res);
        end else do
          res = tree_of_modtype(ty_res);
        end end 
        return --[[ Omty_functor ]]Block.__(0, {
                  param_1.name,
                  may_map(tree_of_modtype, ty_arg),
                  res
                }); end end 
     if ___conditional___ == 3--[[ Mty_alias ]] then do
        return --[[ Omty_alias ]]Block.__(3, {tree_of_path(param[0])}); end end 
    
  end
end end

function tree_of_signature(sg) do
  partial_arg = printing_env.contents;
  return wrap_env((function(env) do
                return env;
              end end), (function(param) do
                return tree_of_signature_rec(partial_arg, false, param);
              end end), sg);
end end

function tree_of_signature_rec(env$prime, in_type_group, param) do
  if (param) then do
    item = param[0];
    in_type_group_1;
    exit = 0;
    if (in_type_group) then do
      if (item.tag == --[[ Sig_type ]]1) then do
        if (item[2] >= 2) then do
          in_type_group_1 = true;
        end else do
          exit = 1;
        end end 
      end else do
        set_printing_env(env$prime);
        in_type_group_1 = false;
      end end 
    end else do
      exit = 1;
    end end 
    if (exit == 1) then do
      set_printing_env(env$prime);
      in_type_group_1 = item.tag == --[[ Sig_type ]]1 and item[2] < 2 and true or false;
    end
     end 
    match = filter_rem_sig(item, param[1]);
    rem = match[1];
    trees;
    local ___conditional___=(item.tag | 0);
    do
       if ___conditional___ == 0--[[ Sig_value ]] then do
          trees = --[[ :: ]]{
            tree_of_value_description(item[0], item[1]),
            --[[ [] ]]0
          }; end else 
       if ___conditional___ == 1--[[ Sig_type ]] then do
          id = item[0];
          if (is_row_name(id.name)) then do
            trees = --[[ [] ]]0;
          end else do
            hide_rec_items(--[[ :: ]]{
                  item,
                  rem
                });
            trees = --[[ :: ]]{
              --[[ Osig_type ]]Block.__(5, {
                  tree_of_type_decl(id, item[1]),
                  item[2]
                }),
              --[[ [] ]]0
            };
          end end  end else 
       if ___conditional___ == 2--[[ Sig_typext ]] then do
          trees = --[[ :: ]]{
            tree_of_extension_constructor(item[0], item[1], item[2]),
            --[[ [] ]]0
          }; end else 
       if ___conditional___ == 3--[[ Sig_module ]] then do
          trees = --[[ :: ]]{
            --[[ Osig_module ]]Block.__(4, {
                item[0].name,
                tree_of_modtype(item[1].md_type),
                item[2]
              }),
            --[[ [] ]]0
          }; end else 
       if ___conditional___ == 4--[[ Sig_modtype ]] then do
          trees = --[[ :: ]]{
            tree_of_modtype_declaration(item[0], item[1]),
            --[[ [] ]]0
          }; end else 
       if ___conditional___ == 5--[[ Sig_class ]] then do
          trees = --[[ :: ]]{
            tree_of_class_declaration(item[0], item[1], item[2]),
            --[[ [] ]]0
          }; end else 
       if ___conditional___ == 6--[[ Sig_class_type ]] then do
          trees = --[[ :: ]]{
            tree_of_cltype_declaration(item[0], item[1], item[2]),
            --[[ [] ]]0
          }; end else 
       end end end end end end end end end end end end end end
      
    end
    env$prime_1 = add_signature(--[[ :: ]]{
          item,
          match[0]
        }, env$prime);
    return Pervasives.$at(trees, tree_of_signature_rec(env$prime_1, in_type_group_1, rem));
  end else do
    return --[[ [] ]]0;
  end end 
end end

function tree_of_modtype_declaration(id, decl) do
  match = decl.mtd_type;
  mty = match ~= undefined and tree_of_modtype(match) or --[[ Omty_abstract ]]0;
  return --[[ Osig_modtype ]]Block.__(3, {
            id.name,
            mty
          });
end end

function modtype_1(ppf, mty) do
  return Curry._2(out_module_type.contents, ppf, tree_of_modtype(mty));
end end

function modtype_declaration_1(id, ppf, decl) do
  return Curry._2(out_sig_item.contents, ppf, tree_of_modtype_declaration(id, decl));
end end

function print_signature(ppf, tree) do
  return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                  --[[ Formatting_gen ]]Block.__(18, {
                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                            --[[ String_literal ]]Block.__(11, {
                                "<v>",
                                --[[ End_of_format ]]0
                              }),
                            "<v>"
                          }}),
                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                              --[[ Close_box ]]0,
                              --[[ End_of_format ]]0
                            })})
                    }),
                  "@[<v>%a@]"
                }), out_signature.contents, tree);
end end

function signature_3(ppf, sg) do
  return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                  --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0}),
                  "%a"
                }), print_signature, tree_of_signature(sg));
end end

function same_path(t, t$prime) do
  t_1 = repr(t);
  t$prime_1 = repr(t$prime);
  if (t_1 == t$prime_1) then do
    return true;
  end else do
    match = t_1.desc;
    match_1 = t$prime_1.desc;
    if (typeof match == "number" or not (match.tag == --[[ Tconstr ]]3 and not (typeof match_1 == "number" or match_1.tag ~= --[[ Tconstr ]]3))) then do
      return false;
    end else do
      match_2 = best_type_path(match[0]);
      s1 = match_2[1];
      match_3 = best_type_path(match_1[0]);
      s2 = match_3[1];
      exit = 0;
      if (typeof s1 == "number" or s1.tag) then do
        exit = 1;
      end else if (typeof s2 == "number" or s2.tag) then do
        return false;
      end else do
        return s1[0] == s2[0];
      end end  end 
      if (exit == 1) then do
        if (typeof s2 ~= "number" and not s2.tag) then do
          return false;
        end
         end 
        if (same(match_2[0], match_3[0])) then do
          tl = apply_subst(s1, match[1]);
          tl$prime = apply_subst(s2, match_1[1]);
          if (List.length(tl) == List.length(tl$prime)) then do
            return List.for_all2(same_type, tl, tl$prime);
          end else do
            return false;
          end end 
        end else do
          return false;
        end end 
      end
       end 
    end end 
  end end 
end end

function type_expansion(t, ppf, t$prime) do
  if (same_path(t, t$prime)) then do
    return type_expr_1(ppf, t);
  end else do
    t$prime_1 = proxy(t) == proxy(t$prime) and unalias(t$prime) or t$prime;
    return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<2>",
                                  --[[ End_of_format ]]0
                                }),
                              "<2>"
                            }}),
                        --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@ ",
                                    1,
                                    0
                                  }),
                                --[[ Char_literal ]]Block.__(12, {
                                    --[[ "=" ]]61,
                                    --[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Break ]]Block.__(0, {
                                            "@ ",
                                            1,
                                            0
                                          }),
                                        --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Close_box ]]0,
                                                --[[ End_of_format ]]0
                                              })})
                                      })
                                  })
                              })})
                      }),
                    "@[<2>%a@ =@ %a@]"
                  }), type_expr_1, t, type_expr_1, t$prime_1);
  end end 
end end

function type_path_expansion(tp, ppf, tp$prime) do
  if (same(tp, tp$prime)) then do
    return path(ppf, tp);
  end else do
    return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<2>",
                                  --[[ End_of_format ]]0
                                }),
                              "<2>"
                            }}),
                        --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@ ",
                                    1,
                                    0
                                  }),
                                --[[ Char_literal ]]Block.__(12, {
                                    --[[ "=" ]]61,
                                    --[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Break ]]Block.__(0, {
                                            "@ ",
                                            1,
                                            0
                                          }),
                                        --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Close_box ]]0,
                                                --[[ End_of_format ]]0
                                              })})
                                      })
                                  })
                              })})
                      }),
                    "@[<2>%a@ =@ %a@]"
                  }), path, tp, path, tp$prime);
  end end 
end end

function trace(fst, txt, ppf, param) do
  if (param) then do
    match = param[1];
    if (match) then do
      match_1 = match[0];
      t2 = match_1[0];
      match_2 = param[0];
      t1 = match_2[0];
      if (not fst) then do
        Format.fprintf(ppf, --[[ Format ]]{
              --[[ Formatting_lit ]]Block.__(17, {
                  --[[ Break ]]Block.__(0, {
                      "@,",
                      0,
                      0
                    }),
                  --[[ End_of_format ]]0
                }),
              "@,"
            });
      end
       end 
      return Curry._7(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Formatting_gen ]]Block.__(18, {
                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                --[[ End_of_format ]]0,
                                ""
                              }}),
                          --[[ String_literal ]]Block.__(11, {
                              "Type",
                              --[[ Formatting_lit ]]Block.__(17, {
                                  --[[ Break ]]Block.__(0, {
                                      "@;<1 2>",
                                      1,
                                      2
                                    }),
                                  --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ String ]]Block.__(2, {
                                              --[[ No_padding ]]0,
                                              --[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Break ]]Block.__(0, {
                                                      "@;<1 2>",
                                                      1,
                                                      2
                                                    }),
                                                  --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                          --[[ Close_box ]]0,
                                                          --[[ Char_literal ]]Block.__(12, {
                                                              --[[ " " ]]32,
                                                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                            })
                                                        })})
                                                })
                                            })
                                        })})
                                })
                            })
                        }),
                      "@[Type@;<1 2>%a@ %s@;<1 2>%a@] %a"
                    }), (function(param, param_1) do
                    return type_expansion(t1, param, param_1);
                  end end), match_2[1], txt, (function(param, param_1) do
                    return type_expansion(t2, param, param_1);
                  end end), match_1[1], (function(param, param_1) do
                    return trace(false, txt, param, param_1);
                  end end), match[1]);
    end else do
      return --[[ () ]]0;
    end end 
  end else do
    return --[[ () ]]0;
  end end 
end end

function filter_trace(keep_last, param) do
  if (param) then do
    match = param[1];
    if (match) then do
      rem = match[1];
      match_1 = match[0];
      t2$prime = match_1[1];
      t2 = match_1[0];
      match_2 = param[0];
      t1$prime = match_2[1];
      t1 = match_2[0];
      if (not rem and (is_Tvar(t1$prime) or is_Tvar(t2$prime))) then do
        return --[[ [] ]]0;
      end
       end 
      rem$prime = filter_trace(keep_last, rem);
      if (is_constr_row(t1$prime) or is_constr_row(t2$prime) or same_path(t1, t1$prime) and same_path(t2, t2$prime) and not (keep_last and rem$prime == --[[ [] ]]0)) then do
        return rem$prime;
      end else do
        return --[[ :: ]]{
                --[[ tuple ]]{
                  t1,
                  t1$prime
                },
                --[[ :: ]]{
                  --[[ tuple ]]{
                    t2,
                    t2$prime
                  },
                  rem$prime
                }
              };
      end end 
    end else do
      return --[[ [] ]]0;
    end end 
  end else do
    return --[[ [] ]]0;
  end end 
end end

function type_path_list(ppf, param) do
  if (param) then do
    rem = param[1];
    match = param[0];
    tp$prime = match[1];
    tp = match[0];
    if (rem) then do
      return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                              --[[ Break ]]Block.__(0, {
                                  "@;<2 0>",
                                  2,
                                  0
                                }),
                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                            })}),
                      "%a@;<2 0>%a"
                    }), (function(param, param_1) do
                    return type_path_expansion(tp, param, param_1);
                  end end), tp$prime, type_path_list, rem);
    end else do
      return type_path_expansion(tp, ppf, tp$prime);
    end end 
  end else do
    return --[[ () ]]0;
  end end 
end end

function hide_variant_name(t) do
  t_1 = repr(t);
  match = t_1.desc;
  if (typeof match == "number" or match.tag ~= --[[ Tvariant ]]8) then do
    return t;
  end else do
    row = match[0];
    if (row_repr_aux(--[[ [] ]]0, row).row_name ~= undefined) then do
      init = row_repr_aux(--[[ [] ]]0, row);
      level = row_more(row).level;
      return newty2(t_1.level, --[[ Tvariant ]]Block.__(8, {do
                      row_fields: init.row_fields,
                      row_more: newty2(level, --[[ Tvar ]]Block.__(0, {undefined})),
                      row_bound: init.row_bound,
                      row_closed: init.row_closed,
                      row_fixed: init.row_fixed,
                      row_name: undefined
                    end}));
    end else do
      return t;
    end end 
  end end 
end end

function prepare_expansion(param) do
  t = param[0];
  t$prime = hide_variant_name(param[1]);
  mark_loops(t);
  if (not same_path(t, t$prime)) then do
    mark_loops(t$prime);
  end
   end 
  return --[[ tuple ]]{
          t,
          t$prime
        };
end end

function may_prepare_expansion(compact, param) do
  t$prime = param[1];
  t = param[0];
  match = repr(t$prime).desc;
  if (typeof match == "number") then do
    return prepare_expansion(--[[ tuple ]]{
                t,
                t$prime
              });
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 4--[[ Tobject ]]
       or ___conditional___ == 8--[[ Tvariant ]]
       end
      return prepare_expansion(--[[ tuple ]]{
                    t,
                    t$prime
                  });
        
    end
  end end 
  if (compact) then do
    mark_loops(t);
    return --[[ tuple ]]{
            t,
            t
          };
  end else do
    return prepare_expansion(--[[ tuple ]]{
                t,
                t$prime
              });
  end end 
end end

function print_tags(ppf, fields) do
  if (fields) then do
    Curry._1(Format.fprintf(ppf, --[[ Format ]]{
              --[[ Char_literal ]]Block.__(12, {
                  --[[ "`" ]]96,
                  --[[ String ]]Block.__(2, {
                      --[[ No_padding ]]0,
                      --[[ End_of_format ]]0
                    })
                }),
              "`%s"
            }), fields[0][0]);
    return List.iter((function(param) do
                  return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                  --[[ Char_literal ]]Block.__(12, {
                                      --[[ "," ]]44,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ Char_literal ]]Block.__(12, {
                                              --[[ "`" ]]96,
                                              --[[ String ]]Block.__(2, {
                                                  --[[ No_padding ]]0,
                                                  --[[ End_of_format ]]0
                                                })
                                            })
                                        })
                                    }),
                                  ",@ `%s"
                                }), param[0]);
                end end), fields[1]);
  end else do
    return --[[ () ]]0;
  end end 
end end

function has_explanation(unif, t3, t4) do
  match = t3.desc;
  match_1 = t4.desc;
  exit = 0;
  exit_1 = 0;
  if (typeof match == "number") then do
    if (typeof match_1 == "number") then do
      exit = 2;
    end else do
      local ___conditional___=(match_1.tag | 0);
      do
         if ___conditional___ == 0--[[ Tvar ]] then do
            exit_1 = 3; end else 
         if ___conditional___ == 3--[[ Tconstr ]] then do
            return true; end end end end 
        exit = 2;
          
      end
    end end 
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 0--[[ Tvar ]] then do
          return true; end end 
       if ___conditional___ == 3--[[ Tconstr ]] then do
          if (typeof match_1 == "number") then do
            return true;
          end else if (match_1.tag) then do
            exit = 2;
          end else do
            exit_1 = 3;
          end end  end  end else 
       if ___conditional___ == 5--[[ Tfield ]] then do
          match_2 = match[3].desc;
          exit_2 = 0;
          if (typeof match_2 == "number" and typeof match_1 ~= "number") then do
            local ___conditional___=(match_1.tag | 0);
            do
               if ___conditional___ == 0--[[ Tvar ]] then do
                  exit_1 = 3; end else 
               if ___conditional___ == 3--[[ Tconstr ]] then do
                  exit_2 = 4; end else 
               if ___conditional___ == 5--[[ Tfield ]] then do
                  match_3 = match_1[3].desc;
                  if (typeof match_3 == "number") then do
                    return match[0] == match_1[0];
                  end else do
                    return false;
                  end end  end end end end end end 
              return false;
                
            end
          end else do
            exit_2 = 4;
          end end 
          if (exit_2 == 4) then do
            if (typeof match_1 == "number") then do
              return true;
            end else do
              local ___conditional___=(match_1.tag | 0);
              do
                 if ___conditional___ == 0--[[ Tvar ]] then do
                    exit_1 = 3; end else 
                 if ___conditional___ == 3--[[ Tconstr ]] then do
                    return true; end end end end 
                return false;
                  
              end
            end end 
          end
           end  end else 
       if ___conditional___ == 8--[[ Tvariant ]] then do
          if (typeof match_1 == "number") then do
            return false;
          end else do
            local ___conditional___=(match_1.tag | 0);
            do
               if ___conditional___ == 0--[[ Tvar ]] then do
                  exit_1 = 3; end else 
               if ___conditional___ == 8--[[ Tvariant ]] then do
                  return true; end end end end 
              return false;
                
            end
          end end  end else 
       end end end end end end
      exit_1 = 3;
        
    end
  end end 
  if (exit_1 == 3) then do
    if (typeof match_1 == "number" or match_1.tag) then do
      exit = 2;
    end else do
      return true;
    end end 
  end
   end 
  if (exit == 2 and typeof match ~= "number" and match.tag ~= --[[ Tconstr ]]3) then do
    return false;
  end
   end 
  if (typeof match_1 == "number" or match_1.tag ~= --[[ Tfield ]]5) then do
    return false;
  end else do
    return true;
  end end 
end end

function mismatch(unif, param) do
  if (param) then do
    match = param[1];
    if (match) then do
      t$prime = match[0][1];
      t = param[0][1];
      m = mismatch(unif, match[1]);
      if (m ~= undefined) then do
        return m;
      end else if (has_explanation(unif, t, t$prime)) then do
        return --[[ tuple ]]{
                t,
                t$prime
              };
      end else do
        return ;
      end end  end 
    end else do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "printtyp.ml",
          1339,
          9
        }
      })
    end end 
  end
   end 
end end

function explanation(unif, mis, ppf) do
  if (mis ~= undefined) then do
    match = mis;
    unif_1 = unif;
    t3 = match[0];
    t4 = match[1];
    ppf_1 = ppf;
    match_1 = t3.desc;
    match_2 = t4.desc;
    exit = 0;
    exit_1 = 0;
    lab;
    exit_2 = 0;
    exit_3 = 0;
    exit_4 = 0;
    if (typeof match_1 == "number") then do
      if (typeof match_2 == "number") then do
        exit = 2;
      end else do
        local ___conditional___=(match_2.tag | 0);
        do
           if ___conditional___ == 0--[[ Tvar ]] then do
              exit_4 = 9; end else 
           if ___conditional___ == 3--[[ Tconstr ]] then do
              exit = 1; end else 
           if ___conditional___ == 5--[[ Tfield ]] then do
              exit_2 = 7; end else 
           end end end end end end
          exit = 2;
            
        end
      end end 
    end else do
      local ___conditional___=(match_1.tag | 0);
      do
         if ___conditional___ == 0--[[ Tvar ]] then do
            if (typeof match_2 == "number") then do
              exit_1 = 5;
            end else do
              local ___conditional___=(match_2.tag | 0);
              do
                 if ___conditional___ == 2--[[ Ttuple ]] then do
                    exit_1 = match_2[0] and 5 or 3; end else 
                 if ___conditional___ == 3--[[ Tconstr ]] then do
                    p = match_2[0];
                    if (unif_1 and t3.level < binding_time(p)) then do
                      return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@,",
                                              0,
                                              0
                                            }),
                                          --[[ Formatting_gen ]]Block.__(18, {
                                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                    --[[ End_of_format ]]0,
                                                    ""
                                                  }}),
                                              --[[ String_literal ]]Block.__(11, {
                                                  "The type constructor",
                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Break ]]Block.__(0, {
                                                          "@;<1 2>",
                                                          1,
                                                          2
                                                        }),
                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Break ]]Block.__(0, {
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                }),
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "would escape its scope",
                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Close_box ]]0,
                                                                      --[[ End_of_format ]]0
                                                                    })
                                                                })
                                                            })})
                                                    })
                                                })
                                            })
                                        }),
                                      "@,@[The type constructor@;<1 2>%a@ would escape its scope@]"
                                    }), path, p);
                    end else do
                      exit_1 = 5;
                    end end  end else 
                 if ___conditional___ == 9--[[ Tunivar ]] then do
                    exit_1 = 4; end else 
                 end end end end end end
                exit_1 = 5;
                  
              end
            end end  end else 
         if ___conditional___ == 2--[[ Ttuple ]] then do
            if (match_1[0]) then do
              exit_4 = 9;
            end else if (typeof match_2 == "number") then do
              exit = 2;
            end else do
              local ___conditional___=(match_2.tag | 0);
              do
                 if ___conditional___ == 0--[[ Tvar ]] then do
                    exit_1 = 3; end else 
                 if ___conditional___ == 5--[[ Tfield ]] then do
                    exit_2 = 7; end else 
                 end end end end
                exit = 2;
                  
              end
            end end  end  end else 
         if ___conditional___ == 3--[[ Tconstr ]] then do
            p_1 = match_1[0];
            if (typeof match_2 == "number") then do
              exit = 1;
            end else do
              local ___conditional___=(match_2.tag | 0);
              do
                 if ___conditional___ == 0--[[ Tvar ]] then do
                    if (unif_1 and t4.level < binding_time(p_1)) then do
                      return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@,",
                                              0,
                                              0
                                            }),
                                          --[[ Formatting_gen ]]Block.__(18, {
                                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                    --[[ End_of_format ]]0,
                                                    ""
                                                  }}),
                                              --[[ String_literal ]]Block.__(11, {
                                                  "The type constructor",
                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Break ]]Block.__(0, {
                                                          "@;<1 2>",
                                                          1,
                                                          2
                                                        }),
                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Break ]]Block.__(0, {
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                }),
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "would escape its scope",
                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Close_box ]]0,
                                                                      --[[ End_of_format ]]0
                                                                    })
                                                                })
                                                            })})
                                                    })
                                                })
                                            })
                                        }),
                                      "@,@[The type constructor@;<1 2>%a@ would escape its scope@]"
                                    }), path, p_1);
                    end else do
                      exit_4 = 9;
                    end end  end else 
                 if ___conditional___ == 5--[[ Tfield ]] then do
                    exit_2 = 7; end else 
                 end end end end
                exit = 2;
                  
              end
            end end  end else 
         if ___conditional___ == 8--[[ Tvariant ]] then do
            if (typeof match_2 == "number") then do
              exit = 2;
            end else do
              local ___conditional___=(match_2.tag | 0);
              do
                 if ___conditional___ == 0--[[ Tvar ]] then do
                    exit_4 = 9; end else 
                 if ___conditional___ == 5--[[ Tfield ]] then do
                    exit_2 = 7; end else 
                 if ___conditional___ == 8--[[ Tvariant ]] then do
                    row1 = row_repr_aux(--[[ [] ]]0, match_1[0]);
                    row2 = row_repr_aux(--[[ [] ]]0, match_2[0]);
                    match_3 = row1.row_fields;
                    match_4 = row1.row_closed;
                    match_5 = row2.row_fields;
                    match_6 = row2.row_closed;
                    if (match_3) then do
                      if (not match_3[1] and match_4 and match_5) then do
                        if (match_5[1] or not match_6) then do
                          return --[[ () ]]0;
                        end else do
                          l1 = match_3[0][0];
                          if (l1 == match_5[0][0]) then do
                            return Curry._1(Format.fprintf(ppf_1, --[[ Format ]]{
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Break ]]Block.__(0, {
                                                    "@,",
                                                    0,
                                                    0
                                                  }),
                                                --[[ String_literal ]]Block.__(11, {
                                                    "Types for tag `",
                                                    --[[ String ]]Block.__(2, {
                                                        --[[ No_padding ]]0,
                                                        --[[ String_literal ]]Block.__(11, {
                                                            " are incompatible",
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })
                                                  })
                                              }),
                                            "@,Types for tag `%s are incompatible"
                                          }), l1);
                          end else do
                            return --[[ () ]]0;
                          end end 
                        end end 
                      end
                       end 
                    end else if (match_4) then do
                      exit_5 = 0;
                      if (match_5 or not match_6) then do
                        exit_5 = 11;
                      end else do
                        return Format.fprintf(ppf_1, --[[ Format ]]{
                                    --[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Break ]]Block.__(0, {
                                            "@,",
                                            0,
                                            0
                                          }),
                                        --[[ String_literal ]]Block.__(11, {
                                            "These two variant types have no intersection",
                                            --[[ End_of_format ]]0
                                          })
                                      }),
                                    "@,These two variant types have no intersection"
                                  });
                      end end 
                      if (exit_5 == 11) then do
                        return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@,",
                                                0,
                                                0
                                              }),
                                            --[[ Formatting_gen ]]Block.__(18, {
                                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                      --[[ End_of_format ]]0,
                                                      ""
                                                    }}),
                                                --[[ String_literal ]]Block.__(11, {
                                                    "The first variant type does not allow tag(s)",
                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                        --[[ Break ]]Block.__(0, {
                                                            "@ ",
                                                            1,
                                                            0
                                                          }),
                                                        --[[ Formatting_gen ]]Block.__(18, {
                                                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "<hov>",
                                                                      --[[ End_of_format ]]0
                                                                    }),
                                                                  "<hov>"
                                                                }}),
                                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                    --[[ Close_box ]]0,
                                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                                        --[[ Close_box ]]0,
                                                                        --[[ End_of_format ]]0
                                                                      })
                                                                  })})
                                                          })
                                                      })
                                                  })
                                              })
                                          }),
                                        "@,@[The first variant type does not allow tag(s)@ @[<hov>%a@]@]"
                                      }), print_tags, match_5);
                      end
                       end 
                    end
                     end  end 
                    if (match_5 or not match_6) then do
                      return --[[ () ]]0;
                    end else do
                      return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@,",
                                              0,
                                              0
                                            }),
                                          --[[ Formatting_gen ]]Block.__(18, {
                                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                    --[[ End_of_format ]]0,
                                                    ""
                                                  }}),
                                              --[[ String_literal ]]Block.__(11, {
                                                  "The second variant type does not allow tag(s)",
                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Break ]]Block.__(0, {
                                                          "@ ",
                                                          1,
                                                          0
                                                        }),
                                                      --[[ Formatting_gen ]]Block.__(18, {
                                                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "<hov>",
                                                                    --[[ End_of_format ]]0
                                                                  }),
                                                                "<hov>"
                                                              }}),
                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                  --[[ Close_box ]]0,
                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Close_box ]]0,
                                                                      --[[ End_of_format ]]0
                                                                    })
                                                                })})
                                                        })
                                                    })
                                                })
                                            })
                                        }),
                                      "@,@[The second variant type does not allow tag(s)@ @[<hov>%a@]@]"
                                    }), print_tags, match_3);
                    end end  end end end end end end 
                exit = 2;
                  
              end
            end end  end else 
         if ___conditional___ == 9--[[ Tunivar ]] then do
            if (typeof match_2 == "number") then do
              exit = 2;
            end else do
              local ___conditional___=(match_2.tag | 0);
              do
                 if ___conditional___ == 0--[[ Tvar ]] then do
                    exit_1 = 4; end else 
                 if ___conditional___ == 5--[[ Tfield ]] then do
                    exit_2 = 7; end else 
                 end end end end
                exit = 2;
                  
              end
            end end  end else 
         end end end end end end end end end end
        exit_4 = 9;
          
      end
    end end 
    if (exit_4 == 9) then do
      if (typeof match_2 == "number" or match_2.tag) then do
        exit_3 = 8;
      end else do
        exit_1 = 5;
      end end 
    end
     end 
    if (exit_3 == 8) then do
      if (typeof match_1 == "number" or match_1.tag ~= --[[ Tfield ]]5) then do
        exit_2 = 7;
      end else do
        lab = match_1[0];
        exit_1 = 6;
      end end 
    end
     end 
    if (exit_2 == 7) then do
      if (typeof match_2 == "number" or match_2.tag ~= --[[ Tfield ]]5) then do
        exit = 2;
      end else do
        lab = match_2[0];
        exit_1 = 6;
      end end 
    end
     end 
    local ___conditional___=(exit_1);
    do
       if ___conditional___ == 3 then do
          return Format.fprintf(ppf_1, --[[ Format ]]{
                      --[[ Formatting_lit ]]Block.__(17, {
                          --[[ Break ]]Block.__(0, {
                              "@,",
                              0,
                              0
                            }),
                          --[[ String_literal ]]Block.__(11, {
                              "Self type cannot escape its class",
                              --[[ End_of_format ]]0
                            })
                        }),
                      "@,Self type cannot escape its class"
                    }); end end 
       if ___conditional___ == 4 then do
          return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                          --[[ Formatting_lit ]]Block.__(17, {
                              --[[ Break ]]Block.__(0, {
                                  "@,",
                                  0,
                                  0
                                }),
                              --[[ String_literal ]]Block.__(11, {
                                  "The universal variable ",
                                  --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                          " would escape its scope",
                                          --[[ End_of_format ]]0
                                        })})
                                })
                            }),
                          "@,The universal variable %a would escape its scope"
                        }), type_expr_1, is_Tunivar(t3) and t3 or t4); end end 
       if ___conditional___ == 5 then do
          match_7 = is_Tvar(t3) and --[[ tuple ]]{
              t3,
              t4
            } or --[[ tuple ]]{
              t4,
              t3
            };
          t$prime = match_7[1];
          t = match_7[0];
          if (occur_in(empty, t, t$prime)) then do
            return Curry._4(Format.fprintf(ppf_1, --[[ Format ]]{
                            --[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@,",
                                    0,
                                    0
                                  }),
                                --[[ Formatting_gen ]]Block.__(18, {
                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "<hov>",
                                              --[[ End_of_format ]]0
                                            }),
                                          "<hov>"
                                        }}),
                                    --[[ String_literal ]]Block.__(11, {
                                        "The type variable ",
                                        --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                                " occurs inside",
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Close_box ]]0,
                                                            --[[ End_of_format ]]0
                                                          })})
                                                  })
                                              })})
                                      })
                                  })
                              }),
                            "@,@[<hov>The type variable %a occurs inside@ %a@]"
                          }), type_expr_1, t, type_expr_1, t$prime);
          end else do
            return Curry._3(Format.fprintf(ppf_1, --[[ Format ]]{
                            --[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@,",
                                    0,
                                    0
                                  }),
                                --[[ Formatting_gen ]]Block.__(18, {
                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "<hov>",
                                              --[[ End_of_format ]]0
                                            }),
                                          "<hov>"
                                        }}),
                                    --[[ String_literal ]]Block.__(11, {
                                        "This instance of ",
                                        --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                                " is ambiguous:",
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ String ]]Block.__(2, {
                                                        --[[ No_padding ]]0,
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Close_box ]]0,
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })
                                                  })
                                              })})
                                      })
                                  })
                              }),
                            "@,@[<hov>This instance of %a is ambiguous:@ %s@]"
                          }), type_expr_1, t$prime, "it would escape the scope of its equation");
          end end  end end 
       if ___conditional___ == 6 then do
          if (lab == dummy_method) then do
            return Format.fprintf(ppf_1, --[[ Format ]]{
                        --[[ Formatting_lit ]]Block.__(17, {
                            --[[ Break ]]Block.__(0, {
                                "@,",
                                0,
                                0
                              }),
                            --[[ String_literal ]]Block.__(11, {
                                "Self type cannot be unified with a closed object type",
                                --[[ End_of_format ]]0
                              })
                          }),
                        "@,Self type cannot be unified with a closed object type"
                      });
          end else do
            exit = 2;
          end end  end else 
       end end
      
    end
    local ___conditional___=(exit);
    do
       if ___conditional___ == 1 then do
          return Curry._1(Format.fprintf(ppf_1, --[[ Format ]]{
                          --[[ Formatting_lit ]]Block.__(17, {
                              --[[ Break ]]Block.__(0, {
                                  "@,",
                                  0,
                                  0
                                }),
                              --[[ Formatting_gen ]]Block.__(18, {
                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                        --[[ End_of_format ]]0,
                                        ""
                                      }}),
                                  --[[ String_literal ]]Block.__(11, {
                                      "The ",
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ String_literal ]]Block.__(11, {
                                              " object type has an abstract row, it cannot be closed",
                                              --[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Close_box ]]0,
                                                  --[[ End_of_format ]]0
                                                })
                                            })
                                        })
                                    })
                                })
                            }),
                          "@,@[The %s object type has an abstract row, it cannot be closed@]"
                        }), t4.desc == --[[ Tnil ]]0 and "first" or "second"); end end 
       if ___conditional___ == 2 then do
          if (typeof match_1 ~= "number") then do
            local ___conditional___=(match_1.tag | 0);
            do
               if ___conditional___ == 3--[[ Tconstr ]]
               or ___conditional___ == 5--[[ Tfield ]] then do
                  l = match_1[0];
                  match_8 = match_1[3].desc;
                  exit_6 = 0;
                  if (typeof match_8 == "number" and typeof match_2 ~= "number") then do
                    local ___conditional___=(match_2.tag | 0);
                    do
                       if ___conditional___ == 3--[[ Tconstr ]] then do
                          exit_6 = 4; end else 
                       if ___conditional___ == 5--[[ Tfield ]] then do
                          match_9 = match_2[3].desc;
                          if (typeof match_9 == "number" and l == match_2[0]) then do
                            return Curry._1(Format.fprintf(ppf_1, --[[ Format ]]{
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Break ]]Block.__(0, {
                                                    "@,",
                                                    0,
                                                    0
                                                  }),
                                                --[[ String_literal ]]Block.__(11, {
                                                    "Types for method ",
                                                    --[[ String ]]Block.__(2, {
                                                        --[[ No_padding ]]0,
                                                        --[[ String_literal ]]Block.__(11, {
                                                            " are incompatible",
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })
                                                  })
                                              }),
                                            "@,Types for method %s are incompatible"
                                          }), l);
                          end else do
                            return --[[ () ]]0;
                          end end  end end end end 
                      return --[[ () ]]0;
                        
                    end
                  end else do
                    exit_6 = 4;
                  end end 
                  if (exit_6 == 4) then do
                    exit_7 = 0;
                    if (typeof match_2 == "number" or match_2.tag == --[[ Tconstr ]]3) then do
                      exit_7 = 5;
                    end else do
                      return --[[ () ]]0;
                    end end 
                    if (exit_7 == 5) then do
                      return Curry._1(Format.fprintf(ppf_1, --[[ Format ]]{
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@,",
                                              0,
                                              0
                                            }),
                                          --[[ Formatting_gen ]]Block.__(18, {
                                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                    --[[ End_of_format ]]0,
                                                    ""
                                                  }}),
                                              --[[ String_literal ]]Block.__(11, {
                                                  "The second object type has no method ",
                                                  --[[ String ]]Block.__(2, {
                                                      --[[ No_padding ]]0,
                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                          --[[ Close_box ]]0,
                                                          --[[ End_of_format ]]0
                                                        })
                                                    })
                                                })
                                            })
                                        }),
                                      "@,@[The second object type has no method %s@]"
                                    }), l);
                    end
                     end 
                  end
                   end  end else 
               end end
              return --[[ () ]]0;
                
            end
          end
           end 
          if (typeof match_2 == "number" or match_2.tag ~= --[[ Tfield ]]5) then do
            return --[[ () ]]0;
          end else do
            return Curry._1(Format.fprintf(ppf_1, --[[ Format ]]{
                            --[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@,",
                                    0,
                                    0
                                  }),
                                --[[ Formatting_gen ]]Block.__(18, {
                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                          --[[ End_of_format ]]0,
                                          ""
                                        }}),
                                    --[[ String_literal ]]Block.__(11, {
                                        "The first object type has no method ",
                                        --[[ String ]]Block.__(2, {
                                            --[[ No_padding ]]0,
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Close_box ]]0,
                                                --[[ End_of_format ]]0
                                              })
                                          })
                                      })
                                  })
                              }),
                            "@,@[The first object type has no method %s@]"
                          }), match_2[0]);
          end end  end else 
       end end
      
    end
  end else do
    return --[[ () ]]0;
  end end 
end end

function path_same_name(_p1, _p2) do
  while(true) do
    p2 = _p2;
    p1 = _p1;
    local ___conditional___=(p1.tag | 0);
    do
       if ___conditional___ == 0--[[ Pident ]] then do
          local ___conditional___=(p2.tag | 0);
          do
             if ___conditional___ == 0--[[ Pident ]] then do
                id1 = p1[0];
                id2 = p2[0];
                if (equal(id1, id2) and not Caml_obj.caml_equal(id1, id2)) then do
                  add_unique(id1);
                  return add_unique(id2);
                end else do
                  return 0;
                end end  end end 
             if ___conditional___ == 1--[[ Pdot ]]
             or ___conditional___ == 2--[[ Papply ]] then do
                return --[[ () ]]0; end end 
            
          end end end 
       if ___conditional___ == 1--[[ Pdot ]] then do
          local ___conditional___=(p2.tag | 0);
          do
             if ___conditional___ == 1--[[ Pdot ]] then do
                if (p1[1] == p2[1]) then do
                  _p2 = p2[0];
                  _p1 = p1[0];
                  ::continue:: ;
                end else do
                  return --[[ () ]]0;
                end end  end end 
             if ___conditional___ == 0--[[ Pident ]]
             or ___conditional___ == 2--[[ Papply ]] then do
                return --[[ () ]]0; end end 
            
          end end end 
       if ___conditional___ == 2--[[ Papply ]] then do
          local ___conditional___=(p2.tag | 0);
          do
             if ___conditional___ == 0--[[ Pident ]]
             or ___conditional___ == 1--[[ Pdot ]] then do
                return --[[ () ]]0; end end 
             if ___conditional___ == 2--[[ Papply ]] then do
                path_same_name(p1[0], p2[0]);
                _p2 = p2[1];
                _p1 = p1[1];
                ::continue:: ; end end 
            
          end end end 
      
    end
  end;
end end

function type_same_name(t1, t2) do
  match = repr(t1).desc;
  match_1 = repr(t2).desc;
  if (typeof match == "number" or not (match.tag == --[[ Tconstr ]]3 and not (typeof match_1 == "number" or match_1.tag ~= --[[ Tconstr ]]3))) then do
    return --[[ () ]]0;
  end else do
    return path_same_name(best_type_path(match[0])[0], best_type_path(match_1[0])[0]);
  end end 
end end

function trace_same_names(_param) do
  while(true) do
    param = _param;
    if (param) then do
      match = param[1];
      if (match) then do
        match_1 = match[0];
        match_2 = param[0];
        type_same_name(match_2[0], match_1[0]);
        type_same_name(match_2[1], match_1[1]);
        _param = match[1];
        ::continue:: ;
      end else do
        return --[[ () ]]0;
      end end 
    end else do
      return --[[ () ]]0;
    end end 
  end;
end end

function report_unification_error(ppf, env, unifOpt, tr, txt1, txt2) do
  unif = unifOpt ~= undefined and unifOpt or true;
  return wrap_printing_env(env, (function(param) do
                unif_1 = unif;
                tr_1 = tr;
                txt1_1 = txt1;
                ppf_1 = ppf;
                txt2_1 = txt2;
                reset(--[[ () ]]0);
                trace_same_names(tr_1);
                tr_2 = List.map((function(param) do
                        return --[[ tuple ]]{
                                param[0],
                                hide_variant_name(param[1])
                              };
                      end end), tr_1);
                mis = mismatch(unif_1, tr_2);
                if (tr_2) then do
                  match = tr_2[1];
                  if (match) then do
                    xpcall(function() do
                      tr_3 = filter_trace(mis == undefined, match[1]);
                      match_1 = may_prepare_expansion(tr_3 == --[[ [] ]]0, tr_2[0]);
                      t1 = match_1[0];
                      match_2 = may_prepare_expansion(tr_3 == --[[ [] ]]0, match[0]);
                      t2 = match_2[0];
                      print_labels.contents = not classic.contents;
                      tr_4 = List.map(prepare_expansion, tr_3);
                      Curry.app(Format.fprintf(ppf_1, --[[ Format ]]{
                                --[[ Formatting_gen ]]Block.__(18, {
                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "<v>",
                                              --[[ End_of_format ]]0
                                            }),
                                          "<v>"
                                        }}),
                                    --[[ Formatting_gen ]]Block.__(18, {
                                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                              --[[ End_of_format ]]0,
                                              ""
                                            }}),
                                        --[[ Theta ]]Block.__(16, {--[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Break ]]Block.__(0, {
                                                    "@;<1 2>",
                                                    1,
                                                    2
                                                  }),
                                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                        --[[ Break ]]Block.__(0, {
                                                            "@ ",
                                                            1,
                                                            0
                                                          }),
                                                        --[[ Theta ]]Block.__(16, {--[[ Formatting_lit ]]Block.__(17, {
                                                                --[[ Break ]]Block.__(0, {
                                                                    "@;<1 2>",
                                                                    1,
                                                                    2
                                                                  }),
                                                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                        --[[ Close_box ]]0,
                                                                        --[[ Alpha ]]Block.__(15, {--[[ Theta ]]Block.__(16, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                    --[[ Close_box ]]0,
                                                                                    --[[ End_of_format ]]0
                                                                                  })})})
                                                                      })})
                                                              })})
                                                      })})
                                              })})
                                      })
                                  }),
                                "@[<v>@[%t@;<1 2>%a@ %t@;<1 2>%a@]%a%t@]"
                              }), {
                            txt1_1,
                            (function(param, param_1) do
                                return type_expansion(t1, param, param_1);
                              end end),
                            match_1[1],
                            txt2_1,
                            (function(param, param_1) do
                                return type_expansion(t2, param, param_1);
                              end end),
                            match_2[1],
                            (function(param, param_1) do
                                return trace(false, "is not compatible with type", param, param_1);
                              end end),
                            tr_4,
                            (function(param) do
                                return explanation(unif_1, mis, param);
                              end end)
                          });
                      print_labels.contents = true;
                      return --[[ () ]]0;
                    end end,function(exn) do
                      print_labels.contents = true;
                      error(exn)
                    end end)
                  end else do
                    error({
                      Caml_builtin_exceptions.assert_failure,
                      --[[ tuple ]]{
                        "printtyp.ml",
                        1438,
                        20
                      }
                    })
                  end end 
                end else do
                  error({
                    Caml_builtin_exceptions.assert_failure,
                    --[[ tuple ]]{
                      "printtyp.ml",
                      1438,
                      20
                    }
                  })
                end end 
              end end));
end end

function trace_1(fst, keep_last, txt, ppf, tr) do
  print_labels.contents = not classic.contents;
  trace_same_names(tr);
  xpcall(function() do
    if (tr) then do
      match = tr[1];
      if (match) then do
        if (fst) then do
          trace(fst, txt, ppf, --[[ :: ]]{
                tr[0],
                --[[ :: ]]{
                  match[0],
                  filter_trace(keep_last, match[1])
                }
              });
        end else do
          trace(fst, txt, ppf, filter_trace(keep_last, tr));
        end end 
        print_labels.contents = true;
        return --[[ () ]]0;
      end else do
        return --[[ () ]]0;
      end end 
    end else do
      return --[[ () ]]0;
    end end 
  end end,function(exn) do
    print_labels.contents = true;
    error(exn)
  end end)
end end

function class_types(env, cty1, cty2) do
  return match_class_types(undefined, env, cty1, cty2);
end end

function class_type_declarations(env, cty1, cty2) do
  return match_class_declarations(env, cty1.clty_params, cty1.clty_type, cty2.clty_params, cty2.clty_type);
end end

function class_declarations(env, cty1, cty2) do
  match = cty1.cty_new;
  match_1 = cty2.cty_new;
  if (match == undefined and match_1 ~= undefined) then do
    return --[[ :: ]]{
            --[[ CM_Virtual_class ]]0,
            --[[ [] ]]0
          };
  end
   end 
  return match_class_declarations(env, cty1.cty_params, cty1.cty_type, cty2.cty_params, cty2.cty_type);
end end

function include_err(ppf, param) do
  if (typeof param == "number") then do
    return Format.fprintf(ppf, --[[ Format ]]{
                --[[ String_literal ]]Block.__(11, {
                    "A class cannot be changed from virtual to concrete",
                    --[[ End_of_format ]]0
                  }),
                "A class cannot be changed from virtual to concrete"
              });
  end else do
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ == 0--[[ CM_Parameter_arity_mismatch ]] then do
          return Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "The classes do not have the same number of type parameters",
                          --[[ End_of_format ]]0
                        }),
                      "The classes do not have the same number of type parameters"
                    }); end end 
       if ___conditional___ == 1--[[ CM_Type_parameter_mismatch ]] then do
          return report_unification_error(ppf, param[0], false, param[1], (function(ppf) do
                        return Format.fprintf(ppf, --[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "A type parameter has type",
                                        --[[ End_of_format ]]0
                                      }),
                                    "A type parameter has type"
                                  });
                      end end), (function(ppf) do
                        return Format.fprintf(ppf, --[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "but is expected to have type",
                                        --[[ End_of_format ]]0
                                      }),
                                    "but is expected to have type"
                                  });
                      end end)); end end 
       if ___conditional___ == 2--[[ CM_Class_type_mismatch ]] then do
          cty2 = param[2];
          cty1 = param[1];
          return wrap_printing_env(param[0], (function(param) do
                        return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                                        --[[ Formatting_gen ]]Block.__(18, {
                                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                  --[[ End_of_format ]]0,
                                                  ""
                                                }}),
                                            --[[ String_literal ]]Block.__(11, {
                                                "The class type",
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@;<1 2>",
                                                        1,
                                                        2
                                                      }),
                                                    --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Break ]]Block.__(0, {
                                                                "@ ",
                                                                1,
                                                                0
                                                              }),
                                                            --[[ String ]]Block.__(2, {
                                                                --[[ No_padding ]]0,
                                                                --[[ Formatting_lit ]]Block.__(17, {
                                                                    --[[ Break ]]Block.__(0, {
                                                                        "@;<1 2>",
                                                                        1,
                                                                        2
                                                                      }),
                                                                    --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                            --[[ Close_box ]]0,
                                                                            --[[ End_of_format ]]0
                                                                          })})
                                                                  })
                                                              })
                                                          })})
                                                  })
                                              })
                                          }),
                                        "@[The class type@;<1 2>%a@ %s@;<1 2>%a@]"
                                      }), class_type_2, cty1, "is not matched by the class type", class_type_2, cty2);
                      end end)); end end 
       if ___conditional___ == 3--[[ CM_Parameter_mismatch ]] then do
          return report_unification_error(ppf, param[0], false, param[1], (function(ppf) do
                        return Format.fprintf(ppf, --[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "A parameter has type",
                                        --[[ End_of_format ]]0
                                      }),
                                    "A parameter has type"
                                  });
                      end end), (function(ppf) do
                        return Format.fprintf(ppf, --[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "but is expected to have type",
                                        --[[ End_of_format ]]0
                                      }),
                                    "but is expected to have type"
                                  });
                      end end)); end end 
       if ___conditional___ == 4--[[ CM_Val_type_mismatch ]] then do
          lab = param[0];
          return report_unification_error(ppf, param[1], false, param[2], (function(ppf) do
                        return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                        --[[ String_literal ]]Block.__(11, {
                                            "The instance variable ",
                                            --[[ String ]]Block.__(2, {
                                                --[[ No_padding ]]0,
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "has type",
                                                        --[[ End_of_format ]]0
                                                      })
                                                  })
                                              })
                                          }),
                                        "The instance variable %s@ has type"
                                      }), lab);
                      end end), (function(ppf) do
                        return Format.fprintf(ppf, --[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "but is expected to have type",
                                        --[[ End_of_format ]]0
                                      }),
                                    "but is expected to have type"
                                  });
                      end end)); end end 
       if ___conditional___ == 5--[[ CM_Meth_type_mismatch ]] then do
          lab_1 = param[0];
          return report_unification_error(ppf, param[1], false, param[2], (function(ppf) do
                        return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                        --[[ String_literal ]]Block.__(11, {
                                            "The method ",
                                            --[[ String ]]Block.__(2, {
                                                --[[ No_padding ]]0,
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "has type",
                                                        --[[ End_of_format ]]0
                                                      })
                                                  })
                                              })
                                          }),
                                        "The method %s@ has type"
                                      }), lab_1);
                      end end), (function(ppf) do
                        return Format.fprintf(ppf, --[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "but is expected to have type",
                                        --[[ End_of_format ]]0
                                      }),
                                    "but is expected to have type"
                                  });
                      end end)); end end 
       if ___conditional___ == 6--[[ CM_Non_mutable_value ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "The non-mutable instance variable ",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ String_literal ]]Block.__(11, {
                                          " cannot become mutable",
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Close_box ]]0,
                                              --[[ End_of_format ]]0
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[The non-mutable instance variable %s cannot become mutable@]"
                        }), param[0]); end end 
       if ___conditional___ == 7--[[ CM_Non_concrete_value ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "The virtual instance variable ",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ String_literal ]]Block.__(11, {
                                          " cannot become concrete",
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Close_box ]]0,
                                              --[[ End_of_format ]]0
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[The virtual instance variable %s cannot become concrete@]"
                        }), param[0]); end end 
       if ___conditional___ == 8--[[ CM_Missing_value ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "The first class type has no instance variable ",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Close_box ]]0,
                                          --[[ End_of_format ]]0
                                        })
                                    })
                                })
                            }),
                          "@[The first class type has no instance variable %s@]"
                        }), param[0]); end end 
       if ___conditional___ == 9--[[ CM_Missing_method ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "The first class type has no method ",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Close_box ]]0,
                                          --[[ End_of_format ]]0
                                        })
                                    })
                                })
                            }),
                          "@[The first class type has no method %s@]"
                        }), param[0]); end end 
       if ___conditional___ == 10--[[ CM_Hide_public ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "The public method ",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ String_literal ]]Block.__(11, {
                                          " cannot be hidden",
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Close_box ]]0,
                                              --[[ End_of_format ]]0
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[The public method %s cannot be hidden@]"
                        }), param[0]); end end 
       if ___conditional___ == 11--[[ CM_Hide_virtual ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "The virtual ",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Char_literal ]]Block.__(12, {
                                          --[[ " " ]]32,
                                          --[[ String ]]Block.__(2, {
                                              --[[ No_padding ]]0,
                                              --[[ String_literal ]]Block.__(11, {
                                                  " cannot be hidden",
                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Close_box ]]0,
                                                      --[[ End_of_format ]]0
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[The virtual %s %s cannot be hidden@]"
                        }), param[0], param[1]); end end 
       if ___conditional___ == 12--[[ CM_Public_method ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "The public method ",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ String_literal ]]Block.__(11, {
                                          " cannot become private",
                                          --[[ End_of_format ]]0
                                        })
                                    })
                                })
                            }),
                          "@[The public method %s cannot become private"
                        }), param[0]); end end 
       if ___conditional___ == 13--[[ CM_Private_method ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "The private method ",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ String_literal ]]Block.__(11, {
                                      " cannot become public",
                                      --[[ End_of_format ]]0
                                    })
                                })
                            }),
                          "The private method %s cannot become public"
                        }), param[0]); end end 
       if ___conditional___ == 14--[[ CM_Virtual_method ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "The virtual method ",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ String_literal ]]Block.__(11, {
                                          " cannot become concrete",
                                          --[[ End_of_format ]]0
                                        })
                                    })
                                })
                            }),
                          "@[The virtual method %s cannot become concrete"
                        }), param[0]); end end 
      
    end
  end end 
end end

function report_error_3(ppf, param) do
  if (param) then do
    print_errs = function(ppf, errs) do
      return List.iter((function(err) do
                    return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                    --[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Break ]]Block.__(0, {
                                            "@ ",
                                            1,
                                            0
                                          }),
                                        --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                      }),
                                    "@ %a"
                                  }), include_err, err);
                  end end), errs);
    end end;
    return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<v>",
                                  --[[ End_of_format ]]0
                                }),
                              "<v>"
                            }}),
                        --[[ Alpha ]]Block.__(15, {--[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                    --[[ Close_box ]]0,
                                    --[[ End_of_format ]]0
                                  })})})
                      }),
                    "@[<v>%a%a@]"
                  }), include_err, param[0], print_errs, param[1]);
  end else do
    return --[[ () ]]0;
  end end 
end end

Dont_match = Caml_exceptions.create("Ocaml_typedtree_test.Includecore.Dont_match");

function private_flags(decl1, decl2) do
  match = decl1.type_private;
  match_1 = decl2.type_private;
  if (match or not match_1) then do
    return true;
  end else if (decl2.type_kind == --[[ Type_abstract ]]0) then do
    if (decl2.type_manifest == undefined) then do
      return true;
    end else do
      return decl1.type_kind ~= --[[ Type_abstract ]]0;
    end end 
  end else do
    return false;
  end end  end 
end end

function is_absrow(env, ty) do
  match = ty.desc;
  if (typeof match == "number" or match.tag ~= --[[ Tconstr ]]3) then do
    return false;
  end else do
    local ___conditional___=(match[0].tag | 0);
    do
       if ___conditional___ == 0--[[ Pident ]] then do
          match_1 = expand_head(env, ty);
          match_2 = match_1.desc;
          if (typeof match_2 == "number") then do
            return false;
          end else do
            local ___conditional___=(match_2.tag | 0);
            do
               if ___conditional___ == 4--[[ Tobject ]]
               or ___conditional___ == 8--[[ Tvariant ]] then do
                  return true; end end 
              return false;
                
            end
          end end  end end 
       if ___conditional___ == 1--[[ Pdot ]]
       or ___conditional___ == 2--[[ Papply ]] then do
          return false; end end 
      
    end
  end end 
end end

function type_manifest(env, ty1, params1, ty2, params2, priv2) do
  ty1$prime = expand_head(env, ty1);
  ty2$prime = expand_head(env, ty2);
  match = ty1$prime.desc;
  match_1 = ty2$prime.desc;
  if (typeof match ~= "number") then do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 4--[[ Tobject ]] then do
          if (typeof match_1 ~= "number" and match_1.tag == --[[ Tobject ]]4) then do
            fi2 = match_1[0];
            if (is_absrow(env, flatten_fields(fi2)[1])) then do
              match_2 = flatten_fields(fi2);
              if (equal_4(env, true, --[[ :: ]]{
                      ty1,
                      params1
                    }, --[[ :: ]]{
                      match_2[1],
                      params2
                    })) then do
                match_3 = flatten_fields(match[0]);
                match_4 = match_3[1].desc;
                tmp;
                if (typeof match_4 == "number") then do
                  tmp = true;
                end else do
                  local ___conditional___=(match_4.tag | 0);
                  do
                     if ___conditional___ == 0--[[ Tvar ]]
                     or ___conditional___ == 3--[[ Tconstr ]] then do
                        tmp = true; end else 
                     end end
                    tmp = false;
                      
                  end
                end end 
                if (tmp) then do
                  match_5 = associate_fields(match_3[0], match_2[0]);
                  if (match_5[2] == --[[ [] ]]0) then do
                    match_6 = List.split(List.map((function(param) do
                                return --[[ tuple ]]{
                                        param[2],
                                        param[4]
                                      };
                              end end), match_5[0]));
                    return equal_4(env, true, Pervasives.$at(params1, match_6[0]), Pervasives.$at(params2, match_6[1]));
                  end else do
                    return false;
                  end end 
                end else do
                  return false;
                end end 
              end else do
                return false;
              end end 
            end
             end 
          end
           end  end else 
       if ___conditional___ == 8--[[ Tvariant ]] then do
          if (typeof match_1 ~= "number" and match_1.tag == --[[ Tvariant ]]8) then do
            row2 = match_1[0];
            if (is_absrow(env, row_more(row2))) then do
              row1 = row_repr_aux(--[[ [] ]]0, match[0]);
              row2_1 = row_repr_aux(--[[ [] ]]0, row2);
              if (equal_4(env, true, --[[ :: ]]{
                      ty1,
                      params1
                    }, --[[ :: ]]{
                      row2_1.row_more,
                      params2
                    })) then do
                match_7 = row1.row_more;
                match_8 = match_7.desc;
                tmp_1;
                if (typeof match_8 == "number") then do
                  tmp_1 = true;
                end else do
                  local ___conditional___=(match_8.tag | 0);
                  do
                     if ___conditional___ == 0--[[ Tvar ]]
                     or ___conditional___ == 3--[[ Tconstr ]] then do
                        tmp_1 = true; end else 
                     end end
                    tmp_1 = false;
                      
                  end
                end end 
                if (tmp_1) then do
                  match_9 = merge_row_fields(row1.row_fields, row2_1.row_fields);
                  if ((not row2_1.row_closed or row1.row_closed and filter_row_fields(false, match_9[0]) == --[[ [] ]]0) and List.for_all((function(param) do
                            match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                            if (typeof match == "number" or match.tag) then do
                              return true;
                            end else do
                              return false;
                            end end 
                          end end), match_9[1])) then do
                    to_equal = do
                      contents: List.combine(params1, params2)
                    end;
                    if (List.for_all((function(param) do
                              match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                              match_1 = row_field_repr_aux(--[[ [] ]]0, param[2]);
                              if (typeof match == "number") then do
                                if (typeof match_1 == "number" or match_1.tag) then do
                                  return true;
                                end else do
                                  return false;
                                end end 
                              end else if (match.tag) then do
                                tl1 = match[1];
                                if (typeof match_1 == "number" or not match_1.tag) then do
                                  return false;
                                end else do
                                  tl2 = match_1[1];
                                  if (List.length(tl1) == List.length(tl2) and match[0] == match_1[0]) then do
                                    to_equal.contents = Pervasives.$at(List.combine(tl1, tl2), to_equal.contents);
                                    return true;
                                  end else do
                                    return false;
                                  end end 
                                end end 
                              end else do
                                match_2 = match[0];
                                if (match_2 ~= undefined) then do
                                  t2;
                                  if (typeof match_1 == "number") then do
                                    return false;
                                  end else if (match_1.tag) then do
                                    if (match_1[0]) then do
                                      return false;
                                    end else do
                                      match_3 = match_1[1];
                                      if (match_3 and not match_3[1]) then do
                                        t2 = match_3[0];
                                      end else do
                                        return false;
                                      end end 
                                    end end 
                                  end else do
                                    match_4 = match_1[0];
                                    if (match_4 ~= undefined) then do
                                      t2 = match_4;
                                    end else do
                                      return false;
                                    end end 
                                  end end  end 
                                  to_equal.contents = --[[ :: ]]{
                                    --[[ tuple ]]{
                                      match_2,
                                      t2
                                    },
                                    to_equal.contents
                                  };
                                  return true;
                                end else if (typeof match_1 == "number") then do
                                  return false;
                                end else if (match_1.tag) then do
                                  if (match_1[0] and not match_1[1]) then do
                                    return true;
                                  end else do
                                    return false;
                                  end end 
                                end else do
                                  return match_1[0] == undefined;
                                end end  end  end 
                              end end  end 
                            end end), match_9[2])) then do
                      match_10 = List.split(to_equal.contents);
                      return equal_4(env, true, match_10[0], match_10[1]);
                    end else do
                      return false;
                    end end 
                  end else do
                    return false;
                  end end 
                end else do
                  return false;
                end end 
              end else do
                return false;
              end end 
            end
             end 
          end
           end  end else 
       end end end end
      
    end
  end
   end 
  check_super = function(ty1) do
    if (equal_4(env, true, --[[ :: ]]{
            ty1,
            params1
          }, --[[ :: ]]{
            ty2,
            params2
          })) then do
      return true;
    end else if (priv2 == --[[ Private ]]0) then do
      xpcall(function() do
        return check_super(try_expand_once_opt(env, expand_head(env, ty1)));
      end end,function(exn) do
        if (exn == Cannot_expand) then do
          return false;
        end else do
          error(exn)
        end end 
      end end)
    end else do
      return false;
    end end  end 
  end end;
  return check_super(ty1);
end end

function report_type_mismatch(first, second, decl, ppf) do
  return (function(param) do
      return List.iter((function(err) do
                    if (err == --[[ Manifest ]]4) then do
                      return --[[ () ]]0;
                    end else do
                      return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                  --[[ "." ]]46,
                                                  --[[ End_of_format ]]0
                                                })})
                                        }),
                                      "@ %a."
                                    }), (function(param, param_1) do
                                    first_1 = first;
                                    second_1 = second;
                                    decl_1 = decl;
                                    ppf = param;
                                    err = param_1;
                                    if (typeof err == "number") then do
                                      local ___conditional___=(err);
                                      do
                                         if ___conditional___ == 0--[[ Arity ]] then do
                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                        --[[ String_literal ]]Block.__(11, {
                                                            "They have different arities",
                                                            --[[ End_of_format ]]0
                                                          }),
                                                        "They have different arities"
                                                      }); end end 
                                         if ___conditional___ == 1--[[ Privacy ]] then do
                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                        --[[ String_literal ]]Block.__(11, {
                                                            "A private type would be revealed",
                                                            --[[ End_of_format ]]0
                                                          }),
                                                        "A private type would be revealed"
                                                      }); end end 
                                         if ___conditional___ == 2--[[ Kind ]] then do
                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                        --[[ String_literal ]]Block.__(11, {
                                                            "Their kinds differ",
                                                            --[[ End_of_format ]]0
                                                          }),
                                                        "Their kinds differ"
                                                      }); end end 
                                         if ___conditional___ == 3--[[ Constraint ]] then do
                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                        --[[ String_literal ]]Block.__(11, {
                                                            "Their constraints differ",
                                                            --[[ End_of_format ]]0
                                                          }),
                                                        "Their constraints differ"
                                                      }); end end 
                                         if ___conditional___ == 4--[[ Manifest ]] then do
                                            return --[[ () ]]0; end end 
                                         if ___conditional___ == 5--[[ Variance ]] then do
                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                        --[[ String_literal ]]Block.__(11, {
                                                            "Their variances do not agree",
                                                            --[[ End_of_format ]]0
                                                          }),
                                                        "Their variances do not agree"
                                                      }); end end 
                                        
                                      end
                                    end else do
                                      local ___conditional___=(err.tag | 0);
                                      do
                                         if ___conditional___ == 0--[[ Field_type ]] then do
                                            return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                            --[[ String_literal ]]Block.__(11, {
                                                                "The types for field ",
                                                                --[[ String ]]Block.__(2, {
                                                                    --[[ No_padding ]]0,
                                                                    --[[ String_literal ]]Block.__(11, {
                                                                        " are not equal",
                                                                        --[[ End_of_format ]]0
                                                                      })
                                                                  })
                                                              }),
                                                            "The types for field %s are not equal"
                                                          }), err[0].name); end end 
                                         if ___conditional___ == 1--[[ Field_mutable ]] then do
                                            return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                            --[[ String_literal ]]Block.__(11, {
                                                                "The mutability of field ",
                                                                --[[ String ]]Block.__(2, {
                                                                    --[[ No_padding ]]0,
                                                                    --[[ String_literal ]]Block.__(11, {
                                                                        " is different",
                                                                        --[[ End_of_format ]]0
                                                                      })
                                                                  })
                                                              }),
                                                            "The mutability of field %s is different"
                                                          }), err[0].name); end end 
                                         if ___conditional___ == 2--[[ Field_arity ]] then do
                                            return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                            --[[ String_literal ]]Block.__(11, {
                                                                "The arities for field ",
                                                                --[[ String ]]Block.__(2, {
                                                                    --[[ No_padding ]]0,
                                                                    --[[ String_literal ]]Block.__(11, {
                                                                        " differ",
                                                                        --[[ End_of_format ]]0
                                                                      })
                                                                  })
                                                              }),
                                                            "The arities for field %s differ"
                                                          }), err[0].name); end end 
                                         if ___conditional___ == 3--[[ Field_names ]] then do
                                            return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                                                            --[[ String_literal ]]Block.__(11, {
                                                                "Fields number ",
                                                                --[[ Int ]]Block.__(4, {
                                                                    --[[ Int_i ]]3,
                                                                    --[[ No_padding ]]0,
                                                                    --[[ No_precision ]]0,
                                                                    --[[ String_literal ]]Block.__(11, {
                                                                        " have different names, ",
                                                                        --[[ String ]]Block.__(2, {
                                                                            --[[ No_padding ]]0,
                                                                            --[[ String_literal ]]Block.__(11, {
                                                                                " and ",
                                                                                --[[ String ]]Block.__(2, {
                                                                                    --[[ No_padding ]]0,
                                                                                    --[[ End_of_format ]]0
                                                                                  })
                                                                              })
                                                                          })
                                                                      })
                                                                  })
                                                              }),
                                                            "Fields number %i have different names, %s and %s"
                                                          }), err[0], err[1].name, err[2].name); end end 
                                         if ___conditional___ == 4--[[ Field_missing ]] then do
                                            return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                                                            --[[ String_literal ]]Block.__(11, {
                                                                "The field ",
                                                                --[[ String ]]Block.__(2, {
                                                                    --[[ No_padding ]]0,
                                                                    --[[ String_literal ]]Block.__(11, {
                                                                        " is only present in ",
                                                                        --[[ String ]]Block.__(2, {
                                                                            --[[ No_padding ]]0,
                                                                            --[[ Char_literal ]]Block.__(12, {
                                                                                --[[ " " ]]32,
                                                                                --[[ String ]]Block.__(2, {
                                                                                    --[[ No_padding ]]0,
                                                                                    --[[ End_of_format ]]0
                                                                                  })
                                                                              })
                                                                          })
                                                                      })
                                                                  })
                                                              }),
                                                            "The field %s is only present in %s %s"
                                                          }), err[1].name, err[0] and second_1 or first_1, decl_1); end end 
                                         if ___conditional___ == 5--[[ Record_representation ]] then do
                                            return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                                                            --[[ String_literal ]]Block.__(11, {
                                                                "Their internal representations differ:",
                                                                --[[ Formatting_lit ]]Block.__(17, {
                                                                    --[[ Break ]]Block.__(0, {
                                                                        "@ ",
                                                                        1,
                                                                        0
                                                                      }),
                                                                    --[[ String ]]Block.__(2, {
                                                                        --[[ No_padding ]]0,
                                                                        --[[ Char_literal ]]Block.__(12, {
                                                                            --[[ " " ]]32,
                                                                            --[[ String ]]Block.__(2, {
                                                                                --[[ No_padding ]]0,
                                                                                --[[ Char_literal ]]Block.__(12, {
                                                                                    --[[ " " ]]32,
                                                                                    --[[ String ]]Block.__(2, {
                                                                                        --[[ No_padding ]]0,
                                                                                        --[[ End_of_format ]]0
                                                                                      })
                                                                                  })
                                                                              })
                                                                          })
                                                                      })
                                                                  })
                                                              }),
                                                            "Their internal representations differ:@ %s %s %s"
                                                          }), err[0] and second_1 or first_1, decl_1, "uses unboxed float representation"); end end 
                                        
                                      end
                                    end end 
                                  end end), err);
                    end end 
                  end end), param);
    end end);
end end

function compare_variants(env, decl1, decl2, _n, _cstrs1, _cstrs2) do
  while(true) do
    cstrs2 = _cstrs2;
    cstrs1 = _cstrs1;
    n = _n;
    if (cstrs1) then do
      c = cstrs1[0];
      if (cstrs2) then do
        match = cstrs2[0];
        ret2 = match.cd_res;
        arg2 = match.cd_args;
        cstr2 = match.cd_id;
        ret1 = c.cd_res;
        arg1 = c.cd_args;
        cstr1 = c.cd_id;
        if (cstr1.name ~= cstr2.name) then do
          return --[[ :: ]]{
                  --[[ Field_names ]]Block.__(3, {
                      n,
                      cstr1,
                      cstr2
                    }),
                  --[[ [] ]]0
                };
        end else if (List.length(arg1) ~= List.length(arg2)) then do
          return --[[ :: ]]{
                  --[[ Field_arity ]]Block.__(2, {cstr1}),
                  --[[ [] ]]0
                };
        end else do
          if (ret1 ~= undefined) then do
            if (not (ret2 ~= undefined and equal_4(env, true, --[[ :: ]]{
                      ret1,
                      --[[ [] ]]0
                    }, --[[ :: ]]{
                      ret2,
                      --[[ [] ]]0
                    }))) then do
              return --[[ :: ]]{
                      --[[ Field_type ]]Block.__(0, {cstr1}),
                      --[[ [] ]]0
                    };
            end
             end 
          end else if (ret2 ~= undefined) then do
            return --[[ :: ]]{
                    --[[ Field_type ]]Block.__(0, {cstr1}),
                    --[[ [] ]]0
                  };
          end
           end  end 
          if (for_all2((function(ty1, ty2) do
                    return equal_4(env, true, --[[ :: ]]{
                                ty1,
                                decl1.type_params
                              }, --[[ :: ]]{
                                ty2,
                                decl2.type_params
                              });
                  end end), arg1, arg2)) then do
            _cstrs2 = cstrs2[1];
            _cstrs1 = cstrs1[1];
            _n = n + 1 | 0;
            ::continue:: ;
          end else do
            return --[[ :: ]]{
                    --[[ Field_type ]]Block.__(0, {cstr1}),
                    --[[ [] ]]0
                  };
          end end 
        end end  end 
      end else do
        return --[[ :: ]]{
                --[[ Field_missing ]]Block.__(4, {
                    false,
                    c.cd_id
                  }),
                --[[ [] ]]0
              };
      end end 
    end else if (cstrs2) then do
      return --[[ :: ]]{
              --[[ Field_missing ]]Block.__(4, {
                  true,
                  cstrs2[0].cd_id
                }),
              --[[ [] ]]0
            };
    end else do
      return --[[ [] ]]0;
    end end  end 
  end;
end end

function compare_records(env, decl1, decl2, _n, _labels1, _labels2) do
  while(true) do
    labels2 = _labels2;
    labels1 = _labels1;
    n = _n;
    if (labels1) then do
      l = labels1[0];
      if (labels2) then do
        match = labels2[0];
        lab2 = match.ld_id;
        lab1 = l.ld_id;
        if (lab1.name ~= lab2.name) then do
          return --[[ :: ]]{
                  --[[ Field_names ]]Block.__(3, {
                      n,
                      lab1,
                      lab2
                    }),
                  --[[ [] ]]0
                };
        end else if (l.ld_mutable ~= match.ld_mutable) then do
          return --[[ :: ]]{
                  --[[ Field_mutable ]]Block.__(1, {lab1}),
                  --[[ [] ]]0
                };
        end else if (equal_4(env, true, --[[ :: ]]{
                l.ld_type,
                decl1.type_params
              }, --[[ :: ]]{
                match.ld_type,
                decl2.type_params
              })) then do
          _labels2 = labels2[1];
          _labels1 = labels1[1];
          _n = n + 1 | 0;
          ::continue:: ;
        end else do
          return --[[ :: ]]{
                  --[[ Field_type ]]Block.__(0, {lab1}),
                  --[[ [] ]]0
                };
        end end  end  end 
      end else do
        return --[[ :: ]]{
                --[[ Field_missing ]]Block.__(4, {
                    false,
                    l.ld_id
                  }),
                --[[ [] ]]0
              };
      end end 
    end else if (labels2) then do
      return --[[ :: ]]{
              --[[ Field_missing ]]Block.__(4, {
                  true,
                  labels2[0].ld_id
                }),
              --[[ [] ]]0
            };
    end else do
      return --[[ [] ]]0;
    end end  end 
  end;
end end

function type_declarations_1(equalityOpt, env, name, decl1, id, decl2) do
  equality = equalityOpt ~= undefined and equalityOpt or false;
  if (decl1.type_arity ~= decl2.type_arity) then do
    return --[[ :: ]]{
            --[[ Arity ]]0,
            --[[ [] ]]0
          };
  end else if (private_flags(decl1, decl2)) then do
    match = decl1.type_kind;
    match_1 = decl2.type_kind;
    err;
    exit = 0;
    if (typeof match_1 == "number" and match_1 == 0) then do
      err = --[[ [] ]]0;
    end else do
      exit = 1;
    end end 
    if (exit == 1) then do
      if (typeof match == "number") then do
        err = match == --[[ Type_abstract ]]0 or typeof match_1 ~= "number" and --[[ :: ]]{
            --[[ Kind ]]2,
            --[[ [] ]]0
          } or --[[ [] ]]0;
      end else if (match.tag) then do
        cstrs1 = match[0];
        if (typeof match_1 == "number" or not match_1.tag) then do
          err = --[[ :: ]]{
            --[[ Kind ]]2,
            --[[ [] ]]0
          };
        end else do
          cstrs2 = match_1[0];
          mark = function(cstrs, usage, name, decl) do
            return List.iter((function(c) do
                          return mark_constructor_used(usage, env, name, decl, c.cd_id.name);
                        end end), cstrs);
          end end;
          usage = decl1.type_private == --[[ Private ]]0 or decl2.type_private == --[[ Public ]]1 and --[[ Positive ]]0 or --[[ Privatize ]]2;
          mark(cstrs1, usage, name, decl1);
          if (equality) then do
            mark(cstrs2, --[[ Positive ]]0, id.name, decl2);
          end
           end 
          err = compare_variants(env, decl1, decl2, 1, cstrs1, cstrs2);
        end end 
      end else if (typeof match_1 == "number" or match_1.tag) then do
        err = --[[ :: ]]{
          --[[ Kind ]]2,
          --[[ [] ]]0
        };
      end else do
        rep2 = match_1[1];
        err_1 = compare_records(env, decl1, decl2, 1, match[0], match_1[0]);
        err = err_1 ~= --[[ [] ]]0 or match[1] == rep2 and err_1 or --[[ :: ]]{
            --[[ Record_representation ]]Block.__(5, {rep2 == --[[ Record_float ]]1}),
            --[[ [] ]]0
          };
      end end  end  end 
    end
     end 
    if (err ~= --[[ [] ]]0) then do
      return err;
    end else do
      match_2 = decl1.type_manifest;
      match_3 = decl2.type_manifest;
      err_2;
      if (match_3 ~= undefined) then do
        if (match_2 ~= undefined) then do
          err_2 = type_manifest(env, match_2, decl1.type_params, match_3, decl2.type_params, decl2.type_private) and --[[ [] ]]0 or --[[ :: ]]{
              --[[ Manifest ]]4,
              --[[ [] ]]0
            };
        end else do
          ty1 = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
                  --[[ Pident ]]Block.__(0, {id}),
                  decl2.type_params,
                  do
                    contents: --[[ Mnil ]]0
                  end
                }));
          err_2 = equal_4(env, true, decl1.type_params, decl2.type_params) and (
              equal_4(env, false, --[[ :: ]]{
                    ty1,
                    --[[ [] ]]0
                  }, --[[ :: ]]{
                    match_3,
                    --[[ [] ]]0
                  }) and --[[ [] ]]0 or --[[ :: ]]{
                  --[[ Manifest ]]4,
                  --[[ [] ]]0
                }
            ) or --[[ :: ]]{
              --[[ Constraint ]]3,
              --[[ [] ]]0
            };
        end end 
      end else do
        err_2 = equal_4(env, true, decl1.type_params, decl2.type_params) and --[[ [] ]]0 or --[[ :: ]]{
            --[[ Constraint ]]3,
            --[[ [] ]]0
          };
      end end 
      if (err_2 ~= --[[ [] ]]0) then do
        return err_2;
      end else do
        abstr = decl2.type_private == --[[ Private ]]0 or decl2.type_kind == --[[ Type_abstract ]]0 and decl2.type_manifest == undefined;
        opn = decl2.type_kind == --[[ Type_open ]]1 and decl2.type_manifest == undefined;
        if (List.for_all2((function(ty, param) do
                  v2 = param[1];
                  v1 = param[0];
                  match = Curry._1(Types_Variance.get_upper, v1);
                  cn1 = match[1];
                  co1 = match[0];
                  match_1 = Curry._1(Types_Variance.get_upper, v2);
                  cn2 = match_1[1];
                  co2 = match_1[0];
                  if (abstr and (not co1 or co2) and (not cn1 or cn2) or (
                        opn or not is_Tvar(repr(ty)) and co1 == co2 and cn1 == cn2 or true
                      )) then do
                    match_2 = Curry._1(Types_Variance.get_lower, v1);
                    match_3 = Curry._1(Types_Variance.get_lower, v2);
                    b = (not match_3[0] or match_2[0]) and (not match_3[1] or match_2[1]) and (not match_3[2] or match_2[2]) and (not match_3[3] or match_2[3]);
                    return abstr and b or true;
                  end else do
                    return false;
                  end end 
                end end), decl2.type_params, List.combine(decl1.type_variance, decl2.type_variance))) then do
          return --[[ [] ]]0;
        end else do
          return --[[ :: ]]{
                  --[[ Variance ]]5,
                  --[[ [] ]]0
                };
        end end 
      end end 
    end end 
  end else do
    return --[[ :: ]]{
            --[[ Privacy ]]1,
            --[[ [] ]]0
          };
  end end  end 
end end

function extension_constructors(env, id, ext1, ext2) do
  usage = ext1.ext_private == --[[ Private ]]0 or ext2.ext_private == --[[ Public ]]1 and --[[ Positive ]]0 or --[[ Privatize ]]2;
  mark_extension_used(usage, env, ext1, id.name);
  ty1 = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
          ext1.ext_type_path,
          ext1.ext_type_params,
          do
            contents: --[[ Mnil ]]0
          end
        }));
  ty2 = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
          ext2.ext_type_path,
          ext2.ext_type_params,
          do
            contents: --[[ Mnil ]]0
          end
        }));
  if (equal_4(env, true, --[[ :: ]]{
          ty1,
          ext1.ext_type_params
        }, --[[ :: ]]{
          ty2,
          ext2.ext_type_params
        }) and List.length(ext1.ext_args) == List.length(ext2.ext_args)) then do
    match = ext1.ext_ret_type;
    match_1 = ext2.ext_ret_type;
    tmp;
    exit = 0;
    if (match ~= undefined) then do
      if (match_1 ~= undefined and equal_4(env, true, --[[ :: ]]{
              match,
              --[[ [] ]]0
            }, --[[ :: ]]{
              match_1,
              --[[ [] ]]0
            })) then do
        exit = 1;
      end else do
        tmp = false;
      end end 
    end else if (match_1 ~= undefined) then do
      tmp = false;
    end else do
      exit = 1;
    end end  end 
    if (exit == 1) then do
      tmp = for_all2((function(ty1, ty2) do
              return equal_4(env, true, --[[ :: ]]{
                          ty1,
                          ext1.ext_type_params
                        }, --[[ :: ]]{
                          ty2,
                          ext2.ext_type_params
                        });
            end end), ext1.ext_args, ext2.ext_args);
    end
     end 
    if (tmp) then do
      match_2 = ext1.ext_private;
      match_3 = ext2.ext_private;
      if (match_2 or not match_3) then do
        return true;
      end else do
        return false;
      end end 
    end else do
      return false;
    end end 
  end else do
    return false;
  end end 
end end

function scrape(env, mty) do
  if (mty.tag) then do
    return mty;
  end else do
    xpcall(function() do
      return scrape(env, find_modtype_expansion(mty[0], env));
    end end,function(exn) do
      if (exn == Caml_builtin_exceptions.not_found) then do
        return mty;
      end else do
        error(exn)
      end end 
    end end)
  end end 
end end

function strengthen_1(env, mty, p) do
  mty_1 = scrape(env, mty);
  local ___conditional___=(mty_1.tag | 0);
  do
     if ___conditional___ == 1--[[ Mty_signature ]] then do
        return --[[ Mty_signature ]]Block.__(1, {strengthen_sig(env, mty_1[0], p)}); end end 
     if ___conditional___ == 2--[[ Mty_functor ]] then do
        param = mty_1[0];
        if (applicative_functors.contents and param.name ~= "*") then do
          return --[[ Mty_functor ]]Block.__(2, {
                    param,
                    mty_1[1],
                    strengthen_1(env, mty_1[2], --[[ Papply ]]Block.__(2, {
                            p,
                            --[[ Pident ]]Block.__(0, {param})
                          }))
                  });
        end else do
          return mty_1;
        end end  end end 
     if ___conditional___ == 0--[[ Mty_ident ]]
     or ___conditional___ == 3--[[ Mty_alias ]] then do
        return mty_1; end end 
    
  end
end end

function strengthen_sig(env, sg, p) do
  if (sg) then do
    sigelt = sg[0];
    local ___conditional___=(sigelt.tag | 0);
    do
       if ___conditional___ == 1--[[ Sig_type ]] then do
          decl = sigelt[1];
          id = sigelt[0];
          match = decl.type_manifest;
          match_1 = decl.type_private;
          match_2 = decl.type_kind;
          newdecl;
          exit = 0;
          if (match ~= undefined and (match_1 or typeof match_2 ~= "number")) then do
            newdecl = decl;
          end else do
            exit = 1;
          end end 
          if (exit == 1) then do
            manif = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
                    --[[ Pdot ]]Block.__(1, {
                        p,
                        id.name,
                        -1
                      }),
                    decl.type_params,
                    do
                      contents: --[[ Mnil ]]0
                    end
                  }));
            newdecl = decl.type_kind == --[[ Type_abstract ]]0 and (do
                  type_params: decl.type_params,
                  type_arity: decl.type_arity,
                  type_kind: decl.type_kind,
                  type_private: --[[ Public ]]1,
                  type_manifest: manif,
                  type_variance: decl.type_variance,
                  type_newtype_level: decl.type_newtype_level,
                  type_loc: decl.type_loc,
                  type_attributes: decl.type_attributes
                end) or (do
                  type_params: decl.type_params,
                  type_arity: decl.type_arity,
                  type_kind: decl.type_kind,
                  type_private: decl.type_private,
                  type_manifest: manif,
                  type_variance: decl.type_variance,
                  type_newtype_level: decl.type_newtype_level,
                  type_loc: decl.type_loc,
                  type_attributes: decl.type_attributes
                end);
          end
           end 
          return --[[ :: ]]{
                  --[[ Sig_type ]]Block.__(1, {
                      id,
                      newdecl,
                      sigelt[2]
                    }),
                  strengthen_sig(env, sg[1], p)
                }; end end 
       if ___conditional___ == 3--[[ Sig_module ]] then do
          md = sigelt[1];
          id_1 = sigelt[0];
          str = strengthen_decl(env, md, --[[ Pdot ]]Block.__(1, {
                  p,
                  id_1.name,
                  -1
                }));
          return --[[ :: ]]{
                  --[[ Sig_module ]]Block.__(3, {
                      id_1,
                      str,
                      sigelt[2]
                    }),
                  strengthen_sig(add_module_declaration(undefined, id_1, md, env), sg[1], p)
                }; end end 
       if ___conditional___ == 4--[[ Sig_modtype ]] then do
          decl_1 = sigelt[1];
          id_2 = sigelt[0];
          match_3 = decl_1.mtd_type;
          newdecl_1 = match_3 ~= undefined and decl_1 or (do
                mtd_type: --[[ Mty_ident ]]Block.__(0, {--[[ Pdot ]]Block.__(1, {
                        p,
                        id_2.name,
                        -1
                      })}),
                mtd_attributes: decl_1.mtd_attributes,
                mtd_loc: decl_1.mtd_loc
              end);
          return --[[ :: ]]{
                  --[[ Sig_modtype ]]Block.__(4, {
                      id_2,
                      newdecl_1
                    }),
                  strengthen_sig(add_modtype_1(id_2, decl_1, env), sg[1], p)
                }; end end 
      return --[[ :: ]]{
                sigelt,
                strengthen_sig(env, sg[1], p)
              };
        
    end
  end else do
    return --[[ [] ]]0;
  end end 
end end

function strengthen_decl(env, md, p) do
  return do
          md_type: strengthen_1(env, md.md_type, p),
          md_attributes: md.md_attributes,
          md_loc: md.md_loc
        end;
end end

strengthen.contents = strengthen_1;

function nondep_supertype(env, mid, mty) do
  nondep_mty = function(env, va, _mty) do
    while(true) do
      mty = _mty;
      local ___conditional___=(mty.tag | 0);
      do
         if ___conditional___ == 0--[[ Mty_ident ]] then do
            p = mty[0];
            if (isfree(mid, p)) then do
              _mty = find_modtype_expansion(p, env);
              ::continue:: ;
            end else do
              return mty;
            end end  end end 
         if ___conditional___ == 1--[[ Mty_signature ]] then do
            return --[[ Mty_signature ]]Block.__(1, {nondep_sig(env, va, mty[0])}); end end 
         if ___conditional___ == 2--[[ Mty_functor ]] then do
            arg = mty[1];
            param = mty[0];
            var_inv;
            local ___conditional___=(va);
            do
               if ___conditional___ == 0--[[ Co ]] then do
                  var_inv = --[[ Contra ]]1; end else 
               if ___conditional___ == 1--[[ Contra ]] then do
                  var_inv = --[[ Co ]]0; end else 
               if ___conditional___ == 2--[[ Strict ]] then do
                  var_inv = --[[ Strict ]]2; end else 
               end end end end end end
              
            end
            return --[[ Mty_functor ]]Block.__(2, {
                      param,
                      may_map((function(var_inv)do
                          return function (param) do
                            return nondep_mty(env, var_inv, param);
                          end end
                          end end)(var_inv), arg),
                      nondep_mty(add_module_1(true, param, default_mty(arg), env), va, mty[2])
                    }); end end 
         if ___conditional___ == 3--[[ Mty_alias ]] then do
            p_1 = mty[0];
            if (isfree(mid, p_1)) then do
              _mty = find_module(false, p_1, env).md_type;
              ::continue:: ;
            end else do
              return mty;
            end end  end end 
        
      end
    end;
  end end;
  nondep_sig = function(env, va, param) do
    if (param) then do
      item = param[0];
      rem$prime = nondep_sig(env, va, param[1]);
      local ___conditional___=(item.tag | 0);
      do
         if ___conditional___ == 0--[[ Sig_value ]] then do
            d = item[1];
            return --[[ :: ]]{
                    --[[ Sig_value ]]Block.__(0, {
                        item[0],
                        do
                          val_type: nondep_type(env, mid, d.val_type),
                          val_kind: d.val_kind,
                          val_loc: d.val_loc,
                          val_attributes: d.val_attributes
                        end
                      }),
                    rem$prime
                  }; end end 
         if ___conditional___ == 1--[[ Sig_type ]] then do
            id = item[0];
            return --[[ :: ]]{
                    --[[ Sig_type ]]Block.__(1, {
                        id,
                        nondep_type_decl(env, mid, id, va == --[[ Co ]]0, item[1]),
                        item[2]
                      }),
                    rem$prime
                  }; end end 
         if ___conditional___ == 2--[[ Sig_typext ]] then do
            return --[[ :: ]]{
                    --[[ Sig_typext ]]Block.__(2, {
                        item[0],
                        nondep_extension_constructor(env, mid, item[1]),
                        item[2]
                      }),
                    rem$prime
                  }; end end 
         if ___conditional___ == 3--[[ Sig_module ]] then do
            md = item[1];
            return --[[ :: ]]{
                    --[[ Sig_module ]]Block.__(3, {
                        item[0],
                        do
                          md_type: nondep_mty(env, va, md.md_type),
                          md_attributes: md.md_attributes,
                          md_loc: md.md_loc
                        end,
                        item[2]
                      }),
                    rem$prime
                  }; end end 
         if ___conditional___ == 4--[[ Sig_modtype ]] then do
            id_1 = item[0];
            xpcall(function() do
              return --[[ :: ]]{
                      --[[ Sig_modtype ]]Block.__(4, {
                          id_1,
                          nondep_modtype_decl(env, item[1])
                        }),
                      rem$prime
                    };
            end end,function(exn) do
              if (exn == Caml_builtin_exceptions.not_found) then do
                if (va ~= 0) then do
                  error(Caml_builtin_exceptions.not_found)
                end
                 end 
                return --[[ :: ]]{
                        --[[ Sig_modtype ]]Block.__(4, {
                            id_1,
                            do
                              mtd_type: undefined,
                              mtd_attributes: --[[ [] ]]0,
                              mtd_loc: none
                            end
                          }),
                        rem$prime
                      };
              end else do
                error(exn)
              end end 
            end end) end end 
         if ___conditional___ == 5--[[ Sig_class ]] then do
            return --[[ :: ]]{
                    --[[ Sig_class ]]Block.__(5, {
                        item[0],
                        nondep_class_declaration(env, mid, item[1]),
                        item[2]
                      }),
                    rem$prime
                  }; end end 
         if ___conditional___ == 6--[[ Sig_class_type ]] then do
            return --[[ :: ]]{
                    --[[ Sig_class_type ]]Block.__(6, {
                        item[0],
                        nondep_cltype_declaration(env, mid, item[1]),
                        item[2]
                      }),
                    rem$prime
                  }; end end 
        
      end
    end else do
      return --[[ [] ]]0;
    end end 
  end end;
  nondep_modtype_decl = function(env, mtd) do
    return do
            mtd_type: may_map((function(param) do
                    return nondep_mty(env, --[[ Strict ]]2, param);
                  end end), mtd.mtd_type),
            mtd_attributes: mtd.mtd_attributes,
            mtd_loc: mtd.mtd_loc
          end;
  end end;
  return nondep_mty(env, --[[ Co ]]0, mty);
end end

function enrich_typedecl(env, p, decl) do
  match = decl.type_manifest;
  if (match ~= undefined) then do
    return decl;
  end else do
    xpcall(function() do
      orig_decl = find_type_full(p, env)[0];
      if (orig_decl.type_arity ~= decl.type_arity) then do
        return decl;
      end else do
        return do
                type_params: decl.type_params,
                type_arity: decl.type_arity,
                type_kind: decl.type_kind,
                type_private: decl.type_private,
                type_manifest: newty2(100000000, --[[ Tconstr ]]Block.__(3, {
                        p,
                        decl.type_params,
                        do
                          contents: --[[ Mnil ]]0
                        end
                      })),
                type_variance: decl.type_variance,
                type_newtype_level: decl.type_newtype_level,
                type_loc: decl.type_loc,
                type_attributes: decl.type_attributes
              end;
      end end 
    end end,function(exn) do
      if (exn == Caml_builtin_exceptions.not_found) then do
        return decl;
      end else do
        error(exn)
      end end 
    end end)
  end end 
end end

function enrich_modtype(env, p, mty) do
  if (mty.tag == --[[ Mty_signature ]]1) then do
    return --[[ Mty_signature ]]Block.__(1, {List.map((function(param) do
                      env_1 = env;
                      p_1 = p;
                      item = param;
                      local ___conditional___=(item.tag | 0);
                      do
                         if ___conditional___ == 1--[[ Sig_type ]] then do
                            id = item[0];
                            return --[[ Sig_type ]]Block.__(1, {
                                      id,
                                      enrich_typedecl(env_1, --[[ Pdot ]]Block.__(1, {
                                              p_1,
                                              id.name,
                                              -1
                                            }), item[1]),
                                      item[2]
                                    }); end end 
                         if ___conditional___ == 3--[[ Sig_module ]] then do
                            md = item[1];
                            id_1 = item[0];
                            return --[[ Sig_module ]]Block.__(3, {
                                      id_1,
                                      do
                                        md_type: enrich_modtype(env_1, --[[ Pdot ]]Block.__(1, {
                                                p_1,
                                                id_1.name,
                                                -1
                                              }), md.md_type),
                                        md_attributes: md.md_attributes,
                                        md_loc: md.md_loc
                                      end,
                                      item[2]
                                    }); end end 
                        return item;
                          
                      end
                    end end), mty[0])});
  end else do
    return mty;
  end end 
end end

function type_paths(env, p, mty) do
  match = scrape(env, mty);
  if (match.tag == --[[ Mty_signature ]]1) then do
    return type_paths_sig(env, p, 0, match[0]);
  end else do
    return --[[ [] ]]0;
  end end 
end end

function type_paths_sig(_env, p, _pos, _sg) do
  while(true) do
    sg = _sg;
    pos = _pos;
    env = _env;
    if (sg) then do
      match = sg[0];
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 0--[[ Sig_value ]] then do
            match_1 = match[1].val_kind;
            pos$prime;
            pos$prime = typeof match_1 == "number" or match_1.tag and pos + 1 | 0 or pos;
            _sg = sg[1];
            _pos = pos$prime;
            ::continue:: ; end end 
         if ___conditional___ == 1--[[ Sig_type ]] then do
            return --[[ :: ]]{
                    --[[ Pdot ]]Block.__(1, {
                        p,
                        match[0].name,
                        -1
                      }),
                    type_paths_sig(env, p, pos, sg[1])
                  }; end end 
         if ___conditional___ == 3--[[ Sig_module ]] then do
            md = match[1];
            id = match[0];
            return Pervasives.$at(type_paths(env, --[[ Pdot ]]Block.__(1, {
                              p,
                              id.name,
                              pos
                            }), md.md_type), type_paths_sig(add_module_declaration(undefined, id, md, env), p, pos + 1 | 0, sg[1])); end end 
         if ___conditional___ == 4--[[ Sig_modtype ]] then do
            _sg = sg[1];
            _env = add_modtype_1(match[0], match[1], env);
            ::continue:: ; end end 
         if ___conditional___ == 2--[[ Sig_typext ]]
         or ___conditional___ == 5--[[ Sig_class ]]
         or ___conditional___ == 6--[[ Sig_class_type ]] then do
            _sg = sg[1];
            ::continue:: ; end end 
        
      end
      _sg = sg[1];
      _pos = pos + 1 | 0;
      ::continue:: ;
    end else do
      return --[[ [] ]]0;
    end end 
  end;
end end

function contains_type(env, _param) do
  while(true) do
    param = _param;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ == 0--[[ Mty_ident ]] then do
          xpcall(function() do
            match = find_modtype(param[0], env).mtd_type;
            if (match ~= undefined) then do
              return contains_type(env, match);
            end else do
              error(Pervasives.Exit)
            end end 
          end end,function(exn) do
            if (exn == Caml_builtin_exceptions.not_found) then do
              error(Pervasives.Exit)
            end
             end 
            error(exn)
          end end) end end 
       if ___conditional___ == 1--[[ Mty_signature ]] then do
          return contains_type_sig(env)(param[0]); end end 
       if ___conditional___ == 2--[[ Mty_functor ]] then do
          _param = param[2];
          ::continue:: ; end end 
       if ___conditional___ == 3--[[ Mty_alias ]] then do
          return --[[ () ]]0; end end 
      
    end
  end;
end end

function contains_type_sig(env) do
  return (function(param) do
      return List.iter((function(param) do
                    env_1 = env;
                    param_1 = param;
                    local ___conditional___=(param_1.tag | 0);
                    do
                       if ___conditional___ == 1--[[ Sig_type ]] then do
                          match = param_1[1];
                          match_1 = match.type_kind;
                          if (match.type_manifest ~= undefined) then do
                            if (typeof match_1 == "number" and not (match_1 ~= 0 or match.type_private)) then do
                              error(Pervasives.Exit)
                            end else do
                              return --[[ () ]]0;
                            end end 
                          end else do
                            error(Pervasives.Exit)
                          end end  end end 
                       if ___conditional___ == 3--[[ Sig_module ]] then do
                          return contains_type(env_1, param_1[1].md_type); end end 
                       if ___conditional___ == 4--[[ Sig_modtype ]] then do
                          error(Pervasives.Exit) end end 
                      return --[[ () ]]0;
                        
                    end
                  end end), param);
    end end);
end end

function contains_type_1(env, mty) do
  xpcall(function() do
    contains_type(env, mty);
    return false;
  end end,function(exn) do
    if (exn == Pervasives.Exit) then do
      return true;
    end else do
      error(exn)
    end end 
  end end)
end end

function compare_3(p1, p2) do
  if (same(p1, p2)) then do
    return 0;
  end else do
    return Caml_obj.caml_compare(p1, p2);
  end end 
end end

function height_7(param) do
  if (param) then do
    return param[--[[ h ]]3];
  end else do
    return 0;
  end end 
end end

function create_8(l, v, r) do
  hl = l and l[--[[ h ]]3] or 0;
  hr = r and r[--[[ h ]]3] or 0;
  return --[[ Node ]]{
          --[[ l ]]l,
          --[[ v ]]v,
          --[[ r ]]r,
          --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
        };
end end

function bal_7(l, v, r) do
  hl = l and l[--[[ h ]]3] or 0;
  hr = r and r[--[[ h ]]3] or 0;
  if (hl > (hr + 2 | 0)) then do
    if (l) then do
      lr = l[--[[ r ]]2];
      lv = l[--[[ v ]]1];
      ll = l[--[[ l ]]0];
      if (height_7(ll) >= height_7(lr)) then do
        return create_8(ll, lv, create_8(lr, v, r));
      end else if (lr) then do
        return create_8(create_8(ll, lv, lr[--[[ l ]]0]), lr[--[[ v ]]1], create_8(lr[--[[ r ]]2], v, r));
      end else do
        error({
          Caml_builtin_exceptions.invalid_argument,
          "Set.bal"
        })
      end end  end 
    end else do
      error({
        Caml_builtin_exceptions.invalid_argument,
        "Set.bal"
      })
    end end 
  end else if (hr > (hl + 2 | 0)) then do
    if (r) then do
      rr = r[--[[ r ]]2];
      rv = r[--[[ v ]]1];
      rl = r[--[[ l ]]0];
      if (height_7(rr) >= height_7(rl)) then do
        return create_8(create_8(l, v, rl), rv, rr);
      end else if (rl) then do
        return create_8(create_8(l, v, rl[--[[ l ]]0]), rl[--[[ v ]]1], create_8(rl[--[[ r ]]2], rv, rr));
      end else do
        error({
          Caml_builtin_exceptions.invalid_argument,
          "Set.bal"
        })
      end end  end 
    end else do
      error({
        Caml_builtin_exceptions.invalid_argument,
        "Set.bal"
      })
    end end 
  end else do
    return --[[ Node ]]{
            --[[ l ]]l,
            --[[ v ]]v,
            --[[ r ]]r,
            --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
          };
  end end  end 
end end

function add_9(x, t) do
  if (t) then do
    r = t[--[[ r ]]2];
    v = t[--[[ v ]]1];
    l = t[--[[ l ]]0];
    c = compare_3(x, v);
    if (c == 0) then do
      return t;
    end else if (c < 0) then do
      ll = add_9(x, l);
      if (l == ll) then do
        return t;
      end else do
        return bal_7(ll, v, r);
      end end 
    end else do
      rr = add_9(x, r);
      if (r == rr) then do
        return t;
      end else do
        return bal_7(l, v, rr);
      end end 
    end end  end 
  end else do
    return --[[ Node ]]{
            --[[ l : Empty ]]0,
            --[[ v ]]x,
            --[[ r : Empty ]]0,
            --[[ h ]]1
          };
  end end 
end end

function singleton_2(x) do
  return --[[ Node ]]{
          --[[ l : Empty ]]0,
          --[[ v ]]x,
          --[[ r : Empty ]]0,
          --[[ h ]]1
        };
end end

function add_min_element_2(x, param) do
  if (param) then do
    return bal_7(add_min_element_2(x, param[--[[ l ]]0]), param[--[[ v ]]1], param[--[[ r ]]2]);
  end else do
    return singleton_2(x);
  end end 
end end

function add_max_element_2(x, param) do
  if (param) then do
    return bal_7(param[--[[ l ]]0], param[--[[ v ]]1], add_max_element_2(x, param[--[[ r ]]2]));
  end else do
    return singleton_2(x);
  end end 
end end

function join_2(l, v, r) do
  if (l) then do
    if (r) then do
      rh = r[--[[ h ]]3];
      lh = l[--[[ h ]]3];
      if (lh > (rh + 2 | 0)) then do
        return bal_7(l[--[[ l ]]0], l[--[[ v ]]1], join_2(l[--[[ r ]]2], v, r));
      end else if (rh > (lh + 2 | 0)) then do
        return bal_7(join_2(l, v, r[--[[ l ]]0]), r[--[[ v ]]1], r[--[[ r ]]2]);
      end else do
        return create_8(l, v, r);
      end end  end 
    end else do
      return add_max_element_2(v, l);
    end end 
  end else do
    return add_min_element_2(v, r);
  end end 
end end

function split_2(x, param) do
  if (param) then do
    r = param[--[[ r ]]2];
    v = param[--[[ v ]]1];
    l = param[--[[ l ]]0];
    c = compare_3(x, v);
    if (c == 0) then do
      return --[[ tuple ]]{
              l,
              true,
              r
            };
    end else if (c < 0) then do
      match = split_2(x, l);
      return --[[ tuple ]]{
              match[0],
              match[1],
              join_2(match[2], v, r)
            };
    end else do
      match_1 = split_2(x, r);
      return --[[ tuple ]]{
              join_2(l, v, match_1[0]),
              match_1[1],
              match_1[2]
            };
    end end  end 
  end else do
    return --[[ tuple ]]{
            --[[ Empty ]]0,
            false,
            --[[ Empty ]]0
          };
  end end 
end end

function union_3(s1, s2) do
  if (s1) then do
    if (s2) then do
      h2 = s2[--[[ h ]]3];
      v2 = s2[--[[ v ]]1];
      h1 = s1[--[[ h ]]3];
      v1 = s1[--[[ v ]]1];
      if (h1 >= h2) then do
        if (h2 == 1) then do
          return add_9(v2, s1);
        end else do
          match = split_2(v1, s2);
          return join_2(union_3(s1[--[[ l ]]0], match[0]), v1, union_3(s1[--[[ r ]]2], match[2]));
        end end 
      end else if (h1 == 1) then do
        return add_9(v1, s2);
      end else do
        match_1 = split_2(v2, s1);
        return join_2(union_3(match_1[0], s2[--[[ l ]]0]), v2, union_3(match_1[2], s2[--[[ r ]]2]));
      end end  end 
    end else do
      return s1;
    end end 
  end else do
    return s2;
  end end 
end end

function fold_6(f, _s, _accu) do
  while(true) do
    accu = _accu;
    s = _s;
    if (s) then do
      _accu = Curry._2(f, s[--[[ v ]]1], fold_6(f, s[--[[ l ]]0], accu));
      _s = s[--[[ r ]]2];
      ::continue:: ;
    end else do
      return accu;
    end end 
  end;
end end

function height_8(param) do
  if (param) then do
    return param[--[[ h ]]4];
  end else do
    return 0;
  end end 
end end

function create_9(l, x, d, r) do
  hl = height_8(l);
  hr = height_8(r);
  return --[[ Node ]]{
          --[[ l ]]l,
          --[[ v ]]x,
          --[[ d ]]d,
          --[[ r ]]r,
          --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
        };
end end

function bal_8(l, x, d, r) do
  hl = l and l[--[[ h ]]4] or 0;
  hr = r and r[--[[ h ]]4] or 0;
  if (hl > (hr + 2 | 0)) then do
    if (l) then do
      lr = l[--[[ r ]]3];
      ld = l[--[[ d ]]2];
      lv = l[--[[ v ]]1];
      ll = l[--[[ l ]]0];
      if (height_8(ll) >= height_8(lr)) then do
        return create_9(ll, lv, ld, create_9(lr, x, d, r));
      end else if (lr) then do
        return create_9(create_9(ll, lv, ld, lr[--[[ l ]]0]), lr[--[[ v ]]1], lr[--[[ d ]]2], create_9(lr[--[[ r ]]3], x, d, r));
      end else do
        error({
          Caml_builtin_exceptions.invalid_argument,
          "Map.bal"
        })
      end end  end 
    end else do
      error({
        Caml_builtin_exceptions.invalid_argument,
        "Map.bal"
      })
    end end 
  end else if (hr > (hl + 2 | 0)) then do
    if (r) then do
      rr = r[--[[ r ]]3];
      rd = r[--[[ d ]]2];
      rv = r[--[[ v ]]1];
      rl = r[--[[ l ]]0];
      if (height_8(rr) >= height_8(rl)) then do
        return create_9(create_9(l, x, d, rl), rv, rd, rr);
      end else if (rl) then do
        return create_9(create_9(l, x, d, rl[--[[ l ]]0]), rl[--[[ v ]]1], rl[--[[ d ]]2], create_9(rl[--[[ r ]]3], rv, rd, rr));
      end else do
        error({
          Caml_builtin_exceptions.invalid_argument,
          "Map.bal"
        })
      end end  end 
    end else do
      error({
        Caml_builtin_exceptions.invalid_argument,
        "Map.bal"
      })
    end end 
  end else do
    return --[[ Node ]]{
            --[[ l ]]l,
            --[[ v ]]x,
            --[[ d ]]d,
            --[[ r ]]r,
            --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
          };
  end end  end 
end end

function add_10(x, data, m) do
  if (m) then do
    r = m[--[[ r ]]3];
    d = m[--[[ d ]]2];
    v = m[--[[ v ]]1];
    l = m[--[[ l ]]0];
    c = compare_3(x, v);
    if (c == 0) then do
      if (d == data) then do
        return m;
      end else do
        return --[[ Node ]]{
                --[[ l ]]l,
                --[[ v ]]x,
                --[[ d ]]data,
                --[[ r ]]r,
                --[[ h ]]m[--[[ h ]]4]
              };
      end end 
    end else if (c < 0) then do
      ll = add_10(x, data, l);
      if (l == ll) then do
        return m;
      end else do
        return bal_8(ll, v, d, r);
      end end 
    end else do
      rr = add_10(x, data, r);
      if (r == rr) then do
        return m;
      end else do
        return bal_8(l, v, d, rr);
      end end 
    end end  end 
  end else do
    return --[[ Node ]]{
            --[[ l : Empty ]]0,
            --[[ v ]]x,
            --[[ d ]]data,
            --[[ r : Empty ]]0,
            --[[ h ]]1
          };
  end end 
end end

function find_5(x, _param) do
  while(true) do
    param = _param;
    if (param) then do
      c = compare_3(x, param[--[[ v ]]1]);
      if (c == 0) then do
        return param[--[[ d ]]2];
      end else do
        _param = c < 0 and param[--[[ l ]]0] or param[--[[ r ]]3];
        ::continue:: ;
      end end 
    end else do
      error(Caml_builtin_exceptions.not_found)
    end end 
  end;
end end

function height_9(param) do
  if (param) then do
    return param[--[[ h ]]3];
  end else do
    return 0;
  end end 
end end

function create_10(l, v, r) do
  hl = l and l[--[[ h ]]3] or 0;
  hr = r and r[--[[ h ]]3] or 0;
  return --[[ Node ]]{
          --[[ l ]]l,
          --[[ v ]]v,
          --[[ r ]]r,
          --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
        };
end end

function bal_9(l, v, r) do
  hl = l and l[--[[ h ]]3] or 0;
  hr = r and r[--[[ h ]]3] or 0;
  if (hl > (hr + 2 | 0)) then do
    if (l) then do
      lr = l[--[[ r ]]2];
      lv = l[--[[ v ]]1];
      ll = l[--[[ l ]]0];
      if (height_9(ll) >= height_9(lr)) then do
        return create_10(ll, lv, create_10(lr, v, r));
      end else if (lr) then do
        return create_10(create_10(ll, lv, lr[--[[ l ]]0]), lr[--[[ v ]]1], create_10(lr[--[[ r ]]2], v, r));
      end else do
        error({
          Caml_builtin_exceptions.invalid_argument,
          "Set.bal"
        })
      end end  end 
    end else do
      error({
        Caml_builtin_exceptions.invalid_argument,
        "Set.bal"
      })
    end end 
  end else if (hr > (hl + 2 | 0)) then do
    if (r) then do
      rr = r[--[[ r ]]2];
      rv = r[--[[ v ]]1];
      rl = r[--[[ l ]]0];
      if (height_9(rr) >= height_9(rl)) then do
        return create_10(create_10(l, v, rl), rv, rr);
      end else if (rl) then do
        return create_10(create_10(l, v, rl[--[[ l ]]0]), rl[--[[ v ]]1], create_10(rl[--[[ r ]]2], rv, rr));
      end else do
        error({
          Caml_builtin_exceptions.invalid_argument,
          "Set.bal"
        })
      end end  end 
    end else do
      error({
        Caml_builtin_exceptions.invalid_argument,
        "Set.bal"
      })
    end end 
  end else do
    return --[[ Node ]]{
            --[[ l ]]l,
            --[[ v ]]v,
            --[[ r ]]r,
            --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
          };
  end end  end 
end end

function add_11(x, t) do
  if (t) then do
    r = t[--[[ r ]]2];
    v = t[--[[ v ]]1];
    l = t[--[[ l ]]0];
    c = Caml_obj.caml_compare(x, v);
    if (c == 0) then do
      return t;
    end else if (c < 0) then do
      ll = add_11(x, l);
      if (l == ll) then do
        return t;
      end else do
        return bal_9(ll, v, r);
      end end 
    end else do
      rr = add_11(x, r);
      if (r == rr) then do
        return t;
      end else do
        return bal_9(l, v, rr);
      end end 
    end end  end 
  end else do
    return --[[ Node ]]{
            --[[ l : Empty ]]0,
            --[[ v ]]x,
            --[[ r : Empty ]]0,
            --[[ h ]]1
          };
  end end 
end end

function singleton_3(x) do
  return --[[ Node ]]{
          --[[ l : Empty ]]0,
          --[[ v ]]x,
          --[[ r : Empty ]]0,
          --[[ h ]]1
        };
end end

function add_min_element_3(x, param) do
  if (param) then do
    return bal_9(add_min_element_3(x, param[--[[ l ]]0]), param[--[[ v ]]1], param[--[[ r ]]2]);
  end else do
    return singleton_3(x);
  end end 
end end

function add_max_element_3(x, param) do
  if (param) then do
    return bal_9(param[--[[ l ]]0], param[--[[ v ]]1], add_max_element_3(x, param[--[[ r ]]2]));
  end else do
    return singleton_3(x);
  end end 
end end

function join_3(l, v, r) do
  if (l) then do
    if (r) then do
      rh = r[--[[ h ]]3];
      lh = l[--[[ h ]]3];
      if (lh > (rh + 2 | 0)) then do
        return bal_9(l[--[[ l ]]0], l[--[[ v ]]1], join_3(l[--[[ r ]]2], v, r));
      end else if (rh > (lh + 2 | 0)) then do
        return bal_9(join_3(l, v, r[--[[ l ]]0]), r[--[[ v ]]1], r[--[[ r ]]2]);
      end else do
        return create_10(l, v, r);
      end end  end 
    end else do
      return add_max_element_3(v, l);
    end end 
  end else do
    return add_min_element_3(v, r);
  end end 
end end

function split_3(x, param) do
  if (param) then do
    r = param[--[[ r ]]2];
    v = param[--[[ v ]]1];
    l = param[--[[ l ]]0];
    c = Caml_obj.caml_compare(x, v);
    if (c == 0) then do
      return --[[ tuple ]]{
              l,
              true,
              r
            };
    end else if (c < 0) then do
      match = split_3(x, l);
      return --[[ tuple ]]{
              match[0],
              match[1],
              join_3(match[2], v, r)
            };
    end else do
      match_1 = split_3(x, r);
      return --[[ tuple ]]{
              join_3(l, v, match_1[0]),
              match_1[1],
              match_1[2]
            };
    end end  end 
  end else do
    return --[[ tuple ]]{
            --[[ Empty ]]0,
            false,
            --[[ Empty ]]0
          };
  end end 
end end

function mem_5(x, _param) do
  while(true) do
    param = _param;
    if (param) then do
      c = Caml_obj.caml_compare(x, param[--[[ v ]]1]);
      if (c == 0) then do
        return true;
      end else do
        _param = c < 0 and param[--[[ l ]]0] or param[--[[ r ]]2];
        ::continue:: ;
      end end 
    end else do
      return false;
    end end 
  end;
end end

function union_4(s1, s2) do
  if (s1) then do
    if (s2) then do
      h2 = s2[--[[ h ]]3];
      v2 = s2[--[[ v ]]1];
      h1 = s1[--[[ h ]]3];
      v1 = s1[--[[ v ]]1];
      if (h1 >= h2) then do
        if (h2 == 1) then do
          return add_11(v2, s1);
        end else do
          match = split_3(v1, s2);
          return join_3(union_4(s1[--[[ l ]]0], match[0]), v1, union_4(s1[--[[ r ]]2], match[2]));
        end end 
      end else if (h1 == 1) then do
        return add_11(v1, s2);
      end else do
        match_1 = split_3(v2, s1);
        return join_3(union_4(match_1[0], s2[--[[ l ]]0]), v2, union_4(match_1[2], s2[--[[ r ]]2]));
      end end  end 
    end else do
      return s1;
    end end 
  end else do
    return s2;
  end end 
end end

function get_prefixes(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Pident ]] then do
        return --[[ Empty ]]0; end end 
     if ___conditional___ == 1--[[ Pdot ]]
     or ___conditional___ == 2--[[ Papply ]]
     end
    
  end
  p = param[0];
  return add_9(p, get_prefixes(p));
end end

function get_arg_paths(_param) do
  while(true) do
    param = _param;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ == 0--[[ Pident ]] then do
          return --[[ Empty ]]0; end end 
       if ___conditional___ == 1--[[ Pdot ]] then do
          _param = param[0];
          ::continue:: ; end end 
       if ___conditional___ == 2--[[ Papply ]] then do
          p2 = param[1];
          return add_9(p2, union_3(get_prefixes(p2), union_3(get_arg_paths(param[0]), get_arg_paths(p2)))); end end 
      
    end
  end;
end end

function rollback_path(subst, _p) do
  while(true) do
    p = _p;
    xpcall(function() do
      return --[[ Pident ]]Block.__(0, {find_5(p, subst)});
    end end,function(exn) do
      if (exn == Caml_builtin_exceptions.not_found) then do
        local ___conditional___=(p.tag | 0);
        do
           if ___conditional___ == 1--[[ Pdot ]] then do
              p1 = p[0];
              p1$prime = rollback_path(subst, p1);
              if (same(p1, p1$prime)) then do
                return p;
              end else do
                _p = --[[ Pdot ]]Block.__(1, {
                    p1$prime,
                    p[1],
                    p[2]
                  });
                ::continue:: ;
              end end  end end 
           if ___conditional___ == 0--[[ Pident ]]
           or ___conditional___ == 2--[[ Papply ]] then do
              return p; end end 
          
        end
      end else do
        error(exn)
      end end 
    end end)
  end;
end end

function collect_ids(subst, bindings, p) do
  match = rollback_path(subst, p);
  local ___conditional___=(match.tag | 0);
  do
     if ___conditional___ == 0--[[ Pident ]] then do
        id = match[0];
        ids;
        xpcall(function() do
          ids = collect_ids(subst, bindings, find_same(id, bindings));
        end end,function(exn) do
          if (exn == Caml_builtin_exceptions.not_found) then do
            ids = --[[ Empty ]]0;
          end else do
            error(exn)
          end end 
        end end)
        return add_11(id, ids); end end 
     if ___conditional___ == 1--[[ Pdot ]]
     or ___conditional___ == 2--[[ Papply ]] then do
        return --[[ Empty ]]0; end end 
    
  end
end end

function collect_arg_paths(mty) do
  paths = do
    contents: --[[ Empty ]]0
  end;
  subst = do
    contents: --[[ Empty ]]0
  end;
  bindings = do
    contents: --[[ Empty ]]0
  end;
  it_path = function(p) do
    paths.contents = union_3(get_arg_paths(p), paths.contents);
    return --[[ () ]]0;
  end end;
  it_signature_item_1 = function(it, si) do
    it_signature_item(it, si);
    if (si.tag == --[[ Sig_module ]]3) then do
      match = si[1].md_type;
      id = si[0];
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 1--[[ Mty_signature ]] then do
            return List.iter((function(param) do
                          if (param.tag == --[[ Sig_module ]]3) then do
                            id$prime = param[0];
                            subst.contents = add_10(--[[ Pdot ]]Block.__(1, {
                                    --[[ Pident ]]Block.__(0, {id}),
                                    id$prime.name,
                                    -1
                                  }), id$prime, subst.contents);
                            return --[[ () ]]0;
                          end else do
                            return --[[ () ]]0;
                          end end 
                        end end), match[0]); end end 
         if ___conditional___ == 0--[[ Mty_ident ]]
         or ___conditional___ == 2--[[ Mty_functor ]] then do
            return --[[ () ]]0; end end 
         if ___conditional___ == 3--[[ Mty_alias ]] then do
            bindings.contents = add(id, match[0], bindings.contents);
            return --[[ () ]]0; end end 
        
      end
    end else do
      return --[[ () ]]0;
    end end 
  end end;
  it = do
    it_signature: it_signature,
    it_signature_item: it_signature_item_1,
    it_value_description: it_value_description,
    it_type_declaration: it_type_declaration,
    it_extension_constructor: it_extension_constructor,
    it_module_declaration: it_module_declaration,
    it_modtype_declaration: it_modtype_declaration,
    it_class_declaration: it_class_declaration,
    it_class_type_declaration: it_class_type_declaration,
    it_module_type: it_module_type,
    it_class_type: it_class_type,
    it_type_kind: it_type_kind,
    it_do_type_expr: it_do_type_expr,
    it_type_expr: it_type_expr,
    it_path: it_path
  end;
  it_module_type(it, mty);
  it_module_type(unmark_iterators, mty);
  return fold_6((function(p) do
                partial_arg = collect_ids(subst.contents, bindings.contents, p);
                return (function(param) do
                    return union_4(partial_arg, param);
                  end end);
              end end), paths.contents, --[[ Empty ]]0);
end end

function remove_aliases(env, excl, _mty) do
  while(true) do
    mty = _mty;
    local ___conditional___=(mty.tag | 0);
    do
       if ___conditional___ == 1--[[ Mty_signature ]] then do
          return --[[ Mty_signature ]]Block.__(1, {remove_aliases_sig(env, excl, mty[0])}); end end 
       if ___conditional___ == 0--[[ Mty_ident ]]
       or ___conditional___ == 2--[[ Mty_functor ]] then do
          return mty; end end 
       if ___conditional___ == 3--[[ Mty_alias ]] then do
          mty$prime = scrape_alias(env, undefined, mty);
          if (Caml_obj.caml_equal(mty$prime, mty)) then do
            return mty;
          end else do
            _mty = mty$prime;
            ::continue:: ;
          end end  end end 
      
    end
  end;
end end

function remove_aliases_sig(env, excl, sg) do
  if (sg) then do
    it = sg[0];
    local ___conditional___=(it.tag | 0);
    do
       if ___conditional___ == 3--[[ Sig_module ]] then do
          md = it[1];
          id = it[0];
          mty = md.md_type;
          mty_1;
          mty_1 = mty.tag == --[[ Mty_alias ]]3 and mem_5(id, excl) and md.md_type or remove_aliases(env, excl, mty);
          return --[[ :: ]]{
                  --[[ Sig_module ]]Block.__(3, {
                      id,
                      do
                        md_type: mty_1,
                        md_attributes: md.md_attributes,
                        md_loc: md.md_loc
                      end,
                      it[2]
                    }),
                  remove_aliases_sig(add_module_1(undefined, id, mty_1, env), excl, sg[1])
                }; end end 
       if ___conditional___ == 4--[[ Sig_modtype ]] then do
          mtd = it[1];
          id_1 = it[0];
          return --[[ :: ]]{
                  --[[ Sig_modtype ]]Block.__(4, {
                      id_1,
                      mtd
                    }),
                  remove_aliases_sig(add_modtype_1(id_1, mtd, env), excl, sg[1])
                }; end end 
      return --[[ :: ]]{
                it,
                remove_aliases_sig(env, excl, sg[1])
              };
        
    end
  end else do
    return --[[ [] ]]0;
  end end 
end end

function remove_aliases_1(env, sg) do
  excl = collect_arg_paths(sg);
  return remove_aliases(env, excl, sg);
end end

__Error_5 = Caml_exceptions.create("Ocaml_typedtree_test.Includemod.Error");

function value_descriptions(env, cxt, subst, id, vd1, vd2) do
  record_value_dependency(vd1, vd2);
  mark_value_used(env, id.name, vd1);
  vd2_1 = value_description(subst, vd2);
  xpcall(function() do
    env_1 = env;
    id_1 = id;
    vd1_1 = vd1;
    vd2_2 = vd2_1;
    if (moregeneral(env_1, true, vd1_1.val_type, vd2_2.val_type)) then do
      match = vd1_1.val_kind;
      match_1 = vd2_2.val_kind;
      if (typeof match ~= "number" and not match.tag) then do
        p1 = match[0];
        if (typeof match_1 == "number" or match_1.tag) then do
          return --[[ Tcoerce_primitive ]]Block.__(2, {
                    id_1,
                    p1
                  });
        end else if (Caml_obj.caml_equal(p1, match_1[0])) then do
          return --[[ Tcoerce_none ]]0;
        end else do
          error(Dont_match)
        end end  end 
      end
       end 
      if (typeof match_1 == "number" or match_1.tag) then do
        return --[[ Tcoerce_none ]]0;
      end else do
        error(Dont_match)
      end end 
    end else do
      error(Dont_match)
    end end 
  end end,function(exn) do
    if (exn == Dont_match) then do
      error({
        __Error_5,
        --[[ :: ]]{
          --[[ tuple ]]{
            cxt,
            env,
            --[[ Value_descriptions ]]Block.__(1, {
                id,
                vd1,
                vd2_1
              })
          },
          --[[ [] ]]0
        }
      })
    end
     end 
    error(exn)
  end end)
end end

function type_declarations_2(env, old_envOpt, cxt, subst, id, decl1, decl2) do
  old_env = old_envOpt ~= undefined and Caml_option.valFromOption(old_envOpt) or env;
  mark_type_used(env, id.name, decl1);
  decl2_1 = type_declaration(subst, decl2);
  err = type_declarations_1(undefined, env, id.name, decl1, id, decl2_1);
  if (err ~= --[[ [] ]]0) then do
    error({
      __Error_5,
      --[[ :: ]]{
        --[[ tuple ]]{
          cxt,
          old_env,
          --[[ Type_declarations ]]Block.__(2, {
              id,
              decl1,
              decl2_1,
              err
            })
        },
        --[[ [] ]]0
      }
    })
  end else do
    return 0;
  end end 
end end

function extension_constructors_1(env, cxt, subst, id, ext1, ext2) do
  ext2_1 = extension_constructor(subst, ext2);
  if (extension_constructors(env, id, ext1, ext2_1)) then do
    return --[[ () ]]0;
  end else do
    error({
      __Error_5,
      --[[ :: ]]{
        --[[ tuple ]]{
          cxt,
          env,
          --[[ Extension_constructors ]]Block.__(3, {
              id,
              ext1,
              ext2_1
            })
        },
        --[[ [] ]]0
      }
    })
  end end 
end end

function class_type_declarations_1(old_env, env, cxt, subst, id, decl1, decl2) do
  decl2_1 = cltype_declaration(subst, decl2);
  reason = class_type_declarations(env, decl1, decl2_1);
  if (reason) then do
    error({
      __Error_5,
      --[[ :: ]]{
        --[[ tuple ]]{
          cxt,
          old_env,
          --[[ Class_type_declarations ]]Block.__(7, {
              id,
              decl1,
              decl2_1,
              reason
            })
        },
        --[[ [] ]]0
      }
    })
  end else do
    return --[[ () ]]0;
  end end 
end end

function class_declarations_1(old_env, env, cxt, subst, id, decl1, decl2) do
  decl2_1 = class_declaration(subst, decl2);
  reason = class_declarations(env, decl1, decl2_1);
  if (reason) then do
    error({
      __Error_5,
      --[[ :: ]]{
        --[[ tuple ]]{
          cxt,
          old_env,
          --[[ Class_declarations ]]Block.__(8, {
              id,
              decl1,
              decl2_1,
              reason
            })
        },
        --[[ [] ]]0
      }
    })
  end else do
    return --[[ () ]]0;
  end end 
end end

Dont_match_1 = Caml_exceptions.create("Ocaml_typedtree_test.Includemod.Dont_match");

function may_expand_module_path(env, path) do
  xpcall(function() do
    find_modtype_expansion(path, env);
    return true;
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return false;
    end else do
      error(exn)
    end end 
  end end)
end end

function expand_module_path(env, cxt, path) do
  xpcall(function() do
    return find_modtype_expansion(path, env);
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      error({
        __Error_5,
        --[[ :: ]]{
          --[[ tuple ]]{
            cxt,
            env,
            --[[ Unbound_modtype_path ]]Block.__(9, {path})
          },
          --[[ [] ]]0
        }
      })
    end
     end 
    error(exn)
  end end)
end end

function expand_module_alias(env, cxt, path) do
  xpcall(function() do
    return find_module(false, path, env).md_type;
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      error({
        __Error_5,
        --[[ :: ]]{
          --[[ tuple ]]{
            cxt,
            env,
            --[[ Unbound_module_path ]]Block.__(10, {path})
          },
          --[[ [] ]]0
        }
      })
    end
     end 
    error(exn)
  end end)
end end

function kind_of_field_desc(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Field_value ]] then do
        return "value"; end end 
     if ___conditional___ == 1--[[ Field_type ]] then do
        return "type"; end end 
     if ___conditional___ == 2--[[ Field_typext ]] then do
        return "extension constructor"; end end 
     if ___conditional___ == 3--[[ Field_module ]] then do
        return "module"; end end 
     if ___conditional___ == 4--[[ Field_modtype ]] then do
        return "module type"; end end 
     if ___conditional___ == 5--[[ Field_class ]] then do
        return "class"; end end 
     if ___conditional___ == 6--[[ Field_classtype ]] then do
        return "class type"; end end 
    
  end
end end

function item_ident_name(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Sig_value ]] then do
        id = param[0];
        return --[[ tuple ]]{
                id,
                param[1].val_loc,
                --[[ Field_value ]]Block.__(0, {id.name})
              }; end end 
     if ___conditional___ == 1--[[ Sig_type ]] then do
        id_1 = param[0];
        return --[[ tuple ]]{
                id_1,
                param[1].type_loc,
                --[[ Field_type ]]Block.__(1, {id_1.name})
              }; end end 
     if ___conditional___ == 2--[[ Sig_typext ]] then do
        id_2 = param[0];
        return --[[ tuple ]]{
                id_2,
                param[1].ext_loc,
                --[[ Field_typext ]]Block.__(2, {id_2.name})
              }; end end 
     if ___conditional___ == 3--[[ Sig_module ]] then do
        id_3 = param[0];
        return --[[ tuple ]]{
                id_3,
                param[1].md_loc,
                --[[ Field_module ]]Block.__(3, {id_3.name})
              }; end end 
     if ___conditional___ == 4--[[ Sig_modtype ]] then do
        id_4 = param[0];
        return --[[ tuple ]]{
                id_4,
                param[1].mtd_loc,
                --[[ Field_modtype ]]Block.__(4, {id_4.name})
              }; end end 
     if ___conditional___ == 5--[[ Sig_class ]] then do
        id_5 = param[0];
        return --[[ tuple ]]{
                id_5,
                param[1].cty_loc,
                --[[ Field_class ]]Block.__(5, {id_5.name})
              }; end end 
     if ___conditional___ == 6--[[ Sig_class_type ]] then do
        id_6 = param[0];
        return --[[ tuple ]]{
                id_6,
                param[1].clty_loc,
                --[[ Field_classtype ]]Block.__(6, {id_6.name})
              }; end end 
    
  end
end end

function is_runtime_component(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Sig_value ]] then do
        tmp = param[1].val_kind;
        if (typeof tmp == "number" or tmp.tag) then do
          return true;
        end else do
          return false;
        end end  end end 
     if ___conditional___ == 1--[[ Sig_type ]]
     or ___conditional___ == 4--[[ Sig_modtype ]]
     or ___conditional___ == 6--[[ Sig_class_type ]] then do
        return false; end end 
    return true;
      
  end
end end

function modtypes(env, cxt, subst, mty1, mty2) do
  xpcall(function() do
    return try_modtypes(env, cxt, subst, mty1, mty2);
  end end,function(raw_err) do
    err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err == Dont_match_1) then do
      error({
        __Error_5,
        --[[ :: ]]{
          --[[ tuple ]]{
            cxt,
            env,
            --[[ Module_types ]]Block.__(4, {
                mty1,
                modtype(subst, mty2)
              })
          },
          --[[ [] ]]0
        }
      })
    end
     end 
    if (err[0] == __Error_5) then do
      if (mty1.tag == --[[ Mty_alias ]]3) then do
        error(err)
      end else if (mty2.tag == --[[ Mty_alias ]]3) then do
        error(err)
      end else do
        error({
          __Error_5,
          --[[ :: ]]{
            --[[ tuple ]]{
              cxt,
              env,
              --[[ Module_types ]]Block.__(4, {
                  mty1,
                  modtype(subst, mty2)
                })
            },
            err[1]
          }
        })
      end end  end 
    end else do
      error(err)
    end end 
  end end)
end end

function try_modtypes(env, cxt, subst, _mty1, mty2) do
  while(true) do
    mty1 = _mty1;
    local ___conditional___=(mty1.tag | 0);
    do
       if ___conditional___ == 0--[[ Mty_ident ]] then do
          p1 = mty1[0];
          if (may_expand_module_path(env, p1)) then do
            _mty1 = expand_module_path(env, cxt, p1);
            ::continue:: ;
          end
           end  end else 
       if ___conditional___ == 1--[[ Mty_signature ]] then do
          local ___conditional___=(mty2.tag | 0);
          do
             if ___conditional___ == 0--[[ Mty_ident ]]
             or ___conditional___ == 1--[[ Mty_signature ]] then do
                return signatures(env, cxt, subst, mty1[0], mty2[0]); end end 
             if ___conditional___ == 2--[[ Mty_functor ]]
             or ___conditional___ == 3--[[ Mty_alias ]] then do
                error(Dont_match_1) end end 
            
          end end else 
       if ___conditional___ == 2--[[ Mty_functor ]] then do
          match = mty1[1];
          param1 = mty1[0];
          if (match ~= undefined) then do
            local ___conditional___=(mty2.tag | 0);
            do
               if ___conditional___ == 0--[[ Mty_ident ]]
               or ___conditional___ == 2--[[ Mty_functor ]] then do
                  match_1 = mty2[1];
                  if (match_1 ~= undefined) then do
                    arg2$prime = modtype(subst, match_1);
                    cc_arg = modtypes(env, --[[ :: ]]{
                          --[[ Arg ]]Block.__(2, {param1}),
                          cxt
                        }, identity, arg2$prime, match);
                    cc_res = modtypes(add_module_1(undefined, param1, arg2$prime, env), --[[ :: ]]{
                          --[[ Body ]]Block.__(3, {param1}),
                          cxt
                        }, add_module(mty2[0], --[[ Pident ]]Block.__(0, {param1}), subst), mty1[2], mty2[2]);
                    if (typeof cc_arg == "number" and typeof cc_res == "number") then do
                      return --[[ Tcoerce_none ]]0;
                    end else do
                      return --[[ Tcoerce_functor ]]Block.__(1, {
                                cc_arg,
                                cc_res
                              });
                    end end 
                  end else do
                    error(Dont_match_1)
                  end end  end end 
               if ___conditional___ == 1--[[ Mty_signature ]]
               or ___conditional___ == 3--[[ Mty_alias ]] then do
                  error(Dont_match_1) end end 
              
            end
          end else do
            local ___conditional___=(mty2.tag | 0);
            do
               if ___conditional___ == 0--[[ Mty_ident ]]
               or ___conditional___ == 2--[[ Mty_functor ]] then do
                  if (mty2[1] ~= undefined) then do
                    error(Dont_match_1)
                  end
                   end 
                  cc = modtypes(env, --[[ :: ]]{
                        --[[ Body ]]Block.__(3, {param1}),
                        cxt
                      }, subst, mty1[2], mty2[2]);
                  if (typeof cc == "number") then do
                    return --[[ Tcoerce_none ]]0;
                  end else do
                    return --[[ Tcoerce_functor ]]Block.__(1, {
                              --[[ Tcoerce_none ]]0,
                              cc
                            });
                  end end  end end 
               if ___conditional___ == 1--[[ Mty_signature ]]
               or ___conditional___ == 3--[[ Mty_alias ]] then do
                  error(Dont_match_1) end end 
              
            end
          end end  end else 
       if ___conditional___ == 3--[[ Mty_alias ]] then do
          p1_1 = mty1[0];
          if (mty2.tag == --[[ Mty_alias ]]3) then do
            p2 = mty2[0];
            if (is_functor_arg(p2, env)) then do
              error({
                __Error_5,
                --[[ :: ]]{
                  --[[ tuple ]]{
                    cxt,
                    env,
                    --[[ Invalid_module_alias ]]Block.__(11, {p2})
                  },
                  --[[ [] ]]0
                }
              })
            end
             end 
            if (same(p1_1, p2)) then do
              return --[[ Tcoerce_none ]]0;
            end else do
              p1_2 = normalize_path_1(undefined, env, p1_1);
              p2_1 = normalize_path_1(undefined, env, module_path(subst, p2));
              if (same(p1_2, p2_1)) then do
                return --[[ Tcoerce_none ]]0;
              end else do
                error(Dont_match_1)
              end end 
            end end 
          end else do
            p1_3;
            xpcall(function() do
              p1_3 = normalize_path_1(none, env, p1_1);
            end end,function(raw_exn) do
              exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn[0] == __Error_2) then do
                match_2 = exn[1];
                if (match_2.tag == --[[ Missing_module ]]3) then do
                  error({
                    __Error_5,
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        cxt,
                        env,
                        --[[ Unbound_module_path ]]Block.__(10, {match_2[2]})
                      },
                      --[[ [] ]]0
                    }
                  })
                end else do
                  error(exn)
                end end 
              end else do
                error(exn)
              end end 
            end end)
            mty1_1 = strengthen_1(env, expand_module_alias(env, cxt, p1_3), p1_3);
            return --[[ Tcoerce_alias ]]Block.__(3, {
                      p1_3,
                      modtypes(env, cxt, subst, mty1_1, mty2)
                    });
          end end  end end end end end end end end 
      
    end
    if (mty2.tag) then do
      error(Dont_match_1)
    end else do
      env_1 = env;
      cxt_1 = cxt;
      mty1_2 = mty1;
      mty2_1 = modtype(subst, mty2);
      if (not mty1_2.tag) then do
        if (mty2_1.tag) then do
          error({
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "includemod.ml",
              275,
              6
            }
          })
        end else if (same(mty1_2[0], mty2_1[0])) then do
          return --[[ Tcoerce_none ]]0;
        end
         end  end 
      end
       end 
      if (mty2_1.tag) then do
        error({
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "includemod.ml",
            275,
            6
          }
        })
      end else do
        return try_modtypes(env_1, cxt_1, identity, mty1_2, expand_module_path(env_1, cxt_1, mty2_1[0]));
      end end 
    end end 
  end;
end end

function signatures(env, cxt, subst, sig1, sig2) do
  new_env = add_signature(sig1, in_signature(env));
  match = List.fold_left((function(param, item) do
          pos = param[1];
          l = param[0];
          if (item.tag == --[[ Sig_module ]]3) then do
            return --[[ tuple ]]{
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        item[0],
                        pos,
                        --[[ Tcoerce_none ]]0
                      },
                      l
                    },
                    pos + 1 | 0
                  };
          end else do
            return --[[ tuple ]]{
                    l,
                    is_runtime_component(item) and pos + 1 | 0 or pos
                  };
          end end 
        end end), --[[ tuple ]]{
        --[[ [] ]]0,
        0
      }, sig1);
  id_pos_list = match[0];
  build_component_table = function(_pos, _tbl, _param) do
    while(true) do
      param = _param;
      tbl = _tbl;
      pos = _pos;
      if (param) then do
        item = param[0];
        match = item_ident_name(item);
        nextpos = is_runtime_component(item) and pos + 1 | 0 or pos;
        _param = param[1];
        _tbl = add_5(match[2], --[[ tuple ]]{
              match[0],
              item,
              pos
            }, tbl);
        _pos = nextpos;
        ::continue:: ;
      end else do
        return --[[ tuple ]]{
                pos,
                tbl
              };
      end end 
    end;
  end end;
  match_1 = build_component_table(0, --[[ Empty ]]0, sig1);
  comps1 = match_1[1];
  len1 = match_1[0];
  len2 = List.fold_left((function(n, i) do
          if (is_runtime_component(i)) then do
            return n + 1 | 0;
          end else do
            return n;
          end end 
        end end), 0, sig2);
  pair_components = function(subst, paired, _unpaired, _param) do
    while(true) do
      param = _param;
      unpaired = _unpaired;
      if (param) then do
        rem = param[1];
        item2 = param[0];
        match = item_ident_name(item2);
        name2 = match[2];
        id2 = match[0];
        match_1;
        if (item2.tag == --[[ Sig_type ]]1 and not (item2[1].type_manifest ~= undefined or name2.tag ~= --[[ Field_type ]]1)) then do
          s = name2[0];
          l = #s;
          match_1 = l >= 4 and __String.sub(s, l - 4 | 0, 4) == "#row" and --[[ tuple ]]{
              --[[ Field_type ]]Block.__(1, {__String.sub(s, 0, #s - 4 | 0)}),
              false
            } or --[[ tuple ]]{
              name2,
              true
            };
        end else do
          match_1 = --[[ tuple ]]{
            name2,
            true
          };
        end end 
        name2_1 = match_1[0];
        xpcall(function() do
          match_2 = find_2(name2_1, comps1);
          id1 = match_2[0];
          new_subst;
          local ___conditional___=(item2.tag | 0);
          do
             if ___conditional___ == 1--[[ Sig_type ]] then do
                new_subst = add_type(id2, --[[ Pident ]]Block.__(0, {id1}), subst); end else 
             if ___conditional___ == 3--[[ Sig_module ]] then do
                new_subst = add_module(id2, --[[ Pident ]]Block.__(0, {id1}), subst); end else 
             if ___conditional___ == 4--[[ Sig_modtype ]] then do
                new_subst = add_modtype(id2, --[[ Mty_ident ]]Block.__(0, {--[[ Pident ]]Block.__(0, {id1})}), subst); end else 
             end end end end end end
            new_subst = subst;
              
          end
          return pair_components(new_subst, --[[ :: ]]{
                      --[[ tuple ]]{
                        match_2[1],
                        item2,
                        match_2[2]
                      },
                      paired
                    }, unpaired, rem);
        end end,function(exn) do
          if (exn == Caml_builtin_exceptions.not_found) then do
            unpaired_1 = match_1[1] and --[[ :: ]]{
                --[[ tuple ]]{
                  cxt,
                  env,
                  --[[ Missing_field ]]Block.__(0, {
                      id2,
                      match[1],
                      kind_of_field_desc(name2_1)
                    })
                },
                unpaired
              } or unpaired;
            _param = rem;
            _unpaired = unpaired_1;
            ::continue:: ;
          end else do
            error(exn)
          end end 
        end end)
      end else do
        if (unpaired) then do
          error({
            __Error_5,
            unpaired
          })
        end
         end 
        cc = signature_components(env, new_env, cxt, subst, List.rev(paired));
        if (len1 == len2) then do
          cc_1 = cc;
          id_pos_list_1 = id_pos_list;
          is_identity_coercion = function(_pos, _param) do
            while(true) do
              param = _param;
              pos = _pos;
              if (param) then do
                match = param[0];
                if (match[0] == pos and match[1] == --[[ Tcoerce_none ]]0) then do
                  _param = param[1];
                  _pos = pos + 1 | 0;
                  ::continue:: ;
                end else do
                  return false;
                end end 
              end else do
                return true;
              end end 
            end;
          end end;
          if (is_identity_coercion(0, cc_1)) then do
            return --[[ Tcoerce_none ]]0;
          end else do
            return --[[ Tcoerce_structure ]]Block.__(0, {
                      cc_1,
                      id_pos_list_1
                    });
          end end 
        end else do
          return --[[ Tcoerce_structure ]]Block.__(0, {
                    cc,
                    id_pos_list
                  });
        end end 
      end end 
    end;
  end end;
  return pair_components(subst, --[[ [] ]]0, --[[ [] ]]0, sig2);
end end

function signature_components(old_env, env, cxt, subst, paired) do
  comps_rec = function(rem) do
    return signature_components(old_env, env, cxt, subst, rem);
  end end;
  if (paired) then do
    match = paired[0];
    match_1 = match[0];
    local ___conditional___=(match_1.tag | 0);
    do
       if ___conditional___ == 0--[[ Sig_value ]] then do
          match_2 = match[1];
          if (not match_2.tag) then do
            rem = paired[1];
            pos = match[2];
            valdecl2 = match_2[1];
            cc = value_descriptions(env, cxt, subst, match_1[0], match_1[1], valdecl2);
            match_3 = valdecl2.val_kind;
            if (typeof match_3 == "number" or match_3.tag) then do
              return --[[ :: ]]{
                      --[[ tuple ]]{
                        pos,
                        cc
                      },
                      comps_rec(rem)
                    };
            end else do
              return comps_rec(rem);
            end end 
          end
           end  end else 
       if ___conditional___ == 1--[[ Sig_type ]] then do
          match_4 = match[1];
          if (match_4.tag == --[[ Sig_type ]]1) then do
            type_declarations_2(env, Caml_option.some(old_env), cxt, subst, match_1[0], match_1[1], match_4[1]);
            return comps_rec(paired[1]);
          end
           end  end else 
       if ___conditional___ == 2--[[ Sig_typext ]] then do
          match_5 = match[1];
          if (match_5.tag == --[[ Sig_typext ]]2) then do
            extension_constructors_1(env, cxt, subst, match_1[0], match_1[1], match_5[1]);
            return --[[ :: ]]{
                    --[[ tuple ]]{
                      match[2],
                      --[[ Tcoerce_none ]]0
                    },
                    comps_rec(paired[1])
                  };
          end
           end  end else 
       if ___conditional___ == 3--[[ Sig_module ]] then do
          match_6 = match[1];
          if (match_6.tag == --[[ Sig_module ]]3) then do
            id1 = match_1[0];
            cc_1 = modtypes(env, --[[ :: ]]{
                  --[[ Module ]]Block.__(0, {id1}),
                  cxt
                }, subst, strengthen_1(env, match_1[1].md_type, --[[ Pident ]]Block.__(0, {id1})), match_6[1].md_type);
            return --[[ :: ]]{
                    --[[ tuple ]]{
                      match[2],
                      cc_1
                    },
                    comps_rec(paired[1])
                  };
          end
           end  end else 
       if ___conditional___ == 4--[[ Sig_modtype ]] then do
          match_7 = match[1];
          if (match_7.tag == --[[ Sig_modtype ]]4) then do
            modtype_infos(env, cxt, subst, match_1[0], match_1[1], match_7[1]);
            return comps_rec(paired[1]);
          end
           end  end else 
       if ___conditional___ == 5--[[ Sig_class ]] then do
          match_8 = match[1];
          if (match_8.tag == --[[ Sig_class ]]5) then do
            class_declarations_1(old_env, env, cxt, subst, match_1[0], match_1[1], match_8[1]);
            return --[[ :: ]]{
                    --[[ tuple ]]{
                      match[2],
                      --[[ Tcoerce_none ]]0
                    },
                    comps_rec(paired[1])
                  };
          end
           end  end else 
       if ___conditional___ == 6--[[ Sig_class_type ]] then do
          match_9 = match[1];
          if (match_9.tag == --[[ Sig_class_type ]]6) then do
            class_type_declarations_1(old_env, env, cxt, subst, match_1[0], match_1[1], match_9[1]);
            return comps_rec(paired[1]);
          end
           end  end else 
       end end end end end end end end end end end end end end
      
    end
  end else do
    return --[[ [] ]]0;
  end end 
  error({
    Caml_builtin_exceptions.assert_failure,
    --[[ tuple ]]{
      "includemod.ml",
      400,
      6
    }
  })
end end

function modtype_infos(env, cxt, subst, id, info1, info2) do
  info2_1 = modtype_declaration(subst, info2);
  cxt$prime_000 = --[[ Modtype ]]Block.__(1, {id});
  cxt$prime = --[[ :: ]]{
    cxt$prime_000,
    cxt
  };
  xpcall(function() do
    match = info1.mtd_type;
    match_1 = info2_1.mtd_type;
    if (match ~= undefined) then do
      if (match_1 ~= undefined) then do
        return check_modtype_equiv(env, cxt$prime, match, match_1);
      end else do
        return --[[ () ]]0;
      end end 
    end else if (match_1 ~= undefined) then do
      return check_modtype_equiv(env, cxt$prime, --[[ Mty_ident ]]Block.__(0, {--[[ Pident ]]Block.__(0, {id})}), match_1);
    end else do
      return --[[ () ]]0;
    end end  end 
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == __Error_5) then do
      error({
        __Error_5,
        --[[ :: ]]{
          --[[ tuple ]]{
            cxt,
            env,
            --[[ Modtype_infos ]]Block.__(5, {
                id,
                info1,
                info2_1
              })
          },
          exn[1]
        }
      })
    end
     end 
    error(exn)
  end end)
end end

function check_modtype_equiv(env, cxt, mty1, mty2) do
  match = modtypes(env, cxt, identity, mty1, mty2);
  match_1 = modtypes(env, cxt, identity, mty2, mty1);
  if (typeof match == "number" and typeof match_1 == "number") then do
    return --[[ () ]]0;
  end
   end 
  error({
    __Error_5,
    --[[ :: ]]{
      --[[ tuple ]]{
        cxt,
        env,
        --[[ Modtype_permutation ]]0
      },
      --[[ [] ]]0
    }
  })
end end

function check_modtype_inclusion_1(env, mty1, path1, mty2) do
  xpcall(function() do
    modtypes(env, --[[ [] ]]0, identity, strengthen_1(env, mty1, path1), mty2);
    return --[[ () ]]0;
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == __Error_5) then do
      error(Caml_builtin_exceptions.not_found)
    end
     end 
    error(exn)
  end end)
end end

check_modtype_inclusion.contents = check_modtype_inclusion_1;

function compunit(env, impl_name, impl_sig, intf_name, intf_sig) do
  xpcall(function() do
    return signatures(env, --[[ [] ]]0, identity, impl_sig, intf_sig);
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == __Error_5) then do
      error({
        __Error_5,
        --[[ :: ]]{
          --[[ tuple ]]{
            --[[ [] ]]0,
            empty,
            --[[ Interface_mismatch ]]Block.__(6, {
                impl_name,
                intf_name
              })
          },
          exn[1]
        }
      })
    end
     end 
    error(exn)
  end end)
end end

function modtypes_1(env, mty1, mty2) do
  return modtypes(env, --[[ [] ]]0, identity, mty1, mty2);
end end

function type_declarations_3(env, id, decl1, decl2) do
  return type_declarations_2(env, undefined, --[[ [] ]]0, identity, id, decl1, decl2);
end end

function show_loc(msg, ppf, loc) do
  pos = loc.loc_start;
  if (List.mem(pos.pos_fname, --[[ :: ]]{
          "",
          --[[ :: ]]{
            "_none_",
            --[[ :: ]]{
              "//toplevel//",
              --[[ [] ]]0
            }
          }
        })) then do
    return --[[ () ]]0;
  end else do
    return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_lit ]]Block.__(17, {
                        --[[ Force_newline ]]3,
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      "<2>",
                                      --[[ End_of_format ]]0
                                    }),
                                  "<2>"
                                }}),
                            --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                    --[[ ":" ]]58,
                                    --[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Break ]]Block.__(0, {
                                            "@ ",
                                            1,
                                            0
                                          }),
                                        --[[ String ]]Block.__(2, {
                                            --[[ No_padding ]]0,
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Close_box ]]0,
                                                --[[ End_of_format ]]0
                                              })
                                          })
                                      })
                                  })})
                          })
                      }),
                    "@\n@[<2>%a:@ %s@]"
                  }), print_loc, loc, msg);
  end end 
end end

function show_locs(ppf, param) do
  show_loc("Expected declaration", ppf, param[1]);
  return show_loc("Actual declaration", ppf, param[0]);
end end

function include_err_1(ppf, param) do
  if (typeof param == "number") then do
    return Format.fprintf(ppf, --[[ Format ]]{
                --[[ String_literal ]]Block.__(11, {
                    "Illegal permutation of structure fields",
                    --[[ End_of_format ]]0
                  }),
                "Illegal permutation of structure fields"
              });
  end else do
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ == 0--[[ Missing_field ]] then do
          Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ String_literal ]]Block.__(11, {
                        "The ",
                        --[[ String ]]Block.__(2, {
                            --[[ No_padding ]]0,
                            --[[ String_literal ]]Block.__(11, {
                                " `",
                                --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                        "' is required but not provided",
                                        --[[ End_of_format ]]0
                                      })})
                              })
                          })
                      }),
                    "The %s `%a' is required but not provided"
                  }), param[2], ident_3, param[0]);
          return show_loc("Expected declaration", ppf, param[1]); end end 
       if ___conditional___ == 1--[[ Value_descriptions ]] then do
          d2 = param[2];
          d1 = param[1];
          id = param[0];
          Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<hv 2>",
                                  --[[ End_of_format ]]0
                                }),
                              "<hv 2>"
                            }}),
                        --[[ String_literal ]]Block.__(11, {
                            "Values do not match:",
                            --[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@ ",
                                    1,
                                    0
                                  }),
                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Break ]]Block.__(0, {
                                            "@;<1 -2>",
                                            1,
                                            -2
                                          }),
                                        --[[ String_literal ]]Block.__(11, {
                                            "is not included in",
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Break ]]Block.__(0, {
                                                    "@ ",
                                                    1,
                                                    0
                                                  }),
                                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                        --[[ Close_box ]]0,
                                                        --[[ End_of_format ]]0
                                                      })})
                                              })
                                          })
                                      })})
                              })
                          })
                      }),
                    "@[<hv 2>Values do not match:@ %a@;<1 -2>is not included in@ %a@]"
                  }), (function(param, param_1) do
                  return value_description_1(id, param, param_1);
                end end), d1, (function(param, param_1) do
                  return value_description_1(id, param, param_1);
                end end), d2);
          return show_locs(ppf, --[[ tuple ]]{
                      d1.val_loc,
                      d2.val_loc
                    }); end end 
       if ___conditional___ == 2--[[ Type_declarations ]] then do
          d2_1 = param[2];
          d1_1 = param[1];
          id_1 = param[0];
          return Curry.app(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<v>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<v>"
                                  }}),
                              --[[ Formatting_gen ]]Block.__(18, {
                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                        --[[ String_literal ]]Block.__(11, {
                                            "<hv>",
                                            --[[ End_of_format ]]0
                                          }),
                                        "<hv>"
                                      }}),
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Char_literal ]]Block.__(12, {
                                          --[[ ":" ]]58,
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@;<1 2>",
                                                  1,
                                                  2
                                                }),
                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Break ]]Block.__(0, {
                                                          "@ ",
                                                          1,
                                                          0
                                                        }),
                                                      --[[ String ]]Block.__(2, {
                                                          --[[ No_padding ]]0,
                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Break ]]Block.__(0, {
                                                                  "@;<1 2>",
                                                                  1,
                                                                  2
                                                                }),
                                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Close_box ]]0,
                                                                      --[[ Alpha ]]Block.__(15, {--[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Close_box ]]0,
                                                                                  --[[ End_of_format ]]0
                                                                                })})})
                                                                    })})
                                                            })
                                                        })
                                                    })})
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[<v>@[<hv>%s:@;<1 2>%a@ %s@;<1 2>%a@]%a%a@]"
                        }), {
                      "Type declarations do not match",
                      (function(param, param_1) do
                          return type_declaration_1(id_1, param, param_1);
                        end end),
                      d1_1,
                      "is not included in",
                      (function(param, param_1) do
                          return type_declaration_1(id_1, param, param_1);
                        end end),
                      d2_1,
                      show_locs,
                      --[[ tuple ]]{
                        d1_1.type_loc,
                        d2_1.type_loc
                      },
                      (function(param) do
                          return report_type_mismatch("the first", "the second", "declaration", param);
                        end end),
                      param[3]
                    }); end end 
       if ___conditional___ == 3--[[ Extension_constructors ]] then do
          x2 = param[2];
          x1 = param[1];
          id_2 = param[0];
          Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<hv 2>",
                                  --[[ End_of_format ]]0
                                }),
                              "<hv 2>"
                            }}),
                        --[[ String_literal ]]Block.__(11, {
                            "Extension declarations do not match:",
                            --[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@ ",
                                    1,
                                    0
                                  }),
                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Break ]]Block.__(0, {
                                            "@;<1 -2>",
                                            1,
                                            -2
                                          }),
                                        --[[ String_literal ]]Block.__(11, {
                                            "is not included in",
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Break ]]Block.__(0, {
                                                    "@ ",
                                                    1,
                                                    0
                                                  }),
                                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                        --[[ Close_box ]]0,
                                                        --[[ End_of_format ]]0
                                                      })})
                                              })
                                          })
                                      })})
                              })
                          })
                      }),
                    "@[<hv 2>Extension declarations do not match:@ %a@;<1 -2>is not included in@ %a@]"
                  }), (function(param, param_1) do
                  return extension_constructor_1(id_2, param, param_1);
                end end), x1, (function(param, param_1) do
                  return extension_constructor_1(id_2, param, param_1);
                end end), x2);
          return show_locs(ppf, --[[ tuple ]]{
                      x1.ext_loc,
                      x2.ext_loc
                    }); end end 
       if ___conditional___ == 4--[[ Module_types ]] then do
          return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hv 2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hv 2>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "Modules do not match:",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@;<1 -2>",
                                                  1,
                                                  -2
                                                }),
                                              --[[ String_literal ]]Block.__(11, {
                                                  "is not included in",
                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Break ]]Block.__(0, {
                                                          "@ ",
                                                          1,
                                                          0
                                                        }),
                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Close_box ]]0,
                                                              --[[ End_of_format ]]0
                                                            })})
                                                    })
                                                })
                                            })})
                                    })
                                })
                            }),
                          "@[<hv 2>Modules do not match:@ %a@;<1 -2>is not included in@ %a@]"
                        }), modtype_1, param[0], modtype_1, param[1]); end end 
       if ___conditional___ == 5--[[ Modtype_infos ]] then do
          id_3 = param[0];
          return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hv 2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hv 2>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "Module type declarations do not match:",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@;<1 -2>",
                                                  1,
                                                  -2
                                                }),
                                              --[[ String_literal ]]Block.__(11, {
                                                  "does not match",
                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Break ]]Block.__(0, {
                                                          "@ ",
                                                          1,
                                                          0
                                                        }),
                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Close_box ]]0,
                                                              --[[ End_of_format ]]0
                                                            })})
                                                    })
                                                })
                                            })})
                                    })
                                })
                            }),
                          "@[<hv 2>Module type declarations do not match:@ %a@;<1 -2>does not match@ %a@]"
                        }), (function(param, param_1) do
                        return modtype_declaration_1(id_3, param, param_1);
                      end end), param[1], (function(param, param_1) do
                        return modtype_declaration_1(id_3, param, param_1);
                      end end), param[2]); end end 
       if ___conditional___ == 6--[[ Interface_mismatch ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "The implementation ",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ String_literal ]]Block.__(11, {
                                              "does not match the interface ",
                                              --[[ String ]]Block.__(2, {
                                                  --[[ No_padding ]]0,
                                                  --[[ Char_literal ]]Block.__(12, {
                                                      --[[ ":" ]]58,
                                                      --[[ End_of_format ]]0
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[The implementation %s@ does not match the interface %s:"
                        }), param[0], param[1]); end end 
       if ___conditional___ == 7--[[ Class_type_declarations ]] then do
          id_4 = param[0];
          return Curry._6(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hv 2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hv 2>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "Class type declarations do not match:",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@;<1 -2>",
                                                  1,
                                                  -2
                                                }),
                                              --[[ String_literal ]]Block.__(11, {
                                                  "does not match",
                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Break ]]Block.__(0, {
                                                          "@ ",
                                                          1,
                                                          0
                                                        }),
                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Close_box ]]0,
                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                  --[[ Break ]]Block.__(0, {
                                                                      "@ ",
                                                                      1,
                                                                      0
                                                                    }),
                                                                  --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                                })
                                                            })})
                                                    })
                                                })
                                            })})
                                    })
                                })
                            }),
                          "@[<hv 2>Class type declarations do not match:@ %a@;<1 -2>does not match@ %a@]@ %a"
                        }), (function(param, param_1) do
                        return cltype_declaration_1(id_4, param, param_1);
                      end end), param[1], (function(param, param_1) do
                        return cltype_declaration_1(id_4, param, param_1);
                      end end), param[2], report_error_3, param[3]); end end 
       if ___conditional___ == 8--[[ Class_declarations ]] then do
          id_5 = param[0];
          return Curry._6(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hv 2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hv 2>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "Class declarations do not match:",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@;<1 -2>",
                                                  1,
                                                  -2
                                                }),
                                              --[[ String_literal ]]Block.__(11, {
                                                  "does not match",
                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Break ]]Block.__(0, {
                                                          "@ ",
                                                          1,
                                                          0
                                                        }),
                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Close_box ]]0,
                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                  --[[ Break ]]Block.__(0, {
                                                                      "@ ",
                                                                      1,
                                                                      0
                                                                    }),
                                                                  --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                                })
                                                            })})
                                                    })
                                                })
                                            })})
                                    })
                                })
                            }),
                          "@[<hv 2>Class declarations do not match:@ %a@;<1 -2>does not match@ %a@]@ %a"
                        }), (function(param, param_1) do
                        return class_declaration_1(id_5, param, param_1);
                      end end), param[1], (function(param, param_1) do
                        return class_declaration_1(id_5, param, param_1);
                      end end), param[2], report_error_3, param[3]); end end 
       if ___conditional___ == 9--[[ Unbound_modtype_path ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "Unbound module type ",
                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                            }),
                          "Unbound module type %a"
                        }), path, param[0]); end end 
       if ___conditional___ == 10--[[ Unbound_module_path ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "Unbound module ",
                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                            }),
                          "Unbound module %a"
                        }), path, param[0]); end end 
       if ___conditional___ == 11--[[ Invalid_module_alias ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "Module ",
                              --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                      " cannot be aliased",
                                      --[[ End_of_format ]]0
                                    })})
                            }),
                          "Module %a cannot be aliased"
                        }), path, param[0]); end end 
      
    end
  end end 
end end

function context(ppf, param) do
  if (param) then do
    match = param[0];
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 0--[[ Module ]] then do
          return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<2>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "module ",
                                  --[[ Alpha ]]Block.__(15, {--[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Close_box ]]0,
                                              --[[ End_of_format ]]0
                                            })})})
                                })
                            }),
                          "@[<2>module %a%a@]"
                        }), ident_3, match[0], args, param[1]); end end 
       if ___conditional___ == 1--[[ Modtype ]] then do
          return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<2>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "module type ",
                                  --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                          " =",
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@ ",
                                                  1,
                                                  0
                                                }),
                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Close_box ]]0,
                                                      --[[ End_of_format ]]0
                                                    })})
                                            })
                                        })})
                                })
                            }),
                          "@[<2>module type %a =@ %a@]"
                        }), ident_3, match[0], context_mty, param[1]); end end 
       if ___conditional___ == 2--[[ Arg ]] then do
          return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "functor (",
                              --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                      " : ",
                                      --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                              ") -> ...",
                                              --[[ End_of_format ]]0
                                            })})
                                    })})
                            }),
                          "functor (%a : %a) -> ..."
                        }), ident_3, match[0], context_mty, param[1]); end end 
       if ___conditional___ == 3--[[ Body ]] then do
          return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "functor (",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ String_literal ]]Block.__(11, {
                                      ") ->",
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                        })
                                    })
                                })
                            }),
                          "functor (%s) ->@ %a"
                        }), argname(match[0]), context_mty, param[1]); end end 
      
    end
  end else do
    return Format.fprintf(ppf, --[[ Format ]]{
                --[[ String_literal ]]Block.__(11, {
                    "<here>",
                    --[[ End_of_format ]]0
                  }),
                "<here>"
              });
  end end 
end end

function context_mty(ppf, rem) do
  if (rem) then do
    local ___conditional___=(rem[0].tag | 0);
    do
       if ___conditional___ == 0--[[ Module ]]
       or ___conditional___ == 1--[[ Modtype ]]
       or ___conditional___ == 2--[[ Arg ]]
       or ___conditional___ == 3--[[ Body ]] then do
          return context(ppf, rem); end end 
      
    end
    return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<2>",
                                  --[[ End_of_format ]]0
                                }),
                              "<2>"
                            }}),
                        --[[ String_literal ]]Block.__(11, {
                            "sig",
                            --[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@ ",
                                    1,
                                    0
                                  }),
                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Break ]]Block.__(0, {
                                            "@;<1 -2>",
                                            1,
                                            -2
                                          }),
                                        --[[ String_literal ]]Block.__(11, {
                                            "end",
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Close_box ]]0,
                                                --[[ End_of_format ]]0
                                              })
                                          })
                                      })})
                              })
                          })
                      }),
                    "@[<2>sig@ %a@;<1 -2>end@]"
                  }), context, rem);
  end else do
    return context(ppf, rem);
  end end 
end end

function args(ppf, cxt) do
  if (cxt) then do
    match = cxt[0];
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 0--[[ Module ]]
       or ___conditional___ == 1--[[ Modtype ]]
       or ___conditional___ == 2--[[ Arg ]] then do
          return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Char_literal ]]Block.__(12, {
                              --[[ "(" ]]40,
                              --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                      " :",
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                                  ") : ...",
                                                  --[[ End_of_format ]]0
                                                })})
                                        })
                                    })})
                            }),
                          "(%a :@ %a) : ..."
                        }), ident_3, match[0], context_mty, cxt[1]); end end 
       if ___conditional___ == 3--[[ Body ]] then do
          return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Char_literal ]]Block.__(12, {
                              --[[ "(" ]]40,
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ Char_literal ]]Block.__(12, {
                                      --[[ ")" ]]41,
                                      --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                    })
                                })
                            }),
                          "(%s)%a"
                        }), argname(match[0]), args, cxt[1]); end end 
      
    end
  end
   end 
  return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                  --[[ String_literal ]]Block.__(11, {
                      " :",
                      --[[ Formatting_lit ]]Block.__(17, {
                          --[[ Break ]]Block.__(0, {
                              "@ ",
                              1,
                              0
                            }),
                          --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                        })
                    }),
                  " :@ %a"
                }), context_mty, cxt);
end end

function argname(x) do
  s = x.name;
  if (s == "*") then do
    return "";
  end else do
    return s;
  end end 
end end

function path_of_context(param) do
  if (param) then do
    match = param[0];
    if (match.tag) then do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "includemod.ml",
          573,
          9
        }
      })
    end else do
      _path = --[[ Pident ]]Block.__(0, {match[0]});
      _param = param[1];
      while(true) do
        param_1 = _param;
        path = _path;
        if (param_1) then do
          match_1 = param_1[0];
          if (match_1.tag) then do
            error({
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "includemod.ml",
                571,
                15
              }
            })
          end else do
            _param = param_1[1];
            _path = --[[ Pdot ]]Block.__(1, {
                path,
                match_1[0].name,
                -1
              });
            ::continue:: ;
          end end 
        end else do
          return path;
        end end 
      end;
    end end 
  end else do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "includemod.ml",
        573,
        9
      }
    })
  end end 
end end

function context_1(ppf, cxt) do
  if (cxt == --[[ [] ]]0) then do
    return --[[ () ]]0;
  end else if (List.for_all((function(param) do
            return param.tag and false or true;
          end end), cxt)) then do
    return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ String_literal ]]Block.__(11, {
                        "In module ",
                        --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                --[[ ":" ]]58,
                                --[[ Formatting_lit ]]Block.__(17, {
                                    --[[ Break ]]Block.__(0, {
                                        "@ ",
                                        1,
                                        0
                                      }),
                                    --[[ End_of_format ]]0
                                  })
                              })})
                      }),
                    "In module %a:@ "
                  }), path, path_of_context(cxt));
  end else do
    return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<hv 2>",
                                  --[[ End_of_format ]]0
                                }),
                              "<hv 2>"
                            }}),
                        --[[ String_literal ]]Block.__(11, {
                            "At position",
                            --[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@ ",
                                    1,
                                    0
                                  }),
                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Close_box ]]0,
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ End_of_format ]]0
                                          })
                                      })})
                              })
                          })
                      }),
                    "@[<hv 2>At position@ %a@]@ "
                  }), context, cxt);
  end end  end 
end end

function include_err_2(ppf, param) do
  err = param[2];
  cxt = param[0];
  return wrap_printing_env(param[1], (function(param) do
                return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                                --[[ Formatting_gen ]]Block.__(18, {
                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "<v>",
                                              --[[ End_of_format ]]0
                                            }),
                                          "<v>"
                                        }}),
                                    --[[ Alpha ]]Block.__(15, {--[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Close_box ]]0,
                                                --[[ End_of_format ]]0
                                              })})})
                                  }),
                                "@[<v>%a%a@]"
                              }), context_1, List.rev(cxt), include_err_1, err);
              end end));
end end

buffer = do
  contents: Bytes.empty
end;

function is_big(obj) do
  size = error_size.contents;
  if (size > 0) then do
    if (#buffer.contents < size) then do
      buffer.contents = Caml_bytes.caml_create_bytes(size);
    end
     end 
    xpcall(function() do
      Marshal.to_buffer(buffer.contents, 0, size, obj, --[[ [] ]]0);
      return false;
    end end,function(exn) do
      return true;
    end end)
  end else do
    return false;
  end end 
end end

function report_error_4(ppf, errs) do
  if (errs == --[[ [] ]]0) then do
    return --[[ () ]]0;
  end else do
    match = split_last(errs);
    pe = do
      contents: true
    end;
    print_errs = function(ppf) do
      return (function(param) do
          return List.iter((function(param) do
                        ppf_1 = ppf;
                        err = param;
                        if (is_big(err[2])) then do
                          if (pe.contents) then do
                            Format.fprintf(ppf_1, --[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      "...",
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ End_of_format ]]0
                                        })
                                    }),
                                  "...@ "
                                });
                            pe.contents = false;
                            return --[[ () ]]0;
                          end else do
                            return 0;
                          end end 
                        end else do
                          return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Break ]]Block.__(0, {
                                                      "@ ",
                                                      1,
                                                      0
                                                    }),
                                                  --[[ End_of_format ]]0
                                                })}),
                                          "%a@ "
                                        }), include_err_2, err);
                        end end 
                      end end), param);
        end end);
    end end;
    return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<v>",
                                  --[[ End_of_format ]]0
                                }),
                              "<v>"
                            }}),
                        --[[ Alpha ]]Block.__(15, {--[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                    --[[ Close_box ]]0,
                                    --[[ End_of_format ]]0
                                  })})})
                      }),
                    "@[<v>%a%a@]"
                  }), print_errs, match[0], include_err_2, match[1]);
  end end 
end end

register_error_of_exn((function(param) do
        if (param[0] == __Error_5) then do
          return error_of_printer_file(report_error_4, param[1]);
        end
         end 
      end end));

function get_location(ti) do
  local ___conditional___=(ti.tag | 0);
  do
     if ___conditional___ == 0--[[ Ti_pat ]] then do
        return ti[0].pat_loc; end end 
     if ___conditional___ == 1--[[ Ti_expr ]] then do
        return ti[0].exp_loc; end end 
     if ___conditional___ == 2--[[ Ti_class ]] then do
        return ti[0].cl_loc; end end 
     if ___conditional___ == 3--[[ Ti_mod ]] then do
        return ti[0].mod_loc; end end 
     if ___conditional___ == 4--[[ An_call ]]
     or ___conditional___ == 5--[[ An_ident ]] then do
        return ti[0]; end end 
    
  end
end end

annotations_1 = do
  contents: --[[ [] ]]0
end;

phrases = do
  contents: --[[ [] ]]0
end;

function record_2(ti) do
  if (annotations.contents and not get_location(ti).loc_ghost) then do
    annotations_1.contents = --[[ :: ]]{
      ti,
      annotations_1.contents
    };
    return --[[ () ]]0;
  end else do
    return 0;
  end end 
end end

function make_pat(desc, ty, tenv) do
  return do
          pat_desc: desc,
          pat_loc: none,
          pat_extra: --[[ [] ]]0,
          pat_type: ty,
          pat_env: tenv,
          pat_attributes: --[[ [] ]]0
        end;
end end

omega = make_pat(--[[ Tpat_any ]]0, none_2, empty);

extra_pat = make_pat(--[[ Tpat_var ]]Block.__(0, {
        create("+"),
        do
          txt: "+",
          loc: none
        end
      }), none_2, empty);

function omegas(i) do
  if (i <= 0) then do
    return --[[ [] ]]0;
  end else do
    return --[[ :: ]]{
            omega,
            omegas(i - 1 | 0)
          };
  end end 
end end

zero = make_pat(--[[ Tpat_constant ]]Block.__(2, {--[[ Const_int ]]Block.__(0, {0})}), none_2, empty);

function is_absent(tag, row) do
  return row_field(tag, row.contents) == --[[ Rabsent ]]0;
end end

function is_absent_pat(p) do
  match = p.pat_desc;
  if (typeof match == "number" or match.tag ~= --[[ Tpat_variant ]]5) then do
    return false;
  end else do
    return is_absent(match[0], match[2]);
  end end 
end end

function const_compare(x, y) do
  local ___conditional___=(x.tag | 0);
  do
     if ___conditional___ == 2--[[ Const_string ]] then do
        if (y.tag == --[[ Const_string ]]2) then do
          return Caml_primitive.caml_string_compare(x[0], y[0]);
        end else do
          return Caml_obj.caml_compare(x, y);
        end end  end end 
     if ___conditional___ == 3--[[ Const_float ]] then do
        if (y.tag == --[[ Const_float ]]3) then do
          return Caml_primitive.caml_float_compare(Caml_format.caml_float_of_string(x[0]), Caml_format.caml_float_of_string(y[0]));
        end else do
          return Caml_obj.caml_compare(x, y);
        end end  end end 
    return Caml_obj.caml_compare(x, y);
      
  end
end end

function records_args(l1, l2) do
  _r1 = --[[ [] ]]0;
  _r2 = --[[ [] ]]0;
  _l1 = l1;
  _l2 = l2;
  while(true) do
    l2_1 = _l2;
    l1_1 = _l1;
    r2 = _r2;
    r1 = _r1;
    if (l1_1) then do
      rem1 = l1_1[1];
      match = l1_1[0];
      p1 = match[2];
      lbl1 = match[1];
      if (l2_1) then do
        rem2 = l2_1[1];
        match_1 = l2_1[0];
        p2 = match_1[2];
        lbl2 = match_1[1];
        if (lbl1.lbl_pos < lbl2.lbl_pos) then do
          _l1 = rem1;
          _r2 = --[[ :: ]]{
            omega,
            r2
          };
          _r1 = --[[ :: ]]{
            p1,
            r1
          };
          ::continue:: ;
        end else if (lbl1.lbl_pos > lbl2.lbl_pos) then do
          _l2 = rem2;
          _r2 = --[[ :: ]]{
            p2,
            r2
          };
          _r1 = --[[ :: ]]{
            omega,
            r1
          };
          ::continue:: ;
        end else do
          _l2 = rem2;
          _l1 = rem1;
          _r2 = --[[ :: ]]{
            p2,
            r2
          };
          _r1 = --[[ :: ]]{
            p1,
            r1
          };
          ::continue:: ;
        end end  end 
      end else do
        _l2 = --[[ [] ]]0;
        _l1 = rem1;
        _r2 = --[[ :: ]]{
          omega,
          r2
        };
        _r1 = --[[ :: ]]{
          p1,
          r1
        };
        ::continue:: ;
      end end 
    end else if (l2_1) then do
      _l2 = l2_1[1];
      _l1 = --[[ [] ]]0;
      _r2 = --[[ :: ]]{
        l2_1[0][2],
        r2
      };
      _r1 = --[[ :: ]]{
        omega,
        r1
      };
      ::continue:: ;
    end else do
      return --[[ tuple ]]{
              List.rev(r1),
              List.rev(r2)
            };
    end end  end 
  end;
end end

function compat(_p, _q) do
  while(true) do
    q = _q;
    p = _p;
    match = p.pat_desc;
    match_1 = q.pat_desc;
    exit = 0;
    if (typeof match == "number") then do
      exit = 1;
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 1--[[ Tpat_alias ]] then do
            _p = match[0];
            ::continue:: ; end end 
         if ___conditional___ == 2--[[ Tpat_constant ]] then do
            if (typeof match_1 == "number") then do
              exit = 1;
            end else do
              local ___conditional___=(match_1.tag | 0);
              do
                 if ___conditional___ == 0--[[ Tpat_var ]]
                 or ___conditional___ == 1--[[ Tpat_alias ]] then do
                    exit = 1; end else 
                 if ___conditional___ == 2--[[ Tpat_constant ]] then do
                    return const_compare(match[0], match_1[0]) == 0; end end end end 
                 if ___conditional___ == 8--[[ Tpat_or ]] then do
                    exit = 2; end else 
                 end end
                exit = 3;
                  
              end
            end end  end else 
         if ___conditional___ == 3--[[ Tpat_tuple ]] then do
            if (typeof match_1 == "number") then do
              exit = 1;
            end else do
              local ___conditional___=(match_1.tag | 0);
              do
                 if ___conditional___ == 0--[[ Tpat_var ]]
                 or ___conditional___ == 1--[[ Tpat_alias ]] then do
                    exit = 1; end else 
                 if ___conditional___ == 3--[[ Tpat_tuple ]] then do
                    return compats(match[0], match_1[0]); end end end end 
                 if ___conditional___ == 8--[[ Tpat_or ]] then do
                    exit = 2; end else 
                 end end
                exit = 3;
                  
              end
            end end  end else 
         if ___conditional___ == 4--[[ Tpat_construct ]] then do
            if (typeof match_1 == "number") then do
              exit = 1;
            end else do
              local ___conditional___=(match_1.tag | 0);
              do
                 if ___conditional___ == 0--[[ Tpat_var ]]
                 or ___conditional___ == 1--[[ Tpat_alias ]] then do
                    exit = 1; end else 
                 if ___conditional___ == 4--[[ Tpat_construct ]] then do
                    if (equal_tag(match[1].cstr_tag, match_1[1].cstr_tag)) then do
                      return compats(match[2], match_1[2]);
                    end else do
                      return false;
                    end end  end end end end 
                 if ___conditional___ == 8--[[ Tpat_or ]] then do
                    exit = 2; end else 
                 end end
                exit = 3;
                  
              end
            end end  end else 
         if ___conditional___ == 5--[[ Tpat_variant ]] then do
            match_2 = match[1];
            l1 = match[0];
            if (match_2 ~= undefined) then do
              if (typeof match_1 == "number") then do
                exit = 1;
              end else do
                local ___conditional___=(match_1.tag | 0);
                do
                   if ___conditional___ == 0--[[ Tpat_var ]]
                   or ___conditional___ == 1--[[ Tpat_alias ]] then do
                      exit = 1; end else 
                   if ___conditional___ == 5--[[ Tpat_variant ]] then do
                      match_3 = match_1[1];
                      if (match_3 ~= undefined and l1 == match_1[0]) then do
                        _q = match_3;
                        _p = match_2;
                        ::continue:: ;
                      end else do
                        return false;
                      end end  end end end end 
                   if ___conditional___ == 8--[[ Tpat_or ]] then do
                      exit = 2; end else 
                   end end
                  exit = 3;
                    
                end
              end end 
            end else if (typeof match_1 == "number") then do
              exit = 1;
            end else do
              local ___conditional___=(match_1.tag | 0);
              do
                 if ___conditional___ == 0--[[ Tpat_var ]]
                 or ___conditional___ == 1--[[ Tpat_alias ]] then do
                    exit = 1; end else 
                 if ___conditional___ == 5--[[ Tpat_variant ]] then do
                    if (match_1[1] ~= undefined) then do
                      return false;
                    end else do
                      return l1 == match_1[0];
                    end end  end end end end 
                 if ___conditional___ == 8--[[ Tpat_or ]] then do
                    exit = 2; end else 
                 end end
                exit = 3;
                  
              end
            end end  end  end else 
         if ___conditional___ == 6--[[ Tpat_record ]] then do
            if (typeof match_1 == "number") then do
              exit = 1;
            end else do
              local ___conditional___=(match_1.tag | 0);
              do
                 if ___conditional___ == 0--[[ Tpat_var ]]
                 or ___conditional___ == 1--[[ Tpat_alias ]] then do
                    exit = 1; end else 
                 if ___conditional___ == 6--[[ Tpat_record ]] then do
                    match_4 = records_args(match[0], match_1[0]);
                    return compats(match_4[0], match_4[1]); end end end end 
                 if ___conditional___ == 8--[[ Tpat_or ]] then do
                    exit = 2; end else 
                 end end
                exit = 3;
                  
              end
            end end  end else 
         if ___conditional___ == 7--[[ Tpat_array ]] then do
            ps = match[0];
            if (typeof match_1 == "number") then do
              exit = 1;
            end else do
              local ___conditional___=(match_1.tag | 0);
              do
                 if ___conditional___ == 0--[[ Tpat_var ]]
                 or ___conditional___ == 1--[[ Tpat_alias ]] then do
                    exit = 1; end else 
                 if ___conditional___ == 7--[[ Tpat_array ]] then do
                    qs = match_1[0];
                    if (List.length(ps) == List.length(qs)) then do
                      return compats(ps, qs);
                    end else do
                      return false;
                    end end  end end end end 
                 if ___conditional___ == 8--[[ Tpat_or ]] then do
                    exit = 2; end else 
                 end end
                exit = 3;
                  
              end
            end end  end else 
         if ___conditional___ == 9--[[ Tpat_lazy ]] then do
            if (typeof match_1 == "number") then do
              exit = 1;
            end else do
              local ___conditional___=(match_1.tag | 0);
              do
                 if ___conditional___ == 0--[[ Tpat_var ]]
                 or ___conditional___ == 1--[[ Tpat_alias ]] then do
                    exit = 1; end else 
                 if ___conditional___ == 8--[[ Tpat_or ]] then do
                    exit = 2; end else 
                 if ___conditional___ == 9--[[ Tpat_lazy ]] then do
                    _q = match_1[0];
                    _p = match[0];
                    ::continue:: ; end end end end end end 
                exit = 3;
                  
              end
            end end  end else 
         end end end end end end end end end end end end end end
        exit = 1;
          
      end
    end end 
    local ___conditional___=(exit);
    do
       if ___conditional___ == 1 then do
          if (typeof match_1 == "number") then do
            return true;
          end else do
            local ___conditional___=(match_1.tag | 0);
            do
               if ___conditional___ == 0--[[ Tpat_var ]] then do
                  return true; end end 
               if ___conditional___ == 1--[[ Tpat_alias ]] then do
                  _q = match_1[0];
                  ::continue:: ; end end 
              if (typeof match == "number" or not (match.tag and not compat(match[0], q))) then do
                  return true;
                end else do
                  _p = match[1];
                  ::continue:: ;
                end end 
                
            end
          end end  end end 
       if ___conditional___ == 2 then do
          if (compat(p, match_1[0])) then do
            return true;
          end else do
            _q = match_1[1];
            ::continue:: ;
          end end  end end 
       if ___conditional___ == 3 then do
          error({
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "parmatch.ml",
              106,
              6
            }
          }) end end 
      
    end
  end;
end end

function compats(_ps, _qs) do
  while(true) do
    qs = _qs;
    ps = _ps;
    if (ps) then do
      if (qs) then do
        if (compat(ps[0], qs[0])) then do
          _qs = qs[1];
          _ps = ps[1];
          ::continue:: ;
        end else do
          return false;
        end end 
      end else do
        error({
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "parmatch.ml",
            111,
            12
          }
        })
      end end 
    end else if (qs) then do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "parmatch.ml",
          111,
          12
        }
      })
    end else do
      return true;
    end end  end 
  end;
end end

Empty = Caml_exceptions.create("Ocaml_typedtree_test.Parmatch.Empty");

function clean_copy(ty) do
  if (ty.level == 100000000) then do
    return ty;
  end else do
    return type_expr(identity, ty);
  end end 
end end

function get_type_path(ty, tenv) do
  ty_1 = repr(expand_head(tenv, clean_copy(ty)));
  match = ty_1.desc;
  if (typeof match == "number" or match.tag ~= --[[ Tconstr ]]3) then do
    return fatal_error("Parmatch.get_type_path");
  end else do
    return match[0];
  end end 
end end

function is_cons(param) do
  if (param.cstr_name == "::") then do
    return true;
  end else do
    return false;
  end end 
end end

function pretty_const(c) do
  local ___conditional___=(c.tag | 0);
  do
     if ___conditional___ == 0--[[ Const_int ]] then do
        return Curry._1(Printf.sprintf(--[[ Format ]]{
                        --[[ Int ]]Block.__(4, {
                            --[[ Int_d ]]0,
                            --[[ No_padding ]]0,
                            --[[ No_precision ]]0,
                            --[[ End_of_format ]]0
                          }),
                        "%d"
                      }), c[0]); end end 
     if ___conditional___ == 1--[[ Const_char ]] then do
        return Curry._1(Printf.sprintf(--[[ Format ]]{
                        --[[ Caml_char ]]Block.__(1, {--[[ End_of_format ]]0}),
                        "%C"
                      }), c[0]); end end 
     if ___conditional___ == 2--[[ Const_string ]] then do
        return Curry._1(Printf.sprintf(--[[ Format ]]{
                        --[[ Caml_string ]]Block.__(3, {
                            --[[ No_padding ]]0,
                            --[[ End_of_format ]]0
                          }),
                        "%S"
                      }), c[0]); end end 
     if ___conditional___ == 3--[[ Const_float ]] then do
        return Curry._1(Printf.sprintf(--[[ Format ]]{
                        --[[ String ]]Block.__(2, {
                            --[[ No_padding ]]0,
                            --[[ End_of_format ]]0
                          }),
                        "%s"
                      }), c[0]); end end 
     if ___conditional___ == 4--[[ Const_int32 ]] then do
        return Curry._1(Printf.sprintf(--[[ Format ]]{
                        --[[ Int32 ]]Block.__(5, {
                            --[[ Int_d ]]0,
                            --[[ No_padding ]]0,
                            --[[ No_precision ]]0,
                            --[[ Char_literal ]]Block.__(12, {
                                --[[ "l" ]]108,
                                --[[ End_of_format ]]0
                              })
                          }),
                        "%ldl"
                      }), c[0]); end end 
     if ___conditional___ == 5--[[ Const_int64 ]] then do
        return Curry._1(Printf.sprintf(--[[ Format ]]{
                        --[[ Int64 ]]Block.__(7, {
                            --[[ Int_d ]]0,
                            --[[ No_padding ]]0,
                            --[[ No_precision ]]0,
                            --[[ Char_literal ]]Block.__(12, {
                                --[[ "L" ]]76,
                                --[[ End_of_format ]]0
                              })
                          }),
                        "%LdL"
                      }), c[0]); end end 
     if ___conditional___ == 6--[[ Const_nativeint ]] then do
        return Curry._1(Printf.sprintf(--[[ Format ]]{
                        --[[ Nativeint ]]Block.__(6, {
                            --[[ Int_d ]]0,
                            --[[ No_padding ]]0,
                            --[[ No_precision ]]0,
                            --[[ Char_literal ]]Block.__(12, {
                                --[[ "n" ]]110,
                                --[[ End_of_format ]]0
                              })
                          }),
                        "%ndn"
                      }), c[0]); end end 
    
  end
end end

function pretty_val(ppf, v) do
  match = v.pat_extra;
  if (match) then do
    rem = match[1];
    tmp = match[0][0];
    if (typeof tmp == "number") then do
      return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Formatting_gen ]]Block.__(18, {
                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                --[[ End_of_format ]]0,
                                ""
                              }}),
                          --[[ String_literal ]]Block.__(11, {
                              "(module ",
                              --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                      --[[ ")" ]]41,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Close_box ]]0,
                                          --[[ End_of_format ]]0
                                        })
                                    })})
                            })
                        }),
                      "@[(module %a)@]"
                    }), pretty_val, do
                  pat_desc: v.pat_desc,
                  pat_loc: v.pat_loc,
                  pat_extra: rem,
                  pat_type: v.pat_type,
                  pat_env: v.pat_env,
                  pat_attributes: v.pat_attributes
                end);
    end else if (tmp.tag) then do
      return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Formatting_gen ]]Block.__(18, {
                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                --[[ End_of_format ]]0,
                                ""
                              }}),
                          --[[ String_literal ]]Block.__(11, {
                              "(# ",
                              --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                      --[[ ")" ]]41,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Close_box ]]0,
                                          --[[ End_of_format ]]0
                                        })
                                    })})
                            })
                        }),
                      "@[(# %a)@]"
                    }), pretty_val, do
                  pat_desc: v.pat_desc,
                  pat_loc: v.pat_loc,
                  pat_extra: rem,
                  pat_type: v.pat_type,
                  pat_env: v.pat_env,
                  pat_attributes: v.pat_attributes
                end);
    end else do
      return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Formatting_gen ]]Block.__(18, {
                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                --[[ End_of_format ]]0,
                                ""
                              }}),
                          --[[ Char_literal ]]Block.__(12, {
                              --[[ "(" ]]40,
                              --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                      " : _)",
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Close_box ]]0,
                                          --[[ End_of_format ]]0
                                        })
                                    })})
                            })
                        }),
                      "@[(%a : _)@]"
                    }), pretty_val, do
                  pat_desc: v.pat_desc,
                  pat_loc: v.pat_loc,
                  pat_extra: rem,
                  pat_type: v.pat_type,
                  pat_env: v.pat_env,
                  pat_attributes: v.pat_attributes
                end);
    end end  end 
  end else do
    match_1 = v.pat_desc;
    if (typeof match_1 == "number") then do
      return Format.fprintf(ppf, --[[ Format ]]{
                  --[[ Char_literal ]]Block.__(12, {
                      --[[ "_" ]]95,
                      --[[ End_of_format ]]0
                    }),
                  "_"
                });
    end else do
      local ___conditional___=(match_1.tag | 0);
      do
         if ___conditional___ == 0--[[ Tpat_var ]] then do
            return print_2(ppf, match_1[0]); end end 
         if ___conditional___ == 1--[[ Tpat_alias ]] then do
            return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                            --[[ Formatting_gen ]]Block.__(18, {
                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                      --[[ End_of_format ]]0,
                                      ""
                                    }}),
                                --[[ Char_literal ]]Block.__(12, {
                                    --[[ "(" ]]40,
                                    --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ String_literal ]]Block.__(11, {
                                                "as ",
                                                --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                        --[[ ")" ]]41,
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Close_box ]]0,
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })})
                                              })
                                          })})
                                  })
                              }),
                            "@[(%a@ as %a)@]"
                          }), pretty_val, match_1[0], print_2, match_1[1]); end end 
         if ___conditional___ == 2--[[ Tpat_constant ]] then do
            return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ End_of_format ]]0
                              }),
                            "%s"
                          }), pretty_const(match_1[0])); end end 
         if ___conditional___ == 3--[[ Tpat_tuple ]] then do
            return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                            --[[ Formatting_gen ]]Block.__(18, {
                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                      --[[ End_of_format ]]0,
                                      ""
                                    }}),
                                --[[ Char_literal ]]Block.__(12, {
                                    --[[ "(" ]]40,
                                    --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                            --[[ ")" ]]41,
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Close_box ]]0,
                                                --[[ End_of_format ]]0
                                              })
                                          })})
                                  })
                              }),
                            "@[(%a)@]"
                          }), (function(param, param_1) do
                          return pretty_vals(",", param, param_1);
                        end end), match_1[0]); end end 
         if ___conditional___ == 4--[[ Tpat_construct ]] then do
            vs = match_1[2];
            cstr = match_1[1];
            if (vs) then do
              if (vs[1]) then do
                name = cstr.cstr_name;
                if (name == "::" and vs) then do
                  match_2 = vs[1];
                  if (match_2 and not match_2[1]) then do
                    return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                                    --[[ Formatting_gen ]]Block.__(18, {
                                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                              --[[ End_of_format ]]0,
                                              ""
                                            }}),
                                        --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                                "::",
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@,",
                                                        0,
                                                        0
                                                      }),
                                                    --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Close_box ]]0,
                                                            --[[ End_of_format ]]0
                                                          })})
                                                  })
                                              })})
                                      }),
                                    "@[%a::@,%a@]"
                                  }), pretty_car, vs[0], pretty_cdr, match_2[0]);
                  end
                   end 
                end
                 end 
                return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                                --[[ Formatting_gen ]]Block.__(18, {
                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "<2>",
                                              --[[ End_of_format ]]0
                                            }),
                                          "<2>"
                                        }}),
                                    --[[ String ]]Block.__(2, {
                                        --[[ No_padding ]]0,
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ Formatting_gen ]]Block.__(18, {
                                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                      --[[ End_of_format ]]0,
                                                      ""
                                                    }}),
                                                --[[ Char_literal ]]Block.__(12, {
                                                    --[[ "(" ]]40,
                                                    --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                            --[[ ")" ]]41,
                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                --[[ Close_box ]]0,
                                                                --[[ Formatting_lit ]]Block.__(17, {
                                                                    --[[ Close_box ]]0,
                                                                    --[[ End_of_format ]]0
                                                                  })
                                                              })
                                                          })})
                                                  })
                                              })
                                          })
                                      })
                                  }),
                                "@[<2>%s@ @[(%a)@]@]"
                              }), name, (function(param, param_1) do
                              return pretty_vals(",", param, param_1);
                            end end), vs);
              end else do
                return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                                --[[ Formatting_gen ]]Block.__(18, {
                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "<2>",
                                              --[[ End_of_format ]]0
                                            }),
                                          "<2>"
                                        }}),
                                    --[[ String ]]Block.__(2, {
                                        --[[ No_padding ]]0,
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Close_box ]]0,
                                                    --[[ End_of_format ]]0
                                                  })})
                                          })
                                      })
                                  }),
                                "@[<2>%s@ %a@]"
                              }), cstr.cstr_name, pretty_arg, vs[0]);
              end end 
            end else do
              return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ End_of_format ]]0
                                }),
                              "%s"
                            }), cstr.cstr_name);
            end end  end else 
         if ___conditional___ == 5--[[ Tpat_variant ]] then do
            match_3 = match_1[1];
            l = match_1[0];
            if (match_3 ~= undefined) then do
              return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                              --[[ Formatting_gen ]]Block.__(18, {
                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                        --[[ String_literal ]]Block.__(11, {
                                            "<2>",
                                            --[[ End_of_format ]]0
                                          }),
                                        "<2>"
                                      }}),
                                  --[[ Char_literal ]]Block.__(12, {
                                      --[[ "`" ]]96,
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@ ",
                                                  1,
                                                  0
                                                }),
                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Close_box ]]0,
                                                      --[[ End_of_format ]]0
                                                    })})
                                            })
                                        })
                                    })
                                }),
                              "@[<2>`%s@ %a@]"
                            }), l, pretty_arg, match_3);
            end else do
              return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                              --[[ Char_literal ]]Block.__(12, {
                                  --[[ "`" ]]96,
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ End_of_format ]]0
                                    })
                                }),
                              "`%s"
                            }), l);
            end end  end end end end 
         if ___conditional___ == 6--[[ Tpat_record ]] then do
            return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                            --[[ Formatting_gen ]]Block.__(18, {
                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                      --[[ End_of_format ]]0,
                                      ""
                                    }}),
                                --[[ Char_literal ]]Block.__(12, {
                                    --[[ "{" ]]123,
                                    --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                            --[[ "}" ]]125,
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Close_box ]]0,
                                                --[[ End_of_format ]]0
                                              })
                                          })})
                                  })
                              }),
                            "@[{%a}@]"
                          }), pretty_lvals, List.filter((function(param) do
                                if (typeof param[2].pat_desc == "number") then do
                                  return false;
                                end else do
                                  return true;
                                end end 
                              end end))(match_1[0])); end end 
         if ___conditional___ == 7--[[ Tpat_array ]] then do
            return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                            --[[ Formatting_gen ]]Block.__(18, {
                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                      --[[ End_of_format ]]0,
                                      ""
                                    }}),
                                --[[ String_literal ]]Block.__(11, {
                                    "[| ",
                                    --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                            " |]",
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Close_box ]]0,
                                                --[[ End_of_format ]]0
                                              })
                                          })})
                                  })
                              }),
                            "@[[| %a |]@]"
                          }), (function(param, param_1) do
                          return pretty_vals(" ;", param, param_1);
                        end end), match_1[0]); end end 
         if ___conditional___ == 8--[[ Tpat_or ]] then do
            return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                            --[[ Formatting_gen ]]Block.__(18, {
                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                      --[[ End_of_format ]]0,
                                      ""
                                    }}),
                                --[[ Char_literal ]]Block.__(12, {
                                    --[[ "(" ]]40,
                                    --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                            --[[ "|" ]]124,
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Break ]]Block.__(0, {
                                                    "@,",
                                                    0,
                                                    0
                                                  }),
                                                --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                        --[[ ")" ]]41,
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Close_box ]]0,
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })})
                                              })
                                          })})
                                  })
                              }),
                            "@[(%a|@,%a)@]"
                          }), pretty_or, match_1[0], pretty_or, match_1[1]); end end 
         if ___conditional___ == 9--[[ Tpat_lazy ]] then do
            return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                            --[[ Formatting_gen ]]Block.__(18, {
                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                      --[[ String_literal ]]Block.__(11, {
                                          "<2>",
                                          --[[ End_of_format ]]0
                                        }),
                                      "<2>"
                                    }}),
                                --[[ String_literal ]]Block.__(11, {
                                    "lazy",
                                    --[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Break ]]Block.__(0, {
                                            "@ ",
                                            1,
                                            0
                                          }),
                                        --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Close_box ]]0,
                                                --[[ End_of_format ]]0
                                              })})
                                      })
                                  })
                              }),
                            "@[<2>lazy@ %a@]"
                          }), pretty_arg, match_1[0]); end end 
        
      end
    end end 
  end end 
end end

function pretty_car(ppf, v) do
  match = v.pat_desc;
  if (typeof match == "number" or match.tag ~= --[[ Tpat_construct ]]4) then do
    return pretty_val(ppf, v);
  end else do
    match_1 = match[2];
    if (match_1) then do
      match_2 = match_1[1];
      if (match_2 and not (match_2[1] or not is_cons(match[1]))) then do
        return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Char_literal ]]Block.__(12, {
                            --[[ "(" ]]40,
                            --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                    --[[ ")" ]]41,
                                    --[[ End_of_format ]]0
                                  })})
                          }),
                        "(%a)"
                      }), pretty_val, v);
      end else do
        return pretty_val(ppf, v);
      end end 
    end else do
      return pretty_val(ppf, v);
    end end 
  end end 
end end

function pretty_cdr(ppf, v) do
  match = v.pat_desc;
  if (typeof match == "number" or match.tag ~= --[[ Tpat_construct ]]4) then do
    return pretty_val(ppf, v);
  end else do
    match_1 = match[2];
    if (match_1) then do
      match_2 = match_1[1];
      if (match_2 and not (match_2[1] or not is_cons(match[1]))) then do
        return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                "::",
                                --[[ Formatting_lit ]]Block.__(17, {
                                    --[[ Break ]]Block.__(0, {
                                        "@,",
                                        0,
                                        0
                                      }),
                                    --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                  })
                              })}),
                        "%a::@,%a"
                      }), pretty_car, match_1[0], pretty_cdr, match_2[0]);
      end else do
        return pretty_val(ppf, v);
      end end 
    end else do
      return pretty_val(ppf, v);
    end end 
  end end 
end end

function pretty_arg(ppf, v) do
  match = v.pat_desc;
  if (typeof match == "number") then do
    return pretty_val(ppf, v);
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 4--[[ Tpat_construct ]] then do
          if (not match[2]) then do
            return pretty_val(ppf, v);
          end
           end  end else 
       if ___conditional___ == 5--[[ Tpat_variant ]] then do
          if (match[1] == undefined) then do
            return pretty_val(ppf, v);
          end
           end  end else 
       end end end end
      return pretty_val(ppf, v);
        
    end
  end end 
  return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                  --[[ Char_literal ]]Block.__(12, {
                      --[[ "(" ]]40,
                      --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                              --[[ ")" ]]41,
                              --[[ End_of_format ]]0
                            })})
                    }),
                  "(%a)"
                }), pretty_val, v);
end end

function pretty_or(ppf, v) do
  match = v.pat_desc;
  if (typeof match == "number" or match.tag ~= --[[ Tpat_or ]]8) then do
    return pretty_val(ppf, v);
  end else do
    return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                            --[[ "|" ]]124,
                            --[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@,",
                                    0,
                                    0
                                  }),
                                --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                              })
                          })}),
                    "%a|@,%a"
                  }), pretty_or, match[0], pretty_or, match[1]);
  end end 
end end

function pretty_vals(sep, ppf, param) do
  if (param) then do
    vs = param[1];
    v = param[0];
    if (vs) then do
      return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Alpha ]]Block.__(15, {--[[ String ]]Block.__(2, {
                              --[[ No_padding ]]0,
                              --[[ Formatting_lit ]]Block.__(17, {
                                  --[[ Break ]]Block.__(0, {
                                      "@ ",
                                      1,
                                      0
                                    }),
                                  --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                })
                            })}),
                      "%a%s@ %a"
                    }), pretty_val, v, sep, (function(param, param_1) do
                    return pretty_vals(sep, param, param_1);
                  end end), vs);
    end else do
      return pretty_val(ppf, v);
    end end 
  end else do
    return --[[ () ]]0;
  end end 
end end

function pretty_lvals(ppf, param) do
  if (param) then do
    rest = param[1];
    match = param[0];
    v = match[2];
    lbl = match[1];
    if (rest) then do
      return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String ]]Block.__(2, {
                          --[[ No_padding ]]0,
                          --[[ Char_literal ]]Block.__(12, {
                              --[[ "=" ]]61,
                              --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                      --[[ ";" ]]59,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                        })
                                    })})
                            })
                        }),
                      "%s=%a;@ %a"
                    }), lbl.lbl_name, pretty_val, v, pretty_lvals, rest);
    end else do
      return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String ]]Block.__(2, {
                          --[[ No_padding ]]0,
                          --[[ Char_literal ]]Block.__(12, {
                              --[[ "=" ]]61,
                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                            })
                        }),
                      "%s=%a"
                    }), lbl.lbl_name, pretty_val, v);
    end end 
  end else do
    return --[[ () ]]0;
  end end 
end end

function top_pretty(ppf, v) do
  return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                  --[[ Formatting_gen ]]Block.__(18, {
                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                            --[[ End_of_format ]]0,
                            ""
                          }}),
                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                              --[[ Close_box ]]0,
                              --[[ Formatting_lit ]]Block.__(17, {
                                  --[[ FFlush ]]2,
                                  --[[ End_of_format ]]0
                                })
                            })})
                    }),
                  "@[%a@]@?"
                }), pretty_val, v);
end end

function simple_match(p1, p2) do
  match = p1.pat_desc;
  match_1 = p2.pat_desc;
  if (typeof match ~= "number") then do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 2--[[ Tpat_constant ]] then do
          if (typeof match_1 ~= "number") then do
            local ___conditional___=(match_1.tag | 0);
            do
               if ___conditional___ == 0--[[ Tpat_var ]]
               or ___conditional___ == 2--[[ Tpat_constant ]] then do
                  return const_compare(match[0], match_1[0]) == 0; end end 
              return false;
                
            end
          end
           end  end else 
       if ___conditional___ == 3--[[ Tpat_tuple ]] then do
          if (typeof match_1 ~= "number") then do
            local ___conditional___=(match_1.tag | 0);
            do
               if ___conditional___ == 0--[[ Tpat_var ]]
               or ___conditional___ == 3--[[ Tpat_tuple ]] then do
                  return true; end end 
              return false;
                
            end
          end
           end  end else 
       if ___conditional___ == 4--[[ Tpat_construct ]] then do
          if (typeof match_1 ~= "number") then do
            local ___conditional___=(match_1.tag | 0);
            do
               if ___conditional___ == 0--[[ Tpat_var ]]
               or ___conditional___ == 4--[[ Tpat_construct ]] then do
                  return equal_tag(match[1].cstr_tag, match_1[1].cstr_tag); end end 
              return false;
                
            end
          end
           end  end else 
       if ___conditional___ == 5--[[ Tpat_variant ]] then do
          if (typeof match_1 ~= "number") then do
            local ___conditional___=(match_1.tag | 0);
            do
               if ___conditional___ == 0--[[ Tpat_var ]]
               or ___conditional___ == 5--[[ Tpat_variant ]] then do
                  return match[0] == match_1[0]; end end 
              return false;
                
            end
          end
           end  end else 
       if ___conditional___ == 6--[[ Tpat_record ]] then do
          if (typeof match_1 ~= "number") then do
            local ___conditional___=(match_1.tag | 0);
            do
               if ___conditional___ == 0--[[ Tpat_var ]]
               or ___conditional___ == 6--[[ Tpat_record ]] then do
                  return true; end end 
              return false;
                
            end
          end
           end  end else 
       if ___conditional___ == 7--[[ Tpat_array ]] then do
          if (typeof match_1 ~= "number") then do
            local ___conditional___=(match_1.tag | 0);
            do
               if ___conditional___ == 0--[[ Tpat_var ]]
               or ___conditional___ == 7--[[ Tpat_array ]] then do
                  return List.length(match[0]) == List.length(match_1[0]); end end 
              return false;
                
            end
          end
           end  end else 
       if ___conditional___ == 9--[[ Tpat_lazy ]] then do
          if (typeof match_1 ~= "number") then do
            local ___conditional___=(match_1.tag | 0);
            do
               if ___conditional___ == 0--[[ Tpat_var ]]
               or ___conditional___ == 9--[[ Tpat_lazy ]] then do
                  return true; end end 
              return false;
                
            end
          end
           end  end else 
       end end end end end end end end end end end end end end
      
    end
  end
   end 
  if (typeof match_1 == "number" or not match_1.tag) then do
    return true;
  end else do
    return false;
  end end 
end end

function record_arg(p) do
  match = p.pat_desc;
  if (typeof match == "number") then do
    return --[[ [] ]]0;
  end else if (match.tag == --[[ Tpat_record ]]6) then do
    return match[0];
  end else do
    return fatal_error("Parmatch.as_record");
  end end  end 
end end

function get_field(pos, arg) do
  return List.find((function(param) do
                  return pos == param[1].lbl_pos;
                end end), arg)[2];
end end

function simple_match_args(p1, _p2) do
  while(true) do
    p2 = _p2;
    match = p2.pat_desc;
    if (typeof match ~= "number") then do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 0--[[ Tpat_var ]]
         or ___conditional___ == 1--[[ Tpat_alias ]] then do
            _p2 = match[0];
            ::continue:: ; end end 
         if ___conditional___ == 4--[[ Tpat_construct ]] then do
            return match[2]; end end 
         if ___conditional___ == 5--[[ Tpat_variant ]] then do
            match_1 = match[1];
            if (match_1 ~= undefined) then do
              return --[[ :: ]]{
                      match_1,
                      --[[ [] ]]0
                    };
            end else do
              return --[[ [] ]]0;
            end end  end end 
         if ___conditional___ == 6--[[ Tpat_record ]] then do
            omegas = record_arg(p1);
            arg = match[0];
            return List.map((function(arg)do
                      return function (param) do
                        xpcall(function() do
                          return get_field(param[1].lbl_pos, arg);
                        end end,function(exn) do
                          if (exn == Caml_builtin_exceptions.not_found) then do
                            return omega;
                          end else do
                            error(exn)
                          end end 
                        end end)
                      end end
                      end end)(arg), omegas); end end 
         if ___conditional___ == 3--[[ Tpat_tuple ]]
         or ___conditional___ == 7--[[ Tpat_array ]] then do
            return match[0]; end end 
         if ___conditional___ == 2--[[ Tpat_constant ]]
         or ___conditional___ == 8--[[ Tpat_or ]] then do
            return --[[ [] ]]0; end end 
         if ___conditional___ == 9--[[ Tpat_lazy ]] then do
            return --[[ :: ]]{
                    match[0],
                    --[[ [] ]]0
                  }; end end 
        
      end
    end
     end 
    match_2 = p1.pat_desc;
    if (typeof match_2 == "number") then do
      return --[[ [] ]]0;
    end else do
      local ___conditional___=(match_2.tag | 0);
      do
         if ___conditional___ == 3--[[ Tpat_tuple ]] then do
            return List.map((function(param) do
                          return omega;
                        end end), match_2[0]); end end 
         if ___conditional___ == 4--[[ Tpat_construct ]] then do
            return List.map((function(param) do
                          return omega;
                        end end), match_2[2]); end end 
         if ___conditional___ == 5--[[ Tpat_variant ]] then do
            if (match_2[1] ~= undefined) then do
              return --[[ :: ]]{
                      omega,
                      --[[ [] ]]0
                    };
            end else do
              return --[[ [] ]]0;
            end end  end end 
         if ___conditional___ == 6--[[ Tpat_record ]] then do
            return List.map((function(param) do
                          return omega;
                        end end), match_2[0]); end end 
         if ___conditional___ == 7--[[ Tpat_array ]] then do
            return List.map((function(param) do
                          return omega;
                        end end), match_2[0]); end end 
         if ___conditional___ == 9--[[ Tpat_lazy ]] then do
            return --[[ :: ]]{
                    omega,
                    --[[ [] ]]0
                  }; end end 
        return --[[ [] ]]0;
          
      end
    end end 
  end;
end end

function normalize_pat(_q) do
  while(true) do
    q = _q;
    match = q.pat_desc;
    if (typeof match == "number") then do
      return q;
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 0--[[ Tpat_var ]] then do
            return make_pat(--[[ Tpat_any ]]0, q.pat_type, q.pat_env); end end 
         if ___conditional___ == 1--[[ Tpat_alias ]] then do
            _q = match[0];
            ::continue:: ; end end 
         if ___conditional___ == 2--[[ Tpat_constant ]] then do
            return q; end end 
         if ___conditional___ == 3--[[ Tpat_tuple ]] then do
            return make_pat(--[[ Tpat_tuple ]]Block.__(3, {List.map((function(param) do
                                  return omega;
                                end end), match[0])}), q.pat_type, q.pat_env); end end 
         if ___conditional___ == 4--[[ Tpat_construct ]] then do
            return make_pat(--[[ Tpat_construct ]]Block.__(4, {
                          match[0],
                          match[1],
                          List.map((function(param) do
                                  return omega;
                                end end), match[2])
                        }), q.pat_type, q.pat_env); end end 
         if ___conditional___ == 5--[[ Tpat_variant ]] then do
            return make_pat(--[[ Tpat_variant ]]Block.__(5, {
                          match[0],
                          may_map((function(param) do
                                  return omega;
                                end end), match[1]),
                          match[2]
                        }), q.pat_type, q.pat_env); end end 
         if ___conditional___ == 6--[[ Tpat_record ]] then do
            return make_pat(--[[ Tpat_record ]]Block.__(6, {
                          List.map((function(param) do
                                  return --[[ tuple ]]{
                                          param[0],
                                          param[1],
                                          omega
                                        };
                                end end), match[0]),
                          match[1]
                        }), q.pat_type, q.pat_env); end end 
         if ___conditional___ == 7--[[ Tpat_array ]] then do
            return make_pat(--[[ Tpat_array ]]Block.__(7, {List.map((function(param) do
                                  return omega;
                                end end), match[0])}), q.pat_type, q.pat_env); end end 
         if ___conditional___ == 8--[[ Tpat_or ]] then do
            return fatal_error("Parmatch.normalize_pat"); end end 
         if ___conditional___ == 9--[[ Tpat_lazy ]] then do
            return make_pat(--[[ Tpat_lazy ]]Block.__(9, {omega}), q.pat_type, q.pat_env); end end 
        
      end
    end end 
  end;
end end

function discr_pat(q, pss) do
  q_1 = normalize_pat(q);
  tmp = q_1.pat_desc;
  if (typeof tmp == "number" or tmp.tag == --[[ Tpat_record ]]6) then do
    _acc = q_1;
    _pss = pss;
    while(true) do
      pss_1 = _pss;
      acc = _acc;
      if (pss_1) then do
        match = pss_1[0];
        if (match) then do
          p = match[0];
          match_1 = p.pat_desc;
          if (typeof match_1 == "number") then do
            _pss = pss_1[1];
            ::continue:: ;
          end else do
            local ___conditional___=(match_1.tag | 0);
            do
               if ___conditional___ == 0--[[ Tpat_var ]] then do
                  _pss = pss_1[1];
                  ::continue:: ; end end 
               if ___conditional___ == 1--[[ Tpat_alias ]] then do
                  _pss = --[[ :: ]]{
                    --[[ :: ]]{
                      match_1[0],
                      match[1]
                    },
                    pss_1[1]
                  };
                  ::continue:: ; end end 
               if ___conditional___ == 6--[[ Tpat_record ]] then do
                  new_omegas = List.fold_right((function(param, r) do
                          lbl = param[1];
                          xpcall(function() do
                            get_field(lbl.lbl_pos, r);
                            return r;
                          end end,function(exn) do
                            if (exn == Caml_builtin_exceptions.not_found) then do
                              return --[[ :: ]]{
                                      --[[ tuple ]]{
                                        param[0],
                                        lbl,
                                        omega
                                      },
                                      r
                                    };
                            end else do
                              error(exn)
                            end end 
                          end end)
                        end end), match_1[0], record_arg(acc));
                  _pss = pss_1[1];
                  _acc = make_pat(--[[ Tpat_record ]]Block.__(6, {
                          new_omegas,
                          match_1[1]
                        }), p.pat_type, p.pat_env);
                  ::continue:: ; end end 
               if ___conditional___ == 8--[[ Tpat_or ]] then do
                  ps = match[1];
                  _pss = --[[ :: ]]{
                    --[[ :: ]]{
                      match_1[0],
                      ps
                    },
                    --[[ :: ]]{
                      --[[ :: ]]{
                        match_1[1],
                        ps
                      },
                      pss_1[1]
                    }
                  };
                  ::continue:: ; end end 
               if ___conditional___ == 3--[[ Tpat_tuple ]]
               or ___conditional___ == 9--[[ Tpat_lazy ]] then do
                  return normalize_pat(p); end end 
              return acc;
                
            end
          end end 
        end else do
          return acc;
        end end 
      end else do
        return acc;
      end end 
    end;
  end else do
    return q_1;
  end end 
end end

function read_args(xs, r) do
  if (xs) then do
    if (r) then do
      match = read_args(xs[1], r[1]);
      return --[[ tuple ]]{
              --[[ :: ]]{
                r[0],
                match[0]
              },
              match[1]
            };
    end else do
      return fatal_error("Parmatch.read_args");
    end end 
  end else do
    return --[[ tuple ]]{
            --[[ [] ]]0,
            r
          };
  end end 
end end

function do_set_args(erase_mutable, q, r) do
  match = q.pat_desc;
  if (typeof match == "number") then do
    return --[[ :: ]]{
            q,
            r
          };
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 2--[[ Tpat_constant ]] then do
          return --[[ :: ]]{
                  q,
                  r
                }; end end 
       if ___conditional___ == 3--[[ Tpat_tuple ]] then do
          match_1 = read_args(match[0], r);
          return --[[ :: ]]{
                  make_pat(--[[ Tpat_tuple ]]Block.__(3, {match_1[0]}), q.pat_type, q.pat_env),
                  match_1[1]
                }; end end 
       if ___conditional___ == 4--[[ Tpat_construct ]] then do
          match_2 = read_args(match[2], r);
          return --[[ :: ]]{
                  make_pat(--[[ Tpat_construct ]]Block.__(4, {
                          match[0],
                          match[1],
                          match_2[0]
                        }), q.pat_type, q.pat_env),
                  match_2[1]
                }; end end 
       if ___conditional___ == 5--[[ Tpat_variant ]] then do
          match_3;
          if (match[1] ~= undefined) then do
            if (r) then do
              match_3 = --[[ tuple ]]{
                r[0],
                r[1]
              };
            end else do
              error({
                Caml_builtin_exceptions.assert_failure,
                --[[ tuple ]]{
                  "parmatch.ml",
                  450,
                  13
                }
              })
            end end 
          end else do
            match_3 = --[[ tuple ]]{
              undefined,
              r
            };
          end end 
          return --[[ :: ]]{
                  make_pat(--[[ Tpat_variant ]]Block.__(5, {
                          match[0],
                          match_3[0],
                          match[2]
                        }), q.pat_type, q.pat_env),
                  match_3[1]
                }; end end 
       if ___conditional___ == 6--[[ Tpat_record ]] then do
          omegas = match[0];
          match_4 = read_args(omegas, r);
          return --[[ :: ]]{
                  make_pat(--[[ Tpat_record ]]Block.__(6, {
                          List.map2((function(param, arg) do
                                  lbl = param[1];
                                  lid = param[0];
                                  tmp = false;
                                  if (erase_mutable) then do
                                    match = lbl.lbl_mut;
                                    tmp = match and true or false;
                                  end
                                   end 
                                  if (tmp) then do
                                    return --[[ tuple ]]{
                                            lid,
                                            lbl,
                                            omega
                                          };
                                  end else do
                                    return --[[ tuple ]]{
                                            lid,
                                            lbl,
                                            arg
                                          };
                                  end end 
                                end end), omegas, match_4[0]),
                          match[1]
                        }), q.pat_type, q.pat_env),
                  match_4[1]
                }; end end 
       if ___conditional___ == 7--[[ Tpat_array ]] then do
          match_5 = read_args(match[0], r);
          return --[[ :: ]]{
                  make_pat(--[[ Tpat_array ]]Block.__(7, {match_5[0]}), q.pat_type, q.pat_env),
                  match_5[1]
                }; end end 
       if ___conditional___ == 9--[[ Tpat_lazy ]] then do
          if (r) then do
            return --[[ :: ]]{
                    make_pat(--[[ Tpat_lazy ]]Block.__(9, {r[0]}), q.pat_type, q.pat_env),
                    r[1]
                  };
          end else do
            return fatal_error("Parmatch.do_set_args (lazy)");
          end end  end end 
      return fatal_error("Parmatch.set_args");
        
    end
  end end 
end end

function filter_one(q, pss) do
  filter_rec = function(_param) do
    while(true) do
      param = _param;
      if (param) then do
        match = param[0];
        if (match) then do
          p = match[0];
          match_1 = p.pat_desc;
          if (typeof match_1 ~= "number") then do
            local ___conditional___=(match_1.tag | 0);
            do
               if ___conditional___ == 1--[[ Tpat_alias ]] then do
                  _param = --[[ :: ]]{
                    --[[ :: ]]{
                      match_1[0],
                      match[1]
                    },
                    param[1]
                  };
                  ::continue:: ; end end 
               if ___conditional___ == 8--[[ Tpat_or ]] then do
                  ps = match[1];
                  _param = --[[ :: ]]{
                    --[[ :: ]]{
                      match_1[0],
                      ps
                    },
                    --[[ :: ]]{
                      --[[ :: ]]{
                        match_1[1],
                        ps
                      },
                      param[1]
                    }
                  };
                  ::continue:: ; end end 
              
            end
          end
           end 
          pss = param[1];
          if (simple_match(q, p)) then do
            return --[[ :: ]]{
                    Pervasives.$at(simple_match_args(q, p), match[1]),
                    filter_rec(pss)
                  };
          end else do
            _param = pss;
            ::continue:: ;
          end end 
        end else do
          return --[[ [] ]]0;
        end end 
      end else do
        return --[[ [] ]]0;
      end end 
    end;
  end end;
  return filter_rec(pss);
end end

function filter_extra(pss) do
  filter_rec = function(_param) do
    while(true) do
      param = _param;
      if (param) then do
        match = param[0];
        if (match) then do
          match_1 = match[0].pat_desc;
          if (typeof match_1 == "number") then do
            return --[[ :: ]]{
                    match[1],
                    filter_rec(param[1])
                  };
          end else do
            local ___conditional___=(match_1.tag | 0);
            do
               if ___conditional___ == 0--[[ Tpat_var ]] then do
                  return --[[ :: ]]{
                          match[1],
                          filter_rec(param[1])
                        }; end end 
               if ___conditional___ == 1--[[ Tpat_alias ]] then do
                  _param = --[[ :: ]]{
                    --[[ :: ]]{
                      match_1[0],
                      match[1]
                    },
                    param[1]
                  };
                  ::continue:: ; end end 
               if ___conditional___ == 8--[[ Tpat_or ]] then do
                  ps = match[1];
                  _param = --[[ :: ]]{
                    --[[ :: ]]{
                      match_1[0],
                      ps
                    },
                    --[[ :: ]]{
                      --[[ :: ]]{
                        match_1[1],
                        ps
                      },
                      param[1]
                    }
                  };
                  ::continue:: ; end end 
              _param = param[1];
                ::continue:: ;
                
            end
          end end 
        end else do
          _param = param[1];
          ::continue:: ;
        end end 
      end else do
        return --[[ [] ]]0;
      end end 
    end;
  end end;
  return filter_rec(pss);
end end

function filter_all(pat0, pss) do
  insert = function(q, qs, env) do
    if (env) then do
      env_1 = env[1];
      c = env[0];
      q0 = c[0];
      if (simple_match(q0, q)) then do
        return --[[ :: ]]{
                --[[ tuple ]]{
                  q0,
                  --[[ :: ]]{
                    Pervasives.$at(simple_match_args(q0, q), qs),
                    c[1]
                  }
                },
                env_1
              };
      end else do
        return --[[ :: ]]{
                c,
                insert(q, qs, env_1)
              };
      end end 
    end else do
      q0_1 = normalize_pat(q);
      return --[[ :: ]]{
              --[[ tuple ]]{
                q0_1,
                --[[ :: ]]{
                  Pervasives.$at(simple_match_args(q0_1, q), qs),
                  --[[ [] ]]0
                }
              },
              --[[ [] ]]0
            };
    end end 
  end end;
  filter_rec = function(_env, _param) do
    while(true) do
      param = _param;
      env = _env;
      if (param) then do
        match = param[0];
        if (match) then do
          p = match[0];
          match_1 = p.pat_desc;
          if (typeof match_1 == "number") then do
            _param = param[1];
            ::continue:: ;
          end else do
            local ___conditional___=(match_1.tag | 0);
            do
               if ___conditional___ == 0--[[ Tpat_var ]] then do
                  _param = param[1];
                  ::continue:: ; end end 
               if ___conditional___ == 1--[[ Tpat_alias ]] then do
                  _param = --[[ :: ]]{
                    --[[ :: ]]{
                      match_1[0],
                      match[1]
                    },
                    param[1]
                  };
                  ::continue:: ; end end 
               if ___conditional___ == 8--[[ Tpat_or ]] then do
                  ps = match[1];
                  _param = --[[ :: ]]{
                    --[[ :: ]]{
                      match_1[0],
                      ps
                    },
                    --[[ :: ]]{
                      --[[ :: ]]{
                        match_1[1],
                        ps
                      },
                      param[1]
                    }
                  };
                  ::continue:: ; end end 
              _param = param[1];
                _env = insert(p, match[1], env);
                ::continue:: ;
                
            end
          end end 
        end else do
          return env;
        end end 
      end else do
        return env;
      end end 
    end;
  end end;
  match = pat0.pat_desc;
  tmp;
  exit = 0;
  if (typeof match == "number") then do
    tmp = --[[ [] ]]0;
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 3--[[ Tpat_tuple ]]
       or ___conditional___ == 6--[[ Tpat_record ]]
       or ___conditional___ == 9--[[ Tpat_lazy ]] then do
          exit = 1; end else 
       end end
      tmp = --[[ [] ]]0;
        
    end
  end end 
  if (exit == 1) then do
    tmp = --[[ :: ]]{
      --[[ tuple ]]{
        pat0,
        --[[ [] ]]0
      },
      --[[ [] ]]0
    };
  end
   end 
  _env = filter_rec(tmp, pss);
  _param = pss;
  while(true) do
    param = _param;
    env = _env;
    if (param) then do
      match_1 = param[0];
      if (match_1) then do
        match_2 = match_1[0].pat_desc;
        if (typeof match_2 ~= "number") then do
          local ___conditional___=(match_2.tag | 0);
          do
             if ___conditional___ == 0--[[ Tpat_var ]]
             or ___conditional___ == 1--[[ Tpat_alias ]] then do
                _param = --[[ :: ]]{
                  --[[ :: ]]{
                    match_2[0],
                    match_1[1]
                  },
                  param[1]
                };
                ::continue:: ; end end 
             if ___conditional___ == 8--[[ Tpat_or ]] then do
                ps = match_1[1];
                _param = --[[ :: ]]{
                  --[[ :: ]]{
                    match_2[0],
                    ps
                  },
                  --[[ :: ]]{
                    --[[ :: ]]{
                      match_2[1],
                      ps
                    },
                    param[1]
                  }
                };
                ::continue:: ; end end 
            _param = param[1];
              ::continue:: ;
              
          end
        end
         end 
        ps_1 = match_1[1];
        _param = param[1];
        _env = List.map((function(ps_1)do
            return function (param) do
              q = param[0];
              return --[[ tuple ]]{
                      q,
                      --[[ :: ]]{
                        Pervasives.$at(simple_match_args(q, omega), ps_1),
                        param[1]
                      }
                    };
            end end
            end end)(ps_1), env);
        ::continue:: ;
      end else do
        _param = param[1];
        ::continue:: ;
      end end 
    end else do
      return env;
    end end 
  end;
end end

function set_last(a, param) do
  if (param) then do
    l = param[1];
    if (l) then do
      return --[[ :: ]]{
              param[0],
              set_last(a, l)
            };
    end else do
      return --[[ :: ]]{
              a,
              --[[ [] ]]0
            };
    end end 
  end else do
    return --[[ [] ]]0;
  end end 
end end

function mark_partial(_param) do
  while(true) do
    param = _param;
    if (param) then do
      ps = param[0];
      if (ps) then do
        match = ps[0].pat_desc;
        if (typeof match == "number") then do
          return --[[ :: ]]{
                  ps,
                  mark_partial(param[1])
                };
        end else do
          local ___conditional___=(match.tag | 0);
          do
             if ___conditional___ == 0--[[ Tpat_var ]] then do
                return --[[ :: ]]{
                        ps,
                        mark_partial(param[1])
                      }; end end 
             if ___conditional___ == 1--[[ Tpat_alias ]] then do
                _param = --[[ :: ]]{
                  --[[ :: ]]{
                    match[0],
                    ps[1]
                  },
                  param[1]
                };
                ::continue:: ; end end 
             if ___conditional___ == 8--[[ Tpat_or ]] then do
                ps_1 = ps[1];
                _param = --[[ :: ]]{
                  --[[ :: ]]{
                    match[0],
                    ps_1
                  },
                  --[[ :: ]]{
                    --[[ :: ]]{
                      match[1],
                      ps_1
                    },
                    param[1]
                  }
                };
                ::continue:: ; end end 
            
          end
        end end 
      end
       end 
      return --[[ :: ]]{
              set_last(zero, ps),
              mark_partial(param[1])
            };
    end else do
      return --[[ [] ]]0;
    end end 
  end;
end end

function close_variant(env, row) do
  row_1 = row_repr_aux(--[[ [] ]]0, row);
  nm = List.fold_left((function(nm, param) do
          match = row_field_repr_aux(--[[ [] ]]0, param[1]);
          if (typeof match == "number" or not (match.tag and not match[2])) then do
            return nm;
          end else do
            set_row_field(match[3], --[[ Rabsent ]]0);
            return ;
          end end 
        end end), row_1.row_name, row_1.row_fields);
  if (not row_1.row_closed or nm ~= row_1.row_name) then do
    return unify_2(env, row_1.row_more, newty2(100000000, --[[ Tvariant ]]Block.__(8, {do
                        row_fields: --[[ [] ]]0,
                        row_more: newty2(100000000, --[[ Tvar ]]Block.__(0, {undefined})),
                        row_bound: row_1.row_bound,
                        row_closed: true,
                        row_fixed: row_1.row_fixed,
                        row_name: nm
                      end})));
  end else do
    return 0;
  end end 
end end

function row_of_pat(pat) do
  match = expand_head(pat.pat_env, pat.pat_type);
  match_1 = match.desc;
  if (typeof match_1 == "number") then do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "parmatch.ml",
        602,
        9
      }
    })
  end else if (match_1.tag == --[[ Tvariant ]]8) then do
    return row_repr_aux(--[[ [] ]]0, match_1[0]);
  end else do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "parmatch.ml",
        602,
        9
      }
    })
  end end  end 
end end

function generalized_constructor(x) do
  match = x[0].pat_desc;
  if (typeof match == "number") then do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "parmatch.ml",
        613,
        9
      }
    })
  end else if (match.tag == --[[ Tpat_construct ]]4) then do
    return match[1].cstr_generalized;
  end else do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "parmatch.ml",
        613,
        9
      }
    })
  end end  end 
end end

function clean_env(env) do
  loop = function(_param) do
    while(true) do
      param = _param;
      if (param) then do
        xs = param[1];
        x = param[0];
        if (generalized_constructor(x)) then do
          _param = xs;
          ::continue:: ;
        end else do
          return --[[ :: ]]{
                  x,
                  loop(xs)
                };
        end end 
      end else do
        return --[[ [] ]]0;
      end end 
    end;
  end end;
  return loop(env);
end end

function full_match(ignore_generalized, closing, env) do
  if (env) then do
    p = env[0][0];
    match = p.pat_desc;
    if (typeof match == "number") then do
      return fatal_error("Parmatch.full_match");
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 2--[[ Tpat_constant ]] then do
            if (match[0].tag == --[[ Const_char ]]1) then do
              return List.length(env) == 256;
            end else do
              return false;
            end end  end end 
         if ___conditional___ == 4--[[ Tpat_construct ]] then do
            c = match[1];
            if (c.cstr_consts < 0) then do
              return false;
            end else if (ignore_generalized) then do
              env_1 = clean_env(env);
              return List.length(env_1) == c.cstr_normal;
            end else do
              return List.length(env) == (c.cstr_consts + c.cstr_nonconsts | 0);
            end end  end  end end 
         if ___conditional___ == 5--[[ Tpat_variant ]] then do
            fields = List.map((function(param) do
                    match = param[0].pat_desc;
                    if (typeof match == "number") then do
                      error({
                        Caml_builtin_exceptions.assert_failure,
                        --[[ tuple ]]{
                          "parmatch.ml",
                          640,
                          17
                        }
                      })
                    end else if (match.tag == --[[ Tpat_variant ]]5) then do
                      return match[0];
                    end else do
                      error({
                        Caml_builtin_exceptions.assert_failure,
                        --[[ tuple ]]{
                          "parmatch.ml",
                          640,
                          17
                        }
                      })
                    end end  end 
                  end end), env);
            row = row_of_pat(p);
            if (closing and not row_fixed(row)) then do
              return List.for_all((function(param) do
                            tag = param[0];
                            match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                            if (typeof match == "number" or match.tag and not match[2]) then do
                              return true;
                            end else do
                              return List.mem(tag, fields);
                            end end 
                          end end), row.row_fields);
            end else if (row.row_closed) then do
              return List.for_all((function(param) do
                            if (row_field_repr_aux(--[[ [] ]]0, param[1]) == --[[ Rabsent ]]0) then do
                              return true;
                            end else do
                              return List.mem(param[0], fields);
                            end end 
                          end end), row.row_fields);
            end else do
              return false;
            end end  end  end end 
         if ___conditional___ == 7--[[ Tpat_array ]] then do
            return false; end end 
         if ___conditional___ == 3--[[ Tpat_tuple ]]
         or ___conditional___ == 6--[[ Tpat_record ]]
         or ___conditional___ == 9--[[ Tpat_lazy ]] then do
            return true; end end 
        return fatal_error("Parmatch.full_match");
          
      end
    end end 
  end else do
    return fatal_error("Parmatch.full_match");
  end end 
end end

function full_match_gadt(env) do
  if (env) then do
    match = env[0][0].pat_desc;
    if (typeof match == "number" or match.tag ~= --[[ Tpat_construct ]]4) then do
      return true;
    end else do
      c = match[1];
      return List.length(env) == (c.cstr_consts + c.cstr_nonconsts | 0);
    end end 
  end else do
    return true;
  end end 
end end

function should_extend(ext, env) do
  if (ext ~= undefined and env) then do
    p = env[0][0];
    match = p.pat_desc;
    if (typeof match == "number" or match.tag ~= --[[ Tpat_construct ]]4) then do
      return false;
    end else do
      local ___conditional___=(match[1].cstr_tag.tag | 0);
      do
         if ___conditional___ == 0--[[ Cstr_constant ]]
         or ___conditional___ == 1--[[ Cstr_block ]]
         or ___conditional___ == 2--[[ Cstr_extension ]] then do
            return false; end end 
        
      end
      path = get_type_path(p.pat_type, p.pat_env);
      return same(path, ext);
    end end 
  end else do
    return false;
  end end 
end end

function complete_tags(nconsts, nconstrs, tags) do
  seen_const = Caml_array.caml_make_vect(nconsts, false);
  seen_constr = Caml_array.caml_make_vect(nconstrs, false);
  List.iter((function(param) do
          local ___conditional___=(param.tag | 0);
          do
             if ___conditional___ == 0--[[ Cstr_constant ]] then do
                return Caml_array.caml_array_set(seen_const, param[0], true); end end 
             if ___conditional___ == 1--[[ Cstr_block ]] then do
                return Caml_array.caml_array_set(seen_constr, param[0], true); end end 
             if ___conditional___ == 2--[[ Cstr_extension ]] then do
                error({
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "parmatch.ml",
                    703,
                    14
                  }
                }) end end 
            
          end
        end end), tags);
  r = --[[ [] ]]0;
  for i = 0 , nconsts - 1 | 0 , 1 do
    if (not Caml_array.caml_array_get(seen_const, i)) then do
      r = --[[ :: ]]{
        --[[ Cstr_constant ]]Block.__(0, {i}),
        r
      };
    end
     end 
  end
  for i_1 = 0 , nconstrs - 1 | 0 , 1 do
    if (not Caml_array.caml_array_get(seen_constr, i_1)) then do
      r = --[[ :: ]]{
        --[[ Cstr_block ]]Block.__(1, {i_1}),
        r
      };
    end
     end 
  end
  return r;
end end

function pat_of_constr(ex_pat, cstr) do
  return do
          pat_desc: --[[ Tpat_construct ]]Block.__(4, {
              do
                txt: --[[ Lident ]]Block.__(0, {"?pat_of_constr?"}),
                loc: none
              end,
              cstr,
              omegas(cstr.cstr_arity)
            }),
          pat_loc: ex_pat.pat_loc,
          pat_extra: ex_pat.pat_extra,
          pat_type: ex_pat.pat_type,
          pat_env: ex_pat.pat_env,
          pat_attributes: ex_pat.pat_attributes
        end;
end end

function pat_of_constrs(ex_pat, param) do
  if (param) then do
    rem = param[1];
    cstr = param[0];
    if (rem) then do
      return do
              pat_desc: --[[ Tpat_or ]]Block.__(8, {
                  pat_of_constr(ex_pat, cstr),
                  pat_of_constrs(ex_pat, rem),
                  undefined
                }),
              pat_loc: ex_pat.pat_loc,
              pat_extra: ex_pat.pat_extra,
              pat_type: ex_pat.pat_type,
              pat_env: ex_pat.pat_env,
              pat_attributes: ex_pat.pat_attributes
            end;
    end else do
      return pat_of_constr(ex_pat, cstr);
    end end 
  end else do
    error(Empty)
  end end 
end end

function get_variant_constructors(env, _ty) do
  while(true) do
    ty = _ty;
    match = repr(ty).desc;
    if (typeof match == "number" or match.tag ~= --[[ Tconstr ]]3) then do
      return fatal_error("Parmatch.get_variant_constructors");
    end else do
      path = match[0];
      match_1 = find_type_full(path, env)[0];
      tmp = match_1.type_kind;
      if (typeof tmp ~= "number" and tmp.tag == --[[ Type_variant ]]1) then do
        return find_type_full(path, env)[1][0];
      end
       end 
      if (match_1.type_manifest ~= undefined) then do
        _ty = expand_head_once(env, clean_copy(ty));
        ::continue:: ;
      end else do
        return fatal_error("Parmatch.get_variant_constructors");
      end end 
    end end 
  end;
end end

function map_filter(f, _param) do
  while(true) do
    param = _param;
    if (param) then do
      xs = param[1];
      match = Curry._1(f, param[0]);
      if (match ~= undefined) then do
        return --[[ :: ]]{
                Caml_option.valFromOption(match),
                map_filter(f, xs)
              };
      end else do
        _param = xs;
        ::continue:: ;
      end end 
    end else do
      return --[[ [] ]]0;
    end end 
  end;
end end

function complete_constrs(p, all_tags) do
  match = p.pat_desc;
  if (typeof match == "number" or match.tag ~= --[[ Tpat_construct ]]4) then do
    return fatal_error("Parmatch.complete_constr");
  end else do
    c = match[1];
    not_tags = complete_tags(c.cstr_consts, c.cstr_nonconsts, all_tags);
    constrs = get_variant_constructors(p.pat_env, c.cstr_res);
    return map_filter((function(cnstr) do
                  if (List.exists((function(tag) do
                            return equal_tag(tag, cnstr.cstr_tag);
                          end end), not_tags)) then do
                    return cnstr;
                  end
                   end 
                end end), constrs);
  end end 
end end

function build_other_constant(proj, make, first, next, p, env) do
  all = List.map((function(param) do
          return Curry._1(proj, param[0].pat_desc);
        end end), env);
  _i = first;
  while(true) do
    i = _i;
    if (List.mem(i, all)) then do
      _i = Curry._1(next, i);
      ::continue:: ;
    end else do
      return make_pat(Curry._1(make, i), p.pat_type, p.pat_env);
    end end 
  end;
end end

function build_other(ext, env) do
  if (env) then do
    p = env[0][0];
    match = p.pat_desc;
    if (typeof match == "number") then do
      return omega;
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 2--[[ Tpat_constant ]] then do
            local ___conditional___=(match[0].tag | 0);
            do
               if ___conditional___ == 0--[[ Const_int ]] then do
                  return build_other_constant((function(param) do
                                if (typeof param ~= "number" and param.tag == --[[ Tpat_constant ]]2) then do
                                  match = param[0];
                                  if (not match.tag) then do
                                    return match[0];
                                  end
                                   end 
                                end
                                 end 
                                error({
                                  Caml_builtin_exceptions.assert_failure,
                                  --[[ tuple ]]{
                                    "parmatch.ml",
                                    857,
                                    55
                                  }
                                })
                              end end), (function(i) do
                                return --[[ Tpat_constant ]]Block.__(2, {--[[ Const_int ]]Block.__(0, {i})});
                              end end), 0, (function(prim) do
                                return prim + 1 | 0;
                              end end), p, env); end end 
               if ___conditional___ == 1--[[ Const_char ]] then do
                  all_chars = List.map((function(param) do
                          match = param[0].pat_desc;
                          if (typeof match ~= "number" and match.tag == --[[ Tpat_constant ]]2) then do
                            match_1 = match[0];
                            if (match_1.tag == --[[ Const_char ]]1) then do
                              return match_1[0];
                            end
                             end 
                          end
                           end 
                          error({
                            Caml_builtin_exceptions.assert_failure,
                            --[[ tuple ]]{
                              "parmatch.ml",
                              832,
                              15
                            }
                          })
                        end end), env);
                  _param = --[[ :: ]]{
                    --[[ tuple ]]{
                      --[[ "a" ]]97,
                      --[[ "z" ]]122
                    },
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        --[[ "A" ]]65,
                        --[[ "Z" ]]90
                      },
                      --[[ :: ]]{
                        --[[ tuple ]]{
                          --[[ "0" ]]48,
                          --[[ "9" ]]57
                        },
                        --[[ :: ]]{
                          --[[ tuple ]]{
                            --[[ " " ]]32,
                            --[[ "~" ]]126
                          },
                          --[[ :: ]]{
                            --[[ tuple ]]{
                              Char.chr(0),
                              Char.chr(255)
                            },
                            --[[ [] ]]0
                          }
                        }
                      }
                    }
                  };
                  while(true) do
                    param = _param;
                    if (param) then do
                      match_1 = param[0];
                      xpcall(function() do
                        _i = match_1[0];
                        imax = match_1[1];
                        while(true) do
                          i = _i;
                          if (i > imax) then do
                            error(Caml_builtin_exceptions.not_found)
                          end
                           end 
                          ci = Char.chr(i);
                          if (List.mem(ci, all_chars)) then do
                            _i = i + 1 | 0;
                            ::continue:: ;
                          end else do
                            return make_pat(--[[ Tpat_constant ]]Block.__(2, {--[[ Const_char ]]Block.__(1, {ci})}), p.pat_type, p.pat_env);
                          end end 
                        end;
                      end end,function(exn) do
                        if (exn == Caml_builtin_exceptions.not_found) then do
                          _param = param[1];
                          ::continue:: ;
                        end else do
                          error(exn)
                        end end 
                      end end)
                    end else do
                      return omega;
                    end end 
                  end; end end 
               if ___conditional___ == 2--[[ Const_string ]] then do
                  return build_other_constant((function(param) do
                                if (typeof param ~= "number" and param.tag == --[[ Tpat_constant ]]2) then do
                                  match = param[0];
                                  if (match.tag == --[[ Const_string ]]2) then do
                                    return #match[0];
                                  end
                                   end 
                                end
                                 end 
                                error({
                                  Caml_builtin_exceptions.assert_failure,
                                  --[[ tuple ]]{
                                    "parmatch.ml",
                                    878,
                                    21
                                  }
                                })
                              end end), (function(i) do
                                return --[[ Tpat_constant ]]Block.__(2, {--[[ Const_string ]]Block.__(2, {
                                              Caml_bytes.bytes_to_string(Bytes.make(i, --[[ "*" ]]42)),
                                              undefined
                                            })});
                              end end), 0, (function(prim) do
                                return prim + 1 | 0;
                              end end), p, env); end end 
               if ___conditional___ == 3--[[ Const_float ]] then do
                  return build_other_constant((function(param) do
                                if (typeof param ~= "number" and param.tag == --[[ Tpat_constant ]]2) then do
                                  match = param[0];
                                  if (match.tag == --[[ Const_float ]]3) then do
                                    return Caml_format.caml_float_of_string(match[0]);
                                  end
                                   end 
                                end
                                 end 
                                error({
                                  Caml_builtin_exceptions.assert_failure,
                                  --[[ tuple ]]{
                                    "parmatch.ml",
                                    884,
                                    21
                                  }
                                })
                              end end), (function(f) do
                                return --[[ Tpat_constant ]]Block.__(2, {--[[ Const_float ]]Block.__(3, {Pervasives.string_of_float(f)})});
                              end end), 0.0, (function(f) do
                                return f + 1.0;
                              end end), p, env); end end 
               if ___conditional___ == 4--[[ Const_int32 ]] then do
                  return build_other_constant((function(param) do
                                if (typeof param ~= "number" and param.tag == --[[ Tpat_constant ]]2) then do
                                  match = param[0];
                                  if (match.tag == --[[ Const_int32 ]]4) then do
                                    return match[0];
                                  end
                                   end 
                                end
                                 end 
                                error({
                                  Caml_builtin_exceptions.assert_failure,
                                  --[[ tuple ]]{
                                    "parmatch.ml",
                                    862,
                                    57
                                  }
                                })
                              end end), (function(i) do
                                return --[[ Tpat_constant ]]Block.__(2, {--[[ Const_int32 ]]Block.__(4, {i})});
                              end end), 0, Int32.succ, p, env); end end 
               if ___conditional___ == 5--[[ Const_int64 ]] then do
                  return build_other_constant((function(param) do
                                if (typeof param ~= "number" and param.tag == --[[ Tpat_constant ]]2) then do
                                  match = param[0];
                                  if (match.tag == --[[ Const_int64 ]]5) then do
                                    return match[0];
                                  end
                                   end 
                                end
                                 end 
                                error({
                                  Caml_builtin_exceptions.assert_failure,
                                  --[[ tuple ]]{
                                    "parmatch.ml",
                                    867,
                                    57
                                  }
                                })
                              end end), (function(i) do
                                return --[[ Tpat_constant ]]Block.__(2, {--[[ Const_int64 ]]Block.__(5, {i})});
                              end end), --[[ int64 ]]{
                              --[[ hi ]]0,
                              --[[ lo ]]0
                            }, Int64.succ, p, env); end end 
               if ___conditional___ == 6--[[ Const_nativeint ]] then do
                  return build_other_constant((function(param) do
                                if (typeof param ~= "number" and param.tag == --[[ Tpat_constant ]]2) then do
                                  match = param[0];
                                  if (match.tag == --[[ Const_nativeint ]]6) then do
                                    return match[0];
                                  end
                                   end 
                                end
                                 end 
                                error({
                                  Caml_builtin_exceptions.assert_failure,
                                  --[[ tuple ]]{
                                    "parmatch.ml",
                                    872,
                                    61
                                  }
                                })
                              end end), (function(i) do
                                return --[[ Tpat_constant ]]Block.__(2, {--[[ Const_nativeint ]]Block.__(6, {i})});
                              end end), 0, Nativeint.succ, p, env); end end 
              
            end end end 
         if ___conditional___ == 4--[[ Tpat_construct ]] then do
            c = match[1];
            exit = 0;
            local ___conditional___=(c.cstr_tag.tag | 0);
            do
               if ___conditional___ == 0--[[ Cstr_constant ]]
               or ___conditional___ == 1--[[ Cstr_block ]] then do
                  exit = 1; end else 
               if ___conditional___ == 2--[[ Cstr_extension ]] then do
                  c_cstr_res = c.cstr_res;
                  c_cstr_existentials = c.cstr_existentials;
                  c_cstr_args = c.cstr_args;
                  c_cstr_arity = c.cstr_arity;
                  c_cstr_tag = c.cstr_tag;
                  c_cstr_consts = c.cstr_consts;
                  c_cstr_nonconsts = c.cstr_nonconsts;
                  c_cstr_normal = c.cstr_normal;
                  c_cstr_generalized = c.cstr_generalized;
                  c_cstr_private = c.cstr_private;
                  c_cstr_loc = c.cstr_loc;
                  c_cstr_attributes = c.cstr_attributes;
                  c_1 = do
                    cstr_name: "*extension*",
                    cstr_res: c_cstr_res,
                    cstr_existentials: c_cstr_existentials,
                    cstr_args: c_cstr_args,
                    cstr_arity: c_cstr_arity,
                    cstr_tag: c_cstr_tag,
                    cstr_consts: c_cstr_consts,
                    cstr_nonconsts: c_cstr_nonconsts,
                    cstr_normal: c_cstr_normal,
                    cstr_generalized: c_cstr_generalized,
                    cstr_private: c_cstr_private,
                    cstr_loc: c_cstr_loc,
                    cstr_attributes: c_cstr_attributes
                  end;
                  return make_pat(--[[ Tpat_construct ]]Block.__(4, {
                                match[0],
                                c_1,
                                --[[ [] ]]0
                              }), none_2, empty); end end end end 
              
            end
            if (exit == 1) then do
              if (ext ~= undefined and same(ext, get_type_path(p.pat_type, p.pat_env))) then do
                return extra_pat;
              end
               end 
              all_tags = List.map((function(param) do
                      param_1 = param[0];
                      match = param_1.pat_desc;
                      if (typeof match == "number" or match.tag ~= --[[ Tpat_construct ]]4) then do
                        return fatal_error("Parmatch.get_tag");
                      end else do
                        return match[1].cstr_tag;
                      end end 
                    end end), env);
              return pat_of_constrs(p, complete_constrs(p, all_tags));
            end
             end  end else 
         if ___conditional___ == 5--[[ Tpat_variant ]] then do
            r = match[2];
            tags = List.map((function(param) do
                    match = param[0].pat_desc;
                    if (typeof match == "number") then do
                      error({
                        Caml_builtin_exceptions.assert_failure,
                        --[[ tuple ]]{
                          "parmatch.ml",
                          801,
                          23
                        }
                      })
                    end else if (match.tag == --[[ Tpat_variant ]]5) then do
                      return match[0];
                    end else do
                      error({
                        Caml_builtin_exceptions.assert_failure,
                        --[[ tuple ]]{
                          "parmatch.ml",
                          801,
                          23
                        }
                      })
                    end end  end 
                  end end), env);
            row = row_of_pat(p);
            make_other_pat = function(tag, __const) do
              arg = __const and undefined or omega;
              return make_pat(--[[ Tpat_variant ]]Block.__(5, {
                            tag,
                            arg,
                            r
                          }), p.pat_type, p.pat_env);
            end end;
            match_2 = List.fold_left((function(others, param) do
                    tag = param[0];
                    if (List.mem(tag, tags)) then do
                      return others;
                    end else do
                      match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                      if (typeof match == "number") then do
                        return others;
                      end else if (match.tag) then do
                        return --[[ :: ]]{
                                make_other_pat(tag, match[0]),
                                others
                              };
                      end else do
                        return --[[ :: ]]{
                                make_other_pat(tag, match[0] == undefined),
                                others
                              };
                      end end  end 
                    end end 
                  end end), --[[ [] ]]0, row.row_fields);
            if (match_2) then do
              return List.fold_left((function(p_res, pat) do
                            return make_pat(--[[ Tpat_or ]]Block.__(8, {
                                          pat,
                                          p_res,
                                          undefined
                                        }), p.pat_type, p.pat_env);
                          end end), match_2[0], match_2[1]);
            end else do
              return make_other_pat("AnyExtraTag", true);
            end end  end end end end 
         if ___conditional___ == 7--[[ Tpat_array ]] then do
            all_lengths = List.map((function(param) do
                    match = param[0].pat_desc;
                    if (typeof match == "number") then do
                      error({
                        Caml_builtin_exceptions.assert_failure,
                        --[[ tuple ]]{
                          "parmatch.ml",
                          893,
                          15
                        }
                      })
                    end else if (match.tag == --[[ Tpat_array ]]7) then do
                      return List.length(match[0]);
                    end else do
                      error({
                        Caml_builtin_exceptions.assert_failure,
                        --[[ tuple ]]{
                          "parmatch.ml",
                          893,
                          15
                        }
                      })
                    end end  end 
                  end end), env);
            _l = 0;
            while(true) do
              l = _l;
              if (List.mem(l, all_lengths)) then do
                _l = l + 1 | 0;
                ::continue:: ;
              end else do
                return make_pat(--[[ Tpat_array ]]Block.__(7, {omegas(l)}), p.pat_type, p.pat_env);
              end end 
            end; end end 
        return omega;
          
      end
    end end 
  end else do
    return omega;
  end end 
end end

function build_other_gadt(ext, env) do
  if (env) then do
    p = env[0][0];
    tmp = p.pat_desc;
    if (typeof tmp ~= "number" and tmp.tag == --[[ Tpat_construct ]]4) then do
      all_tags = List.map((function(param) do
              param_1 = param[0];
              match = param_1.pat_desc;
              if (typeof match == "number" or match.tag ~= --[[ Tpat_construct ]]4) then do
                return fatal_error("Parmatch.get_tag");
              end else do
                return match[1].cstr_tag;
              end end 
            end end), env);
      cnstrs = complete_constrs(p, all_tags);
      return List.map((function(param) do
                    return pat_of_constr(p, param);
                  end end), cnstrs);
    end
     end 
  end
   end 
  error({
    Caml_builtin_exceptions.assert_failure,
    --[[ tuple ]]{
      "parmatch.ml",
      917,
      11
    }
  })
end end

function has_instance(_p) do
  while(true) do
    p = _p;
    match = p.pat_desc;
    if (typeof match == "number") then do
      return true;
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 4--[[ Tpat_construct ]] then do
            return has_instances(match[2]); end end 
         if ___conditional___ == 5--[[ Tpat_variant ]] then do
            match_1 = match[1];
            if (is_absent(match[0], match[2])) then do
              return false;
            end else if (match_1 ~= undefined) then do
              _p = match_1;
              ::continue:: ;
            end else do
              return true;
            end end  end  end end 
         if ___conditional___ == 6--[[ Tpat_record ]] then do
            return has_instances(List.map((function(param) do
                              return param[2];
                            end end), match[0])); end end 
         if ___conditional___ == 3--[[ Tpat_tuple ]]
         or ___conditional___ == 7--[[ Tpat_array ]] then do
            return has_instances(match[0]); end end 
         if ___conditional___ == 8--[[ Tpat_or ]] then do
            if (has_instance(match[0])) then do
              return true;
            end else do
              _p = match[1];
              ::continue:: ;
            end end  end end 
         if ___conditional___ == 1--[[ Tpat_alias ]]
         or ___conditional___ == 9--[[ Tpat_lazy ]] then do
            _p = match[0];
            ::continue:: ; end end 
        return true;
          
      end
    end end 
  end;
end end

function has_instances(_param) do
  while(true) do
    param = _param;
    if (param) then do
      if (has_instance(param[0])) then do
        _param = param[1];
        ::continue:: ;
      end else do
        return false;
      end end 
    end else do
      return true;
    end end 
  end;
end end

function satisfiable(_pss, _qs) do
  while(true) do
    qs = _qs;
    pss = _pss;
    if (pss) then do
      if (qs) then do
        q = qs[0];
        match = q.pat_desc;
        exit = 0;
        if (typeof match == "number") then do
          exit = 1;
        end else do
          local ___conditional___=(match.tag | 0);
          do
             if ___conditional___ == 0--[[ Tpat_var ]] then do
                exit = 1; end else 
             if ___conditional___ == 1--[[ Tpat_alias ]] then do
                _qs = --[[ :: ]]{
                  match[0],
                  qs[1]
                };
                ::continue:: ; end end end end 
             if ___conditional___ == 5--[[ Tpat_variant ]] then do
                if (is_absent(match[0], match[2])) then do
                  return false;
                end else do
                  exit = 2;
                end end  end else 
             if ___conditional___ == 8--[[ Tpat_or ]] then do
                qs_1 = qs[1];
                if (satisfiable(pss, --[[ :: ]]{
                        match[0],
                        qs_1
                      })) then do
                  return true;
                end else do
                  _qs = --[[ :: ]]{
                    match[1],
                    qs_1
                  };
                  ::continue:: ;
                end end  end end end end 
            exit = 2;
              
          end
        end end 
        local ___conditional___=(exit);
        do
           if ___conditional___ == 1 then do
              qs_2 = qs[1];
              q0 = discr_pat(omega, pss);
              constrs = filter_all(q0, pss);
              if (constrs) then do
                if (full_match(false, false, constrs)) then do
                  return List.exists((function(qs_2)do
                            return function (param) do
                              p = param[0];
                              if (is_absent_pat(p)) then do
                                return false;
                              end else do
                                return satisfiable(param[1], Pervasives.$at(simple_match_args(p, omega), qs_2));
                              end end 
                            end end
                            end end)(qs_2), constrs);
                end else do
                  _qs = qs_2;
                  _pss = filter_extra(pss);
                  ::continue:: ;
                end end 
              end else do
                _qs = qs_2;
                _pss = filter_extra(pss);
                ::continue:: ;
              end end  end end 
           if ___conditional___ == 2 then do
              q0_1 = discr_pat(q, pss);
              _qs = Pervasives.$at(simple_match_args(q0_1, q), qs[1]);
              _pss = filter_one(q0_1, pss);
              ::continue:: ; end end 
          
        end
      end else do
        return false;
      end end 
    end else do
      return has_instances(qs);
    end end 
  end;
end end

function orify_many(param) do
  if (param) then do
    xs = param[1];
    x = param[0];
    if (xs) then do
      x_1 = x;
      y = Curry._1(orify_many, xs);
      return make_pat(--[[ Tpat_or ]]Block.__(8, {
                    x_1,
                    y,
                    undefined
                  }), x_1.pat_type, x_1.pat_env);
    end else do
      return x;
    end end 
  end else do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "parmatch.ml",
        989,
        12
      }
    })
  end end 
end end

function try_many_gadt(f, param) do
  if (param) then do
    match = param[0];
    r1 = Curry._1(f, --[[ tuple ]]{
          match[0],
          match[1]
        });
    r2 = try_many_gadt(f, param[1]);
    if (r1) then do
      if (r2) then do
        return --[[ Rsome ]]{Pervasives.$at(r1[0], r2[0])};
      end else do
        return r1;
      end end 
    end else do
      return r2;
    end end 
  end else do
    return --[[ Rnone ]]0;
  end end 
end end

function exhaust(ext, pss, n) do
  if (pss) then do
    if (pss[0]) then do
      q0 = discr_pat(omega, pss);
      constrs = filter_all(q0, pss);
      if (constrs) then do
        try_non_omega = function(param) do
          p = param[0];
          if (is_absent_pat(p)) then do
            return --[[ Rnone ]]0;
          end else do
            r = exhaust(ext, param[1], (List.length(simple_match_args(p, omega)) + n | 0) - 1 | 0);
            if (r) then do
              return --[[ Rsome ]]{do_set_args(false, p, r[0])};
            end else do
              return r;
            end end 
          end end 
        end end;
        if (full_match(true, false, constrs) and not should_extend(ext, constrs)) then do
          f = try_non_omega;
          _param = constrs;
          while(true) do
            param = _param;
            if (param) then do
              match = param[0];
              r = Curry._1(f, --[[ tuple ]]{
                    match[0],
                    match[1]
                  });
              if (r) then do
                return r;
              end else do
                _param = param[1];
                ::continue:: ;
              end end 
            end else do
              return --[[ Rnone ]]0;
            end end 
          end;
        end else do
          r_1 = exhaust(ext, filter_extra(pss), n - 1 | 0);
          if (r_1) then do
            xpcall(function() do
              return --[[ Rsome ]]{--[[ :: ]]{
                        build_other(ext, constrs),
                        r_1[0]
                      }};
            end end,function(exn) do
              if (exn == Empty) then do
                return fatal_error("Parmatch.exhaust");
              end else do
                error(exn)
              end end 
            end end)
          end else do
            return --[[ Rnone ]]0;
          end end 
        end end 
      end else do
        r_2 = exhaust(ext, filter_extra(pss), n - 1 | 0);
        if (r_2) then do
          return --[[ Rsome ]]{--[[ :: ]]{
                    q0,
                    r_2[0]
                  }};
        end else do
          return r_2;
        end end 
      end end 
    end else do
      return --[[ Rnone ]]0;
    end end 
  end else do
    return --[[ Rsome ]]{omegas(n)};
  end end 
end end

function combinations(f, lst, lst$prime) do
  iter2 = function(x, param) do
    if (param) then do
      return --[[ :: ]]{
              Curry._2(f, x, param[0]),
              iter2(x, param[1])
            };
    end else do
      return --[[ [] ]]0;
    end end 
  end end;
  iter = function(param) do
    if (param) then do
      return Pervasives.$at(iter2(param[0], lst$prime), iter(param[1]));
    end else do
      return --[[ [] ]]0;
    end end 
  end end;
  return iter(lst);
end end

function exhaust_gadt(ext, pss, n) do
  if (pss) then do
    if (pss[0]) then do
      q0 = discr_pat(omega, pss);
      constrs = filter_all(q0, pss);
      if (constrs) then do
        try_non_omega = function(param) do
          p = param[0];
          if (is_absent_pat(p)) then do
            return --[[ Rnone ]]0;
          end else do
            r = exhaust_gadt(ext, param[1], (List.length(simple_match_args(p, omega)) + n | 0) - 1 | 0);
            if (r) then do
              return --[[ Rsome ]]{List.map((function(row) do
                              return do_set_args(false, p, row);
                            end end), r[0])};
            end else do
              return r;
            end end 
          end end 
        end end;
        before = try_many_gadt(try_non_omega, constrs);
        if (full_match_gadt(constrs) and not should_extend(ext, constrs)) then do
          return before;
        end else do
          r = exhaust_gadt(ext, filter_extra(pss), n - 1 | 0);
          if (r) then do
            xpcall(function() do
              missing_trailing = build_other_gadt(ext, constrs);
              dug = combinations((function(head, tail) do
                      return --[[ :: ]]{
                              head,
                              tail
                            };
                    end end), missing_trailing, r[0]);
              if (before) then do
                return --[[ Rsome ]]{Pervasives.$at(before[0], dug)};
              end else do
                return --[[ Rsome ]]{dug};
              end end 
            end end,function(exn) do
              if (exn == Empty) then do
                return fatal_error("Parmatch.exhaust");
              end else do
                error(exn)
              end end 
            end end)
          end else do
            return before;
          end end 
        end end 
      end else do
        r_1 = exhaust_gadt(ext, filter_extra(pss), n - 1 | 0);
        if (r_1) then do
          return --[[ Rsome ]]{List.map((function(row) do
                          return --[[ :: ]]{
                                  q0,
                                  row
                                };
                        end end), r_1[0])};
        end else do
          return r_1;
        end end 
      end end 
    end else do
      return --[[ Rnone ]]0;
    end end 
  end else do
    return --[[ Rsome ]]{--[[ :: ]]{
              omegas(n),
              --[[ [] ]]0
            }};
  end end 
end end

function exhaust_gadt_1(ext, pss, n) do
  ret = exhaust_gadt(ext, pss, n);
  if (ret) then do
    lst = ret[0];
    if (lst == --[[ [] ]]0) then do
      return --[[ Rsome ]]{omegas(n)};
    end else do
      singletons = List.map((function(param) do
              if (param) then do
                if (param[1]) then do
                  error({
                    Caml_builtin_exceptions.assert_failure,
                    --[[ tuple ]]{
                      "parmatch.ml",
                      1165,
                      19
                    }
                  })
                end
                 end 
                return param[0];
              end else do
                error({
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "parmatch.ml",
                    1165,
                    19
                  }
                })
              end end 
            end end), lst);
      return --[[ Rsome ]]{--[[ :: ]]{
                Curry._1(orify_many, singletons),
                --[[ [] ]]0
              }};
    end end 
  end else do
    return --[[ Rnone ]]0;
  end end 
end end

function pressure_variants(_tdefs, _pss) do
  while(true) do
    pss = _pss;
    tdefs = _tdefs;
    if (pss) then do
      if (pss[0]) then do
        q0 = discr_pat(omega, pss);
        constrs = filter_all(q0, pss);
        if (constrs) then do
          try_non_omega = (function(tdefs)do
          return function try_non_omega(param) do
            if (param) then do
              ok = pressure_variants(tdefs, param[0][1]);
              if (try_non_omega(param[1])) then do
                return ok;
              end else do
                return false;
              end end 
            end else do
              return true;
            end end 
          end end
          end end)(tdefs);
          if (full_match(true, tdefs == undefined, constrs)) then do
            return try_non_omega(constrs);
          end else if (tdefs == undefined) then do
            _pss = filter_extra(pss);
            _tdefs = undefined;
            ::continue:: ;
          end else do
            full = full_match(true, true, constrs);
            ok = full and try_non_omega(constrs) or try_non_omega(filter_all(q0, mark_partial(pss)));
            if (constrs) then do
              p = constrs[0][0];
              tmp = p.pat_desc;
              if (typeof tmp ~= "number" and tmp.tag == --[[ Tpat_variant ]]5 and tdefs ~= undefined) then do
                row = row_of_pat(p);
                if (not (row_fixed(row) or pressure_variants(undefined, filter_extra(pss)))) then do
                  close_variant(Caml_option.valFromOption(tdefs), row);
                end
                 end 
              end
               end 
            end
             end 
            return ok;
          end end  end 
        end else do
          _pss = filter_extra(pss);
          ::continue:: ;
        end end 
      end else do
        return true;
      end end 
    end else do
      return false;
    end end 
  end;
end end

function make_row(ps) do
  return do
          no_ors: --[[ [] ]]0,
          ors: --[[ [] ]]0,
          active: ps
        end;
end end

function unalias_1(_p) do
  while(true) do
    p = _p;
    match = p.pat_desc;
    if (typeof match == "number" or match.tag ~= --[[ Tpat_alias ]]1) then do
      return p;
    end else do
      _p = match[0];
      ::continue:: ;
    end end 
  end;
end end

function is_var_column(rs) do
  return List.for_all((function(r) do
                match = r.active;
                if (match) then do
                  p = match[0];
                  match_1 = unalias_1(p).pat_desc;
                  if (typeof match_1 == "number" or not match_1.tag) then do
                    return true;
                  end else do
                    return false;
                  end end 
                end else do
                  error({
                    Caml_builtin_exceptions.assert_failure,
                    --[[ tuple ]]{
                      "parmatch.ml",
                      1274,
                      14
                    }
                  })
                end end 
              end end), rs);
end end

function or_args(_p) do
  while(true) do
    p = _p;
    match = p.pat_desc;
    if (typeof match == "number") then do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "parmatch.ml",
          1281,
          23
        }
      })
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 1--[[ Tpat_alias ]] then do
            _p = match[0];
            ::continue:: ; end end 
         if ___conditional___ == 8--[[ Tpat_or ]] then do
            return --[[ tuple ]]{
                    match[0],
                    match[1]
                  }; end end 
        error({
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "parmatch.ml",
              1281,
              23
            }
          })
          
      end
    end end 
  end;
end end

function remove(r) do
  match = r.active;
  if (match) then do
    return do
            no_ors: r.no_ors,
            ors: r.ors,
            active: match[1]
          end;
  end else do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "parmatch.ml",
        1286,
        12
      }
    })
  end end 
end end

function push_no_or(r) do
  match = r.active;
  if (match) then do
    return do
            no_ors: --[[ :: ]]{
              match[0],
              r.no_ors
            },
            ors: r.ors,
            active: match[1]
          end;
  end else do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "parmatch.ml",
        1293,
        8
      }
    })
  end end 
end end

function push_or(r) do
  match = r.active;
  if (match) then do
    return do
            no_ors: r.no_ors,
            ors: --[[ :: ]]{
              match[0],
              r.ors
            },
            active: match[1]
          end;
  end else do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "parmatch.ml",
        1297,
        8
      }
    })
  end end 
end end

function discr_pat_1(q, rs) do
  return discr_pat(q, List.map((function(r) do
                    return r.active;
                  end end), rs));
end end

function filter_one_1(q, rs) do
  filter_rec = function(_rs) do
    while(true) do
      rs = _rs;
      if (rs) then do
        rem = rs[1];
        r = rs[0];
        match = r.active;
        if (match) then do
          p = match[0];
          match_1 = p.pat_desc;
          if (typeof match_1 ~= "number") then do
            local ___conditional___=(match_1.tag | 0);
            do
               if ___conditional___ == 1--[[ Tpat_alias ]] then do
                  _rs = --[[ :: ]]{
                    do
                      no_ors: r.no_ors,
                      ors: r.ors,
                      active: --[[ :: ]]{
                        match_1[0],
                        match[1]
                      }
                    end,
                    rem
                  };
                  ::continue:: ; end end 
               if ___conditional___ == 8--[[ Tpat_or ]] then do
                  ps = match[1];
                  _rs = --[[ :: ]]{
                    do
                      no_ors: r.no_ors,
                      ors: r.ors,
                      active: --[[ :: ]]{
                        match_1[0],
                        ps
                      }
                    end,
                    --[[ :: ]]{
                      do
                        no_ors: r.no_ors,
                        ors: r.ors,
                        active: --[[ :: ]]{
                          match_1[1],
                          ps
                        }
                      end,
                      rem
                    }
                  };
                  ::continue:: ; end end 
              
            end
          end
           end 
          if (simple_match(q, p)) then do
            return --[[ :: ]]{
                    do
                      no_ors: r.no_ors,
                      ors: r.ors,
                      active: Pervasives.$at(simple_match_args(q, p), match[1])
                    end,
                    filter_rec(rem)
                  };
          end else do
            _rs = rem;
            ::continue:: ;
          end end 
        end else do
          error({
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "parmatch.ml",
              1314,
              14
            }
          })
        end end 
      end else do
        return --[[ [] ]]0;
      end end 
    end;
  end end;
  return filter_rec(rs);
end end

function make_vector(r) do
  return r.no_ors;
end end

function extract_elements(qs) do
  do_rec = function(seen, param) do
    if (param) then do
      rem = param[1];
      q = param[0];
      return --[[ :: ]]{
              do
                no_ors: Pervasives.$at(List.rev_append(seen, rem), qs.no_ors),
                ors: --[[ [] ]]0,
                active: --[[ :: ]]{
                  q,
                  --[[ [] ]]0
                }
              end,
              do_rec(--[[ :: ]]{
                    q,
                    seen
                  }, rem)
            };
    end else do
      return --[[ [] ]]0;
    end end 
  end end;
  return do_rec(--[[ [] ]]0, qs.ors);
end end

function extract_columns(pss, qs) do
  if (pss) then do
    rs = List.map(extract_elements, pss);
    if (rs) then do
      i = List.map((function(x) do
              return --[[ :: ]]{
                      x,
                      --[[ [] ]]0
                    };
            end end), rs[0]);
      return List.fold_left((function(param, param_1) do
                    return List.map2((function(r, x) do
                                  return --[[ :: ]]{
                                          x,
                                          r
                                        };
                                end end), param, param_1);
                  end end), i, rs[1]);
    end else do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "parmatch.ml",
          1357,
          8
        }
      })
    end end 
  end else do
    return List.map((function(param) do
                  return --[[ [] ]]0;
                end end), qs.ors);
  end end 
end end

function every_satisfiables(_pss, _qs) do
  while(true) do
    qs = _qs;
    pss = _pss;
    match = qs.active;
    if (match) then do
      q = match[0];
      uq = unalias_1(q);
      match_1 = uq.pat_desc;
      exit = 0;
      if (typeof match_1 == "number") then do
        exit = 2;
      end else do
        local ___conditional___=(match_1.tag | 0);
        do
           if ___conditional___ == 0--[[ Tpat_var ]] then do
              exit = 2; end else 
           if ___conditional___ == 5--[[ Tpat_variant ]] then do
              if (is_absent(match_1[0], match_1[2])) then do
                return --[[ Unused ]]1;
              end else do
                exit = 1;
              end end  end else 
           if ___conditional___ == 8--[[ Tpat_or ]] then do
              if (match_1[0].pat_loc.loc_ghost and match_1[1].pat_loc.loc_ghost) then do
                _qs = push_no_or(qs);
                _pss = List.map(push_no_or, pss);
                ::continue:: ;
              end else do
                _qs = push_or(qs);
                _pss = List.map(push_or, pss);
                ::continue:: ;
              end end  end end end end end end 
          exit = 1;
            
        end
      end end 
      local ___conditional___=(exit);
      do
         if ___conditional___ == 1 then do
            q0 = discr_pat_1(q, pss);
            _qs = do
              no_ors: qs.no_ors,
              ors: qs.ors,
              active: Pervasives.$at(simple_match_args(q0, q), match[1])
            end;
            _pss = filter_one_1(q0, pss);
            ::continue:: ; end end 
         if ___conditional___ == 2 then do
            if (is_var_column(pss)) then do
              _qs = remove(qs);
              _pss = List.map(remove, pss);
              ::continue:: ;
            end else do
              _qs = push_no_or(qs);
              _pss = List.map(push_no_or, pss);
              ::continue:: ;
            end end  end end 
        
      end
    end else do
      match_2 = qs.ors;
      if (match_2) then do
        return List.fold_right2((function(pss, qs, r) do
                      if (typeof r == "number" and r ~= 0) then do
                        return --[[ Unused ]]1;
                      end
                       end 
                      match = qs.active;
                      if (match) then do
                        if (match[1]) then do
                          error({
                            Caml_builtin_exceptions.assert_failure,
                            --[[ tuple ]]{
                              "parmatch.ml",
                              1394,
                              23
                            }
                          })
                        end
                         end 
                        match_1 = or_args(match[0]);
                        r_loc = every_both(pss, qs, match_1[0], match_1[1]);
                        r1 = r;
                        r2 = r_loc;
                        if (typeof r1 == "number") then do
                          if (r1 ~= 0) then do
                            return --[[ Unused ]]1;
                          end
                           end 
                        end else if (typeof r2 == "number") then do
                          if (r2 == 0) then do
                            return r1;
                          end
                           end 
                        end else do
                          return --[[ Upartial ]]{Pervasives.$at(r1[0], r2[0])};
                        end end  end 
                        if (typeof r2 == "number" and r2 ~= 0) then do
                          return --[[ Unused ]]1;
                        end else do
                          return r2;
                        end end 
                      end else do
                        error({
                          Caml_builtin_exceptions.assert_failure,
                          --[[ tuple ]]{
                            "parmatch.ml",
                            1394,
                            23
                          }
                        })
                      end end 
                    end end), extract_columns(pss, qs), extract_elements(qs), --[[ Used ]]0);
      end else if (satisfiable(List.map(make_vector, pss), qs.no_ors)) then do
        return --[[ Used ]]0;
      end else do
        return --[[ Unused ]]1;
      end end  end 
    end end 
  end;
end end

function every_both(pss, qs, q1, q2) do
  qs1_no_ors = qs.no_ors;
  qs1_ors = qs.ors;
  qs1_active = --[[ :: ]]{
    q1,
    --[[ [] ]]0
  };
  qs1 = do
    no_ors: qs1_no_ors,
    ors: qs1_ors,
    active: qs1_active
  end;
  qs2_no_ors = qs.no_ors;
  qs2_ors = qs.ors;
  qs2_active = --[[ :: ]]{
    q2,
    --[[ [] ]]0
  };
  qs2 = do
    no_ors: qs2_no_ors,
    ors: qs2_ors,
    active: qs2_active
  end;
  r1 = every_satisfiables(pss, qs1);
  r2 = every_satisfiables(compat(q1, q2) and --[[ :: ]]{
          qs1,
          pss
        } or pss, qs2);
  if (typeof r1 == "number") then do
    if (r1 ~= 0) then do
      if (typeof r2 == "number") then do
        if (r2 ~= 0) then do
          return --[[ Unused ]]1;
        end else do
          return --[[ Upartial ]]{--[[ :: ]]{
                    q1,
                    --[[ [] ]]0
                  }};
        end end 
      end else do
        return --[[ Upartial ]]{--[[ :: ]]{
                  q1,
                  r2[0]
                }};
      end end 
    end else if (typeof r2 == "number" and r2 ~= 0) then do
      return --[[ Upartial ]]{--[[ :: ]]{
                q2,
                --[[ [] ]]0
              }};
    end else do
      return r2;
    end end  end 
  end else do
    u1 = r1[0];
    if (typeof r2 == "number") then do
      if (r2 ~= 0) then do
        return --[[ Upartial ]]{Pervasives.$at(u1, --[[ :: ]]{
                      q2,
                      --[[ [] ]]0
                    })};
      end else do
        return r1;
      end end 
    end else do
      return --[[ Upartial ]]{Pervasives.$at(u1, r2[0])};
    end end 
  end end 
end end

function le_pat(_p, _q) do
  while(true) do
    q = _q;
    p = _p;
    match = p.pat_desc;
    match_1 = q.pat_desc;
    exit = 0;
    if (typeof match == "number") then do
      return true;
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 0--[[ Tpat_var ]] then do
            return true; end end 
         if ___conditional___ == 1--[[ Tpat_alias ]] then do
            _p = match[0];
            ::continue:: ; end end 
         if ___conditional___ == 2--[[ Tpat_constant ]] then do
            if (typeof match_1 ~= "number") then do
              local ___conditional___=(match_1.tag | 0);
              do
                 if ___conditional___ == 1--[[ Tpat_alias ]] then do
                    exit = 2; end else 
                 if ___conditional___ == 2--[[ Tpat_constant ]] then do
                    return const_compare(match[0], match_1[0]) == 0; end end end end 
                
              end
            end
             end  end else 
         if ___conditional___ == 3--[[ Tpat_tuple ]] then do
            if (typeof match_1 ~= "number") then do
              local ___conditional___=(match_1.tag | 0);
              do
                 if ___conditional___ == 1--[[ Tpat_alias ]] then do
                    exit = 2; end else 
                 if ___conditional___ == 3--[[ Tpat_tuple ]] then do
                    return le_pats(match[0], match_1[0]); end end end end 
                
              end
            end
             end  end else 
         if ___conditional___ == 4--[[ Tpat_construct ]] then do
            if (typeof match_1 ~= "number") then do
              local ___conditional___=(match_1.tag | 0);
              do
                 if ___conditional___ == 1--[[ Tpat_alias ]] then do
                    exit = 2; end else 
                 if ___conditional___ == 4--[[ Tpat_construct ]] then do
                    if (equal_tag(match[1].cstr_tag, match_1[1].cstr_tag)) then do
                      return le_pats(match[2], match_1[2]);
                    end else do
                      return false;
                    end end  end end end end 
                
              end
            end
             end  end else 
         if ___conditional___ == 5--[[ Tpat_variant ]] then do
            match_2 = match[1];
            l1 = match[0];
            if (match_2 ~= undefined) then do
              if (typeof match_1 ~= "number") then do
                local ___conditional___=(match_1.tag | 0);
                do
                   if ___conditional___ == 1--[[ Tpat_alias ]] then do
                      exit = 2; end else 
                   if ___conditional___ == 5--[[ Tpat_variant ]] then do
                      match_3 = match_1[1];
                      if (match_3 ~= undefined and l1 == match_1[0]) then do
                        _q = match_3;
                        _p = match_2;
                        ::continue:: ;
                      end else do
                        return false;
                      end end  end end end end 
                  
                end
              end
               end 
            end else if (typeof match_1 ~= "number") then do
              local ___conditional___=(match_1.tag | 0);
              do
                 if ___conditional___ == 1--[[ Tpat_alias ]] then do
                    exit = 2; end else 
                 if ___conditional___ == 5--[[ Tpat_variant ]] then do
                    if (match_1[1] ~= undefined) then do
                      return false;
                    end else do
                      return l1 == match_1[0];
                    end end  end end end end 
                
              end
            end
             end  end  end else 
         if ___conditional___ == 6--[[ Tpat_record ]] then do
            if (typeof match_1 ~= "number") then do
              local ___conditional___=(match_1.tag | 0);
              do
                 if ___conditional___ == 1--[[ Tpat_alias ]] then do
                    exit = 2; end else 
                 if ___conditional___ == 6--[[ Tpat_record ]] then do
                    match_4 = records_args(match[0], match_1[0]);
                    return le_pats(match_4[0], match_4[1]); end end end end 
                
              end
            end
             end  end else 
         if ___conditional___ == 7--[[ Tpat_array ]] then do
            ps = match[0];
            if (typeof match_1 ~= "number") then do
              local ___conditional___=(match_1.tag | 0);
              do
                 if ___conditional___ == 1--[[ Tpat_alias ]] then do
                    exit = 2; end else 
                 if ___conditional___ == 7--[[ Tpat_array ]] then do
                    qs = match_1[0];
                    if (List.length(ps) == List.length(qs)) then do
                      return le_pats(ps, qs);
                    end else do
                      return false;
                    end end  end end end end 
                
              end
            end
             end  end else 
         if ___conditional___ == 8--[[ Tpat_or ]] then do
            exit = 2; end else 
         if ___conditional___ == 9--[[ Tpat_lazy ]] then do
            if (typeof match_1 ~= "number") then do
              local ___conditional___=(match_1.tag | 0);
              do
                 if ___conditional___ == 1--[[ Tpat_alias ]] then do
                    exit = 2; end else 
                 if ___conditional___ == 9--[[ Tpat_lazy ]] then do
                    _q = match_1[0];
                    _p = match[0];
                    ::continue:: ; end end end end 
                
              end
            end
             end  end else 
         end end end end end end end end end end end end end end end end
        
      end
    end end 
    if (exit == 2 and typeof match_1 ~= "number" and match_1.tag == --[[ Tpat_alias ]]1) then do
      _q = match_1[0];
      ::continue:: ;
    end
     end 
    return not satisfiable(--[[ :: ]]{
                --[[ :: ]]{
                  p,
                  --[[ [] ]]0
                },
                --[[ [] ]]0
              }, --[[ :: ]]{
                q,
                --[[ [] ]]0
              });
  end;
end end

function le_pats(_ps, _qs) do
  while(true) do
    qs = _qs;
    ps = _ps;
    if (ps and qs) then do
      if (le_pat(ps[0], qs[0])) then do
        _qs = qs[1];
        _ps = ps[1];
        ::continue:: ;
      end else do
        return false;
      end end 
    end else do
      return true;
    end end 
  end;
end end

function get_mins(le, ps) do
  select_rec = function(_r, _param) do
    while(true) do
      param = _param;
      r = _r;
      if (param) then do
        ps = param[1];
        p = param[0];
        if (List.exists((function(p)do
              return function (p0) do
                return Curry._2(le, p0, p);
              end end
              end end)(p), ps)) then do
          _param = ps;
          ::continue:: ;
        end else do
          _param = ps;
          _r = --[[ :: ]]{
            p,
            r
          };
          ::continue:: ;
        end end 
      end else do
        return r;
      end end 
    end;
  end end;
  return select_rec(--[[ [] ]]0, select_rec(--[[ [] ]]0, ps));
end end

function pressure_variants_1(tdefs, patl) do
  pss = List.map((function(p) do
          return --[[ :: ]]{
                  p,
                  --[[ :: ]]{
                    omega,
                    --[[ [] ]]0
                  }
                };
        end end), patl);
  pressure_variants(Caml_option.some(tdefs), pss);
  return --[[ () ]]0;
end end

function initial_matrix(_param) do
  while(true) do
    param = _param;
    if (param) then do
      match = param[0];
      if (match.c_guard ~= undefined) then do
        _param = param[1];
        ::continue:: ;
      end else do
        return --[[ :: ]]{
                --[[ :: ]]{
                  match.c_lhs,
                  --[[ [] ]]0
                },
                initial_matrix(param[1])
              };
      end end 
    end else do
      return --[[ [] ]]0;
    end end 
  end;
end end

NoGuard = Caml_exceptions.create("Ocaml_typedtree_test.Parmatch.NoGuard");

function initial_all(no_guard, param) do
  if (param) then do
    match = param[0];
    pat = match.c_lhs;
    return --[[ :: ]]{
            --[[ tuple ]]{
              --[[ :: ]]{
                pat,
                --[[ [] ]]0
              },
              pat.pat_loc
            },
            initial_all(no_guard and match.c_guard == undefined, param[1])
          };
  end else if (no_guard) then do
    error(NoGuard)
  end else do
    return --[[ [] ]]0;
  end end  end 
end end

function do_filter_var(param) do
  if (param) then do
    match = param[0];
    match_1 = match[0];
    if (match_1) then do
      return --[[ :: ]]{
              --[[ tuple ]]{
                match_1[1],
                match[1]
              },
              do_filter_var(param[1])
            };
    end else do
      return --[[ [] ]]0;
    end end 
  end else do
    return --[[ [] ]]0;
  end end 
end end

function do_filter_one(q, pss) do
  filter_rec = function(_param) do
    while(true) do
      param = _param;
      if (param) then do
        match = param[0];
        match_1 = match[0];
        if (match_1) then do
          p = match_1[0];
          match_2 = p.pat_desc;
          if (typeof match_2 ~= "number") then do
            local ___conditional___=(match_2.tag | 0);
            do
               if ___conditional___ == 1--[[ Tpat_alias ]] then do
                  _param = --[[ :: ]]{
                    --[[ tuple ]]{
                      --[[ :: ]]{
                        match_2[0],
                        match_1[1]
                      },
                      match[1]
                    },
                    param[1]
                  };
                  ::continue:: ; end end 
               if ___conditional___ == 8--[[ Tpat_or ]] then do
                  loc = match[1];
                  ps = match_1[1];
                  _param = --[[ :: ]]{
                    --[[ tuple ]]{
                      --[[ :: ]]{
                        match_2[0],
                        ps
                      },
                      loc
                    },
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        --[[ :: ]]{
                          match_2[1],
                          ps
                        },
                        loc
                      },
                      param[1]
                    }
                  };
                  ::continue:: ; end end 
              
            end
          end
           end 
          pss = param[1];
          if (simple_match(q, p)) then do
            return --[[ :: ]]{
                    --[[ tuple ]]{
                      Pervasives.$at(simple_match_args(q, p), match_1[1]),
                      match[1]
                    },
                    filter_rec(pss)
                  };
          end else do
            _param = pss;
            ::continue:: ;
          end end 
        end else do
          return --[[ [] ]]0;
        end end 
      end else do
        return --[[ [] ]]0;
      end end 
    end;
  end end;
  return filter_rec(pss);
end end

function do_match(_pss, _qs) do
  while(true) do
    qs = _qs;
    pss = _pss;
    if (qs) then do
      q = qs[0];
      match = q.pat_desc;
      qs_1 = qs[1];
      if (typeof match == "number") then do
        _qs = qs_1;
        _pss = do_filter_var(pss);
        ::continue:: ;
      end else if (match.tag == --[[ Tpat_or ]]8) then do
        r = do_match(pss, --[[ :: ]]{
              match[0],
              qs_1
            });
        if (r ~= undefined) then do
          return r;
        end else do
          _qs = --[[ :: ]]{
            match[1],
            qs_1
          };
          ::continue:: ;
        end end 
      end else do
        q0 = normalize_pat(q);
        _qs = Pervasives.$at(simple_match_args(q0, q), qs_1);
        _pss = do_filter_one(q0, pss);
        ::continue:: ;
      end end  end 
    end else if (pss) then do
      match_1 = pss[0];
      if (match_1[0]) then do
        return ;
      end else do
        return Caml_option.some(match_1[1]);
      end end 
    end else do
      return ;
    end end  end 
  end;
end end

function check_partial_all(v, casel) do
  xpcall(function() do
    pss = initial_all(true, casel);
    return do_match(pss, --[[ :: ]]{
                v,
                --[[ [] ]]0
              });
  end end,function(exn) do
    if (exn == NoGuard) then do
      return ;
    end else do
      error(exn)
    end end 
  end end)
end end

function get_first(f, _param) do
  while(true) do
    param = _param;
    if (param) then do
      x = Curry._1(f, param[0]);
      if (x ~= undefined) then do
        return x;
      end else do
        _param = param[1];
        ::continue:: ;
      end end 
    end else do
      return ;
    end end 
  end;
end end

function select(param) do
  if (param) then do
    xs = param[0];
    if (param[1]) then do
      if (xs) then do
        ys = param[1];
        x = xs[0];
        return Pervasives.$at(List.map((function(lst) do
                          return --[[ :: ]]{
                                  x,
                                  lst
                                };
                        end end), select(ys)), select(--[[ :: ]]{
                        xs[1],
                        ys
                      }));
      end else do
        return --[[ [] ]]0;
      end end 
    end else do
      return List.map((function(y) do
                    return --[[ :: ]]{
                            y,
                            --[[ [] ]]0
                          };
                  end end), xs);
    end end 
  end else do
    return --[[ [] ]]0;
  end end 
end end

name_counter_1 = do
  contents: 0
end;

function fresh(name) do
  current = name_counter_1.contents;
  name_counter_1.contents = name_counter_1.contents + 1 | 0;
  return "#$" .. (name .. String(current));
end end

function conv(typed) do
  constrs = Hashtbl.create(undefined, 0);
  labels = Hashtbl.create(undefined, 0);
  loop = function(_pat) do
    while(true) do
      pat = _pat;
      match = pat.pat_desc;
      if (typeof match == "number") then do
        return --[[ :: ]]{
                mk_1(undefined, undefined, --[[ Ppat_any ]]0),
                --[[ [] ]]0
              };
      end else do
        local ___conditional___=(match.tag | 0);
        do
           if ___conditional___ == 1--[[ Tpat_alias ]] then do
              _pat = match[0];
              ::continue:: ; end end 
           if ___conditional___ == 3--[[ Tpat_tuple ]] then do
              results = select(List.map(loop, match[0]));
              return List.map((function(lst) do
                            return mk_1(undefined, undefined, --[[ Ppat_tuple ]]Block.__(4, {lst}));
                          end end), results); end end 
           if ___conditional___ == 4--[[ Tpat_construct ]] then do
              lst = match[2];
              cstr = match[1];
              id = fresh(cstr.cstr_name);
              lid_txt = --[[ Lident ]]Block.__(0, {id});
              lid_loc = match[0].loc;
              lid = do
                txt: lid_txt,
                loc: lid_loc
              end;
              Hashtbl.add(constrs, id, cstr);
              results_1 = select(List.map(loop, lst));
              if (lst) then do
                return List.map((function(lid)do
                          return function (lst) do
                            arg;
                            if (lst) then do
                              arg = lst[1] and mk_1(undefined, undefined, --[[ Ppat_tuple ]]Block.__(4, {lst})) or lst[0];
                            end else do
                              error({
                                Caml_builtin_exceptions.assert_failure,
                                --[[ tuple ]]{
                                  "parmatch.ml",
                                  1729,
                                  28
                                }
                              })
                            end end 
                            return mk_1(undefined, undefined, --[[ Ppat_construct ]]Block.__(5, {
                                          lid,
                                          arg
                                        }));
                          end end
                          end end)(lid), results_1);
              end else do
                return --[[ :: ]]{
                        mk_1(undefined, undefined, --[[ Ppat_construct ]]Block.__(5, {
                                lid,
                                undefined
                              })),
                        --[[ [] ]]0
                      };
              end end  end end 
           if ___conditional___ == 5--[[ Tpat_variant ]] then do
              p_opt = match[1];
              label = match[0];
              if (p_opt ~= undefined) then do
                results_2 = loop(p_opt);
                return List.map((function(label)do
                          return function (p) do
                            return mk_1(undefined, undefined, --[[ Ppat_variant ]]Block.__(6, {
                                          label,
                                          p
                                        }));
                          end end
                          end end)(label), results_2);
              end else do
                return --[[ :: ]]{
                        mk_1(undefined, undefined, --[[ Ppat_variant ]]Block.__(6, {
                                label,
                                undefined
                              })),
                        --[[ [] ]]0
                      };
              end end  end end 
           if ___conditional___ == 6--[[ Tpat_record ]] then do
              subpatterns = match[0];
              pats = select(List.map((function(param) do
                          return loop(param[2]);
                        end end), subpatterns));
              label_idents = List.map((function(param) do
                      lbl = param[1];
                      id = fresh(lbl.lbl_name);
                      Hashtbl.add(labels, id, lbl);
                      return --[[ Lident ]]Block.__(0, {id});
                    end end), subpatterns);
              return List.map((function(label_idents)do
                        return function (lst) do
                          lst_1 = List.map2((function(lid, pat) do
                                  return --[[ tuple ]]{
                                          do
                                            txt: lid,
                                            loc: none
                                          end,
                                          pat
                                        };
                                end end), label_idents, lst);
                          return mk_1(undefined, undefined, --[[ Ppat_record ]]Block.__(7, {
                                        lst_1,
                                        --[[ Open ]]1
                                      }));
                        end end
                        end end)(label_idents), pats); end end 
           if ___conditional___ == 7--[[ Tpat_array ]] then do
              results_3 = select(List.map(loop, match[0]));
              return List.map((function(lst) do
                            return mk_1(undefined, undefined, --[[ Ppat_array ]]Block.__(8, {lst}));
                          end end), results_3); end end 
           if ___conditional___ == 8--[[ Tpat_or ]] then do
              return Pervasives.$at(loop(match[0]), loop(match[1])); end end 
           if ___conditional___ == 9--[[ Tpat_lazy ]] then do
              results_4 = loop(match[0]);
              return List.map((function(p) do
                            return mk_1(undefined, undefined, --[[ Ppat_lazy ]]Block.__(12, {p}));
                          end end), results_4); end end 
          return --[[ :: ]]{
                    mk_1(undefined, undefined, --[[ Ppat_any ]]0),
                    --[[ [] ]]0
                  };
            
        end
      end end 
    end;
  end end;
  ps = loop(typed);
  return --[[ tuple ]]{
          ps,
          constrs,
          labels
        };
end end

function do_check_partial(pred, exhaust, loc, casel, pss) do
  if (pss) then do
    match = Curry._3(exhaust, undefined, pss, List.length(pss[0]));
    if (match) then do
      match_1 = match[0];
      if (match_1 and not match_1[1]) then do
        u = match_1[0];
        v;
        if (pred ~= undefined) then do
          match_2 = conv(u);
          v = get_first(Curry._2(pred, match_2[1], match_2[2]), match_2[0]);
        end else do
          v = u;
        end end 
        if (v ~= undefined) then do
          v_1 = v;
          match_3 = v_1.pat_desc;
          errmsg;
          exit = 0;
          if (typeof match_3 == "number" or not (match_3.tag == --[[ Tpat_construct ]]4 and match_3[1].cstr_name == "*extension*")) then do
            exit = 1;
          end else do
            errmsg = "_\nMatching over values of extensible variant types must include\na wild card pattern in order to be exhaustive.";
          end end 
          if (exit == 1) then do
            xpcall(function() do
              buf = __Buffer.create(16);
              fmt = Format.formatter_of_buffer(buf);
              top_pretty(fmt, v_1);
              match_4 = check_partial_all(v_1, casel);
              if (match_4 ~= undefined) then do
                __Buffer.add_string(buf, "\n(However, some guarded clause may match this value.)");
              end
               end 
              errmsg = __Buffer.contents(buf);
            end end,function(exn) do
              errmsg = "";
            end end)
          end
           end 
          prerr_warning(loc, --[[ Partial_match ]]Block.__(3, {errmsg}));
          return --[[ Partial ]]0;
        end else do
          return --[[ Total ]]1;
        end end 
      end else do
        return fatal_error("Parmatch.check_partial");
      end end 
    end else do
      return --[[ Total ]]1;
    end end 
  end else do
    if (casel) then do
      prerr_warning(loc, --[[ All_clauses_guarded ]]12);
    end
     end 
    return --[[ Partial ]]0;
  end end 
end end

function do_check_partial_normal(loc, casel, pss) do
  return do_check_partial(undefined, exhaust, loc, casel, pss);
end end

function add_path(path, paths) do
  if (paths) then do
    x = paths[0];
    if (same(path, x)) then do
      return paths;
    end else do
      return --[[ :: ]]{
              x,
              add_path(path, paths[1])
            };
    end end 
  end else do
    return --[[ :: ]]{
            path,
            --[[ [] ]]0
          };
  end end 
end end

function extendable_path(path) do
  return not (same(path, path_bool) or same(path, path_list) or same(path, path_unit) or same(path, path_option));
end end

function collect_paths_from_pat(_r, _p) do
  while(true) do
    p = _p;
    r = _r;
    match = p.pat_desc;
    if (typeof match == "number") then do
      return r;
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 4--[[ Tpat_construct ]] then do
            local ___conditional___=(match[1].cstr_tag.tag | 0);
            do
               if ___conditional___ == 0--[[ Cstr_constant ]]
               or ___conditional___ == 1--[[ Cstr_block ]]
               or ___conditional___ == 2--[[ Cstr_extension ]] then do
                  return List.fold_left(collect_paths_from_pat, r, match[2]); end end 
              
            end
            path = get_type_path(p.pat_type, p.pat_env);
            return List.fold_left(collect_paths_from_pat, extendable_path(path) and add_path(path, r) or r, match[2]); end end 
         if ___conditional___ == 5--[[ Tpat_variant ]] then do
            match_1 = match[1];
            if (match_1 ~= undefined) then do
              _p = match_1;
              ::continue:: ;
            end else do
              return r;
            end end  end end 
         if ___conditional___ == 6--[[ Tpat_record ]] then do
            return List.fold_left((function(r, param) do
                          return collect_paths_from_pat(r, param[2]);
                        end end), r, match[0]); end end 
         if ___conditional___ == 3--[[ Tpat_tuple ]]
         or ___conditional___ == 7--[[ Tpat_array ]] then do
            return List.fold_left(collect_paths_from_pat, r, match[0]); end end 
         if ___conditional___ == 8--[[ Tpat_or ]] then do
            _p = match[1];
            _r = collect_paths_from_pat(r, match[0]);
            ::continue:: ; end end 
         if ___conditional___ == 1--[[ Tpat_alias ]]
         or ___conditional___ == 9--[[ Tpat_lazy ]] then do
            _p = match[0];
            ::continue:: ; end end 
        return r;
          
      end
    end end 
  end;
end end

function do_check_fragile_param(exhaust, loc, casel, pss) do
  exts = List.fold_left((function(r, c) do
          return collect_paths_from_pat(r, c.c_lhs);
        end end), --[[ [] ]]0, casel);
  if (exts and pss) then do
    ps = pss[0];
    return List.iter((function(ext) do
                  match = Curry._3(exhaust, ext, pss, List.length(ps));
                  if (match) then do
                    return --[[ () ]]0;
                  end else do
                    return prerr_warning(loc, --[[ Fragile_match ]]Block.__(1, {name(undefined, ext)}));
                  end end 
                end end), exts);
  end else do
    return --[[ () ]]0;
  end end 
end end

function do_check_fragile_normal(param, param_1, param_2) do
  return do_check_fragile_param(exhaust, param, param_1, param_2);
end end

function do_check_fragile_gadt(param, param_1, param_2) do
  return do_check_fragile_param(exhaust_gadt_1, param, param_1, param_2);
end end

function check_partial_param(do_check_partial, do_check_fragile, loc, casel) do
  if (is_active(--[[ Partial_match ]]Block.__(3, {""}))) then do
    pss = initial_matrix(casel);
    pss_1 = get_mins(le_pats, pss);
    total = Curry._3(do_check_partial, loc, casel, pss_1);
    if (total == --[[ Total ]]1 and is_active(--[[ Fragile_match ]]Block.__(1, {""}))) then do
      Curry._3(do_check_fragile, loc, casel, pss_1);
    end
     end 
    return total;
  end else do
    return --[[ Partial ]]0;
  end end 
end end

function check_partial(param, param_1) do
  return check_partial_param(do_check_partial_normal, do_check_fragile_normal, param, param_1);
end end

Already_bound = Caml_exceptions.create("Ocaml_typedtree_test.Typetexp.Already_bound");

__Error_6 = Caml_exceptions.create("Ocaml_typedtree_test.Typetexp.Error");

Error_forward = Caml_exceptions.create("Ocaml_typedtree_test.Typetexp.Error_forward");

function string_of_payload(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ PStr ]] then do
        match = param[0];
        if (match) then do
          match_1 = match[0].pstr_desc;
          if (match_1.tag) then do
            return ;
          end else do
            match_2 = match_1[0].pexp_desc;
            if (match_2.tag == --[[ Pexp_constant ]]1 and not match[1]) then do
              param_1 = match_2[0];
              if (param_1.tag == --[[ Const_string ]]2) then do
                return param_1[0];
              end else do
                return ;
              end end 
            end else do
              return ;
            end end 
          end end 
        end else do
          return ;
        end end  end end 
     if ___conditional___ == 1--[[ PTyp ]]
     or ___conditional___ == 2--[[ PPat ]] then do
        return ; end end 
    
  end
end end

function error_of_extension(ext) do
  match = ext[0];
  txt = match.txt;
  exit = 0;
  local ___conditional___=(txt);
  do
     if ___conditional___ == "error"
     or ___conditional___ == "ocaml.error" then do
        exit = 1; end else 
     end end
    return Curry._1(errorf(match.loc, undefined, undefined, --[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "Uninterpreted extension '",
                          --[[ String ]]Block.__(2, {
                              --[[ No_padding ]]0,
                              --[[ String_literal ]]Block.__(11, {
                                  "'.",
                                  --[[ End_of_format ]]0
                                })
                            })
                        }),
                      "Uninterpreted extension '%s'."
                    }), txt);
      
  end
  if (exit == 1) then do
    p = ext[1];
    loc = match.loc;
    sub_from = function(inner) do
      if (inner) then do
        match = inner[0].pstr_desc;
        if (match.tag == --[[ Pstr_extension ]]14) then do
          return --[[ :: ]]{
                  error_of_extension(match[0]),
                  sub_from(inner[1])
                };
        end else do
          return --[[ :: ]]{
                  Curry._1(errorf(loc, undefined, undefined, --[[ Format ]]{
                            --[[ String_literal ]]Block.__(11, {
                                "Invalid syntax for sub-error of extension '",
                                --[[ String ]]Block.__(2, {
                                    --[[ No_padding ]]0,
                                    --[[ String_literal ]]Block.__(11, {
                                        "'.",
                                        --[[ End_of_format ]]0
                                      })
                                  })
                              }),
                            "Invalid syntax for sub-error of extension '%s'."
                          }), txt),
                  sub_from(inner[1])
                };
        end end 
      end else do
        return --[[ [] ]]0;
      end end 
    end end;
    local ___conditional___=(p.tag | 0);
    do
       if ___conditional___ == 0--[[ PStr ]] then do
          match_1 = p[0];
          if (match_1) then do
            match_2 = match_1[0].pstr_desc;
            if (not match_2.tag) then do
              match_3 = match_2[0].pexp_desc;
              if (match_3.tag == --[[ Pexp_constant ]]1) then do
                match_4 = match_3[0];
                if (match_4.tag == --[[ Const_string ]]2) then do
                  inner = match_1[1];
                  msg = match_4[0];
                  exit_1 = 0;
                  if (inner) then do
                    match_5 = inner[0].pstr_desc;
                    if (match_5.tag) then do
                      exit_1 = 3;
                    end else do
                      match_6 = match_5[0].pexp_desc;
                      if (match_6.tag == --[[ Pexp_constant ]]1) then do
                        match_7 = match_6[0];
                        if (match_7.tag == --[[ Const_string ]]2) then do
                          return error(loc, sub_from(inner[1]), match_7[0], msg);
                        end else do
                          exit_1 = 3;
                        end end 
                      end else do
                        exit_1 = 3;
                      end end 
                    end end 
                  end else do
                    exit_1 = 3;
                  end end 
                  if (exit_1 == 3) then do
                    return error(loc, sub_from(inner), undefined, msg);
                  end
                   end 
                end
                 end 
              end
               end 
            end
             end 
          end
           end  end else 
       if ___conditional___ == 1--[[ PTyp ]]
       or ___conditional___ == 2--[[ PPat ]]
       end end end
      
    end
    return Curry._1(errorf(loc, undefined, undefined, --[[ Format ]]{
                    --[[ String_literal ]]Block.__(11, {
                        "Invalid syntax for extension '",
                        --[[ String ]]Block.__(2, {
                            --[[ No_padding ]]0,
                            --[[ String_literal ]]Block.__(11, {
                                "'.",
                                --[[ End_of_format ]]0
                              })
                          })
                      }),
                    "Invalid syntax for extension '%s'."
                  }), txt);
  end
   end 
end end

function check_deprecated(loc, attrs, s) do
  return List.iter((function(param) do
                local ___conditional___=(param[0].txt);
                do
                   if ___conditional___ == "deprecated"
                   or ___conditional___ == "ocaml.deprecated"
                   end
                  return --[[ () ]]0;
                    
                end
                match = string_of_payload(param[1]);
                if (match ~= undefined) then do
                  txt = match;
                  if (bs_vscode) then do
                    return prerr_warning(loc, --[[ Deprecated ]]Block.__(0, {s .. (" " .. txt)}));
                  end else do
                    return prerr_warning(loc, --[[ Deprecated ]]Block.__(0, {s .. ("\n" .. txt)}));
                  end end 
                end else do
                  return prerr_warning(loc, --[[ Deprecated ]]Block.__(0, {s}));
                end end 
              end end), attrs);
end end

newrecord_1 = Caml_obj.caml_obj_dup(default_mapper);

newrecord_1.attribute = (function(param, a) do
    exit = 0;
    local ___conditional___=(a[0].txt);
    do
       if ___conditional___ == "ocaml.ppwarning"
       or ___conditional___ == "ppwarning" then do
          exit = 1; end else 
       end end
      
    end
    if (exit == 1) then do
      match = a[1];
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 0--[[ PStr ]] then do
            match_1 = match[0];
            if (match_1) then do
              match_2 = match_1[0];
              match_3 = match_2.pstr_desc;
              if (not match_3.tag) then do
                match_4 = match_3[0].pexp_desc;
                if (match_4.tag == --[[ Pexp_constant ]]1) then do
                  match_5 = match_4[0];
                  if (match_5.tag == --[[ Const_string ]]2 and not match_1[1]) then do
                    prerr_warning(match_2.pstr_loc, --[[ Preprocessor ]]Block.__(10, {match_5[0]}));
                  end
                   end 
                end
                 end 
              end
               end 
            end
             end  end else 
         if ___conditional___ == 1--[[ PTyp ]]
         or ___conditional___ == 2--[[ PPat ]]
         end end end
        
      end
    end
     end 
    return a;
  end end);

warning_scope = do
  contents: --[[ [] ]]0
end;

function warning_enter_scope(param) do
  warning_scope.contents = --[[ :: ]]{
    current.contents,
    warning_scope.contents
  };
  return --[[ () ]]0;
end end

function warning_leave_scope(param) do
  match = warning_scope.contents;
  if (match) then do
    current.contents = match[0];
    warning_scope.contents = match[1];
    return --[[ () ]]0;
  end else do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "typetexp.ml",
        146,
        10
      }
    })
  end end 
end end

function warning_attribute(attrs) do
  __process = function(loc, txt, errflag, payload) do
    match = string_of_payload(payload);
    if (match ~= undefined) then do
      xpcall(function() do
        return parse_options(errflag, match);
      end end,function(raw_exn) do
        exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn[0] == Arg.Bad) then do
          return prerr_warning(loc, --[[ Attribute_payload ]]Block.__(30, {
                        txt,
                        "Ill-formed list of warnings"
                      }));
        end else do
          error(exn)
        end end 
      end end)
    end else do
      return prerr_warning(loc, --[[ Attribute_payload ]]Block.__(30, {
                    txt,
                    "A single string literal is expected"
                  }));
    end end 
  end end;
  return List.iter((function(param) do
                match = param[0];
                txt = match.txt;
                exit = 0;
                local ___conditional___=(txt);
                do
                   if ___conditional___ == "ocaml.warnerror"
                   or ___conditional___ == "warnerror" then do
                      exit = 2; end else 
                   if ___conditional___ == "ocaml.warning"
                   or ___conditional___ == "warning" then do
                      exit = 1; end else 
                   end end end end
                  return --[[ () ]]0;
                    
                end
                local ___conditional___=(exit);
                do
                   if ___conditional___ == 1 then do
                      return __process(match.loc, txt, false, param[1]); end end 
                   if ___conditional___ == 2 then do
                      return __process(match.loc, txt, true, param[1]); end end 
                  
                end
              end end), attrs);
end end

function narrow_unbound_lid_error(env, loc, lid, make_error) do
  check_module = function(mlid) do
    xpcall(function() do
      lookup_module(true, mlid, env);
      return --[[ () ]]0;
    end end,function(exn) do
      if (exn == Caml_builtin_exceptions.not_found) then do
        return narrow_unbound_lid_error(env, loc, mlid, (function(lid) do
                      return --[[ Unbound_module ]]Block.__(20, {lid});
                    end end));
      end else do
        if (exn == Recmodule) then do
          error({
            __Error_6,
            loc,
            env,
            --[[ Illegal_reference_to_recursive_module ]]1
          })
        end
         end 
        error(exn)
      end end 
    end end)
  end end;
  local ___conditional___=(lid.tag | 0);
  do
     if ___conditional___ == 0--[[ Lident ]]
     or ___conditional___ == 1--[[ Ldot ]] then do
        mlid = lid[0];
        check_module(mlid);
        md = find_module(false, lookup_module(true, mlid, env), env);
        match = scrape_alias(env, undefined, md.md_type);
        if (match.tag == --[[ Mty_functor ]]2) then do
          error({
            __Error_6,
            loc,
            env,
            --[[ Access_functor_as_structure ]]Block.__(25, {mlid})
          })
        end
         end  end else 
     if ___conditional___ == 2--[[ Lapply ]] then do
        check_module(lid[0]);
        check_module(lid[1]);
        error({
          __Error_6,
          loc,
          env,
          --[[ Ill_typed_functor_application ]]Block.__(24, {lid})
        }) end end end end 
    
  end
  error({
    __Error_6,
    loc,
    env,
    Curry._1(make_error, lid)
  })
end end

function find_component(lookup, make_error, env, loc, lid) do
  xpcall(function() do
    local ___conditional___=(lid.tag | 0);
    do
       if ___conditional___ == 1--[[ Ldot ]] then do
          match = lid[0];
          local ___conditional___=(match.tag | 0);
          do
             if ___conditional___ == 0--[[ Lident ]] then do
                if (match[0] == "*predef*") then do
                  return Curry._2(lookup, --[[ Lident ]]Block.__(0, {lid[1]}), initial_safe_string);
                end else do
                  return Curry._2(lookup, lid, env);
                end end  end end 
             if ___conditional___ == 1--[[ Ldot ]]
             or ___conditional___ == 2--[[ Lapply ]] then do
                return Curry._2(lookup, lid, env); end end 
            
          end end end 
       if ___conditional___ == 0--[[ Lident ]]
       or ___conditional___ == 2--[[ Lapply ]] then do
          return Curry._2(lookup, lid, env); end end 
      
    end
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return narrow_unbound_lid_error(env, loc, lid, make_error);
    end else do
      if (exn == Recmodule) then do
        error({
          __Error_6,
          loc,
          env,
          --[[ Illegal_reference_to_recursive_module ]]1
        })
      end
       end 
      error(exn)
    end end 
  end end)
end end

function find_type(env, loc, lid) do
  r = find_component(lookup_type_1, (function(lid) do
          return --[[ Unbound_type_constructor ]]Block.__(1, {lid});
        end end), env, loc, lid);
  check_deprecated(loc, r[1].type_attributes, name(undefined, r[0]));
  return r;
end end

function find_constructor(param, param_1, param_2) do
  return find_component(lookup_constructor, (function(lid) do
                return --[[ Unbound_constructor ]]Block.__(18, {lid});
              end end), param, param_1, param_2);
end end

function find_all_constructors(param, param_1, param_2) do
  return find_component(lookup_all_constructors_1, (function(lid) do
                return --[[ Unbound_constructor ]]Block.__(18, {lid});
              end end), param, param_1, param_2);
end end

function find_all_labels(param, param_1, param_2) do
  return find_component(lookup_all_labels_1, (function(lid) do
                return --[[ Unbound_label ]]Block.__(19, {lid});
              end end), param, param_1, param_2);
end end

function find_class_1(env, loc, lid) do
  r = find_component(lookup_class_1, (function(lid) do
          return --[[ Unbound_class ]]Block.__(21, {lid});
        end end), env, loc, lid);
  check_deprecated(loc, r[1].cty_attributes, name(undefined, r[0]));
  return r;
end end

function find_value_1(env, loc, lid) do
  check_value_name(last_1(lid), loc);
  r = find_component(lookup_value_1, (function(lid) do
          return --[[ Unbound_value ]]Block.__(17, {lid});
        end end), env, loc, lid);
  check_deprecated(loc, r[1].val_attributes, name(undefined, r[0]));
  return r;
end end

function lookup_module_1(loadOpt, env, loc, lid) do
  load = loadOpt ~= undefined and loadOpt or false;
  return find_component((function(lid, env) do
                  return --[[ tuple ]]{
                          lookup_module(load, lid, env),
                          --[[ () ]]0
                        };
                end end), (function(lid) do
                  return --[[ Unbound_module ]]Block.__(20, {lid});
                end end), env, loc, lid)[0];
end end

function find_module_1(env, loc, lid) do
  path = lookup_module_1(true, env, loc, lid);
  decl = find_module(false, path, env);
  check_deprecated(loc, decl.md_attributes, name(undefined, path));
  return --[[ tuple ]]{
          path,
          decl
        };
end end

function find_modtype_1(env, loc, lid) do
  r = find_component(lookup_modtype, (function(lid) do
          return --[[ Unbound_modtype ]]Block.__(22, {lid});
        end end), env, loc, lid);
  check_deprecated(loc, r[1].mtd_attributes, name(undefined, r[0]));
  return r;
end end

function find_class_type(env, loc, lid) do
  r = find_component(lookup_cltype_1, (function(lid) do
          return --[[ Unbound_cltype ]]Block.__(23, {lid});
        end end), env, loc, lid);
  check_deprecated(loc, r[1].clty_attributes, name(undefined, r[0]));
  return r;
end end

function unbound_constructor_error(env, lid) do
  return narrow_unbound_lid_error(env, lid.loc, lid.txt, (function(lid) do
                return --[[ Unbound_constructor ]]Block.__(18, {lid});
              end end));
end end

function unbound_label_error(env, lid) do
  return narrow_unbound_lid_error(env, lid.loc, lid.txt, (function(lid) do
                return --[[ Unbound_label ]]Block.__(19, {lid});
              end end));
end end

transl_modtype_longident = do
  contents: (function(param) do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "typetexp.ml",
          293,
          45
        }
      })
    end end)
end;

transl_modtype = do
  contents: (function(param) do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "typetexp.ml",
          294,
          35
        }
      })
    end end)
end;

function create_package_mty(fake, loc, env, param) do
  l = List.sort((function(param, param_1) do
          s2 = param_1[0];
          s1 = param[0];
          if (Caml_obj.caml_equal(s1.txt, s2.txt)) then do
            error({
              __Error_6,
              loc,
              env,
              --[[ Multiple_constraints_on_type ]]Block.__(15, {s1.txt})
            })
          end
           end 
          return Caml_obj.caml_compare(s1.txt, s2.txt);
        end end), param[1]);
  return --[[ tuple ]]{
          l,
          List.fold_left((function(mty, param) do
                  s = param[0];
                  d_ptype_name = do
                    txt: last_1(s.txt),
                    loc: s.loc
                  end;
                  d_ptype_manifest = fake and undefined or param[1];
                  d = do
                    ptype_name: d_ptype_name,
                    ptype_params: --[[ [] ]]0,
                    ptype_cstrs: --[[ [] ]]0,
                    ptype_kind: --[[ Ptype_abstract ]]0,
                    ptype_private: --[[ Public ]]1,
                    ptype_manifest: d_ptype_manifest,
                    ptype_attributes: --[[ [] ]]0,
                    ptype_loc: loc
                  end;
                  return mk_3(loc, undefined, --[[ Pmty_with ]]Block.__(3, {
                                mty,
                                --[[ :: ]]{
                                  --[[ Pwith_type ]]Block.__(0, {
                                      do
                                        txt: s.txt,
                                        loc: loc
                                      end,
                                      d
                                    }),
                                  --[[ [] ]]0
                                }
                              }));
                end end), mk_3(loc, undefined, --[[ Pmty_ident ]]Block.__(0, {param[0]})), l)
        };
end end

type_variables = do
  contents: --[[ Empty ]]0
end;

univars = do
  contents: --[[ [] ]]0
end;

pre_univars = do
  contents: --[[ [] ]]0
end;

used_variables = do
  contents: --[[ Empty ]]0
end;

function reset_type_variables(param) do
  reset_global_level(--[[ () ]]0);
  type_variables.contents = --[[ Empty ]]0;
  return --[[ () ]]0;
end end

function narrow(param) do
  return --[[ tuple ]]{
          increase_global_level(--[[ () ]]0),
          type_variables.contents
        };
end end

function widen(param) do
  global_level.contents = param[0];
  type_variables.contents = param[1];
  return --[[ () ]]0;
end end

function strict_lowercase(c) do
  if (c == --[[ "_" ]]95) then do
    return true;
  end else if (c >= --[[ "a" ]]97) then do
    return c <= --[[ "z" ]]122;
  end else do
    return false;
  end end  end 
end end

function validate_name(s) do
  if (s ~= undefined) then do
    name = s;
    if (name ~= "" and strict_lowercase(Caml_string.get(name, 0))) then do
      return s;
    end else do
      return ;
    end end 
  end
   end 
end end

function transl_type_param(env, styp) do
  loc = styp.ptyp_loc;
  match = styp.ptyp_desc;
  if (typeof match == "number") then do
    ty = new_global_var(validate_name("_"), --[[ () ]]0);
    return do
            ctyp_desc: --[[ Ttyp_any ]]0,
            ctyp_type: ty,
            ctyp_env: env,
            ctyp_loc: loc,
            ctyp_attributes: styp.ptyp_attributes
          end;
  end else if (match.tag) then do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "typetexp.ml",
        379,
        9
      }
    })
  end else do
    name = match[0];
    ty_1;
    xpcall(function() do
      if (name ~= "" and Caml_string.get(name, 0) == --[[ "_" ]]95) then do
        error({
          __Error_6,
          loc,
          empty,
          --[[ Invalid_variable_name ]]Block.__(13, {"'" .. name})
        })
      end
       end 
      find_2(name, type_variables.contents);
      error(Already_bound)
    end end,function(exn) do
      if (exn == Caml_builtin_exceptions.not_found) then do
        v = new_global_var(validate_name(name), --[[ () ]]0);
        type_variables.contents = add_5(name, v, type_variables.contents);
        ty_1 = v;
      end else do
        error(exn)
      end end 
    end end)
    return do
            ctyp_desc: --[[ Ttyp_var ]]Block.__(0, {name}),
            ctyp_type: ty_1,
            ctyp_env: env,
            ctyp_loc: loc,
            ctyp_attributes: styp.ptyp_attributes
          end;
  end end  end 
end end

function new_pre_univar(name, param) do
  v = newvar(validate_name(name), --[[ () ]]0);
  pre_univars.contents = --[[ :: ]]{
    v,
    pre_univars.contents
  };
  return v;
end end

function swap_list(l) do
  if (l) then do
    match = l[1];
    if (match) then do
      return --[[ :: ]]{
              match[0],
              --[[ :: ]]{
                l[0],
                swap_list(match[1])
              }
            };
    end else do
      return l;
    end end 
  end else do
    return l;
  end end 
end end

function transl_type(env, policy, styp) do
  loc = styp.ptyp_loc;
  ctyp = function(ctyp_desc, ctyp_type) do
    return do
            ctyp_desc: ctyp_desc,
            ctyp_type: ctyp_type,
            ctyp_env: env,
            ctyp_loc: loc,
            ctyp_attributes: styp.ptyp_attributes
          end;
  end end;
  match = styp.ptyp_desc;
  if (typeof match == "number") then do
    ty;
    if (policy == --[[ Univars ]]2) then do
      ty = new_pre_univar(undefined, --[[ () ]]0);
    end else do
      if (policy == --[[ Fixed ]]0) then do
        error({
          __Error_6,
          styp.ptyp_loc,
          env,
          --[[ Unbound_type_variable ]]Block.__(0, {"_"})
        })
      end
       end 
      ty = newvar(validate_name(undefined), --[[ () ]]0);
    end end 
    return ctyp(--[[ Ttyp_any ]]0, ty);
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 0--[[ Ptyp_var ]] then do
          name = match[0];
          if (name ~= "" and Caml_string.get(name, 0) == --[[ "_" ]]95) then do
            error({
              __Error_6,
              styp.ptyp_loc,
              env,
              --[[ Invalid_variable_name ]]Block.__(13, {"'" .. name})
            })
          end
           end 
          ty_1;
          xpcall(function() do
            ty_1 = instance(undefined, env, List.assoc(name, univars.contents));
          end end,function(exn) do
            if (exn == Caml_builtin_exceptions.not_found) then do
              xpcall(function() do
                ty_1 = instance(undefined, env, find_2(name, used_variables.contents)[0]);
              end end,function(exn_1) do
                if (exn_1 == Caml_builtin_exceptions.not_found) then do
                  v = policy == --[[ Univars ]]2 and new_pre_univar(name, --[[ () ]]0) or newvar(validate_name(name), --[[ () ]]0);
                  used_variables.contents = add_5(name, --[[ tuple ]]{
                        v,
                        styp.ptyp_loc
                      }, used_variables.contents);
                  ty_1 = v;
                end else do
                  error(exn_1)
                end end 
              end end)
            end else do
              error(exn)
            end end 
          end end)
          return ctyp(--[[ Ttyp_var ]]Block.__(0, {name}), ty_1); end end 
       if ___conditional___ == 1--[[ Ptyp_arrow ]] then do
          l = match[0];
          cty1 = transl_type(env, policy, match[1]);
          cty2 = transl_type(env, policy, match[2]);
          ty_2 = newty2(current_level.contents, --[[ Tarrow ]]Block.__(1, {
                  l,
                  cty1.ctyp_type,
                  cty2.ctyp_type,
                  --[[ Cok ]]0
                }));
          return ctyp(--[[ Ttyp_arrow ]]Block.__(1, {
                        l,
                        cty1,
                        cty2
                      }), ty_2); end end 
       if ___conditional___ == 2--[[ Ptyp_tuple ]] then do
          stl = match[0];
          if (List.length(stl) < 2) then do
            ill_formed_ast(loc, "Tuples must have at least 2 components.");
          end
           end 
          ctys = List.map((function(param) do
                  return transl_type(env, policy, param);
                end end), stl);
          desc = --[[ Ttuple ]]Block.__(2, {List.map((function(ctyp) do
                      return ctyp.ctyp_type;
                    end end), ctys)});
          ty_3 = newty2(current_level.contents, desc);
          return ctyp(--[[ Ttyp_tuple ]]Block.__(2, {ctys}), ty_3); end end 
       if ___conditional___ == 3--[[ Ptyp_constr ]] then do
          stl_1 = match[1];
          lid = match[0];
          match_1 = find_type(env, styp.ptyp_loc, lid.txt);
          decl = match_1[1];
          path = match_1[0];
          stl_2;
          if (stl_1) then do
            t = stl_1[0];
            stl_2 = typeof t.ptyp_desc == "number" and not (stl_1[1] or decl.type_arity <= 1) and List.map((function(param) do
                      return t;
                    end end), decl.type_params) or stl_1;
          end else do
            stl_2 = stl_1;
          end end 
          if (List.length(stl_2) ~= decl.type_arity) then do
            error({
              __Error_6,
              styp.ptyp_loc,
              env,
              --[[ Type_arity_mismatch ]]Block.__(3, {
                  lid.txt,
                  decl.type_arity,
                  List.length(stl_2)
                })
            })
          end
           end 
          args = List.map((function(param) do
                  return transl_type(env, policy, param);
                end end), stl_2);
          params = instance_list(empty, decl.type_params);
          match_2 = decl.type_manifest;
          unify_param = match_2 ~= undefined and repr(match_2).level ~= 100000000 and unify_2 or unify_var;
          List.iter2((function(param, ty$prime) do
                  xpcall(function() do
                    return Curry._3(unify_param, env, ty$prime, param[1].ctyp_type);
                  end end,function(raw_exn) do
                    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn[0] == Unify) then do
                      error({
                        __Error_6,
                        param[0].ptyp_loc,
                        env,
                        --[[ Type_mismatch ]]Block.__(6, {swap_list(exn[1])})
                      })
                    end
                     end 
                    error(exn)
                  end end)
                end end), List.combine(stl_2, args), params);
          constr = newconstr(path, List.map((function(ctyp) do
                      return ctyp.ctyp_type;
                    end end), args));
          xpcall(function() do
            enforce_constraints(env, constr);
          end end,function(raw_exn) do
            exn_2 = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn_2[0] == Unify) then do
              error({
                __Error_6,
                styp.ptyp_loc,
                env,
                --[[ Type_mismatch ]]Block.__(6, {exn_2[1]})
              })
            end
             end 
            error(exn_2)
          end end)
          return ctyp(--[[ Ttyp_constr ]]Block.__(3, {
                        path,
                        lid,
                        args
                      }), constr); end end 
       if ___conditional___ == 4--[[ Ptyp_object ]] then do
          o = match[1];
          fields = List.map((function(param) do
                  return --[[ tuple ]]{
                          param[0],
                          param[1],
                          transl_poly_type(env, policy, param[2])
                        };
                end end), match[0]);
          ty_4 = newobj(transl_fields(loc, env, policy, --[[ [] ]]0, o, fields));
          return ctyp(--[[ Ttyp_object ]]Block.__(4, {
                        fields,
                        o
                      }), ty_4); end end 
       if ___conditional___ == 5--[[ Ptyp_class ]] then do
          stl_3 = match[1];
          lid_1 = match[0];
          match_3;
          xpcall(function() do
            match_4 = lookup_type_1(lid_1.txt, env);
            decl_1 = match_4[1];
            check = function(_decl) do
              while(true) do
                decl = _decl;
                match = decl.type_manifest;
                if (match ~= undefined) then do
                  match_1 = repr(match).desc;
                  if (typeof match_1 == "number") then do
                    error(Caml_builtin_exceptions.not_found)
                  end else do
                    local ___conditional___=(match_1.tag | 0);
                    do
                       if ___conditional___ == 3--[[ Tconstr ]] then do
                          _decl = find_type_full(match_1[0], env)[0];
                          ::continue:: ; end end 
                       if ___conditional___ == 8--[[ Tvariant ]] then do
                          if (static_row(match_1[0])) then do
                            return --[[ () ]]0;
                          end else do
                            error(Caml_builtin_exceptions.not_found)
                          end end  end end 
                      error(Caml_builtin_exceptions.not_found)
                        
                    end
                  end end 
                end else do
                  error(Caml_builtin_exceptions.not_found)
                end end 
              end;
            end end;
            check(decl_1);
            prerr_warning(styp.ptyp_loc, --[[ Deprecated ]]Block.__(0, {"old syntax for polymorphic variant type"}));
            match_3 = --[[ tuple ]]{
              match_4[0],
              decl_1,
              true
            };
          end end,function(exn_3) do
            if (exn_3 == Caml_builtin_exceptions.not_found) then do
              xpcall(function() do
                match_5 = lid_1.txt;
                lid2;
                local ___conditional___=(match_5.tag | 0);
                do
                   if ___conditional___ == 0--[[ Lident ]] then do
                      lid2 = --[[ Lident ]]Block.__(0, {"#" .. match_5[0]}); end else 
                   if ___conditional___ == 1--[[ Ldot ]] then do
                      lid2 = --[[ Ldot ]]Block.__(1, {
                          match_5[0],
                          "#" .. match_5[1]
                        }); end else 
                   if ___conditional___ == 2--[[ Lapply ]] then do
                      lid2 = fatal_error("Typetexp.transl_type"); end else 
                   end end end end end end
                  
                end
                match_6 = lookup_type_1(lid2, env);
                match_3 = --[[ tuple ]]{
                  match_6[0],
                  match_6[1],
                  false
                };
              end end,function(exn_4) do
                if (exn_4 == Caml_builtin_exceptions.not_found) then do
                  find_class_1(env, styp.ptyp_loc, lid_1.txt);
                  error({
                    Caml_builtin_exceptions.assert_failure,
                    --[[ tuple ]]{
                      "typetexp.ml",
                      505,
                      57
                    }
                  })
                end else do
                  error(exn_4)
                end end 
              end end)
            end else do
              error(exn_3)
            end end 
          end end)
          decl_2 = match_3[1];
          path_1 = match_3[0];
          if (List.length(stl_3) ~= decl_2.type_arity) then do
            error({
              __Error_6,
              styp.ptyp_loc,
              env,
              --[[ Type_arity_mismatch ]]Block.__(3, {
                  lid_1.txt,
                  decl_2.type_arity,
                  List.length(stl_3)
                })
            })
          end
           end 
          args_1 = List.map((function(param) do
                  return transl_type(env, policy, param);
                end end), stl_3);
          params_1 = instance_list(empty, decl_2.type_params);
          List.iter2((function(param, ty$prime) do
                  xpcall(function() do
                    return unify_var(env, ty$prime, param[1].ctyp_type);
                  end end,function(raw_exn) do
                    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn[0] == Unify) then do
                      error({
                        __Error_6,
                        param[0].ptyp_loc,
                        env,
                        --[[ Type_mismatch ]]Block.__(6, {swap_list(exn[1])})
                      })
                    end
                     end 
                    error(exn)
                  end end)
                end end), List.combine(stl_3, args_1), params_1);
          ty_args = List.map((function(ctyp) do
                  return ctyp.ctyp_type;
                end end), args_1);
          ty_5;
          xpcall(function() do
            ty_5 = expand_head(env, newconstr(path_1, ty_args));
          end end,function(raw_exn_1) do
            exn_5 = Caml_js_exceptions.internalToOCamlException(raw_exn_1);
            if (exn_5[0] == Unify) then do
              error({
                __Error_6,
                styp.ptyp_loc,
                env,
                --[[ Type_mismatch ]]Block.__(6, {exn_5[1]})
              })
            end
             end 
            error(exn_5)
          end end)
          match_7 = ty_5.desc;
          ty_6;
          if (typeof match_7 == "number") then do
            error({
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "typetexp.ml",
                553,
                10
              }
            })
          end else do
            local ___conditional___=(match_7.tag | 0);
            do
               if ___conditional___ == 4--[[ Tobject ]] then do
                  match_8 = flatten_fields(match_7[0]);
                  if (policy == --[[ Univars ]]2) then do
                    pre_univars.contents = --[[ :: ]]{
                      match_8[1],
                      pre_univars.contents
                    };
                  end
                   end 
                  ty_6 = ty_5; end else 
               if ___conditional___ == 8--[[ Tvariant ]] then do
                  row = row_repr_aux(--[[ [] ]]0, match_7[0]);
                  fields_1 = List.map((function(param) do
                          f = param[1];
                          match = row_field_repr_aux(--[[ [] ]]0, f);
                          tmp;
                          if (typeof match == "number" or match.tag) then do
                            tmp = f;
                          end else do
                            match_1 = match[0];
                            tmp = match_1 ~= undefined and --[[ Reither ]]Block.__(1, {
                                  false,
                                  --[[ :: ]]{
                                    match_1,
                                    --[[ [] ]]0
                                  },
                                  false,
                                  do
                                    contents: undefined
                                  end
                                }) or --[[ Reither ]]Block.__(1, {
                                  true,
                                  --[[ [] ]]0,
                                  false,
                                  do
                                    contents: undefined
                                  end
                                });
                          end end 
                          return --[[ tuple ]]{
                                  param[0],
                                  tmp
                                };
                        end end), row.row_fields);
                  row_row_more = newvar(validate_name(undefined), --[[ () ]]0);
                  row_row_name = --[[ tuple ]]{
                    path_1,
                    ty_args
                  };
                  row_1 = do
                    row_fields: fields_1,
                    row_more: row_row_more,
                    row_bound: --[[ () ]]0,
                    row_closed: true,
                    row_fixed: false,
                    row_name: row_row_name
                  end;
                  __static = static_row(row_1);
                  row_2 = __static and (do
                        row_fields: fields_1,
                        row_more: newty2(current_level.contents, --[[ Tnil ]]0),
                        row_bound: --[[ () ]]0,
                        row_closed: true,
                        row_fixed: false,
                        row_name: row_row_name
                      end) or (
                      policy ~= --[[ Univars ]]2 and row_1 or (do
                            row_fields: fields_1,
                            row_more: new_pre_univar(undefined, --[[ () ]]0),
                            row_bound: --[[ () ]]0,
                            row_closed: true,
                            row_fixed: false,
                            row_name: row_row_name
                          end)
                    );
                  ty_6 = newty2(current_level.contents, --[[ Tvariant ]]Block.__(8, {row_2})); end else 
               end end end end
              error({
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "typetexp.ml",
                    553,
                    10
                  }
                })
                
            end
          end end 
          return ctyp(--[[ Ttyp_class ]]Block.__(5, {
                        path_1,
                        lid_1,
                        args_1
                      }), ty_6); end end 
       if ___conditional___ == 6--[[ Ptyp_alias ]] then do
          alias = match[1];
          st = match[0];
          cty;
          xpcall(function() do
            t_1;
            xpcall(function() do
              t_1 = List.assoc(alias, univars.contents);
            end end,function(exn_6) do
              if (exn_6 == Caml_builtin_exceptions.not_found) then do
                t_1 = instance(undefined, env, find_2(alias, used_variables.contents)[0]);
              end else do
                error(exn_6)
              end end 
            end end)
            ty_7 = transl_type(env, policy, st);
            xpcall(function() do
              unify_var(env, t_1, ty_7.ctyp_type);
            end end,function(raw_exn_2) do
              exn_7 = Caml_js_exceptions.internalToOCamlException(raw_exn_2);
              if (exn_7[0] == Unify) then do
                trace = swap_list(exn_7[1]);
                error({
                  __Error_6,
                  styp.ptyp_loc,
                  env,
                  --[[ Alias_type_mismatch ]]Block.__(7, {trace})
                })
              end else do
                error(exn_7)
              end end 
            end end)
            cty = ty_7;
          end end,function(exn_8) do
            if (exn_8 == Caml_builtin_exceptions.not_found) then do
              if (principal.contents) then do
                begin_def(--[[ () ]]0);
              end
               end 
              t_2 = newvar(validate_name(undefined), --[[ () ]]0);
              used_variables.contents = add_5(alias, --[[ tuple ]]{
                    t_2,
                    styp.ptyp_loc
                  }, used_variables.contents);
              ty_8 = transl_type(env, policy, st);
              xpcall(function() do
                unify_var(env, t_2, ty_8.ctyp_type);
              end end,function(raw_exn_3) do
                exn_9 = Caml_js_exceptions.internalToOCamlException(raw_exn_3);
                if (exn_9[0] == Unify) then do
                  trace_1 = swap_list(exn_9[1]);
                  error({
                    __Error_6,
                    styp.ptyp_loc,
                    env,
                    --[[ Alias_type_mismatch ]]Block.__(7, {trace_1})
                  })
                end else do
                  error(exn_9)
                end end 
              end end)
              if (principal.contents) then do
                end_def(--[[ () ]]0);
                generalize_structure_1(current_level.contents, t_2);
              end
               end 
              t_3 = instance(undefined, env, t_2);
              px = proxy(t_3);
              match_9 = px.desc;
              if (typeof match_9 ~= "number") then do
                local ___conditional___=(match_9.tag | 0);
                do
                   if ___conditional___ == 0--[[ Tvar ]] then do
                      if (match_9[0] == undefined) then do
                        log_type(px);
                        px.desc = --[[ Tvar ]]Block.__(0, {alias});
                      end
                       end  end else 
                   if ___conditional___ == 9--[[ Tunivar ]] then do
                      if (match_9[0] == undefined) then do
                        log_type(px);
                        px.desc = --[[ Tunivar ]]Block.__(9, {alias});
                      end
                       end  end else 
                   end end end end
                  
                end
              end
               end 
              cty = do
                ctyp_desc: ty_8.ctyp_desc,
                ctyp_type: t_3,
                ctyp_env: ty_8.ctyp_env,
                ctyp_loc: ty_8.ctyp_loc,
                ctyp_attributes: ty_8.ctyp_attributes
              end;
            end else do
              error(exn_8)
            end end 
          end end)
          return ctyp(--[[ Ttyp_alias ]]Block.__(6, {
                        cty,
                        alias
                      }), cty.ctyp_type); end end 
       if ___conditional___ == 7--[[ Ptyp_variant ]] then do
          present = match[2];
          closed = match[1];
          name_1 = do
            contents: undefined
          end;
          mkfield = function(l, f) do
            desc = --[[ Tvariant ]]Block.__(8, {do
                  row_fields: --[[ :: ]]{
                    --[[ tuple ]]{
                      l,
                      f
                    },
                    --[[ [] ]]0
                  },
                  row_more: newvar(validate_name(undefined), --[[ () ]]0),
                  row_bound: --[[ () ]]0,
                  row_closed: true,
                  row_fixed: false,
                  row_name: undefined
                end});
            return newty2(current_level.contents, desc);
          end end;
          hfields = Hashtbl.create(undefined, 17);
          add_typed_field = function(loc, l, f) do
            h = hash_variant(l);
            xpcall(function() do
              match = Hashtbl.find(hfields, h);
              l$prime = match[0];
              if (l ~= l$prime) then do
                error({
                  __Error_6,
                  styp.ptyp_loc,
                  env,
                  --[[ Variant_tags ]]Block.__(12, {
                      l,
                      l$prime
                    })
                })
              end
               end 
              ty = mkfield(l, f);
              ty$prime = mkfield(l, match[1]);
              if (equal_4(env, false, --[[ :: ]]{
                      ty,
                      --[[ [] ]]0
                    }, --[[ :: ]]{
                      ty$prime,
                      --[[ [] ]]0
                    })) then do
                return --[[ () ]]0;
              end else do
                xpcall(function() do
                  return unify_2(env, ty, ty$prime);
                end end,function(raw_exn) do
                  exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                  if (exn[0] == Unify) then do
                    error({
                      __Error_6,
                      loc,
                      env,
                      --[[ Constructor_mismatch ]]Block.__(10, {
                          ty,
                          ty$prime
                        })
                    })
                  end
                   end 
                  error(exn)
                end end)
              end end 
            end end,function(exn_1) do
              if (exn_1 == Caml_builtin_exceptions.not_found) then do
                return Hashtbl.add(hfields, h, --[[ tuple ]]{
                            l,
                            f
                          });
              end else do
                error(exn_1)
              end end 
            end end)
          end end;
          add_field = function(param) do
            if (param.tag) then do
              sty = param[0];
              cty = transl_type(env, policy, sty);
              ty = cty.ctyp_type;
              match = repr(cty.ctyp_type);
              match_1 = match.desc;
              nm;
              nm = typeof match_1 == "number" or match_1.tag ~= --[[ Tconstr ]]3 and undefined or --[[ tuple ]]{
                  match_1[0],
                  match_1[1]
                };
              xpcall(function() do
                Hashtbl.iter((function(param, param_1) do
                        error(Pervasives.Exit)
                      end end), hfields);
                name_1.contents = nm;
              end end,function(exn) do
                if (exn == Pervasives.Exit) then do
                  name_1.contents = undefined;
                end else do
                  error(exn)
                end end 
              end end)
              match_2 = expand_head(env, cty.ctyp_type);
              match_3 = match_2.desc;
              fl;
              exit = 0;
              if (typeof match_3 == "number") then do
                exit = 1;
              end else do
                local ___conditional___=(match_3.tag | 0);
                do
                   if ___conditional___ == 0--[[ Tvar ]] then do
                      if (nm ~= undefined) then do
                        error({
                          __Error_6,
                          sty.ptyp_loc,
                          env,
                          --[[ Unbound_type_constructor_2 ]]Block.__(2, {nm[0]})
                        })
                      end
                       end 
                      exit = 1; end else 
                   if ___conditional___ == 8--[[ Tvariant ]] then do
                      row = match_3[0];
                      if (static_row(row)) then do
                        fl = row_repr_aux(--[[ [] ]]0, row).row_fields;
                      end else do
                        exit = 1;
                      end end  end else 
                   end end end end
                  exit = 1;
                    
                end
              end end 
              if (exit == 1) then do
                error({
                  __Error_6,
                  sty.ptyp_loc,
                  env,
                  --[[ Not_a_variant ]]Block.__(11, {ty})
                })
              end
               end 
              List.iter((function(param) do
                      f = param[1];
                      l = param[0];
                      f_1;
                      if (present ~= undefined and not List.mem(l, present)) then do
                        if (typeof f == "number") then do
                          error({
                            Caml_builtin_exceptions.assert_failure,
                            --[[ tuple ]]{
                              "typetexp.ml",
                              666,
                              24
                            }
                          })
                        end else if (f.tag) then do
                          error({
                            Caml_builtin_exceptions.assert_failure,
                            --[[ tuple ]]{
                              "typetexp.ml",
                              666,
                              24
                            }
                          })
                        end else do
                          match = f[0];
                          f_1 = match ~= undefined and --[[ Reither ]]Block.__(1, {
                                false,
                                --[[ :: ]]{
                                  match,
                                  --[[ [] ]]0
                                },
                                false,
                                do
                                  contents: undefined
                                end
                              }) or --[[ Reither ]]Block.__(1, {
                                true,
                                --[[ [] ]]0,
                                false,
                                do
                                  contents: undefined
                                end
                              });
                        end end  end 
                      end else do
                        f_1 = f;
                      end end 
                      return add_typed_field(sty.ptyp_loc, l, f_1);
                    end end), fl);
              return --[[ Tinherit ]]Block.__(1, {cty});
            end else do
              stl = param[3];
              c = param[2];
              l = param[0];
              name_1.contents = undefined;
              tl = List.map((function(param) do
                      return transl_type(env, policy, param);
                    end end), stl);
              f;
              exit_1 = 0;
              if (present ~= undefined and not List.mem(l, present)) then do
                ty_tl = List.map((function(cty) do
                        return cty.ctyp_type;
                      end end), tl);
                f = --[[ Reither ]]Block.__(1, {
                    c,
                    ty_tl,
                    false,
                    do
                      contents: undefined
                    end
                  });
              end else do
                exit_1 = 1;
              end end 
              if (exit_1 == 1) then do
                if (List.length(stl) > 1 or c and stl ~= --[[ [] ]]0) then do
                  error({
                    __Error_6,
                    styp.ptyp_loc,
                    env,
                    --[[ Present_has_conjunction ]]Block.__(8, {l})
                  })
                end
                 end 
                f = tl and --[[ Rpresent ]]Block.__(0, {tl[0].ctyp_type}) or --[[ Rpresent ]]Block.__(0, {undefined});
              end
               end 
              add_typed_field(styp.ptyp_loc, l, f);
              return --[[ Ttag ]]Block.__(0, {
                        l,
                        param[1],
                        c,
                        tl
                      });
            end end 
          end end;
          tfields = List.map(add_field, match[0]);
          fields_2 = Hashtbl.fold((function(param, p, l) do
                  return --[[ :: ]]{
                          p,
                          l
                        };
                end end), hfields, --[[ [] ]]0);
          if (present ~= undefined) then do
            List.iter((function(l) do
                    if (List.mem_assoc(l, fields_2)) then do
                      return 0;
                    end else do
                      error({
                        __Error_6,
                        styp.ptyp_loc,
                        env,
                        --[[ Present_has_no_type ]]Block.__(9, {l})
                      })
                    end end 
                  end end), present);
          end
           end 
          row_row_fields = List.rev(fields_2);
          row_row_more_1 = newvar(validate_name(undefined), --[[ () ]]0);
          row_row_closed = closed == --[[ Closed ]]0;
          row_row_name_1 = name_1.contents;
          row_3 = do
            row_fields: row_row_fields,
            row_more: row_row_more_1,
            row_bound: --[[ () ]]0,
            row_closed: row_row_closed,
            row_fixed: false,
            row_name: row_row_name_1
          end;
          __static_1 = static_row(row_3);
          row_4 = __static_1 and (do
                row_fields: row_row_fields,
                row_more: newty2(current_level.contents, --[[ Tnil ]]0),
                row_bound: --[[ () ]]0,
                row_closed: row_row_closed,
                row_fixed: false,
                row_name: row_row_name_1
              end) or (
              policy ~= --[[ Univars ]]2 and row_3 or (do
                    row_fields: row_row_fields,
                    row_more: new_pre_univar(undefined, --[[ () ]]0),
                    row_bound: --[[ () ]]0,
                    row_closed: row_row_closed,
                    row_fixed: false,
                    row_name: row_row_name_1
                  end)
            );
          ty_9 = newty2(current_level.contents, --[[ Tvariant ]]Block.__(8, {row_4}));
          return ctyp(--[[ Ttyp_variant ]]Block.__(7, {
                        tfields,
                        closed,
                        present
                      }), ty_9); end end 
       if ___conditional___ == 8--[[ Ptyp_poly ]] then do
          vars = match[0];
          begin_def(--[[ () ]]0);
          new_univars = List.map((function(name) do
                  return --[[ tuple ]]{
                          name,
                          newvar(validate_name(name), --[[ () ]]0)
                        };
                end end), vars);
          old_univars = univars.contents;
          univars.contents = Pervasives.$at(new_univars, univars.contents);
          cty_1 = transl_type(env, policy, match[1]);
          ty_10 = cty_1.ctyp_type;
          univars.contents = old_univars;
          end_def(--[[ () ]]0);
          iter_generalize_1(do
                contents: --[[ [] ]]0
              end, ty_10);
          ty_list = List.fold_left((function(tyl, param) do
                  v = proxy(param[1]);
                  if (deep_occur(v, ty_10)) then do
                    match = v.desc;
                    if (typeof match ~= "number" and not match.tag and v.level == 100000000) then do
                      v.desc = --[[ Tunivar ]]Block.__(9, {match[0]});
                      return --[[ :: ]]{
                              v,
                              tyl
                            };
                    end
                     end 
                    error({
                      __Error_6,
                      styp.ptyp_loc,
                      env,
                      --[[ Cannot_quantify ]]Block.__(14, {
                          param[0],
                          v
                        })
                    })
                  end else do
                    return tyl;
                  end end 
                end end), --[[ [] ]]0, new_univars);
          ty$prime = newty2(100000000, --[[ Tpoly ]]Block.__(10, {
                  ty_10,
                  List.rev(ty_list)
                }));
          unify_var(env, newvar(validate_name(undefined), --[[ () ]]0), ty$prime);
          return ctyp(--[[ Ttyp_poly ]]Block.__(8, {
                        vars,
                        cty_1
                      }), ty$prime); end end 
       if ___conditional___ == 9--[[ Ptyp_package ]] then do
          match_10 = match[0];
          p = match_10[0];
          match_11 = create_package_mty(true, styp.ptyp_loc, env, --[[ tuple ]]{
                p,
                match_10[1]
              });
          l_1 = match_11[0];
          z = narrow(--[[ () ]]0);
          mty = Curry._2(transl_modtype.contents, env, match_11[1]);
          widen(z);
          ptys = List.map((function(param) do
                  return --[[ tuple ]]{
                          param[0],
                          transl_type(env, policy, param[1])
                        };
                end end), l_1);
          path_2 = Curry._3(transl_modtype_longident.contents, styp.ptyp_loc, env, p.txt);
          desc_001 = List.map((function(param) do
                  return param[0].txt;
                end end), l_1);
          desc_002 = List.map((function(param) do
                  return param[1].ctyp_type;
                end end), ptys);
          desc_1 = --[[ Tpackage ]]Block.__(11, {
              path_2,
              desc_001,
              desc_002
            });
          ty_11 = newty2(current_level.contents, desc_1);
          return ctyp(--[[ Ttyp_package ]]Block.__(9, {do
                          pack_path: path_2,
                          pack_fields: ptys,
                          pack_type: mty.mty_type,
                          pack_txt: p
                        end}), ty_11); end end 
       if ___conditional___ == 10--[[ Ptyp_extension ]] then do
          error({
            Error_forward,
            error_of_extension(match[0])
          }) end end 
      
    end
  end end 
end end

function transl_poly_type(env, policy, t) do
  return transl_type(env, policy, force_poly(t));
end end

function transl_fields(loc, env, policy, seen, o, param) do
  if (param) then do
    match = param[0];
    s = match[0];
    if (List.mem(s, seen)) then do
      error({
        __Error_6,
        loc,
        env,
        --[[ Repeated_method_label ]]Block.__(16, {s})
      })
    end
     end 
    ty2 = transl_fields(loc, env, policy, --[[ :: ]]{
          s,
          seen
        }, o, param[1]);
    return newty2(current_level.contents, --[[ Tfield ]]Block.__(5, {
                  s,
                  --[[ Fpresent ]]0,
                  match[2].ctyp_type,
                  ty2
                }));
  end else if (o) then do
    if (policy >= 2) then do
      return new_pre_univar(undefined, --[[ () ]]0);
    end else do
      return newvar(validate_name(undefined), --[[ () ]]0);
    end end 
  end else do
    return newty2(current_level.contents, --[[ Tnil ]]0);
  end end  end 
end end

function make_fixed_univars(ty) do
  ty_1 = repr(ty);
  if (ty_1.level >= 0) then do
    mark_type_node(ty_1);
    match = ty_1.desc;
    if (typeof match == "number" or match.tag ~= --[[ Tvariant ]]8) then do
      return iter_type_expr(make_fixed_univars, ty_1);
    end else do
      row = row_repr_aux(--[[ [] ]]0, match[0]);
      if (is_Tunivar(row_more(row))) then do
        ty_1.desc = --[[ Tvariant ]]Block.__(8, {do
              row_fields: List.map((function(p) do
                      match = row_field_repr_aux(--[[ [] ]]0, p[1]);
                      if (typeof match == "number" or not match.tag) then do
                        return p;
                      end else do
                        return --[[ tuple ]]{
                                p[0],
                                --[[ Reither ]]Block.__(1, {
                                    match[0],
                                    match[1],
                                    true,
                                    match[3]
                                  })
                              };
                      end end 
                    end end), row.row_fields),
              row_more: row.row_more,
              row_bound: row.row_bound,
              row_closed: row.row_closed,
              row_fixed: true,
              row_name: row.row_name
            end});
      end
       end 
      return iter_row(make_fixed_univars, row);
    end end 
  end else do
    return 0;
  end end 
end end

function globalize_used_variables(env, fixed) do
  r = do
    contents: --[[ [] ]]0
  end;
  iter_2((function(name, param) do
          loc = param[1];
          ty = param[0];
          v = new_global_var(validate_name(undefined), --[[ () ]]0);
          snap = snapshot(--[[ () ]]0);
          tmp;
          xpcall(function() do
            unify_2(env, v, ty);
            tmp = true;
          end end,function(exn) do
            backtrack(snap);
            tmp = false;
          end end)
          if (tmp) then do
            xpcall(function() do
              r.contents = --[[ :: ]]{
                --[[ tuple ]]{
                  loc,
                  v,
                  find_2(name, type_variables.contents)
                },
                r.contents
              };
              return --[[ () ]]0;
            end end,function(exn_1) do
              if (exn_1 == Caml_builtin_exceptions.not_found) then do
                if (fixed and is_Tvar(repr(ty))) then do
                  error({
                    __Error_6,
                    loc,
                    env,
                    --[[ Unbound_type_variable ]]Block.__(0, {"'" .. name})
                  })
                end
                 end 
                v2 = new_global_var(validate_name(undefined), --[[ () ]]0);
                r.contents = --[[ :: ]]{
                  --[[ tuple ]]{
                    loc,
                    v,
                    v2
                  },
                  r.contents
                };
                type_variables.contents = add_5(name, v2, type_variables.contents);
                return --[[ () ]]0;
              end else do
                error(exn_1)
              end end 
            end end)
          end else do
            return 0;
          end end 
        end end), used_variables.contents);
  used_variables.contents = --[[ Empty ]]0;
  return (function(param) do
      return List.iter((function(param) do
                    xpcall(function() do
                      return unify_2(env, param[1], param[2]);
                    end end,function(raw_exn) do
                      exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                      if (exn[0] == Unify) then do
                        error({
                          __Error_6,
                          param[0],
                          env,
                          --[[ Type_mismatch ]]Block.__(6, {exn[1]})
                        })
                      end
                       end 
                      error(exn)
                    end end)
                  end end), r.contents);
    end end);
end end

function transl_simple_type(env, fixed, styp) do
  univars.contents = --[[ [] ]]0;
  used_variables.contents = --[[ Empty ]]0;
  typ = transl_type(env, fixed and --[[ Fixed ]]0 or --[[ Extensible ]]1, styp);
  globalize_used_variables(env, fixed)(--[[ () ]]0);
  ty = typ.ctyp_type;
  make_fixed_univars(ty);
  unmark_type(ty);
  return typ;
end end

function transl_simple_type_univars(env, styp) do
  univars.contents = --[[ [] ]]0;
  used_variables.contents = --[[ Empty ]]0;
  pre_univars.contents = --[[ [] ]]0;
  begin_def(--[[ () ]]0);
  typ = transl_type(env, --[[ Univars ]]2, styp);
  new_variables = used_variables.contents;
  used_variables.contents = --[[ Empty ]]0;
  iter_2((function(name, p) do
          if (mem_4(name, type_variables.contents)) then do
            used_variables.contents = add_5(name, p, used_variables.contents);
            return --[[ () ]]0;
          end else do
            return 0;
          end end 
        end end), new_variables);
  globalize_used_variables(env, false)(--[[ () ]]0);
  end_def(--[[ () ]]0);
  iter_generalize_1(do
        contents: --[[ [] ]]0
      end, typ.ctyp_type);
  univs = List.fold_left((function(acc, v) do
          v_1 = repr(v);
          match = v_1.desc;
          if (typeof match == "number" or match.tag or v_1.level ~= 100000000) then do
            return acc;
          end else do
            v_1.desc = --[[ Tunivar ]]Block.__(9, {match[0]});
            return --[[ :: ]]{
                    v_1,
                    acc
                  };
          end end 
        end end), --[[ [] ]]0, pre_univars.contents);
  ty = typ.ctyp_type;
  make_fixed_univars(ty);
  unmark_type(ty);
  return do
          ctyp_desc: typ.ctyp_desc,
          ctyp_type: instance(undefined, env, newty2(100000000, --[[ Tpoly ]]Block.__(10, {
                      typ.ctyp_type,
                      univs
                    }))),
          ctyp_env: typ.ctyp_env,
          ctyp_loc: typ.ctyp_loc,
          ctyp_attributes: typ.ctyp_attributes
        end;
end end

function transl_simple_type_delayed(env, styp) do
  univars.contents = --[[ [] ]]0;
  used_variables.contents = --[[ Empty ]]0;
  typ = transl_type(env, --[[ Extensible ]]1, styp);
  ty = typ.ctyp_type;
  make_fixed_univars(ty);
  unmark_type(ty);
  return --[[ tuple ]]{
          typ,
          globalize_used_variables(env, false)
        };
end end

function transl_type_scheme(env, styp) do
  reset_type_variables(--[[ () ]]0);
  begin_def(--[[ () ]]0);
  typ = transl_simple_type(env, false, styp);
  end_def(--[[ () ]]0);
  iter_generalize_1(do
        contents: --[[ [] ]]0
      end, typ.ctyp_type);
  return typ;
end end

function spellcheck(ppf, fold, env, lid) do
  match = #last_1(lid);
  switcher = match - 1 | 0;
  cutoff = switcher > 3 or switcher < 0 and (
      switcher == 5 or switcher == 4 and 2 or 3
    ) or (
      switcher >= 2 and 1 or 0
    );
  compare = function(target, head, acc) do
    best_dist = acc[1];
    best_choice = acc[0];
    match = edit_distance(target, head, cutoff);
    if (match ~= undefined) then do
      dist = match;
      choice = dist < best_dist and --[[ :: ]]{
          head,
          --[[ [] ]]0
        } or (
          dist == best_dist and --[[ :: ]]{
              head,
              best_choice
            } or best_choice
        );
      return --[[ tuple ]]{
              choice,
              dist < best_dist and dist or best_dist
            };
    end else do
      return --[[ tuple ]]{
              best_choice,
              best_dist
            };
    end end 
  end end;
  init = --[[ tuple ]]{
    --[[ [] ]]0,
    Pervasives.max_int
  };
  handle = function(param) do
    match = List.rev(param[0]);
    if (match) then do
      rev_rest = match[1];
      return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Formatting_lit ]]Block.__(17, {
                          --[[ Force_newline ]]3,
                          --[[ String_literal ]]Block.__(11, {
                              "Hint: Did you mean ",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ Char_literal ]]Block.__(12, {
                                              --[[ "?" ]]63,
                                              --[[ End_of_format ]]0
                                            })
                                        })
                                    })
                                })
                            })
                        }),
                      "@\nHint: Did you mean %s%s%s?"
                    }), __String.concat(", ", List.rev(rev_rest)), rev_rest == --[[ [] ]]0 and "" or " or ", match[0]);
    end else do
      return --[[ () ]]0;
    end end 
  end end;
  Format.fprintf(ppf, --[[ Format ]]{
        --[[ Formatting_lit ]]Block.__(17, {
            --[[ FFlush ]]2,
            --[[ End_of_format ]]0
          }),
        "@?"
      });
  local ___conditional___=(lid.tag | 0);
  do
     if ___conditional___ == 0--[[ Lident ]] then do
        s = lid[0];
        return handle(Curry._4(fold, (function(param, param_1) do
                          return compare(s, param, param_1);
                        end end), undefined, env, init)); end end 
     if ___conditional___ == 1--[[ Ldot ]] then do
        s_1 = lid[1];
        return handle(Curry._4(fold, (function(param, param_1) do
                          return compare(s_1, param, param_1);
                        end end), lid[0], env, init)); end end 
     if ___conditional___ == 2--[[ Lapply ]] then do
        return --[[ () ]]0; end end 
    
  end
end end

function spellcheck_simple(ppf, fold, extr) do
  return (function(param, param_1) do
      return spellcheck(ppf, (function(f) do
                    return Curry._1(fold, (function(decl, x) do
                                  return Curry._2(f, Curry._1(extr, decl), x);
                                end end));
                  end end), param, param_1);
    end end);
end end

function spellcheck_1(ppf, fold) do
  return (function(param, param_1) do
      return spellcheck(ppf, (function(f) do
                    return Curry._1(fold, (function(s, param, param_1, x) do
                                  return Curry._2(f, s, x);
                                end end));
                  end end), param, param_1);
    end end);
end end

register_error_of_exn((function(param) do
        if (param[0] == __Error_6) then do
          env = param[2];
          return error_of_printer(param[1], (function(param, param_1) do
                        env_1 = env;
                        ppf = param;
                        param_2 = param_1;
                        if (typeof param_2 == "number") then do
                          if (param_2 == --[[ Recursive_type ]]0) then do
                            return Format.fprintf(ppf, --[[ Format ]]{
                                        --[[ String_literal ]]Block.__(11, {
                                            "This type is recursive",
                                            --[[ End_of_format ]]0
                                          }),
                                        "This type is recursive"
                                      });
                          end else do
                            return Format.fprintf(ppf, --[[ Format ]]{
                                        --[[ String_literal ]]Block.__(11, {
                                            "Illegal recursive module reference",
                                            --[[ End_of_format ]]0
                                          }),
                                        "Illegal recursive module reference"
                                      });
                          end end 
                        end else do
                          local ___conditional___=(param_2.tag | 0);
                          do
                             if ___conditional___ == 0--[[ Unbound_type_variable ]] then do
                                return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ String_literal ]]Block.__(11, {
                                                    "Unbound type parameter ",
                                                    --[[ String ]]Block.__(2, {
                                                        --[[ No_padding ]]0,
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Flush_newline ]]4,
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })
                                                  }),
                                                "Unbound type parameter %s@."
                                              }), param_2[0]); end end 
                             if ___conditional___ == 1--[[ Unbound_type_constructor ]] then do
                                lid = param_2[0];
                                Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "Unbound type constructor ",
                                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                            }),
                                          "Unbound type constructor %a"
                                        }), longident, lid);
                                return spellcheck_1(ppf, fold_types)(env_1, lid); end end 
                             if ___conditional___ == 2--[[ Unbound_type_constructor_2 ]] then do
                                return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ String_literal ]]Block.__(11, {
                                                    "The type constructor",
                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                        --[[ Break ]]Block.__(0, {
                                                            "@ ",
                                                            1,
                                                            0
                                                          }),
                                                        --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                --[[ Break ]]Block.__(0, {
                                                                    "@ ",
                                                                    1,
                                                                    0
                                                                  }),
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "is not yet completely defined",
                                                                    --[[ End_of_format ]]0
                                                                  })
                                                              })})
                                                      })
                                                  }),
                                                "The type constructor@ %a@ is not yet completely defined"
                                              }), path, param_2[0]); end end 
                             if ___conditional___ == 3--[[ Type_arity_mismatch ]] then do
                                return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ Formatting_gen ]]Block.__(18, {
                                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                          --[[ End_of_format ]]0,
                                                          ""
                                                        }}),
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "The type constructor ",
                                                        --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                --[[ Break ]]Block.__(0, {
                                                                    "@ ",
                                                                    1,
                                                                    0
                                                                  }),
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "expects ",
                                                                    --[[ Int ]]Block.__(4, {
                                                                        --[[ Int_i ]]3,
                                                                        --[[ No_padding ]]0,
                                                                        --[[ No_precision ]]0,
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            " argument(s),",
                                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                                --[[ Break ]]Block.__(0, {
                                                                                    "@ ",
                                                                                    1,
                                                                                    0
                                                                                  }),
                                                                                --[[ String_literal ]]Block.__(11, {
                                                                                    "but is here applied to ",
                                                                                    --[[ Int ]]Block.__(4, {
                                                                                        --[[ Int_i ]]3,
                                                                                        --[[ No_padding ]]0,
                                                                                        --[[ No_precision ]]0,
                                                                                        --[[ String_literal ]]Block.__(11, {
                                                                                            " argument(s)",
                                                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                                                --[[ Close_box ]]0,
                                                                                                --[[ End_of_format ]]0
                                                                                              })
                                                                                          })
                                                                                      })
                                                                                  })
                                                                              })
                                                                          })
                                                                      })
                                                                  })
                                                              })})
                                                      })
                                                  }),
                                                "@[The type constructor %a@ expects %i argument(s),@ but is here applied to %i argument(s)@]"
                                              }), longident, param_2[0], param_2[1], param_2[2]); end end 
                             if ___conditional___ == 4--[[ Bound_type_variable ]] then do
                                return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ String_literal ]]Block.__(11, {
                                                    "Already bound type parameter '",
                                                    --[[ String ]]Block.__(2, {
                                                        --[[ No_padding ]]0,
                                                        --[[ End_of_format ]]0
                                                      })
                                                  }),
                                                "Already bound type parameter '%s"
                                              }), param_2[0]); end end 
                             if ___conditional___ == 5--[[ Unbound_row_variable ]] then do
                                return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ String_literal ]]Block.__(11, {
                                                    "Unbound row variable in #",
                                                    --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                  }),
                                                "Unbound row variable in #%a"
                                              }), longident, param_2[0]); end end 
                             if ___conditional___ == 6--[[ Type_mismatch ]] then do
                                return report_unification_error(ppf, empty, undefined, param_2[0], (function(ppf) do
                                              return Format.fprintf(ppf, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "This type",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "This type"
                                                        });
                                            end end), (function(ppf) do
                                              return Format.fprintf(ppf, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "should be an instance of type",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "should be an instance of type"
                                                        });
                                            end end)); end end 
                             if ___conditional___ == 7--[[ Alias_type_mismatch ]] then do
                                return report_unification_error(ppf, empty, undefined, param_2[0], (function(ppf) do
                                              return Format.fprintf(ppf, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "This alias is bound to type",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "This alias is bound to type"
                                                        });
                                            end end), (function(ppf) do
                                              return Format.fprintf(ppf, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "but is used as an instance of type",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "but is used as an instance of type"
                                                        });
                                            end end)); end end 
                             if ___conditional___ == 8--[[ Present_has_conjunction ]] then do
                                return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ String_literal ]]Block.__(11, {
                                                    "The present constructor ",
                                                    --[[ String ]]Block.__(2, {
                                                        --[[ No_padding ]]0,
                                                        --[[ String_literal ]]Block.__(11, {
                                                            " has a conjunctive type",
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })
                                                  }),
                                                "The present constructor %s has a conjunctive type"
                                              }), param_2[0]); end end 
                             if ___conditional___ == 9--[[ Present_has_no_type ]] then do
                                return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ String_literal ]]Block.__(11, {
                                                    "The present constructor ",
                                                    --[[ String ]]Block.__(2, {
                                                        --[[ No_padding ]]0,
                                                        --[[ String_literal ]]Block.__(11, {
                                                            " has no type",
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })
                                                  }),
                                                "The present constructor %s has no type"
                                              }), param_2[0]); end end 
                             if ___conditional___ == 10--[[ Constructor_mismatch ]] then do
                                ty$prime = param_2[1];
                                ty = param_2[0];
                                return wrap_printing_env(env_1, (function(param) do
                                              reset_and_mark_loops_list(--[[ :: ]]{
                                                    ty,
                                                    --[[ :: ]]{
                                                      ty$prime,
                                                      --[[ [] ]]0
                                                    }
                                                  });
                                              return Curry._6(Format.fprintf(ppf, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "<hov>",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "<hov>"
                                                                      }}),
                                                                  --[[ String ]]Block.__(2, {
                                                                      --[[ No_padding ]]0,
                                                                      --[[ Char_literal ]]Block.__(12, {
                                                                          --[[ " " ]]32,
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Break ]]Block.__(0, {
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    }),
                                                                                  --[[ String ]]Block.__(2, {
                                                                                      --[[ No_padding ]]0,
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Break ]]Block.__(0, {
                                                                                              "@ ",
                                                                                              1,
                                                                                              0
                                                                                            }),
                                                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                  --[[ Close_box ]]0,
                                                                                                  --[[ End_of_format ]]0
                                                                                                })})
                                                                                        })
                                                                                    })
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[<hov>%s %a@ %s@ %a@]"
                                                            }), "This variant type contains a constructor", type_expr_1, ty, "which should be", type_expr_1, ty$prime);
                                            end end)); end end 
                             if ___conditional___ == 11--[[ Not_a_variant ]] then do
                                ty_1 = param_2[0];
                                reset(--[[ () ]]0);
                                mark_loops(ty_1);
                                return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ Formatting_gen ]]Block.__(18, {
                                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                          --[[ End_of_format ]]0,
                                                          ""
                                                        }}),
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "The type ",
                                                        --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                --[[ Break ]]Block.__(0, {
                                                                    "@ ",
                                                                    1,
                                                                    0
                                                                  }),
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "is not a polymorphic variant type",
                                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                                        --[[ Close_box ]]0,
                                                                        --[[ End_of_format ]]0
                                                                      })
                                                                  })
                                                              })})
                                                      })
                                                  }),
                                                "@[The type %a@ is not a polymorphic variant type@]"
                                              }), type_expr_1, ty_1); end end 
                             if ___conditional___ == 12--[[ Variant_tags ]] then do
                                return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ Formatting_gen ]]Block.__(18, {
                                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                          --[[ End_of_format ]]0,
                                                          ""
                                                        }}),
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "Variant tags `",
                                                        --[[ String ]]Block.__(2, {
                                                            --[[ No_padding ]]0,
                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                --[[ Break ]]Block.__(0, {
                                                                    "@ ",
                                                                    1,
                                                                    0
                                                                  }),
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "and `",
                                                                    --[[ String ]]Block.__(2, {
                                                                        --[[ No_padding ]]0,
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            " have the same hash value.",
                                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                                --[[ Break ]]Block.__(0, {
                                                                                    "@ ",
                                                                                    1,
                                                                                    0
                                                                                  }),
                                                                                --[[ String ]]Block.__(2, {
                                                                                    --[[ No_padding ]]0,
                                                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                                                        --[[ Close_box ]]0,
                                                                                        --[[ End_of_format ]]0
                                                                                      })
                                                                                  })
                                                                              })
                                                                          })
                                                                      })
                                                                  })
                                                              })
                                                          })
                                                      })
                                                  }),
                                                "@[Variant tags `%s@ and `%s have the same hash value.@ %s@]"
                                              }), param_2[0], param_2[1], "Change one of them."); end end 
                             if ___conditional___ == 13--[[ Invalid_variable_name ]] then do
                                return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ String_literal ]]Block.__(11, {
                                                    "The type variable name ",
                                                    --[[ String ]]Block.__(2, {
                                                        --[[ No_padding ]]0,
                                                        --[[ String_literal ]]Block.__(11, {
                                                            " is not allowed in programs",
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })
                                                  }),
                                                "The type variable name %s is not allowed in programs"
                                              }), param_2[0]); end end 
                             if ___conditional___ == 14--[[ Cannot_quantify ]] then do
                                v = param_2[1];
                                return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ Formatting_gen ]]Block.__(18, {
                                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "<hov>",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "<hov>"
                                                        }}),
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "The universal type variable '",
                                                        --[[ String ]]Block.__(2, {
                                                            --[[ No_padding ]]0,
                                                            --[[ String_literal ]]Block.__(11, {
                                                                " cannot be generalized:",
                                                                --[[ Formatting_lit ]]Block.__(17, {
                                                                    --[[ Break ]]Block.__(0, {
                                                                        "@ ",
                                                                        1,
                                                                        0
                                                                      }),
                                                                    --[[ String ]]Block.__(2, {
                                                                        --[[ No_padding ]]0,
                                                                        --[[ Char_literal ]]Block.__(12, {
                                                                            --[[ "." ]]46,
                                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                                --[[ Close_box ]]0,
                                                                                --[[ End_of_format ]]0
                                                                              })
                                                                          })
                                                                      })
                                                                  })
                                                              })
                                                          })
                                                      })
                                                  }),
                                                "@[<hov>The universal type variable '%s cannot be generalized:@ %s.@]"
                                              }), param_2[0], is_Tvar(v) and "it escapes its scope" or (
                                              is_Tunivar(v) and "it is already bound to another variable" or "it is not a variable"
                                            )); end end 
                             if ___conditional___ == 15--[[ Multiple_constraints_on_type ]] then do
                                return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ String_literal ]]Block.__(11, {
                                                    "Multiple constraints for type ",
                                                    --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                  }),
                                                "Multiple constraints for type %a"
                                              }), longident, param_2[0]); end end 
                             if ___conditional___ == 16--[[ Repeated_method_label ]] then do
                                return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ Formatting_gen ]]Block.__(18, {
                                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                          --[[ End_of_format ]]0,
                                                          ""
                                                        }}),
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "This is the second method `",
                                                        --[[ String ]]Block.__(2, {
                                                            --[[ No_padding ]]0,
                                                            --[[ String_literal ]]Block.__(11, {
                                                                "' of this object type.",
                                                                --[[ Formatting_lit ]]Block.__(17, {
                                                                    --[[ Break ]]Block.__(0, {
                                                                        "@ ",
                                                                        1,
                                                                        0
                                                                      }),
                                                                    --[[ String ]]Block.__(2, {
                                                                        --[[ No_padding ]]0,
                                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                                            --[[ Close_box ]]0,
                                                                            --[[ End_of_format ]]0
                                                                          })
                                                                      })
                                                                  })
                                                              })
                                                          })
                                                      })
                                                  }),
                                                "@[This is the second method `%s' of this object type.@ %s@]"
                                              }), param_2[0], "Multiple occurences are not allowed."); end end 
                             if ___conditional___ == 17--[[ Unbound_value ]] then do
                                lid_1 = param_2[0];
                                Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "Unbound value ",
                                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                            }),
                                          "Unbound value %a"
                                        }), longident, lid_1);
                                return spellcheck_1(ppf, fold_values)(env_1, lid_1); end end 
                             if ___conditional___ == 18--[[ Unbound_constructor ]] then do
                                lid_2 = param_2[0];
                                Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "Unbound constructor ",
                                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                            }),
                                          "Unbound constructor %a"
                                        }), longident, lid_2);
                                return spellcheck_simple(ppf, fold_constructors, (function(d) do
                                                return d.cstr_name;
                                              end end))(env_1, lid_2); end end 
                             if ___conditional___ == 19--[[ Unbound_label ]] then do
                                lid_3 = param_2[0];
                                Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "Unbound record field ",
                                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                            }),
                                          "Unbound record field %a"
                                        }), longident, lid_3);
                                return spellcheck_simple(ppf, fold_labels, (function(d) do
                                                return d.lbl_name;
                                              end end))(env_1, lid_3); end end 
                             if ___conditional___ == 20--[[ Unbound_module ]] then do
                                lid_4 = param_2[0];
                                Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "Unbound module ",
                                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                            }),
                                          "Unbound module %a"
                                        }), longident, lid_4);
                                return spellcheck_1(ppf, fold_modules)(env_1, lid_4); end end 
                             if ___conditional___ == 21--[[ Unbound_class ]] then do
                                lid_5 = param_2[0];
                                Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "Unbound class ",
                                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                            }),
                                          "Unbound class %a"
                                        }), longident, lid_5);
                                return spellcheck_1(ppf, fold_classs)(env_1, lid_5); end end 
                             if ___conditional___ == 22--[[ Unbound_modtype ]] then do
                                lid_6 = param_2[0];
                                Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "Unbound module type ",
                                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                            }),
                                          "Unbound module type %a"
                                        }), longident, lid_6);
                                return spellcheck_1(ppf, fold_modtypes)(env_1, lid_6); end end 
                             if ___conditional___ == 23--[[ Unbound_cltype ]] then do
                                lid_7 = param_2[0];
                                Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "Unbound class type ",
                                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                            }),
                                          "Unbound class type %a"
                                        }), longident, lid_7);
                                return spellcheck_1(ppf, fold_cltypes)(env_1, lid_7); end end 
                             if ___conditional___ == 24--[[ Ill_typed_functor_application ]] then do
                                return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ String_literal ]]Block.__(11, {
                                                    "Ill-typed functor application ",
                                                    --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                  }),
                                                "Ill-typed functor application %a"
                                              }), longident, param_2[0]); end end 
                             if ___conditional___ == 25--[[ Access_functor_as_structure ]] then do
                                return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ String_literal ]]Block.__(11, {
                                                    "The module ",
                                                    --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                                            " is a functor, not a structure",
                                                            --[[ End_of_format ]]0
                                                          })})
                                                  }),
                                                "The module %a is a functor, not a structure"
                                              }), longident, param_2[0]); end end 
                            
                          end
                        end end 
                      end end), param[3]);
        end else if (param[0] == Error_forward) then do
          return param[1];
        end else do
          return ;
        end end  end 
      end end));

__Error_7 = Caml_exceptions.create("Ocaml_typedtree_test.Typecore.Error");

Error_forward_1 = Caml_exceptions.create("Ocaml_typedtree_test.Typecore.Error_forward");

type_module = do
  contents: (function(env, md) do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "typecore.ml",
          77,
          22
        }
      })
    end end)
end;

type_open = do
  contents: (function(param) do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "typecore.ml",
          83,
          16
        }
      })
    end end)
end;

type_package = do
  contents: (function(param) do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "typecore.ml",
          88,
          16
        }
      })
    end end)
end;

type_object = do
  contents: (function(env, s) do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "typecore.ml",
          92,
          20
        }
      })
    end end)
end;

function re(node) do
  add_saved_type(--[[ Partial_expression ]]Block.__(2, {node}));
  record_2(--[[ Ti_expr ]]Block.__(1, {node}));
  return node;
end end

function rp(node) do
  add_saved_type(--[[ Partial_pattern ]]Block.__(3, {node}));
  record_2(--[[ Ti_pat ]]Block.__(0, {node}));
  return node;
end end

function snd3(param) do
  return param[1];
end end

function iter_expression(f, e) do
  expr = function(_e) do
    while(true) do
      e = _e;
      Curry._1(f, e);
      match = e.pexp_desc;
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 2--[[ Pexp_let ]] then do
            expr(match[2]);
            return List.iter(binding, match[1]); end end 
         if ___conditional___ == 3--[[ Pexp_function ]] then do
            return List.iter(__case, match[0]); end end 
         if ___conditional___ == 4--[[ Pexp_fun ]] then do
            may(expr, match[1]);
            _e = match[3];
            ::continue:: ; end end 
         if ___conditional___ == 5--[[ Pexp_apply ]] then do
            expr(match[0]);
            return List.iter((function(param) do
                          return expr(param[1]);
                        end end), match[1]); end end 
         if ___conditional___ == 6--[[ Pexp_match ]]
         or ___conditional___ == 7--[[ Pexp_try ]]
         or ___conditional___ == 9--[[ Pexp_construct ]]
         or ___conditional___ == 10--[[ Pexp_variant ]] then do
            return may(expr, match[1]); end end 
         if ___conditional___ == 11--[[ Pexp_record ]] then do
            may(expr, match[1]);
            return List.iter((function(param) do
                          return expr(param[1]);
                        end end), match[0]); end end 
         if ___conditional___ == 13--[[ Pexp_setfield ]] then do
            expr(match[0]);
            _e = match[2];
            ::continue:: ; end end 
         if ___conditional___ == 8--[[ Pexp_tuple ]]
         or ___conditional___ == 14--[[ Pexp_array ]] then do
            return List.iter(expr, match[0]); end end 
         if ___conditional___ == 15--[[ Pexp_ifthenelse ]] then do
            expr(match[0]);
            expr(match[1]);
            return may(expr, match[2]); end end 
         if ___conditional___ == 16--[[ Pexp_sequence ]]
         or ___conditional___ == 17--[[ Pexp_while ]] then do
            expr(match[0]);
            _e = match[1];
            ::continue:: ; end end 
         if ___conditional___ == 18--[[ Pexp_for ]] then do
            expr(match[1]);
            expr(match[2]);
            _e = match[4];
            ::continue:: ; end end 
         if ___conditional___ == 24--[[ Pexp_override ]] then do
            return List.iter((function(param) do
                          return expr(param[1]);
                        end end), match[0]); end end 
         if ___conditional___ == 25--[[ Pexp_letmodule ]] then do
            expr(match[2]);
            return module_expr(match[1]); end end 
         if ___conditional___ == 29--[[ Pexp_object ]] then do
            return List.iter(class_field, match[0].pcstr_fields); end end 
         if ___conditional___ == 23--[[ Pexp_setinstvar ]]
         or ___conditional___ == 30--[[ Pexp_newtype ]] then do
            _e = match[1];
            ::continue:: ; end end 
         if ___conditional___ == 31--[[ Pexp_pack ]] then do
            return module_expr(match[0]); end end 
         if ___conditional___ == 32--[[ Pexp_open ]] then do
            _e = match[2];
            ::continue:: ; end end 
         if ___conditional___ == 0--[[ Pexp_ident ]]
         or ___conditional___ == 1--[[ Pexp_constant ]]
         or ___conditional___ == 22--[[ Pexp_new ]]
         or ___conditional___ == 33--[[ Pexp_extension ]] then do
            return --[[ () ]]0; end end 
        _e = match[0];
          ::continue:: ;
          
      end
      expr(match[0]);
      return List.iter(__case, match[1]);
    end;
  end end;
  __case = function(param) do
    may(expr, param.pc_guard);
    return expr(param.pc_rhs);
  end end;
  binding = function(x) do
    return expr(x.pvb_expr);
  end end;
  module_expr = function(_me) do
    while(true) do
      me = _me;
      match = me.pmod_desc;
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 1--[[ Pmod_structure ]] then do
            return List.iter(structure_item, match[0]); end end 
         if ___conditional___ == 2--[[ Pmod_functor ]] then do
            _me = match[2];
            ::continue:: ; end end 
         if ___conditional___ == 3--[[ Pmod_apply ]] then do
            module_expr(match[0]);
            _me = match[1];
            ::continue:: ; end end 
         if ___conditional___ == 4--[[ Pmod_constraint ]] then do
            _me = match[0];
            ::continue:: ; end end 
         if ___conditional___ == 5--[[ Pmod_unpack ]] then do
            return expr(match[0]); end end 
         if ___conditional___ == 0--[[ Pmod_ident ]]
         or ___conditional___ == 6--[[ Pmod_extension ]] then do
            return --[[ () ]]0; end end 
        
      end
    end;
  end end;
  structure_item = function(str) do
    match = str.pstr_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 0--[[ Pstr_eval ]] then do
          return expr(match[0]); end end 
       if ___conditional___ == 1--[[ Pstr_value ]] then do
          return List.iter(binding, match[1]); end end 
       if ___conditional___ == 6--[[ Pstr_module ]] then do
          return module_expr(match[0].pmb_expr); end end 
       if ___conditional___ == 7--[[ Pstr_recmodule ]] then do
          return List.iter((function(x) do
                        return module_expr(x.pmb_expr);
                      end end), match[0]); end end 
       if ___conditional___ == 10--[[ Pstr_class ]] then do
          return List.iter((function(c) do
                        return class_expr(c.pci_expr);
                      end end), match[0]); end end 
       if ___conditional___ == 12--[[ Pstr_include ]] then do
          return module_expr(match[0].pincl_mod); end end 
      return --[[ () ]]0;
        
    end
  end end;
  class_expr = function(_ce) do
    while(true) do
      ce = _ce;
      match = ce.pcl_desc;
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 1--[[ Pcl_structure ]] then do
            return List.iter(class_field, match[0].pcstr_fields); end end 
         if ___conditional___ == 2--[[ Pcl_fun ]] then do
            may(expr, match[1]);
            _ce = match[3];
            ::continue:: ; end end 
         if ___conditional___ == 3--[[ Pcl_apply ]] then do
            class_expr(match[0]);
            return List.iter((function(param) do
                          return expr(param[1]);
                        end end), match[1]); end end 
         if ___conditional___ == 4--[[ Pcl_let ]] then do
            List.iter(binding, match[1]);
            _ce = match[2];
            ::continue:: ; end end 
         if ___conditional___ == 5--[[ Pcl_constraint ]] then do
            _ce = match[0];
            ::continue:: ; end end 
         if ___conditional___ == 0--[[ Pcl_constr ]]
         or ___conditional___ == 6--[[ Pcl_extension ]] then do
            return --[[ () ]]0; end end 
        
      end
    end;
  end end;
  class_field = function(cf) do
    match = cf.pcf_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 0--[[ Pcf_inherit ]] then do
          return class_expr(match[1]); end end 
       if ___conditional___ == 1--[[ Pcf_val ]] then do
          match_1 = match[0][2];
          if (match_1.tag) then do
            return expr(match_1[1]);
          end else do
            return --[[ () ]]0;
          end end  end end 
       if ___conditional___ == 2--[[ Pcf_method ]] then do
          match_2 = match[0][2];
          if (match_2.tag) then do
            return expr(match_2[1]);
          end else do
            return --[[ () ]]0;
          end end  end end 
       if ___conditional___ == 4--[[ Pcf_initializer ]] then do
          return expr(match[0]); end end 
       if ___conditional___ == 3--[[ Pcf_constraint ]]
       or ___conditional___ == 5--[[ Pcf_attribute ]]
       or ___conditional___ == 6--[[ Pcf_extension ]] then do
          return --[[ () ]]0; end end 
      
    end
  end end;
  return expr(e);
end end

function all_idents_cases(el) do
  idents = Hashtbl.create(undefined, 8);
  f = function(param) do
    match = param.pexp_desc;
    if (match.tag) then do
      return --[[ () ]]0;
    end else do
      match_1 = match[0].txt;
      local ___conditional___=(match_1.tag | 0);
      do
         if ___conditional___ == 0--[[ Lident ]] then do
            return Hashtbl.replace(idents, match_1[0], --[[ () ]]0); end end 
         if ___conditional___ == 1--[[ Ldot ]]
         or ___conditional___ == 2--[[ Lapply ]] then do
            return --[[ () ]]0; end end 
        
      end
    end end 
  end end;
  List.iter((function(cp) do
          may((function(param) do
                  return iter_expression(f, param);
                end end), cp.pc_guard);
          return iter_expression(f, cp.pc_rhs);
        end end), el);
  return Hashtbl.fold((function(x, param, rest) do
                return --[[ :: ]]{
                        x,
                        rest
                      };
              end end), idents, --[[ [] ]]0);
end end

function type_constant(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Const_int ]] then do
        return instance_def(type_int); end end 
     if ___conditional___ == 1--[[ Const_char ]] then do
        return instance_def(type_char); end end 
     if ___conditional___ == 2--[[ Const_string ]] then do
        return instance_def(type_string); end end 
     if ___conditional___ == 3--[[ Const_float ]] then do
        return instance_def(type_float); end end 
     if ___conditional___ == 4--[[ Const_int32 ]] then do
        return instance_def(type_int32); end end 
     if ___conditional___ == 5--[[ Const_int64 ]] then do
        return instance_def(type_int64); end end 
     if ___conditional___ == 6--[[ Const_nativeint ]] then do
        return instance_def(type_nativeint); end end 
    
  end
end end

function type_option_1(ty) do
  return newty2(current_level.contents, --[[ Tconstr ]]Block.__(3, {
                path_option,
                --[[ :: ]]{
                  ty,
                  --[[ [] ]]0
                },
                do
                  contents: --[[ Mnil ]]0
                end
              }));
end end

function mkexp_1(exp_desc, exp_type, exp_loc, exp_env) do
  return do
          exp_desc: exp_desc,
          exp_loc: exp_loc,
          exp_extra: --[[ [] ]]0,
          exp_type: exp_type,
          exp_env: exp_env,
          exp_attributes: --[[ [] ]]0
        end;
end end

function option_none(ty, loc) do
  lid = --[[ Lident ]]Block.__(0, {"None"});
  cnone = lookup_constructor(lid, initial_safe_string);
  return mkexp_1(--[[ Texp_construct ]]Block.__(8, {
                do
                  txt: lid,
                  loc: none
                end,
                cnone,
                --[[ [] ]]0
              }), ty, loc, initial_safe_string);
end end

function option_some(texp) do
  lid = --[[ Lident ]]Block.__(0, {"Some"});
  csome = lookup_constructor(lid, initial_safe_string);
  return mkexp_1(--[[ Texp_construct ]]Block.__(8, {
                do
                  txt: lid,
                  loc: none
                end,
                csome,
                --[[ :: ]]{
                  texp,
                  --[[ [] ]]0
                }
              }), type_option_1(texp.exp_type), texp.exp_loc, texp.exp_env);
end end

function extract_option_type(env, ty) do
  match = expand_head(env, ty);
  match_1 = match.desc;
  if (typeof match_1 ~= "number" and match_1.tag == --[[ Tconstr ]]3) then do
    match_2 = match_1[1];
    if (match_2 and not match_2[1] and same(match_1[0], path_option)) then do
      return match_2[0];
    end
     end 
  end
   end 
  error({
    Caml_builtin_exceptions.assert_failure,
    --[[ tuple ]]{
      "typecore.ml",
      275,
      9
    }
  })
end end

function extract_concrete_record(env, ty) do
  match = extract_concrete_typedecl(env, ty);
  match_1 = match[2].type_kind;
  if (typeof match_1 == "number") then do
    error(Caml_builtin_exceptions.not_found)
  end else if (match_1.tag) then do
    error(Caml_builtin_exceptions.not_found)
  end else do
    return --[[ tuple ]]{
            match[0],
            match[1],
            match_1[0]
          };
  end end  end 
end end

function extract_concrete_variant(env, ty) do
  match = extract_concrete_typedecl(env, ty);
  match_1 = match[2].type_kind;
  p = match[1];
  p0 = match[0];
  if (typeof match_1 == "number") then do
    if (match_1 == --[[ Type_abstract ]]0) then do
      error(Caml_builtin_exceptions.not_found)
    end else do
      return --[[ tuple ]]{
              p0,
              p,
              --[[ [] ]]0
            };
    end end 
  end else if (match_1.tag) then do
    return --[[ tuple ]]{
            p0,
            p,
            match_1[0]
          };
  end else do
    error(Caml_builtin_exceptions.not_found)
  end end  end 
end end

function extract_label_names(sexp, env, ty) do
  xpcall(function() do
    match = extract_concrete_record(env, ty);
    return List.map((function(l) do
                  return l.ld_id;
                end end), match[2]);
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "typecore.ml",
          293,
          4
        }
      })
    end
     end 
    error(exn)
  end end)
end end

function explicit_arity(param) do
  return List.exists((function(param) do
                local ___conditional___=(param[0].txt);
                do
                   if ___conditional___ == "explicit_arity"
                   or ___conditional___ == "ocaml.explicit_arity" then do
                      return true; end end 
                  return false;
                    
                end
              end end), param);
end end

function unify_pat_types(loc, env, ty, ty$prime) do
  xpcall(function() do
    return unify_2(env, ty, ty$prime);
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      error({
        __Error_7,
        loc,
        env,
        --[[ Pattern_type_clash ]]Block.__(3, {exn[1]})
      })
    end
     end 
    if (exn[0] == Tags) then do
      error({
        __Error_6,
        loc,
        env,
        --[[ Variant_tags ]]Block.__(12, {
            exn[1],
            exn[2]
          })
      })
    end
     end 
    error(exn)
  end end)
end end

function unify_exp_types(loc, env, ty, expected_ty) do
  xpcall(function() do
    return unify_2(env, ty, expected_ty);
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      error({
        __Error_7,
        loc,
        env,
        --[[ Expr_type_clash ]]Block.__(7, {exn[1]})
      })
    end
     end 
    if (exn[0] == Tags) then do
      error({
        __Error_6,
        loc,
        env,
        --[[ Variant_tags ]]Block.__(12, {
            exn[1],
            exn[2]
          })
      })
    end
     end 
    error(exn)
  end end)
end end

newtype_level_1 = do
  contents: undefined
end;

function get_newtype_level_1(param) do
  match = newtype_level_1.contents;
  if (match ~= undefined) then do
    return match;
  end else do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "typecore.ml",
        331,
        12
      }
    })
  end end 
end end

function unify_pat_types_gadt(loc, env, ty, ty$prime) do
  match = newtype_level_1.contents;
  newtype_level_2;
  if (match ~= undefined) then do
    newtype_level_2 = match;
  end else do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "typecore.ml",
        336,
        14
      }
    })
  end end 
  xpcall(function() do
    lev = newtype_level_2;
    env_1 = env;
    ty1 = ty;
    ty2 = ty$prime;
    xpcall(function() do
      univar_pairs.contents = --[[ [] ]]0;
      newtype_level.contents = lev;
      set_mode_pattern(true, true, (function(param) do
              return unify_1(env_1, ty1, ty2);
            end end));
      newtype_level.contents = undefined;
      return Curry._1(TypePairs.clear, unify_eq_set);
    end end,function(raw_e) do
      e = Caml_js_exceptions.internalToOCamlException(raw_e);
      Curry._1(TypePairs.clear, unify_eq_set);
      if (e[0] == Unify) then do
        error({
          Unify,
          e[1]
        })
      end
       end 
      newtype_level.contents = undefined;
      error(e)
    end end)
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      error({
        __Error_7,
        loc,
        env.contents,
        --[[ Pattern_type_clash ]]Block.__(3, {exn[1]})
      })
    end
     end 
    if (exn[0] == Tags) then do
      error({
        __Error_6,
        loc,
        env.contents,
        --[[ Variant_tags ]]Block.__(12, {
            exn[1],
            exn[2]
          })
      })
    end
     end 
    if (exn[0] == Unification_recursive_abbrev) then do
      error({
        __Error_7,
        loc,
        env.contents,
        --[[ Recursive_local_constraint ]]Block.__(33, {exn[1]})
      })
    end
     end 
    error(exn)
  end end)
end end

function unify_pat(env, pat, expected_ty) do
  return unify_pat_types(pat.pat_loc, env, pat.pat_type, expected_ty);
end end

function finalize_variant(pat) do
  match = pat.pat_desc;
  if (typeof match == "number" or match.tag ~= --[[ Tpat_variant ]]5) then do
    return --[[ () ]]0;
  end else do
    opat = match[1];
    match_1 = expand_head(pat.pat_env, pat.pat_type);
    match_2 = match_1.desc;
    row;
    if (typeof match_2 == "number") then do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "typecore.ml",
          362,
          15
        }
      })
    end else if (match_2.tag == --[[ Tvariant ]]8) then do
      row_1 = match_2[0];
      match[2].contents = row_1;
      row = row_repr_aux(--[[ [] ]]0, row_1);
    end else do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "typecore.ml",
          362,
          15
        }
      })
    end end  end 
    match_3 = row_field(match[0], row);
    if (typeof match_3 == "number" or not match_3.tag) then do
      return --[[ () ]]0;
    end else do
      c = match_3[0];
      if (c) then do
        if (not match_3[1] and not row.row_closed) then do
          return set_row_field(match_3[3], --[[ Rpresent ]]Block.__(0, {undefined}));
        end
         end 
      end else do
        match_4 = match_3[1];
        if (match_4 and not row.row_closed) then do
          ty = match_4[0];
          set_row_field(match_3[3], --[[ Rpresent ]]Block.__(0, {ty}));
          if (opat ~= undefined) then do
            pat_1 = opat;
            partial_arg = pat_1.pat_env;
            return List.iter((function(param) do
                          return unify_pat(partial_arg, pat_1, param);
                        end end), --[[ :: ]]{
                        ty,
                        match_4[1]
                      });
          end else do
            error({
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "typecore.ml",
                370,
                40
              }
            })
          end end 
        end
         end 
      end end 
      if (match_3[2] and not row_fixed(row)) then do
        return set_row_field(match_3[3], --[[ Reither ]]Block.__(1, {
                      c,
                      --[[ [] ]]0,
                      false,
                      do
                        contents: undefined
                      end
                    }));
      end else do
        return --[[ () ]]0;
      end end 
    end end 
  end end 
end end

function iter_pattern(f, p) do
  Curry._1(f, p);
  return iter_pattern_desc((function(param) do
                return iter_pattern(f, param);
              end end), p.pat_desc);
end end

function has_variants(p) do
  xpcall(function() do
    iter_pattern((function(param) do
            tmp = param.pat_desc;
            if (typeof tmp == "number" or tmp.tag ~= --[[ Tpat_variant ]]5) then do
              return --[[ () ]]0;
            end else do
              error(Pervasives.Exit)
            end end 
          end end), p);
    return false;
  end end,function(exn) do
    if (exn == Pervasives.Exit) then do
      return true;
    end else do
      error(exn)
    end end 
  end end)
end end

pattern_variables = do
  contents: --[[ [] ]]0
end;

pattern_force = do
  contents: --[[ [] ]]0
end;

pattern_scope = do
  contents: undefined
end;

allow_modules = do
  contents: false
end;

module_variables = do
  contents: --[[ [] ]]0
end;

function reset_pattern(scope, allow) do
  pattern_variables.contents = --[[ [] ]]0;
  pattern_force.contents = --[[ [] ]]0;
  pattern_scope.contents = scope;
  allow_modules.contents = allow;
  module_variables.contents = --[[ [] ]]0;
  return --[[ () ]]0;
end end

function enter_variable(is_moduleOpt, is_as_variableOpt, loc, name, ty) do
  is_module = is_moduleOpt ~= undefined and is_moduleOpt or false;
  is_as_variable = is_as_variableOpt ~= undefined and is_as_variableOpt or false;
  if (List.exists((function(param) do
            return param[0].name == name.txt;
          end end), pattern_variables.contents)) then do
    error({
      __Error_7,
      loc,
      empty,
      --[[ Multiply_bound_variable ]]Block.__(5, {name.txt})
    })
  end
   end 
  id = create(name.txt);
  pattern_variables.contents = --[[ :: ]]{
    --[[ tuple ]]{
      id,
      ty,
      name,
      loc,
      is_as_variable
    },
    pattern_variables.contents
  };
  if (is_module) then do
    if (not allow_modules.contents) then do
      error({
        __Error_7,
        loc,
        empty,
        --[[ Modules_not_allowed ]]2
      })
    end
     end 
    module_variables.contents = --[[ :: ]]{
      --[[ tuple ]]{
        name,
        loc
      },
      module_variables.contents
    };
  end else do
    may((function(s) do
            return record_2(--[[ An_ident ]]Block.__(5, {
                          name.loc,
                          name.txt,
                          s
                        }));
          end end), pattern_scope.contents);
  end end 
  return id;
end end

function sort_pattern_variables(vs) do
  return List.sort((function(param, param_1) do
                return Caml_primitive.caml_string_compare(param[0].name, param_1[0].name);
              end end), vs);
end end

function enter_orpat_variables(loc, env, p1_vs, p2_vs) do
  p1_vs_1 = sort_pattern_variables(p1_vs);
  p2_vs_1 = sort_pattern_variables(p2_vs);
  unify_vars = function(_p1_vs, _p2_vs) do
    while(true) do
      p2_vs = _p2_vs;
      p1_vs = _p1_vs;
      if (p1_vs) then do
        match = p1_vs[0];
        x1 = match[0];
        if (p2_vs) then do
          rem2 = p2_vs[1];
          match_1 = p2_vs[0];
          x2 = match_1[0];
          rem1 = p1_vs[1];
          if (equal(x1, x2)) then do
            if (x1 == x2) then do
              _p2_vs = rem2;
              _p1_vs = rem1;
              ::continue:: ;
            end else do
              xpcall(function() do
                unify_2(env, match[1], match_1[1]);
              end end,function(raw_exn) do
                exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                if (exn[0] == Unify) then do
                  error({
                    __Error_7,
                    loc,
                    env,
                    --[[ Or_pattern_type_clash ]]Block.__(4, {
                        x1,
                        exn[1]
                      })
                  })
                end
                 end 
                error(exn)
              end end)
              return --[[ :: ]]{
                      --[[ tuple ]]{
                        x2,
                        x1
                      },
                      unify_vars(rem1, rem2)
                    };
            end end 
          end else do
            min_var = x1.name < x2.name and x1 or x2;
            error({
              __Error_7,
              loc,
              env,
              --[[ Orpat_vars ]]Block.__(6, {min_var})
            })
          end end 
        end else do
          error({
            __Error_7,
            loc,
            env,
            --[[ Orpat_vars ]]Block.__(6, {x1})
          })
        end end 
      end else if (p2_vs) then do
        error({
          __Error_7,
          loc,
          env,
          --[[ Orpat_vars ]]Block.__(6, {p2_vs[0][0]})
        })
      end else do
        return --[[ [] ]]0;
      end end  end 
    end;
  end end;
  return unify_vars(p1_vs_1, p2_vs_1);
end end

function build_as_type(env, _p) do
  while(true) do
    p = _p;
    match = p.pat_desc;
    if (typeof match == "number") then do
      return p.pat_type;
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 1--[[ Tpat_alias ]] then do
            _p = match[0];
            ::continue:: ; end end 
         if ___conditional___ == 3--[[ Tpat_tuple ]] then do
            tyl = List.map((function(param) do
                    return build_as_type(env, param);
                  end end), match[0]);
            return newty2(current_level.contents, --[[ Ttuple ]]Block.__(2, {tyl})); end end 
         if ___conditional___ == 4--[[ Tpat_construct ]] then do
            pl = match[2];
            cstr = match[1];
            keep = cstr.cstr_private == --[[ Private ]]0 or cstr.cstr_existentials ~= --[[ [] ]]0;
            if (keep) then do
              return p.pat_type;
            end else do
              tyl_1 = List.map((function(param) do
                      return build_as_type(env, param);
                    end end), pl);
              match_1 = instance_constructor(undefined, cstr);
              List.iter2((function(param) do
                      p = param[0];
                      partial_arg = do
                        pat_desc: p.pat_desc,
                        pat_loc: p.pat_loc,
                        pat_extra: p.pat_extra,
                        pat_type: param[1],
                        pat_env: p.pat_env,
                        pat_attributes: p.pat_attributes
                      end;
                      return (function(param) do
                          return unify_pat(env, partial_arg, param);
                        end end);
                    end end), List.combine(pl, tyl_1), match_1[0]);
              return match_1[1];
            end end  end end 
         if ___conditional___ == 5--[[ Tpat_variant ]] then do
            ty = may_map((function(param) do
                    return build_as_type(env, param);
                  end end), match[1]);
            desc = --[[ Tvariant ]]Block.__(8, {do
                  row_fields: --[[ :: ]]{
                    --[[ tuple ]]{
                      match[0],
                      --[[ Rpresent ]]Block.__(0, {ty})
                    },
                    --[[ [] ]]0
                  },
                  row_more: newvar(undefined, --[[ () ]]0),
                  row_bound: --[[ () ]]0,
                  row_closed: false,
                  row_fixed: false,
                  row_name: undefined
                end});
            return newty2(current_level.contents, desc); end end 
         if ___conditional___ == 6--[[ Tpat_record ]] then do
            lpl = match[0];
            lbl = snd3(List.hd(lpl));
            if (lbl.lbl_private == --[[ Private ]]0) then do
              return p.pat_type;
            end else do
              ty_1 = newvar(undefined, --[[ () ]]0);
              ppl = List.map((function(param) do
                      return --[[ tuple ]]{
                              param[1].lbl_pos,
                              param[2]
                            };
                    end end), lpl);
              do_label = (function(p,ty_1,ppl)do
              return function do_label(lbl) do
                match = instance_label(false, lbl);
                ty_arg = match[1];
                unify_pat(env, do
                      pat_desc: p.pat_desc,
                      pat_loc: p.pat_loc,
                      pat_extra: p.pat_extra,
                      pat_type: ty_1,
                      pat_env: p.pat_env,
                      pat_attributes: p.pat_attributes
                    end, match[2]);
                refinable = false;
                if (lbl.lbl_mut == --[[ Immutable ]]0) then do
                  tmp = false;
                  if (List.mem_assoc(lbl.lbl_pos, ppl)) then do
                    match_1 = repr(lbl.lbl_arg).desc;
                    tmp_1;
                    tmp_1 = typeof match_1 == "number" or match_1.tag ~= --[[ Tpoly ]]10 and true or false;
                    tmp = tmp_1;
                  end
                   end 
                  refinable = tmp;
                end
                 end 
                if (refinable) then do
                  arg = List.assoc(lbl.lbl_pos, ppl);
                  return unify_pat(env, do
                              pat_desc: arg.pat_desc,
                              pat_loc: arg.pat_loc,
                              pat_extra: arg.pat_extra,
                              pat_type: build_as_type(env, arg),
                              pat_env: arg.pat_env,
                              pat_attributes: arg.pat_attributes
                            end, ty_arg);
                end else do
                  match_2 = instance_label(false, lbl);
                  unify_2(env, ty_arg, match_2[1]);
                  return unify_pat(env, p, match_2[2]);
                end end 
              end end
              end end)(p,ty_1,ppl);
              __Array.iter(do_label, lbl.lbl_all);
              return ty_1;
            end end  end end 
         if ___conditional___ == 8--[[ Tpat_or ]] then do
            row = match[2];
            p2 = match[1];
            if (row ~= undefined) then do
              row_1 = row_repr_aux(--[[ [] ]]0, row);
              desc_1 = --[[ Tvariant ]]Block.__(8, {do
                    row_fields: row_1.row_fields,
                    row_more: newvar(undefined, --[[ () ]]0),
                    row_bound: row_1.row_bound,
                    row_closed: false,
                    row_fixed: row_1.row_fixed,
                    row_name: row_1.row_name
                  end});
              return newty2(current_level.contents, desc_1);
            end else do
              ty1 = build_as_type(env, match[0]);
              ty2 = build_as_type(env, p2);
              unify_pat(env, do
                    pat_desc: p2.pat_desc,
                    pat_loc: p2.pat_loc,
                    pat_extra: p2.pat_extra,
                    pat_type: ty2,
                    pat_env: p2.pat_env,
                    pat_attributes: p2.pat_attributes
                  end, ty1);
              return ty1;
            end end  end end 
        return p.pat_type;
          
      end
    end end 
  end;
end end

function build_or_pat(env, loc, lid) do
  match = find_type(env, loc, lid);
  path = match[0];
  tyl = List.map((function(param) do
          return newvar(undefined, --[[ () ]]0);
        end end), match[1].type_params);
  ty = expand_head(env, newty2(current_level.contents, --[[ Tconstr ]]Block.__(3, {
              path,
              tyl,
              do
                contents: --[[ Mnil ]]0
              end
            })));
  match_1 = ty.desc;
  row0;
  exit = 0;
  if (typeof match_1 == "number" or match_1.tag ~= --[[ Tvariant ]]8) then do
    exit = 1;
  end else do
    row = match_1[0];
    if (static_row(row)) then do
      row0 = row;
    end else do
      exit = 1;
    end end 
  end end 
  if (exit == 1) then do
    error({
      __Error_7,
      loc,
      env,
      --[[ Not_a_variant_type ]]Block.__(30, {lid})
    })
  end
   end 
  match_2 = List.fold_left((function(param, param_1) do
          l = param_1[0];
          fields = param[1];
          pats = param[0];
          match = row_field_repr_aux(--[[ [] ]]0, param_1[1]);
          if (typeof match == "number" or match.tag) then do
            return --[[ tuple ]]{
                    pats,
                    fields
                  };
          end else do
            match_1 = match[0];
            if (match_1 ~= undefined) then do
              ty = match_1;
              return --[[ tuple ]]{
                      --[[ :: ]]{
                        --[[ tuple ]]{
                          l,
                          do
                            pat_desc: --[[ Tpat_any ]]0,
                            pat_loc: none,
                            pat_extra: --[[ [] ]]0,
                            pat_type: ty,
                            pat_env: env,
                            pat_attributes: --[[ [] ]]0
                          end
                        },
                        pats
                      },
                      --[[ :: ]]{
                        --[[ tuple ]]{
                          l,
                          --[[ Reither ]]Block.__(1, {
                              false,
                              --[[ :: ]]{
                                ty,
                                --[[ [] ]]0
                              },
                              true,
                              do
                                contents: undefined
                              end
                            })
                        },
                        fields
                      }
                    };
            end else do
              return --[[ tuple ]]{
                      --[[ :: ]]{
                        --[[ tuple ]]{
                          l,
                          undefined
                        },
                        pats
                      },
                      --[[ :: ]]{
                        --[[ tuple ]]{
                          l,
                          --[[ Reither ]]Block.__(1, {
                              true,
                              --[[ [] ]]0,
                              true,
                              do
                                contents: undefined
                              end
                            })
                        },
                        fields
                      }
                    };
            end end 
          end end 
        end end), --[[ tuple ]]{
        --[[ [] ]]0,
        --[[ [] ]]0
      }, row_repr_aux(--[[ [] ]]0, row0).row_fields);
  row_row_fields = List.rev(match_2[1]);
  row_row_more = newvar(undefined, --[[ () ]]0);
  row_row_name = --[[ tuple ]]{
    path,
    tyl
  };
  row_1 = do
    row_fields: row_row_fields,
    row_more: row_row_more,
    row_bound: --[[ () ]]0,
    row_closed: false,
    row_fixed: false,
    row_name: row_row_name
  end;
  ty_1 = newty2(current_level.contents, --[[ Tvariant ]]Block.__(8, {row_1}));
  gloc_loc_start = loc.loc_start;
  gloc_loc_end = loc.loc_end;
  gloc = do
    loc_start: gloc_loc_start,
    loc_end: gloc_loc_end,
    loc_ghost: true
  end;
  row$prime = do
    contents: do
      row_fields: row_row_fields,
      row_more: newvar(undefined, --[[ () ]]0),
      row_bound: --[[ () ]]0,
      row_closed: false,
      row_fixed: false,
      row_name: row_row_name
    end
  end;
  pats = List.map((function(param) do
          return do
                  pat_desc: --[[ Tpat_variant ]]Block.__(5, {
                      param[0],
                      param[1],
                      row$prime
                    }),
                  pat_loc: gloc,
                  pat_extra: --[[ [] ]]0,
                  pat_type: ty_1,
                  pat_env: env,
                  pat_attributes: --[[ [] ]]0
                end;
        end end), match_2[0]);
  if (pats) then do
    r = List.fold_left((function(pat, pat0) do
            return do
                    pat_desc: --[[ Tpat_or ]]Block.__(8, {
                        pat0,
                        pat,
                        row0
                      }),
                    pat_loc: gloc,
                    pat_extra: --[[ [] ]]0,
                    pat_type: ty_1,
                    pat_env: env,
                    pat_attributes: --[[ [] ]]0
                  end;
          end end), pats[0], pats[1]);
    return --[[ tuple ]]{
            path,
            rp(do
                  pat_desc: r.pat_desc,
                  pat_loc: loc,
                  pat_extra: r.pat_extra,
                  pat_type: r.pat_type,
                  pat_env: r.pat_env,
                  pat_attributes: r.pat_attributes
                end),
            ty_1
          };
  end else do
    error({
      __Error_7,
      loc,
      env,
      --[[ Not_a_variant_type ]]Block.__(30, {lid})
    })
  end end 
end end

function expand_path(env, _p) do
  while(true) do
    p = _p;
    decl;
    xpcall(function() do
      decl = find_type_full(p, env)[0];
    end end,function(exn) do
      if (exn == Caml_builtin_exceptions.not_found) then do
        decl = undefined;
      end else do
        error(exn)
      end end 
    end end)
    if (decl ~= undefined) then do
      match = decl.type_manifest;
      if (match ~= undefined) then do
        match_1 = repr(match);
        match_2 = match_1.desc;
        if (typeof match_2 == "number" or match_2.tag ~= --[[ Tconstr ]]3) then do
          return p;
        end else do
          _p = match_2[0];
          ::continue:: ;
        end end 
      end
       end 
    end
     end 
    p$prime = normalize_path_1(undefined, env, p);
    if (same(p, p$prime)) then do
      return p;
    end else do
      _p = p$prime;
      ::continue:: ;
    end end 
  end;
end end

function compare_type_path(env, tpath1, tpath2) do
  return same(expand_path(env, tpath1), expand_path(env, tpath2));
end end

function wrap_disambiguate(kind, ty, f, x) do
  xpcall(function() do
    return Curry._1(f, x);
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == __Error_7) then do
      match = exn[3];
      if (typeof match == "number") then do
        error(exn)
      end else if (match.tag == --[[ Wrong_name ]]13) then do
        error({
          __Error_7,
          exn[1],
          exn[2],
          --[[ Wrong_name ]]Block.__(13, {
              kind,
              ty,
              match[2],
              match[3],
              match[4]
            })
        })
      end else do
        error(exn)
      end end  end 
    end else do
      error(exn)
    end end 
  end end)
end end

type_kind = "record";

function get_type_path_1(env, d) do
  match = d.lbl_res.desc;
  if (typeof match == "number") then do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "typecore.ml",
        602,
        11
      }
    })
  end else if (match.tag == --[[ Tconstr ]]3) then do
    return match[0];
  end else do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "typecore.ml",
        602,
        11
      }
    })
  end end  end 
end end

function lookup_from_type(env, tpath, lid) do
  descrs = find_type_full(tpath, env)[1][1];
  mark_type_used(env, last(tpath), find_type_full(tpath, env)[0]);
  match = lid.txt;
  local ___conditional___=(match.tag | 0);
  do
     if ___conditional___ == 0--[[ Lident ]] then do
        s = match[0];
        xpcall(function() do
          return List.find((function(nd) do
                        return nd.lbl_name == s;
                      end end), descrs);
        end end,function(exn) do
          if (exn == Caml_builtin_exceptions.not_found) then do
            error({
              __Error_7,
              lid.loc,
              env,
              --[[ Wrong_name ]]Block.__(13, {
                  "",
                  newvar(undefined, --[[ () ]]0),
                  type_kind,
                  tpath,
                  lid.txt
                })
            })
          end
           end 
          error(exn)
        end end) end end 
     if ___conditional___ == 1--[[ Ldot ]]
     or ___conditional___ == 2--[[ Lapply ]] then do
        error(Caml_builtin_exceptions.not_found) end end 
    
  end
end end

function unique(eq, _acc, _param) do
  while(true) do
    param = _param;
    acc = _acc;
    if (param) then do
      rem = param[1];
      x = param[0];
      if (List.exists(Curry._1(eq, x), acc)) then do
        _param = rem;
        ::continue:: ;
      end else do
        _param = rem;
        _acc = --[[ :: ]]{
          x,
          acc
        };
        ::continue:: ;
      end end 
    end else do
      return List.rev(acc);
    end end 
  end;
end end

function ambiguous_types(env, lbl, others) do
  tpath = get_type_path_1(env, lbl);
  others_1 = List.map((function(param) do
          return get_type_path_1(env, param[0]);
        end end), others);
  tpaths = unique((function(param, param_1) do
          return compare_type_path(env, param, param_1);
        end end), --[[ :: ]]{
        tpath,
        --[[ [] ]]0
      }, others_1);
  if (tpaths and not tpaths[1]) then do
    return --[[ [] ]]0;
  end else do
    return List.map(string_of_path, tpaths);
  end end 
end end

function disambiguate_by_type(env, tpath, lbls) do
  check_type = function(param) do
    lbl_tpath = get_type_path_1(env, param[0]);
    return compare_type_path(env, tpath, lbl_tpath);
  end end;
  return List.find(check_type, lbls);
end end

function disambiguate(warnOpt, check_lkOpt, scope, lid, env, opath, lbls) do
  warn = warnOpt ~= undefined and warnOpt or prerr_warning;
  check_lk = check_lkOpt ~= undefined and check_lkOpt or (function(param, param_1) do
        return --[[ () ]]0;
      end end);
  scope_1 = scope ~= undefined and scope or lbls;
  lbl;
  if (opath ~= undefined) then do
    match = opath;
    pr = match[2];
    tpath = match[1];
    warn_pr = function(param) do
      kind = type_kind == "record" and "field" or "constructor";
      return Curry._2(warn, lid.loc, --[[ Not_principal ]]Block.__(8, {"this type-based " .. (kind .. " disambiguation")}));
    end end;
    xpcall(function() do
      match_1 = disambiguate_by_type(env, tpath, scope_1);
      lbl_1 = match_1[0];
      Curry._1(match_1[1], --[[ () ]]0);
      if (not pr) then do
        if (lbls) then do
          lbl_tpath = get_type_path_1(env, lbls[0][0]);
          if (compare_type_path(env, tpath, lbl_tpath)) then do
            paths = ambiguous_types(env, lbl_1, lbls[1]);
            if (paths ~= --[[ [] ]]0) then do
              Curry._2(warn, lid.loc, --[[ Ambiguous_name ]]Block.__(24, {
                      --[[ :: ]]{
                        last_1(lid.txt),
                        --[[ [] ]]0
                      },
                      paths,
                      false
                    }));
            end
             end 
          end else do
            warn_pr(--[[ () ]]0);
          end end 
        end else do
          warn_pr(--[[ () ]]0);
        end end 
      end
       end 
      lbl = lbl_1;
    end end,function(exn) do
      if (exn == Caml_builtin_exceptions.not_found) then do
        xpcall(function() do
          lbl_2 = lookup_from_type(env, tpath, lid);
          Curry._2(check_lk, tpath, lbl_2);
          s = string_of_out_ident(tree_of_path(tpath));
          Curry._2(warn, lid.loc, --[[ Name_out_of_scope ]]Block.__(23, {
                  s,
                  --[[ :: ]]{
                    last_1(lid.txt),
                    --[[ [] ]]0
                  },
                  false
                }));
          if (not pr) then do
            warn_pr(--[[ () ]]0);
          end
           end 
          lbl = lbl_2;
        end end,function(exn_1) do
          if (exn_1 == Caml_builtin_exceptions.not_found) then do
            if (lbls == --[[ [] ]]0) then do
              lbl = unbound_label_error(env, lid);
            end else do
              tp_000 = match[0];
              tp_001 = expand_path(env, tpath);
              tp = --[[ tuple ]]{
                tp_000,
                tp_001
              };
              tpl = List.map((function(param) do
                      tp0 = get_type_path_1(env, param[0]);
                      tp = expand_path(env, tp0);
                      return --[[ tuple ]]{
                              tp0,
                              tp
                            };
                    end end), lbls);
              error({
                __Error_7,
                lid.loc,
                env,
                --[[ Name_type_mismatch ]]Block.__(14, {
                    type_kind,
                    lid.txt,
                    tp,
                    tpl
                  })
              })
            end end 
          end else do
            error(exn_1)
          end end 
        end end)
      end else do
        error(exn)
      end end 
    end end)
  end else if (lbls) then do
    match_2 = lbls[0];
    lbl_3 = match_2[0];
    Curry._1(match_2[1], --[[ () ]]0);
    paths_1 = ambiguous_types(env, lbl_3, lbls[1]);
    if (paths_1 ~= --[[ [] ]]0) then do
      Curry._2(warn, lid.loc, --[[ Ambiguous_name ]]Block.__(24, {
              --[[ :: ]]{
                last_1(lid.txt),
                --[[ [] ]]0
              },
              paths_1,
              false
            }));
    end
     end 
    lbl = lbl_3;
  end else do
    lbl = unbound_label_error(env, lid);
  end end  end 
  if (scope_1 and scope_1[0][0] == lbl) then do
    
  end else do
    prerr_warning(lid.loc, --[[ Disambiguated_name ]]Block.__(25, {lbl.lbl_name}));
  end end 
  return lbl;
end end

function disambiguate_label_by_ids(keep, env, closed, ids, labels) do
  check_ids = function(param) do
    lbls = Hashtbl.create(undefined, 8);
    __Array.iter((function(lbl) do
            return Hashtbl.add(lbls, lbl.lbl_name, --[[ () ]]0);
          end end), param[0].lbl_all);
    return List.for_all((function(param) do
                  return Hashtbl.mem(lbls, param);
                end end), ids);
  end end;
  check_closed = function(param) do
    if (closed) then do
      return List.length(ids) == #param[0].lbl_all;
    end else do
      return true;
    end end 
  end end;
  labels$prime = List.filter(check_ids)(labels);
  if (keep and labels$prime == --[[ [] ]]0) then do
    return --[[ tuple ]]{
            false,
            labels
          };
  end else do
    labels$prime$prime = List.filter(check_closed)(labels$prime);
    if (keep and labels$prime$prime == --[[ [] ]]0) then do
      return --[[ tuple ]]{
              false,
              labels$prime
            };
    end else do
      return --[[ tuple ]]{
              true,
              labels$prime$prime
            };
    end end 
  end end 
end end

function disambiguate_lid_a_list(loc, closed, env, opath, lid_a_list) do
  ids = List.map((function(param) do
          return last_1(param[0].txt);
        end end), lid_a_list);
  w_pr = do
    contents: false
  end;
  w_amb = do
    contents: --[[ [] ]]0
  end;
  w_scope = do
    contents: --[[ [] ]]0
  end;
  w_scope_ty = do
    contents: ""
  end;
  warn = function(loc, msg) do
    if (typeof msg == "number") then do
      return prerr_warning(loc, msg);
    end else do
      local ___conditional___=(msg.tag | 0);
      do
         if ___conditional___ == 8--[[ Not_principal ]] then do
            w_pr.contents = true;
            return --[[ () ]]0; end end 
         if ___conditional___ == 23--[[ Name_out_of_scope ]] then do
            match = msg[1];
            if (match and not match[1]) then do
              w_scope.contents = --[[ :: ]]{
                match[0],
                w_scope.contents
              };
              w_scope_ty.contents = msg[0];
              return --[[ () ]]0;
            end else do
              return prerr_warning(loc, msg);
            end end  end end 
         if ___conditional___ == 24--[[ Ambiguous_name ]] then do
            match_1 = msg[0];
            if (match_1 and not match_1[1]) then do
              w_amb.contents = --[[ :: ]]{
                --[[ tuple ]]{
                  match_1[0],
                  msg[1]
                },
                w_amb.contents
              };
              return --[[ () ]]0;
            end else do
              return prerr_warning(loc, msg);
            end end  end end 
        return prerr_warning(loc, msg);
          
      end
    end end 
  end end;
  process_label = function(lid) do
    scope = find_all_labels(env, lid.loc, lid.txt);
    if (opath == undefined and scope == --[[ [] ]]0) then do
      unbound_label_error(env, lid);
    end
     end 
    match;
    exit = 0;
    if (opath ~= undefined and opath[2]) then do
      match = --[[ tuple ]]{
        true,
        scope
      };
    end else do
      exit = 1;
    end end 
    if (exit == 1) then do
      match = disambiguate_label_by_ids(opath == undefined, env, closed, ids, scope);
    end
     end 
    labels = match[1];
    if (match[0]) then do
      return disambiguate(warn, undefined, scope, lid, env, opath, labels);
    end else do
      return List.hd(labels)[0];
    end end 
  end end;
  lbl_a_list = List.map((function(param) do
          lid = param[0];
          return --[[ tuple ]]{
                  lid,
                  process_label(lid),
                  param[1]
                };
        end end), lid_a_list);
  if (w_pr.contents) then do
    prerr_warning(loc, --[[ Not_principal ]]Block.__(8, {"this type-based record disambiguation"}));
  end else do
    amb = List.rev(w_amb.contents);
    if (amb) then do
      paths = List.map((function(param) do
              return get_type_path_1(env, param[1]);
            end end), lbl_a_list);
      path = List.hd(paths);
      if (List.for_all((function(param) do
                return compare_type_path(env, path, param);
              end end), List.tl(paths))) then do
        prerr_warning(loc, --[[ Ambiguous_name ]]Block.__(24, {
                List.map((function(prim) do
                        return prim[0];
                      end end), amb),
                amb[0][1],
                true
              }));
      end else do
        List.iter((function(param) do
                return prerr_warning(loc, --[[ Ambiguous_name ]]Block.__(24, {
                              --[[ :: ]]{
                                param[0],
                                --[[ [] ]]0
                              },
                              param[1],
                              false
                            }));
              end end), amb);
      end end 
    end
     end 
  end end 
  if (w_scope.contents ~= --[[ [] ]]0) then do
    prerr_warning(loc, --[[ Name_out_of_scope ]]Block.__(23, {
            w_scope_ty.contents,
            List.rev(w_scope.contents),
            true
          }));
  end
   end 
  return lbl_a_list;
end end

function find_record_qual(_param) do
  while(true) do
    param = _param;
    if (param) then do
      match = param[0][0].txt;
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 1--[[ Ldot ]] then do
            return match[0]; end end 
         if ___conditional___ == 0--[[ Lident ]]
         or ___conditional___ == 2--[[ Lapply ]] then do
            _param = param[1];
            ::continue:: ; end end 
        
      end
    end else do
      return ;
    end end 
  end;
end end

function type_label_a_list(labels, loc, closed, env, type_lbl_a, opath, lid_a_list) do
  lbl_a_list;
  exit = 0;
  if (lid_a_list) then do
    match = lid_a_list[0][0].txt;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 0--[[ Lident ]] then do
          if (labels ~= undefined) then do
            labels_1 = Caml_option.valFromOption(labels);
            if (Hashtbl.mem(labels_1, match[0])) then do
              lbl_a_list = List.map((function(param) do
                      lid = param[0];
                      match = lid.txt;
                      local ___conditional___=(match.tag | 0);
                      do
                         if ___conditional___ == 0--[[ Lident ]] then do
                            return --[[ tuple ]]{
                                    lid,
                                    Hashtbl.find(labels_1, match[0]),
                                    param[1]
                                  }; end end 
                         if ___conditional___ == 1--[[ Ldot ]]
                         or ___conditional___ == 2--[[ Lapply ]] then do
                            error({
                              Caml_builtin_exceptions.assert_failure,
                              --[[ tuple ]]{
                                "typecore.ml",
                                819,
                                17
                              }
                            }) end end 
                        
                      end
                    end end), lid_a_list);
            end else do
              exit = 1;
            end end 
          end else do
            exit = 1;
          end end  end else 
       if ___conditional___ == 1--[[ Ldot ]]
       or ___conditional___ == 2--[[ Lapply ]] then do
          exit = 1; end else 
       end end end end
      
    end
  end else do
    exit = 1;
  end end 
  if (exit == 1) then do
    match_1 = find_record_qual(lid_a_list);
    lid_a_list_1;
    if (match_1 ~= undefined) then do
      modname = match_1;
      lid_a_list_1 = List.map((function(lid_a) do
              lid = lid_a[0];
              match = lid.txt;
              local ___conditional___=(match.tag | 0);
              do
                 if ___conditional___ == 0--[[ Lident ]] then do
                    return --[[ tuple ]]{
                            do
                              txt: --[[ Ldot ]]Block.__(1, {
                                  modname,
                                  match[0]
                                }),
                              loc: lid.loc
                            end,
                            lid_a[1]
                          }; end end 
                 if ___conditional___ == 1--[[ Ldot ]]
                 or ___conditional___ == 2--[[ Lapply ]] then do
                    return lid_a; end end 
                
              end
            end end), lid_a_list);
    end else do
      lid_a_list_1 = lid_a_list;
    end end 
    lbl_a_list = disambiguate_lid_a_list(loc, closed, env, opath, lid_a_list_1);
  end
   end 
  lbl_a_list_1 = List.sort((function(param, param_1) do
          return Caml_primitive.caml_int_compare(param[1].lbl_pos, param_1[1].lbl_pos);
        end end), lbl_a_list);
  return List.map(type_lbl_a, lbl_a_list_1);
end end

function check_recordpat_labels(loc, lbl_pat_list, closed) do
  if (lbl_pat_list) then do
    all = lbl_pat_list[0][1].lbl_all;
    defined = Caml_array.caml_make_vect(#all, false);
    check_defined = function(param) do
      label = param[1];
      if (Caml_array.caml_array_get(defined, label.lbl_pos)) then do
        error({
          __Error_7,
          loc,
          empty,
          --[[ Label_multiply_defined ]]Block.__(10, {label.lbl_name})
        })
      end
       end 
      return Caml_array.caml_array_set(defined, label.lbl_pos, true);
    end end;
    List.iter(check_defined, lbl_pat_list);
    if (closed == --[[ Closed ]]0 and is_active(--[[ Non_closed_record_pattern ]]Block.__(4, {""}))) then do
      __undefined = --[[ [] ]]0;
      for i = 0 , #all - 1 | 0 , 1 do
        if (not Caml_array.caml_array_get(defined, i)) then do
          __undefined = --[[ :: ]]{
            Caml_array.caml_array_get(all, i).lbl_name,
            __undefined
          };
        end
         end 
      end
      if (__undefined ~= --[[ [] ]]0) then do
        u = __String.concat(", ", List.rev(__undefined));
        return prerr_warning(loc, --[[ Non_closed_record_pattern ]]Block.__(4, {u}));
      end else do
        return 0;
      end end 
    end else do
      return 0;
    end end 
  end else do
    return --[[ () ]]0;
  end end 
end end

type_kind_1 = "variant";

function get_type_path_2(env, d) do
  match = d.cstr_res.desc;
  if (typeof match == "number") then do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "typecore.ml",
        602,
        11
      }
    })
  end else if (match.tag == --[[ Tconstr ]]3) then do
    return match[0];
  end else do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "typecore.ml",
        602,
        11
      }
    })
  end end  end 
end end

function lookup_from_type_1(env, tpath, lid) do
  descrs = find_type_full(tpath, env)[1][0];
  mark_type_used(env, last(tpath), find_type_full(tpath, env)[0]);
  match = lid.txt;
  local ___conditional___=(match.tag | 0);
  do
     if ___conditional___ == 0--[[ Lident ]] then do
        s = match[0];
        xpcall(function() do
          return List.find((function(nd) do
                        return nd.cstr_name == s;
                      end end), descrs);
        end end,function(exn) do
          if (exn == Caml_builtin_exceptions.not_found) then do
            error({
              __Error_7,
              lid.loc,
              env,
              --[[ Wrong_name ]]Block.__(13, {
                  "",
                  newvar(undefined, --[[ () ]]0),
                  type_kind_1,
                  tpath,
                  lid.txt
                })
            })
          end
           end 
          error(exn)
        end end) end end 
     if ___conditional___ == 1--[[ Ldot ]]
     or ___conditional___ == 2--[[ Lapply ]] then do
        error(Caml_builtin_exceptions.not_found) end end 
    
  end
end end

function unique_1(eq, _acc, _param) do
  while(true) do
    param = _param;
    acc = _acc;
    if (param) then do
      rem = param[1];
      x = param[0];
      if (List.exists(Curry._1(eq, x), acc)) then do
        _param = rem;
        ::continue:: ;
      end else do
        _param = rem;
        _acc = --[[ :: ]]{
          x,
          acc
        };
        ::continue:: ;
      end end 
    end else do
      return List.rev(acc);
    end end 
  end;
end end

function ambiguous_types_1(env, lbl, others) do
  tpath = get_type_path_2(env, lbl);
  others_1 = List.map((function(param) do
          return get_type_path_2(env, param[0]);
        end end), others);
  tpaths = unique_1((function(param, param_1) do
          return compare_type_path(env, param, param_1);
        end end), --[[ :: ]]{
        tpath,
        --[[ [] ]]0
      }, others_1);
  if (tpaths and not tpaths[1]) then do
    return --[[ [] ]]0;
  end else do
    return List.map(string_of_path, tpaths);
  end end 
end end

function disambiguate_by_type_1(env, tpath, lbls) do
  check_type = function(param) do
    lbl_tpath = get_type_path_2(env, param[0]);
    return compare_type_path(env, tpath, lbl_tpath);
  end end;
  return List.find(check_type, lbls);
end end

function disambiguate_1(warnOpt, check_lkOpt, scope, lid, env, opath, lbls) do
  warn = warnOpt ~= undefined and warnOpt or prerr_warning;
  check_lk = check_lkOpt ~= undefined and check_lkOpt or (function(param, param_1) do
        return --[[ () ]]0;
      end end);
  scope_1 = scope ~= undefined and scope or lbls;
  lbl;
  if (opath ~= undefined) then do
    match = opath;
    pr = match[2];
    tpath = match[1];
    warn_pr = function(param) do
      kind = type_kind_1 == "record" and "field" or "constructor";
      return Curry._2(warn, lid.loc, --[[ Not_principal ]]Block.__(8, {"this type-based " .. (kind .. " disambiguation")}));
    end end;
    xpcall(function() do
      match_1 = disambiguate_by_type_1(env, tpath, scope_1);
      lbl_1 = match_1[0];
      Curry._1(match_1[1], --[[ () ]]0);
      if (not pr) then do
        if (lbls) then do
          lbl_tpath = get_type_path_2(env, lbls[0][0]);
          if (compare_type_path(env, tpath, lbl_tpath)) then do
            paths = ambiguous_types_1(env, lbl_1, lbls[1]);
            if (paths ~= --[[ [] ]]0) then do
              Curry._2(warn, lid.loc, --[[ Ambiguous_name ]]Block.__(24, {
                      --[[ :: ]]{
                        last_1(lid.txt),
                        --[[ [] ]]0
                      },
                      paths,
                      false
                    }));
            end
             end 
          end else do
            warn_pr(--[[ () ]]0);
          end end 
        end else do
          warn_pr(--[[ () ]]0);
        end end 
      end
       end 
      lbl = lbl_1;
    end end,function(exn) do
      if (exn == Caml_builtin_exceptions.not_found) then do
        xpcall(function() do
          lbl_2 = lookup_from_type_1(env, tpath, lid);
          Curry._2(check_lk, tpath, lbl_2);
          s = string_of_out_ident(tree_of_path(tpath));
          Curry._2(warn, lid.loc, --[[ Name_out_of_scope ]]Block.__(23, {
                  s,
                  --[[ :: ]]{
                    last_1(lid.txt),
                    --[[ [] ]]0
                  },
                  false
                }));
          if (not pr) then do
            warn_pr(--[[ () ]]0);
          end
           end 
          lbl = lbl_2;
        end end,function(exn_1) do
          if (exn_1 == Caml_builtin_exceptions.not_found) then do
            if (lbls == --[[ [] ]]0) then do
              lbl = unbound_constructor_error(env, lid);
            end else do
              tp_000 = match[0];
              tp_001 = expand_path(env, tpath);
              tp = --[[ tuple ]]{
                tp_000,
                tp_001
              };
              tpl = List.map((function(param) do
                      tp0 = get_type_path_2(env, param[0]);
                      tp = expand_path(env, tp0);
                      return --[[ tuple ]]{
                              tp0,
                              tp
                            };
                    end end), lbls);
              error({
                __Error_7,
                lid.loc,
                env,
                --[[ Name_type_mismatch ]]Block.__(14, {
                    type_kind_1,
                    lid.txt,
                    tp,
                    tpl
                  })
              })
            end end 
          end else do
            error(exn_1)
          end end 
        end end)
      end else do
        error(exn)
      end end 
    end end)
  end else if (lbls) then do
    match_2 = lbls[0];
    lbl_3 = match_2[0];
    Curry._1(match_2[1], --[[ () ]]0);
    paths_1 = ambiguous_types_1(env, lbl_3, lbls[1]);
    if (paths_1 ~= --[[ [] ]]0) then do
      Curry._2(warn, lid.loc, --[[ Ambiguous_name ]]Block.__(24, {
              --[[ :: ]]{
                last_1(lid.txt),
                --[[ [] ]]0
              },
              paths_1,
              false
            }));
    end
     end 
    lbl = lbl_3;
  end else do
    lbl = unbound_constructor_error(env, lid);
  end end  end 
  if (scope_1 and scope_1[0][0] == lbl) then do
    
  end else do
    prerr_warning(lid.loc, --[[ Disambiguated_name ]]Block.__(25, {lbl.cstr_name}));
  end end 
  return lbl;
end end

function unify_head_only(loc, env, ty, constr) do
  match = instance_constructor(undefined, constr);
  ty_res = match[1];
  match_1 = repr(ty_res).desc;
  if (typeof match_1 == "number") then do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "typecore.ml",
        892,
        9
      }
    })
  end else if (match_1.tag == --[[ Tconstr ]]3) then do
    ty_res.desc = --[[ Tconstr ]]Block.__(3, {
        match_1[0],
        List.map((function(param) do
                return newvar(undefined, --[[ () ]]0);
              end end), match_1[1]),
        match_1[2]
      });
    enforce_constraints(env, ty_res);
    return unify_pat_types(loc, env, ty_res, ty);
  end else do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "typecore.ml",
        892,
        9
      }
    })
  end end  end 
end end

function type_pat(constrs, labels, no_existentials, mode, env, sp, expected_ty) do
  type_pat_1 = function(modeOpt, envOpt) do
    mode_1 = modeOpt ~= undefined and modeOpt or mode;
    env_1 = envOpt ~= undefined and envOpt or env;
    return (function(param, param_1) do
        return type_pat(constrs, labels, no_existentials, mode_1, env_1, param, param_1);
      end end);
  end end;
  loc = sp.ppat_loc;
  match = sp.ppat_desc;
  if (typeof match == "number") then do
    return rp(do
                pat_desc: --[[ Tpat_any ]]0,
                pat_loc: loc,
                pat_extra: --[[ [] ]]0,
                pat_type: expected_ty,
                pat_env: env.contents,
                pat_attributes: sp.ppat_attributes
              end);
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 0--[[ Ppat_var ]] then do
          name = match[0];
          id = enter_variable(undefined, undefined, loc, name, expected_ty);
          return rp(do
                      pat_desc: --[[ Tpat_var ]]Block.__(0, {
                          id,
                          name
                        }),
                      pat_loc: loc,
                      pat_extra: --[[ [] ]]0,
                      pat_type: expected_ty,
                      pat_env: env.contents,
                      pat_attributes: sp.ppat_attributes
                    end); end end 
       if ___conditional___ == 1--[[ Ppat_alias ]] then do
          name_1 = match[1];
          q = type_pat_1(undefined, undefined)(match[0], expected_ty);
          begin_def(--[[ () ]]0);
          ty_var = build_as_type(env.contents, q);
          end_def(--[[ () ]]0);
          iter_generalize_1(do
                contents: --[[ [] ]]0
              end, ty_var);
          id_1 = enter_variable(undefined, true, loc, name_1, ty_var);
          return rp(do
                      pat_desc: --[[ Tpat_alias ]]Block.__(1, {
                          q,
                          id_1,
                          name_1
                        }),
                      pat_loc: loc,
                      pat_extra: --[[ [] ]]0,
                      pat_type: q.pat_type,
                      pat_env: env.contents,
                      pat_attributes: sp.ppat_attributes
                    end); end end 
       if ___conditional___ == 2--[[ Ppat_constant ]] then do
          cst = match[0];
          unify_pat_types(loc, env.contents, type_constant(cst), expected_ty);
          return rp(do
                      pat_desc: --[[ Tpat_constant ]]Block.__(2, {cst}),
                      pat_loc: loc,
                      pat_extra: --[[ [] ]]0,
                      pat_type: expected_ty,
                      pat_env: env.contents,
                      pat_attributes: sp.ppat_attributes
                    end); end end 
       if ___conditional___ == 3--[[ Ppat_interval ]] then do
          match_1 = match[0];
          if (match_1.tag == --[[ Const_char ]]1) then do
            match_2 = match[1];
            if (match_2.tag == --[[ Const_char ]]1) then do
              c2 = match_2[0];
              c1 = match_1[0];
              gloc_loc_start = loc.loc_start;
              gloc_loc_end = loc.loc_end;
              gloc = do
                loc_start: gloc_loc_start,
                loc_end: gloc_loc_end,
                loc_ghost: true
              end;
              loop = function(c1, c2) do
                if (c1 == c2) then do
                  return constant(gloc, undefined, --[[ Const_char ]]Block.__(1, {c1}));
                end else do
                  return or_(gloc, undefined, constant(gloc, undefined, --[[ Const_char ]]Block.__(1, {c1})), loop(Char.chr(c1 + 1 | 0), c2));
                end end 
              end end;
              p = c1 <= c2 and loop(c1, c2) or loop(c2, c1);
              p_ppat_desc = p.ppat_desc;
              p_ppat_attributes = p.ppat_attributes;
              p_1 = do
                ppat_desc: p_ppat_desc,
                ppat_loc: loc,
                ppat_attributes: p_ppat_attributes
              end;
              return type_pat_1(undefined, undefined)(p_1, expected_ty);
            end else do
              error({
                __Error_7,
                loc,
                env.contents,
                --[[ Invalid_interval ]]5
              })
            end end 
          end else do
            error({
              __Error_7,
              loc,
              env.contents,
              --[[ Invalid_interval ]]5
            })
          end end  end end 
       if ___conditional___ == 4--[[ Ppat_tuple ]] then do
          spl = match[0];
          if (List.length(spl) < 2) then do
            ill_formed_ast(loc, "Tuples must have at least 2 components.");
          end
           end 
          spl_ann = List.map((function(p) do
                  return --[[ tuple ]]{
                          p,
                          newvar(undefined, --[[ () ]]0)
                        };
                end end), spl);
          desc = --[[ Ttuple ]]Block.__(2, {List.map((function(prim) do
                      return prim[1];
                    end end), spl_ann)});
          ty = newty2(current_level.contents, desc);
          unify_pat_types(loc, env.contents, ty, expected_ty);
          pl = List.map((function(param) do
                  return type_pat_1(undefined, undefined)(param[0], param[1]);
                end end), spl_ann);
          return rp(do
                      pat_desc: --[[ Tpat_tuple ]]Block.__(3, {pl}),
                      pat_loc: loc,
                      pat_extra: --[[ [] ]]0,
                      pat_type: expected_ty,
                      pat_env: env.contents,
                      pat_attributes: sp.ppat_attributes
                    end); end end 
       if ___conditional___ == 5--[[ Ppat_construct ]] then do
          sarg = match[1];
          lid = match[0];
          opath;
          xpcall(function() do
            match_3 = extract_concrete_variant(env.contents, expected_ty);
            opath = --[[ tuple ]]{
              match_3[0],
              match_3[1],
              true
            };
          end end,function(exn) do
            if (exn == Caml_builtin_exceptions.not_found) then do
              opath = undefined;
            end else do
              error(exn)
            end end 
          end end)
          match_4 = lid.txt;
          constrs_1;
          exit = 0;
          local ___conditional___=(match_4.tag | 0);
          do
             if ___conditional___ == 0--[[ Lident ]] then do
                if (constrs ~= undefined) then do
                  constrs_2 = Caml_option.valFromOption(constrs);
                  s = match_4[0];
                  if (Hashtbl.mem(constrs_2, s)) then do
                    constrs_1 = --[[ :: ]]{
                      --[[ tuple ]]{
                        Hashtbl.find(constrs_2, s),
                        (function(param) do
                            return --[[ () ]]0;
                          end end)
                      },
                      --[[ [] ]]0
                    };
                  end else do
                    exit = 1;
                  end end 
                end else do
                  exit = 1;
                end end  end else 
             if ___conditional___ == 1--[[ Ldot ]]
             or ___conditional___ == 2--[[ Lapply ]] then do
                exit = 1; end else 
             end end end end
            
          end
          if (exit == 1) then do
            constrs_1 = find_all_constructors(env.contents, lid.loc, lid.txt);
          end
           end 
          check_lk = function(tpath, constr) do
            if (constr.cstr_generalized) then do
              error({
                __Error_7,
                lid.loc,
                env.contents,
                --[[ Unqualified_gadt_pattern ]]Block.__(34, {
                    tpath,
                    constr.cstr_name
                  })
              })
            end else do
              return 0;
            end end 
          end end;
          partial_arg = env.contents;
          partial_arg_1 = check_lk;
          constr = wrap_disambiguate("This variant pattern is expected to have", expected_ty, (function(param) do
                  return disambiguate_1(undefined, partial_arg_1, undefined, lid, partial_arg, opath, param);
                end end), constrs_1);
          mark_constructor(--[[ Pattern ]]1, env.contents, last_1(lid.txt), constr);
          check_deprecated(loc, constr.cstr_attributes, constr.cstr_name);
          if (no_existentials and constr.cstr_existentials ~= --[[ [] ]]0) then do
            error({
              __Error_7,
              loc,
              env.contents,
              --[[ Unexpected_existential ]]4
            })
          end
           end 
          if (constr.cstr_generalized) then do
            unify_head_only(loc, env.contents, expected_ty, constr);
          end
           end 
          sargs;
          if (sarg ~= undefined) then do
            sp_1 = sarg;
            match_5 = sp_1.ppat_desc;
            if (typeof match_5 == "number") then do
              if (constr.cstr_arity ~= 1) then do
                if (constr.cstr_arity == 0) then do
                  prerr_warning(sp_1.ppat_loc, --[[ Wildcard_arg_to_constant_constr ]]13);
                end
                 end 
                sargs = replicate_list(sp_1, constr.cstr_arity);
              end else do
                sargs = --[[ :: ]]{
                  sp_1,
                  --[[ [] ]]0
                };
              end end 
            end else do
              sargs = match_5.tag == --[[ Ppat_tuple ]]4 and (constr.cstr_arity > 1 or explicit_arity(sp.ppat_attributes)) and match_5[0] or --[[ :: ]]{
                  sp_1,
                  --[[ [] ]]0
                };
            end end 
          end else do
            sargs = --[[ [] ]]0;
          end end 
          if (List.length(sargs) ~= constr.cstr_arity) then do
            error({
              __Error_7,
              loc,
              env.contents,
              --[[ Constructor_arity_mismatch ]]Block.__(1, {
                  lid.txt,
                  constr.cstr_arity,
                  List.length(sargs)
                })
            })
          end
           end 
          match_6 = instance_constructor(--[[ tuple ]]{
                env,
                get_newtype_level_1(--[[ () ]]0)
              }, constr);
          ty_res = match_6[1];
          if (constr.cstr_generalized and mode == --[[ Normal ]]0) then do
            unify_pat_types_gadt(loc, env, ty_res, expected_ty);
          end else do
            unify_pat_types(loc, env.contents, ty_res, expected_ty);
          end end 
          args = List.map2((function(p, t) do
                  return type_pat_1(undefined, undefined)(p, t);
                end end), sargs, match_6[0]);
          return rp(do
                      pat_desc: --[[ Tpat_construct ]]Block.__(4, {
                          lid,
                          constr,
                          args
                        }),
                      pat_loc: loc,
                      pat_extra: --[[ [] ]]0,
                      pat_type: expected_ty,
                      pat_env: env.contents,
                      pat_attributes: sp.ppat_attributes
                    end); end end 
       if ___conditional___ == 6--[[ Ppat_variant ]] then do
          sarg_1 = match[1];
          l = match[0];
          arg_type = sarg_1 ~= undefined and --[[ :: ]]{
              newvar(undefined, --[[ () ]]0),
              --[[ [] ]]0
            } or --[[ [] ]]0;
          row_row_fields = --[[ :: ]]{
            --[[ tuple ]]{
              l,
              --[[ Reither ]]Block.__(1, {
                  sarg_1 == undefined,
                  arg_type,
                  true,
                  do
                    contents: undefined
                  end
                })
            },
            --[[ [] ]]0
          };
          row_row_more = newvar(undefined, --[[ () ]]0);
          row = do
            row_fields: row_row_fields,
            row_more: row_row_more,
            row_bound: --[[ () ]]0,
            row_closed: false,
            row_fixed: false,
            row_name: undefined
          end;
          unify_pat_types(loc, env.contents, newty2(current_level.contents, --[[ Tvariant ]]Block.__(8, {row})), expected_ty);
          arg = sarg_1 ~= undefined and arg_type and not arg_type[1] and type_pat_1(undefined, undefined)(sarg_1, arg_type[0]) or undefined;
          return rp(do
                      pat_desc: --[[ Tpat_variant ]]Block.__(5, {
                          l,
                          arg,
                          do
                            contents: do
                              row_fields: row_row_fields,
                              row_more: newvar(undefined, --[[ () ]]0),
                              row_bound: --[[ () ]]0,
                              row_closed: false,
                              row_fixed: false,
                              row_name: undefined
                            end
                          end
                        }),
                      pat_loc: loc,
                      pat_extra: --[[ [] ]]0,
                      pat_type: expected_ty,
                      pat_env: env.contents,
                      pat_attributes: sp.ppat_attributes
                    end); end end 
       if ___conditional___ == 7--[[ Ppat_record ]] then do
          closed = match[1];
          lid_sp_list = match[0];
          if (lid_sp_list == --[[ [] ]]0) then do
            ill_formed_ast(loc, "Records cannot be empty.");
          end
           end 
          match_7;
          xpcall(function() do
            match_8 = extract_concrete_record(env.contents, expected_ty);
            match_7 = --[[ tuple ]]{
              --[[ tuple ]]{
                match_8[0],
                match_8[1],
                true
              },
              expected_ty
            };
          end end,function(exn_1) do
            if (exn_1 == Caml_builtin_exceptions.not_found) then do
              match_7 = --[[ tuple ]]{
                undefined,
                newvar(undefined, --[[ () ]]0)
              };
            end else do
              error(exn_1)
            end end 
          end end)
          record_ty = match_7[1];
          opath_1 = match_7[0];
          type_label_pat = function(param) do
            label = param[1];
            label_lid = param[0];
            begin_def(--[[ () ]]0);
            match = instance_label(false, label);
            ty_arg = match[1];
            vars = match[0];
            if (vars == --[[ [] ]]0) then do
              end_def(--[[ () ]]0);
            end
             end 
            xpcall(function() do
              unify_pat_types(loc, env.contents, match[2], record_ty);
            end end,function(raw_exn) do
              exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn[0] == Unify) then do
                error({
                  __Error_7,
                  label_lid.loc,
                  env.contents,
                  --[[ Label_mismatch ]]Block.__(2, {
                      label_lid.txt,
                      exn[1]
                    })
                })
              end
               end 
              error(exn)
            end end)
            arg = type_pat_1(undefined, undefined)(param[2], ty_arg);
            if (vars ~= --[[ [] ]]0) then do
              end_def(--[[ () ]]0);
              iter_generalize_1(do
                    contents: --[[ [] ]]0
                  end, ty_arg);
              List.iter(generalize, vars);
              instantiated = function(tv) do
                tv_1 = expand_head(env.contents, tv);
                if (is_Tvar(tv_1)) then do
                  return tv_1.level ~= 100000000;
                end else do
                  return true;
                end end 
              end end;
              if (List.exists(instantiated, vars)) then do
                error({
                  __Error_7,
                  label_lid.loc,
                  env.contents,
                  --[[ Polymorphic_label ]]Block.__(0, {label_lid.txt})
                })
              end
               end 
            end
             end 
            return --[[ tuple ]]{
                    label_lid,
                    label,
                    arg
                  };
          end end;
          partial_arg_2 = env.contents;
          lbl_pat_list = wrap_disambiguate("This record pattern is expected to have", expected_ty, (function(param) do
                  return type_label_a_list(labels, loc, false, partial_arg_2, type_label_pat, opath_1, param);
                end end), lid_sp_list);
          check_recordpat_labels(loc, lbl_pat_list, closed);
          unify_pat_types(loc, env.contents, record_ty, expected_ty);
          return rp(do
                      pat_desc: --[[ Tpat_record ]]Block.__(6, {
                          lbl_pat_list,
                          closed
                        }),
                      pat_loc: loc,
                      pat_extra: --[[ [] ]]0,
                      pat_type: expected_ty,
                      pat_env: env.contents,
                      pat_attributes: sp.ppat_attributes
                    end); end end 
       if ___conditional___ == 8--[[ Ppat_array ]] then do
          ty_elt = newvar(undefined, --[[ () ]]0);
          unify_pat_types(loc, env.contents, instance_def(type_array(ty_elt)), expected_ty);
          spl_ann_1 = List.map((function(p) do
                  return --[[ tuple ]]{
                          p,
                          newvar(undefined, --[[ () ]]0)
                        };
                end end), match[0]);
          pl_1 = List.map((function(param) do
                  return type_pat_1(undefined, undefined)(param[0], ty_elt);
                end end), spl_ann_1);
          return rp(do
                      pat_desc: --[[ Tpat_array ]]Block.__(7, {pl_1}),
                      pat_loc: loc,
                      pat_extra: --[[ [] ]]0,
                      pat_type: expected_ty,
                      pat_env: env.contents,
                      pat_attributes: sp.ppat_attributes
                    end); end end 
       if ___conditional___ == 9--[[ Ppat_or ]] then do
          initial_pattern_variables = pattern_variables.contents;
          p1 = type_pat_1(--[[ Inside_or ]]1, undefined)(match[0], expected_ty);
          p1_variables = pattern_variables.contents;
          pattern_variables.contents = initial_pattern_variables;
          p2 = type_pat_1(--[[ Inside_or ]]1, undefined)(match[1], expected_ty);
          p2_variables = pattern_variables.contents;
          alpha_env = enter_orpat_variables(loc, env.contents, p1_variables, p2_variables);
          pattern_variables.contents = p1_variables;
          return rp(do
                      pat_desc: --[[ Tpat_or ]]Block.__(8, {
                          p1,
                          alpha_pat(alpha_env, p2),
                          undefined
                        }),
                      pat_loc: loc,
                      pat_extra: --[[ [] ]]0,
                      pat_type: expected_ty,
                      pat_env: env.contents,
                      pat_attributes: sp.ppat_attributes
                    end); end end 
       if ___conditional___ == 10--[[ Ppat_constraint ]] then do
          sp_2 = match[0];
          match_9 = sp_2.ppat_desc;
          exit_1 = 0;
          if (typeof match_9 == "number" or match_9.tag) then do
            exit_1 = 1;
          end else do
            sty = match[1];
            tmp = sty.ptyp_desc;
            if (typeof tmp == "number" or tmp.tag ~= --[[ Ptyp_poly ]]8) then do
              exit_1 = 1;
            end else do
              lloc = sp_2.ppat_loc;
              name_2 = match_9[0];
              match_10 = transl_simple_type_delayed(env.contents, sty);
              cty = match_10[0];
              ty_1 = cty.ctyp_type;
              unify_pat_types(lloc, env.contents, ty_1, expected_ty);
              pattern_force.contents = --[[ :: ]]{
                match_10[1],
                pattern_force.contents
              };
              match_11 = ty_1.desc;
              if (typeof match_11 == "number") then do
                error({
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "typecore.ml",
                    955,
                    13
                  }
                })
              end else if (match_11.tag == --[[ Tpoly ]]10) then do
                begin_def(--[[ () ]]0);
                match_12 = instance_poly(true, false, match_11[1], match_11[0]);
                ty$prime = match_12[1];
                end_def(--[[ () ]]0);
                iter_generalize_1(do
                      contents: --[[ [] ]]0
                    end, ty$prime);
                id_2 = enter_variable(undefined, undefined, lloc, name_2, ty$prime);
                return rp(do
                            pat_desc: --[[ Tpat_var ]]Block.__(0, {
                                id_2,
                                name_2
                              }),
                            pat_loc: lloc,
                            pat_extra: --[[ :: ]]{
                              --[[ tuple ]]{
                                --[[ Tpat_constraint ]]Block.__(0, {cty}),
                                loc,
                                sp.ppat_attributes
                              },
                              --[[ [] ]]0
                            },
                            pat_type: ty_1,
                            pat_env: env.contents,
                            pat_attributes: --[[ [] ]]0
                          end);
              end else do
                error({
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "typecore.ml",
                    955,
                    13
                  }
                })
              end end  end 
            end end 
          end end 
          if (exit_1 == 1) then do
            begin_def(--[[ () ]]0);
            match_13 = transl_simple_type_delayed(env.contents, match[1]);
            cty_1 = match_13[0];
            ty_2 = cty_1.ctyp_type;
            end_def(--[[ () ]]0);
            generalize_structure_1(current_level.contents, ty_2);
            match_000 = instance(undefined, env.contents, ty_2);
            match_001 = instance(undefined, env.contents, ty_2);
            ty_3 = match_000;
            unify_pat_types(loc, env.contents, ty_3, expected_ty);
            p_2 = type_pat_1(undefined, undefined)(sp_2, match_001);
            pattern_force.contents = --[[ :: ]]{
              match_13[1],
              pattern_force.contents
            };
            extra_000 = --[[ Tpat_constraint ]]Block.__(0, {cty_1});
            extra_002 = sp_2.ppat_attributes;
            extra = --[[ tuple ]]{
              extra_000,
              loc,
              extra_002
            };
            match_14 = p_2.pat_desc;
            if (typeof match_14 ~= "number" and not match_14.tag) then do
              return do
                      pat_desc: --[[ Tpat_alias ]]Block.__(1, {
                          do
                            pat_desc: --[[ Tpat_any ]]0,
                            pat_loc: p_2.pat_loc,
                            pat_extra: p_2.pat_extra,
                            pat_type: p_2.pat_type,
                            pat_env: p_2.pat_env,
                            pat_attributes: --[[ [] ]]0
                          end,
                          match_14[0],
                          match_14[1]
                        }),
                      pat_loc: p_2.pat_loc,
                      pat_extra: --[[ :: ]]{
                        extra,
                        --[[ [] ]]0
                      },
                      pat_type: ty_3,
                      pat_env: p_2.pat_env,
                      pat_attributes: p_2.pat_attributes
                    end;
            end
             end 
            return do
                    pat_desc: p_2.pat_desc,
                    pat_loc: p_2.pat_loc,
                    pat_extra: --[[ :: ]]{
                      extra,
                      p_2.pat_extra
                    },
                    pat_type: ty_3,
                    pat_env: p_2.pat_env,
                    pat_attributes: p_2.pat_attributes
                  end;
          end
           end  end else 
       if ___conditional___ == 11--[[ Ppat_type ]] then do
          lid_1 = match[0];
          match_15 = build_or_pat(env.contents, loc, lid_1.txt);
          p_3 = match_15[1];
          unify_pat_types(loc, env.contents, match_15[2], expected_ty);
          return do
                  pat_desc: p_3.pat_desc,
                  pat_loc: p_3.pat_loc,
                  pat_extra: --[[ :: ]]{
                    --[[ tuple ]]{
                      --[[ Tpat_type ]]Block.__(1, {
                          match_15[0],
                          lid_1
                        }),
                      loc,
                      sp.ppat_attributes
                    },
                    p_3.pat_extra
                  },
                  pat_type: p_3.pat_type,
                  pat_env: p_3.pat_env,
                  pat_attributes: p_3.pat_attributes
                end; end end end end 
       if ___conditional___ == 12--[[ Ppat_lazy ]] then do
          nv = newvar(undefined, --[[ () ]]0);
          unify_pat_types(loc, env.contents, instance_def(type_lazy_t(nv)), expected_ty);
          p1_1 = type_pat_1(undefined, undefined)(match[0], nv);
          return rp(do
                      pat_desc: --[[ Tpat_lazy ]]Block.__(9, {p1_1}),
                      pat_loc: loc,
                      pat_extra: --[[ [] ]]0,
                      pat_type: expected_ty,
                      pat_env: env.contents,
                      pat_attributes: sp.ppat_attributes
                    end); end end 
       if ___conditional___ == 13--[[ Ppat_unpack ]] then do
          name_3 = match[0];
          id_3 = enter_variable(true, undefined, loc, name_3, expected_ty);
          return rp(do
                      pat_desc: --[[ Tpat_var ]]Block.__(0, {
                          id_3,
                          name_3
                        }),
                      pat_loc: sp.ppat_loc,
                      pat_extra: --[[ :: ]]{
                        --[[ tuple ]]{
                          --[[ Tpat_unpack ]]0,
                          loc,
                          sp.ppat_attributes
                        },
                        --[[ [] ]]0
                      },
                      pat_type: expected_ty,
                      pat_env: env.contents,
                      pat_attributes: --[[ [] ]]0
                    end); end end 
       if ___conditional___ == 14--[[ Ppat_exception ]] then do
          error({
            __Error_7,
            loc,
            env.contents,
            --[[ Exception_pattern_below_toplevel ]]8
          }) end end 
       if ___conditional___ == 15--[[ Ppat_extension ]] then do
          error({
            Error_forward_1,
            error_of_extension(match[0])
          }) end end 
      
    end
  end end 
end end

function type_pat_1(allow_existentialsOpt, constrs, labels, levOpt, env, sp, expected_ty) do
  allow_existentials = allow_existentialsOpt ~= undefined and allow_existentialsOpt or false;
  lev = levOpt ~= undefined and levOpt or current_level.contents;
  newtype_level_1.contents = lev;
  xpcall(function() do
    r = type_pat(constrs, labels, not allow_existentials, --[[ Normal ]]0, env, sp, expected_ty);
    iter_pattern((function(p) do
            p.pat_env = env.contents;
            return --[[ () ]]0;
          end end), r);
    newtype_level_1.contents = undefined;
    return r;
  end end,function(e) do
    newtype_level_1.contents = undefined;
    error(e)
  end end)
end end

function partial_pred(lev, env, expected_ty, constrs, labels, p) do
  snap = snapshot(--[[ () ]]0);
  xpcall(function() do
    reset_pattern(undefined, true);
    typed_p = type_pat_1(true, Caml_option.some(constrs), Caml_option.some(labels), lev, do
          contents: env
        end, p, expected_ty);
    backtrack(snap);
    return typed_p;
  end end,function(exn) do
    backtrack(snap);
    return ;
  end end)
end end

function check_partial_1(levOpt, env, expected_ty) do
  lev = levOpt ~= undefined and levOpt or current_level.contents;
  return (function(param, param_1) do
      pred = function(param, param_1, param_2) do
        return partial_pred(lev, env, expected_ty, param, param_1, param_2);
      end end;
      loc = param;
      casel = param_1;
      first_check = check_partial(loc, casel);
      if (first_check) then do
        return check_partial_param((function(param, param_1, param_2) do
                      pred_1 = pred;
                      loc = param;
                      casel = param_1;
                      pss = param_2;
                      return do_check_partial(pred_1, exhaust_gadt_1, loc, casel, pss);
                    end end), do_check_fragile_gadt, loc, casel);
      end else do
        return --[[ Partial ]]0;
      end end 
    end end);
end end

function add_pattern_variables(check, check_as, env) do
  pv = get_ref(pattern_variables);
  return --[[ tuple ]]{
          List.fold_right((function(param, env) do
                  check_1 = param[4] and check_as or check;
                  return add_value(check_1, param[0], do
                              val_type: param[1],
                              val_kind: --[[ Val_reg ]]0,
                              val_loc: param[3],
                              val_attributes: --[[ [] ]]0
                            end, env);
                end end), pv, env),
          get_ref(module_variables)
        };
end end

function type_pattern(lev, env, spat, scope, expected_ty) do
  reset_pattern(scope, true);
  new_env = do
    contents: env
  end;
  pat = type_pat_1(true, undefined, undefined, lev, new_env, spat, expected_ty);
  match = add_pattern_variables((function(s) do
          return --[[ Unused_var_strict ]]Block.__(13, {s});
        end end), (function(s) do
          return --[[ Unused_var ]]Block.__(12, {s});
        end end), new_env.contents);
  return --[[ tuple ]]{
          pat,
          match[0],
          get_ref(pattern_force),
          match[1]
        };
end end

function type_pattern_list(env, spatl, scope, expected_tys, allow) do
  reset_pattern(scope, allow);
  new_env = do
    contents: env
  end;
  patl = List.map2((function(param, param_1) do
          return type_pat_1(undefined, undefined, undefined, undefined, new_env, param, param_1);
        end end), spatl, expected_tys);
  match = add_pattern_variables(undefined, undefined, new_env.contents);
  return --[[ tuple ]]{
          patl,
          match[0],
          get_ref(pattern_force),
          match[1]
        };
end end

function type_class_arg_pattern(cl_num, val_env, met_env, l, spat) do
  reset_pattern(undefined, false);
  nv = newvar(undefined, --[[ () ]]0);
  pat = type_pat_1(undefined, undefined, undefined, undefined, do
        contents: val_env
      end, spat, nv);
  if (has_variants(pat)) then do
    pressure_variants_1(val_env, --[[ :: ]]{
          pat,
          --[[ [] ]]0
        });
    iter_pattern(finalize_variant, pat);
  end
   end 
  List.iter((function(f) do
          return Curry._1(f, --[[ () ]]0);
        end end), get_ref(pattern_force));
  if (is_optional(l)) then do
    unify_pat(val_env, pat, type_option_1(newvar(undefined, --[[ () ]]0)));
  end
   end 
  match = List.fold_right((function(param, param_1) do
          as_var = param[4];
          ty = param[1];
          id = param[0];
          check = function(s) do
            if (as_var) then do
              return --[[ Unused_var ]]Block.__(12, {s});
            end else do
              return --[[ Unused_var_strict ]]Block.__(13, {s});
            end end 
          end end;
          id$prime = create(id.name);
          return --[[ tuple ]]{
                  --[[ :: ]]{
                    --[[ tuple ]]{
                      id$prime,
                      param[2],
                      id,
                      ty
                    },
                    param_1[0]
                  },
                  add_value(check, id$prime, do
                        val_type: ty,
                        val_kind: --[[ Val_ivar ]]Block.__(1, {
                            --[[ Immutable ]]0,
                            cl_num
                          }),
                        val_loc: param[3],
                        val_attributes: --[[ [] ]]0
                      end, param_1[1])
                };
        end end), pattern_variables.contents, --[[ tuple ]]{
        --[[ [] ]]0,
        met_env
      });
  match_1 = add_pattern_variables(undefined, undefined, val_env);
  return --[[ tuple ]]{
          pat,
          match[0],
          match_1[0],
          match[1]
        };
end end

function type_self_pattern(cl_num, privty, val_env, met_env, par_env, spat) do
  spat_1 = mk_1(undefined, undefined, --[[ Ppat_alias ]]Block.__(1, {
          mk_1(undefined, undefined, --[[ Ppat_alias ]]Block.__(1, {
                  spat,
                  do
                    txt: "selfpat-*",
                    loc: none
                  end
                })),
          do
            txt: "selfpat-" .. cl_num,
            loc: none
          end
        }));
  reset_pattern(undefined, false);
  nv = newvar(undefined, --[[ () ]]0);
  pat = type_pat_1(undefined, undefined, undefined, undefined, do
        contents: val_env
      end, spat_1, nv);
  List.iter((function(f) do
          return Curry._1(f, --[[ () ]]0);
        end end), get_ref(pattern_force));
  meths = do
    contents: --[[ Empty ]]0
  end;
  vars = do
    contents: --[[ Empty ]]0
  end;
  pv = pattern_variables.contents;
  pattern_variables.contents = --[[ [] ]]0;
  match = List.fold_right((function(param, param_1) do
          as_var = param[4];
          loc = param[3];
          ty = param[1];
          id = param[0];
          return --[[ tuple ]]{
                  add_value(undefined, id, do
                        val_type: ty,
                        val_kind: --[[ Val_unbound ]]1,
                        val_loc: loc,
                        val_attributes: --[[ [] ]]0
                      end, param_1[0]),
                  add_value((function(s) do
                          if (as_var) then do
                            return --[[ Unused_var ]]Block.__(12, {s});
                          end else do
                            return --[[ Unused_var_strict ]]Block.__(13, {s});
                          end end 
                        end end), id, do
                        val_type: ty,
                        val_kind: --[[ Val_self ]]Block.__(2, {
                            meths,
                            vars,
                            cl_num,
                            privty
                          }),
                        val_loc: loc,
                        val_attributes: --[[ [] ]]0
                      end, param_1[1]),
                  add_value(undefined, id, do
                        val_type: ty,
                        val_kind: --[[ Val_unbound ]]1,
                        val_loc: loc,
                        val_attributes: --[[ [] ]]0
                      end, param_1[2])
                };
        end end), pv, --[[ tuple ]]{
        val_env,
        met_env,
        par_env
      });
  return --[[ tuple ]]{
          pat,
          meths,
          vars,
          match[0],
          match[1],
          match[2]
        };
end end

delayed_checks = do
  contents: --[[ [] ]]0
end;

function add_delayed_check(f) do
  delayed_checks.contents = --[[ :: ]]{
    --[[ tuple ]]{
      f,
      current.contents
    },
    delayed_checks.contents
  };
  return --[[ () ]]0;
end end

function force_delayed_checks(param) do
  snap = snapshot(--[[ () ]]0);
  w_old = current.contents;
  List.iter((function(param) do
          current.contents = param[1];
          return Curry._1(param[0], --[[ () ]]0);
        end end), List.rev(delayed_checks.contents));
  current.contents = w_old;
  delayed_checks.contents = --[[ [] ]]0;
  return backtrack(snap);
end end

function final_subexpression(_sexp) do
  while(true) do
    sexp = _sexp;
    match = sexp.pexp_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 2--[[ Pexp_let ]] then do
          _sexp = match[2];
          ::continue:: ; end end 
       if ___conditional___ == 6--[[ Pexp_match ]] then do
          match_1 = match[1];
          if (match_1) then do
            _sexp = match_1[0].pc_rhs;
            ::continue:: ;
          end else do
            return sexp;
          end end  end end 
       if ___conditional___ == 7--[[ Pexp_try ]] then do
          _sexp = match[0];
          ::continue:: ; end end 
       if ___conditional___ == 15--[[ Pexp_ifthenelse ]]
       or ___conditional___ == 16--[[ Pexp_sequence ]] then do
          _sexp = match[1];
          ::continue:: ; end end 
      return sexp;
        
    end
  end;
end end

function is_nonexpansive(_exp) do
  while(true) do
    exp = _exp;
    match = exp.exp_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 2--[[ Texp_let ]] then do
          if (List.for_all((function(vb) do
                    return is_nonexpansive(vb.vb_expr);
                  end end), match[1])) then do
            _exp = match[2];
            ::continue:: ;
          end else do
            return false;
          end end  end end 
       if ___conditional___ == 0--[[ Texp_ident ]]
       or ___conditional___ == 1--[[ Texp_constant ]]
       or ___conditional___ == 3--[[ Texp_function ]] then do
          return true; end end 
       if ___conditional___ == 4--[[ Texp_apply ]] then do
          match_1 = match[1];
          if (match_1 and not (match_1[0][1] ~= undefined or not is_nonexpansive(match[0]))) then do
            return List.for_all(is_nonexpansive_opt, List.map(snd3, match_1[1]));
          end else do
            return false;
          end end  end end 
       if ___conditional___ == 5--[[ Texp_match ]] then do
          if (match[2] or not is_nonexpansive(match[0])) then do
            return false;
          end else do
            return List.for_all((function(param) do
                          if (is_nonexpansive_opt(param.c_guard)) then do
                            return is_nonexpansive(param.c_rhs);
                          end else do
                            return false;
                          end end 
                        end end), match[1]);
          end end  end end 
       if ___conditional___ == 7--[[ Texp_tuple ]] then do
          return List.for_all(is_nonexpansive, match[0]); end end 
       if ___conditional___ == 8--[[ Texp_construct ]] then do
          return List.for_all(is_nonexpansive, match[2]); end end 
       if ___conditional___ == 9--[[ Texp_variant ]] then do
          return is_nonexpansive_opt(match[1]); end end 
       if ___conditional___ == 10--[[ Texp_record ]] then do
          if (List.for_all((function(param) do
                    return param[1].lbl_mut == --[[ Immutable ]]0 and is_nonexpansive(param[2]) or false;
                  end end), match[0])) then do
            return is_nonexpansive_opt(match[1]);
          end else do
            return false;
          end end  end end 
       if ___conditional___ == 13--[[ Texp_array ]] then do
          if (match[0]) then do
            return false;
          end else do
            return true;
          end end  end end 
       if ___conditional___ == 14--[[ Texp_ifthenelse ]] then do
          if (is_nonexpansive(match[1])) then do
            return is_nonexpansive_opt(match[2]);
          end else do
            return false;
          end end  end end 
       if ___conditional___ == 15--[[ Texp_sequence ]] then do
          _exp = match[1];
          ::continue:: ; end end 
       if ___conditional___ == 19--[[ Texp_new ]] then do
          return class_type_arity(match[2].cty_type) > 0; end end 
       if ___conditional___ == 23--[[ Texp_letmodule ]] then do
          if (is_nonexpansive_mod(match[2])) then do
            _exp = match[3];
            ::continue:: ;
          end else do
            return false;
          end end  end end 
       if ___conditional___ == 11--[[ Texp_field ]]
       or ___conditional___ == 25--[[ Texp_lazy ]] then do
          _exp = match[0];
          ::continue:: ; end end 
       if ___conditional___ == 26--[[ Texp_object ]] then do
          match_2 = match[0];
          count = do
            contents: 0
          end;
          if (List.for_all((function(count)do
                return function (field) do
                  match = field.cf_desc;
                  local ___conditional___=(match.tag | 0);
                  do
                     if ___conditional___ == 0--[[ Tcf_inherit ]] then do
                        return false; end end 
                     if ___conditional___ == 1--[[ Tcf_val ]] then do
                        match_1 = match[3];
                        count.contents = count.contents + 1 | 0;
                        return match_1.tag and is_nonexpansive(match_1[1]) or true; end end 
                     if ___conditional___ == 4--[[ Tcf_initializer ]] then do
                        return is_nonexpansive(match[0]); end end 
                    return true;
                      
                  end
                end end
                end end)(count), match_2.cstr_fields) and fold((function(count)do
                return function (param, param_1, b) do
                  count.contents = count.contents - 1 | 0;
                  return b and param_1[0] == --[[ Immutable ]]0 or false;
                end end
                end end)(count), match_2.cstr_type.csig_vars, true)) then do
            return count.contents == 0;
          end else do
            return false;
          end end  end end 
       if ___conditional___ == 27--[[ Texp_pack ]] then do
          return is_nonexpansive_mod(match[0]); end end 
      return false;
        
    end
  end;
end end

function is_nonexpansive_mod(_mexp) do
  while(true) do
    mexp = _mexp;
    match = mexp.mod_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 1--[[ Tmod_structure ]] then do
          return List.for_all((function(item) do
                        match = item.str_desc;
                        local ___conditional___=(match.tag | 0);
                        do
                           if ___conditional___ == 1--[[ Tstr_value ]] then do
                              return List.for_all((function(vb) do
                                            return is_nonexpansive(vb.vb_expr);
                                          end end), match[1]); end end 
                           if ___conditional___ == 4--[[ Tstr_typext ]] then do
                              return List.for_all((function(param) do
                                            if (param.ext_kind.tag) then do
                                              return true;
                                            end else do
                                              return false;
                                            end end 
                                          end end), match[0].tyext_constructors); end end 
                           if ___conditional___ == 5--[[ Tstr_exception ]] then do
                              if (match[0].ext_kind.tag) then do
                                return true;
                              end else do
                                return false;
                              end end  end end 
                           if ___conditional___ == 6--[[ Tstr_module ]] then do
                              return is_nonexpansive_mod(match[0].mb_expr); end end 
                           if ___conditional___ == 7--[[ Tstr_recmodule ]] then do
                              return List.for_all((function(param) do
                                            return is_nonexpansive_mod(param.mb_expr);
                                          end end), match[0]); end end 
                           if ___conditional___ == 10--[[ Tstr_class ]] then do
                              return false; end end 
                           if ___conditional___ == 12--[[ Tstr_include ]] then do
                              return is_nonexpansive_mod(match[0].incl_mod); end end 
                           if ___conditional___ == 13--[[ Tstr_attribute ]] then do
                              return true; end end 
                          return true;
                            
                        end
                      end end), match[0].str_items); end end 
       if ___conditional___ == 0--[[ Tmod_ident ]]
       or ___conditional___ == 2--[[ Tmod_functor ]] then do
          return true; end end 
       if ___conditional___ == 3--[[ Tmod_apply ]] then do
          return false; end end 
       if ___conditional___ == 4--[[ Tmod_constraint ]] then do
          _mexp = match[0];
          ::continue:: ; end end 
       if ___conditional___ == 5--[[ Tmod_unpack ]] then do
          return is_nonexpansive(match[0]); end end 
      
    end
  end;
end end

function is_nonexpansive_opt(param) do
  if (param ~= undefined) then do
    return is_nonexpansive(param);
  end else do
    return true;
  end end 
end end

function approx_type(env, _sty) do
  while(true) do
    sty = _sty;
    match = sty.ptyp_desc;
    if (typeof match == "number") then do
      return newvar(undefined, --[[ () ]]0);
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 1--[[ Ptyp_arrow ]] then do
            p = match[0];
            ty1 = is_optional(p) and type_option_1(newvar(undefined, --[[ () ]]0)) or newvar(undefined, --[[ () ]]0);
            desc_002 = approx_type(env, match[2]);
            desc = --[[ Tarrow ]]Block.__(1, {
                p,
                ty1,
                desc_002,
                --[[ Cok ]]0
              });
            return newty2(current_level.contents, desc); end end 
         if ___conditional___ == 2--[[ Ptyp_tuple ]] then do
            desc_1 = --[[ Ttuple ]]Block.__(2, {List.map((function(param) do
                        return approx_type(env, param);
                      end end), match[0])});
            return newty2(current_level.contents, desc_1); end end 
         if ___conditional___ == 3--[[ Ptyp_constr ]] then do
            ctl = match[1];
            xpcall(function() do
              match_1 = lookup_type_1(match[0].txt, env);
              if (List.length(ctl) ~= match_1[1].type_arity) then do
                error(Caml_builtin_exceptions.not_found)
              end
               end 
              tyl = List.map((function(param) do
                      return approx_type(env, param);
                    end end), ctl);
              return newconstr(match_1[0], tyl);
            end end,function(exn) do
              if (exn == Caml_builtin_exceptions.not_found) then do
                return newvar(undefined, --[[ () ]]0);
              end else do
                error(exn)
              end end 
            end end) end end 
         if ___conditional___ == 8--[[ Ptyp_poly ]] then do
            _sty = match[1];
            ::continue:: ; end end 
        return newvar(undefined, --[[ () ]]0);
          
      end
    end end 
  end;
end end

function type_approx(env, _sexp) do
  while(true) do
    sexp = _sexp;
    match = sexp.pexp_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 2--[[ Pexp_let ]] then do
          _sexp = match[2];
          ::continue:: ; end end 
       if ___conditional___ == 3--[[ Pexp_function ]] then do
          match_1 = match[0];
          if (match_1) then do
            desc_001 = newvar(undefined, --[[ () ]]0);
            desc_002 = type_approx(env, match_1[0].pc_rhs);
            desc = --[[ Tarrow ]]Block.__(1, {
                "",
                desc_001,
                desc_002,
                --[[ Cok ]]0
              });
            return newty2(current_level.contents, desc);
          end else do
            return newvar(undefined, --[[ () ]]0);
          end end  end end 
       if ___conditional___ == 4--[[ Pexp_fun ]] then do
          e = match[3];
          p = match[0];
          if (is_optional(p)) then do
            desc_001_1 = type_option_1(newvar(undefined, --[[ () ]]0));
            desc_002_1 = type_approx(env, e);
            desc_1 = --[[ Tarrow ]]Block.__(1, {
                p,
                desc_001_1,
                desc_002_1,
                --[[ Cok ]]0
              });
            return newty2(current_level.contents, desc_1);
          end else do
            desc_001_2 = newvar(undefined, --[[ () ]]0);
            desc_002_2 = type_approx(env, e);
            desc_2 = --[[ Tarrow ]]Block.__(1, {
                p,
                desc_001_2,
                desc_002_2,
                --[[ Cok ]]0
              });
            return newty2(current_level.contents, desc_2);
          end end  end end 
       if ___conditional___ == 6--[[ Pexp_match ]] then do
          match_2 = match[1];
          if (match_2) then do
            _sexp = match_2[0].pc_rhs;
            ::continue:: ;
          end else do
            return newvar(undefined, --[[ () ]]0);
          end end  end end 
       if ___conditional___ == 7--[[ Pexp_try ]] then do
          _sexp = match[0];
          ::continue:: ; end end 
       if ___conditional___ == 8--[[ Pexp_tuple ]] then do
          desc_3 = --[[ Ttuple ]]Block.__(2, {List.map((function(param) do
                      return type_approx(env, param);
                    end end), match[0])});
          return newty2(current_level.contents, desc_3); end end 
       if ___conditional___ == 15--[[ Pexp_ifthenelse ]]
       or ___conditional___ == 16--[[ Pexp_sequence ]] then do
          _sexp = match[1];
          ::continue:: ; end end 
       if ___conditional___ == 19--[[ Pexp_constraint ]] then do
          ty = type_approx(env, match[0]);
          ty1 = approx_type(env, match[1]);
          xpcall(function() do
            unify_2(env, ty, ty1);
          end end,function(raw_exn) do
            exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn[0] == Unify) then do
              error({
                __Error_7,
                sexp.pexp_loc,
                env,
                --[[ Expr_type_clash ]]Block.__(7, {exn[1]})
              })
            end
             end 
            error(exn)
          end end)
          return ty1; end end 
       if ___conditional___ == 20--[[ Pexp_coerce ]] then do
          approx_ty_opt = function(param) do
            if (param ~= undefined) then do
              return approx_type(env, param);
            end else do
              return newvar(undefined, --[[ () ]]0);
            end end 
          end end;
          ty_1 = type_approx(env, match[0]);
          ty1_1 = approx_ty_opt(match[1]);
          ty2 = approx_type(env, match[2]);
          xpcall(function() do
            unify_2(env, ty_1, ty1_1);
          end end,function(raw_exn_1) do
            exn_1 = Caml_js_exceptions.internalToOCamlException(raw_exn_1);
            if (exn_1[0] == Unify) then do
              error({
                __Error_7,
                sexp.pexp_loc,
                env,
                --[[ Expr_type_clash ]]Block.__(7, {exn_1[1]})
              })
            end
             end 
            error(exn_1)
          end end)
          return ty2; end end 
      return newvar(undefined, --[[ () ]]0);
        
    end
  end;
end end

function list_labels(env, ty) do
  return wrap_trace_gadt_instances(env, (function(param) do
                env_1 = env;
                _visited = --[[ [] ]]0;
                _ls = --[[ [] ]]0;
                _ty_fun = param;
                while(true) do
                  ty_fun = _ty_fun;
                  ls = _ls;
                  visited = _visited;
                  ty = expand_head(env_1, ty_fun);
                  if (List.memq(ty, visited)) then do
                    return --[[ tuple ]]{
                            List.rev(ls),
                            false
                          };
                  end else do
                    match = ty.desc;
                    if (typeof match == "number" or match.tag ~= --[[ Tarrow ]]1) then do
                      return --[[ tuple ]]{
                              List.rev(ls),
                              is_Tvar(ty)
                            };
                    end else do
                      _ty_fun = match[2];
                      _ls = --[[ :: ]]{
                        match[0],
                        ls
                      };
                      _visited = --[[ :: ]]{
                        ty,
                        visited
                      };
                      ::continue:: ;
                    end end 
                  end end 
                end;
              end end), ty);
end end

function check_univars(env, expans, kind, exp, ty_expected, vars) do
  if (expans and not is_nonexpansive(exp)) then do
    generalize_expansive_1(env, exp.exp_type);
  end
   end 
  vars_1 = List.map((function(param) do
          return expand_head(env, param);
        end end), vars);
  vars_2 = List.map((function(param) do
          return expand_head(env, param);
        end end), vars_1);
  vars$prime = List.filter((function(t) do
            t_1 = repr(t);
            iter_generalize_1(do
                  contents: --[[ [] ]]0
                end, t_1);
            match = t_1.desc;
            if (typeof match == "number" or match.tag or t_1.level ~= 100000000) then do
              return false;
            end else do
              log_type(t_1);
              t_1.desc = --[[ Tunivar ]]Block.__(9, {match[0]});
              return true;
            end end 
          end end))(vars_2);
  if (List.length(vars_2) == List.length(vars$prime)) then do
    return --[[ () ]]0;
  end else do
    ty = newty2(100000000, --[[ Tpoly ]]Block.__(10, {
            repr(exp.exp_type),
            vars$prime
          }));
    ty_expected_1 = repr(ty_expected);
    error({
      __Error_7,
      exp.exp_loc,
      env,
      --[[ Less_general ]]Block.__(31, {
          kind,
          --[[ :: ]]{
            --[[ tuple ]]{
              ty,
              ty
            },
            --[[ :: ]]{
              --[[ tuple ]]{
                ty_expected_1,
                ty_expected_1
              },
              --[[ [] ]]0
            }
          }
        })
    })
  end end 
end end

function check_application_result(env, statement, exp) do
  loc = exp.exp_loc;
  match = expand_head(env, exp.exp_type).desc;
  if (typeof match ~= "number") then do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 0--[[ Tvar ]] then do
          return --[[ () ]]0; end end 
       if ___conditional___ == 1--[[ Tarrow ]] then do
          return prerr_warning(exp.exp_loc, --[[ Partial_application ]]2); end end 
       if ___conditional___ == 3--[[ Tconstr ]] then do
          if (same(match[0], path_unit)) then do
            return --[[ () ]]0;
          end
           end  end else 
       end end
      
    end
  end
   end 
  if (statement) then do
    return prerr_warning(loc, --[[ Statement_type ]]4);
  end else do
    return 0;
  end end 
end end

function generalizable(level, ty) do
  check = function(ty) do
    ty_1 = repr(ty);
    if (ty_1.level < 0) then do
      return --[[ () ]]0;
    end else do
      if (ty_1.level <= level) then do
        error(Pervasives.Exit)
      end
       end 
      mark_type_node(ty_1);
      return iter_type_expr(check, ty_1);
    end end 
  end end;
  xpcall(function() do
    check(ty);
    unmark_type(ty);
    return true;
  end end,function(exn) do
    if (exn == Pervasives.Exit) then do
      unmark_type(ty);
      return false;
    end else do
      error(exn)
    end end 
  end end)
end end

self_coercion = do
  contents: --[[ [] ]]0
end;

function wrap_unpacks(sexp, unpacks) do
  return List.fold_left((function(sexp, param) do
                name = param[0];
                return Curry._5(Ast_helper_Exp.letmodule, sexp.pexp_loc, undefined, name, unpack_1(param[1], undefined, Curry._3(Ast_helper_Exp.ident, name.loc, undefined, do
                                    txt: --[[ Lident ]]Block.__(0, {name.txt}),
                                    loc: name.loc
                                  end)), sexp);
              end end), sexp, unpacks);
end end

function contains_variant_either(ty) do
  loop = function(ty) do
    ty_1 = repr(ty);
    if (ty_1.level >= 0) then do
      mark_type_node(ty_1);
      match = ty_1.desc;
      if (typeof match == "number" or match.tag ~= --[[ Tvariant ]]8) then do
        return iter_type_expr(loop, ty_1);
      end else do
        row = row_repr_aux(--[[ [] ]]0, match[0]);
        if (not row.row_fixed) then do
          List.iter((function(param) do
                  match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                  if (typeof match == "number" or not match.tag) then do
                    return --[[ () ]]0;
                  end else do
                    error(Pervasives.Exit)
                  end end 
                end end), row.row_fields);
        end
         end 
        return iter_row(loop, row);
      end end 
    end else do
      return 0;
    end end 
  end end;
  xpcall(function() do
    loop(ty);
    unmark_type(ty);
    return false;
  end end,function(exn) do
    if (exn == Pervasives.Exit) then do
      unmark_type(ty);
      return true;
    end else do
      error(exn)
    end end 
  end end)
end end

function iter_ppat(f, p) do
  match = p.ppat_desc;
  if (typeof match == "number") then do
    return --[[ () ]]0;
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 5--[[ Ppat_construct ]]
       or ___conditional___ == 6--[[ Ppat_variant ]] then do
          return may(f, match[1]); end end 
       if ___conditional___ == 7--[[ Ppat_record ]] then do
          return List.iter((function(param) do
                        return Curry._1(f, param[1]);
                      end end), match[0]); end end 
       if ___conditional___ == 4--[[ Ppat_tuple ]]
       or ___conditional___ == 8--[[ Ppat_array ]] then do
          return List.iter(f, match[0]); end end 
       if ___conditional___ == 9--[[ Ppat_or ]] then do
          Curry._1(f, match[0]);
          return Curry._1(f, match[1]); end end 
       if ___conditional___ == 1--[[ Ppat_alias ]]
       or ___conditional___ == 10--[[ Ppat_constraint ]]
       or ___conditional___ == 12--[[ Ppat_lazy ]]
       or ___conditional___ == 14--[[ Ppat_exception ]] then do
          return Curry._1(f, match[0]); end end 
      return --[[ () ]]0;
        
    end
  end end 
end end

function contains_polymorphic_variant(p) do
  loop = function(p) do
    match = p.ppat_desc;
    if (typeof match == "number") then do
      return iter_ppat(loop, p);
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 6--[[ Ppat_variant ]]
         or ___conditional___ == 11--[[ Ppat_type ]] then do
            error(Pervasives.Exit) end end 
        return iter_ppat(loop, p);
          
      end
    end end 
  end end;
  xpcall(function() do
    loop(p);
    return false;
  end end,function(exn) do
    if (exn == Pervasives.Exit) then do
      return true;
    end else do
      error(exn)
    end end 
  end end)
end end

function contains_gadt(env, p) do
  loop = function(p) do
    match = p.ppat_desc;
    if (typeof match == "number" or match.tag ~= --[[ Ppat_construct ]]5) then do
      return iter_ppat(loop, p);
    end else do
      xpcall(function() do
        cstrs = lookup_all_constructors_1(match[0].txt, env);
        List.iter((function(param) do
                if (param[0].cstr_generalized) then do
                  error(Pervasives.Exit)
                end else do
                  return 0;
                end end 
              end end), cstrs);
      end end,function(exn) do
        if (exn ~= Caml_builtin_exceptions.not_found) then do
          error(exn)
        end
         end 
      end end)
      return iter_ppat(loop, p);
    end end 
  end end;
  xpcall(function() do
    loop(p);
    return false;
  end end,function(exn) do
    if (exn == Pervasives.Exit) then do
      return true;
    end else do
      error(exn)
    end end 
  end end)
end end

function check_absent_variant(env) do
  return (function(param) do
      return iter_pattern((function(pat) do
                    match = pat.pat_desc;
                    if (typeof match == "number" or match.tag ~= --[[ Tpat_variant ]]5) then do
                      return --[[ () ]]0;
                    end else do
                      arg = match[1];
                      s = match[0];
                      row = row_repr_aux(--[[ [] ]]0, match[2].contents);
                      if (List.exists((function(param) do
                                if (s == param[0]) then do
                                  return row_field_repr_aux(--[[ [] ]]0, param[1]) ~= --[[ Rabsent ]]0;
                                end else do
                                  return false;
                                end end 
                              end end), row.row_fields) or not row.row_fixed and not static_row(row)) then do
                        return --[[ () ]]0;
                      end else do
                        ty_arg = arg ~= undefined and --[[ :: ]]{
                            type_expr(identity, arg.pat_type),
                            --[[ [] ]]0
                          } or --[[ [] ]]0;
                        row$prime_row_fields = --[[ :: ]]{
                          --[[ tuple ]]{
                            s,
                            --[[ Reither ]]Block.__(1, {
                                arg == undefined,
                                ty_arg,
                                true,
                                do
                                  contents: undefined
                                end
                              })
                          },
                          --[[ [] ]]0
                        };
                        row$prime_row_more = newvar(undefined, --[[ () ]]0);
                        row$prime = do
                          row_fields: row$prime_row_fields,
                          row_more: row$prime_row_more,
                          row_bound: --[[ () ]]0,
                          row_closed: false,
                          row_fixed: false,
                          row_name: undefined
                        end;
                        return unify_pat(env, do
                                    pat_desc: pat.pat_desc,
                                    pat_loc: pat.pat_loc,
                                    pat_extra: pat.pat_extra,
                                    pat_type: newty2(current_level.contents, --[[ Tvariant ]]Block.__(8, {row$prime})),
                                    pat_env: pat.pat_env,
                                    pat_attributes: pat.pat_attributes
                                  end, type_expr(identity, pat.pat_type));
                      end end 
                    end end 
                  end end), param);
    end end);
end end

function duplicate_ident_types(loc, caselist, env) do
  caselist_1 = List.filter((function(param) do
            return contains_gadt(env, param.pc_lhs);
          end end))(caselist);
  idents = all_idents_cases(caselist_1);
  return List.fold_left((function(env, s) do
                xpcall(function() do
                  match = lookup_value_1(--[[ Lident ]]Block.__(0, {s}), env);
                  desc = match[1];
                  path = match[0];
                  local ___conditional___=(path.tag | 0);
                  do
                     if ___conditional___ == 0--[[ Pident ]] then do
                        desc_val_type = type_expr(identity, desc.val_type);
                        desc_val_kind = desc.val_kind;
                        desc_val_loc = desc.val_loc;
                        desc_val_attributes = desc.val_attributes;
                        desc_1 = do
                          val_type: desc_val_type,
                          val_kind: desc_val_kind,
                          val_loc: desc_val_loc,
                          val_attributes: desc_val_attributes
                        end;
                        return add_value(undefined, path[0], desc_1, env); end end 
                     if ___conditional___ == 1--[[ Pdot ]]
                     or ___conditional___ == 2--[[ Papply ]] then do
                        return env; end end 
                    
                  end
                end end,function(exn) do
                  if (exn == Caml_builtin_exceptions.not_found) then do
                    return env;
                  end else do
                    error(exn)
                  end end 
                end end)
              end end), env, idents);
end end

function unify_exp(env, exp, expected_ty) do
  return unify_exp_types(exp.exp_loc, env, exp.exp_type, expected_ty);
end end

function type_exp(env, sexp) do
  return type_expect(undefined, env, sexp, newvar(undefined, --[[ () ]]0));
end end

function type_expect(in_function, env, sexp, ty_expected) do
  previous_saved_types = saved_types.contents;
  warning_enter_scope(--[[ () ]]0);
  warning_attribute(sexp.pexp_attributes);
  exp = type_expect_(in_function, env, sexp, ty_expected);
  warning_leave_scope(--[[ () ]]0);
  saved_types.contents = --[[ :: ]]{
    --[[ Partial_expression ]]Block.__(2, {exp}),
    previous_saved_types
  };
  return exp;
end end

function type_expect_(in_function, env, sexp, ty_expected) do
  loc = sexp.pexp_loc;
  rue = function(exp) do
    unify_exp(env, re(exp), instance(undefined, env, ty_expected));
    return exp;
  end end;
  match = sexp.pexp_desc;
  local ___conditional___=(match.tag | 0);
  do
     if ___conditional___ == 0--[[ Pexp_ident ]] then do
        lid = match[0];
        match_1 = find_value_1(env, loc, lid.txt);
        desc = match_1[1];
        path = match_1[0];
        if (annotations.contents) then do
          dloc = desc.val_loc;
          annot = dloc.loc_ghost and --[[ Iref_external ]]0 or --[[ Iref_internal ]]Block.__(0, {dloc});
          name_1 = name(parenthesized_ident, path);
          record_2(--[[ An_ident ]]Block.__(5, {
                  loc,
                  name_1,
                  annot
                }));
        end
         end 
        match_2 = desc.val_kind;
        tmp;
        if (typeof match_2 == "number") then do
          if (match_2 == --[[ Val_unbound ]]1) then do
            error({
              __Error_7,
              loc,
              env,
              --[[ Masked_instance_variable ]]Block.__(29, {lid.txt})
            })
          end else do
            tmp = --[[ Texp_ident ]]Block.__(0, {
                path,
                lid,
                desc
              });
          end end 
        end else do
          local ___conditional___=(match_2.tag | 0);
          do
             if ___conditional___ == 1--[[ Val_ivar ]] then do
                match_3 = lookup_value_1(--[[ Lident ]]Block.__(0, {"self-" .. match_2[1]}), env);
                match_4 = lid.txt;
                tmp_1;
                local ___conditional___=(match_4.tag | 0);
                do
                   if ___conditional___ == 0--[[ Lident ]] then do
                      tmp_1 = do
                        txt: match_4[0],
                        loc: lid.loc
                      end; end else 
                   if ___conditional___ == 1--[[ Ldot ]]
                   or ___conditional___ == 2--[[ Lapply ]] then do
                      error({
                        Caml_builtin_exceptions.assert_failure,
                        --[[ tuple ]]{
                          "typecore.ml",
                          1773,
                          38
                        }
                      }) end end end end 
                  
                end
                tmp = --[[ Texp_instvar ]]Block.__(20, {
                    match_3[0],
                    path,
                    tmp_1
                  }); end else 
             if ___conditional___ == 2--[[ Val_self ]] then do
                match_5 = lookup_value_1(--[[ Lident ]]Block.__(0, {"self-" .. match_2[2]}), env);
                tmp = --[[ Texp_ident ]]Block.__(0, {
                    match_5[0],
                    lid,
                    desc
                  }); end else 
             end end end end
            tmp = --[[ Texp_ident ]]Block.__(0, {
                  path,
                  lid,
                  desc
                });
              
          end
        end end 
        return rue(do
                    exp_desc: tmp,
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: instance(undefined, env, desc.val_type),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end); end end 
     if ___conditional___ == 1--[[ Pexp_constant ]] then do
        cst = match[0];
        if (cst.tag == --[[ Const_string ]]2) then do
          ty_exp = expand_head(env, ty_expected);
          fmt6_path_000 = --[[ Pident ]]Block.__(0, {do
                stamp: 0,
                name: "CamlinternalFormatBasics",
                flags: 1
              end});
          fmt6_path = --[[ Pdot ]]Block.__(1, {
              fmt6_path_000,
              "format6",
              0
            });
          match_6 = ty_exp.desc;
          is_format;
          if (typeof match_6 == "number" or not (match_6.tag == --[[ Tconstr ]]3 and same(match_6[0], fmt6_path))) then do
            is_format = false;
          end else do
            if (principal.contents and ty_exp.level ~= 100000000) then do
              prerr_warning(loc, --[[ Not_principal ]]Block.__(8, {"this coercion to format6"}));
            end
             end 
            is_format = true;
          end end 
          if (is_format) then do
            init = type_format(loc, cst[0], env);
            format_parsetree_pexp_desc = init.pexp_desc;
            format_parsetree_pexp_loc = sexp.pexp_loc;
            format_parsetree_pexp_attributes = init.pexp_attributes;
            format_parsetree = do
              pexp_desc: format_parsetree_pexp_desc,
              pexp_loc: format_parsetree_pexp_loc,
              pexp_attributes: format_parsetree_pexp_attributes
            end;
            return type_expect(in_function, env, format_parsetree, ty_expected);
          end else do
            return rue(do
                        exp_desc: --[[ Texp_constant ]]Block.__(1, {cst}),
                        exp_loc: loc,
                        exp_extra: --[[ [] ]]0,
                        exp_type: instance_def(type_string),
                        exp_env: env,
                        exp_attributes: sexp.pexp_attributes
                      end);
          end end 
        end else do
          return rue(do
                      exp_desc: --[[ Texp_constant ]]Block.__(1, {cst}),
                      exp_loc: loc,
                      exp_extra: --[[ [] ]]0,
                      exp_type: type_constant(cst),
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    end);
        end end  end end 
     if ___conditional___ == 2--[[ Pexp_let ]] then do
        rec_flag = match[0];
        exit = 0;
        if (rec_flag) then do
          exit = 1;
        end else do
          match_7 = match[1];
          if (match_7) then do
            match_8 = match_7[0];
            if (match_8.pvb_attributes or match_7[1]) then do
              exit = 1;
            end else do
              spat = match_8.pvb_pat;
              if (contains_gadt(env, spat)) then do
                return type_expect(in_function, env, do
                            pexp_desc: --[[ Pexp_match ]]Block.__(6, {
                                match_8.pvb_expr,
                                --[[ :: ]]{
                                  Curry._3(Ast_helper_Exp.__case, spat, undefined, match[2]),
                                  --[[ [] ]]0
                                }
                              }),
                            pexp_loc: sexp.pexp_loc,
                            pexp_attributes: sexp.pexp_attributes
                          end, ty_expected);
              end else do
                exit = 1;
              end end 
            end end 
          end else do
            exit = 1;
          end end 
        end end 
        if (exit == 1) then do
          sbody = match[2];
          match_9 = sexp.pexp_attributes;
          scp;
          exit_1 = 0;
          if (match_9 and match_9[0][0].txt == "#default" and not match_9[1]) then do
            scp = undefined;
          end else do
            exit_1 = 2;
          end end 
          if (exit_1 == 2) then do
            scp = rec_flag and --[[ Idef ]]Block.__(1, {loc}) or --[[ Idef ]]Block.__(1, {sbody.pexp_loc});
          end
           end 
          match_10 = type_let(undefined, undefined, env, rec_flag, match[1], scp, true);
          body = type_expect(undefined, match_10[1], wrap_unpacks(sbody, match_10[2]), ty_expected);
          return re(do
                      exp_desc: --[[ Texp_let ]]Block.__(2, {
                          rec_flag,
                          match_10[0],
                          body
                        }),
                      exp_loc: loc,
                      exp_extra: --[[ [] ]]0,
                      exp_type: body.exp_type,
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    end);
        end
         end  end else 
     if ___conditional___ == 3--[[ Pexp_function ]] then do
        return type_function(in_function, loc, sexp.pexp_attributes, env, ty_expected, "", match[0]); end end end end 
     if ___conditional___ == 4--[[ Pexp_fun ]] then do
        match_11 = match[1];
        l = match[0];
        if (match_11 ~= undefined) then do
          __default = match_11;
          if (not is_optional(l)) then do
            error({
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "typecore.ml",
                1852,
                6
              }
            })
          end
           end 
          default_loc = __default.pexp_loc;
          scases_000 = Curry._3(Ast_helper_Exp.__case, construct(default_loc, undefined, do
                    txt: --[[ Ldot ]]Block.__(1, {
                        --[[ Lident ]]Block.__(0, {"*predef*"}),
                        "Some"
                      }),
                    loc: none
                  end, __var_1(default_loc, undefined, do
                        txt: "*sth*",
                        loc: none
                      end)), undefined, Curry._3(Ast_helper_Exp.ident, default_loc, undefined, do
                    txt: --[[ Lident ]]Block.__(0, {"*sth*"}),
                    loc: none
                  end));
          scases_001 = --[[ :: ]]{
            Curry._3(Ast_helper_Exp.__case, construct(default_loc, undefined, do
                      txt: --[[ Ldot ]]Block.__(1, {
                          --[[ Lident ]]Block.__(0, {"*predef*"}),
                          "None"
                        }),
                      loc: none
                    end, undefined), undefined, __default),
            --[[ [] ]]0
          };
          scases = --[[ :: ]]{
            scases_000,
            scases_001
          };
          smatch = Curry._4(Ast_helper_Exp.match_, loc, undefined, Curry._3(Ast_helper_Exp.ident, loc, undefined, do
                    txt: --[[ Lident ]]Block.__(0, {"*opt*"}),
                    loc: none
                  end), scases);
          sfun = Curry._6(Ast_helper_Exp.fun_, loc, undefined, l, undefined, __var_1(loc, undefined, do
                    txt: "*opt*",
                    loc: none
                  end), Curry._5(Ast_helper_Exp.let_, loc, --[[ :: ]]{
                    --[[ tuple ]]{
                      do
                        txt: "#default",
                        loc: none
                      end,
                      --[[ PStr ]]Block.__(0, {--[[ [] ]]0})
                    },
                    --[[ [] ]]0
                  }, --[[ Nonrecursive ]]0, --[[ :: ]]{
                    mk_17(undefined, undefined, undefined, undefined, match[2], smatch),
                    --[[ [] ]]0
                  }, match[3]));
          return type_expect(in_function, env, sfun, ty_expected);
        end else do
          sexp_1 = match[3];
          return type_function(in_function, loc, sexp_1.pexp_attributes, env, ty_expected, l, --[[ :: ]]{
                      do
                        pc_lhs: match[2],
                        pc_guard: undefined,
                        pc_rhs: sexp_1
                      end,
                      --[[ [] ]]0
                    });
        end end  end end 
     if ___conditional___ == 5--[[ Pexp_apply ]] then do
        sargs = match[1];
        if (sargs == --[[ [] ]]0) then do
          ill_formed_ast(loc, "Function application with no argument.");
        end
         end 
        begin_def(--[[ () ]]0);
        if (principal.contents) then do
          begin_def(--[[ () ]]0);
        end
         end 
        funct = type_exp(env, match[0]);
        if (principal.contents) then do
          end_def(--[[ () ]]0);
          generalize_structure_1(current_level.contents, funct.exp_type);
        end
         end 
        ty = instance(undefined, env, funct.exp_type);
        end_def(--[[ () ]]0);
        wrap_trace_gadt_instances(env, (function(param) do
                _seen = --[[ [] ]]0;
                _ty_fun = param;
                while(true) do
                  ty_fun = _ty_fun;
                  seen = _seen;
                  ty = expand_head(env, ty_fun);
                  if (List.memq(ty, seen)) then do
                    return --[[ () ]]0;
                  end else do
                    match = ty.desc;
                    if (typeof match == "number" or match.tag ~= --[[ Tarrow ]]1) then do
                      return --[[ () ]]0;
                    end else do
                      xpcall(function() do
                        unify_var(env, newvar(undefined, --[[ () ]]0), match[1]);
                      end end,function(raw_exn) do
                        exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                        if (exn[0] == Unify) then do
                          error({
                            Caml_builtin_exceptions.assert_failure,
                            --[[ tuple ]]{
                              "typecore.ml",
                              1903,
                              65
                            }
                          })
                        end
                         end 
                        error(exn)
                      end end)
                      _ty_fun = match[2];
                      _seen = --[[ :: ]]{
                        ty,
                        seen
                      };
                      ::continue:: ;
                    end end 
                  end end 
                end;
              end end), ty);
        begin_def(--[[ () ]]0);
        match_12 = type_application(env, funct, sargs);
        end_def(--[[ () ]]0);
        unify_var(env, newvar(undefined, --[[ () ]]0), funct.exp_type);
        return rue(do
                    exp_desc: --[[ Texp_apply ]]Block.__(4, {
                        funct,
                        match_12[0]
                      }),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: match_12[1],
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end); end end 
     if ___conditional___ == 6--[[ Pexp_match ]] then do
        begin_def(--[[ () ]]0);
        arg = type_exp(env, match[0]);
        end_def(--[[ () ]]0);
        if (is_nonexpansive(arg)) then do
          iter_generalize_1(do
                contents: --[[ [] ]]0
              end, arg.exp_type);
        end else do
          generalize_expansive_1(env, arg.exp_type);
        end end 
        split_cases = function(_vc, _ec, _param) do
          while(true) do
            param = _param;
            ec = _ec;
            vc = _vc;
            if (param) then do
              c = param[0];
              match = c.pc_lhs.ppat_desc;
              if (typeof match ~= "number" and match.tag == --[[ Ppat_exception ]]14) then do
                _param = param[1];
                _ec = --[[ :: ]]{
                  do
                    pc_lhs: match[0],
                    pc_guard: c.pc_guard,
                    pc_rhs: c.pc_rhs
                  end,
                  ec
                };
                ::continue:: ;
              end
               end 
              _param = param[1];
              _vc = --[[ :: ]]{
                c,
                vc
              };
              ::continue:: ;
            end else do
              return --[[ tuple ]]{
                      List.rev(vc),
                      List.rev(ec)
                    };
            end end 
          end;
        end end;
        match_13 = split_cases(--[[ [] ]]0, --[[ [] ]]0, match[1]);
        exn_caselist = match_13[1];
        val_caselist = match_13[0];
        if (val_caselist == --[[ [] ]]0 and exn_caselist ~= --[[ [] ]]0) then do
          error({
            __Error_7,
            loc,
            env,
            --[[ No_value_clauses ]]7
          })
        end
         end 
        match_14 = type_cases(undefined, env, arg.exp_type, ty_expected, true, loc, val_caselist);
        match_15 = type_cases(undefined, env, type_exn, ty_expected, false, loc, exn_caselist);
        return re(do
                    exp_desc: --[[ Texp_match ]]Block.__(5, {
                        arg,
                        match_14[0],
                        match_15[0],
                        match_14[1]
                      }),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: instance(undefined, env, ty_expected),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end); end end 
     if ___conditional___ == 7--[[ Pexp_try ]] then do
        body_1 = type_expect(undefined, env, match[0], ty_expected);
        match_16 = type_cases(undefined, env, type_exn, ty_expected, false, loc, match[1]);
        return re(do
                    exp_desc: --[[ Texp_try ]]Block.__(6, {
                        body_1,
                        match_16[0]
                      }),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: body_1.exp_type,
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end); end end 
     if ___conditional___ == 8--[[ Pexp_tuple ]] then do
        sexpl = match[0];
        if (List.length(sexpl) < 2) then do
          ill_formed_ast(loc, "Tuples must have at least 2 components.");
        end
         end 
        subtypes = List.map((function(param) do
                return newty2(100000000, --[[ Tvar ]]Block.__(0, {undefined}));
              end end), sexpl);
        to_unify = newty2(100000000, --[[ Ttuple ]]Block.__(2, {subtypes}));
        unify_exp_types(loc, env, to_unify, ty_expected);
        expl = List.map2((function(body, ty) do
                return type_expect(undefined, env, body, ty);
              end end), sexpl, subtypes);
        desc_1 = --[[ Ttuple ]]Block.__(2, {List.map((function(e) do
                    return e.exp_type;
                  end end), expl)});
        return re(do
                    exp_desc: --[[ Texp_tuple ]]Block.__(7, {expl}),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: newty2(current_level.contents, desc_1),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end); end end 
     if ___conditional___ == 9--[[ Pexp_construct ]] then do
        env_1 = env;
        loc_1 = loc;
        lid_1 = match[0];
        sarg = match[1];
        ty_expected_1 = ty_expected;
        attrs = sexp.pexp_attributes;
        opath;
        xpcall(function() do
          match_17 = extract_concrete_variant(env_1, ty_expected_1);
          opath = --[[ tuple ]]{
            match_17[0],
            match_17[1],
            ty_expected_1.level == 100000000 or not principal.contents
          };
        end end,function(exn) do
          if (exn == Caml_builtin_exceptions.not_found) then do
            opath = undefined;
          end else do
            error(exn)
          end end 
        end end)
        constrs = find_all_constructors(env_1, lid_1.loc, lid_1.txt);
        constr = wrap_disambiguate("This variant expression is expected to have", ty_expected_1, (function(param) do
                return disambiguate_1(undefined, undefined, undefined, lid_1, env_1, opath, param);
              end end), constrs);
        mark_constructor(--[[ Positive ]]0, env_1, last_1(lid_1.txt), constr);
        check_deprecated(loc_1, constr.cstr_attributes, constr.cstr_name);
        sargs_1;
        if (sarg ~= undefined) then do
          se = sarg;
          match_18 = se.pexp_desc;
          sargs_1 = match_18.tag == --[[ Pexp_tuple ]]8 and (constr.cstr_arity > 1 or explicit_arity(attrs)) and match_18[0] or --[[ :: ]]{
              se,
              --[[ [] ]]0
            };
        end else do
          sargs_1 = --[[ [] ]]0;
        end end 
        if (List.length(sargs_1) ~= constr.cstr_arity) then do
          error({
            __Error_7,
            loc_1,
            env_1,
            --[[ Constructor_arity_mismatch ]]Block.__(1, {
                lid_1.txt,
                constr.cstr_arity,
                List.length(sargs_1)
              })
          })
        end
         end 
        separate = principal.contents or env_1.local_constraints;
        if (separate) then do
          begin_def(--[[ () ]]0);
          begin_def(--[[ () ]]0);
        end
         end 
        match_19 = instance_constructor(undefined, constr);
        ty_res = match_19[1];
        ty_args = match_19[0];
        texp = re(do
              exp_desc: --[[ Texp_construct ]]Block.__(8, {
                  lid_1,
                  constr,
                  --[[ [] ]]0
                }),
              exp_loc: loc_1,
              exp_extra: --[[ [] ]]0,
              exp_type: ty_res,
              exp_env: env_1,
              exp_attributes: attrs
            end);
        if (separate) then do
          end_def(--[[ () ]]0);
          generalize_structure_1(current_level.contents, ty_res);
          unify_exp(env_1, do
                exp_desc: texp.exp_desc,
                exp_loc: texp.exp_loc,
                exp_extra: texp.exp_extra,
                exp_type: instance_def(ty_res),
                exp_env: texp.exp_env,
                exp_attributes: texp.exp_attributes
              end, instance(undefined, env_1, ty_expected_1));
          end_def(--[[ () ]]0);
          List.iter(generalize_structure_2, ty_args);
          generalize_structure_1(current_level.contents, ty_res);
        end
         end 
        match_20 = instance_list(env_1, --[[ :: ]]{
              ty_res,
              ty_args
            });
        match_21;
        if (match_20) then do
          match_21 = --[[ tuple ]]{
            match_20[1],
            match_20[0]
          };
        end else do
          error({
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "typecore.ml",
              3375,
              11
            }
          })
        end end 
        ty_res_1 = match_21[1];
        texp_exp_desc = texp.exp_desc;
        texp_exp_loc = texp.exp_loc;
        texp_exp_extra = texp.exp_extra;
        texp_exp_env = texp.exp_env;
        texp_exp_attributes = texp.exp_attributes;
        texp_1 = do
          exp_desc: texp_exp_desc,
          exp_loc: texp_exp_loc,
          exp_extra: texp_exp_extra,
          exp_type: ty_res_1,
          exp_env: texp_exp_env,
          exp_attributes: texp_exp_attributes
        end;
        if (not separate) then do
          unify_exp(env_1, texp_1, instance(undefined, env_1, ty_expected_1));
        end
         end 
        args = List.map2((function(e, param) do
                return type_argument(env_1, e, param[0], param[1]);
              end end), sargs_1, List.combine(ty_args, match_21[0]));
        if (constr.cstr_private == --[[ Private ]]0) then do
          error({
            __Error_7,
            loc_1,
            env_1,
            --[[ Private_type ]]Block.__(19, {ty_res_1})
          })
        end
         end 
        return do
                exp_desc: --[[ Texp_construct ]]Block.__(8, {
                    lid_1,
                    constr,
                    args
                  }),
                exp_loc: texp_exp_loc,
                exp_extra: texp_exp_extra,
                exp_type: ty_res_1,
                exp_env: texp_exp_env,
                exp_attributes: texp_exp_attributes
              end; end end 
     if ___conditional___ == 10--[[ Pexp_variant ]] then do
        sarg_1 = match[1];
        l_1 = match[0];
        ty_expected0 = instance(undefined, env, ty_expected);
        xpcall(function() do
          match_22 = expand_head(env, ty_expected);
          match_23 = expand_head(env, ty_expected0);
          if (sarg_1 ~= undefined) then do
            match_24 = match_22.desc;
            if (typeof match_24 == "number") then do
              error(Caml_builtin_exceptions.not_found)
            end else if (match_24.tag == --[[ Tvariant ]]8) then do
              match_25 = match_23.desc;
              if (typeof match_25 == "number") then do
                error(Caml_builtin_exceptions.not_found)
              end else if (match_25.tag == --[[ Tvariant ]]8) then do
                row = row_repr_aux(--[[ [] ]]0, match_24[0]);
                match_26 = row_field_repr_aux(--[[ [] ]]0, List.assoc(l_1, row.row_fields));
                match_27 = row_field_repr_aux(--[[ [] ]]0, List.assoc(l_1, match_25[0].row_fields));
                if (typeof match_26 == "number") then do
                  error(Caml_builtin_exceptions.not_found)
                end else if (match_26.tag) then do
                  error(Caml_builtin_exceptions.not_found)
                end else do
                  match_28 = match_26[0];
                  if (match_28 ~= undefined) then do
                    if (typeof match_27 == "number") then do
                      error(Caml_builtin_exceptions.not_found)
                    end else if (match_27.tag) then do
                      error(Caml_builtin_exceptions.not_found)
                    end else do
                      match_29 = match_27[0];
                      if (match_29 ~= undefined) then do
                        arg_1 = type_argument(env, sarg_1, match_28, match_29);
                        return re(do
                                    exp_desc: --[[ Texp_variant ]]Block.__(9, {
                                        l_1,
                                        arg_1
                                      }),
                                    exp_loc: loc,
                                    exp_extra: --[[ [] ]]0,
                                    exp_type: ty_expected0,
                                    exp_env: env,
                                    exp_attributes: sexp.pexp_attributes
                                  end);
                      end else do
                        error(Caml_builtin_exceptions.not_found)
                      end end 
                    end end  end 
                  end else do
                    error(Caml_builtin_exceptions.not_found)
                  end end 
                end end  end 
              end else do
                error(Caml_builtin_exceptions.not_found)
              end end  end 
            end else do
              error(Caml_builtin_exceptions.not_found)
            end end  end 
          end else do
            error(Caml_builtin_exceptions.not_found)
          end end 
        end end,function(exn_1) do
          if (exn_1 == Caml_builtin_exceptions.not_found) then do
            arg_2 = may_map((function(param) do
                    return type_exp(env, param);
                  end end), sarg_1);
            arg_type = may_map((function(arg) do
                    return arg.exp_type;
                  end end), arg_2);
            desc_2 = --[[ Tvariant ]]Block.__(8, {do
                  row_fields: --[[ :: ]]{
                    --[[ tuple ]]{
                      l_1,
                      --[[ Rpresent ]]Block.__(0, {arg_type})
                    },
                    --[[ [] ]]0
                  },
                  row_more: newvar(undefined, --[[ () ]]0),
                  row_bound: --[[ () ]]0,
                  row_closed: false,
                  row_fixed: false,
                  row_name: undefined
                end});
            return rue(do
                        exp_desc: --[[ Texp_variant ]]Block.__(9, {
                            l_1,
                            arg_2
                          }),
                        exp_loc: loc,
                        exp_extra: --[[ [] ]]0,
                        exp_type: newty2(current_level.contents, desc_2),
                        exp_env: env,
                        exp_attributes: sexp.pexp_attributes
                      end);
          end else do
            error(exn_1)
          end end 
        end end) end end 
     if ___conditional___ == 11--[[ Pexp_record ]] then do
        opt_sexp = match[1];
        lid_sexp_list = match[0];
        if (lid_sexp_list == --[[ [] ]]0) then do
          ill_formed_ast(loc, "Records cannot be empty.");
        end
         end 
        opt_exp;
        if (opt_sexp ~= undefined) then do
          if (principal.contents) then do
            begin_def(--[[ () ]]0);
          end
           end 
          exp = type_exp(env, opt_sexp);
          if (principal.contents) then do
            end_def(--[[ () ]]0);
            generalize_structure_1(current_level.contents, exp.exp_type);
          end
           end 
          opt_exp = exp;
        end else do
          opt_exp = undefined;
        end end 
        get_path = function(ty) do
          xpcall(function() do
            match = extract_concrete_record(env, ty);
            return --[[ tuple ]]{
                    match[0],
                    match[1],
                    ty.level == 100000000 or not principal.contents
                  };
          end end,function(exn) do
            if (exn == Caml_builtin_exceptions.not_found) then do
              return ;
            end else do
              error(exn)
            end end 
          end end)
        end end;
        op = get_path(ty_expected);
        match_30;
        if (op ~= undefined) then do
          match_30 = --[[ tuple ]]{
            ty_expected,
            op
          };
        end else if (opt_exp ~= undefined) then do
          op_1 = get_path(opt_exp.exp_type);
          if (op_1 ~= undefined) then do
            p$prime = op_1[1];
            decl = find_type_full(p$prime, env)[0];
            begin_def(--[[ () ]]0);
            ty_1 = newconstr(p$prime, instance_list(env, decl.type_params));
            end_def(--[[ () ]]0);
            generalize_structure_1(current_level.contents, ty_1);
            match_30 = --[[ tuple ]]{
              ty_1,
              op_1
            };
          end else do
            match_30 = --[[ tuple ]]{
              newvar(undefined, --[[ () ]]0),
              undefined
            };
          end end 
        end else do
          match_30 = --[[ tuple ]]{
            newvar(undefined, --[[ () ]]0),
            undefined
          };
        end end  end 
        opath_1 = match_30[1];
        ty_record = match_30[0];
        closed = opt_sexp == undefined;
        lbl_exp_list = wrap_disambiguate("This record expression is expected to have", ty_record, (function(param) do
                return type_label_a_list(undefined, loc, closed, env, (function(param) do
                              return type_label_exp(true, env, loc, ty_record, param);
                            end end), opath_1, param);
              end end), lid_sexp_list);
        unify_exp_types(loc, env, ty_record, instance(undefined, env, ty_expected));
        check_duplicates = function(_param) do
          while(true) do
            param = _param;
            if (param) then do
              rem = param[1];
              lbl1 = param[0][1];
              if (rem) then do
                if (lbl1.lbl_pos == rem[0][1].lbl_pos) then do
                  error({
                    __Error_7,
                    loc,
                    env,
                    --[[ Label_multiply_defined ]]Block.__(10, {lbl1.lbl_name})
                  })
                end
                 end 
                _param = rem;
                ::continue:: ;
              end else do
                _param = rem;
                ::continue:: ;
              end end 
            end else do
              return --[[ () ]]0;
            end end 
          end;
        end end;
        check_duplicates(lbl_exp_list);
        opt_exp_1;
        if (opt_exp ~= undefined) then do
          if (lbl_exp_list) then do
            exp_1 = opt_exp;
            ty_exp_1 = instance(undefined, env, exp_1.exp_type);
            unify_kept = function(lbl) do
              if (List.for_all((function(param) do
                        return param[1].lbl_pos ~= lbl.lbl_pos;
                      end end), lbl_exp_list)) then do
                match = instance_label(false, lbl);
                match_1 = instance_label(false, lbl);
                unify_2(env, match[1], match_1[1]);
                unify_2(env, instance(undefined, env, ty_expected), match_1[2]);
                return unify_exp_types(exp_1.exp_loc, env, ty_exp_1, match[2]);
              end else do
                return 0;
              end end 
            end end;
            __Array.iter(unify_kept, lbl_exp_list[0][1].lbl_all);
            opt_exp_1 = do
              exp_desc: exp_1.exp_desc,
              exp_loc: exp_1.exp_loc,
              exp_extra: exp_1.exp_extra,
              exp_type: ty_exp_1,
              exp_env: exp_1.exp_env,
              exp_attributes: exp_1.exp_attributes
            end;
          end else do
            error({
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "typecore.ml",
                2092,
                15
              }
            })
          end end 
        end else do
          opt_exp_1 = undefined;
        end end 
        num_fields;
        if (lbl_exp_list) then do
          num_fields = #lbl_exp_list[0][1].lbl_all;
        end else do
          error({
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "typecore.ml",
              2095,
              38
            }
          })
        end end 
        if (opt_sexp == undefined and List.length(lid_sexp_list) ~= num_fields) then do
          present_indices = List.map((function(param) do
                  return param[1].lbl_pos;
                end end), lbl_exp_list);
          label_names = extract_label_names(sexp, env, ty_expected);
          missing_labels = function(_n, _param) do
            while(true) do
              param = _param;
              n = _n;
              if (param) then do
                rem = param[1];
                if (List.mem(n, present_indices)) then do
                  _param = rem;
                  _n = n + 1 | 0;
                  ::continue:: ;
                end else do
                  return --[[ :: ]]{
                          param[0],
                          missing_labels(n + 1 | 0, rem)
                        };
                end end 
              end else do
                return --[[ [] ]]0;
              end end 
            end;
          end end;
          missing = missing_labels(0, label_names);
          error({
            __Error_7,
            loc,
            env,
            --[[ Label_missing ]]Block.__(11, {missing})
          })
        end else if (opt_sexp ~= undefined and List.length(lid_sexp_list) == num_fields) then do
          prerr_warning(loc, --[[ Useless_record_with ]]11);
        end
         end  end 
        return re(do
                    exp_desc: --[[ Texp_record ]]Block.__(10, {
                        lbl_exp_list,
                        opt_exp_1
                      }),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: instance(undefined, env, ty_expected),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end); end end 
     if ___conditional___ == 12--[[ Pexp_field ]] then do
        lid_2 = match[1];
        match_31 = type_label_access(env, loc, match[0], lid_2);
        label = match_31[1];
        record_3 = match_31[0];
        match_32 = instance_label(false, label);
        unify_exp(env, record_3, match_32[2]);
        return rue(do
                    exp_desc: --[[ Texp_field ]]Block.__(11, {
                        record_3,
                        lid_2,
                        label
                      }),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: match_32[1],
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end); end end 
     if ___conditional___ == 13--[[ Pexp_setfield ]] then do
        lid_3 = match[1];
        match_33 = type_label_access(env, loc, match[0], lid_3);
        record_4 = match_33[0];
        ty_record_1 = match_33[2] == undefined and newvar(undefined, --[[ () ]]0) or record_4.exp_type;
        match_34 = type_label_exp(false, env, loc, ty_record_1, --[[ tuple ]]{
              lid_3,
              match_33[1],
              match[2]
            });
        label_1 = match_34[1];
        unify_exp(env, record_4, ty_record_1);
        if (label_1.lbl_mut == --[[ Immutable ]]0) then do
          error({
            __Error_7,
            loc,
            env,
            --[[ Label_not_mutable ]]Block.__(12, {lid_3.txt})
          })
        end
         end 
        return rue(do
                    exp_desc: --[[ Texp_setfield ]]Block.__(12, {
                        record_4,
                        match_34[0],
                        label_1,
                        match_34[2]
                      }),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: instance_def(type_unit),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end); end end 
     if ___conditional___ == 14--[[ Pexp_array ]] then do
        ty_2 = newty2(100000000, --[[ Tvar ]]Block.__(0, {undefined}));
        to_unify_1 = type_array(ty_2);
        unify_exp_types(loc, env, to_unify_1, ty_expected);
        argl = List.map((function(sarg) do
                return type_expect(undefined, env, sarg, ty_2);
              end end), match[0]);
        return re(do
                    exp_desc: --[[ Texp_array ]]Block.__(13, {argl}),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: instance(undefined, env, ty_expected),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end); end end 
     if ___conditional___ == 15--[[ Pexp_ifthenelse ]] then do
        sifnot = match[2];
        sifso = match[1];
        cond = type_expect(undefined, env, match[0], type_bool);
        if (sifnot ~= undefined) then do
          ifso = type_expect(undefined, env, sifso, ty_expected);
          ifnot = type_expect(undefined, env, sifnot, ty_expected);
          unify_exp(env, ifnot, ifso.exp_type);
          return re(do
                      exp_desc: --[[ Texp_ifthenelse ]]Block.__(14, {
                          cond,
                          ifso,
                          ifnot
                        }),
                      exp_loc: loc,
                      exp_extra: --[[ [] ]]0,
                      exp_type: ifso.exp_type,
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    end);
        end else do
          ifso_1 = type_expect(undefined, env, sifso, type_unit);
          return rue(do
                      exp_desc: --[[ Texp_ifthenelse ]]Block.__(14, {
                          cond,
                          ifso_1,
                          undefined
                        }),
                      exp_loc: loc,
                      exp_extra: --[[ [] ]]0,
                      exp_type: ifso_1.exp_type,
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    end);
        end end  end end 
     if ___conditional___ == 16--[[ Pexp_sequence ]] then do
        exp1 = type_statement(env, match[0]);
        exp2 = type_expect(undefined, env, match[1], ty_expected);
        return re(do
                    exp_desc: --[[ Texp_sequence ]]Block.__(15, {
                        exp1,
                        exp2
                      }),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: exp2.exp_type,
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end); end end 
     if ___conditional___ == 17--[[ Pexp_while ]] then do
        cond_1 = type_expect(undefined, env, match[0], type_bool);
        body_2 = type_statement(env, match[1]);
        return rue(do
                    exp_desc: --[[ Texp_while ]]Block.__(16, {
                        cond_1,
                        body_2
                      }),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: instance_def(type_unit),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end); end end 
     if ___conditional___ == 18--[[ Pexp_for ]] then do
        param = match[0];
        low = type_expect(undefined, env, match[1], type_int);
        high = type_expect(undefined, env, match[2], type_int);
        match_35 = param.ppat_desc;
        match_36;
        if (typeof match_35 == "number") then do
          match_36 = --[[ tuple ]]{
            create("_for"),
            env
          };
        end else if (match_35.tag) then do
          error({
            __Error_7,
            param.ppat_loc,
            env,
            --[[ Invalid_for_loop_index ]]6
          })
        end else do
          match_36 = enter_value((function(s) do
                    return --[[ Unused_for_index ]]Block.__(19, {s});
                  end end))(match_35[0].txt, do
                val_type: instance_def(type_int),
                val_kind: --[[ Val_reg ]]0,
                val_loc: loc,
                val_attributes: --[[ [] ]]0
              end, env);
        end end  end 
        body_3 = type_statement(match_36[1], match[4]);
        return rue(do
                    exp_desc: --[[ Texp_for ]]Block.__(17, {
                        match_36[0],
                        param,
                        low,
                        high,
                        match[3],
                        body_3
                      }),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: instance_def(type_unit),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end); end end 
     if ___conditional___ == 19--[[ Pexp_constraint ]] then do
        sarg_2 = match[0];
        begin_def(--[[ () ]]0);
        cty = transl_simple_type(env, false, match[1]);
        ty_3 = cty.ctyp_type;
        end_def(--[[ () ]]0);
        generalize_structure_1(current_level.contents, ty_3);
        match_000 = type_argument(env, sarg_2, ty_3, instance(undefined, env, ty_3));
        match_001 = instance(undefined, env, ty_3);
        arg_3 = match_000;
        return rue(do
                    exp_desc: arg_3.exp_desc,
                    exp_loc: arg_3.exp_loc,
                    exp_extra: --[[ :: ]]{
                      --[[ tuple ]]{
                        --[[ Texp_constraint ]]Block.__(0, {cty}),
                        loc,
                        sexp.pexp_attributes
                      },
                      arg_3.exp_extra
                    },
                    exp_type: match_001,
                    exp_env: env,
                    exp_attributes: arg_3.exp_attributes
                  end); end end 
     if ___conditional___ == 20--[[ Pexp_coerce ]] then do
        sty$prime = match[2];
        sty = match[1];
        sarg_3 = match[0];
        match_37;
        if (sty ~= undefined) then do
          begin_def(--[[ () ]]0);
          match_38 = transl_simple_type_delayed(env, sty);
          cty_1 = match_38[0];
          match_39 = transl_simple_type_delayed(env, sty$prime);
          cty$prime = match_39[0];
          ty_4 = cty_1.ctyp_type;
          ty$prime = cty$prime.ctyp_type;
          xpcall(function() do
            force$prime$prime = subtype(env, ty_4, ty$prime);
            Curry._1(match_38[1], --[[ () ]]0);
            Curry._1(match_39[1], --[[ () ]]0);
            Curry._1(force$prime$prime, --[[ () ]]0);
          end end,function(raw_exn) do
            exn_2 = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn_2[0] == Subtype) then do
              error({
                __Error_7,
                loc,
                env,
                --[[ Not_subtype ]]Block.__(23, {
                    exn_2[1],
                    exn_2[2]
                  })
              })
            end
             end 
            error(exn_2)
          end end)
          end_def(--[[ () ]]0);
          generalize_structure_1(current_level.contents, ty_4);
          generalize_structure_1(current_level.contents, ty$prime);
          match_37 = --[[ tuple ]]{
            type_argument(env, sarg_3, ty_4, instance(undefined, env, ty_4)),
            instance(undefined, env, ty$prime),
            cty_1,
            cty$prime
          };
        end else do
          match_40 = transl_simple_type_delayed(env, sty$prime);
          force = match_40[1];
          cty$prime_1 = match_40[0];
          ty$prime_1 = cty$prime_1.ctyp_type;
          begin_def(--[[ () ]]0);
          arg_4 = type_exp(env, sarg_3);
          end_def(--[[ () ]]0);
          tv = newvar(undefined, --[[ () ]]0);
          gen = generalizable(tv.level, arg_4.exp_type);
          unify_var(env, tv, arg_4.exp_type);
          gen_1 = gen;
          match_41 = arg_4.exp_desc;
          match_42 = self_coercion.contents;
          match_43 = repr(ty$prime_1).desc;
          exit_2 = 0;
          if (match_41.tag) then do
            exit_2 = 1;
          end else do
            tmp_2 = match_41[2].val_kind;
            if (typeof tmp_2 == "number" or not (tmp_2.tag == --[[ Val_self ]]2 and match_42 and not (typeof match_43 == "number" or match_43.tag ~= --[[ Tconstr ]]3))) then do
              exit_2 = 1;
            end else do
              match_44 = match_42[0];
              r = match_44[1];
              if (same(match_44[0], match_43[0])) then do
                r.contents = --[[ :: ]]{
                  loc,
                  r.contents
                };
                Curry._1(force, --[[ () ]]0);
              end else do
                exit_2 = 1;
              end end 
            end end 
          end end 
          if (exit_2 == 1) then do
            if (free_variables_1(Caml_option.some(env), arg_4.exp_type) == --[[ [] ]]0 and free_variables_1(Caml_option.some(env), ty$prime_1) == --[[ [] ]]0) then do
              tmp_3 = false;
              if (not gen_1) then do
                snap = snapshot(--[[ () ]]0);
                match_45 = enlarge_type(env, ty$prime_1);
                tmp_4;
                xpcall(function() do
                  Curry._1(force, --[[ () ]]0);
                  unify_2(env, arg_4.exp_type, match_45[0]);
                  tmp_4 = true;
                end end,function(raw_exn_1) do
                  exn_3 = Caml_js_exceptions.internalToOCamlException(raw_exn_1);
                  if (exn_3[0] == Unify) then do
                    backtrack(snap);
                    tmp_4 = false;
                  end else do
                    error(exn_3)
                  end end 
                end end)
                tmp_3 = tmp_4;
              end
               end 
              if (not tmp_3) then do
                xpcall(function() do
                  force$prime = subtype(env, arg_4.exp_type, ty$prime_1);
                  Curry._1(force, --[[ () ]]0);
                  Curry._1(force$prime, --[[ () ]]0);
                  if (not gen_1) then do
                    prerr_warning(loc, --[[ Not_principal ]]Block.__(8, {"this ground coercion"}));
                  end
                   end 
                end end,function(raw_exn_2) do
                  exn_4 = Caml_js_exceptions.internalToOCamlException(raw_exn_2);
                  if (exn_4[0] == Subtype) then do
                    error({
                      __Error_7,
                      loc,
                      env,
                      --[[ Not_subtype ]]Block.__(23, {
                          exn_4[1],
                          exn_4[2]
                        })
                    })
                  end
                   end 
                  error(exn_4)
                end end)
              end
               end 
            end else do
              match_46 = enlarge_type(env, ty$prime_1);
              Curry._1(force, --[[ () ]]0);
              xpcall(function() do
                unify_2(env, arg_4.exp_type, match_46[0]);
              end end,function(raw_exn_3) do
                exn_5 = Caml_js_exceptions.internalToOCamlException(raw_exn_3);
                if (exn_5[0] == Unify) then do
                  error({
                    __Error_7,
                    sarg_3.pexp_loc,
                    env,
                    --[[ Coercion_failure ]]Block.__(25, {
                        ty$prime_1,
                        full_expand(env, ty$prime_1),
                        exn_5[1],
                        match_46[1]
                      })
                  })
                end
                 end 
                error(exn_5)
              end end)
            end end 
          end
           end 
          match_37 = --[[ tuple ]]{
            arg_4,
            ty$prime_1,
            undefined,
            cty$prime_1
          };
        end end 
        arg_5 = match_37[0];
        return rue(do
                    exp_desc: arg_5.exp_desc,
                    exp_loc: arg_5.exp_loc,
                    exp_extra: --[[ :: ]]{
                      --[[ tuple ]]{
                        --[[ Texp_coerce ]]Block.__(1, {
                            match_37[2],
                            match_37[3]
                          }),
                        loc,
                        sexp.pexp_attributes
                      },
                      arg_5.exp_extra
                    },
                    exp_type: match_37[1],
                    exp_env: env,
                    exp_attributes: arg_5.exp_attributes
                  end); end end 
     if ___conditional___ == 21--[[ Pexp_send ]] then do
        met = match[1];
        e = match[0];
        if (principal.contents) then do
          begin_def(--[[ () ]]0);
        end
         end 
        obj = type_exp(env, e);
        xpcall(function() do
          match_47 = obj.exp_desc;
          match_48;
          exit_3 = 0;
          if (match_47.tag) then do
            exit_3 = 1;
          end else do
            match_49 = match_47[2].val_kind;
            lid_4 = match_47[1];
            if (typeof match_49 == "number") then do
              exit_3 = 1;
            end else do
              local ___conditional___=(match_49.tag | 0);
              do
                 if ___conditional___ == 2--[[ Val_self ]] then do
                    match_50 = filter_self_method(env, met, --[[ Private ]]0, match_49[0], match_49[3]);
                    typ = match_50[1];
                    if (is_Tvar(repr(typ))) then do
                      prerr_warning(loc, --[[ Undeclared_virtual_method ]]Block.__(7, {met}));
                    end
                     end 
                    match_48 = --[[ tuple ]]{
                      --[[ Tmeth_val ]]Block.__(1, {match_50[0]}),
                      undefined,
                      typ
                    }; end else 
                 if ___conditional___ == 3--[[ Val_anc ]] then do
                    cl_num = match_49[1];
                    method_id;
                    xpcall(function() do
                      method_id = List.assoc(met, match_49[0]);
                    end end,function(exn_6) do
                      if (exn_6 == Caml_builtin_exceptions.not_found) then do
                        error({
                          __Error_7,
                          e.pexp_loc,
                          env,
                          --[[ Undefined_inherited_method ]]Block.__(17, {met})
                        })
                      end
                       end 
                      error(exn_6)
                    end end)
                    match_51 = lookup_value_1(--[[ Lident ]]Block.__(0, {"selfpat-" .. cl_num}), env);
                    match_52 = lookup_value_1(--[[ Lident ]]Block.__(0, {"self-" .. cl_num}), env);
                    desc_3 = match_51[1];
                    match_53 = desc_3.val_kind;
                    if (typeof match_53 == "number") then do
                      error({
                        Caml_builtin_exceptions.assert_failure,
                        --[[ tuple ]]{
                          "typecore.ml",
                          2384,
                          18
                        }
                      })
                    end else if (match_53.tag == --[[ Val_self ]]2) then do
                      match_54 = filter_self_method(env, met, --[[ Private ]]0, match_53[0], match_53[3]);
                      typ_1 = match_54[1];
                      method_type = newvar(undefined, --[[ () ]]0);
                      match_55 = filter_arrow(env, method_type, "");
                      unify_2(env, match_55[0], desc_3.val_type);
                      unify_2(env, match_55[1], instance(undefined, env, typ_1));
                      exp_000 = do
                        exp_desc: --[[ Texp_ident ]]Block.__(0, {
                            --[[ Pident ]]Block.__(0, {method_id}),
                            lid_4,
                            do
                              val_type: method_type,
                              val_kind: --[[ Val_reg ]]0,
                              val_loc: none,
                              val_attributes: --[[ [] ]]0
                            end
                          }),
                        exp_loc: loc,
                        exp_extra: --[[ [] ]]0,
                        exp_type: method_type,
                        exp_env: env,
                        exp_attributes: --[[ [] ]]0
                      end;
                      exp_001 = --[[ :: ]]{
                        --[[ tuple ]]{
                          "",
                          do
                            exp_desc: --[[ Texp_ident ]]Block.__(0, {
                                match_52[0],
                                lid_4,
                                desc_3
                              }),
                            exp_loc: obj.exp_loc,
                            exp_extra: --[[ [] ]]0,
                            exp_type: desc_3.val_type,
                            exp_env: env,
                            exp_attributes: --[[ [] ]]0
                          end,
                          --[[ Required ]]0
                        },
                        --[[ [] ]]0
                      };
                      exp_2 = --[[ Texp_apply ]]Block.__(4, {
                          exp_000,
                          exp_001
                        });
                      match_48 = --[[ tuple ]]{
                        --[[ Tmeth_name ]]Block.__(0, {met}),
                        re(do
                              exp_desc: exp_2,
                              exp_loc: loc,
                              exp_extra: --[[ [] ]]0,
                              exp_type: typ_1,
                              exp_env: env,
                              exp_attributes: --[[ [] ]]0
                            end),
                        typ_1
                      };
                    end else do
                      error({
                        Caml_builtin_exceptions.assert_failure,
                        --[[ tuple ]]{
                          "typecore.ml",
                          2384,
                          18
                        }
                      })
                    end end  end  end else 
                 end end end end
                exit_3 = 1;
                  
              end
            end end 
          end end 
          if (exit_3 == 1) then do
            match_48 = --[[ tuple ]]{
              --[[ Tmeth_name ]]Block.__(0, {met}),
              undefined,
              filter_method(env, met, --[[ Public ]]1, obj.exp_type)
            };
          end
           end 
          typ_2 = match_48[2];
          if (principal.contents) then do
            end_def(--[[ () ]]0);
            generalize_structure_1(current_level.contents, typ_2);
          end
           end 
          ty_5 = repr(typ_2);
          match_56 = ty_5.desc;
          typ_3;
          if (typeof match_56 == "number") then do
            error({
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "typecore.ml",
                2410,
                14
              }
            })
          end else do
            local ___conditional___=(match_56.tag | 0);
            do
               if ___conditional___ == 0--[[ Tvar ]] then do
                  ty$prime_2 = newvar(undefined, --[[ () ]]0);
                  unify_2(env, instance_def(ty_5), newty2(current_level.contents, --[[ Tpoly ]]Block.__(10, {
                              ty$prime_2,
                              --[[ [] ]]0
                            })));
                  typ_3 = ty$prime_2; end else 
               if ___conditional___ == 10--[[ Tpoly ]] then do
                  tl = match_56[1];
                  ty_6 = match_56[0];
                  if (tl) then do
                    l_2 = ty_5.level;
                    if (principal.contents and l_2 ~= 100000000) then do
                      prerr_warning(loc, --[[ Not_principal ]]Block.__(8, {"this use of a polymorphic method"}));
                    end
                     end 
                    typ_3 = instance_poly(undefined, false, tl, ty_6)[1];
                  end else do
                    typ_3 = instance(undefined, env, ty_6);
                  end end  end else 
               end end end end
              error({
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "typecore.ml",
                    2410,
                    14
                  }
                })
                
            end
          end end 
          return rue(do
                      exp_desc: --[[ Texp_send ]]Block.__(18, {
                          obj,
                          match_48[0],
                          match_48[1]
                        }),
                      exp_loc: loc,
                      exp_extra: --[[ [] ]]0,
                      exp_type: typ_3,
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    end);
        end end,function(raw_exn_4) do
          exn_7 = Caml_js_exceptions.internalToOCamlException(raw_exn_4);
          if (exn_7[0] == Unify) then do
            error({
              __Error_7,
              e.pexp_loc,
              env,
              --[[ Undefined_method ]]Block.__(16, {
                  obj.exp_type,
                  met
                })
            })
          end
           end 
          error(exn_7)
        end end) end else 
     if ___conditional___ == 22--[[ Pexp_new ]] then do
        cl = match[0];
        match_57 = find_class_1(env, loc, cl.txt);
        cl_decl = match_57[1];
        match_58 = cl_decl.cty_new;
        if (match_58 ~= undefined) then do
          return rue(do
                      exp_desc: --[[ Texp_new ]]Block.__(19, {
                          match_57[0],
                          cl,
                          cl_decl
                        }),
                      exp_loc: loc,
                      exp_extra: --[[ [] ]]0,
                      exp_type: instance_def(match_58),
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    end);
        end else do
          error({
            __Error_7,
            loc,
            env,
            --[[ Virtual_class ]]Block.__(18, {cl.txt})
          })
        end end  end end end end 
     if ___conditional___ == 23--[[ Pexp_setinstvar ]] then do
        lab = match[0];
        xpcall(function() do
          match_59 = lookup_value_1(--[[ Lident ]]Block.__(0, {lab.txt}), env);
          desc_4 = match_59[1];
          match_60 = desc_4.val_kind;
          exit_4 = 0;
          if (typeof match_60 == "number" or match_60.tag ~= --[[ Val_ivar ]]1) then do
            exit_4 = 1;
          end else if (match_60[0]) then do
            newval = type_expect(undefined, env, match[1], instance(undefined, env, desc_4.val_type));
            match_61 = lookup_value_1(--[[ Lident ]]Block.__(0, {"self-" .. match_60[1]}), env);
            return rue(do
                        exp_desc: --[[ Texp_setinstvar ]]Block.__(21, {
                            match_61[0],
                            match_59[0],
                            lab,
                            newval
                          }),
                        exp_loc: loc,
                        exp_extra: --[[ [] ]]0,
                        exp_type: instance_def(type_unit),
                        exp_env: env,
                        exp_attributes: sexp.pexp_attributes
                      end);
          end else do
            error({
              __Error_7,
              loc,
              env,
              --[[ Instance_variable_not_mutable ]]Block.__(22, {
                  true,
                  lab.txt
                })
            })
          end end  end 
          if (exit_4 == 1) then do
            error({
              __Error_7,
              loc,
              env,
              --[[ Instance_variable_not_mutable ]]Block.__(22, {
                  false,
                  lab.txt
                })
            })
          end
           end 
        end end,function(exn_8) do
          if (exn_8 == Caml_builtin_exceptions.not_found) then do
            error({
              __Error_7,
              loc,
              env,
              --[[ Unbound_instance_variable ]]Block.__(21, {lab.txt})
            })
          end
           end 
          error(exn_8)
        end end) end else 
     if ___conditional___ == 24--[[ Pexp_override ]] then do
        lst = match[0];
        List.fold_right((function(param, l) do
                lab = param[0];
                if (List.exists((function(l) do
                          return l.txt == lab.txt;
                        end end), l)) then do
                  error({
                    __Error_7,
                    loc,
                    env,
                    --[[ Value_multiply_overridden ]]Block.__(24, {lab.txt})
                  })
                end
                 end 
                return --[[ :: ]]{
                        lab,
                        l
                      };
              end end), lst, --[[ [] ]]0);
        match_62;
        xpcall(function() do
          match_62 = --[[ tuple ]]{
            lookup_value_1(--[[ Lident ]]Block.__(0, {"selfpat-*"}), env),
            lookup_value_1(--[[ Lident ]]Block.__(0, {"self-*"}), env)
          };
        end end,function(exn_9) do
          if (exn_9 == Caml_builtin_exceptions.not_found) then do
            error({
              __Error_7,
              loc,
              env,
              --[[ Outside_class ]]0
            })
          end
           end 
          error(exn_9)
        end end)
        match_63 = match_62[0][1];
        match_64 = match_63.val_kind;
        if (typeof match_64 == "number") then do
          error({
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "typecore.ml",
              2494,
              10
            }
          })
        end else if (match_64.tag == --[[ Val_self ]]2) then do
          vars = match_64[1];
          type_override = function(param) do
            lab = param[0];
            xpcall(function() do
              match = find(lab.txt, vars.contents);
              return --[[ tuple ]]{
                      --[[ Pident ]]Block.__(0, {match[0]}),
                      lab,
                      type_expect(undefined, env, param[1], instance(undefined, env, match[3]))
                    };
            end end,function(exn) do
              if (exn == Caml_builtin_exceptions.not_found) then do
                error({
                  __Error_7,
                  loc,
                  env,
                  --[[ Unbound_instance_variable ]]Block.__(21, {lab.txt})
                })
              end
               end 
              error(exn)
            end end)
          end end;
          modifs = List.map(type_override, lst);
          return rue(do
                      exp_desc: --[[ Texp_override ]]Block.__(22, {
                          match_62[1][0],
                          modifs
                        }),
                      exp_loc: loc,
                      exp_extra: --[[ [] ]]0,
                      exp_type: match_63.val_type,
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    end);
        end else do
          error({
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "typecore.ml",
              2494,
              10
            }
          })
        end end  end  end end end end 
     if ___conditional___ == 25--[[ Pexp_letmodule ]] then do
        name_2 = match[0];
        ty_7 = newvar(undefined, --[[ () ]]0);
        begin_def(--[[ () ]]0);
        set_current_time(ty_7.level);
        context = narrow(--[[ () ]]0);
        modl = Curry._2(type_module.contents, env, match[1]);
        match_65 = enter_module(undefined, name_2.txt, modl.mod_type, env);
        new_env = match_65[1];
        init_def(currentstamp.contents);
        widen(context);
        body_4 = type_expect(undefined, new_env, match[2], ty_expected);
        end_def(--[[ () ]]0);
        xpcall(function() do
          unify_var(new_env, ty_7, body_4.exp_type);
        end end,function(raw_exn_5) do
          exn_10 = Caml_js_exceptions.internalToOCamlException(raw_exn_5);
          if (exn_10[0] == Unify) then do
            error({
              __Error_7,
              loc,
              env,
              --[[ Scoping_let_module ]]Block.__(28, {
                  name_2.txt,
                  body_4.exp_type
                })
            })
          end
           end 
          error(exn_10)
        end end)
        return re(do
                    exp_desc: --[[ Texp_letmodule ]]Block.__(23, {
                        match_65[0],
                        name_2,
                        modl,
                        body_4
                      }),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: ty_7,
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end); end end 
     if ___conditional___ == 26--[[ Pexp_assert ]] then do
        cond_2 = type_expect(undefined, env, match[0], type_bool);
        match_66 = cond_2.exp_desc;
        exp_type;
        exp_type = match_66.tag == --[[ Texp_construct ]]8 and match_66[1].cstr_name == "false" and instance(undefined, env, ty_expected) or instance_def(type_unit);
        return rue(do
                    exp_desc: --[[ Texp_assert ]]Block.__(24, {cond_2}),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: exp_type,
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end); end end 
     if ___conditional___ == 27--[[ Pexp_lazy ]] then do
        ty_8 = newty2(100000000, --[[ Tvar ]]Block.__(0, {undefined}));
        to_unify_2 = type_lazy_t(ty_8);
        unify_exp_types(loc, env, to_unify_2, ty_expected);
        arg_6 = type_expect(undefined, env, match[0], ty_8);
        return re(do
                    exp_desc: --[[ Texp_lazy ]]Block.__(25, {arg_6}),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: instance(undefined, env, ty_expected),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end); end end 
     if ___conditional___ == 28--[[ Pexp_poly ]] then do
        sty_1 = match[1];
        sbody_1 = match[0];
        if (principal.contents) then do
          begin_def(--[[ () ]]0);
        end
         end 
        match_67;
        if (sty_1 ~= undefined) then do
          sty_2 = force_poly(sty_1);
          cty_2 = transl_simple_type(env, false, sty_2);
          match_67 = --[[ tuple ]]{
            repr(cty_2.ctyp_type),
            cty_2
          };
        end else do
          match_67 = --[[ tuple ]]{
            repr(ty_expected),
            undefined
          };
        end end 
        ty_9 = match_67[0];
        if (principal.contents) then do
          end_def(--[[ () ]]0);
          generalize_structure_1(current_level.contents, ty_9);
        end
         end 
        if (sty_1 ~= undefined) then do
          unify_exp_types(loc, env, instance(undefined, env, ty_9), instance(undefined, env, ty_expected));
        end
         end 
        match_68 = expand_head(env, ty_9).desc;
        exp_3;
        if (typeof match_68 == "number") then do
          error({
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "typecore.ml",
              2600,
              15
            }
          })
        end else do
          local ___conditional___=(match_68.tag | 0);
          do
             if ___conditional___ == 0--[[ Tvar ]] then do
                exp_4 = type_exp(env, sbody_1);
                exp_exp_desc = exp_4.exp_desc;
                exp_exp_loc = exp_4.exp_loc;
                exp_exp_extra = exp_4.exp_extra;
                exp_exp_type = newty2(current_level.contents, --[[ Tpoly ]]Block.__(10, {
                        exp_4.exp_type,
                        --[[ [] ]]0
                      }));
                exp_exp_env = exp_4.exp_env;
                exp_exp_attributes = exp_4.exp_attributes;
                exp_5 = do
                  exp_desc: exp_exp_desc,
                  exp_loc: exp_exp_loc,
                  exp_extra: exp_exp_extra,
                  exp_type: exp_exp_type,
                  exp_env: exp_exp_env,
                  exp_attributes: exp_exp_attributes
                end;
                unify_exp(env, exp_5, ty_9);
                exp_3 = exp_5; end else 
             if ___conditional___ == 10--[[ Tpoly ]] then do
                tl_1 = match_68[1];
                ty$prime_3 = match_68[0];
                if (tl_1) then do
                  begin_def(--[[ () ]]0);
                  if (principal.contents) then do
                    begin_def(--[[ () ]]0);
                  end
                   end 
                  match_69 = instance_poly(undefined, true, tl_1, ty$prime_3);
                  ty$prime$prime = match_69[1];
                  if (principal.contents) then do
                    end_def(--[[ () ]]0);
                    generalize_structure_1(current_level.contents, ty$prime$prime);
                  end
                   end 
                  exp_6 = type_expect(undefined, env, sbody_1, ty$prime$prime);
                  end_def(--[[ () ]]0);
                  check_univars(env, false, "method", exp_6, ty_expected, match_69[0]);
                  exp_3 = do
                    exp_desc: exp_6.exp_desc,
                    exp_loc: exp_6.exp_loc,
                    exp_extra: exp_6.exp_extra,
                    exp_type: instance(undefined, env, ty_9),
                    exp_env: exp_6.exp_env,
                    exp_attributes: exp_6.exp_attributes
                  end;
                end else do
                  exp_7 = type_expect(undefined, env, sbody_1, ty$prime_3);
                  exp_3 = do
                    exp_desc: exp_7.exp_desc,
                    exp_loc: exp_7.exp_loc,
                    exp_extra: exp_7.exp_extra,
                    exp_type: instance(undefined, env, ty_9),
                    exp_env: exp_7.exp_env,
                    exp_attributes: exp_7.exp_attributes
                  end;
                end end  end else 
             end end end end
            error({
                Caml_builtin_exceptions.assert_failure,
                --[[ tuple ]]{
                  "typecore.ml",
                  2600,
                  15
                }
              })
              
          end
        end end 
        return re(do
                    exp_desc: exp_3.exp_desc,
                    exp_loc: exp_3.exp_loc,
                    exp_extra: --[[ :: ]]{
                      --[[ tuple ]]{
                        --[[ Texp_poly ]]Block.__(3, {match_67[1]}),
                        loc,
                        sexp.pexp_attributes
                      },
                      exp_3.exp_extra
                    },
                    exp_type: exp_3.exp_type,
                    exp_env: exp_3.exp_env,
                    exp_attributes: exp_3.exp_attributes
                  end); end end 
     if ___conditional___ == 29--[[ Pexp_object ]] then do
        match_70 = Curry._3(type_object.contents, env, loc, match[0]);
        return rue(do
                    exp_desc: --[[ Texp_object ]]Block.__(26, {
                        match_70[0],
                        match_70[2]
                      }),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: match_70[1].csig_self,
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end); end end 
     if ___conditional___ == 30--[[ Pexp_newtype ]] then do
        name_3 = match[0];
        ty_10 = newvar(undefined, --[[ () ]]0);
        begin_def(--[[ () ]]0);
        level = current_level.contents;
        decl_type_newtype_level = --[[ tuple ]]{
          level,
          level
        };
        decl_1 = do
          type_params: --[[ [] ]]0,
          type_arity: 0,
          type_kind: --[[ Type_abstract ]]0,
          type_private: --[[ Public ]]1,
          type_manifest: undefined,
          type_variance: --[[ [] ]]0,
          type_newtype_level: decl_type_newtype_level,
          type_loc: loc,
          type_attributes: --[[ [] ]]0
        end;
        set_current_time(ty_10.level);
        match_71 = enter_type(name_3, decl_1, env);
        id = match_71[0];
        init_def(currentstamp.contents);
        body_5 = type_exp(match_71[1], match[1]);
        seen = Hashtbl.create(undefined, 8);
        replace = function(t) do
          if (Hashtbl.mem(seen, t.id)) then do
            return --[[ () ]]0;
          end else do
            Hashtbl.add(seen, t.id, --[[ () ]]0);
            match = t.desc;
            if (typeof match == "number" or match.tag ~= --[[ Tconstr ]]3) then do
              return iter_type_expr(replace, t);
            end else do
              match_1 = match[0];
              local ___conditional___=(match_1.tag | 0);
              do
                 if ___conditional___ == 0--[[ Pident ]] then do
                    if (id == match_1[0]) then do
                      return link_type(t, ty_10);
                    end else do
                      return iter_type_expr(replace, t);
                    end end  end end 
                 if ___conditional___ == 1--[[ Pdot ]]
                 or ___conditional___ == 2--[[ Papply ]] then do
                    return iter_type_expr(replace, t); end end 
                
              end
            end end 
          end end 
        end end;
        ety = type_expr(identity, body_5.exp_type);
        replace(ety);
        end_def(--[[ () ]]0);
        return rue(do
                    exp_desc: body_5.exp_desc,
                    exp_loc: loc,
                    exp_extra: --[[ :: ]]{
                      --[[ tuple ]]{
                        --[[ Texp_newtype ]]Block.__(4, {name_3}),
                        loc,
                        sexp.pexp_attributes
                      },
                      body_5.exp_extra
                    },
                    exp_type: ety,
                    exp_env: body_5.exp_env,
                    exp_attributes: body_5.exp_attributes
                  end); end end 
     if ___conditional___ == 31--[[ Pexp_pack ]] then do
        match_72 = expand_head(env, instance(undefined, env, ty_expected));
        match_73 = match_72.desc;
        match_74;
        if (typeof match_73 == "number") then do
          error({
            __Error_7,
            loc,
            env,
            --[[ Not_a_packed_module ]]Block.__(32, {ty_expected})
          })
        end else do
          local ___conditional___=(match_73.tag | 0);
          do
             if ___conditional___ == 0--[[ Tvar ]] then do
                error({
                  __Error_7,
                  loc,
                  env,
                  --[[ Cannot_infer_signature ]]3
                }) end end 
             if ___conditional___ == 11--[[ Tpackage ]] then do
                if (principal.contents and expand_head(env, ty_expected).level < 100000000) then do
                  prerr_warning(loc, --[[ Not_principal ]]Block.__(8, {"this module packing"}));
                end
                 end 
                match_74 = --[[ tuple ]]{
                  match_73[0],
                  match_73[1],
                  match_73[2]
                }; end else 
             end end
            error({
                __Error_7,
                loc,
                env,
                --[[ Not_a_packed_module ]]Block.__(32, {ty_expected})
              })
              
          end
        end end 
        nl = match_74[1];
        p = match_74[0];
        match_75 = Curry._5(type_package.contents, env, match[0], p, nl, match_74[2]);
        return rue(do
                    exp_desc: --[[ Texp_pack ]]Block.__(27, {match_75[0]}),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: newty2(current_level.contents, --[[ Tpackage ]]Block.__(11, {
                            p,
                            nl,
                            match_75[1]
                          })),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end); end end 
     if ___conditional___ == 32--[[ Pexp_open ]] then do
        lid_5 = match[1];
        ovf = match[0];
        match_76 = Curry._4(type_open.contents, ovf, env, sexp.pexp_loc, lid_5);
        newenv = match_76[1];
        exp_8 = type_expect(undefined, newenv, match[2], ty_expected);
        return do
                exp_desc: exp_8.exp_desc,
                exp_loc: exp_8.exp_loc,
                exp_extra: --[[ :: ]]{
                  --[[ tuple ]]{
                    --[[ Texp_open ]]Block.__(2, {
                        ovf,
                        match_76[0],
                        lid_5,
                        newenv
                      }),
                    loc,
                    sexp.pexp_attributes
                  },
                  exp_8.exp_extra
                },
                exp_type: exp_8.exp_type,
                exp_env: exp_8.exp_env,
                exp_attributes: exp_8.exp_attributes
              end; end end 
     if ___conditional___ == 33--[[ Pexp_extension ]] then do
        error({
          Error_forward_1,
          error_of_extension(match[0])
        }) end end 
    
  end
end end

function type_function(in_function, loc, attrs, env, ty_expected, l, caselist) do
  match = in_function ~= undefined and in_function or --[[ tuple ]]{
      loc,
      instance(undefined, env, ty_expected)
    };
  ty_fun = match[1];
  loc_fun = match[0];
  separate = principal.contents or env.local_constraints;
  if (separate) then do
    begin_def(--[[ () ]]0);
  end
   end 
  match_1;
  xpcall(function() do
    match_1 = filter_arrow(env, instance(undefined, env, ty_expected), l);
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      ty = expand_head(env, ty_expected);
      match_2 = ty.desc;
      exit = 0;
      if (typeof match_2 == "number" or match_2.tag ~= --[[ Tarrow ]]1) then do
        exit = 1;
      end else do
        error({
          __Error_7,
          loc,
          env,
          --[[ Abstract_wrong_label ]]Block.__(27, {
              l,
              ty
            })
        })
      end end 
      if (exit == 1) then do
        error({
          __Error_7,
          loc_fun,
          env,
          --[[ Too_many_arguments ]]Block.__(26, {
              in_function ~= undefined,
              ty_fun
            })
        })
      end
       end 
    end else do
      error(exn)
    end end 
  end end)
  ty_res = match_1[1];
  ty_arg = match_1[0];
  ty_arg_1;
  if (is_optional(l)) then do
    tv = newvar(undefined, --[[ () ]]0);
    xpcall(function() do
      unify_2(env, ty_arg, type_option_1(tv));
    end end,function(raw_exn_1) do
      exn_1 = Caml_js_exceptions.internalToOCamlException(raw_exn_1);
      if (exn_1[0] == Unify) then do
        error({
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "typecore.ml",
            2706,
            24
          }
        })
      end
       end 
      error(exn_1)
    end end)
    ty_arg_1 = type_option_1(tv);
  end else do
    ty_arg_1 = ty_arg;
  end end 
  if (separate) then do
    end_def(--[[ () ]]0);
    generalize_structure_1(current_level.contents, ty_arg_1);
    generalize_structure_1(current_level.contents, ty_res);
  end
   end 
  match_3 = type_cases(--[[ tuple ]]{
        loc_fun,
        ty_fun
      }, env, ty_arg_1, ty_res, true, loc, caselist);
  cases = match_3[0];
  not_function = function(ty) do
    match = list_labels(env, ty);
    if (match[0] == --[[ [] ]]0) then do
      return not match[1];
    end else do
      return false;
    end end 
  end end;
  if (is_optional(l) and not_function(ty_res)) then do
    prerr_warning(List.hd(cases).c_lhs.pat_loc, --[[ Unerasable_optional_argument ]]8);
  end
   end 
  return re(do
              exp_desc: --[[ Texp_function ]]Block.__(3, {
                  l,
                  cases,
                  match_3[1]
                }),
              exp_loc: loc,
              exp_extra: --[[ [] ]]0,
              exp_type: instance(undefined, env, newty2(100000000, --[[ Tarrow ]]Block.__(1, {
                          l,
                          ty_arg_1,
                          ty_res,
                          --[[ Cok ]]0
                        }))),
              exp_env: env,
              exp_attributes: attrs
            end);
end end

function type_label_access(env, loc, srecord, lid) do
  if (principal.contents) then do
    begin_def(--[[ () ]]0);
  end
   end 
  record = type_exp(env, srecord);
  if (principal.contents) then do
    end_def(--[[ () ]]0);
    generalize_structure_1(current_level.contents, record.exp_type);
  end
   end 
  ty_exp = record.exp_type;
  opath;
  xpcall(function() do
    match = extract_concrete_record(env, ty_exp);
    opath = --[[ tuple ]]{
      match[0],
      match[1],
      ty_exp.level == 100000000 or not principal.contents
    };
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      opath = undefined;
    end else do
      error(exn)
    end end 
  end end)
  labels = find_all_labels(env, lid.loc, lid.txt);
  label = wrap_disambiguate("This expression has", ty_exp, (function(param) do
          return disambiguate(undefined, undefined, undefined, lid, env, opath, param);
        end end), labels);
  return --[[ tuple ]]{
          record,
          label,
          opath
        };
end end

function type_format(loc, str, env) do
  error({
    Caml_builtin_exceptions.assert_failure,
    --[[ tuple ]]{
      "typecore.ml",
      2759,
      11
    }
  })
end end

function type_label_exp(create, env, loc, ty_expected, param) do
  sarg = param[2];
  label = param[1];
  lid = param[0];
  begin_def(--[[ () ]]0);
  separate = principal.contents or env.local_constraints;
  if (separate) then do
    begin_def(--[[ () ]]0);
    begin_def(--[[ () ]]0);
  end
   end 
  match = instance_label(true, label);
  ty_res = match[2];
  ty_arg = match[1];
  vars = match[0];
  if (separate) then do
    end_def(--[[ () ]]0);
    generalize_structure_1(current_level.contents, ty_arg);
    generalize_structure_1(current_level.contents, ty_res);
  end
   end 
  xpcall(function() do
    unify_2(env, instance_def(ty_res), instance(undefined, env, ty_expected));
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      error({
        __Error_7,
        lid.loc,
        env,
        --[[ Label_mismatch ]]Block.__(2, {
            lid.txt,
            exn[1]
          })
      })
    end
     end 
    error(exn)
  end end)
  ty_arg_1 = instance_def(ty_arg);
  if (separate) then do
    end_def(--[[ () ]]0);
    generalize_structure_1(current_level.contents, ty_arg_1);
  end
   end 
  if (label.lbl_private == --[[ Private ]]0) then do
    if (create) then do
      error({
        __Error_7,
        loc,
        env,
        --[[ Private_type ]]Block.__(19, {ty_expected})
      })
    end
     end 
    error({
      __Error_7,
      lid.loc,
      env,
      --[[ Private_label ]]Block.__(20, {
          lid.txt,
          ty_expected
        })
    })
  end
   end 
  snap = vars == --[[ [] ]]0 and undefined or Caml_option.some(snapshot(--[[ () ]]0));
  arg = type_argument(env, sarg, ty_arg_1, instance(undefined, env, ty_arg_1));
  end_def(--[[ () ]]0);
  arg_1;
  xpcall(function() do
    check_univars(env, vars ~= --[[ [] ]]0, "field value", arg, label.lbl_arg, vars);
    arg_1 = arg;
  end end,function(exn_1) do
    if (is_nonexpansive(arg)) then do
      error(exn_1)
    end else do
      xpcall(function() do
        may(backtrack, snap);
        begin_def(--[[ () ]]0);
        arg_2 = type_exp(env, sarg);
        end_def(--[[ () ]]0);
        generalize_expansive_1(env, arg_2.exp_type);
        unify_exp(env, arg_2, ty_arg_1);
        check_univars(env, false, "field value", arg_2, label.lbl_arg, vars);
        arg_1 = arg_2;
      end end,function(raw_e) do
        e = Caml_js_exceptions.internalToOCamlException(raw_e);
        if (e[0] == __Error_7) then do
          tmp = e[3];
          if (typeof tmp == "number") then do
            error(exn_1)
          end else if (tmp.tag == --[[ Less_general ]]31) then do
            error(e)
          end else do
            error(exn_1)
          end end  end 
        end else do
          error(exn_1)
        end end 
      end end)
    end end 
  end end)
  return --[[ tuple ]]{
          lid,
          label,
          do
            exp_desc: arg_1.exp_desc,
            exp_loc: arg_1.exp_loc,
            exp_extra: arg_1.exp_extra,
            exp_type: instance(undefined, env, arg_1.exp_type),
            exp_env: arg_1.exp_env,
            exp_attributes: arg_1.exp_attributes
          end
        };
end end

function type_argument(env, sarg, ty_expected$prime, ty_expected) do
  no_labels = function(ty) do
    match = list_labels(env, ty);
    if (match[1]) then do
      return false;
    end else do
      return List.for_all((function(param) do
                    return "" == param;
                  end end), match[0]);
    end end 
  end end;
  is_inferred = function(_sexp) do
    while(true) do
      sexp = _sexp;
      match = sexp.pexp_desc;
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 15--[[ Pexp_ifthenelse ]] then do
            match_1 = match[2];
            if (match_1 ~= undefined and is_inferred(match[1])) then do
              _sexp = match_1;
              ::continue:: ;
            end else do
              return false;
            end end  end end 
         if ___conditional___ == 16--[[ Pexp_sequence ]] then do
            _sexp = match[1];
            ::continue:: ; end end 
         if ___conditional___ == 0--[[ Pexp_ident ]]
         or ___conditional___ == 5--[[ Pexp_apply ]]
         or ___conditional___ == 12--[[ Pexp_field ]]
         or ___conditional___ == 19--[[ Pexp_constraint ]]
         or ___conditional___ == 20--[[ Pexp_coerce ]]
         or ___conditional___ == 21--[[ Pexp_send ]]
         or ___conditional___ == 22--[[ Pexp_new ]] then do
            return true; end end 
         if ___conditional___ == 32--[[ Pexp_open ]] then do
            _sexp = match[2];
            ::continue:: ; end end 
        return false;
          
      end
    end;
  end end;
  match = expand_head(env, ty_expected$prime);
  match_1 = match.desc;
  if (typeof match_1 ~= "number" and match_1.tag == --[[ Tarrow ]]1 and match_1[0] == "") then do
    ty_res = match_1[2];
    lv = match.level;
    if (is_inferred(sarg)) then do
      if (principal.contents) then do
        begin_def(--[[ () ]]0);
      end
       end 
      texp = type_exp(env, sarg);
      if (principal.contents) then do
        end_def(--[[ () ]]0);
        generalize_structure_1(current_level.contents, texp.exp_type);
      end
       end 
      make_args = function(_args, _ty_fun) do
        while(true) do
          ty_fun = _ty_fun;
          args = _args;
          match = expand_head(env, ty_fun).desc;
          if (typeof match ~= "number") then do
            local ___conditional___=(match.tag | 0);
            do
               if ___conditional___ == 0--[[ Tvar ]] then do
                  return --[[ tuple ]]{
                          List.rev(args),
                          ty_fun,
                          false
                        }; end end 
               if ___conditional___ == 1--[[ Tarrow ]] then do
                  ty_fun_1 = match[2];
                  l = match[0];
                  if (is_optional(l)) then do
                    ty = option_none(instance(undefined, env, match[1]), sarg.pexp_loc);
                    _ty_fun = ty_fun_1;
                    _args = --[[ :: ]]{
                      --[[ tuple ]]{
                        l,
                        ty,
                        --[[ Optional ]]1
                      },
                      args
                    };
                    ::continue:: ;
                  end else if (l == "" or classic.contents) then do
                    return --[[ tuple ]]{
                            List.rev(args),
                            ty_fun,
                            no_labels(ty_fun_1)
                          };
                  end
                   end  end  end else 
               end end
              
            end
          end
           end 
          return --[[ tuple ]]{
                  --[[ [] ]]0,
                  texp.exp_type,
                  false
                };
        end;
      end end;
      match_2 = make_args(--[[ [] ]]0, texp.exp_type);
      ty_fun$prime = match_2[1];
      args = match_2[0];
      warn = principal.contents and (lv ~= 100000000 or repr(ty_fun$prime).level ~= 100000000);
      texp_exp_desc = texp.exp_desc;
      texp_exp_loc = texp.exp_loc;
      texp_exp_extra = texp.exp_extra;
      texp_exp_type = instance(undefined, env, texp.exp_type);
      texp_exp_env = texp.exp_env;
      texp_exp_attributes = texp.exp_attributes;
      texp_1 = do
        exp_desc: texp_exp_desc,
        exp_loc: texp_exp_loc,
        exp_extra: texp_exp_extra,
        exp_type: texp_exp_type,
        exp_env: texp_exp_env,
        exp_attributes: texp_exp_attributes
      end;
      ty_fun = instance(undefined, env, ty_fun$prime);
      if (match_2[2] or no_labels(ty_res)) then do
        unify_exp(env, do
              exp_desc: texp_exp_desc,
              exp_loc: texp_exp_loc,
              exp_extra: texp_exp_extra,
              exp_type: ty_fun,
              exp_env: texp_exp_env,
              exp_attributes: texp_exp_attributes
            end, ty_expected);
        if (args == --[[ [] ]]0) then do
          return texp_1;
        end else do
          var_pair = function(name, ty) do
            id = create(name);
            return --[[ tuple ]]{
                    do
                      pat_desc: --[[ Tpat_var ]]Block.__(0, {
                          id,
                          do
                            txt: name,
                            loc: none
                          end
                        }),
                      pat_loc: none,
                      pat_extra: --[[ [] ]]0,
                      pat_type: ty,
                      pat_env: env,
                      pat_attributes: --[[ [] ]]0
                    end,
                    do
                      exp_desc: --[[ Texp_ident ]]Block.__(0, {
                          --[[ Pident ]]Block.__(0, {id}),
                          do
                            txt: --[[ Lident ]]Block.__(0, {name}),
                            loc: none
                          end,
                          do
                            val_type: ty,
                            val_kind: --[[ Val_reg ]]0,
                            val_loc: none,
                            val_attributes: --[[ [] ]]0
                          end
                        }),
                      exp_loc: none,
                      exp_extra: --[[ [] ]]0,
                      exp_type: ty,
                      exp_env: env,
                      exp_attributes: --[[ [] ]]0
                    end
                  };
          end end;
          match_3 = var_pair("eta", match_1[1]);
          eta_var = match_3[1];
          eta_pat = match_3[0];
          func = function(texp) do
            e_exp_desc = --[[ Texp_apply ]]Block.__(4, {
                texp,
                Pervasives.$at(args, --[[ :: ]]{
                      --[[ tuple ]]{
                        "",
                        eta_var,
                        --[[ Required ]]0
                      },
                      --[[ [] ]]0
                    })
              });
            e_exp_loc = texp.exp_loc;
            e_exp_extra = texp.exp_extra;
            e_exp_env = texp.exp_env;
            e_exp_attributes = texp.exp_attributes;
            e = do
              exp_desc: e_exp_desc,
              exp_loc: e_exp_loc,
              exp_extra: e_exp_extra,
              exp_type: ty_res,
              exp_env: e_exp_env,
              exp_attributes: e_exp_attributes
            end;
            return do
                    exp_desc: --[[ Texp_function ]]Block.__(3, {
                        "",
                        --[[ :: ]]{
                          do
                            c_lhs: eta_pat,
                            c_guard: undefined,
                            c_rhs: e
                          end,
                          --[[ [] ]]0
                        },
                        --[[ Total ]]1
                      }),
                    exp_loc: texp.exp_loc,
                    exp_extra: texp.exp_extra,
                    exp_type: ty_fun,
                    exp_env: texp.exp_env,
                    exp_attributes: texp.exp_attributes
                  end;
          end end;
          prerr_warning(texp_exp_loc, --[[ Eliminated_optional_arguments ]]Block.__(31, {List.map((function(param) do
                          return param[0];
                        end end), args)}));
          if (warn) then do
            prerr_warning(texp_exp_loc, --[[ Without_principality ]]Block.__(9, {"eliminated optional argument"}));
          end
           end 
          if (is_nonexpansive(texp_1)) then do
            return func(texp_1);
          end else do
            match_4 = var_pair("arg", texp_exp_type);
            return re(do
                        exp_desc: --[[ Texp_let ]]Block.__(2, {
                            --[[ Nonrecursive ]]0,
                            --[[ :: ]]{
                              do
                                vb_pat: match_4[0],
                                vb_expr: texp_1,
                                vb_attributes: --[[ [] ]]0,
                                vb_loc: none
                              end,
                              --[[ [] ]]0
                            },
                            func(match_4[1])
                          }),
                        exp_loc: texp_exp_loc,
                        exp_extra: texp_exp_extra,
                        exp_type: ty_fun,
                        exp_env: texp_exp_env,
                        exp_attributes: texp_exp_attributes
                      end);
          end end 
        end end 
      end else do
        unify_exp(env, texp_1, ty_expected);
        return texp_1;
      end end 
    end
     end 
  end
   end 
  texp_2 = type_expect(undefined, env, sarg, ty_expected$prime);
  unify_exp(env, texp_2, ty_expected);
  return texp_2;
end end

function type_application(env, funct, sargs) do
  result_type = function(omitted, ty_fun) do
    return List.fold_left((function(ty_fun, param) do
                  return newty2(param[2], --[[ Tarrow ]]Block.__(1, {
                                param[0],
                                param[1],
                                ty_fun,
                                --[[ Cok ]]0
                              }));
                end end), ty_fun, omitted);
  end end;
  has_label = function(l, ty_fun) do
    match = list_labels(env, ty_fun);
    if (match[1]) then do
      return true;
    end else do
      return List.mem(l, match[0]);
    end end 
  end end;
  ignored = do
    contents: --[[ [] ]]0
  end;
  ignore_labels = true;
  if (not classic.contents) then do
    match = list_labels(env, funct.exp_type);
    tmp = false;
    if (not match[1]) then do
      labels = List.filter((function(l) do
                return not is_optional(l);
              end end))(match[0]);
      tmp = List.length(labels) == List.length(sargs) and List.for_all((function(param) do
              return param[0] == "";
            end end), sargs) and List.exists((function(l) do
              return l ~= "";
            end end), labels) and (prerr_warning(funct.exp_loc, --[[ Labels_omitted ]]3), true);
    end
     end 
    ignore_labels = tmp;
  end
   end 
  warned = do
    contents: false
  end;
  type_args = function(_args, _omitted, _ty_fun, _ty_fun0, _ty_old, _sargs, _more_sargs) do
    while(true) do
      more_sargs = _more_sargs;
      sargs = _sargs;
      ty_old = _ty_old;
      ty_fun0 = _ty_fun0;
      ty_fun = _ty_fun;
      omitted = _omitted;
      args = _args;
      match = expand_head(env, ty_fun);
      match_1 = expand_head(env, ty_fun0);
      match_2 = match.desc;
      exit = 0;
      if (typeof match_2 == "number" or match_2.tag ~= --[[ Tarrow ]]1) then do
        exit = 1;
      end else do
        ty_fun_1 = match_2[2];
        ty = match_2[1];
        l = match_2[0];
        lv = match.level;
        match_3 = match_1.desc;
        if (typeof match_3 == "number" or match_3.tag ~= --[[ Tarrow ]]1) then do
          exit = 1;
        end else do
          ty0 = match_3[1];
          if ((sargs ~= --[[ [] ]]0 or more_sargs ~= --[[ [] ]]0) and commu_repr(match_2[3]) == --[[ Cok ]]0) then do
            may_warn = (function(lv)do
            return function may_warn(loc, w) do
              if (not warned.contents and principal.contents and lv ~= 100000000) then do
                warned.contents = true;
                return prerr_warning(loc, w);
              end else do
                return 0;
              end end 
            end end
            end end)(lv);
            name = label_name(l);
            optional = is_optional(l) and --[[ Optional ]]1 or --[[ Required ]]0;
            match_4;
            if (ignore_labels and not is_optional(l)) then do
              if (sargs) then do
                match_5 = sargs[0];
                error({
                  __Error_7,
                  match_5[1].pexp_loc,
                  env,
                  --[[ Apply_wrong_label ]]Block.__(9, {
                      match_5[0],
                      ty_old
                    })
                })
              end else if (more_sargs) then do
                match_6 = more_sargs[0];
                sarg0 = match_6[1];
                l$prime = match_6[0];
                if (l ~= l$prime and l$prime ~= "") then do
                  error({
                    __Error_7,
                    sarg0.pexp_loc,
                    env,
                    --[[ Apply_wrong_label ]]Block.__(9, {
                        l$prime,
                        match
                      })
                  })
                end
                 end 
                match_4 = --[[ tuple ]]{
                  --[[ [] ]]0,
                  more_sargs[1],
                  (function(ty,ty0,sarg0)do
                  return function (param) do
                    return type_argument(env, sarg0, ty, ty0);
                  end end
                  end end)(ty,ty0,sarg0)
                };
              end else do
                error({
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "typecore.ml",
                    3250,
                    16
                  }
                })
              end end  end 
            end else do
              xpcall(function() do
                match_7;
                xpcall(function() do
                  match_8 = extract_label_aux(--[[ [] ]]0, name, sargs);
                  sargs1 = match_8[2];
                  sarg0_1 = match_8[1];
                  if (sargs1 ~= --[[ [] ]]0) then do
                    may_warn(sarg0_1.pexp_loc, --[[ Not_principal ]]Block.__(8, {"commuting this argument"}));
                  end
                   end 
                  match_7 = --[[ tuple ]]{
                    match_8[0],
                    sarg0_1,
                    Pervasives.$at(sargs1, match_8[3]),
                    more_sargs
                  };
                end end,function(exn) do
                  if (exn == Caml_builtin_exceptions.not_found) then do
                    match_9 = extract_label_aux(--[[ [] ]]0, name, more_sargs);
                    sargs1_1 = match_9[2];
                    sarg0_2 = match_9[1];
                    if (sargs1_1 ~= --[[ [] ]]0 or sargs ~= --[[ [] ]]0) then do
                      may_warn(sarg0_2.pexp_loc, --[[ Not_principal ]]Block.__(8, {"commuting this argument"}));
                    end
                     end 
                    match_7 = --[[ tuple ]]{
                      match_9[0],
                      sarg0_2,
                      Pervasives.$at(sargs, sargs1_1),
                      match_9[3]
                    };
                  end else do
                    error(exn)
                  end end 
                end end)
                sarg0_3 = match_7[1];
                l$prime_1 = match_7[0];
                if (optional == --[[ Required ]]0 and is_optional(l$prime_1)) then do
                  prerr_warning(sarg0_3.pexp_loc, --[[ Nonoptional_label ]]Block.__(26, {l}));
                end
                 end 
                match_4 = --[[ tuple ]]{
                  match_7[2],
                  match_7[3],
                  optional == --[[ Required ]]0 or is_optional(l$prime_1) and (function(ty,ty0,sarg0_3)do
                    return function (param) do
                      return type_argument(env, sarg0_3, ty, ty0);
                    end end
                    end end)(ty,ty0,sarg0_3) or (may_warn(sarg0_3.pexp_loc, --[[ Not_principal ]]Block.__(8, {"using an optional argument here"})), (function(ty,ty0,sarg0_3)do
                      return function (param) do
                        return option_some(type_argument(env, sarg0_3, extract_option_type(env, ty), extract_option_type(env, ty0)));
                      end end
                      end end)(ty,ty0,sarg0_3))
                };
              end end,function(exn_1) do
                if (exn_1 == Caml_builtin_exceptions.not_found) then do
                  match_4 = --[[ tuple ]]{
                    sargs,
                    more_sargs,
                    optional == --[[ Optional ]]1 and (List.mem_assoc("", sargs) or List.mem_assoc("", more_sargs)) and (may_warn(funct.exp_loc, --[[ Without_principality ]]Block.__(9, {"eliminated optional argument"})), ignored.contents = --[[ :: ]]{
                          --[[ tuple ]]{
                            l,
                            ty,
                            lv
                          },
                          ignored.contents
                        }, (function(ty)do
                        return function (param) do
                          return option_none(instance(undefined, env, ty), none);
                        end end
                        end end)(ty)) or (may_warn(funct.exp_loc, --[[ Without_principality ]]Block.__(9, {"commuted an argument"})), undefined)
                  };
                end else do
                  error(exn_1)
                end end 
              end end)
            end end 
            arg = match_4[2];
            sargs_1 = match_4[0];
            omitted_1 = arg == undefined and --[[ :: ]]{
                --[[ tuple ]]{
                  l,
                  ty,
                  lv
                },
                omitted
              } or omitted;
            ty_old_1 = sargs_1 == --[[ [] ]]0 and ty_fun_1 or ty_old;
            _more_sargs = match_4[1];
            _sargs = sargs_1;
            _ty_old = ty_old_1;
            _ty_fun0 = match_3[2];
            _ty_fun = ty_fun_1;
            _omitted = omitted_1;
            _args = --[[ :: ]]{
              --[[ tuple ]]{
                l,
                arg,
                optional
              },
              args
            };
            ::continue:: ;
          end else do
            exit = 1;
          end end 
        end end 
      end end 
      if (exit == 1) then do
        if (sargs and ignore_labels) then do
          match_10 = sargs[0];
          error({
            __Error_7,
            match_10[1].pexp_loc,
            env,
            --[[ Apply_wrong_label ]]Block.__(9, {
                match_10[0],
                ty_old
              })
          })
        end
         end 
        _args_1 = args;
        omitted_2 = omitted;
        _ty_fun_1 = ty_fun0;
        _param = Pervasives.$at(sargs, more_sargs);
        while(true) do
          param = _param;
          ty_fun_2 = _ty_fun_1;
          args_1 = _args_1;
          if (param) then do
            match_11 = param[0];
            sarg1 = match_11[1];
            l1 = match_11[0];
            ty_fun_3 = expand_head(env, ty_fun_2);
            td = ty_fun_3.desc;
            match_12;
            exit_1 = 0;
            if (typeof td == "number") then do
              exit_1 = 1;
            end else do
              local ___conditional___=(td.tag | 0);
              do
                 if ___conditional___ == 0--[[ Tvar ]] then do
                    t1 = newvar(undefined, --[[ () ]]0);
                    t2 = newvar(undefined, --[[ () ]]0);
                    not_identity = function(param) do
                      if (param.tag) then do
                        return true;
                      end else do
                        match = param[2].val_kind;
                        if (typeof match == "number" or match.tag or match[0].prim_name ~= "%identity") then do
                          return true;
                        end else do
                          return false;
                        end end 
                      end end 
                    end end;
                    if (ty_fun_3.level >= t1.level and not_identity(funct.exp_desc)) then do
                      prerr_warning(sarg1.pexp_loc, --[[ Unused_argument ]]9);
                    end
                     end 
                    unify_2(env, ty_fun_3, newty2(current_level.contents, --[[ Tarrow ]]Block.__(1, {
                                l1,
                                t1,
                                t2,
                                --[[ Clink ]]{do
                                    contents: --[[ Cunknown ]]1
                                  end}
                              })));
                    match_12 = --[[ tuple ]]{
                      t1,
                      t2
                    }; end else 
                 if ___conditional___ == 1--[[ Tarrow ]] then do
                    l_1 = td[0];
                    if (l_1 == l1 or classic.contents and l1 == "" and not is_optional(l_1)) then do
                      match_12 = --[[ tuple ]]{
                        td[1],
                        td[2]
                      };
                    end else do
                      exit_1 = 1;
                    end end  end else 
                 end end end end
                exit_1 = 1;
                  
              end
            end end 
            if (exit_1 == 1) then do
              ty_fun_4;
              ty_fun_4 = typeof td == "number" or td.tag ~= --[[ Tarrow ]]1 and ty_fun_3 or newty2(current_level.contents, td);
              ty_res = result_type(Pervasives.$at(omitted_2, ignored.contents), ty_fun_4);
              match_13 = ty_res.desc;
              exit_2 = 0;
              if (typeof match_13 == "number" or match_13.tag ~= --[[ Tarrow ]]1) then do
                exit_2 = 2;
              end else do
                if (classic.contents or not has_label(l1, ty_fun_4)) then do
                  error({
                    __Error_7,
                    sarg1.pexp_loc,
                    env,
                    --[[ Apply_wrong_label ]]Block.__(9, {
                        l1,
                        ty_res
                      })
                  })
                end
                 end 
                error({
                  __Error_7,
                  funct.exp_loc,
                  env,
                  --[[ Incoherent_label_order ]]1
                })
              end end 
              if (exit_2 == 2) then do
                error({
                  __Error_7,
                  funct.exp_loc,
                  env,
                  --[[ Apply_non_function ]]Block.__(8, {expand_head(env, funct.exp_type)})
                })
              end
               end 
            end
             end 
            ty1 = match_12[0];
            optional_1 = is_optional(l1) and --[[ Optional ]]1 or --[[ Required ]]0;
            arg1 = (function(sarg1,ty1,optional_1)do
            return function arg1(param) do
              arg1_1 = type_expect(undefined, env, sarg1, ty1);
              if (optional_1 == --[[ Optional ]]1) then do
                unify_exp(env, arg1_1, type_option_1(newvar(undefined, --[[ () ]]0)));
              end
               end 
              return arg1_1;
            end end
            end end)(sarg1,ty1,optional_1);
            _param = param[1];
            _ty_fun_1 = match_12[1];
            _args_1 = --[[ :: ]]{
              --[[ tuple ]]{
                l1,
                arg1,
                optional_1
              },
              args_1
            };
            ::continue:: ;
          end else do
            return --[[ tuple ]]{
                    List.map((function(param) do
                            match = param[1];
                            l = param[0];
                            if (match ~= undefined) then do
                              return --[[ tuple ]]{
                                      l,
                                      Curry._1(match, --[[ () ]]0),
                                      param[2]
                                    };
                            end else do
                              return --[[ tuple ]]{
                                      l,
                                      undefined,
                                      param[2]
                                    };
                            end end 
                          end end), List.rev(args_1)),
                    instance(undefined, env, result_type(omitted_2, ty_fun_2))
                  };
          end end 
        end;
      end
       end 
    end;
  end end;
  match_1 = funct.exp_desc;
  if (not match_1.tag) then do
    match_2 = match_1[2].val_kind;
    if (typeof match_2 ~= "number" and not match_2.tag and match_2[0].prim_name == "%ignore" and sargs) then do
      match_3 = sargs[0];
      if (match_3[0] == "" and not sargs[1]) then do
        match_4 = filter_arrow(env, instance(undefined, env, funct.exp_type), "");
        exp = type_expect(undefined, env, match_3[1], match_4[0]);
        match_5 = expand_head(env, exp.exp_type).desc;
        if (typeof match_5 ~= "number") then do
          local ___conditional___=(match_5.tag | 0);
          do
             if ___conditional___ == 0--[[ Tvar ]] then do
                add_delayed_check((function(param) do
                        return check_application_result(env, false, exp);
                      end end)); end else 
             if ___conditional___ == 1--[[ Tarrow ]] then do
                prerr_warning(exp.exp_loc, --[[ Partial_application ]]2); end else 
             end end end end
            
          end
        end
         end 
        return --[[ tuple ]]{
                --[[ :: ]]{
                  --[[ tuple ]]{
                    "",
                    exp,
                    --[[ Required ]]0
                  },
                  --[[ [] ]]0
                },
                match_4[1]
              };
      end
       end 
    end
     end 
  end
   end 
  ty = funct.exp_type;
  if (ignore_labels) then do
    return type_args(--[[ [] ]]0, --[[ [] ]]0, ty, instance(undefined, env, ty), ty, --[[ [] ]]0, sargs);
  end else do
    return type_args(--[[ [] ]]0, --[[ [] ]]0, ty, instance(undefined, env, ty), ty, sargs, --[[ [] ]]0);
  end end 
end end

function type_statement(env, sexp) do
  loc = final_subexpression(sexp).pexp_loc;
  begin_def(--[[ () ]]0);
  exp = type_exp(env, sexp);
  end_def(--[[ () ]]0);
  if (strict_sequence.contents) then do
    expected_ty = instance_def(type_unit);
    unify_exp(env, exp, expected_ty);
    return exp;
  end else do
    ty = expand_head(env, exp.exp_type);
    tv = newvar(undefined, --[[ () ]]0);
    match = ty.desc;
    if (typeof match == "number") then do
      prerr_warning(loc, --[[ Statement_type ]]4);
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 0--[[ Tvar ]] then do
            if (ty.level > tv.level) then do
              prerr_warning(loc, --[[ Nonreturning_statement ]]10);
            end else do
              add_delayed_check((function(param) do
                      return check_application_result(env, true, exp);
                    end end));
            end end  end else 
         if ___conditional___ == 1--[[ Tarrow ]] then do
            prerr_warning(loc, --[[ Partial_application ]]2); end else 
         if ___conditional___ == 3--[[ Tconstr ]] then do
            if (not same(match[0], path_unit)) then do
              prerr_warning(loc, --[[ Statement_type ]]4);
            end
             end  end else 
         end end end end end end
        prerr_warning(loc, --[[ Statement_type ]]4);
          
      end
    end end 
    unify_var(env, tv, ty);
    return exp;
  end end 
end end

function type_cases(in_function, env, ty_arg, ty_res, partial_flag, loc, caselist) do
  patterns = List.map((function(param) do
          return param.pc_lhs;
        end end), caselist);
  erase_either = List.exists(contains_polymorphic_variant, patterns) and contains_variant_either(ty_arg);
  has_gadts = List.exists((function(param) do
          return contains_gadt(env, param);
        end end), patterns);
  ty_arg_1 = (has_gadts or erase_either) and not principal.contents and type_expr(identity, ty_arg) or ty_arg;
  match = has_gadts and not principal.contents and --[[ tuple ]]{
      type_expr(identity, ty_res),
      duplicate_ident_types(loc, caselist, env)
    } or --[[ tuple ]]{
      ty_res,
      env
    };
  env_1 = match[1];
  ty_res_1 = match[0];
  match_1;
  if (has_gadts) then do
    begin_def(--[[ () ]]0);
    set_current_time(current_level.contents);
    lev = currentstamp.contents;
    init_def(lev + 1000 | 0);
    match_1 = --[[ tuple ]]{
      lev,
      add_gadt_instance_level(lev, env_1)
    };
  end else do
    match_1 = --[[ tuple ]]{
      current_level.contents,
      env_1
    };
  end end 
  env_2 = match_1[1];
  lev_1 = match_1[0];
  begin_def(--[[ () ]]0);
  ty_arg$prime = newvar(undefined, --[[ () ]]0);
  pattern_force = do
    contents: --[[ [] ]]0
  end;
  pat_env_list = List.map((function(param) do
          pc_rhs = param.pc_rhs;
          pc_guard = param.pc_guard;
          loc;
          if (pc_guard ~= undefined) then do
            init = pc_rhs.pexp_loc;
            loc = do
              loc_start: pc_guard.pexp_loc.loc_start,
              loc_end: init.loc_end,
              loc_ghost: init.loc_ghost
            end;
          end else do
            loc = pc_rhs.pexp_loc;
          end end 
          if (principal.contents) then do
            begin_def(--[[ () ]]0);
          end
           end 
          scope = --[[ Idef ]]Block.__(1, {loc});
          partial = principal.contents or erase_either and false or undefined;
          ty_arg_2 = instance(partial, env_2, ty_arg_1);
          match = type_pattern(lev_1, env_2, param.pc_lhs, scope, ty_arg_2);
          pat = match[0];
          pattern_force.contents = Pervasives.$at(match[2], pattern_force.contents);
          pat_1 = principal.contents and (end_def(--[[ () ]]0), iter_pattern((function(param) do
                      return generalize_structure_1(current_level.contents, param.pat_type);
                    end end), pat), do
                pat_desc: pat.pat_desc,
                pat_loc: pat.pat_loc,
                pat_extra: pat.pat_extra,
                pat_type: instance(undefined, env_2, pat.pat_type),
                pat_env: pat.pat_env,
                pat_attributes: pat.pat_attributes
              end) or pat;
          return --[[ tuple ]]{
                  pat_1,
                  --[[ tuple ]]{
                    match[1],
                    match[3]
                  }
                };
        end end), caselist);
  patl = List.map((function(prim) do
          return prim[0];
        end end), pat_env_list);
  List.iter((function(pat) do
          return unify_pat(env_2, pat, ty_arg$prime);
        end end), patl);
  if (List.exists(has_variants, patl)) then do
    pressure_variants_1(env_2, patl);
    List.iter((function(param) do
            return iter_pattern(finalize_variant, param);
          end end), patl);
  end
   end 
  List.iter((function(f) do
          return Curry._1(f, --[[ () ]]0);
        end end), pattern_force.contents);
  List.iter((function(param) do
          return iter_pattern((function(param) do
                        return unify_var(env_2, param.pat_type, newvar(undefined, --[[ () ]]0));
                      end end), param);
        end end), patl);
  List.iter((function(pat) do
          return unify_pat(env_2, pat, instance(undefined, env_2, ty_arg_1));
        end end), patl);
  end_def(--[[ () ]]0);
  List.iter((function(param) do
          return iter_pattern((function(param) do
                        return iter_generalize_1(do
                                    contents: --[[ [] ]]0
                                  end, param.pat_type);
                      end end), param);
        end end), patl);
  in_function_1 = List.length(caselist) == 1 and in_function or undefined;
  cases = List.map2((function(param, param_1) do
          pc_guard = param_1.pc_guard;
          match = param[1];
          unpacks = match[1];
          ext_env = match[0];
          sexp = wrap_unpacks(param_1.pc_rhs, unpacks);
          ty_res$prime;
          if (principal.contents) then do
            begin_def(--[[ () ]]0);
            ty = instance(true, env_2, ty_res_1);
            end_def(--[[ () ]]0);
            generalize_structure_1(current_level.contents, ty);
            ty_res$prime = ty;
          end else do
            ty_res$prime = contains_gadt(env_2, param_1.pc_lhs) and type_expr(identity, ty_res_1) or ty_res_1;
          end end 
          guard = pc_guard ~= undefined and type_expect(undefined, ext_env, wrap_unpacks(pc_guard, unpacks), type_bool) or undefined;
          exp = type_expect(in_function_1, ext_env, sexp, ty_res$prime);
          return do
                  c_lhs: param[0],
                  c_guard: guard,
                  c_rhs: do
                    exp_desc: exp.exp_desc,
                    exp_loc: exp.exp_loc,
                    exp_extra: exp.exp_extra,
                    exp_type: instance(undefined, env_2, ty_res$prime),
                    exp_env: exp.exp_env,
                    exp_attributes: exp.exp_attributes
                  end
                end;
        end end), pat_env_list, caselist);
  if (principal.contents or has_gadts) then do
    ty_res$prime = instance(undefined, env_2, ty_res_1);
    List.iter((function(c) do
            return unify_exp(env_2, c.c_rhs, ty_res$prime);
          end end), cases);
  end
   end 
  partial = partial_flag and check_partial_1(lev_1, env_2, ty_arg_1)(loc, cases) or --[[ Partial ]]0;
  add_delayed_check((function(param) do
          List.iter((function(param) do
                  return check_absent_variant(param[1][0])(param[0]);
                end end), pat_env_list);
          casel = cases;
          if (is_active(--[[ Unused_match ]]5)) then do
            _pref = --[[ [] ]]0;
            _param = casel;
            while(true) do
              param_1 = _param;
              pref = _pref;
              if (param_1) then do
                rem = param_1[1];
                match = param_1[0];
                q = match.c_lhs;
                qs = --[[ :: ]]{
                  q,
                  --[[ [] ]]0
                };
                xpcall(function() do
                  pss = get_mins(le_pats, List.filter((function(qs)do
                            return function (param) do
                              return compats(qs, param);
                            end end
                            end end)(qs))(pref));
                  r = every_satisfiables(List.map(make_row, pss), do
                        no_ors: --[[ [] ]]0,
                        ors: --[[ [] ]]0,
                        active: qs
                      end);
                  if (typeof r == "number") then do
                    if (r ~= 0) then do
                      prerr_warning(q.pat_loc, --[[ Unused_match ]]5);
                    end
                     end 
                  end else do
                    List.iter((function(p) do
                            return prerr_warning(p.pat_loc, --[[ Unused_pat ]]6);
                          end end), r[0]);
                  end end 
                end end,function(exn) do
                  exit = 0;
                  if (exn == Empty or exn == Caml_builtin_exceptions.not_found or exn == NoGuard) then do
                    exit = 1;
                  end else do
                    error(exn)
                  end end 
                  if (exit == 1) then do
                    error({
                      Caml_builtin_exceptions.assert_failure,
                      --[[ tuple ]]{
                        "parmatch.ml",
                        1947,
                        48
                      }
                    })
                  end
                   end 
                end end)
                if (match.c_guard ~= undefined) then do
                  _param = rem;
                  ::continue:: ;
                end else do
                  _param = rem;
                  _pref = --[[ :: ]]{
                    --[[ :: ]]{
                      q,
                      --[[ [] ]]0
                    },
                    pref
                  };
                  ::continue:: ;
                end end 
              end else do
                return --[[ () ]]0;
              end end 
            end;
          end else do
            return 0;
          end end 
        end end));
  if (has_gadts) then do
    end_def(--[[ () ]]0);
    unify_exp_types(loc, env_2, instance(undefined, env_2, ty_res_1), newvar(undefined, --[[ () ]]0));
  end
   end 
  return --[[ tuple ]]{
          cases,
          partial
        };
end end

function type_let(checkOpt, check_strictOpt, env, rec_flag, spat_sexp_list, scope, allow) do
  check = checkOpt ~= undefined and checkOpt or (function(s) do
        return --[[ Unused_var ]]Block.__(12, {s});
      end end);
  check_strict = check_strictOpt ~= undefined and check_strictOpt or (function(s) do
        return --[[ Unused_var_strict ]]Block.__(13, {s});
      end end);
  begin_def(--[[ () ]]0);
  if (principal.contents) then do
    begin_def(--[[ () ]]0);
  end
   end 
  is_fake_let;
  if (spat_sexp_list) then do
    match = spat_sexp_list[0].pvb_expr.pexp_desc;
    if (match.tag == --[[ Pexp_match ]]6) then do
      match_1 = match[0].pexp_desc;
      if (match_1.tag) then do
        is_fake_let = false;
      end else do
        match_2 = match_1[0].txt;
        local ___conditional___=(match_2.tag | 0);
        do
           if ___conditional___ == 0--[[ Lident ]] then do
              is_fake_let = match_2[0] == "*opt*" and not spat_sexp_list[1] and true or false; end else 
           if ___conditional___ == 1--[[ Ldot ]]
           or ___conditional___ == 2--[[ Lapply ]] then do
              is_fake_let = false; end else 
           end end end end
          
        end
      end end 
    end else do
      is_fake_let = false;
    end end 
  end else do
    is_fake_let = false;
  end end 
  check_1 = is_fake_let and check_strict or check;
  spatl = List.map((function(param) do
          spat = param.pvb_pat;
          match = spat.ppat_desc;
          match_1 = param.pvb_expr.pexp_desc;
          sty;
          if (typeof match == "number" or match.tag == --[[ Ppat_constraint ]]10) then do
            return spat;
          end else do
            local ___conditional___=(match_1.tag | 0);
            do
               if ___conditional___ == 19--[[ Pexp_constraint ]] then do
                  sty = match_1[1]; end else 
               if ___conditional___ == 20--[[ Pexp_coerce ]] then do
                  sty = match_1[2]; end else 
               end end end end
              return spat;
                
            end
          end end 
          if (principal.contents) then do
            init = spat.ppat_loc;
            return constraint_(do
                        loc_start: init.loc_start,
                        loc_end: init.loc_end,
                        loc_ghost: true
                      end, undefined, spat, sty);
          end else do
            return spat;
          end end 
        end end), spat_sexp_list);
  nvs = List.map((function(param) do
          return newvar(undefined, --[[ () ]]0);
        end end), spatl);
  match_3 = type_pattern_list(env, spatl, scope, nvs, allow);
  unpacks = match_3[3];
  new_env = match_3[1];
  pat_list = match_3[0];
  is_recursive = rec_flag == --[[ Recursive ]]1;
  if (is_recursive) then do
    List.iter2((function(pat, binding) do
            match = pat.pat_type.desc;
            pat_1;
            pat_1 = typeof match == "number" or match.tag ~= --[[ Tpoly ]]10 and pat or (do
                  pat_desc: pat.pat_desc,
                  pat_loc: pat.pat_loc,
                  pat_extra: pat.pat_extra,
                  pat_type: instance_poly(true, false, match[1], match[0])[1],
                  pat_env: pat.pat_env,
                  pat_attributes: pat.pat_attributes
                end);
            return unify_pat(env, pat_1, type_approx(env, binding.pvb_expr));
          end end), pat_list, spat_sexp_list);
  end
   end 
  List.iter((function(pat) do
          if (has_variants(pat)) then do
            pressure_variants_1(env, --[[ :: ]]{
                  pat,
                  --[[ [] ]]0
                });
            return iter_pattern(finalize_variant, pat);
          end else do
            return 0;
          end end 
        end end), pat_list);
  pat_list_1 = principal.contents and (end_def(--[[ () ]]0), List.map((function(pat) do
              iter_pattern((function(pat) do
                      return generalize_structure_1(current_level.contents, pat.pat_type);
                    end end), pat);
              return do
                      pat_desc: pat.pat_desc,
                      pat_loc: pat.pat_loc,
                      pat_extra: pat.pat_extra,
                      pat_type: instance(undefined, env, pat.pat_type),
                      pat_env: pat.pat_env,
                      pat_attributes: pat.pat_attributes
                    end;
            end end), pat_list)) or pat_list;
  List.iter((function(f) do
          return Curry._1(f, --[[ () ]]0);
        end end), match_3[2]);
  exp_env = is_recursive and new_env or env;
  current_slot = do
    contents: undefined
  end;
  rec_needed = do
    contents: false
  end;
  warn_unused = is_active(Curry._1(check_1, "")) or is_active(Curry._1(check_strict, "")) or is_recursive and is_active(--[[ Unused_rec_flag ]]15);
  pat_slot_list = List.map((function(pat) do
          if (warn_unused) then do
            some_used = do
              contents: false
            end;
            slot = do
              contents: --[[ [] ]]0
            end;
            List.iter((function(param) do
                    id = param[0];
                    vd = find_value(--[[ Pident ]]Block.__(0, {id}), new_env);
                    name = id.name;
                    used = do
                      contents: false
                    end;
                    if (not (name == "" or Caml_string.get(name, 0) == --[[ "_" ]]95 or Caml_string.get(name, 0) == --[[ "#" ]]35)) then do
                      add_delayed_check((function(param) do
                              if (used.contents) then do
                                return 0;
                              end else do
                                return prerr_warning(vd.val_loc, Curry._1(some_used.contents and check_strict or check_1, name));
                              end end 
                            end end));
                    end
                     end 
                    name_1 = name;
                    vd_1 = vd;
                    callback = function(param) do
                      match = current_slot.contents;
                      if (match ~= undefined) then do
                        slot_1 = match;
                        slot_1.contents = --[[ :: ]]{
                          --[[ tuple ]]{
                            name,
                            vd
                          },
                          slot_1.contents
                        };
                        rec_needed.contents = true;
                        return --[[ () ]]0;
                      end else do
                        List.iter((function(param) do
                                return mark_value_used(env, param[0], param[1]);
                              end end), get_ref(slot));
                        used.contents = true;
                        some_used.contents = true;
                        return --[[ () ]]0;
                      end end 
                    end end;
                    key_001 = vd_1.val_loc;
                    key = --[[ tuple ]]{
                      name_1,
                      key_001
                    };
                    xpcall(function() do
                      old = Hashtbl.find(value_declarations, key);
                      return Hashtbl.replace(value_declarations, key, (function(param) do
                                    Curry._1(old, --[[ () ]]0);
                                    return Curry._1(callback, --[[ () ]]0);
                                  end end));
                    end end,function(exn) do
                      if (exn == Caml_builtin_exceptions.not_found) then do
                        return Hashtbl.add(value_declarations, key, callback);
                      end else do
                        error(exn)
                      end end 
                    end end)
                  end end), pat_bound_idents(pat));
            return --[[ tuple ]]{
                    pat,
                    slot
                  };
          end else do
            return --[[ tuple ]]{
                    pat,
                    undefined
                  };
          end end 
        end end), pat_list_1);
  exp_list = List.map2((function(param, param_1) do
          pat = param_1[0];
          sexp = param.pvb_expr;
          sexp_1 = rec_flag == --[[ Recursive ]]1 and wrap_unpacks(sexp, unpacks) or sexp;
          if (is_recursive) then do
            current_slot.contents = param_1[1];
          end
           end 
          match = pat.pat_type.desc;
          if (typeof match == "number" or match.tag ~= --[[ Tpoly ]]10) then do
            return type_expect(undefined, exp_env, sexp_1, pat.pat_type);
          end else do
            begin_def(--[[ () ]]0);
            if (principal.contents) then do
              begin_def(--[[ () ]]0);
            end
             end 
            match_1 = instance_poly(true, true, match[1], match[0]);
            ty$prime = match_1[1];
            if (principal.contents) then do
              end_def(--[[ () ]]0);
              generalize_structure_1(current_level.contents, ty$prime);
            end
             end 
            exp = type_expect(undefined, exp_env, sexp_1, ty$prime);
            end_def(--[[ () ]]0);
            check_univars(env, true, "definition", exp, pat.pat_type, match_1[0]);
            return do
                    exp_desc: exp.exp_desc,
                    exp_loc: exp.exp_loc,
                    exp_extra: exp.exp_extra,
                    exp_type: instance(undefined, env, exp.exp_type),
                    exp_env: exp.exp_env,
                    exp_attributes: exp.exp_attributes
                  end;
          end end 
        end end), spat_sexp_list, pat_slot_list);
  current_slot.contents = undefined;
  if (is_recursive and not rec_needed.contents and is_active(--[[ Unused_rec_flag ]]15)) then do
    prerr_warning(List.hd(spat_sexp_list).pvb_pat.ppat_loc, --[[ Unused_rec_flag ]]15);
  end
   end 
  List.iter2((function(pat, exp) do
          check_partial_1(undefined, env, pat.pat_type)(pat.pat_loc, --[[ :: ]]{
                do
                  c_lhs: pat,
                  c_guard: undefined,
                  c_rhs: exp
                end,
                --[[ [] ]]0
              });
          return --[[ () ]]0;
        end end), pat_list_1, exp_list);
  end_def(--[[ () ]]0);
  List.iter2((function(pat, exp) do
          if (is_nonexpansive(exp)) then do
            return 0;
          end else do
            return iter_pattern((function(pat) do
                          return generalize_expansive_1(env, pat.pat_type);
                        end end), pat);
          end end 
        end end), pat_list_1, exp_list);
  List.iter((function(pat) do
          return iter_pattern((function(pat) do
                        return iter_generalize_1(do
                                    contents: --[[ [] ]]0
                                  end, pat.pat_type);
                      end end), pat);
        end end), pat_list_1);
  l = List.combine(pat_list_1, exp_list);
  l_1 = List.map2((function(param, pvb) do
          return do
                  vb_pat: param[0],
                  vb_expr: param[1],
                  vb_attributes: pvb.pvb_attributes,
                  vb_loc: pvb.pvb_loc
                end;
        end end), l, spat_sexp_list);
  return --[[ tuple ]]{
          l_1,
          new_env,
          unpacks
        };
end end

function type_binding(env, rec_flag, spat_sexp_list, scope) do
  reset_type_variables(--[[ () ]]0);
  match = type_let((function(s) do
          return --[[ Unused_value_declaration ]]Block.__(16, {s});
        end end), (function(s) do
          return --[[ Unused_value_declaration ]]Block.__(16, {s});
        end end), env, rec_flag, spat_sexp_list, scope, false);
  return --[[ tuple ]]{
          match[0],
          match[1]
        };
end end

function type_let_1(env, rec_flag, spat_sexp_list, scope) do
  match = type_let(undefined, undefined, env, rec_flag, spat_sexp_list, scope, false);
  return --[[ tuple ]]{
          match[0],
          match[1]
        };
end end

function type_expression(env, sexp) do
  reset_type_variables(--[[ () ]]0);
  begin_def(--[[ () ]]0);
  exp = type_exp(env, sexp);
  end_def(--[[ () ]]0);
  if (is_nonexpansive(exp)) then do
    iter_generalize_1(do
          contents: --[[ [] ]]0
        end, exp.exp_type);
  end else do
    generalize_expansive_1(env, exp.exp_type);
  end end 
  match = sexp.pexp_desc;
  if (match.tag) then do
    return exp;
  end else do
    match_1 = lookup_value_1(match[0].txt, env);
    return do
            exp_desc: exp.exp_desc,
            exp_loc: exp.exp_loc,
            exp_extra: exp.exp_extra,
            exp_type: match_1[1].val_type,
            exp_env: exp.exp_env,
            exp_attributes: exp.exp_attributes
          end;
  end end 
end end

register_error_of_exn((function(param) do
        if (param[0] == __Error_7) then do
          env = param[2];
          return error_of_printer(param[1], (function(param, param_1) do
                        env_1 = env;
                        ppf = param;
                        err = param_1;
                        return wrap_printing_env(env_1, (function(param) do
                                      env_2 = env_1;
                                      ppf_1 = ppf;
                                      param_1 = err;
                                      if (typeof param_1 == "number") then do
                                        local ___conditional___=(param_1);
                                        do
                                           if ___conditional___ == 0--[[ Outside_class ]] then do
                                              return Format.fprintf(ppf_1, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "This object duplication occurs outside a method definition",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "This object duplication occurs outside a method definition"
                                                        }); end end 
                                           if ___conditional___ == 1--[[ Incoherent_label_order ]] then do
                                              Format.fprintf(ppf_1, --[[ Format ]]{
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "This function is applied to arguments",
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Break ]]Block.__(0, {
                                                                "@ ",
                                                                1,
                                                                0
                                                              }),
                                                            --[[ End_of_format ]]0
                                                          })
                                                      }),
                                                    "This function is applied to arguments@ "
                                                  });
                                              Format.fprintf(ppf_1, --[[ Format ]]{
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "in an order different from other calls.",
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Break ]]Block.__(0, {
                                                                "@ ",
                                                                1,
                                                                0
                                                              }),
                                                            --[[ End_of_format ]]0
                                                          })
                                                      }),
                                                    "in an order different from other calls.@ "
                                                  });
                                              return Format.fprintf(ppf_1, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "This is only allowed when the real type is known.",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "This is only allowed when the real type is known."
                                                        }); end end 
                                           if ___conditional___ == 2--[[ Modules_not_allowed ]] then do
                                              return Format.fprintf(ppf_1, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "Modules are not allowed in this pattern.",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "Modules are not allowed in this pattern."
                                                        }); end end 
                                           if ___conditional___ == 3--[[ Cannot_infer_signature ]] then do
                                              return Format.fprintf(ppf_1, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "The signature for this packaged module couldn't be inferred.",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "The signature for this packaged module couldn't be inferred."
                                                        }); end end 
                                           if ___conditional___ == 4--[[ Unexpected_existential ]] then do
                                              return Format.fprintf(ppf_1, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "Unexpected existential",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "Unexpected existential"
                                                        }); end end 
                                           if ___conditional___ == 5--[[ Invalid_interval ]] then do
                                              return Format.fprintf(ppf_1, --[[ Format ]]{
                                                          --[[ Formatting_gen ]]Block.__(18, {
                                                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                    --[[ End_of_format ]]0,
                                                                    ""
                                                                  }}),
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "Only character intervals are supported in patterns.",
                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Close_box ]]0,
                                                                      --[[ End_of_format ]]0
                                                                    })
                                                                })
                                                            }),
                                                          "@[Only character intervals are supported in patterns.@]"
                                                        }); end end 
                                           if ___conditional___ == 6--[[ Invalid_for_loop_index ]] then do
                                              return Format.fprintf(ppf_1, --[[ Format ]]{
                                                          --[[ Formatting_gen ]]Block.__(18, {
                                                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                    --[[ End_of_format ]]0,
                                                                    ""
                                                                  }}),
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "Invalid for-loop index: only variables and _ are allowed.",
                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Close_box ]]0,
                                                                      --[[ End_of_format ]]0
                                                                    })
                                                                })
                                                            }),
                                                          "@[Invalid for-loop index: only variables and _ are allowed.@]"
                                                        }); end end 
                                           if ___conditional___ == 7--[[ No_value_clauses ]] then do
                                              return Format.fprintf(ppf_1, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "None of the patterns in this 'match' expression match values.",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "None of the patterns in this 'match' expression match values."
                                                        }); end end 
                                           if ___conditional___ == 8--[[ Exception_pattern_below_toplevel ]] then do
                                              return Format.fprintf(ppf_1, --[[ Format ]]{
                                                          --[[ Formatting_gen ]]Block.__(18, {
                                                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                    --[[ End_of_format ]]0,
                                                                    ""
                                                                  }}),
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "Exception patterns must be at the top level of a match case.",
                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Close_box ]]0,
                                                                      --[[ End_of_format ]]0
                                                                    })
                                                                })
                                                            }),
                                                          "@[Exception patterns must be at the top level of a match case.@]"
                                                        }); end end 
                                          
                                        end
                                      end else do
                                        local ___conditional___=(param_1.tag | 0);
                                        do
                                           if ___conditional___ == 0--[[ Polymorphic_label ]] then do
                                              return Curry._3(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The record field ",
                                                                      --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                                                              " is polymorphic.",
                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Break ]]Block.__(0, {
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    }),
                                                                                  --[[ String ]]Block.__(2, {
                                                                                      --[[ No_padding ]]0,
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Close_box ]]0,
                                                                                          --[[ End_of_format ]]0
                                                                                        })
                                                                                    })
                                                                                })
                                                                            })})
                                                                    })
                                                                }),
                                                              "@[The record field %a is polymorphic.@ %s@]"
                                                            }), longident, param_1[0], "You cannot instantiate it in a pattern."); end end 
                                           if ___conditional___ == 1--[[ Constructor_arity_mismatch ]] then do
                                              return Curry._4(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The constructor ",
                                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Break ]]Block.__(0, {
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                }),
                                                                              --[[ String_literal ]]Block.__(11, {
                                                                                  "expects ",
                                                                                  --[[ Int ]]Block.__(4, {
                                                                                      --[[ Int_i ]]3,
                                                                                      --[[ No_padding ]]0,
                                                                                      --[[ No_precision ]]0,
                                                                                      --[[ String_literal ]]Block.__(11, {
                                                                                          " argument(s),",
                                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                                              --[[ Break ]]Block.__(0, {
                                                                                                  "@ ",
                                                                                                  1,
                                                                                                  0
                                                                                                }),
                                                                                              --[[ String_literal ]]Block.__(11, {
                                                                                                  "but is applied here to ",
                                                                                                  --[[ Int ]]Block.__(4, {
                                                                                                      --[[ Int_i ]]3,
                                                                                                      --[[ No_padding ]]0,
                                                                                                      --[[ No_precision ]]0,
                                                                                                      --[[ String_literal ]]Block.__(11, {
                                                                                                          " argument(s)",
                                                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                                                              --[[ Close_box ]]0,
                                                                                                              --[[ End_of_format ]]0
                                                                                                            })
                                                                                                        })
                                                                                                    })
                                                                                                })
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })
                                                                            })})
                                                                    })
                                                                }),
                                                              "@[The constructor %a@ expects %i argument(s),@ but is applied here to %i argument(s)@]"
                                                            }), longident, param_1[0], param_1[1], param_1[2]); end end 
                                           if ___conditional___ == 2--[[ Label_mismatch ]] then do
                                              lid = param_1[0];
                                              return report_unification_error(ppf_1, env_2, undefined, param_1[1], (function(ppf) do
                                                            return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                                            --[[ String_literal ]]Block.__(11, {
                                                                                "The record field ",
                                                                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                        --[[ Break ]]Block.__(0, {
                                                                                            "@ ",
                                                                                            1,
                                                                                            0
                                                                                          }),
                                                                                        --[[ String_literal ]]Block.__(11, {
                                                                                            "belongs to the type",
                                                                                            --[[ End_of_format ]]0
                                                                                          })
                                                                                      })})
                                                                              }),
                                                                            "The record field %a@ belongs to the type"
                                                                          }), longident, lid);
                                                          end end), (function(ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "but is mixed here with fields of type",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "but is mixed here with fields of type"
                                                                      });
                                                          end end)); end end 
                                           if ___conditional___ == 3--[[ Pattern_type_clash ]] then do
                                              return report_unification_error(ppf_1, env_2, undefined, param_1[0], (function(ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "This pattern matches values of type",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "This pattern matches values of type"
                                                                      });
                                                          end end), (function(ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "but a pattern was expected which matches values of type",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "but a pattern was expected which matches values of type"
                                                                      });
                                                          end end)); end end 
                                           if ___conditional___ == 4--[[ Or_pattern_type_clash ]] then do
                                              id = param_1[0];
                                              return report_unification_error(ppf_1, env_2, undefined, param_1[1], (function(ppf) do
                                                            return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                                            --[[ String_literal ]]Block.__(11, {
                                                                                "The variable ",
                                                                                --[[ String ]]Block.__(2, {
                                                                                    --[[ No_padding ]]0,
                                                                                    --[[ String_literal ]]Block.__(11, {
                                                                                        " on the left-hand side of this or-pattern has type",
                                                                                        --[[ End_of_format ]]0
                                                                                      })
                                                                                  })
                                                                              }),
                                                                            "The variable %s on the left-hand side of this or-pattern has type"
                                                                          }), id.name);
                                                          end end), (function(ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "but on the right-hand side it has type",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "but on the right-hand side it has type"
                                                                      });
                                                          end end)); end end 
                                           if ___conditional___ == 5--[[ Multiply_bound_variable ]] then do
                                              return Curry._1(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "Variable ",
                                                                  --[[ String ]]Block.__(2, {
                                                                      --[[ No_padding ]]0,
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          " is bound several times in this matching",
                                                                          --[[ End_of_format ]]0
                                                                        })
                                                                    })
                                                                }),
                                                              "Variable %s is bound several times in this matching"
                                                            }), param_1[0]); end end 
                                           if ___conditional___ == 6--[[ Orpat_vars ]] then do
                                              return Curry._1(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "Variable ",
                                                                  --[[ String ]]Block.__(2, {
                                                                      --[[ No_padding ]]0,
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          " must occur on both sides of this | pattern",
                                                                          --[[ End_of_format ]]0
                                                                        })
                                                                    })
                                                                }),
                                                              "Variable %s must occur on both sides of this | pattern"
                                                            }), param_1[0].name); end end 
                                           if ___conditional___ == 7--[[ Expr_type_clash ]] then do
                                              return report_unification_error(ppf_1, env_2, undefined, param_1[0], (function(ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "This expression has type",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "This expression has type"
                                                                      });
                                                          end end), (function(ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "but an expression was expected of type",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "but an expression was expected of type"
                                                                      });
                                                          end end)); end end 
                                           if ___conditional___ == 8--[[ Apply_non_function ]] then do
                                              typ = param_1[0];
                                              reset(--[[ () ]]0);
                                              mark_loops(typ);
                                              match = repr(typ).desc;
                                              if (typeof match ~= "number" and match.tag == --[[ Tarrow ]]1) then do
                                                Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                          --[[ Formatting_gen ]]Block.__(18, {
                                                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                    --[[ String_literal ]]Block.__(11, {
                                                                        "<v>",
                                                                        --[[ End_of_format ]]0
                                                                      }),
                                                                    "<v>"
                                                                  }}),
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "<2>",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "<2>"
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "This function has type",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Close_box ]]0,
                                                                                  --[[ End_of_format ]]0
                                                                                })})
                                                                        })
                                                                    })
                                                                })
                                                            }),
                                                          "@[<v>@[<2>This function has type@ %a@]"
                                                        }), type_expr_1, typ);
                                                return Curry._1(Format.fprintf(ppf_1, --[[ Format ]]{
                                                                --[[ Formatting_lit ]]Block.__(17, {
                                                                    --[[ Break ]]Block.__(0, {
                                                                        "@ ",
                                                                        1,
                                                                        0
                                                                      }),
                                                                    --[[ Formatting_gen ]]Block.__(18, {
                                                                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                              --[[ End_of_format ]]0,
                                                                              ""
                                                                            }}),
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "It is applied to too many arguments;",
                                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                                --[[ Break ]]Block.__(0, {
                                                                                    "@ ",
                                                                                    1,
                                                                                    0
                                                                                  }),
                                                                                --[[ String ]]Block.__(2, {
                                                                                    --[[ No_padding ]]0,
                                                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                                                        --[[ Close_box ]]0,
                                                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                                                            --[[ Close_box ]]0,
                                                                                            --[[ End_of_format ]]0
                                                                                          })
                                                                                      })
                                                                                  })
                                                                              })
                                                                          })
                                                                      })
                                                                  }),
                                                                "@ @[It is applied to too many arguments;@ %s@]@]"
                                                              }), "maybe you forgot a `;'.");
                                              end
                                               end 
                                              return Curry._3(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "<v>",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "<v>"
                                                                      }}),
                                                                  --[[ Formatting_gen ]]Block.__(18, {
                                                                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                            --[[ String_literal ]]Block.__(11, {
                                                                                "<2>",
                                                                                --[[ End_of_format ]]0
                                                                              }),
                                                                            "<2>"
                                                                          }}),
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          "This expression has type",
                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Break ]]Block.__(0, {
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                }),
                                                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Close_box ]]0,
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Break ]]Block.__(0, {
                                                                                              "@ ",
                                                                                              1,
                                                                                              0
                                                                                            }),
                                                                                          --[[ String ]]Block.__(2, {
                                                                                              --[[ No_padding ]]0,
                                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                                  --[[ Close_box ]]0,
                                                                                                  --[[ End_of_format ]]0
                                                                                                })
                                                                                            })
                                                                                        })
                                                                                    })})
                                                                            })
                                                                        })
                                                                    })
                                                                }),
                                                              "@[<v>@[<2>This expression has type@ %a@]@ %s@]"
                                                            }), type_expr_1, typ, "This is not a function; it cannot be applied."); end end 
                                           if ___conditional___ == 9--[[ Apply_wrong_label ]] then do
                                              ty = param_1[1];
                                              print_label = function(ppf, l) do
                                                if (l == "") then do
                                                  return Format.fprintf(ppf, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "without label",
                                                                  --[[ End_of_format ]]0
                                                                }),
                                                              "without label"
                                                            });
                                                end else do
                                                  return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "with label ",
                                                                      --[[ String ]]Block.__(2, {
                                                                          --[[ No_padding ]]0,
                                                                          --[[ End_of_format ]]0
                                                                        })
                                                                    }),
                                                                  "with label %s"
                                                                }), prefixed_label_name(l));
                                                end end 
                                              end end;
                                              reset(--[[ () ]]0);
                                              mark_loops(ty);
                                              return Curry._4(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "<v>",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "<v>"
                                                                      }}),
                                                                  --[[ Formatting_gen ]]Block.__(18, {
                                                                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                            --[[ String_literal ]]Block.__(11, {
                                                                                "<2>",
                                                                                --[[ End_of_format ]]0
                                                                              }),
                                                                            "<2>"
                                                                          }}),
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          "The function applied to this argument has type",
                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Break ]]Block.__(0, {
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                }),
                                                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Close_box ]]0,
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Flush_newline ]]4,
                                                                                          --[[ String_literal ]]Block.__(11, {
                                                                                              "This argument cannot be applied ",
                                                                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                      --[[ Close_box ]]0,
                                                                                                      --[[ End_of_format ]]0
                                                                                                    })})
                                                                                            })
                                                                                        })
                                                                                    })})
                                                                            })
                                                                        })
                                                                    })
                                                                }),
                                                              "@[<v>@[<2>The function applied to this argument has type@ %a@]@.This argument cannot be applied %a@]"
                                                            }), type_expr_1, ty, print_label, param_1[0]); end end 
                                           if ___conditional___ == 10--[[ Label_multiply_defined ]] then do
                                              return Curry._1(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "The record field label ",
                                                                  --[[ String ]]Block.__(2, {
                                                                      --[[ No_padding ]]0,
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          " is defined several times",
                                                                          --[[ End_of_format ]]0
                                                                        })
                                                                    })
                                                                }),
                                                              "The record field label %s is defined several times"
                                                            }), param_1[0]); end end 
                                           if ___conditional___ == 11--[[ Label_missing ]] then do
                                              print_labels = function(ppf) do
                                                return (function(param) do
                                                    return List.iter((function(lbl) do
                                                                  return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Break ]]Block.__(0, {
                                                                                          "@ ",
                                                                                          1,
                                                                                          0
                                                                                        }),
                                                                                      --[[ String ]]Block.__(2, {
                                                                                          --[[ No_padding ]]0,
                                                                                          --[[ End_of_format ]]0
                                                                                        })
                                                                                    }),
                                                                                  "@ %s"
                                                                                }), lbl.name);
                                                                end end), param);
                                                  end end);
                                              end end;
                                              return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "<hov>",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "<hov>"
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "Some record fields are undefined:",
                                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Close_box ]]0,
                                                                              --[[ End_of_format ]]0
                                                                            })})
                                                                    })
                                                                }),
                                                              "@[<hov>Some record fields are undefined:%a@]"
                                                            }), print_labels, param_1[0]); end end 
                                           if ___conditional___ == 12--[[ Label_not_mutable ]] then do
                                              return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "The record field ",
                                                                  --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                                                          " is not mutable",
                                                                          --[[ End_of_format ]]0
                                                                        })})
                                                                }),
                                                              "The record field %a is not mutable"
                                                            }), longident, param_1[0]); end end 
                                           if ___conditional___ == 13--[[ Wrong_name ]] then do
                                              lid_1 = param_1[4];
                                              p = param_1[3];
                                              kind = param_1[2];
                                              ty_1 = param_1[1];
                                              reset(--[[ () ]]0);
                                              mark_loops(ty_1);
                                              Curry._3(Format.fprintf(ppf_1, --[[ Format ]]{
                                                        --[[ Formatting_gen ]]Block.__(18, {
                                                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                  --[[ End_of_format ]]0,
                                                                  ""
                                                                }}),
                                                            --[[ Formatting_gen ]]Block.__(18, {
                                                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          "<2>",
                                                                          --[[ End_of_format ]]0
                                                                        }),
                                                                      "<2>"
                                                                    }}),
                                                                --[[ String ]]Block.__(2, {
                                                                    --[[ No_padding ]]0,
                                                                    --[[ String_literal ]]Block.__(11, {
                                                                        " type",
                                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                                            --[[ Break ]]Block.__(0, {
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              }),
                                                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                    --[[ Close_box ]]0,
                                                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                                                        --[[ Break ]]Block.__(0, {
                                                                                            "@ ",
                                                                                            1,
                                                                                            0
                                                                                          }),
                                                                                        --[[ End_of_format ]]0
                                                                                      })
                                                                                  })})
                                                                          })
                                                                      })
                                                                  })
                                                              })
                                                          }),
                                                        "@[@[<2>%s type@ %a@]@ "
                                                      }), param_1[0], type_expr_1, ty_1);
                                              Curry._5(Format.fprintf(ppf_1, --[[ Format ]]{
                                                        --[[ String_literal ]]Block.__(11, {
                                                            "The ",
                                                            --[[ String ]]Block.__(2, {
                                                                --[[ No_padding ]]0,
                                                                --[[ Char_literal ]]Block.__(12, {
                                                                    --[[ " " ]]32,
                                                                    --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                                                            " does not belong to type ",
                                                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                    --[[ Close_box ]]0,
                                                                                    --[[ End_of_format ]]0
                                                                                  })})
                                                                          })})
                                                                  })
                                                              })
                                                          }),
                                                        "The %s %a does not belong to type %a@]"
                                                      }), kind == "record" and "field" or "constructor", longident, lid_1, path, p);
                                              if (kind == "record") then do
                                                ppf_2 = ppf_1;
                                                env_3 = env_2;
                                                p_1 = p;
                                                lid_2 = lid_1;
                                                return spellcheck_simple(ppf_2, fold_labels, (function(d) do
                                                                if (compare_type_path(env_3, p_1, get_type_path_1(env_3, d))) then do
                                                                  return d.lbl_name;
                                                                end else do
                                                                  return "";
                                                                end end 
                                                              end end))(env_3, lid_2);
                                              end else do
                                                ppf_3 = ppf_1;
                                                env_4 = env_2;
                                                p_2 = p;
                                                lid_3 = lid_1;
                                                return spellcheck_simple(ppf_3, fold_constructors, (function(d) do
                                                                if (compare_type_path(env_4, p_2, get_type_path_2(env_4, d))) then do
                                                                  return d.cstr_name;
                                                                end else do
                                                                  return "";
                                                                end end 
                                                              end end))(env_4, lid_3);
                                              end end  end end 
                                           if ___conditional___ == 14--[[ Name_type_mismatch ]] then do
                                              lid_4 = param_1[1];
                                              kind_1 = param_1[0];
                                              name = kind_1 == "record" and "field" or "constructor";
                                              ppf_4 = ppf_1;
                                              env_5 = env_2;
                                              param_2 = param_1[2];
                                              tpl = param_1[3];
                                              txt1 = function(ppf) do
                                                return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "The ",
                                                                    --[[ String ]]Block.__(2, {
                                                                        --[[ No_padding ]]0,
                                                                        --[[ Char_literal ]]Block.__(12, {
                                                                            --[[ " " ]]32,
                                                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                    --[[ Break ]]Block.__(0, {
                                                                                        "@ ",
                                                                                        1,
                                                                                        0
                                                                                      }),
                                                                                    --[[ String_literal ]]Block.__(11, {
                                                                                        "belongs to the ",
                                                                                        --[[ String ]]Block.__(2, {
                                                                                            --[[ No_padding ]]0,
                                                                                            --[[ String_literal ]]Block.__(11, {
                                                                                                " type",
                                                                                                --[[ End_of_format ]]0
                                                                                              })
                                                                                          })
                                                                                      })
                                                                                  })})
                                                                          })
                                                                      })
                                                                  }),
                                                                "The %s %a@ belongs to the %s type"
                                                              }), name, longident, lid_4, kind_1);
                                              end end;
                                              txt2 = function(ppf) do
                                                return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "The ",
                                                                    --[[ String ]]Block.__(2, {
                                                                        --[[ No_padding ]]0,
                                                                        --[[ Char_literal ]]Block.__(12, {
                                                                            --[[ " " ]]32,
                                                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                    --[[ Break ]]Block.__(0, {
                                                                                        "@ ",
                                                                                        1,
                                                                                        0
                                                                                      }),
                                                                                    --[[ String_literal ]]Block.__(11, {
                                                                                        "belongs to one of the following ",
                                                                                        --[[ String ]]Block.__(2, {
                                                                                            --[[ No_padding ]]0,
                                                                                            --[[ String_literal ]]Block.__(11, {
                                                                                                " types:",
                                                                                                --[[ End_of_format ]]0
                                                                                              })
                                                                                          })
                                                                                      })
                                                                                  })})
                                                                          })
                                                                      })
                                                                  }),
                                                                "The %s %a@ belongs to one of the following %s types:"
                                                              }), name, longident, lid_4, kind_1);
                                              end end;
                                              txt3 = function(ppf) do
                                                return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "but a ",
                                                                    --[[ String ]]Block.__(2, {
                                                                        --[[ No_padding ]]0,
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            " was expected belonging to the ",
                                                                            --[[ String ]]Block.__(2, {
                                                                                --[[ No_padding ]]0,
                                                                                --[[ String_literal ]]Block.__(11, {
                                                                                    " type",
                                                                                    --[[ End_of_format ]]0
                                                                                  })
                                                                              })
                                                                          })
                                                                      })
                                                                  }),
                                                                "but a %s was expected belonging to the %s type"
                                                              }), name, kind_1);
                                              end end;
                                              tp0$prime = param_2[1];
                                              tp0 = param_2[0];
                                              return wrap_printing_env(env_5, (function(param) do
                                                            reset(--[[ () ]]0);
                                                            List.iter((function(param) do
                                                                    path_same_name(tp0, param[0]);
                                                                    return path_same_name(tp0$prime, param[1]);
                                                                  end end), tpl);
                                                            if (tpl) then do
                                                              if (tpl[1]) then do
                                                                return Curry._6(Format.fprintf(ppf_4, --[[ Format ]]{
                                                                                --[[ Formatting_gen ]]Block.__(18, {
                                                                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                                          --[[ End_of_format ]]0,
                                                                                          ""
                                                                                        }}),
                                                                                    --[[ Theta ]]Block.__(16, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                            --[[ Break ]]Block.__(0, {
                                                                                                "@;<1 2>",
                                                                                                1,
                                                                                                2
                                                                                              }),
                                                                                            --[[ Formatting_gen ]]Block.__(18, {
                                                                                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                                                      --[[ String_literal ]]Block.__(11, {
                                                                                                          "<hv>",
                                                                                                          --[[ End_of_format ]]0
                                                                                                        }),
                                                                                                      "<hv>"
                                                                                                    }}),
                                                                                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                        --[[ Close_box ]]0,
                                                                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                                                                            --[[ Break ]]Block.__(0, {
                                                                                                                "@ ",
                                                                                                                1,
                                                                                                                0
                                                                                                              }),
                                                                                                            --[[ Theta ]]Block.__(16, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                                    --[[ Break ]]Block.__(0, {
                                                                                                                        "@;<1 2>",
                                                                                                                        1,
                                                                                                                        2
                                                                                                                      }),
                                                                                                                    --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                                            --[[ Close_box ]]0,
                                                                                                                            --[[ End_of_format ]]0
                                                                                                                          })})
                                                                                                                  })})
                                                                                                          })
                                                                                                      })})
                                                                                              })
                                                                                          })})
                                                                                  }),
                                                                                "@[%t@;<1 2>@[<hv>%a@]@ %t@;<1 2>%a@]"
                                                                              }), txt2, type_path_list, tpl, txt3, (function(param, param_1) do
                                                                              return type_path_expansion(tp0, param, param_1);
                                                                            end end), tp0$prime);
                                                              end else do
                                                                match = tpl[0];
                                                                tp = match[0];
                                                                return Curry._6(Format.fprintf(ppf_4, --[[ Format ]]{
                                                                                --[[ Formatting_gen ]]Block.__(18, {
                                                                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                                          --[[ End_of_format ]]0,
                                                                                          ""
                                                                                        }}),
                                                                                    --[[ Theta ]]Block.__(16, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                            --[[ Break ]]Block.__(0, {
                                                                                                "@;<1 2>",
                                                                                                1,
                                                                                                2
                                                                                              }),
                                                                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                    --[[ Break ]]Block.__(0, {
                                                                                                        "@ ",
                                                                                                        1,
                                                                                                        0
                                                                                                      }),
                                                                                                    --[[ Theta ]]Block.__(16, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                            --[[ Break ]]Block.__(0, {
                                                                                                                "@;<1 2>",
                                                                                                                1,
                                                                                                                2
                                                                                                              }),
                                                                                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                                    --[[ Close_box ]]0,
                                                                                                                    --[[ End_of_format ]]0
                                                                                                                  })})
                                                                                                          })})
                                                                                                  })})
                                                                                          })})
                                                                                  }),
                                                                                "@[%t@;<1 2>%a@ %t@;<1 2>%a@]"
                                                                              }), txt1, (function(param, param_1) do
                                                                              return type_path_expansion(tp, param, param_1);
                                                                            end end), match[1], txt3, (function(param, param_1) do
                                                                              return type_path_expansion(tp0, param, param_1);
                                                                            end end), tp0$prime);
                                                              end end 
                                                            end else do
                                                              error({
                                                                Caml_builtin_exceptions.assert_failure,
                                                                --[[ tuple ]]{
                                                                  "printtyp.ml",
                                                                  1585,
                                                                  12
                                                                }
                                                              })
                                                            end end 
                                                          end end)); end end 
                                           if ___conditional___ == 15--[[ Invalid_format ]] then do
                                              return Curry._1(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ String ]]Block.__(2, {
                                                                  --[[ No_padding ]]0,
                                                                  --[[ End_of_format ]]0
                                                                }),
                                                              "%s"
                                                            }), param_1[0]); end end 
                                           if ___conditional___ == 16--[[ Undefined_method ]] then do
                                              ty_2 = param_1[0];
                                              reset(--[[ () ]]0);
                                              mark_loops(ty_2);
                                              return Curry._3(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "<v>",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "<v>"
                                                                      }}),
                                                                  --[[ Formatting_gen ]]Block.__(18, {
                                                                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                            --[[ End_of_format ]]0,
                                                                            ""
                                                                          }}),
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          "This expression has type",
                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Break ]]Block.__(0, {
                                                                                  "@;<1 2>",
                                                                                  1,
                                                                                  2
                                                                                }),
                                                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Close_box ]]0,
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Break ]]Block.__(0, {
                                                                                              "@,",
                                                                                              0,
                                                                                              0
                                                                                            }),
                                                                                          --[[ String_literal ]]Block.__(11, {
                                                                                              "It has no method ",
                                                                                              --[[ String ]]Block.__(2, {
                                                                                                  --[[ No_padding ]]0,
                                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                                      --[[ Close_box ]]0,
                                                                                                      --[[ End_of_format ]]0
                                                                                                    })
                                                                                                })
                                                                                            })
                                                                                        })
                                                                                    })})
                                                                            })
                                                                        })
                                                                    })
                                                                }),
                                                              "@[<v>@[This expression has type@;<1 2>%a@]@,It has no method %s@]"
                                                            }), type_expr_1, ty_2, param_1[1]); end end 
                                           if ___conditional___ == 17--[[ Undefined_inherited_method ]] then do
                                              return Curry._1(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "This expression has no method ",
                                                                  --[[ String ]]Block.__(2, {
                                                                      --[[ No_padding ]]0,
                                                                      --[[ End_of_format ]]0
                                                                    })
                                                                }),
                                                              "This expression has no method %s"
                                                            }), param_1[0]); end end 
                                           if ___conditional___ == 18--[[ Virtual_class ]] then do
                                              return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "Cannot instantiate the virtual class ",
                                                                  --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                                }),
                                                              "Cannot instantiate the virtual class %a"
                                                            }), longident, param_1[0]); end end 
                                           if ___conditional___ == 19--[[ Private_type ]] then do
                                              return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "Cannot create values of the private type ",
                                                                  --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                                }),
                                                              "Cannot create values of the private type %a"
                                                            }), type_expr_1, param_1[0]); end end 
                                           if ___conditional___ == 20--[[ Private_label ]] then do
                                              return Curry._4(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "Cannot assign field ",
                                                                  --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                                                          " of the private type ",
                                                                          --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                                        })})
                                                                }),
                                                              "Cannot assign field %a of the private type %a"
                                                            }), longident, param_1[0], type_expr_1, param_1[1]); end end 
                                           if ___conditional___ == 21--[[ Unbound_instance_variable ]] then do
                                              return Curry._1(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "Unbound instance variable ",
                                                                  --[[ String ]]Block.__(2, {
                                                                      --[[ No_padding ]]0,
                                                                      --[[ End_of_format ]]0
                                                                    })
                                                                }),
                                                              "Unbound instance variable %s"
                                                            }), param_1[0]); end end 
                                           if ___conditional___ == 22--[[ Instance_variable_not_mutable ]] then do
                                              v = param_1[1];
                                              if (param_1[0]) then do
                                                return Curry._1(Format.fprintf(ppf_1, --[[ Format ]]{
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "The instance variable ",
                                                                    --[[ String ]]Block.__(2, {
                                                                        --[[ No_padding ]]0,
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            " is not mutable",
                                                                            --[[ End_of_format ]]0
                                                                          })
                                                                      })
                                                                  }),
                                                                "The instance variable %s is not mutable"
                                                              }), v);
                                              end else do
                                                return Curry._1(Format.fprintf(ppf_1, --[[ Format ]]{
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "The value ",
                                                                    --[[ String ]]Block.__(2, {
                                                                        --[[ No_padding ]]0,
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            " is not an instance variable",
                                                                            --[[ End_of_format ]]0
                                                                          })
                                                                      })
                                                                  }),
                                                                "The value %s is not an instance variable"
                                                              }), v);
                                              end end  end end 
                                           if ___conditional___ == 23--[[ Not_subtype ]] then do
                                              ppf_5 = ppf_1;
                                              env_6 = env_2;
                                              tr1 = param_1[0];
                                              txt1_1 = "is not a subtype of";
                                              tr2 = param_1[1];
                                              return wrap_printing_env(env_6, (function(param) do
                                                            reset(--[[ () ]]0);
                                                            tr1_1 = List.map(prepare_expansion, tr1);
                                                            tr2_1 = List.map(prepare_expansion, tr2);
                                                            partial_arg = tr2_1 == --[[ [] ]]0;
                                                            Curry._2(Format.fprintf(ppf_5, --[[ Format ]]{
                                                                      --[[ Formatting_gen ]]Block.__(18, {
                                                                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                                --[[ String_literal ]]Block.__(11, {
                                                                                    "<v>",
                                                                                    --[[ End_of_format ]]0
                                                                                  }),
                                                                                "<v>"
                                                                              }}),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                                        }),
                                                                      "@[<v>%a"
                                                                    }), (function(param, param_1) do
                                                                    return trace_1(true, partial_arg, txt1_1, param, param_1);
                                                                  end end), tr1_1);
                                                            if (tr2_1 == --[[ [] ]]0) then do
                                                              return Format.fprintf(ppf_5, --[[ Format ]]{
                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Close_box ]]0,
                                                                              --[[ End_of_format ]]0
                                                                            }),
                                                                          "@]"
                                                                        });
                                                            end else do
                                                              mis = mismatch(true, tr2_1);
                                                              partial_arg_1 = mis == undefined;
                                                              return Curry._3(Format.fprintf(ppf_5, --[[ Format ]]{
                                                                              --[[ Alpha ]]Block.__(15, {--[[ Theta ]]Block.__(16, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Close_box ]]0,
                                                                                          --[[ End_of_format ]]0
                                                                                        })})}),
                                                                              "%a%t@]"
                                                                            }), (function(param, param_1) do
                                                                            return trace_1(false, partial_arg_1, "is not compatible with type", param, param_1);
                                                                          end end), tr2_1, (function(param) do
                                                                            return explanation(true, mis, param);
                                                                          end end));
                                                            end end 
                                                          end end)); end end 
                                           if ___conditional___ == 24--[[ Value_multiply_overridden ]] then do
                                              return Curry._1(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "The instance variable ",
                                                                  --[[ String ]]Block.__(2, {
                                                                      --[[ No_padding ]]0,
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          " is overridden several times",
                                                                          --[[ End_of_format ]]0
                                                                        })
                                                                    })
                                                                }),
                                                              "The instance variable %s is overridden several times"
                                                            }), param_1[0]); end end 
                                           if ___conditional___ == 25--[[ Coercion_failure ]] then do
                                              ty$prime = param_1[1];
                                              ty_3 = param_1[0];
                                              report_unification_error(ppf_1, env_2, undefined, param_1[2], (function(ppf) do
                                                      match = prepare_expansion(--[[ tuple ]]{
                                                            ty_3,
                                                            ty$prime
                                                          });
                                                      ty_4 = match[0];
                                                      return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          "This expression cannot be coerced to type",
                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Break ]]Block.__(0, {
                                                                                  "@;<1 2>",
                                                                                  1,
                                                                                  2
                                                                                }),
                                                                              --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                                                      --[[ ";" ]]59,
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Break ]]Block.__(0, {
                                                                                              "@ ",
                                                                                              1,
                                                                                              0
                                                                                            }),
                                                                                          --[[ String_literal ]]Block.__(11, {
                                                                                              "it has type",
                                                                                              --[[ End_of_format ]]0
                                                                                            })
                                                                                        })
                                                                                    })})
                                                                            })
                                                                        }),
                                                                      "This expression cannot be coerced to type@;<1 2>%a;@ it has type"
                                                                    }), (function(param, param_1) do
                                                                    return type_expansion(ty_4, param, param_1);
                                                                  end end), match[1]);
                                                    end end), (function(ppf) do
                                                      return Format.fprintf(ppf, --[[ Format ]]{
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "but is here used with type",
                                                                      --[[ End_of_format ]]0
                                                                    }),
                                                                  "but is here used with type"
                                                                });
                                                    end end));
                                              if (param_1[3]) then do
                                                return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                                --[[ Char_literal ]]Block.__(12, {
                                                                    --[[ "." ]]46,
                                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                                        --[[ Flush_newline ]]4,
                                                                        --[[ Formatting_gen ]]Block.__(18, {
                                                                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                                  --[[ String_literal ]]Block.__(11, {
                                                                                      "<hov>",
                                                                                      --[[ End_of_format ]]0
                                                                                    }),
                                                                                  "<hov>"
                                                                                }}),
                                                                            --[[ String ]]Block.__(2, {
                                                                                --[[ No_padding ]]0,
                                                                                --[[ Formatting_lit ]]Block.__(17, {
                                                                                    --[[ Break ]]Block.__(0, {
                                                                                        "@ ",
                                                                                        1,
                                                                                        0
                                                                                      }),
                                                                                    --[[ String ]]Block.__(2, {
                                                                                        --[[ No_padding ]]0,
                                                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                                                            --[[ Close_box ]]0,
                                                                                            --[[ End_of_format ]]0
                                                                                          })
                                                                                      })
                                                                                  })
                                                                              })
                                                                          })
                                                                      })
                                                                  }),
                                                                ".@.@[<hov>%s@ %s@]"
                                                              }), "This simple coercion was not fully general.", "Consider using a double coercion.");
                                              end else do
                                                return 0;
                                              end end  end end 
                                           if ___conditional___ == 26--[[ Too_many_arguments ]] then do
                                              ty_4 = param_1[1];
                                              reset(--[[ () ]]0);
                                              mark_loops(ty_4);
                                              if (param_1[0]) then do
                                                Format.fprintf(ppf_1, --[[ Format ]]{
                                                      --[[ String_literal ]]Block.__(11, {
                                                          "This function expects too many arguments,",
                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Break ]]Block.__(0, {
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                }),
                                                              --[[ End_of_format ]]0
                                                            })
                                                        }),
                                                      "This function expects too many arguments,@ "
                                                    });
                                                return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "it should have type",
                                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                                        --[[ Break ]]Block.__(0, {
                                                                            "@ ",
                                                                            1,
                                                                            0
                                                                          }),
                                                                        --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                                      })
                                                                  }),
                                                                "it should have type@ %a"
                                                              }), type_expr_1, ty_4);
                                              end else do
                                                Format.fprintf(ppf_1, --[[ Format ]]{
                                                      --[[ String_literal ]]Block.__(11, {
                                                          "This expression should not be a function,",
                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Break ]]Block.__(0, {
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                }),
                                                              --[[ End_of_format ]]0
                                                            })
                                                        }),
                                                      "This expression should not be a function,@ "
                                                    });
                                                return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "the expected type is",
                                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                                        --[[ Break ]]Block.__(0, {
                                                                            "@ ",
                                                                            1,
                                                                            0
                                                                          }),
                                                                        --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                                      })
                                                                  }),
                                                                "the expected type is@ %a"
                                                              }), type_expr_1, ty_4);
                                              end end  end end 
                                           if ___conditional___ == 27--[[ Abstract_wrong_label ]] then do
                                              ty_5 = param_1[1];
                                              label_mark = function(l) do
                                                if (l == "") then do
                                                  return "but its first argument is not labelled";
                                                end else do
                                                  return Curry._1(Format.sprintf(--[[ Format ]]{
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "but its first argument is labelled ",
                                                                      --[[ String ]]Block.__(2, {
                                                                          --[[ No_padding ]]0,
                                                                          --[[ End_of_format ]]0
                                                                        })
                                                                    }),
                                                                  "but its first argument is labelled %s"
                                                                }), prefixed_label_name(l));
                                                end end 
                                              end end;
                                              reset(--[[ () ]]0);
                                              mark_loops(ty_5);
                                              return Curry._3(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "<v>",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "<v>"
                                                                      }}),
                                                                  --[[ Formatting_gen ]]Block.__(18, {
                                                                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                            --[[ String_literal ]]Block.__(11, {
                                                                                "<2>",
                                                                                --[[ End_of_format ]]0
                                                                              }),
                                                                            "<2>"
                                                                          }}),
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          "This function should have type",
                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Break ]]Block.__(0, {
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                }),
                                                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Close_box ]]0,
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Break ]]Block.__(0, {
                                                                                              "@,",
                                                                                              0,
                                                                                              0
                                                                                            }),
                                                                                          --[[ String ]]Block.__(2, {
                                                                                              --[[ No_padding ]]0,
                                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                                  --[[ Close_box ]]0,
                                                                                                  --[[ End_of_format ]]0
                                                                                                })
                                                                                            })
                                                                                        })
                                                                                    })})
                                                                            })
                                                                        })
                                                                    })
                                                                }),
                                                              "@[<v>@[<2>This function should have type@ %a@]@,%s@]"
                                                            }), type_expr_1, ty_5, label_mark(param_1[0])); end end 
                                           if ___conditional___ == 28--[[ Scoping_let_module ]] then do
                                              ty_6 = param_1[1];
                                              reset(--[[ () ]]0);
                                              mark_loops(ty_6);
                                              Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                        --[[ String_literal ]]Block.__(11, {
                                                            "This `let module' expression has type",
                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                --[[ Break ]]Block.__(0, {
                                                                    "@ ",
                                                                    1,
                                                                    0
                                                                  }),
                                                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                        --[[ Break ]]Block.__(0, {
                                                                            "@ ",
                                                                            1,
                                                                            0
                                                                          }),
                                                                        --[[ End_of_format ]]0
                                                                      })})
                                                              })
                                                          }),
                                                        "This `let module' expression has type@ %a@ "
                                                      }), type_expr_1, ty_6);
                                              return Curry._1(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "In this type, the locally bound module name ",
                                                                  --[[ String ]]Block.__(2, {
                                                                      --[[ No_padding ]]0,
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          " escapes its scope",
                                                                          --[[ End_of_format ]]0
                                                                        })
                                                                    })
                                                                }),
                                                              "In this type, the locally bound module name %s escapes its scope"
                                                            }), param_1[0]); end end 
                                           if ___conditional___ == 29--[[ Masked_instance_variable ]] then do
                                              return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "The instance variable ",
                                                                  --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ String_literal ]]Block.__(11, {
                                                                              "cannot be accessed from the definition of another instance variable",
                                                                              --[[ End_of_format ]]0
                                                                            })
                                                                        })})
                                                                }),
                                                              "The instance variable %a@ cannot be accessed from the definition of another instance variable"
                                                            }), longident, param_1[0]); end end 
                                           if ___conditional___ == 30--[[ Not_a_variant_type ]] then do
                                              return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "The type ",
                                                                  --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ String_literal ]]Block.__(11, {
                                                                              "is not a variant type",
                                                                              --[[ End_of_format ]]0
                                                                            })
                                                                        })})
                                                                }),
                                                              "The type %a@ is not a variant type"
                                                            }), longident, param_1[0]); end end 
                                           if ___conditional___ == 31--[[ Less_general ]] then do
                                              kind_2 = param_1[0];
                                              return report_unification_error(ppf_1, env_2, undefined, param_1[1], (function(ppf) do
                                                            return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                                            --[[ String_literal ]]Block.__(11, {
                                                                                "This ",
                                                                                --[[ String ]]Block.__(2, {
                                                                                    --[[ No_padding ]]0,
                                                                                    --[[ String_literal ]]Block.__(11, {
                                                                                        " has type",
                                                                                        --[[ End_of_format ]]0
                                                                                      })
                                                                                  })
                                                                              }),
                                                                            "This %s has type"
                                                                          }), kind_2);
                                                          end end), (function(ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "which is less general than",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "which is less general than"
                                                                      });
                                                          end end)); end end 
                                           if ___conditional___ == 32--[[ Not_a_packed_module ]] then do
                                              return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "This expression is packed module, but the expected type is",
                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Break ]]Block.__(0, {
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        }),
                                                                      --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                                    })
                                                                }),
                                                              "This expression is packed module, but the expected type is@ %a"
                                                            }), type_expr_1, param_1[0]); end end 
                                           if ___conditional___ == 33--[[ Recursive_local_constraint ]] then do
                                              return report_unification_error(ppf_1, env_2, undefined, param_1[0], (function(ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "Recursive local constraint when unifying",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "Recursive local constraint when unifying"
                                                                      });
                                                          end end), (function(ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "with",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "with"
                                                                      });
                                                          end end)); end end 
                                           if ___conditional___ == 34--[[ Unqualified_gadt_pattern ]] then do
                                              return Curry._4(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The GADT constructor ",
                                                                      --[[ String ]]Block.__(2, {
                                                                          --[[ No_padding ]]0,
                                                                          --[[ String_literal ]]Block.__(11, {
                                                                              " of type ",
                                                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Break ]]Block.__(0, {
                                                                                          "@ ",
                                                                                          1,
                                                                                          0
                                                                                        }),
                                                                                      --[[ String ]]Block.__(2, {
                                                                                          --[[ No_padding ]]0,
                                                                                          --[[ Char_literal ]]Block.__(12, {
                                                                                              --[[ "." ]]46,
                                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                                  --[[ Close_box ]]0,
                                                                                                  --[[ End_of_format ]]0
                                                                                                })
                                                                                            })
                                                                                        })
                                                                                    })})
                                                                            })
                                                                        })
                                                                    })
                                                                }),
                                                              "@[The GADT constructor %s of type %a@ %s.@]"
                                                            }), param_1[1], path, param_1[0], "must be qualified in this pattern"); end end 
                                          
                                        end
                                      end end 
                                    end end));
                      end end), param[3]);
        end else if (param[0] == Error_forward_1) then do
          return param[1];
        end else do
          return ;
        end end  end 
      end end));

add_delayed_check_forward.contents = add_delayed_check;

__Error_8 = Caml_exceptions.create("Ocaml_typedtree_test.Typedecl.Error");

function enter_type_1(env, sdecl, id) do
  match = sdecl.ptype_manifest;
  decl_type_params = List.map((function(param) do
          return newty2(100000000, --[[ Tvar ]]Block.__(0, {undefined}));
        end end), sdecl.ptype_params);
  decl_type_arity = List.length(sdecl.ptype_params);
  decl_type_private = sdecl.ptype_private;
  decl_type_manifest = match ~= undefined and newvar(undefined, --[[ () ]]0) or undefined;
  decl_type_variance = List.map((function(param) do
          return Types_Variance.full;
        end end), sdecl.ptype_params);
  decl_type_loc = sdecl.ptype_loc;
  decl_type_attributes = sdecl.ptype_attributes;
  decl = do
    type_params: decl_type_params,
    type_arity: decl_type_arity,
    type_kind: --[[ Type_abstract ]]0,
    type_private: decl_type_private,
    type_manifest: decl_type_manifest,
    type_variance: decl_type_variance,
    type_newtype_level: undefined,
    type_loc: decl_type_loc,
    type_attributes: decl_type_attributes
  end;
  return add_type_1(true, id, decl, env);
end end

function is_fixed_type(sd) do
  match = sd.ptype_manifest;
  if (match ~= undefined and sd.ptype_kind == --[[ Ptype_abstract ]]0 and sd.ptype_private == --[[ Private ]]0) then do
    _sty = match;
    while(true) do
      sty = _sty;
      match_1 = sty.ptyp_desc;
      if (typeof match_1 == "number") then do
        return false;
      end else do
        local ___conditional___=(match_1.tag | 0);
        do
           if ___conditional___ == 4--[[ Ptyp_object ]] then do
              if (match_1[1]) then do
                return true;
              end else do
                return false;
              end end  end end 
           if ___conditional___ == 5--[[ Ptyp_class ]] then do
              return true; end end 
           if ___conditional___ == 6--[[ Ptyp_alias ]] then do
              _sty = match_1[0];
              ::continue:: ; end end 
           if ___conditional___ == 7--[[ Ptyp_variant ]] then do
              if (match_1[1]) then do
                return true;
              end else do
                return match_1[2] ~= undefined;
              end end  end end 
          return false;
            
        end
      end end 
    end;
  end else do
    return false;
  end end 
end end

function set_fixed_row(env, loc, p, decl) do
  match = decl.type_manifest;
  tm;
  if (match ~= undefined) then do
    tm = expand_head(env, match);
  end else do
    error({
      Caml_builtin_exceptions.assert_failure,
      --[[ tuple ]]{
        "typedecl.ml",
        113,
        14
      }
    })
  end end 
  match_1 = tm.desc;
  rv;
  if (typeof match_1 == "number") then do
    error({
      __Error_8,
      loc,
      --[[ Bad_fixed_type ]]Block.__(18, {"is not an object or variant"})
    })
  end else do
    local ___conditional___=(match_1.tag | 0);
    do
       if ___conditional___ == 4--[[ Tobject ]] then do
          rv = flatten_fields(match_1[0])[1]; end else 
       if ___conditional___ == 8--[[ Tvariant ]] then do
          row = row_repr_aux(--[[ [] ]]0, match_1[0]);
          tm.desc = --[[ Tvariant ]]Block.__(8, {do
                row_fields: row.row_fields,
                row_more: row.row_more,
                row_bound: row.row_bound,
                row_closed: row.row_closed,
                row_fixed: true,
                row_name: row.row_name
              end});
          rv = static_row(row) and newty2(100000000, --[[ Tnil ]]0) or row.row_more; end else 
       end end end end
      error({
          __Error_8,
          loc,
          --[[ Bad_fixed_type ]]Block.__(18, {"is not an object or variant"})
        })
        
    end
  end end 
  if (not is_Tvar(rv)) then do
    error({
      __Error_8,
      loc,
      --[[ Bad_fixed_type ]]Block.__(18, {"has no row variable"})
    })
  end
   end 
  rv.desc = --[[ Tconstr ]]Block.__(3, {
      p,
      decl.type_params,
      do
        contents: --[[ Mnil ]]0
      end
    });
  return --[[ () ]]0;
end end

function height_10(param) do
  if (param) then do
    return param[--[[ h ]]3];
  end else do
    return 0;
  end end 
end end

function create_11(l, v, r) do
  hl = l and l[--[[ h ]]3] or 0;
  hr = r and r[--[[ h ]]3] or 0;
  return --[[ Node ]]{
          --[[ l ]]l,
          --[[ v ]]v,
          --[[ r ]]r,
          --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
        };
end end

function bal_10(l, v, r) do
  hl = l and l[--[[ h ]]3] or 0;
  hr = r and r[--[[ h ]]3] or 0;
  if (hl > (hr + 2 | 0)) then do
    if (l) then do
      lr = l[--[[ r ]]2];
      lv = l[--[[ v ]]1];
      ll = l[--[[ l ]]0];
      if (height_10(ll) >= height_10(lr)) then do
        return create_11(ll, lv, create_11(lr, v, r));
      end else if (lr) then do
        return create_11(create_11(ll, lv, lr[--[[ l ]]0]), lr[--[[ v ]]1], create_11(lr[--[[ r ]]2], v, r));
      end else do
        error({
          Caml_builtin_exceptions.invalid_argument,
          "Set.bal"
        })
      end end  end 
    end else do
      error({
        Caml_builtin_exceptions.invalid_argument,
        "Set.bal"
      })
    end end 
  end else if (hr > (hl + 2 | 0)) then do
    if (r) then do
      rr = r[--[[ r ]]2];
      rv = r[--[[ v ]]1];
      rl = r[--[[ l ]]0];
      if (height_10(rr) >= height_10(rl)) then do
        return create_11(create_11(l, v, rl), rv, rr);
      end else if (rl) then do
        return create_11(create_11(l, v, rl[--[[ l ]]0]), rl[--[[ v ]]1], create_11(rl[--[[ r ]]2], rv, rr));
      end else do
        error({
          Caml_builtin_exceptions.invalid_argument,
          "Set.bal"
        })
      end end  end 
    end else do
      error({
        Caml_builtin_exceptions.invalid_argument,
        "Set.bal"
      })
    end end 
  end else do
    return --[[ Node ]]{
            --[[ l ]]l,
            --[[ v ]]v,
            --[[ r ]]r,
            --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
          };
  end end  end 
end end

function add_12(x, t) do
  if (t) then do
    r = t[--[[ r ]]2];
    v = t[--[[ v ]]1];
    l = t[--[[ l ]]0];
    c = Caml_primitive.caml_string_compare(x, v);
    if (c == 0) then do
      return t;
    end else if (c < 0) then do
      ll = add_12(x, l);
      if (l == ll) then do
        return t;
      end else do
        return bal_10(ll, v, r);
      end end 
    end else do
      rr = add_12(x, r);
      if (r == rr) then do
        return t;
      end else do
        return bal_10(l, v, rr);
      end end 
    end end  end 
  end else do
    return --[[ Node ]]{
            --[[ l : Empty ]]0,
            --[[ v ]]x,
            --[[ r : Empty ]]0,
            --[[ h ]]1
          };
  end end 
end end

function mem_6(x, _param) do
  while(true) do
    param = _param;
    if (param) then do
      c = Caml_primitive.caml_string_compare(x, param[--[[ v ]]1]);
      if (c == 0) then do
        return true;
      end else do
        _param = c < 0 and param[--[[ l ]]0] or param[--[[ r ]]2];
        ::continue:: ;
      end end 
    end else do
      return false;
    end end 
  end;
end end

function make_params(env, params) do
  make_param = function(param) do
    sty = param[0];
    xpcall(function() do
      return --[[ tuple ]]{
              transl_type_param(env, sty),
              param[1]
            };
    end end,function(exn) do
      if (exn == Already_bound) then do
        error({
          __Error_8,
          sty.ptyp_loc,
          --[[ Repeated_parameter ]]0
        })
      end
       end 
      error(exn)
    end end)
  end end;
  return List.map(make_param, params);
end end

function make_constructor(env, type_path, type_params, sargs, sret_type) do
  if (sret_type ~= undefined) then do
    sret_type_1 = sret_type;
    z = narrow(--[[ () ]]0);
    reset_type_variables(--[[ () ]]0);
    targs = List.map((function(param) do
            return transl_simple_type(env, false, param);
          end end), sargs);
    args = List.map((function(cty) do
            return cty.ctyp_type;
          end end), targs);
    tret_type = transl_simple_type(env, false, sret_type_1);
    ret_type = tret_type.ctyp_type;
    match = repr(ret_type).desc;
    exit = 0;
    if (typeof match == "number" or not (match.tag == --[[ Tconstr ]]3 and same(type_path, match[0]))) then do
      exit = 1;
    end
     end 
    if (exit == 1) then do
      error({
        __Error_8,
        sret_type_1.ptyp_loc,
        --[[ Constraint_failed ]]Block.__(5, {
            ret_type,
            newconstr(type_path, type_params)
          })
      })
    end
     end 
    widen(z);
    return --[[ tuple ]]{
            targs,
            tret_type,
            args,
            ret_type
          };
  end else do
    targs_1 = List.map((function(param) do
            return transl_simple_type(env, true, param);
          end end), sargs);
    args_1 = List.map((function(cty) do
            return cty.ctyp_type;
          end end), targs_1);
    return --[[ tuple ]]{
            targs_1,
            undefined,
            args_1,
            undefined
          };
  end end 
end end

function generalize_decl(decl) do
  List.iter(generalize, decl.type_params);
  match = decl.type_kind;
  if (typeof match == "number") then do
    match == --[[ Type_abstract ]]0;
  end else if (match.tag) then do
    List.iter((function(c) do
            List.iter(generalize, c.cd_args);
            return may(generalize, c.cd_res);
          end end), match[0]);
  end else do
    List.iter((function(l) do
            return iter_generalize_1(do
                        contents: --[[ [] ]]0
                      end, l.ld_type);
          end end), match[0]);
  end end  end 
  match_1 = decl.type_manifest;
  if (match_1 ~= undefined) then do
    return iter_generalize_1(do
                contents: --[[ [] ]]0
              end, match_1);
  end else do
    return --[[ () ]]0;
  end end 
end end

function check_constraints_rec(env, loc, visited, _ty) do
  while(true) do
    ty = _ty;
    ty_1 = repr(ty);
    if (mem_3(ty_1, visited.contents)) then do
      return --[[ () ]]0;
    end else do
      visited.contents = add_3(ty_1, visited.contents);
      match = ty_1.desc;
      if (typeof match == "number") then do
        return iter_type_expr((function(param) do
                      return check_constraints_rec(env, loc, visited, param);
                    end end), ty_1);
      end else do
        local ___conditional___=(match.tag | 0);
        do
           if ___conditional___ == 3--[[ Tconstr ]] then do
              args = match[1];
              path = match[0];
              args$prime = List.map((function(param) do
                      return newvar(undefined, --[[ () ]]0);
                    end end), args);
              ty$prime = newconstr(path, args$prime);
              xpcall(function() do
                enforce_constraints(env, ty$prime);
              end end,function(raw_exn) do
                exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                if (exn[0] == Unify) then do
                  error({
                    Caml_builtin_exceptions.assert_failure,
                    --[[ tuple ]]{
                      "typedecl.ml",
                      360,
                      28
                    }
                  })
                end
                 end 
                if (exn == Caml_builtin_exceptions.not_found) then do
                  error({
                    __Error_8,
                    loc,
                    --[[ Unavailable_type_constructor ]]Block.__(17, {path})
                  })
                end
                 end 
                error(exn)
              end end)
              if (not matches(env, ty_1, ty$prime)) then do
                error({
                  __Error_8,
                  loc,
                  --[[ Constraint_failed ]]Block.__(5, {
                      ty_1,
                      ty$prime
                    })
                })
              end
               end 
              return List.iter((function(param) do
                            return check_constraints_rec(env, loc, visited, param);
                          end end), args); end end 
           if ___conditional___ == 10--[[ Tpoly ]] then do
              match_1 = instance_poly(undefined, false, match[1], match[0]);
              _ty = match_1[1];
              ::continue:: ; end end 
          return iter_type_expr((function(param) do
                          return check_constraints_rec(env, loc, visited, param);
                        end end), ty_1);
            
        end
      end end 
    end end 
  end;
end end

function height_11(param) do
  if (param) then do
    return param[--[[ h ]]4];
  end else do
    return 0;
  end end 
end end

function create_12(l, x, d, r) do
  hl = height_11(l);
  hr = height_11(r);
  return --[[ Node ]]{
          --[[ l ]]l,
          --[[ v ]]x,
          --[[ d ]]d,
          --[[ r ]]r,
          --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
        };
end end

function bal_11(l, x, d, r) do
  hl = l and l[--[[ h ]]4] or 0;
  hr = r and r[--[[ h ]]4] or 0;
  if (hl > (hr + 2 | 0)) then do
    if (l) then do
      lr = l[--[[ r ]]3];
      ld = l[--[[ d ]]2];
      lv = l[--[[ v ]]1];
      ll = l[--[[ l ]]0];
      if (height_11(ll) >= height_11(lr)) then do
        return create_12(ll, lv, ld, create_12(lr, x, d, r));
      end else if (lr) then do
        return create_12(create_12(ll, lv, ld, lr[--[[ l ]]0]), lr[--[[ v ]]1], lr[--[[ d ]]2], create_12(lr[--[[ r ]]3], x, d, r));
      end else do
        error({
          Caml_builtin_exceptions.invalid_argument,
          "Map.bal"
        })
      end end  end 
    end else do
      error({
        Caml_builtin_exceptions.invalid_argument,
        "Map.bal"
      })
    end end 
  end else if (hr > (hl + 2 | 0)) then do
    if (r) then do
      rr = r[--[[ r ]]3];
      rd = r[--[[ d ]]2];
      rv = r[--[[ v ]]1];
      rl = r[--[[ l ]]0];
      if (height_11(rr) >= height_11(rl)) then do
        return create_12(create_12(l, x, d, rl), rv, rd, rr);
      end else if (rl) then do
        return create_12(create_12(l, x, d, rl[--[[ l ]]0]), rl[--[[ v ]]1], rl[--[[ d ]]2], create_12(rl[--[[ r ]]3], rv, rd, rr));
      end else do
        error({
          Caml_builtin_exceptions.invalid_argument,
          "Map.bal"
        })
      end end  end 
    end else do
      error({
        Caml_builtin_exceptions.invalid_argument,
        "Map.bal"
      })
    end end 
  end else do
    return --[[ Node ]]{
            --[[ l ]]l,
            --[[ v ]]x,
            --[[ d ]]d,
            --[[ r ]]r,
            --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
          };
  end end  end 
end end

function add_13(x, data, m) do
  if (m) then do
    r = m[--[[ r ]]3];
    d = m[--[[ d ]]2];
    v = m[--[[ v ]]1];
    l = m[--[[ l ]]0];
    c = Caml_primitive.caml_string_compare(x, v);
    if (c == 0) then do
      if (d == data) then do
        return m;
      end else do
        return --[[ Node ]]{
                --[[ l ]]l,
                --[[ v ]]x,
                --[[ d ]]data,
                --[[ r ]]r,
                --[[ h ]]m[--[[ h ]]4]
              };
      end end 
    end else if (c < 0) then do
      ll = add_13(x, data, l);
      if (l == ll) then do
        return m;
      end else do
        return bal_11(ll, v, d, r);
      end end 
    end else do
      rr = add_13(x, data, r);
      if (r == rr) then do
        return m;
      end else do
        return bal_11(l, v, d, rr);
      end end 
    end end  end 
  end else do
    return --[[ Node ]]{
            --[[ l : Empty ]]0,
            --[[ v ]]x,
            --[[ d ]]data,
            --[[ r : Empty ]]0,
            --[[ h ]]1
          };
  end end 
end end

function find_6(x, _param) do
  while(true) do
    param = _param;
    if (param) then do
      c = Caml_primitive.caml_string_compare(x, param[--[[ v ]]1]);
      if (c == 0) then do
        return param[--[[ d ]]2];
      end else do
        _param = c < 0 and param[--[[ l ]]0] or param[--[[ r ]]3];
        ::continue:: ;
      end end 
    end else do
      error(Caml_builtin_exceptions.not_found)
    end end 
  end;
end end

function check_coherence(env, loc, id, decl) do
  match = decl.type_kind;
  if (typeof match == "number" and match == 0) then do
    return --[[ () ]]0;
  end
   end 
  match_1 = decl.type_manifest;
  if (match_1 ~= undefined) then do
    ty = match_1;
    match_2 = repr(ty).desc;
    if (typeof match_2 == "number") then do
      error({
        __Error_8,
        loc,
        --[[ Definition_mismatch ]]Block.__(4, {
            ty,
            --[[ [] ]]0
          })
      })
    end else if (match_2.tag == --[[ Tconstr ]]3) then do
      args = match_2[1];
      path = match_2[0];
      xpcall(function() do
        decl$prime = find_type_full(path, env)[0];
        err = List.length(args) ~= List.length(decl.type_params) and --[[ :: ]]{
            --[[ Arity ]]0,
            --[[ [] ]]0
          } or (
            equal_4(env, false, args, decl.type_params) and type_declarations_1(true, env, last(path), decl$prime, id, type_declaration(add_type(id, path, identity), decl)) or --[[ :: ]]{
                --[[ Constraint ]]3,
                --[[ [] ]]0
              }
          );
        if (err ~= --[[ [] ]]0) then do
          error({
            __Error_8,
            loc,
            --[[ Definition_mismatch ]]Block.__(4, {
                ty,
                err
              })
          })
        end else do
          return 0;
        end end 
      end end,function(exn) do
        if (exn == Caml_builtin_exceptions.not_found) then do
          error({
            __Error_8,
            loc,
            --[[ Unavailable_type_constructor ]]Block.__(17, {path})
          })
        end
         end 
        error(exn)
      end end)
    end else do
      error({
        __Error_8,
        loc,
        --[[ Definition_mismatch ]]Block.__(4, {
            ty,
            --[[ [] ]]0
          })
      })
    end end  end 
  end else do
    return --[[ () ]]0;
  end end 
end end

function check_well_founded(env, loc, path, to_check, ty) do
  visited = do
    contents: --[[ Empty ]]0
  end;
  check = function(ty0, exp_nodes, ty) do
    ty_1 = repr(ty);
    if (mem_3(ty_1, exp_nodes)) then do
      match = ty0.desc;
      tmp;
      tmp = typeof match == "number" or match.tag ~= --[[ Tconstr ]]3 and false or same(match[0], path);
      if (tmp) then do
        error({
          __Error_8,
          loc,
          --[[ Recursive_abbrev ]]Block.__(2, {name(undefined, path)})
        })
      end
       end 
      error({
        __Error_8,
        loc,
        --[[ Cycle_in_def ]]Block.__(3, {
            name(undefined, path),
            ty0
          })
      })
    end
     end 
    match_1;
    xpcall(function() do
      prev = find_1(ty_1, visited.contents);
      match_1 = subset_1(exp_nodes, prev) and --[[ tuple ]]{
          true,
          exp_nodes
        } or --[[ tuple ]]{
          false,
          union_2(exp_nodes, prev)
        };
    end end,function(exn) do
      if (exn == Caml_builtin_exceptions.not_found) then do
        match_1 = --[[ tuple ]]{
          false,
          exp_nodes
        };
      end else do
        error(exn)
      end end 
    end end)
    exp_nodes_1 = match_1[1];
    snap = snapshot(--[[ () ]]0);
    if (match_1[0]) then do
      return --[[ () ]]0;
    end else do
      xpcall(function() do
        visited.contents = add_4(ty_1, exp_nodes_1, visited.contents);
        match_2 = ty_1.desc;
        if (typeof match_2 == "number") then do
          error(Cannot_expand)
        end else if (match_2.tag == --[[ Tconstr ]]3) then do
          if (not (
              exp_nodes_1 and false or true
            ) or Curry._1(to_check, match_2[0])) then do
            ty$prime = try_expand_once_opt(env, ty_1);
            ty0_1 = (
              exp_nodes_1 and false or true
            ) and ty_1 or ty0;
            return check(ty0_1, add_3(ty_1, exp_nodes_1), ty$prime);
          end else do
            error(Cannot_expand)
          end end 
        end else do
          error(Cannot_expand)
        end end  end 
      end end,function(raw_exn) do
        exn_1 = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn_1 == Cannot_expand) then do
          tmp_1 = true;
          if (not (recursive_types.contents and is_contractive(env, ty_1))) then do
            match_3 = ty_1.desc;
            tmp_2;
            if (typeof match_3 == "number") then do
              tmp_2 = false;
            end else do
              local ___conditional___=(match_3.tag | 0);
              do
                 if ___conditional___ == 4--[[ Tobject ]]
                 or ___conditional___ == 8--[[ Tvariant ]] then do
                    tmp_2 = true; end else 
                 end end
                tmp_2 = false;
                  
              end
            end end 
            tmp_1 = tmp_2;
          end
           end 
          nodes = tmp_1 and --[[ Empty ]]0 or exp_nodes_1;
          return iter_type_expr((function(param) do
                        return check(ty0, nodes, param);
                      end end), ty_1);
        end else if (exn_1[0] == Unify) then do
          return backtrack(snap);
        end else do
          error(exn_1)
        end end  end 
      end end)
    end end 
  end end;
  return wrap_trace_gadt_instances(env, (function(param) do
                return check(ty, --[[ Empty ]]0, param);
              end end), ty);
end end

function check_well_founded_decl(env, loc, path, decl, to_check) do
  it_it_type_expr = function(param) do
    return (function(param) do
        return check_well_founded(env, loc, path, to_check, param);
      end end);
  end end;
  it = do
    it_signature: it_signature,
    it_signature_item: it_signature_item,
    it_value_description: it_value_description,
    it_type_declaration: it_type_declaration,
    it_extension_constructor: it_extension_constructor,
    it_module_declaration: it_module_declaration,
    it_modtype_declaration: it_modtype_declaration,
    it_class_declaration: it_class_declaration,
    it_class_type_declaration: it_class_type_declaration,
    it_module_type: it_module_type,
    it_class_type: it_class_type,
    it_type_kind: it_type_kind,
    it_do_type_expr: it_do_type_expr,
    it_type_expr: it_it_type_expr,
    it_path: it_path
  end;
  return it_type_declaration(it, instance_declaration(decl));
end end

function check_recursion(env, loc, path, decl, to_check) do
  if (decl.type_params == --[[ [] ]]0) then do
    return --[[ () ]]0;
  end else do
    visited = do
      contents: --[[ [] ]]0
    end;
    check_regular = function(cpath, args, prev_exp, _ty) do
      while(true) do
        ty = _ty;
        ty_1 = repr(ty);
        if (List.memq(ty_1, visited.contents)) then do
          return 0;
        end else do
          visited.contents = --[[ :: ]]{
            ty_1,
            visited.contents
          };
          match = ty_1.desc;
          if (typeof match == "number") then do
            return iter_type_expr((function(param) do
                          return check_regular(cpath, args, prev_exp, param);
                        end end), ty_1);
          end else do
            local ___conditional___=(match.tag | 0);
            do
               if ___conditional___ == 3--[[ Tconstr ]] then do
                  args$prime = match[1];
                  path$prime = match[0];
                  if (same(path, path$prime)) then do
                    if (not equal_4(env, false, args, args$prime)) then do
                      error({
                        __Error_8,
                        loc,
                        --[[ Parameters_differ ]]Block.__(8, {
                            cpath,
                            ty_1,
                            newconstr(path, args)
                          })
                      })
                    end
                     end 
                  end else if (Curry._1(to_check, path$prime) and not List.mem(path$prime, prev_exp)) then do
                    xpcall(function() do
                      match_1 = find_type_expansion(path$prime, env);
                      params0 = match_1[0];
                      match_2 = instance_parameterized_type(undefined, params0, match_1[1]);
                      xpcall(function() do
                        List.iter2((function(param, param_1) do
                                return unify_2(env, param, param_1);
                              end end), match_2[0], args$prime);
                      end end,function(raw_exn) do
                        exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                        if (exn[0] == Unify) then do
                          error({
                            __Error_8,
                            loc,
                            --[[ Constraint_failed ]]Block.__(5, {
                                ty_1,
                                newconstr(path$prime, params0)
                              })
                          })
                        end
                         end 
                        error(exn)
                      end end)
                      check_regular(path$prime, args, --[[ :: ]]{
                            path$prime,
                            prev_exp
                          }, match_2[1]);
                    end end,function(exn_1) do
                      if (exn_1 ~= Caml_builtin_exceptions.not_found) then do
                        error(exn_1)
                      end
                       end 
                    end end)
                  end
                   end  end 
                  return List.iter((function(param) do
                                return check_regular(cpath, args, prev_exp, param);
                              end end), args$prime); end end 
               if ___conditional___ == 10--[[ Tpoly ]] then do
                  match_3 = instance_poly(true, false, match[1], match[0]);
                  _ty = match_3[1];
                  ::continue:: ; end end 
              return iter_type_expr((function(param) do
                              return check_regular(cpath, args, prev_exp, param);
                            end end), ty_1);
                
            end
          end end 
        end end 
      end;
    end end;
    return may((function(body) do
                  match = instance_parameterized_type(true, decl.type_params, body);
                  return check_regular(path, match[0], --[[ [] ]]0, match[1]);
                end end), decl.type_manifest);
  end end 
end end

function get_variance(ty, visited) do
  xpcall(function() do
    return find_1(ty, visited.contents);
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return Types_Variance.__null;
    end else do
      error(exn)
    end end 
  end end)
end end

function compute_variance(env, visited, vari, ty) do
  compute_variance_rec = function(_vari, _ty) do
    while(true) do
      ty = _ty;
      vari = _vari;
      ty_1 = repr(ty);
      vari$prime = get_variance(ty_1, visited);
      if (Curry._2(Types_Variance.subset, vari, vari$prime)) then do
        return --[[ () ]]0;
      end else do
        vari_1 = Curry._2(Types_Variance.union, vari, vari$prime);
        visited.contents = add_4(ty_1, vari_1, visited.contents);
        compute_same = (function(vari_1)do
        return function compute_same(param) do
          return compute_variance_rec(vari_1, param);
        end end
        end end)(vari_1);
        match = ty_1.desc;
        if (typeof match == "number") then do
          return --[[ () ]]0;
        end else do
          local ___conditional___=(match.tag | 0);
          do
             if ___conditional___ == 1--[[ Tarrow ]] then do
                v = Curry._1(Types_Variance.conjugate, vari_1);
                v1 = Curry._2(Types_Variance.mem, --[[ May_pos ]]0, v) or Curry._2(Types_Variance.mem, --[[ May_neg ]]1, v) and Curry._3(Types_Variance.set, --[[ May_weak ]]2, true, v) or v;
                compute_variance_rec(v1, match[1]);
                _ty = match[2];
                _vari = vari_1;
                ::continue:: ; end end 
             if ___conditional___ == 2--[[ Ttuple ]] then do
                return List.iter(compute_same, match[0]); end end 
             if ___conditional___ == 3--[[ Tconstr ]] then do
                tl = match[1];
                if (tl == --[[ [] ]]0) then do
                  return --[[ () ]]0;
                end else do
                  xpcall(function() do
                    decl = find_type_full(match[0], env)[0];
                    return List.iter2((function(vari_1)do
                              return function (ty, v) do
                                strict = Curry._2(Types_Variance.mem, --[[ Inv ]]6, vari_1) and Curry._2(Types_Variance.mem, --[[ Inj ]]3, v) or (Curry._2(Types_Variance.mem, --[[ Pos ]]4, vari_1) or Curry._2(Types_Variance.mem, --[[ Neg ]]5, vari_1)) and Curry._2(Types_Variance.mem, --[[ Inv ]]6, v);
                                if (strict) then do
                                  return compute_variance_rec(Types_Variance.full, ty);
                                end else do
                                  p1 = Curry._2(Types_Variance.inter, v, vari_1);
                                  n1 = Curry._2(Types_Variance.inter, v, Curry._1(Types_Variance.conjugate, vari_1));
                                  v1 = Curry._2(Types_Variance.union, Curry._2(Types_Variance.inter, Types_Variance.covariant, Curry._2(Types_Variance.union, p1, Curry._1(Types_Variance.conjugate, p1))), Curry._2(Types_Variance.inter, Curry._1(Types_Variance.conjugate, Types_Variance.covariant), Curry._2(Types_Variance.union, n1, Curry._1(Types_Variance.conjugate, n1))));
                                  weak = Curry._2(Types_Variance.mem, --[[ May_weak ]]2, vari_1) and (Curry._2(Types_Variance.mem, --[[ May_pos ]]0, v) or Curry._2(Types_Variance.mem, --[[ May_neg ]]1, v)) or (Curry._2(Types_Variance.mem, --[[ May_pos ]]0, vari_1) or Curry._2(Types_Variance.mem, --[[ May_neg ]]1, vari_1)) and Curry._2(Types_Variance.mem, --[[ May_weak ]]2, v);
                                  v2 = Curry._3(Types_Variance.set, --[[ May_weak ]]2, weak, v1);
                                  return compute_variance_rec(v2, ty);
                                end end 
                              end end
                              end end)(vari_1), tl, decl.type_variance);
                  end end,function(exn) do
                    if (exn == Caml_builtin_exceptions.not_found) then do
                      return List.iter((function(param) do
                                    return compute_variance_rec(Types_Variance.may_inv, param);
                                  end end), tl);
                    end else do
                      error(exn)
                    end end 
                  end end)
                end end  end end 
             if ___conditional___ == 5--[[ Tfield ]] then do
                compute_variance_rec(vari_1, match[2]);
                _ty = match[3];
                _vari = vari_1;
                ::continue:: ; end end 
             if ___conditional___ == 8--[[ Tvariant ]] then do
                row = row_repr_aux(--[[ [] ]]0, match[0]);
                List.iter((function(vari_1)do
                    return function (param) do
                      match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                      if (typeof match == "number") then do
                        return --[[ () ]]0;
                      end else if (match.tag) then do
                        upper = List.fold_left((function(s, f) do
                                return Curry._3(Types_Variance.set, f, true, s);
                              end end), Types_Variance.__null, --[[ :: ]]{
                              --[[ May_pos ]]0,
                              --[[ :: ]]{
                                --[[ May_neg ]]1,
                                --[[ :: ]]{
                                  --[[ May_weak ]]2,
                                  --[[ [] ]]0
                                }
                              }
                            });
                        v = Curry._2(Types_Variance.inter, vari_1, upper);
                        return List.iter((function(param) do
                                      return compute_variance_rec(v, param);
                                    end end), match[1]);
                      end else do
                        match_1 = match[0];
                        if (match_1 ~= undefined) then do
                          return compute_variance_rec(vari_1, match_1);
                        end else do
                          return --[[ () ]]0;
                        end end 
                      end end  end 
                    end end
                    end end)(vari_1), row.row_fields);
                _ty = row.row_more;
                _vari = vari_1;
                ::continue:: ; end end 
             if ___conditional___ == 4--[[ Tobject ]]
             or ___conditional___ == 7--[[ Tsubst ]]
             or ___conditional___ == 10--[[ Tpoly ]] then do
                _ty = match[0];
                _vari = vari_1;
                ::continue:: ; end end 
             if ___conditional___ == 11--[[ Tpackage ]] then do
                v_1 = Curry._2(Types_Variance.mem, --[[ Pos ]]4, vari_1) or Curry._2(Types_Variance.mem, --[[ Neg ]]5, vari_1) and Types_Variance.full or Types_Variance.may_inv;
                return List.iter((function(v_1)do
                          return function (param) do
                            return compute_variance_rec(v_1, param);
                          end end
                          end end)(v_1), match[2]); end end 
            return --[[ () ]]0;
              
          end
        end end 
      end end 
    end;
  end end;
  return compute_variance_rec(vari, ty);
end end

function make(p, n, i) do
  return Curry._3(Types_Variance.set, --[[ May_pos ]]0, p, Curry._3(Types_Variance.set, --[[ May_neg ]]1, n, Curry._3(Types_Variance.set, --[[ May_weak ]]2, n, Curry._3(Types_Variance.set, --[[ Inj ]]3, i, Types_Variance.__null))));
end end

function compute_variance_type(env, check, param, decl, tyl) do
  loc = param[1];
  required = List.map((function(param) do
          i = param[2];
          n = param[1];
          c = param[0];
          if (c or n) then do
            return --[[ tuple ]]{
                    c,
                    n,
                    i
                  };
          end else do
            return --[[ tuple ]]{
                    true,
                    true,
                    i
                  };
          end end 
        end end), param[0]);
  params = List.map(repr, decl.type_params);
  tvl = do
    contents: --[[ Empty ]]0
  end;
  List.iter((function(param) do
          return compute_variance(env, tvl, param[0] and Types_Variance.full or Types_Variance.covariant, param[1]);
        end end), tyl);
  if (check) then do
    pos = do
      contents: 0
    end;
    List.iter2((function(ty, param) do
            i = param[2];
            n = param[1];
            c = param[0];
            pos.contents = pos.contents + 1 | 0;
            __var = get_variance(ty, tvl);
            match = Curry._1(Types_Variance.get_upper, __var);
            cn = match[1];
            co = match[0];
            ij = Curry._2(Types_Variance.mem, --[[ Inj ]]3, __var);
            if (is_Tvar(ty) and (co and not c or cn and not n or not ij and i)) then do
              error({
                __Error_8,
                loc,
                --[[ Bad_variance ]]Block.__(16, {
                    pos.contents,
                    --[[ tuple ]]{
                      co,
                      cn,
                      ij
                    },
                    --[[ tuple ]]{
                      c,
                      n,
                      i
                    }
                  })
              })
            end else do
              return 0;
            end end 
          end end), params, required);
    args = newty2(100000000, --[[ Ttuple ]]Block.__(2, {params}));
    fvl = free_variables_1(undefined, args);
    fvl_1 = List.filter((function(v) do
              return not List.memq(v, params);
            end end))(fvl);
    if (fvl_1 ~= --[[ [] ]]0) then do
      tvl2 = do
        contents: --[[ Empty ]]0
      end;
      List.iter2((function(ty, param) do
              if (is_Tvar(ty)) then do
                return --[[ () ]]0;
              end else do
                v = param[0] and (
                    param[1] and Types_Variance.full or Types_Variance.covariant
                  ) or Curry._1(Types_Variance.conjugate, Types_Variance.covariant);
                return compute_variance(env, tvl2, v, ty);
              end end 
            end end), params, required);
      visited = do
        contents: --[[ Empty ]]0
      end;
      check_1 = function(ty) do
        ty_1 = repr(ty);
        if (mem_3(ty_1, visited.contents)) then do
          return --[[ () ]]0;
        end else do
          visited$prime = add_3(ty_1, visited.contents);
          visited.contents = visited$prime;
          v1 = get_variance(ty_1, tvl);
          snap = snapshot(--[[ () ]]0);
          v2 = fold_3((function(t, vt, v) do
                  if (equal_4(env, false, --[[ :: ]]{
                          ty_1,
                          --[[ [] ]]0
                        }, --[[ :: ]]{
                          t,
                          --[[ [] ]]0
                        })) then do
                    return Curry._2(Types_Variance.union, vt, v);
                  end else do
                    return v;
                  end end 
                end end), tvl2.contents, Types_Variance.__null);
          backtrack(snap);
          match = Curry._1(Types_Variance.get_upper, v1);
          n1 = match[1];
          c1 = match[0];
          match_1 = Curry._1(Types_Variance.get_lower, v2);
          n2 = match_1[1];
          c2 = match_1[0];
          if (c1 and not c2 or n1 and not n2) then do
            if (List.memq(ty_1, fvl_1)) then do
              code = match_1[3] and (
                  c2 or n2 and -1 or -3
                ) or -2;
              error({
                __Error_8,
                loc,
                --[[ Bad_variance ]]Block.__(16, {
                    code,
                    --[[ tuple ]]{
                      c1,
                      n1,
                      false
                    },
                    --[[ tuple ]]{
                      c2,
                      n2,
                      false
                    }
                  })
              })
            end else do
              return iter_type_expr(check_1, ty_1);
            end end 
          end else do
            return 0;
          end end 
        end end 
      end end;
      List.iter((function(param) do
              return check_1(param[1]);
            end end), tyl);
    end
     end 
  end
   end 
  return List.map2((function(ty, param) do
                v = get_variance(ty, tvl);
                tr = decl.type_private;
                concr = decl.type_kind ~= --[[ Type_abstract ]]0;
                match = tr == --[[ Private ]]0 or not is_Tvar(ty) and --[[ tuple ]]{
                    param[0],
                    param[1]
                  } or --[[ tuple ]]{
                    false,
                    false
                  };
                n = match[1];
                p = match[0];
                i = concr or param[2] and tr == --[[ Private ]]0;
                v_1 = Curry._2(Types_Variance.union, v, make(p, n, i));
                v_2 = concr and (
                    Curry._2(Types_Variance.mem, --[[ Pos ]]4, v_1) and Curry._2(Types_Variance.mem, --[[ Neg ]]5, v_1) and Types_Variance.full or (
                        is_Tvar(ty) and v_1 or Curry._2(Types_Variance.union, v_1, p and (
                                  n and Types_Variance.full or Types_Variance.covariant
                                ) or Curry._1(Types_Variance.conjugate, Types_Variance.covariant))
                      )
                  ) or v_1;
                if (decl.type_kind == --[[ Type_abstract ]]0 and tr == --[[ Public ]]1) then do
                  return v_2;
                end else do
                  return Curry._3(Types_Variance.set, --[[ May_weak ]]2, Curry._2(Types_Variance.mem, --[[ May_neg ]]1, v_2), v_2);
                end end 
              end end), params, required);
end end

function add_false(param) do
  return List.map((function(ty) do
                return --[[ tuple ]]{
                        false,
                        ty
                      };
              end end), param);
end end

function constrained(env, vars, ty) do
  match = ty.desc;
  if (typeof match == "number" or match.tag) then do
    return true;
  end else do
    return List.exists((function(tl) do
                  return List.memq(ty, tl);
                end end), vars);
  end end 
end end

function compute_variance_gadt(env, check, rloc, decl, param) do
  ret_type_opt = param[1];
  tl = param[0];
  loc = rloc[1];
  if (ret_type_opt ~= undefined) then do
    match = repr(ret_type_opt);
    match_1 = match.desc;
    if (typeof match_1 == "number") then do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "typedecl.ml",
          809,
          13
        }
      })
    end else if (match_1.tag == --[[ Tconstr ]]3) then do
      tyl = List.map(repr, match_1[1]);
      fvl = List.map((function(param) do
              return free_variables_1(undefined, param);
            end end), tyl);
      List.fold_left2((function(param, ty, param_1) do
              fv2 = param[1];
              if (fv2) then do
                fv2_1 = fv2[1];
                fv1 = param[0];
                if ((param_1[0] or param_1[1]) and constrained(env, Pervasives.$at(fv1, fv2_1), ty)) then do
                  error({
                    __Error_8,
                    loc,
                    --[[ Varying_anonymous ]]4
                  })
                end
                 end 
                return --[[ tuple ]]{
                        --[[ :: ]]{
                          fv2[0],
                          fv1
                        },
                        fv2_1
                      };
              end else do
                error({
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "typedecl.ml",
                    798,
                    37
                  }
                })
              end end 
            end end), --[[ tuple ]]{
            --[[ [] ]]0,
            fvl
          }, tyl, rloc[0]);
      return compute_variance_type(env, check, rloc, do
                  type_params: tyl,
                  type_arity: decl.type_arity,
                  type_kind: decl.type_kind,
                  type_private: --[[ Private ]]0,
                  type_manifest: decl.type_manifest,
                  type_variance: decl.type_variance,
                  type_newtype_level: decl.type_newtype_level,
                  type_loc: decl.type_loc,
                  type_attributes: decl.type_attributes
                end, add_false(tl));
    end else do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "typedecl.ml",
          809,
          13
        }
      })
    end end  end 
  end else do
    return compute_variance_type(env, check, rloc, do
                type_params: decl.type_params,
                type_arity: decl.type_arity,
                type_kind: decl.type_kind,
                type_private: --[[ Private ]]0,
                type_manifest: decl.type_manifest,
                type_variance: decl.type_variance,
                type_newtype_level: decl.type_newtype_level,
                type_loc: decl.type_loc,
                type_attributes: decl.type_attributes
              end, add_false(tl));
  end end 
end end

function compute_variance_extension(env, check, decl, ext, rloc) do
  return compute_variance_gadt(env, check, rloc, do
              type_params: ext.ext_type_params,
              type_arity: decl.type_arity,
              type_kind: decl.type_kind,
              type_private: decl.type_private,
              type_manifest: decl.type_manifest,
              type_variance: decl.type_variance,
              type_newtype_level: decl.type_newtype_level,
              type_loc: decl.type_loc,
              type_attributes: decl.type_attributes
            end, --[[ tuple ]]{
              ext.ext_args,
              ext.ext_ret_type
            });
end end

function compute_variance_decl(env, check, decl, rloc) do
  if ((decl.type_kind == --[[ Type_abstract ]]0 or decl.type_kind == --[[ Type_open ]]1) and decl.type_manifest == undefined) then do
    return List.map((function(param) do
                  return make(not param[1], not param[0], decl.type_kind ~= --[[ Type_abstract ]]0 or param[2]);
                end end), rloc[0]);
  end else do
    match = decl.type_manifest;
    mn = match ~= undefined and --[[ :: ]]{
        --[[ tuple ]]{
          false,
          match
        },
        --[[ [] ]]0
      } or --[[ [] ]]0;
    match_1 = decl.type_kind;
    if (typeof match_1 == "number") then do
      return compute_variance_type(env, check, rloc, decl, mn);
    end else if (match_1.tag) then do
      tll = match_1[0];
      if (List.for_all((function(c) do
                return c.cd_res == undefined;
              end end), tll)) then do
        return compute_variance_type(env, check, rloc, decl, Pervasives.$at(mn, add_false(List.flatten(List.map((function(c) do
                                      return c.cd_args;
                                    end end), tll)))));
      end else do
        mn_1 = List.map((function(param) do
                return --[[ tuple ]]{
                        --[[ :: ]]{
                          param[1],
                          --[[ [] ]]0
                        },
                        undefined
                      };
              end end), mn);
        tll_1 = Pervasives.$at(mn_1, List.map((function(c) do
                    return --[[ tuple ]]{
                            c.cd_args,
                            c.cd_res
                          };
                  end end), tll));
        match_2 = List.map((function(param) do
                return compute_variance_gadt(env, check, rloc, decl, param);
              end end), tll_1);
        if (match_2) then do
          varl = List.fold_left((function(param, param_1) do
                  return List.map2(Types_Variance.union, param, param_1);
                end end), match_2[0], match_2[1]);
          return List.map((function(v) do
                        if (Curry._2(Types_Variance.mem, --[[ Pos ]]4, v) and Curry._2(Types_Variance.mem, --[[ Neg ]]5, v)) then do
                          return Types_Variance.full;
                        end else do
                          return v;
                        end end 
                      end end), varl);
        end else do
          error({
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "typedecl.ml",
              848,
              15
            }
          })
        end end 
      end end 
    end else do
      return compute_variance_type(env, check, rloc, decl, Pervasives.$at(mn, List.map((function(param) do
                            return --[[ tuple ]]{
                                    param.ld_mutable == --[[ Mutable ]]1,
                                    param.ld_type
                                  };
                          end end), match_1[0])));
    end end  end 
  end end 
end end

function is_sharp(id) do
  s = id.name;
  if (#s ~= 0) then do
    return Caml_string.get(s, 0) == --[[ "#" ]]35;
  end else do
    return false;
  end end 
end end

function compute_variance_fixpoint(env, decls, required, _variances) do
  while(true) do
    variances = _variances;
    new_decls = List.map2((function(param, variance) do
            decl = param[1];
            return --[[ tuple ]]{
                    param[0],
                    do
                      type_params: decl.type_params,
                      type_arity: decl.type_arity,
                      type_kind: decl.type_kind,
                      type_private: decl.type_private,
                      type_manifest: decl.type_manifest,
                      type_variance: variance,
                      type_newtype_level: decl.type_newtype_level,
                      type_loc: decl.type_loc,
                      type_attributes: decl.type_attributes
                    end
                  };
          end end), decls, variances);
    new_env = List.fold_right((function(param, env) do
            return add_type_1(true, param[0], param[1], env);
          end end), new_decls, env);
    new_variances = List.map2((function(new_env)do
        return function (param) do
          decl = param[1];
          return (function(param) do
              return compute_variance_decl(new_env, false, decl, param);
            end end);
        end end
        end end)(new_env), new_decls, required);
    new_variances_1 = List.map2((function(param, param_1) do
            return List.map2(Types_Variance.union, param, param_1);
          end end), new_variances, variances);
    if (Caml_obj.caml_notequal(new_variances_1, variances)) then do
      _variances = new_variances_1;
      ::continue:: ;
    end else do
      List.iter2((function(new_env)do
          return function (param, req) do
            if (is_sharp(param[0])) then do
              return 0;
            end else do
              compute_variance_decl(new_env, true, param[1], req);
              return --[[ () ]]0;
            end end 
          end end
          end end)(new_env), new_decls, required);
      return --[[ tuple ]]{
              new_decls,
              new_env
            };
    end end 
  end;
end end

function init_variance(param) do
  return List.map((function(param) do
                return Types_Variance.__null;
              end end), param[1].type_params);
end end

function add_injectivity(param) do
  return List.map((function(param) do
                local ___conditional___=(param);
                do
                   if ___conditional___ == 0--[[ Covariant ]] then do
                      return --[[ tuple ]]{
                              true,
                              false,
                              false
                            }; end end 
                   if ___conditional___ == 1--[[ Contravariant ]] then do
                      return --[[ tuple ]]{
                              false,
                              true,
                              false
                            }; end end 
                   if ___conditional___ == 2--[[ Invariant ]] then do
                      return --[[ tuple ]]{
                              false,
                              false,
                              false
                            }; end end 
                  
                end
              end end), param);
end end

function compute_variance_decls(env, cldecls) do
  match = List.fold_right((function(param, param_1) do
          ci = param[5];
          variance = List.map((function(prim) do
                  return prim[1];
                end end), ci.ci_params);
          return --[[ tuple ]]{
                  --[[ :: ]]{
                    --[[ tuple ]]{
                      param[0],
                      param[1]
                    },
                    param_1[0]
                  },
                  --[[ :: ]]{
                    --[[ tuple ]]{
                      add_injectivity(variance),
                      ci.ci_loc
                    },
                    param_1[1]
                  }
                };
        end end), cldecls, --[[ tuple ]]{
        --[[ [] ]]0,
        --[[ [] ]]0
      });
  decls = match[0];
  variances = List.map(init_variance, decls);
  match_1 = compute_variance_fixpoint(env, decls, match[1], variances);
  return List.map2((function(param, param_1) do
                cltydef = param_1[4];
                clty = param_1[3];
                cl_abbr = param_1[2];
                decl = param[1];
                variance = decl.type_variance;
                return --[[ tuple ]]{
                        decl,
                        do
                          type_params: cl_abbr.type_params,
                          type_arity: cl_abbr.type_arity,
                          type_kind: cl_abbr.type_kind,
                          type_private: cl_abbr.type_private,
                          type_manifest: cl_abbr.type_manifest,
                          type_variance: variance,
                          type_newtype_level: cl_abbr.type_newtype_level,
                          type_loc: cl_abbr.type_loc,
                          type_attributes: cl_abbr.type_attributes
                        end,
                        do
                          cty_params: clty.cty_params,
                          cty_type: clty.cty_type,
                          cty_path: clty.cty_path,
                          cty_new: clty.cty_new,
                          cty_variance: variance,
                          cty_loc: clty.cty_loc,
                          cty_attributes: clty.cty_attributes
                        end,
                        do
                          clty_params: cltydef.clty_params,
                          clty_type: cltydef.clty_type,
                          clty_path: cltydef.clty_path,
                          clty_variance: variance,
                          clty_loc: cltydef.clty_loc,
                          clty_attributes: cltydef.clty_attributes
                        end
                      };
              end end), match_1[0], cldecls);
end end

function check_duplicates(sdecl_list) do
  labels = Hashtbl.create(undefined, 7);
  constrs = Hashtbl.create(undefined, 7);
  return List.iter((function(sdecl) do
                match = sdecl.ptype_kind;
                if (typeof match == "number") then do
                  return --[[ () ]]0;
                end else if (match.tag) then do
                  return List.iter((function(param) do
                                cname = param.pld_name;
                                xpcall(function() do
                                  name$prime = Hashtbl.find(labels, cname.txt);
                                  return prerr_warning(param.pld_loc, --[[ Duplicate_definitions ]]Block.__(14, {
                                                "label",
                                                cname.txt,
                                                name$prime,
                                                sdecl.ptype_name.txt
                                              }));
                                end end,function(exn) do
                                  if (exn == Caml_builtin_exceptions.not_found) then do
                                    return Hashtbl.add(labels, cname.txt, sdecl.ptype_name.txt);
                                  end else do
                                    error(exn)
                                  end end 
                                end end)
                              end end), match[0]);
                end else do
                  return List.iter((function(pcd) do
                                xpcall(function() do
                                  name$prime = Hashtbl.find(constrs, pcd.pcd_name.txt);
                                  return prerr_warning(pcd.pcd_loc, --[[ Duplicate_definitions ]]Block.__(14, {
                                                "constructor",
                                                pcd.pcd_name.txt,
                                                name$prime,
                                                sdecl.ptype_name.txt
                                              }));
                                end end,function(exn) do
                                  if (exn == Caml_builtin_exceptions.not_found) then do
                                    return Hashtbl.add(constrs, pcd.pcd_name.txt, sdecl.ptype_name.txt);
                                  end else do
                                    error(exn)
                                  end end 
                                end end)
                              end end), match[0]);
                end end  end 
              end end), sdecl_list);
end end

function name_recursion(sdecl, id, decl) do
  match = decl.type_kind;
  if (typeof match == "number" and not (match ~= 0 or decl.type_private)) then do
    match_1 = decl.type_manifest;
    if (match_1 ~= undefined and is_fixed_type(sdecl)) then do
      ty = repr(match_1);
      ty$prime = newty2(ty.level, ty.desc);
      if (deep_occur(ty, ty$prime)) then do
        td_000 = --[[ Pident ]]Block.__(0, {id});
        td_001 = decl.type_params;
        td_002 = do
          contents: --[[ Mnil ]]0
        end;
        td = --[[ Tconstr ]]Block.__(3, {
            td_000,
            td_001,
            td_002
          });
        link_type(ty, newty2(ty.level, td));
        return do
                type_params: decl.type_params,
                type_arity: decl.type_arity,
                type_kind: decl.type_kind,
                type_private: decl.type_private,
                type_manifest: ty$prime,
                type_variance: decl.type_variance,
                type_newtype_level: decl.type_newtype_level,
                type_loc: decl.type_loc,
                type_attributes: decl.type_attributes
              end;
      end else do
        return decl;
      end end 
    end else do
      return decl;
    end end 
  end else do
    return decl;
  end end 
end end

function transl_type_decl(env, rec_flag, sdecl_list) do
  fixed_types = List.filter(is_fixed_type)(sdecl_list);
  sdecl_list_1 = Pervasives.$at(List.map((function(sdecl) do
              ptype_name_txt = sdecl.ptype_name.txt .. "#row";
              ptype_name_loc = sdecl.ptype_name.loc;
              ptype_name = do
                txt: ptype_name_txt,
                loc: ptype_name_loc
              end;
              return do
                      ptype_name: ptype_name,
                      ptype_params: sdecl.ptype_params,
                      ptype_cstrs: sdecl.ptype_cstrs,
                      ptype_kind: --[[ Ptype_abstract ]]0,
                      ptype_private: sdecl.ptype_private,
                      ptype_manifest: undefined,
                      ptype_attributes: sdecl.ptype_attributes,
                      ptype_loc: sdecl.ptype_loc
                    end;
            end end), fixed_types), sdecl_list);
  id_list = List.map((function(sdecl) do
          return create(sdecl.ptype_name.txt);
        end end), sdecl_list_1);
  init_def(currentstamp.contents);
  begin_def(--[[ () ]]0);
  temp_env = rec_flag and List.fold_left2(enter_type_1, env, sdecl_list_1, id_list) or env;
  current_slot = do
    contents: undefined
  end;
  warn_unused = is_active(--[[ Unused_type_declaration ]]Block.__(18, {""}));
  id_slots = function(id) do
    if (rec_flag and warn_unused) then do
      slot = do
        contents: --[[ [] ]]0
      end;
      td = find_type_full(--[[ Pident ]]Block.__(0, {id}), temp_env)[0];
      name = id.name;
      set_type_used_callback(name, td, (function(old_callback) do
              match = current_slot.contents;
              if (match ~= undefined) then do
                slot_1 = match;
                slot_1.contents = --[[ :: ]]{
                  --[[ tuple ]]{
                    name,
                    td
                  },
                  slot_1.contents
                };
                return --[[ () ]]0;
              end else do
                List.iter((function(param) do
                        return mark_type_used(env, param[0], param[1]);
                      end end), get_ref(slot));
                return Curry._1(old_callback, --[[ () ]]0);
              end end 
            end end));
      return --[[ tuple ]]{
              id,
              slot
            };
    end else do
      return --[[ tuple ]]{
              id,
              undefined
            };
    end end 
  end end;
  transl_declaration = function(name_sdecl, param) do
    current_slot.contents = param[1];
    env = temp_env;
    sdecl = name_sdecl;
    id = param[0];
    reset_type_variables(--[[ () ]]0);
    begin_def(--[[ () ]]0);
    tparams = make_params(env, sdecl.ptype_params);
    params = List.map((function(param) do
            return param[0].ctyp_type;
          end end), tparams);
    cstrs = List.map((function(param) do
            return --[[ tuple ]]{
                    transl_simple_type(env, false, param[0]),
                    transl_simple_type(env, false, param[1]),
                    param[2]
                  };
          end end), sdecl.ptype_cstrs);
    match = sdecl.ptype_kind;
    match_1;
    if (typeof match == "number") then do
      match_1 = match == --[[ Ptype_abstract ]]0 and --[[ tuple ]]{
          --[[ Ttype_abstract ]]0,
          --[[ Type_abstract ]]0
        } or --[[ tuple ]]{
          --[[ Ttype_open ]]1,
          --[[ Type_open ]]1
        };
    end else if (match.tag) then do
      lbls = match[0];
      if (lbls == --[[ [] ]]0) then do
        ill_formed_ast(sdecl.ptype_loc, "Records cannot be empty.");
      end
       end 
      all_labels = do
        contents: --[[ Empty ]]0
      end;
      List.iter((function(param) do
              name = param.pld_name.txt;
              if (mem_6(name, all_labels.contents)) then do
                error({
                  __Error_8,
                  sdecl.ptype_loc,
                  --[[ Duplicate_label ]]Block.__(1, {name})
                })
              end
               end 
              all_labels.contents = add_12(name, all_labels.contents);
              return --[[ () ]]0;
            end end), lbls);
      lbls_1 = List.map((function(param) do
              name = param.pld_name;
              arg = force_poly(param.pld_type);
              cty = transl_simple_type(env, true, arg);
              return do
                      ld_id: create(name.txt),
                      ld_name: name,
                      ld_mutable: param.pld_mutable,
                      ld_type: cty,
                      ld_loc: param.pld_loc,
                      ld_attributes: param.pld_attributes
                    end;
            end end), lbls);
      lbls$prime = List.map((function(ld) do
              ty = ld.ld_type.ctyp_type;
              match = ty.desc;
              ty_1;
              ty_1 = typeof match == "number" or not (match.tag == --[[ Tpoly ]]10 and not match[1]) and ty or match[0];
              return do
                      ld_id: ld.ld_id,
                      ld_mutable: ld.ld_mutable,
                      ld_type: ty_1,
                      ld_loc: ld.ld_loc,
                      ld_attributes: ld.ld_attributes
                    end;
            end end), lbls_1);
      rep = List.for_all((function(l) do
              env_1 = env;
              ty = l.ld_type;
              match = repr(expand_head_opt(env_1, ty));
              match_1 = match.desc;
              if (typeof match_1 == "number" or match_1.tag ~= --[[ Tconstr ]]3) then do
                return false;
              end else do
                return same(match_1[0], path_float);
              end end 
            end end), lbls$prime) and --[[ Record_float ]]1 or --[[ Record_regular ]]0;
      match_1 = --[[ tuple ]]{
        --[[ Ttype_record ]]Block.__(1, {lbls_1}),
        --[[ Type_record ]]Block.__(0, {
            lbls$prime,
            rep
          })
      };
    end else do
      scstrs = match[0];
      if (scstrs == --[[ [] ]]0) then do
        ill_formed_ast(sdecl.ptype_loc, "Variant types cannot be empty.");
      end
       end 
      all_constrs = do
        contents: --[[ Empty ]]0
      end;
      List.iter((function(param) do
              name = param.pcd_name.txt;
              if (mem_6(name, all_constrs.contents)) then do
                error({
                  __Error_8,
                  sdecl.ptype_loc,
                  --[[ Duplicate_constructor ]]Block.__(0, {name})
                })
              end
               end 
              all_constrs.contents = add_12(name, all_constrs.contents);
              return --[[ () ]]0;
            end end), scstrs);
      if (List.length(List.filter((function(cd) do
                      return cd.pcd_args ~= --[[ [] ]]0;
                    end end))(scstrs)) > 246) then do
        error({
          __Error_8,
          sdecl.ptype_loc,
          --[[ Too_many_constructors ]]1
        })
      end
       end 
      make_cstr = function(scstr) do
        name = create(scstr.pcd_name.txt);
        match = make_constructor(env, --[[ Pident ]]Block.__(0, {id}), params, scstr.pcd_args, scstr.pcd_res);
        tcstr_cd_name = scstr.pcd_name;
        tcstr_cd_args = match[0];
        tcstr_cd_res = match[1];
        tcstr_cd_loc = scstr.pcd_loc;
        tcstr_cd_attributes = scstr.pcd_attributes;
        tcstr = do
          cd_id: name,
          cd_name: tcstr_cd_name,
          cd_args: tcstr_cd_args,
          cd_res: tcstr_cd_res,
          cd_loc: tcstr_cd_loc,
          cd_attributes: tcstr_cd_attributes
        end;
        cstr_cd_args = match[2];
        cstr_cd_res = match[3];
        cstr_cd_loc = scstr.pcd_loc;
        cstr_cd_attributes = scstr.pcd_attributes;
        cstr = do
          cd_id: name,
          cd_args: cstr_cd_args,
          cd_res: cstr_cd_res,
          cd_loc: cstr_cd_loc,
          cd_attributes: cstr_cd_attributes
        end;
        return --[[ tuple ]]{
                tcstr,
                cstr
              };
      end end;
      match_2 = List.split(List.map(make_cstr, scstrs));
      match_1 = --[[ tuple ]]{
        --[[ Ttype_variant ]]Block.__(0, {match_2[0]}),
        --[[ Type_variant ]]Block.__(1, {match_2[1]})
      };
    end end  end 
    match_3 = sdecl.ptype_manifest;
    match_4;
    if (match_3 ~= undefined) then do
      no_row = not is_fixed_type(sdecl);
      cty = transl_simple_type(env, no_row, match_3);
      match_4 = --[[ tuple ]]{
        cty,
        cty.ctyp_type
      };
    end else do
      match_4 = --[[ tuple ]]{
        undefined,
        undefined
      };
    end end 
    man = match_4[1];
    decl_type_arity = List.length(params);
    decl_type_kind = match_1[1];
    decl_type_private = sdecl.ptype_private;
    decl_type_variance = List.map((function(param) do
            return Types_Variance.full;
          end end), params);
    decl_type_loc = sdecl.ptype_loc;
    decl_type_attributes = sdecl.ptype_attributes;
    decl = do
      type_params: params,
      type_arity: decl_type_arity,
      type_kind: decl_type_kind,
      type_private: decl_type_private,
      type_manifest: man,
      type_variance: decl_type_variance,
      type_newtype_level: undefined,
      type_loc: decl_type_loc,
      type_attributes: decl_type_attributes
    end;
    List.iter((function(param) do
            ty = param[0].ctyp_type;
            ty$prime = param[1].ctyp_type;
            xpcall(function() do
              return unify_2(env, ty, ty$prime);
            end end,function(raw_exn) do
              exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn[0] == Unify) then do
                error({
                  __Error_8,
                  param[2],
                  --[[ Inconsistent_constraint ]]Block.__(6, {
                      env,
                      exn[1]
                    })
                })
              end
               end 
              error(exn)
            end end)
          end end), cstrs);
    end_def(--[[ () ]]0);
    if (is_fixed_type(sdecl)) then do
      match_5;
      xpcall(function() do
        match_5 = lookup_type_1(--[[ Lident ]]Block.__(0, {id.name .. "#row"}), env);
      end end,function(exn) do
        if (exn == Caml_builtin_exceptions.not_found) then do
          error({
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "typedecl.ml",
              301,
              26
            }
          })
        end
         end 
        error(exn)
      end end)
      set_fixed_row(env, sdecl.ptype_loc, match_5[0], decl);
    end
     end 
    if (man ~= undefined and cyclic_abbrev(env, id, man)) then do
      error({
        __Error_8,
        sdecl.ptype_loc,
        --[[ Recursive_abbrev ]]Block.__(2, {sdecl.ptype_name.txt})
      })
    end
     end 
    return do
            typ_id: id,
            typ_name: sdecl.ptype_name,
            typ_params: tparams,
            typ_type: decl,
            typ_cstrs: cstrs,
            typ_kind: match_1[0],
            typ_private: sdecl.ptype_private,
            typ_manifest: match_4[0],
            typ_loc: sdecl.ptype_loc,
            typ_attributes: sdecl.ptype_attributes
          end;
  end end;
  tdecls = List.map2(transl_declaration, sdecl_list_1, List.map(id_slots, id_list));
  decls = List.map((function(tdecl) do
          return --[[ tuple ]]{
                  tdecl.typ_id,
                  tdecl.typ_type
                };
        end end), tdecls);
  current_slot.contents = undefined;
  check_duplicates(sdecl_list_1);
  newenv = List.fold_right((function(param, env) do
          return add_type_1(true, param[0], param[1], env);
        end end), decls, env);
  if (rec_flag) then do
    List.iter2((function(id, sdecl) do
            temp_env_1 = temp_env;
            env = newenv;
            id_1 = id;
            loc = sdecl.ptype_loc;
            path = --[[ Pident ]]Block.__(0, {id_1});
            decl = find_type_full(path, temp_env_1)[0];
            match = decl.type_manifest;
            if (match ~= undefined) then do
              params = List.map((function(param) do
                      return newvar(undefined, --[[ () ]]0);
                    end end), decl.type_params);
              xpcall(function() do
                return unify_2(env, newconstr(path, params), match);
              end end,function(raw_exn) do
                exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                if (exn[0] == Unify) then do
                  error({
                    __Error_8,
                    loc,
                    --[[ Type_clash ]]Block.__(7, {
                        env,
                        exn[1]
                      })
                  })
                end
                 end 
                error(exn)
              end end)
            end else do
              return --[[ () ]]0;
            end end 
          end end), id_list, sdecl_list_1);
  end
   end 
  end_def(--[[ () ]]0);
  List.iter((function(param) do
          return generalize_decl(param[1]);
        end end), decls);
  id_loc_list = List.map2((function(id, sdecl) do
          return --[[ tuple ]]{
                  id,
                  sdecl.ptype_loc
                };
        end end), id_list, sdecl_list_1);
  List.iter((function(param) do
          id = param[0];
          env = newenv;
          loc = List.assoc(id, id_loc_list);
          path = --[[ Pident ]]Block.__(0, {id});
          decl = param[1];
          if (decl.type_manifest == undefined) then do
            return --[[ () ]]0;
          end else do
            args = List.map((function(param) do
                    return newvar(undefined, --[[ () ]]0);
                  end end), decl.type_params);
            return check_well_founded(env, loc, path, (function(param) do
                          return same(path, param);
                        end end), newconstr(path, args));
          end end 
        end end), decls);
  to_check = function(param) do
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ == 0--[[ Pident ]] then do
          return List.mem_assoc(param[0], id_loc_list); end end 
       if ___conditional___ == 1--[[ Pdot ]]
       or ___conditional___ == 2--[[ Papply ]] then do
          return false; end end 
      
    end
  end end;
  List.iter((function(param) do
          id = param[0];
          return check_well_founded_decl(newenv, List.assoc(id, id_loc_list), --[[ Pident ]]Block.__(0, {id}), param[1], to_check);
        end end), decls);
  List.iter((function(param) do
          env = newenv;
          id_loc_list_1 = id_loc_list;
          to_check_1 = to_check;
          tdecl = param;
          decl = tdecl.typ_type;
          id = tdecl.typ_id;
          return check_recursion(env, List.assoc(id, id_loc_list_1), --[[ Pident ]]Block.__(0, {id}), decl, to_check_1);
        end end), tdecls);
  List.iter2((function(sdecl, tdecl) do
          decl = tdecl.typ_type;
          match = closed_type_decl(decl);
          if (match ~= undefined) then do
            error({
              __Error_8,
              sdecl.ptype_loc,
              --[[ Unbound_type_var ]]Block.__(9, {
                  match,
                  decl
                })
            })
          end else do
            return --[[ () ]]0;
          end end 
        end end), sdecl_list_1, tdecls);
  List.iter2((function(param, param_1) do
          env = newenv;
          sdecl = param;
          param_2 = param_1;
          decl = param_2[1];
          visited = do
            contents: --[[ Empty ]]0
          end;
          match = decl.type_kind;
          if (typeof match == "number") then do
            match == --[[ Type_abstract ]]0;
          end else if (match.tag) then do
            find_pl = function(param) do
              if (typeof param == "number") then do
                error({
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "typedecl.ml",
                    382,
                    58
                  }
                })
              end else if (param.tag) then do
                error({
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "typedecl.ml",
                    382,
                    58
                  }
                })
              end else do
                return param[0];
              end end  end 
            end end;
            pl = find_pl(sdecl.ptype_kind);
            foldf = function(acc, x) do
              return add_13(x.pcd_name.txt, x, acc);
            end end;
            pl_index = List.fold_left(foldf, --[[ Empty ]]0, pl);
            List.iter((function(param) do
                    ret_type = param.cd_res;
                    match;
                    xpcall(function() do
                      match = find_6(param.cd_id.name, pl_index);
                    end end,function(exn) do
                      if (exn == Caml_builtin_exceptions.not_found) then do
                        error({
                          Caml_builtin_exceptions.assert_failure,
                          --[[ tuple ]]{
                            "typedecl.ml",
                            395,
                            30
                          }
                        })
                      end
                       end 
                      error(exn)
                    end end)
                    sret_type = match.pcd_res;
                    List.iter2((function(sty, ty) do
                            return check_constraints_rec(env, sty.ptyp_loc, visited, ty);
                          end end), match.pcd_args, param.cd_args);
                    if (sret_type ~= undefined and ret_type ~= undefined) then do
                      return check_constraints_rec(env, sret_type.ptyp_loc, visited, ret_type);
                    end else do
                      return --[[ () ]]0;
                    end end 
                  end end), match[0]);
          end else do
            find_pl_1 = function(param) do
              if (typeof param == "number") then do
                error({
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "typedecl.ml",
                    409,
                    59
                  }
                })
              end else if (param.tag == --[[ Ptype_record ]]1) then do
                return param[0];
              end else do
                error({
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "typedecl.ml",
                    409,
                    59
                  }
                })
              end end  end 
            end end;
            pl_1 = find_pl_1(sdecl.ptype_kind);
            get_loc = function(name, _param) do
              while(true) do
                param = _param;
                if (param) then do
                  pld = param[0];
                  if (name == pld.pld_name.txt) then do
                    return pld.pld_type.ptyp_loc;
                  end else do
                    _param = param[1];
                    ::continue:: ;
                  end end 
                end else do
                  error({
                    Caml_builtin_exceptions.assert_failure,
                    --[[ tuple ]]{
                      "typedecl.ml",
                      413,
                      16
                    }
                  })
                end end 
              end;
            end end;
            List.iter((function(param) do
                    return check_constraints_rec(env, get_loc(param.ld_id.name, pl_1), visited, param.ld_type);
                  end end), match[0]);
          end end  end 
          match_1 = decl.type_manifest;
          if (match_1 ~= undefined) then do
            match_2 = sdecl.ptype_manifest;
            sty;
            if (match_2 ~= undefined) then do
              sty = match_2;
            end else do
              error({
                Caml_builtin_exceptions.assert_failure,
                --[[ tuple ]]{
                  "typedecl.ml",
                  428,
                  63
                }
              })
            end end 
            return check_constraints_rec(env, sty.ptyp_loc, visited, match_1);
          end else do
            return --[[ () ]]0;
          end end 
        end end), sdecl_list_1, decls);
  decls_1 = List.map2((function(sdecl, param) do
          id = param[0];
          return --[[ tuple ]]{
                  id,
                  name_recursion(sdecl, id, param[1])
                };
        end end), sdecl_list_1, decls);
  required = List.map((function(sdecl) do
          return --[[ tuple ]]{
                  add_injectivity(List.map((function(prim) do
                              return prim[1];
                            end end), sdecl.ptype_params)),
                  sdecl.ptype_loc
                };
        end end), sdecl_list_1);
  match = compute_variance_fixpoint(env, decls_1, required, List.map(init_variance, decls_1));
  final_env = match[1];
  final_decls = match[0];
  List.iter2((function(param, param_1) do
          env = final_env;
          sdecl = param;
          param_2 = param_1;
          return check_coherence(env, sdecl.ptype_loc, param_2[0], param_2[1]);
        end end), sdecl_list_1, final_decls);
  final_decls_1 = List.map2((function(tdecl, param) do
          return do
                  typ_id: tdecl.typ_id,
                  typ_name: tdecl.typ_name,
                  typ_params: tdecl.typ_params,
                  typ_type: param[1],
                  typ_cstrs: tdecl.typ_cstrs,
                  typ_kind: tdecl.typ_kind,
                  typ_private: tdecl.typ_private,
                  typ_manifest: tdecl.typ_manifest,
                  typ_loc: tdecl.typ_loc,
                  typ_attributes: tdecl.typ_attributes
                end;
        end end), tdecls, final_decls);
  return --[[ tuple ]]{
          final_decls_1,
          final_env
        };
end end

function transl_extension_constructor(env, check_open, type_path, type_params, typext_params, priv, sext) do
  id = create(sext.pext_name.txt);
  match = sext.pext_kind;
  match_1;
  if (match.tag) then do
    lid = match[0];
    cdescr = find_constructor(env, sext.pext_loc, lid.txt);
    usage = cdescr.cstr_private == --[[ Private ]]0 or priv == --[[ Public ]]1 and --[[ Positive ]]0 or --[[ Privatize ]]2;
    mark_constructor(usage, env, last_1(lid.txt), cdescr);
    match_2 = instance_constructor(undefined, cdescr);
    args = match_2[0];
    match_3;
    if (cdescr.cstr_generalized) then do
      params = instance_list(env, type_params);
      res = newconstr(type_path, params);
      ret_type = newconstr(type_path, params);
      match_3 = --[[ tuple ]]{
        res,
        ret_type
      };
    end else do
      match_3 = --[[ tuple ]]{
        newconstr(type_path, typext_params),
        undefined
      };
    end end 
    xpcall(function() do
      unify_2(env, match_2[1], match_3[0]);
    end end,function(raw_exn) do
      exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] == Unify) then do
        error({
          __Error_8,
          lid.loc,
          --[[ Rebind_wrong_type ]]Block.__(13, {
              lid.txt,
              env,
              exn[1]
            })
        })
      end
       end 
      error(exn)
    end end)
    if (not cdescr.cstr_generalized) then do
      vars = free_variables_1(undefined, newty2(100000000, --[[ Ttuple ]]Block.__(2, {args})));
      List.iter((function(ty) do
              match = ty.desc;
              if (typeof match == "number" or match.tag) then do
                return --[[ () ]]0;
              end else do
                match_1 = match[0];
                if (match_1 ~= undefined and match_1 == "_" and List.memq(ty, vars)) then do
                  ty.desc = --[[ Tvar ]]Block.__(0, {undefined});
                  return --[[ () ]]0;
                end else do
                  return --[[ () ]]0;
                end end 
              end end 
            end end), typext_params);
    end
     end 
    match_4 = cdescr.cstr_res.desc;
    match_5;
    if (typeof match_4 == "number") then do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "typedecl.ml",
          1162,
          17
        }
      })
    end else if (match_4.tag == --[[ Tconstr ]]3) then do
      p = match_4[0];
      decl = find_type_full(p, env)[0];
      match_5 = --[[ tuple ]]{
        p,
        decl.type_params
      };
    end else do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "typedecl.ml",
          1162,
          17
        }
      })
    end end  end 
    cstr_type_params = match_5[1];
    cstr_type_path = match_5[0];
    cstr_types_000 = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
            cstr_type_path,
            cstr_type_params,
            do
              contents: --[[ Mnil ]]0
            end
          }));
    cstr_types = --[[ :: ]]{
      cstr_types_000,
      cstr_type_params
    };
    ext_types_000 = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
            type_path,
            type_params,
            do
              contents: --[[ Mnil ]]0
            end
          }));
    ext_types = --[[ :: ]]{
      ext_types_000,
      type_params
    };
    if (not equal_4(env, true, cstr_types, ext_types)) then do
      error({
        __Error_8,
        lid.loc,
        --[[ Rebind_mismatch ]]Block.__(14, {
            lid.txt,
            cstr_type_path,
            type_path
          })
      })
    end
     end 
    match_6 = cdescr.cstr_private;
    if (not match_6 and priv) then do
      error({
        __Error_8,
        lid.loc,
        --[[ Rebind_private ]]Block.__(15, {lid.txt})
      })
    end
     end 
    match_7 = cdescr.cstr_tag;
    path;
    local ___conditional___=(match_7.tag | 0);
    do
       if ___conditional___ == 0--[[ Cstr_constant ]]
       or ___conditional___ == 1--[[ Cstr_block ]] then do
          error({
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "typedecl.ml",
              1187,
              17
            }
          }) end end 
       if ___conditional___ == 2--[[ Cstr_extension ]] then do
          path = match_7[0]; end else 
       end end
      
    end
    match_1 = --[[ tuple ]]{
      args,
      match_3[1],
      --[[ Text_rebind ]]Block.__(1, {
          path,
          lid
        })
    };
  end else do
    match_8 = make_constructor(env, type_path, typext_params, match[0], match[1]);
    match_1 = --[[ tuple ]]{
      match_8[2],
      match_8[3],
      --[[ Text_decl ]]Block.__(0, {
          match_8[0],
          match_8[1]
        })
    };
  end end 
  ext_ext_args = match_1[0];
  ext_ext_ret_type = match_1[1];
  ext_ext_loc = sext.pext_loc;
  ext_ext_attributes = sext.pext_attributes;
  ext = do
    ext_type_path: type_path,
    ext_type_params: typext_params,
    ext_args: ext_ext_args,
    ext_ret_type: ext_ext_ret_type,
    ext_private: priv,
    ext_loc: ext_ext_loc,
    ext_attributes: ext_ext_attributes
  end;
  return do
          ext_id: id,
          ext_name: sext.pext_name,
          ext_type: ext,
          ext_kind: match_1[2],
          ext_loc: sext.pext_loc,
          ext_attributes: sext.pext_attributes
        end;
end end

function transl_type_extension(check_open, env, loc, styext) do
  reset_type_variables(--[[ () ]]0);
  begin_def(--[[ () ]]0);
  match = find_type(env, loc, styext.ptyext_path.txt);
  type_decl = match[1];
  type_path = match[0];
  match_1 = type_decl.type_kind;
  if (typeof match_1 == "number") then do
    if (match_1 == 0 and check_open) then do
      xpcall(function() do
        match_2 = List.find((function(param) do
                if (param.pext_kind.tag) then do
                  return false;
                end else do
                  return true;
                end end 
              end end), styext.ptyext_constructors);
        error({
          __Error_8,
          match_2.pext_loc,
          --[[ Not_open_type ]]Block.__(10, {type_path})
        })
      end end,function(exn) do
        if (exn ~= Caml_builtin_exceptions.not_found) then do
          error(exn)
        end
         end 
      end end)
    end
     end 
  end else do
    error({
      __Error_8,
      loc,
      --[[ Not_extensible_type ]]Block.__(11, {type_path})
    })
  end end 
  type_variance = List.map((function(v) do
          match = Curry._1(Types_Variance.get_upper, v);
          return --[[ tuple ]]{
                  not match[1],
                  not match[0],
                  false
                };
        end end), type_decl.type_variance);
  err = type_decl.type_arity ~= List.length(styext.ptyext_params) and --[[ :: ]]{
      --[[ Arity ]]0,
      --[[ [] ]]0
    } or (
      List.for_all2((function(param, param_1) do
              if (not param_1[0] or param[0]) then do
                if (param_1[1]) then do
                  return param[1];
                end else do
                  return true;
                end end 
              end else do
                return false;
              end end 
            end end), type_variance, add_injectivity(List.map((function(prim) do
                      return prim[1];
                    end end), styext.ptyext_params))) and --[[ [] ]]0 or --[[ :: ]]{
          --[[ Variance ]]5,
          --[[ [] ]]0
        }
    );
  if (err ~= --[[ [] ]]0) then do
    error({
      __Error_8,
      loc,
      --[[ Extension_mismatch ]]Block.__(12, {
          type_path,
          err
        })
    })
  end
   end 
  ttype_params = make_params(env, styext.ptyext_params);
  type_params = List.map((function(param) do
          return param[0].ctyp_type;
        end end), ttype_params);
  List.iter2((function(param, param_1) do
          return unify_var(env, param, param_1);
        end end), instance_list(env, type_decl.type_params), type_params);
  partial_arg = styext.ptyext_private;
  partial_arg_1 = type_decl.type_params;
  constructors = List.map((function(param) do
          return transl_extension_constructor(env, check_open, type_path, partial_arg_1, type_params, partial_arg, param);
        end end), styext.ptyext_constructors);
  end_def(--[[ () ]]0);
  List.iter(generalize, type_params);
  List.iter((function(ext) do
          List.iter(generalize, ext.ext_type.ext_args);
          return may(generalize, ext.ext_type.ext_ret_type);
        end end), constructors);
  List.iter((function(ext) do
          match = closed_extension_constructor(ext.ext_type);
          if (match ~= undefined) then do
            error({
              __Error_8,
              ext.ext_loc,
              --[[ Unbound_type_var_ext ]]Block.__(19, {
                  match,
                  ext.ext_type
                })
            })
          end else do
            return --[[ () ]]0;
          end end 
        end end), constructors);
  List.iter((function(ext) do
          compute_variance_extension(env, true, type_decl, ext.ext_type, --[[ tuple ]]{
                type_variance,
                loc
              });
          return --[[ () ]]0;
        end end), constructors);
  newenv = List.fold_left((function(env, ext) do
          return add_extension(true, ext.ext_id, ext.ext_type, env);
        end end), env, constructors);
  tyext_tyext_txt = styext.ptyext_path;
  tyext_tyext_private = styext.ptyext_private;
  tyext_tyext_attributes = styext.ptyext_attributes;
  tyext = do
    tyext_path: type_path,
    tyext_txt: tyext_tyext_txt,
    tyext_params: ttype_params,
    tyext_constructors: constructors,
    tyext_private: tyext_tyext_private,
    tyext_attributes: tyext_tyext_attributes
  end;
  return --[[ tuple ]]{
          tyext,
          newenv
        };
end end

function transl_exception(env, sext) do
  reset_type_variables(--[[ () ]]0);
  begin_def(--[[ () ]]0);
  ext = transl_extension_constructor(env, false, path_exn, --[[ [] ]]0, --[[ [] ]]0, --[[ Public ]]1, sext);
  end_def(--[[ () ]]0);
  List.iter(generalize, ext.ext_type.ext_args);
  may(generalize, ext.ext_type.ext_ret_type);
  match = closed_extension_constructor(ext.ext_type);
  if (match ~= undefined) then do
    error({
      __Error_8,
      ext.ext_loc,
      --[[ Unbound_type_var_ext ]]Block.__(19, {
          match,
          ext.ext_type
        })
    })
  end
   end 
  newenv = add_extension(true, ext.ext_id, ext.ext_type, env);
  return --[[ tuple ]]{
          ext,
          newenv
        };
end end

function customize_arity(arity, pval_attributes) do
  cur_arity = do
    contents: arity
  end;
  List.iter((function(x) do
          if (x[0].txt == "internal.arity") then do
            match = x[1];
            local ___conditional___=(match.tag | 0);
            do
               if ___conditional___ == 0--[[ PStr ]] then do
                  match_1 = match[0];
                  if (match_1) then do
                    match_2 = match_1[0].pstr_desc;
                    if (match_2.tag) then do
                      return --[[ () ]]0;
                    end else do
                      match_3 = match_2[0].pexp_desc;
                      if (match_3.tag == --[[ Pexp_constant ]]1) then do
                        match_4 = match_3[0];
                        if (match_4.tag or match_1[1]) then do
                          return --[[ () ]]0;
                        end else do
                          i = match_4[0];
                          if (i < cur_arity.contents) then do
                            cur_arity.contents = i;
                            return --[[ () ]]0;
                          end else do
                            return 0;
                          end end 
                        end end 
                      end else do
                        return --[[ () ]]0;
                      end end 
                    end end 
                  end else do
                    return --[[ () ]]0;
                  end end  end end 
               if ___conditional___ == 1--[[ PTyp ]]
               or ___conditional___ == 2--[[ PPat ]] then do
                  return --[[ () ]]0; end end 
              
            end
          end else do
            return --[[ () ]]0;
          end end 
        end end), pval_attributes);
  return cur_arity.contents;
end end

function transl_value_decl(env, loc, valdecl) do
  cty = transl_type_scheme(env, valdecl.pval_type);
  ty = cty.ctyp_type;
  decl = valdecl.pval_prim;
  v;
  if (decl) then do
    arity_1 = customize_arity(arity(ty), valdecl.pval_attributes);
    prim = parse_declaration(arity_1, decl);
    prim_native_name = prim.prim_native_name;
    if (arity_1 == 0 and not (#prim_native_name > 3 and prim_native_name[0] == "B" and prim_native_name[1] == "S" and prim_native_name[2] == ":") and (#prim.prim_name == 0 or Caml_string.get(prim.prim_name, 0) ~= --[[ "%" ]]37 and Caml_string.get(prim.prim_name, 0) ~= --[[ "#" ]]35)) then do
      error({
        __Error_8,
        valdecl.pval_type.ptyp_loc,
        --[[ Null_arity_external ]]2
      })
    end
     end 
    if (native_code.contents and prim.prim_arity > 5 and prim_native_name == "") then do
      error({
        __Error_8,
        valdecl.pval_type.ptyp_loc,
        --[[ Missing_native_external ]]3
      })
    end
     end 
    v = do
      val_type: ty,
      val_kind: --[[ Val_prim ]]Block.__(0, {prim}),
      val_loc: loc,
      val_attributes: valdecl.pval_attributes
    end;
  end else do
    v = do
      val_type: ty,
      val_kind: --[[ Val_reg ]]0,
      val_loc: loc,
      val_attributes: valdecl.pval_attributes
    end;
  end end 
  match = enter_value((function(s) do
            return --[[ Unused_value_declaration ]]Block.__(16, {s});
          end end))(valdecl.pval_name.txt, v, env);
  desc_val_id = match[0];
  desc_val_name = valdecl.pval_name;
  desc_val_prim = valdecl.pval_prim;
  desc_val_loc = valdecl.pval_loc;
  desc_val_attributes = valdecl.pval_attributes;
  desc = do
    val_id: desc_val_id,
    val_name: desc_val_name,
    val_desc: cty,
    val_val: v,
    val_prim: desc_val_prim,
    val_loc: desc_val_loc,
    val_attributes: desc_val_attributes
  end;
  return --[[ tuple ]]{
          desc,
          match[1]
        };
end end

function transl_with_constraint(env, id, row_path, orig_decl, sdecl) do
  mark_type_used(env, id.name, orig_decl);
  reset_type_variables(--[[ () ]]0);
  begin_def(--[[ () ]]0);
  tparams = make_params(env, sdecl.ptype_params);
  params = List.map((function(param) do
          return param[0].ctyp_type;
        end end), tparams);
  orig_decl_1 = instance_declaration(orig_decl);
  arity_ok = List.length(params) == orig_decl_1.type_arity;
  if (arity_ok) then do
    List.iter2((function(param, param_1) do
            return unify_var(env, param, param_1);
          end end), params, orig_decl_1.type_params);
  end
   end 
  constraints = List.map((function(param) do
          loc = param[2];
          xpcall(function() do
            cty = transl_simple_type(env, false, param[0]);
            cty$prime = transl_simple_type(env, false, param[1]);
            ty = cty.ctyp_type;
            ty$prime = cty$prime.ctyp_type;
            unify_2(env, ty, ty$prime);
            return --[[ tuple ]]{
                    cty,
                    cty$prime,
                    loc
                  };
          end end,function(raw_exn) do
            exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn[0] == Unify) then do
              error({
                __Error_8,
                loc,
                --[[ Inconsistent_constraint ]]Block.__(6, {
                    env,
                    exn[1]
                  })
              })
            end
             end 
            error(exn)
          end end)
        end end), sdecl.ptype_cstrs);
  no_row = not is_fixed_type(sdecl);
  match = sdecl.ptype_manifest;
  match_1;
  if (match ~= undefined) then do
    cty = transl_simple_type(env, no_row, match);
    match_1 = --[[ tuple ]]{
      cty,
      cty.ctyp_type
    };
  end else do
    match_1 = --[[ tuple ]]{
      undefined,
      undefined
    };
  end end 
  man = match_1[1];
  priv = sdecl.ptype_private == --[[ Private ]]0 and --[[ Private ]]0 or (
      arity_ok and orig_decl_1.type_kind ~= --[[ Type_abstract ]]0 and orig_decl_1.type_private or sdecl.ptype_private
    );
  if (arity_ok and orig_decl_1.type_kind ~= --[[ Type_abstract ]]0 and sdecl.ptype_private == --[[ Private ]]0) then do
    prerr_warning(sdecl.ptype_loc, --[[ Deprecated ]]Block.__(0, {"spurious use of private"}));
  end
   end 
  decl_type_arity = List.length(params);
  decl_type_kind = arity_ok and man ~= undefined and orig_decl_1.type_kind or --[[ Type_abstract ]]0;
  decl_type_loc = sdecl.ptype_loc;
  decl_type_attributes = sdecl.ptype_attributes;
  decl = do
    type_params: params,
    type_arity: decl_type_arity,
    type_kind: decl_type_kind,
    type_private: priv,
    type_manifest: man,
    type_variance: --[[ [] ]]0,
    type_newtype_level: undefined,
    type_loc: decl_type_loc,
    type_attributes: decl_type_attributes
  end;
  if (row_path ~= undefined) then do
    set_fixed_row(env, sdecl.ptype_loc, row_path, decl);
  end
   end 
  match_2 = closed_type_decl(decl);
  if (match_2 ~= undefined) then do
    error({
      __Error_8,
      sdecl.ptype_loc,
      --[[ Unbound_type_var ]]Block.__(9, {
          match_2,
          decl
        })
    })
  end
   end 
  decl_1 = name_recursion(sdecl, id, decl);
  decl_type_params = decl_1.type_params;
  decl_type_arity_1 = decl_1.type_arity;
  decl_type_kind_1 = decl_1.type_kind;
  decl_type_private = decl_1.type_private;
  decl_type_manifest = decl_1.type_manifest;
  decl_type_variance = compute_variance_decl(env, false, decl_1, --[[ tuple ]]{
        add_injectivity(List.map((function(prim) do
                    return prim[1];
                  end end), sdecl.ptype_params)),
        sdecl.ptype_loc
      });
  decl_type_newtype_level = decl_1.type_newtype_level;
  decl_type_loc_1 = decl_1.type_loc;
  decl_type_attributes_1 = decl_1.type_attributes;
  decl_2 = do
    type_params: decl_type_params,
    type_arity: decl_type_arity_1,
    type_kind: decl_type_kind_1,
    type_private: decl_type_private,
    type_manifest: decl_type_manifest,
    type_variance: decl_type_variance,
    type_newtype_level: decl_type_newtype_level,
    type_loc: decl_type_loc_1,
    type_attributes: decl_type_attributes_1
  end;
  end_def(--[[ () ]]0);
  generalize_decl(decl_2);
  return do
          typ_id: id,
          typ_name: sdecl.ptype_name,
          typ_params: tparams,
          typ_type: decl_2,
          typ_cstrs: constraints,
          typ_kind: --[[ Ttype_abstract ]]0,
          typ_private: sdecl.ptype_private,
          typ_manifest: match_1[0],
          typ_loc: sdecl.ptype_loc,
          typ_attributes: sdecl.ptype_attributes
        end;
end end

function abstract_type_decl(arity) do
  make_params = function(n) do
    if (n <= 0) then do
      return --[[ [] ]]0;
    end else do
      return --[[ :: ]]{
              newvar(undefined, --[[ () ]]0),
              make_params(n - 1 | 0)
            };
    end end 
  end end;
  begin_def(--[[ () ]]0);
  decl_type_params = make_params(arity);
  decl_type_variance = replicate_list(Types_Variance.full, arity);
  decl = do
    type_params: decl_type_params,
    type_arity: arity,
    type_kind: --[[ Type_abstract ]]0,
    type_private: --[[ Public ]]1,
    type_manifest: undefined,
    type_variance: decl_type_variance,
    type_newtype_level: undefined,
    type_loc: none,
    type_attributes: --[[ [] ]]0
  end;
  end_def(--[[ () ]]0);
  generalize_decl(decl);
  return decl;
end end

function approx_type_decl(env, sdecl_list) do
  return List.map((function(sdecl) do
                return --[[ tuple ]]{
                        create(sdecl.ptype_name.txt),
                        abstract_type_decl(List.length(sdecl.ptype_params))
                      };
              end end), sdecl_list);
end end

function explain_unbound(ppf, tv, tl, typ, kwd, lab) do
  xpcall(function() do
    ti = List.find((function(ti) do
            return deep_occur(tv, Curry._1(typ, ti));
          end end), tl);
    ty0 = newty2(100000000, --[[ Tobject ]]Block.__(4, {
            tv,
            do
              contents: undefined
            end
          }));
    reset_and_mark_loops_list(--[[ :: ]]{
          Curry._1(typ, ti),
          --[[ :: ]]{
            ty0,
            --[[ [] ]]0
          }
        });
    return Curry._6(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Char_literal ]]Block.__(12, {
                        --[[ "." ]]46,
                        --[[ Formatting_lit ]]Block.__(17, {
                            --[[ Flush_newline ]]4,
                            --[[ Formatting_gen ]]Block.__(18, {
                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                      --[[ String_literal ]]Block.__(11, {
                                          "<hov2>",
                                          --[[ End_of_format ]]0
                                        }),
                                      "<hov2>"
                                    }}),
                                --[[ String_literal ]]Block.__(11, {
                                    "In ",
                                    --[[ String ]]Block.__(2, {
                                        --[[ No_padding ]]0,
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ String ]]Block.__(2, {
                                                --[[ No_padding ]]0,
                                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                        --[[ Break ]]Block.__(0, {
                                                            "@;<1 -2>",
                                                            1,
                                                            -2
                                                          }),
                                                        --[[ String_literal ]]Block.__(11, {
                                                            "the variable ",
                                                            --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                                                    " is unbound",
                                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                                        --[[ Close_box ]]0,
                                                                        --[[ End_of_format ]]0
                                                                      })
                                                                  })})
                                                          })
                                                      })})
                                              })
                                          })
                                      })
                                  })
                              })
                          })
                      }),
                    ".@.@[<hov2>In %s@ %s%a@;<1 -2>the variable %a is unbound@]"
                  }), kwd, Curry._1(lab, ti), type_expr_1, Curry._1(typ, ti), type_expr_1, tv);
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return --[[ () ]]0;
    end else do
      error(exn)
    end end 
  end end)
end end

function report_error_5(ppf, param) do
  if (typeof param == "number") then do
    local ___conditional___=(param);
    do
       if ___conditional___ == 0--[[ Repeated_parameter ]] then do
          return Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "A type parameter occurs several times",
                          --[[ End_of_format ]]0
                        }),
                      "A type parameter occurs several times"
                    }); end end 
       if ___conditional___ == 1--[[ Too_many_constructors ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "Too many non-constant constructors",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ String_literal ]]Block.__(11, {
                                          "-- maximum is ",
                                          --[[ Int ]]Block.__(4, {
                                              --[[ Int_i ]]3,
                                              --[[ No_padding ]]0,
                                              --[[ No_precision ]]0,
                                              --[[ Char_literal ]]Block.__(12, {
                                                  --[[ " " ]]32,
                                                  --[[ String ]]Block.__(2, {
                                                      --[[ No_padding ]]0,
                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                          --[[ Close_box ]]0,
                                                          --[[ End_of_format ]]0
                                                        })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[Too many non-constant constructors@ -- maximum is %i %s@]"
                        }), 246, "non-constant constructors"); end end 
       if ___conditional___ == 2--[[ Null_arity_external ]] then do
          return Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "External identifiers must be functions",
                          --[[ End_of_format ]]0
                        }),
                      "External identifiers must be functions"
                    }); end end 
       if ___conditional___ == 3--[[ Missing_native_external ]] then do
          return Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Formatting_gen ]]Block.__(18, {
                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                --[[ String_literal ]]Block.__(11, {
                                    "<hv>",
                                    --[[ End_of_format ]]0
                                  }),
                                "<hv>"
                              }}),
                          --[[ String_literal ]]Block.__(11, {
                              "An external function with more than 5 arguments requires a second stub function",
                              --[[ Formatting_lit ]]Block.__(17, {
                                  --[[ Break ]]Block.__(0, {
                                      "@ ",
                                      1,
                                      0
                                    }),
                                  --[[ String_literal ]]Block.__(11, {
                                      "for native-code compilation",
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Close_box ]]0,
                                          --[[ End_of_format ]]0
                                        })
                                    })
                                })
                            })
                        }),
                      "@[<hv>An external function with more than 5 arguments requires a second stub function@ for native-code compilation@]"
                    }); end end 
       if ___conditional___ == 4--[[ Varying_anonymous ]] then do
          return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@ ",
                                                  1,
                                                  0
                                                }),
                                              --[[ String ]]Block.__(2, {
                                                  --[[ No_padding ]]0,
                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Close_box ]]0,
                                                      --[[ End_of_format ]]0
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[%s@ %s@ %s@]"
                        }), "In this GADT definition,", "the variance of some parameter", "cannot be checked"); end end 
      
    end
  end else do
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ == 0--[[ Duplicate_constructor ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "Two constructors are named ",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ End_of_format ]]0
                                })
                            }),
                          "Two constructors are named %s"
                        }), param[0]); end end 
       if ___conditional___ == 1--[[ Duplicate_label ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "Two labels are named ",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ End_of_format ]]0
                                })
                            }),
                          "Two labels are named %s"
                        }), param[0]); end end 
       if ___conditional___ == 2--[[ Recursive_abbrev ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "The type abbreviation ",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ String_literal ]]Block.__(11, {
                                      " is cyclic",
                                      --[[ End_of_format ]]0
                                    })
                                })
                            }),
                          "The type abbreviation %s is cyclic"
                        }), param[0]); end end 
       if ___conditional___ == 3--[[ Cycle_in_def ]] then do
          ty = param[1];
          reset(--[[ () ]]0);
          mark_loops(ty);
          return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<v>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<v>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "The definition of ",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ String_literal ]]Block.__(11, {
                                          " contains a cycle:",
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@ ",
                                                  1,
                                                  0
                                                }),
                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Close_box ]]0,
                                                      --[[ End_of_format ]]0
                                                    })})
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[<v>The definition of %s contains a cycle:@ %a@]"
                        }), param[0], type_expr_1, ty); end end 
       if ___conditional___ == 4--[[ Definition_mismatch ]] then do
          ty_1 = param[0];
          reset(--[[ () ]]0);
          mark_loops(ty_1);
          return Curry._6(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<v>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<v>"
                                  }}),
                              --[[ Formatting_gen ]]Block.__(18, {
                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                        --[[ String_literal ]]Block.__(11, {
                                            "<hov>",
                                            --[[ End_of_format ]]0
                                          }),
                                        "<hov>"
                                      }}),
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ String ]]Block.__(2, {
                                              --[[ No_padding ]]0,
                                              --[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Break ]]Block.__(0, {
                                                      "@;<1 2>",
                                                      1,
                                                      2
                                                    }),
                                                  --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                          --[[ Close_box ]]0,
                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                  --[[ Close_box ]]0,
                                                                  --[[ End_of_format ]]0
                                                                })})
                                                        })})
                                                })
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[<v>@[<hov>%s@ %s@;<1 2>%a@]%a@]"
                        }), "This variant or record definition", "does not match that of type", type_expr_1, ty_1, (function(param) do
                        return report_type_mismatch("the original", "this", "definition", param);
                      end end), param[1]); end end 
       if ___conditional___ == 5--[[ Constraint_failed ]] then do
          ty$prime = param[1];
          ty_2 = param[0];
          reset(--[[ () ]]0);
          mark_loops(ty_2);
          mark_loops(ty$prime);
          return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ Formatting_gen ]]Block.__(18, {
                                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                --[[ String_literal ]]Block.__(11, {
                                                    "<hv>",
                                                    --[[ End_of_format ]]0
                                                  }),
                                                "<hv>"
                                              }}),
                                          --[[ String_literal ]]Block.__(11, {
                                              "Type",
                                              --[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Break ]]Block.__(0, {
                                                      "@ ",
                                                      1,
                                                      0
                                                    }),
                                                  --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                          --[[ Break ]]Block.__(0, {
                                                              "@ ",
                                                              1,
                                                              0
                                                            }),
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "should be an instance of",
                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                  --[[ Break ]]Block.__(0, {
                                                                      "@ ",
                                                                      1,
                                                                      0
                                                                    }),
                                                                  --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Close_box ]]0,
                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Close_box ]]0,
                                                                              --[[ End_of_format ]]0
                                                                            })
                                                                        })})
                                                                })
                                                            })
                                                        })})
                                                })
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[%s@ @[<hv>Type@ %a@ should be an instance of@ %a@]@]"
                        }), "Constraints are not satisfied in this type.", type_expr_1, ty_2, type_expr_1, ty$prime); end end 
       if ___conditional___ == 6--[[ Inconsistent_constraint ]] then do
          Format.fprintf(ppf, --[[ Format ]]{
                --[[ String_literal ]]Block.__(11, {
                    "The type constraints are not consistent.",
                    --[[ Formatting_lit ]]Block.__(17, {
                        --[[ Flush_newline ]]4,
                        --[[ End_of_format ]]0
                      })
                  }),
                "The type constraints are not consistent.@."
              });
          return report_unification_error(ppf, param[0], undefined, param[1], (function(ppf) do
                        return Format.fprintf(ppf, --[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "Type",
                                        --[[ End_of_format ]]0
                                      }),
                                    "Type"
                                  });
                      end end), (function(ppf) do
                        return Format.fprintf(ppf, --[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "is not compatible with type",
                                        --[[ End_of_format ]]0
                                      }),
                                    "is not compatible with type"
                                  });
                      end end)); end end 
       if ___conditional___ == 7--[[ Type_clash ]] then do
          return report_unification_error(ppf, param[0], undefined, param[1], (function(ppf) do
                        return Format.fprintf(ppf, --[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "This type constructor expands to type",
                                        --[[ End_of_format ]]0
                                      }),
                                    "This type constructor expands to type"
                                  });
                      end end), (function(ppf) do
                        return Format.fprintf(ppf, --[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "but is used here with type",
                                        --[[ End_of_format ]]0
                                      }),
                                    "but is used here with type"
                                  });
                      end end)); end end 
       if ___conditional___ == 8--[[ Parameters_differ ]] then do
          ty$prime_1 = param[2];
          ty_3 = param[1];
          reset(--[[ () ]]0);
          mark_loops(ty_3);
          mark_loops(ty$prime_1);
          return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hv>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hv>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "In the definition of ",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ String_literal ]]Block.__(11, {
                                          ", type",
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@ ",
                                                  1,
                                                  0
                                                }),
                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Break ]]Block.__(0, {
                                                          "@ ",
                                                          1,
                                                          0
                                                        }),
                                                      --[[ String_literal ]]Block.__(11, {
                                                          "should be",
                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Break ]]Block.__(0, {
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                }),
                                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Close_box ]]0,
                                                                      --[[ End_of_format ]]0
                                                                    })})
                                                            })
                                                        })
                                                    })})
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[<hv>In the definition of %s, type@ %a@ should be@ %a@]"
                        }), name(undefined, param[0]), type_expr_1, ty_3, type_expr_1, ty$prime_1); end end 
       if ___conditional___ == 9--[[ Unbound_type_var ]] then do
          decl = param[1];
          Format.fprintf(ppf, --[[ Format ]]{
                --[[ String_literal ]]Block.__(11, {
                    "A type variable is unbound in this type declaration",
                    --[[ End_of_format ]]0
                  }),
                "A type variable is unbound in this type declaration"
              });
          ty_4 = repr(param[0]);
          match = decl.type_kind;
          match_1 = decl.type_manifest;
          if (typeof match == "number") then do
            if (match == --[[ Type_abstract ]]0 and match_1 ~= undefined) then do
              ppf_1 = ppf;
              tv = ty_4;
              ty_5 = match_1;
              trivial = function(ty) do
                return explain_unbound(ppf_1, tv, --[[ :: ]]{
                            ty,
                            --[[ [] ]]0
                          }, (function(t) do
                              return t;
                            end end), "type", (function(param) do
                              return "";
                            end end));
              end end;
              match_2 = repr(ty_5).desc;
              if (typeof match_2 == "number") then do
                return trivial(ty_5);
              end else do
                local ___conditional___=(match_2.tag | 0);
                do
                   if ___conditional___ == 4--[[ Tobject ]] then do
                      match_3 = flatten_fields(match_2[0]);
                      if (match_3[1] == tv) then do
                        return trivial(ty_5);
                      end else do
                        return explain_unbound(ppf_1, tv, match_3[0], (function(param) do
                                      return param[2];
                                    end end), "method", (function(param) do
                                      return param[0] .. ": ";
                                    end end));
                      end end  end end 
                   if ___conditional___ == 8--[[ Tvariant ]] then do
                      row = row_repr_aux(--[[ [] ]]0, match_2[0]);
                      if (row.row_more == tv) then do
                        return trivial(ty_5);
                      end else do
                        return explain_unbound(ppf_1, tv, row.row_fields, (function(param) do
                                      match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                                      if (typeof match == "number") then do
                                        return newty2(100000000, --[[ Ttuple ]]Block.__(2, {--[[ [] ]]0}));
                                      end else if (match.tag) then do
                                        tl = match[1];
                                        if (tl and not tl[1]) then do
                                          return tl[0];
                                        end else do
                                          return newty2(100000000, --[[ Ttuple ]]Block.__(2, {tl}));
                                        end end 
                                      end else do
                                        match_1 = match[0];
                                        if (match_1 ~= undefined) then do
                                          return match_1;
                                        end else do
                                          return newty2(100000000, --[[ Ttuple ]]Block.__(2, {--[[ [] ]]0}));
                                        end end 
                                      end end  end 
                                    end end), "case", (function(param) do
                                      return "`" .. (param[0] .. " of ");
                                    end end));
                      end end  end end 
                  return trivial(ty_5);
                    
                end
              end end 
            end else do
              return --[[ () ]]0;
            end end 
          end else if (match.tag) then do
            return explain_unbound(ppf, ty_4, match[0], (function(c) do
                          return newty2(100000000, --[[ Ttuple ]]Block.__(2, {c.cd_args}));
                        end end), "case", (function(c) do
                          return c.cd_id.name .. " of ";
                        end end));
          end else do
            return explain_unbound(ppf, ty_4, match[0], (function(l) do
                          return l.ld_type;
                        end end), "field", (function(l) do
                          return l.ld_id.name .. ": ";
                        end end));
          end end  end  end end 
       if ___conditional___ == 10--[[ Not_open_type ]] then do
          return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Close_box ]]0,
                                              --[[ End_of_format ]]0
                                            })})
                                    })
                                })
                            }),
                          "@[%s@ %a@]"
                        }), "Cannot extend type definition", path, param[0]); end end 
       if ___conditional___ == 11--[[ Not_extensible_type ]] then do
          return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@ ",
                                                  1,
                                                  0
                                                }),
                                              --[[ String ]]Block.__(2, {
                                                  --[[ No_padding ]]0,
                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Close_box ]]0,
                                                      --[[ End_of_format ]]0
                                                    })
                                                })
                                            })})
                                    })
                                })
                            }),
                          "@[%s@ %a@ %s@]"
                        }), "Type", path, param[0], "is not extensible"); end end 
       if ___conditional___ == 12--[[ Extension_mismatch ]] then do
          return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<v>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<v>"
                                  }}),
                              --[[ Formatting_gen ]]Block.__(18, {
                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                        --[[ String_literal ]]Block.__(11, {
                                            "<hov>",
                                            --[[ End_of_format ]]0
                                          }),
                                        "<hov>"
                                      }}),
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ String ]]Block.__(2, {
                                              --[[ No_padding ]]0,
                                              --[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Break ]]Block.__(0, {
                                                      "@;<1 2>",
                                                      1,
                                                      2
                                                    }),
                                                  --[[ String ]]Block.__(2, {
                                                      --[[ No_padding ]]0,
                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                          --[[ Close_box ]]0,
                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                  --[[ Close_box ]]0,
                                                                  --[[ End_of_format ]]0
                                                                })})
                                                        })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[<v>@[<hov>%s@ %s@;<1 2>%s@]%a@]"
                        }), "This extension", "does not match the definition of type", name(undefined, param[0]), (function(param) do
                        return report_type_mismatch("the type", "this extension", "definition", param);
                      end end), param[1]); end end 
       if ___conditional___ == 13--[[ Rebind_wrong_type ]] then do
          lid = param[0];
          return report_unification_error(ppf, param[1], undefined, param[2], (function(ppf) do
                        return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                        --[[ String_literal ]]Block.__(11, {
                                            "The constructor ",
                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "has type",
                                                        --[[ End_of_format ]]0
                                                      })
                                                  })})
                                          }),
                                        "The constructor %a@ has type"
                                      }), longident, lid);
                      end end), (function(ppf) do
                        return Format.fprintf(ppf, --[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "but was expected to be of type",
                                        --[[ End_of_format ]]0
                                      }),
                                    "but was expected to be of type"
                                  });
                      end end)); end end 
       if ___conditional___ == 14--[[ Rebind_mismatch ]] then do
          return Curry._8(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@ ",
                                                  1,
                                                  0
                                                }),
                                              --[[ String ]]Block.__(2, {
                                                  --[[ No_padding ]]0,
                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Break ]]Block.__(0, {
                                                          "@ ",
                                                          1,
                                                          0
                                                        }),
                                                      --[[ String ]]Block.__(2, {
                                                          --[[ No_padding ]]0,
                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Break ]]Block.__(0, {
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                }),
                                                              --[[ String ]]Block.__(2, {
                                                                  --[[ No_padding ]]0,
                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Break ]]Block.__(0, {
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        }),
                                                                      --[[ String ]]Block.__(2, {
                                                                          --[[ No_padding ]]0,
                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Break ]]Block.__(0, {
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                }),
                                                                              --[[ String ]]Block.__(2, {
                                                                                  --[[ No_padding ]]0,
                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Close_box ]]0,
                                                                                      --[[ End_of_format ]]0
                                                                                    })
                                                                                })
                                                                            })
                                                                        })
                                                                    })
                                                                })
                                                            })
                                                        })
                                                    })
                                                })
                                            })})
                                    })
                                })
                            }),
                          "@[%s@ %a@ %s@ %s@ %s@ %s@ %s@]"
                        }), "The constructor", longident, param[0], "extends type", name(undefined, param[1]), "whose declaration does not match", "the declaration of type", name(undefined, param[2])); end end 
       if ___conditional___ == 15--[[ Rebind_private ]] then do
          return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@ ",
                                                  1,
                                                  0
                                                }),
                                              --[[ String ]]Block.__(2, {
                                                  --[[ No_padding ]]0,
                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Close_box ]]0,
                                                      --[[ End_of_format ]]0
                                                    })
                                                })
                                            })})
                                    })
                                })
                            }),
                          "@[%s@ %a@ %s@]"
                        }), "The constructor", longident, param[0], "is private"); end end 
       if ___conditional___ == 16--[[ Bad_variance ]] then do
          n = param[0];
          variance = function(param) do
            n = param[1];
            inj = param[2] and "injective " or "";
            if (param[0]) then do
              if (n) then do
                return inj .. "invariant";
              end else do
                return inj .. "covariant";
              end end 
            end else if (n) then do
              return inj .. "contravariant";
            end else if (inj == "") then do
              return "unrestricted";
            end else do
              return inj;
            end end  end  end 
          end end;
          suffix = function(n) do
            teen = (n % 100 / 10 | 0) == 1;
            match = n % 10;
            local ___conditional___=(match);
            do
               if ___conditional___ == 1 then do
                  if (teen) then do
                    return "th";
                  end else do
                    return "st";
                  end end  end end 
               if ___conditional___ == 2 then do
                  if (teen) then do
                    return "th";
                  end else do
                    return "nd";
                  end end  end end 
               if ___conditional___ == 3 then do
                  if (teen) then do
                    return "th";
                  end else do
                    return "rd";
                  end end  end end 
              return "th";
                
            end
          end end;
          if (n == -1) then do
            Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Formatting_gen ]]Block.__(18, {
                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                --[[ End_of_format ]]0,
                                ""
                              }}),
                          --[[ String ]]Block.__(2, {
                              --[[ No_padding ]]0,
                              --[[ Formatting_lit ]]Block.__(17, {
                                  --[[ Break ]]Block.__(0, {
                                      "@ ",
                                      1,
                                      0
                                    }),
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ String_literal ]]Block.__(11, {
                                              "It",
                                              --[[ End_of_format ]]0
                                            })
                                        })
                                    })
                                })
                            })
                        }),
                      "@[%s@ %s@ It"
                    }), "In this definition, a type variable has a variance that", "is not reflected by its occurrence in type parameters.");
          end else if (n == -2) then do
            Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Formatting_gen ]]Block.__(18, {
                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                --[[ End_of_format ]]0,
                                ""
                              }}),
                          --[[ String ]]Block.__(2, {
                              --[[ No_padding ]]0,
                              --[[ Formatting_lit ]]Block.__(17, {
                                  --[[ Break ]]Block.__(0, {
                                      "@ ",
                                      1,
                                      0
                                    }),
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Close_box ]]0,
                                          --[[ End_of_format ]]0
                                        })
                                    })
                                })
                            })
                        }),
                      "@[%s@ %s@]"
                    }), "In this definition, a type variable cannot be deduced", "from the type parameters.");
          end else if (n == -3) then do
            Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Formatting_gen ]]Block.__(18, {
                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                --[[ End_of_format ]]0,
                                ""
                              }}),
                          --[[ String ]]Block.__(2, {
                              --[[ No_padding ]]0,
                              --[[ Formatting_lit ]]Block.__(17, {
                                  --[[ Break ]]Block.__(0, {
                                      "@ ",
                                      1,
                                      0
                                    }),
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ String_literal ]]Block.__(11, {
                                              "It",
                                              --[[ End_of_format ]]0
                                            })
                                        })
                                    })
                                })
                            })
                        }),
                      "@[%s@ %s@ It"
                    }), "In this definition, a type variable has a variance that", "cannot be deduced from the type parameters.");
          end else do
            Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Formatting_gen ]]Block.__(18, {
                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                --[[ End_of_format ]]0,
                                ""
                              }}),
                          --[[ String ]]Block.__(2, {
                              --[[ No_padding ]]0,
                              --[[ Formatting_lit ]]Block.__(17, {
                                  --[[ Break ]]Block.__(0, {
                                      "@ ",
                                      1,
                                      0
                                    }),
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ String_literal ]]Block.__(11, {
                                              "The ",
                                              --[[ Int ]]Block.__(4, {
                                                  --[[ Int_d ]]0,
                                                  --[[ No_padding ]]0,
                                                  --[[ No_precision ]]0,
                                                  --[[ String ]]Block.__(2, {
                                                      --[[ No_padding ]]0,
                                                      --[[ String_literal ]]Block.__(11, {
                                                          " type parameter",
                                                          --[[ End_of_format ]]0
                                                        })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            })
                        }),
                      "@[%s@ %s@ The %d%s type parameter"
                    }), "In this definition, expected parameter", "variances are not satisfied.", n, suffix(n));
          end end  end  end 
          if (n ~= -2) then do
            return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                            --[[ String_literal ]]Block.__(11, {
                                " was expected to be ",
                                --[[ String ]]Block.__(2, {
                                    --[[ No_padding ]]0,
                                    --[[ Char_literal ]]Block.__(12, {
                                        --[[ "," ]]44,
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ String_literal ]]Block.__(11, {
                                                "but it is ",
                                                --[[ String ]]Block.__(2, {
                                                    --[[ No_padding ]]0,
                                                    --[[ Char_literal ]]Block.__(12, {
                                                        --[[ "." ]]46,
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Close_box ]]0,
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })
                                                  })
                                              })
                                          })
                                      })
                                  })
                              }),
                            " was expected to be %s,@ but it is %s.@]"
                          }), variance(param[2]), variance(param[1]));
          end else do
            return 0;
          end end  end end 
       if ___conditional___ == 17--[[ Unavailable_type_constructor ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "The definition of type ",
                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ String_literal ]]Block.__(11, {
                                          "is unavailable",
                                          --[[ End_of_format ]]0
                                        })
                                    })})
                            }),
                          "The definition of type %a@ is unavailable"
                        }), path, param[0]); end end 
       if ___conditional___ == 18--[[ Bad_fixed_type ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "This fixed type ",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ End_of_format ]]0
                                })
                            }),
                          "This fixed type %s"
                        }), param[0]); end end 
       if ___conditional___ == 19--[[ Unbound_type_var_ext ]] then do
          Format.fprintf(ppf, --[[ Format ]]{
                --[[ String_literal ]]Block.__(11, {
                    "A type variable is unbound in this extension constructor",
                    --[[ End_of_format ]]0
                  }),
                "A type variable is unbound in this extension constructor"
              });
          return explain_unbound(ppf, param[0], param[1].ext_args, (function(c) do
                        return c;
                      end end), "type", (function(param) do
                        return "";
                      end end)); end end 
      
    end
  end end 
end end

register_error_of_exn((function(param) do
        if (param[0] == __Error_8) then do
          return error_of_printer(param[1], report_error_5, param[2]);
        end
         end 
      end end));

__Error_9 = Caml_exceptions.create("Ocaml_typedtree_test.Typeclass.Error");

Error_forward_2 = Caml_exceptions.create("Ocaml_typedtree_test.Typeclass.Error_forward");

function ctyp(desc, typ, env, loc) do
  return do
          ctyp_desc: desc,
          ctyp_type: typ,
          ctyp_env: env,
          ctyp_loc: loc,
          ctyp_attributes: --[[ [] ]]0
        end;
end end

unbound_class = --[[ Pident ]]Block.__(0, {create("")});

function scrape_class_type(_cty) do
  while(true) do
    cty = _cty;
    local ___conditional___=(cty.tag | 0);
    do
       if ___conditional___ == 0--[[ Cty_constr ]] then do
          _cty = cty[2];
          ::continue:: ; end end 
       if ___conditional___ == 1--[[ Cty_signature ]]
       or ___conditional___ == 2--[[ Cty_arrow ]] then do
          return cty; end end 
      
    end
  end;
end end

function generalize_class_type(gen, _param) do
  while(true) do
    param = _param;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ == 0--[[ Cty_constr ]] then do
          List.iter(gen, param[1]);
          _param = param[2];
          ::continue:: ; end end 
       if ___conditional___ == 1--[[ Cty_signature ]] then do
          match = param[0];
          Curry._1(gen, match.csig_self);
          iter_1((function(param, param_1) do
                  return Curry._1(gen, param_1[2]);
                end end), match.csig_vars);
          return List.iter((function(param) do
                        return List.iter(gen, param[1]);
                      end end), match.csig_inher); end end 
       if ___conditional___ == 2--[[ Cty_arrow ]] then do
          Curry._1(gen, param[1]);
          _param = param[2];
          ::continue:: ; end end 
      
    end
  end;
end end

function virtual_methods(sign) do
  match = flatten_fields(object_fields(sign.csig_self));
  return List.fold_left((function(virt, param) do
                lab = param[0];
                if (lab == dummy_method or mem_2(lab, sign.csig_concr)) then do
                  return virt;
                end else do
                  return --[[ :: ]]{
                          lab,
                          virt
                        };
                end end 
              end end), --[[ [] ]]0, match[0]);
end end

function constructor_type(constr, _cty) do
  while(true) do
    cty = _cty;
    local ___conditional___=(cty.tag | 0);
    do
       if ___conditional___ == 0--[[ Cty_constr ]] then do
          _cty = cty[2];
          ::continue:: ; end end 
       if ___conditional___ == 1--[[ Cty_signature ]] then do
          return constr; end end 
       if ___conditional___ == 2--[[ Cty_arrow ]] then do
          desc_000 = cty[0];
          desc_001 = cty[1];
          desc_002 = constructor_type(constr, cty[2]);
          desc = --[[ Tarrow ]]Block.__(1, {
              desc_000,
              desc_001,
              desc_002,
              --[[ Cok ]]0
            });
          return newty2(current_level.contents, desc); end end 
      
    end
  end;
end end

function class_body(_cty) do
  while(true) do
    cty = _cty;
    local ___conditional___=(cty.tag | 0);
    do
       if ___conditional___ == 0--[[ Cty_constr ]]
       or ___conditional___ == 1--[[ Cty_signature ]] then do
          return cty; end end 
       if ___conditional___ == 2--[[ Cty_arrow ]] then do
          _cty = cty[2];
          ::continue:: ; end end 
      
    end
  end;
end end

function extract_constraints(cty) do
  sign = signature_of_class_type(cty);
  match = flatten_fields(object_fields(sign.csig_self));
  return --[[ tuple ]]{
          fold((function(lab, param, vars) do
                  return --[[ :: ]]{
                          lab,
                          vars
                        };
                end end), sign.csig_vars, --[[ [] ]]0),
          List.fold_left((function(meths, param) do
                  lab = param[0];
                  if (lab == dummy_method) then do
                    return meths;
                  end else do
                    return --[[ :: ]]{
                            lab,
                            meths
                          };
                  end end 
                end end), --[[ [] ]]0, match[0]),
          sign.csig_concr
        };
end end

function abbreviate_class_type(path, params, cty) do
  local ___conditional___=(cty.tag | 0);
  do
     if ___conditional___ == 0--[[ Cty_constr ]]
     or ___conditional___ == 1--[[ Cty_signature ]] then do
        return --[[ Cty_constr ]]Block.__(0, {
                  path,
                  params,
                  cty
                }); end end 
     if ___conditional___ == 2--[[ Cty_arrow ]] then do
        return --[[ Cty_arrow ]]Block.__(2, {
                  cty[0],
                  cty[1],
                  abbreviate_class_type(path, params, cty[2])
                }); end end 
    
  end
end end

function closed_class_1(cty) do
  if (List.for_all(closed_schema, cty.cty_params)) then do
    _param = cty.cty_type;
    while(true) do
      param = _param;
      local ___conditional___=(param.tag | 0);
      do
         if ___conditional___ == 0--[[ Cty_constr ]] then do
            return List.for_all(closed_schema, param[1]); end end 
         if ___conditional___ == 1--[[ Cty_signature ]] then do
            sign = param[0];
            if (closed_schema(sign.csig_self)) then do
              return fold((function(param, param_1, cc) do
                            if (closed_schema(param_1[2])) then do
                              return cc;
                            end else do
                              return false;
                            end end 
                          end end), sign.csig_vars, true);
            end else do
              return false;
            end end  end end 
         if ___conditional___ == 2--[[ Cty_arrow ]] then do
            if (closed_schema(param[1])) then do
              _param = param[2];
              ::continue:: ;
            end else do
              return false;
            end end  end end 
        
      end
    end;
  end else do
    return false;
  end end 
end end

function limited_generalize_1(rv, _param) do
  while(true) do
    param = _param;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ == 0--[[ Cty_constr ]] then do
          List.iter((function(param) do
                  return limited_generalize(rv, param);
                end end), param[1]);
          _param = param[2];
          ::continue:: ; end end 
       if ___conditional___ == 1--[[ Cty_signature ]] then do
          sign = param[0];
          limited_generalize(rv, sign.csig_self);
          iter_1((function(param, param_1) do
                  return limited_generalize(rv, param_1[2]);
                end end), sign.csig_vars);
          return List.iter((function(param) do
                        return List.iter((function(param) do
                                      return limited_generalize(rv, param);
                                    end end), param[1]);
                      end end), sign.csig_inher); end end 
       if ___conditional___ == 2--[[ Cty_arrow ]] then do
          limited_generalize(rv, param[1]);
          _param = param[2];
          ::continue:: ; end end 
      
    end
  end;
end end

function rc(node) do
  add_saved_type(--[[ Partial_class_expr ]]Block.__(4, {node}));
  record_2(--[[ Ti_class ]]Block.__(2, {node}));
  return node;
end end

function enter_met_env(check, loc, lab, kind, ty, val_env, met_env, par_env) do
  match = enter_value(undefined)(lab, do
        val_type: ty,
        val_kind: --[[ Val_unbound ]]1,
        val_loc: loc,
        val_attributes: --[[ [] ]]0
      end, val_env);
  id = match[0];
  return --[[ tuple ]]{
          id,
          match[1],
          add_value(check, id, do
                val_type: ty,
                val_kind: kind,
                val_loc: loc,
                val_attributes: --[[ [] ]]0
              end, met_env),
          add_value(undefined, id, do
                val_type: ty,
                val_kind: --[[ Val_unbound ]]1,
                val_loc: loc,
                val_attributes: --[[ [] ]]0
              end, par_env)
        };
end end

function enter_val(cl_num, vars, inh, lab, mut, virt, ty, val_env, met_env, par_env, loc) do
  match;
  xpcall(function() do
    match_1 = find(lab, vars.contents);
    virt$prime = match_1[2];
    if (match_1[1] ~= mut) then do
      error({
        __Error_9,
        loc,
        val_env,
        --[[ Mutability_mismatch ]]Block.__(22, {
            lab,
            mut
          })
      })
    end
     end 
    unify_2(val_env, instance(undefined, val_env, ty), instance(undefined, val_env, match_1[3]));
    match = --[[ tuple ]]{
      inh and undefined or match_1[0],
      virt$prime == --[[ Concrete ]]1 and virt$prime or virt
    };
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      error({
        __Error_9,
        loc,
        val_env,
        --[[ Field_type_mismatch ]]Block.__(1, {
            "instance variable",
            lab,
            exn[1]
          })
      })
    end
     end 
    if (exn == Caml_builtin_exceptions.not_found) then do
      match = --[[ tuple ]]{
        undefined,
        virt
      };
    end else do
      error(exn)
    end end 
  end end)
  id = match[0];
  result = id ~= undefined and --[[ tuple ]]{
      id,
      val_env,
      met_env,
      par_env
    } or enter_met_env(undefined, none, lab, --[[ Val_ivar ]]Block.__(1, {
            mut,
            cl_num
          }), ty, val_env, met_env, par_env);
  vars.contents = add_1(lab, --[[ tuple ]]{
        result[0],
        mut,
        match[1],
        ty
      }, vars.contents);
  return result;
end end

function concr_vals(vars) do
  return fold((function(id, param, s) do
                if (param[1] == --[[ Virtual ]]0) then do
                  return s;
                end else do
                  return add_2(id, s);
                end end 
              end end), vars, --[[ Empty ]]0);
end end

function inheritance(self_type, env, ovf, concr_meths, warn_vals, loc, parent) do
  match = scrape_class_type(parent);
  local ___conditional___=(match.tag | 0);
  do
     if ___conditional___ == 1--[[ Cty_signature ]] then do
        cl_sig = match[0];
        xpcall(function() do
          unify_2(env, self_type, cl_sig.csig_self);
        end end,function(raw_exn) do
          exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn[0] == Unify) then do
            trace = exn[1];
            exit = 0;
            if (trace) then do
              match_1 = trace[1];
              if (match_1) then do
                match_2 = match_1[1];
                if (match_2) then do
                  match_3 = match_2[1];
                  if (match_3) then do
                    match_4 = match_3[0][0].desc;
                    if (typeof match_4 == "number" or match_4.tag ~= --[[ Tfield ]]5) then do
                      exit = 1;
                    end else do
                      error({
                        __Error_9,
                        loc,
                        env,
                        --[[ Field_type_mismatch ]]Block.__(1, {
                            "method",
                            match_4[0],
                            match_3[1]
                          })
                      })
                    end end 
                  end else do
                    exit = 1;
                  end end 
                end else do
                  exit = 1;
                end end 
              end else do
                exit = 1;
              end end 
            end else do
              exit = 1;
            end end 
            if (exit == 1) then do
              error({
                Caml_builtin_exceptions.assert_failure,
                --[[ tuple ]]{
                  "typeclass.ml",
                  261,
                  12
                }
              })
            end
             end 
          end else do
            error(exn)
          end end 
        end end)
        over_meths = inter_1(cl_sig.csig_concr, concr_meths);
        concr_vals_1 = concr_vals(cl_sig.csig_vars);
        over_vals = inter_1(concr_vals_1, warn_vals);
        if (ovf ~= undefined) then do
          if (ovf) then do
            cname;
            local ___conditional___=(parent.tag | 0);
            do
               if ___conditional___ == 0--[[ Cty_constr ]] then do
                  cname = name(undefined, parent[0]); end else 
               if ___conditional___ == 1--[[ Cty_signature ]]
               or ___conditional___ == 2--[[ Cty_arrow ]] then do
                  cname = "inherited"; end else 
               end end end end
              
            end
            if (not (
                over_meths and false or true
              )) then do
              prerr_warning(loc, --[[ Method_override ]]Block.__(2, {--[[ :: ]]{
                        cname,
                        elements_aux(--[[ [] ]]0, over_meths)
                      }}));
            end
             end 
            if (not (
                over_vals and false or true
              )) then do
              prerr_warning(loc, --[[ Instance_variable_override ]]Block.__(5, {--[[ :: ]]{
                        cname,
                        elements_aux(--[[ [] ]]0, over_vals)
                      }}));
            end
             end 
          end else if ((
              over_meths and false or true
            ) and (
              over_vals and false or true
            )) then do
            error({
              __Error_9,
              loc,
              env,
              --[[ No_overriding ]]Block.__(23, {
                  "",
                  ""
                })
            })
          end
           end  end 
        end
         end 
        concr_meths_1 = union_1(cl_sig.csig_concr, concr_meths);
        warn_vals_1 = union_1(concr_vals_1, warn_vals);
        return --[[ tuple ]]{
                cl_sig,
                concr_meths_1,
                warn_vals_1
              }; end end 
     if ___conditional___ == 0--[[ Cty_constr ]]
     or ___conditional___ == 2--[[ Cty_arrow ]] then do
        error({
          __Error_9,
          loc,
          env,
          --[[ Structure_expected ]]Block.__(2, {parent})
        }) end end 
    
  end
end end

function virtual_method(val_env, meths, self_type, lab, priv, sty, loc) do
  match = filter_self_method(val_env, lab, priv, meths, self_type);
  sty_1 = force_poly(sty);
  cty = transl_simple_type(val_env, false, sty_1);
  ty = cty.ctyp_type;
  xpcall(function() do
    unify_2(val_env, ty, match[1]);
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      error({
        __Error_9,
        loc,
        val_env,
        --[[ Field_type_mismatch ]]Block.__(1, {
            "method",
            lab,
            exn[1]
          })
      })
    end
     end 
    error(exn)
  end end)
  return cty;
end end

delayed_meth_specs = do
  contents: --[[ [] ]]0
end;

function declare_method(val_env, meths, self_type, lab, priv, sty, loc) do
  match = filter_self_method(val_env, lab, priv, meths, self_type);
  ty$prime = match[1];
  unif = function(ty) do
    xpcall(function() do
      return unify_2(val_env, ty, ty$prime);
    end end,function(raw_exn) do
      exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] == Unify) then do
        error({
          __Error_9,
          loc,
          val_env,
          --[[ Field_type_mismatch ]]Block.__(1, {
              "method",
              lab,
              exn[1]
            })
        })
      end
       end 
      error(exn)
    end end)
  end end;
  sty_1 = force_poly(sty);
  match_1 = sty_1.ptyp_desc;
  if (typeof match_1 ~= "number" and match_1.tag == --[[ Ptyp_poly ]]8 and not match_1[0] and priv) then do
    sty$prime = match_1[1];
    returned_cty = ctyp(--[[ Ttyp_any ]]0, newty2(current_level.contents, --[[ Tnil ]]0), val_env, loc);
    delayed_meth_specs.contents = --[[ :: ]]{
      Caml_obj.caml_lazy_make((function(param) do
              cty = transl_simple_type_univars(val_env, sty$prime);
              ty = cty.ctyp_type;
              unif(ty);
              returned_cty.ctyp_desc = --[[ Ttyp_poly ]]Block.__(8, {
                  --[[ [] ]]0,
                  cty
                });
              returned_cty.ctyp_type = ty;
              return --[[ () ]]0;
            end end)),
      delayed_meth_specs.contents
    };
    return returned_cty;
  end
   end 
  cty = transl_simple_type(val_env, false, sty_1);
  ty = cty.ctyp_type;
  unif(ty);
  return cty;
end end

function type_constraint(val_env, sty, sty$prime, loc) do
  cty = transl_simple_type(val_env, false, sty);
  ty = cty.ctyp_type;
  cty$prime = transl_simple_type(val_env, false, sty$prime);
  ty$prime = cty$prime.ctyp_type;
  xpcall(function() do
    unify_2(val_env, ty, ty$prime);
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      error({
        __Error_9,
        loc,
        val_env,
        --[[ Unconsistent_constraint ]]Block.__(0, {exn[1]})
      })
    end
     end 
    error(exn)
  end end)
  return --[[ tuple ]]{
          cty,
          cty$prime
        };
end end

function make_method(loc, cl_num, expr) do
  return Curry._6(Ast_helper_Exp.fun_, expr.pexp_loc, undefined, "", undefined, alias_1(loc, undefined, __var_1(loc, undefined, do
                      txt: "self-*",
                      loc: loc
                    end), do
                  txt: "self-" .. cl_num,
                  loc: loc
                end), expr);
end end

function add_val(env, loc, lab, param, val_sig) do
  virt = param[1];
  virt_1;
  xpcall(function() do
    match = find(lab, val_sig);
    virt$prime = match[1];
    virt_1 = virt$prime == --[[ Concrete ]]1 and virt$prime or virt;
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      virt_1 = virt;
    end else do
      error(exn)
    end end 
  end end)
  return add_1(lab, --[[ tuple ]]{
              param[0],
              virt_1,
              param[2]
            }, val_sig);
end end

function class_signature_1(env, param) do
  sty = param.pcsig_self;
  meths = do
    contents: --[[ Empty ]]0
  end;
  self_cty = transl_simple_type(env, false, sty);
  self_cty_1 = do
    ctyp_desc: self_cty.ctyp_desc,
    ctyp_type: expand_head(env, self_cty.ctyp_type),
    ctyp_env: self_cty.ctyp_env,
    ctyp_loc: self_cty.ctyp_loc,
    ctyp_attributes: self_cty.ctyp_attributes
  end;
  self_type = self_cty_1.ctyp_type;
  dummy_obj = newvar(undefined, --[[ () ]]0);
  unify_2(env, filter_method(env, dummy_method, --[[ Private ]]0, dummy_obj), newty2(current_level.contents, --[[ Ttuple ]]Block.__(2, {--[[ [] ]]0})));
  xpcall(function() do
    unify_2(env, self_type, dummy_obj);
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      error({
        __Error_9,
        sty.ptyp_loc,
        env,
        --[[ Pattern_type_clash ]]Block.__(5, {self_type})
      })
    end
     end 
    error(exn)
  end end)
  warning_enter_scope(--[[ () ]]0);
  match = List.fold_left((function(param, param_1) do
          env_1 = env;
          self_type_1 = self_type;
          meths_1 = meths;
          param_2 = param;
          ctf = param_1;
          inher = param_2[3];
          concr_meths = param_2[2];
          val_sig = param_2[1];
          fields = param_2[0];
          loc = ctf.pctf_loc;
          mkctf = function(desc) do
            return do
                    ctf_desc: desc,
                    ctf_loc: loc,
                    ctf_attributes: ctf.pctf_attributes
                  end;
          end end;
          match = ctf.pctf_desc;
          local ___conditional___=(match.tag | 0);
          do
             if ___conditional___ == 0--[[ Pctf_inherit ]] then do
                sparent = match[0];
                parent = class_type_3(env_1, sparent);
                match_1 = parent.cltyp_type;
                inher_1;
                local ___conditional___=(match_1.tag | 0);
                do
                   if ___conditional___ == 0--[[ Cty_constr ]] then do
                      inher_1 = --[[ :: ]]{
                        --[[ tuple ]]{
                          match_1[0],
                          match_1[1]
                        },
                        inher
                      }; end else 
                   if ___conditional___ == 1--[[ Cty_signature ]]
                   or ___conditional___ == 2--[[ Cty_arrow ]] then do
                      inher_1 = inher; end else 
                   end end end end
                  
                end
                match_2 = inheritance(self_type_1, env_1, undefined, concr_meths, --[[ Empty ]]0, sparent.pcty_loc, parent.cltyp_type);
                partial_arg = sparent.pcty_loc;
                val_sig_1 = fold((function(param, param_1, param_2) do
                        return add_val(env_1, partial_arg, param, param_1, param_2);
                      end end), match_2[0].csig_vars, val_sig);
                return --[[ tuple ]]{
                        --[[ :: ]]{
                          mkctf(--[[ Tctf_inherit ]]Block.__(0, {parent})),
                          fields
                        },
                        val_sig_1,
                        match_2[1],
                        inher_1
                      }; end end 
             if ___conditional___ == 1--[[ Pctf_val ]] then do
                match_3 = match[0];
                virt = match_3[2];
                mut = match_3[1];
                lab = match_3[0];
                cty = transl_simple_type(env_1, false, match_3[3]);
                ty = cty.ctyp_type;
                return --[[ tuple ]]{
                        --[[ :: ]]{
                          mkctf(--[[ Tctf_val ]]Block.__(1, {--[[ tuple ]]{
                                    lab,
                                    mut,
                                    virt,
                                    cty
                                  }})),
                          fields
                        },
                        add_val(env_1, ctf.pctf_loc, lab, --[[ tuple ]]{
                              mut,
                              virt,
                              ty
                            }, val_sig),
                        concr_meths,
                        inher
                      }; end end 
             if ___conditional___ == 2--[[ Pctf_method ]] then do
                match_4 = match[0];
                virt_1 = match_4[2];
                priv = match_4[1];
                lab_1 = match_4[0];
                cty_1 = declare_method(env_1, meths_1, self_type_1, lab_1, priv, match_4[3], ctf.pctf_loc);
                concr_meths_1 = virt_1 and add_2(lab_1, concr_meths) or concr_meths;
                return --[[ tuple ]]{
                        --[[ :: ]]{
                          mkctf(--[[ Tctf_method ]]Block.__(2, {--[[ tuple ]]{
                                    lab_1,
                                    priv,
                                    virt_1,
                                    cty_1
                                  }})),
                          fields
                        },
                        val_sig,
                        concr_meths_1,
                        inher
                      }; end end 
             if ___conditional___ == 3--[[ Pctf_constraint ]] then do
                match_5 = match[0];
                match_6 = type_constraint(env_1, match_5[0], match_5[1], ctf.pctf_loc);
                return --[[ tuple ]]{
                        --[[ :: ]]{
                          mkctf(--[[ Tctf_constraint ]]Block.__(3, {--[[ tuple ]]{
                                    match_6[0],
                                    match_6[1]
                                  }})),
                          fields
                        },
                        val_sig,
                        concr_meths,
                        inher
                      }; end end 
             if ___conditional___ == 4--[[ Pctf_attribute ]] then do
                x = match[0];
                warning_attribute(--[[ :: ]]{
                      x,
                      --[[ [] ]]0
                    });
                return --[[ tuple ]]{
                        --[[ :: ]]{
                          mkctf(--[[ Tctf_attribute ]]Block.__(4, {x})),
                          fields
                        },
                        val_sig,
                        concr_meths,
                        inher
                      }; end end 
             if ___conditional___ == 5--[[ Pctf_extension ]] then do
                error({
                  Error_forward_2,
                  error_of_extension(match[0])
                }) end end 
            
          end
        end end), --[[ tuple ]]{
        --[[ [] ]]0,
        --[[ Empty ]]0,
        --[[ Empty ]]0,
        --[[ [] ]]0
      }, param.pcsig_fields);
  warning_leave_scope(--[[ () ]]0);
  cty_csig_vars = match[1];
  cty_csig_concr = match[2];
  cty_csig_inher = match[3];
  cty = do
    csig_self: self_type,
    csig_vars: cty_csig_vars,
    csig_concr: cty_csig_concr,
    csig_inher: cty_csig_inher
  end;
  return do
          csig_self: self_cty_1,
          csig_fields: List.rev(match[0]),
          csig_type: cty
        end;
end end

function class_type_3(env, scty) do
  cltyp = function(desc, typ) do
    return do
            cltyp_desc: desc,
            cltyp_type: typ,
            cltyp_env: env,
            cltyp_loc: scty.pcty_loc,
            cltyp_attributes: scty.pcty_attributes
          end;
  end end;
  match = scty.pcty_desc;
  local ___conditional___=(match.tag | 0);
  do
     if ___conditional___ == 0--[[ Pcty_constr ]] then do
        styl = match[1];
        lid = match[0];
        match_1 = find_class_type(env, scty.pcty_loc, lid.txt);
        decl = match_1[1];
        path = match_1[0];
        if (same(decl.clty_path, unbound_class)) then do
          error({
            __Error_9,
            scty.pcty_loc,
            env,
            --[[ Unbound_class_type_2 ]]Block.__(7, {lid.txt})
          })
        end
         end 
        match_2 = instance_class(decl.clty_params, decl.clty_type);
        params = match_2[0];
        if (List.length(params) ~= List.length(styl)) then do
          error({
            __Error_9,
            scty.pcty_loc,
            env,
            --[[ Parameter_arity_mismatch ]]Block.__(11, {
                lid.txt,
                List.length(params),
                List.length(styl)
              })
          })
        end
         end 
        ctys = List.map2((function(sty, ty) do
                cty$prime = transl_simple_type(env, false, sty);
                ty$prime = cty$prime.ctyp_type;
                xpcall(function() do
                  unify_2(env, ty$prime, ty);
                end end,function(raw_exn) do
                  exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                  if (exn[0] == Unify) then do
                    error({
                      __Error_9,
                      sty.ptyp_loc,
                      env,
                      --[[ Parameter_mismatch ]]Block.__(12, {exn[1]})
                    })
                  end
                   end 
                  error(exn)
                end end)
                return cty$prime;
              end end), styl, params);
        typ_002 = match_2[1];
        typ = --[[ Cty_constr ]]Block.__(0, {
            path,
            params,
            typ_002
          });
        return cltyp(--[[ Tcty_constr ]]Block.__(0, {
                      path,
                      lid,
                      ctys
                    }), typ); end end 
     if ___conditional___ == 1--[[ Pcty_signature ]] then do
        clsig = class_signature_1(env, match[0]);
        typ_1 = --[[ Cty_signature ]]Block.__(1, {clsig.csig_type});
        return cltyp(--[[ Tcty_signature ]]Block.__(1, {clsig}), typ_1); end end 
     if ___conditional___ == 2--[[ Pcty_arrow ]] then do
        l = match[0];
        cty = transl_simple_type(env, false, match[1]);
        ty = cty.ctyp_type;
        clty = class_type_3(env, match[2]);
        typ_002_1 = clty.cltyp_type;
        typ_2 = --[[ Cty_arrow ]]Block.__(2, {
            l,
            ty,
            typ_002_1
          });
        return cltyp(--[[ Tcty_arrow ]]Block.__(2, {
                      l,
                      cty,
                      clty
                    }), typ_2); end end 
     if ___conditional___ == 3--[[ Pcty_extension ]] then do
        error({
          Error_forward_2,
          error_of_extension(match[0])
        }) end end 
    
  end
end end

function class_type_4(env, scty) do
  delayed_meth_specs.contents = --[[ [] ]]0;
  cty = class_type_3(env, scty);
  List.iter(CamlinternalLazy.force, List.rev(delayed_meth_specs.contents));
  delayed_meth_specs.contents = --[[ [] ]]0;
  return cty;
end end

function class_structure(cl_num, __final, val_env, met_env, loc, param) do
  spat = param.pcstr_self;
  init = spat.ppat_loc;
  self_loc_loc_start = init.loc_start;
  self_loc_loc_end = init.loc_end;
  self_loc = do
    loc_start: self_loc_loc_start,
    loc_end: self_loc_loc_end,
    loc_ghost: true
  end;
  self_type = newvar(undefined, --[[ () ]]0);
  unify_2(val_env, filter_method(val_env, dummy_method, --[[ Private ]]0, self_type), newty2(current_level.contents, --[[ Ttuple ]]Block.__(2, {--[[ [] ]]0})));
  private_self = __final and newvar(undefined, --[[ () ]]0) or self_type;
  match = type_self_pattern(cl_num, private_self, val_env, met_env, met_env, spat);
  val_env_1 = match[3];
  vars = match[2];
  meths = match[1];
  pat = match[0];
  public_self = pat.pat_type;
  ty;
  if (__final) then do
    desc_000 = newvar(undefined, --[[ () ]]0);
    desc_001 = do
      contents: undefined
    end;
    desc = --[[ Tobject ]]Block.__(4, {
        desc_000,
        desc_001
      });
    ty = newty2(current_level.contents, desc);
  end else do
    ty = self_type;
  end end 
  xpcall(function() do
    unify_2(val_env_1, public_self, ty);
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      error({
        __Error_9,
        spat.ppat_loc,
        val_env_1,
        --[[ Pattern_type_clash ]]Block.__(5, {public_self})
      })
    end
     end 
    error(exn)
  end end)
  get_methods = function(ty) do
    return flatten_fields(object_fields(expand_head(val_env_1, ty)))[0];
  end end;
  if (__final) then do
    List.iter((function(param) do
            k = field_kind_repr(param[1]) == --[[ Fpresent ]]0 and --[[ Public ]]1 or --[[ Private ]]0;
            xpcall(function() do
              return unify_2(val_env_1, param[2], filter_method(val_env_1, param[0], k, self_type));
            end end,function(exn) do
              error({
                Caml_builtin_exceptions.assert_failure,
                --[[ tuple ]]{
                  "typeclass.ml",
                  760,
                  18
                }
              })
            end end)
          end end), get_methods(public_self));
  end
   end 
  warning_enter_scope(--[[ () ]]0);
  match_1 = List.fold_left((function(param, param_1) do
          self_loc_1 = self_loc;
          cl_num_1 = cl_num;
          self_type_1 = self_type;
          meths_1 = meths;
          vars_1 = vars;
          param_2 = param;
          cf = param_1;
          local_vals = param_2[8];
          local_meths = param_2[7];
          inher = param_2[6];
          warn_vals = param_2[5];
          concr_meths = param_2[4];
          fields = param_2[3];
          par_env = param_2[2];
          met_env = param_2[1];
          val_env = param_2[0];
          loc = cf.pcf_loc;
          mkcf = function(desc) do
            return do
                    cf_desc: desc,
                    cf_loc: loc,
                    cf_attributes: cf.pcf_attributes
                  end;
          end end;
          match = cf.pcf_desc;
          local ___conditional___=(match.tag | 0);
          do
             if ___conditional___ == 0--[[ Pcf_inherit ]] then do
                __super = match[2];
                sparent = match[1];
                ovf = match[0];
                parent = class_expr(cl_num_1, val_env, par_env, sparent);
                match_1 = parent.cl_type;
                inher_1;
                local ___conditional___=(match_1.tag | 0);
                do
                   if ___conditional___ == 0--[[ Cty_constr ]] then do
                      inher_1 = --[[ :: ]]{
                        --[[ tuple ]]{
                          match_1[0],
                          match_1[1]
                        },
                        inher
                      }; end else 
                   if ___conditional___ == 1--[[ Cty_signature ]]
                   or ___conditional___ == 2--[[ Cty_arrow ]] then do
                      inher_1 = inher; end else 
                   end end end end
                  
                end
                match_2 = inheritance(self_type_1, val_env, ovf, concr_meths, warn_vals, sparent.pcl_loc, parent.cl_type);
                cl_sig = match_2[0];
                match_3 = fold((function(lab, info, param) do
                        match = enter_val(cl_num_1, vars_1, true, lab, info[0], info[1], info[2], param[0], param[1], param[2], sparent.pcl_loc);
                        return --[[ tuple ]]{
                                match[1],
                                match[2],
                                match[3],
                                --[[ :: ]]{
                                  --[[ tuple ]]{
                                    lab,
                                    match[0]
                                  },
                                  param[3]
                                }
                              };
                      end end), cl_sig.csig_vars, --[[ tuple ]]{
                      val_env,
                      met_env,
                      par_env,
                      --[[ [] ]]0
                    });
                inh_vars = match_3[3];
                par_env_1 = match_3[2];
                met_env_1 = match_3[1];
                val_env_1 = match_3[0];
                inh_meths = fold_1((function(lab, rem) do
                        return --[[ :: ]]{
                                --[[ tuple ]]{
                                  lab,
                                  create(lab)
                                },
                                rem
                              };
                      end end), cl_sig.csig_concr, --[[ [] ]]0);
                match_4;
                if (__super ~= undefined) then do
                  match_5 = enter_met_env((function(s) do
                          return --[[ Unused_ancestor ]]Block.__(20, {s});
                        end end), sparent.pcl_loc, __super, --[[ Val_anc ]]Block.__(3, {
                          inh_meths,
                          cl_num_1
                        }), self_type_1, val_env_1, met_env_1, par_env_1);
                  match_4 = --[[ tuple ]]{
                    match_5[1],
                    match_5[2],
                    match_5[3]
                  };
                end else do
                  match_4 = --[[ tuple ]]{
                    val_env_1,
                    met_env_1,
                    par_env_1
                  };
                end end 
                return --[[ tuple ]]{
                        match_4[0],
                        match_4[1],
                        match_4[2],
                        --[[ :: ]]{
                          Caml_obj.caml_lazy_make((function(param) do
                                  return mkcf(--[[ Tcf_inherit ]]Block.__(0, {
                                                ovf,
                                                parent,
                                                __super,
                                                inh_vars,
                                                inh_meths
                                              }));
                                end end)),
                          fields
                        },
                        match_2[1],
                        match_2[2],
                        inher_1,
                        local_meths,
                        local_vals
                      }; end end 
             if ___conditional___ == 1--[[ Pcf_val ]] then do
                match_6 = match[0];
                match_7 = match_6[2];
                mut = match_6[1];
                lab = match_6[0];
                if (match_7.tag) then do
                  ovf_1 = match_7[0];
                  if (mem_2(lab.txt, local_vals)) then do
                    error({
                      __Error_9,
                      loc,
                      val_env,
                      --[[ Duplicate ]]Block.__(24, {
                          "instance variable",
                          lab.txt
                        })
                    })
                  end
                   end 
                  if (mem_2(lab.txt, warn_vals)) then do
                    if (ovf_1 == --[[ Fresh ]]1) then do
                      prerr_warning(lab.loc, --[[ Instance_variable_override ]]Block.__(5, {--[[ :: ]]{
                                lab.txt,
                                --[[ [] ]]0
                              }}));
                    end
                     end 
                  end else if (ovf_1 == --[[ Override ]]0) then do
                    error({
                      __Error_9,
                      loc,
                      val_env,
                      --[[ No_overriding ]]Block.__(23, {
                          "instance variable",
                          lab.txt
                        })
                    })
                  end
                   end  end 
                  if (principal.contents) then do
                    begin_def(--[[ () ]]0);
                  end
                   end 
                  exp;
                  xpcall(function() do
                    exp = type_exp(val_env, match_7[1]);
                  end end,function(raw_exn) do
                    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn[0] == Unify) then do
                      match_8 = exn[1];
                      if (match_8) then do
                        if (match_8[1]) then do
                          error(exn)
                        end
                         end 
                        error({
                          __Error_9,
                          loc,
                          val_env,
                          --[[ Make_nongen_seltype ]]Block.__(17, {match_8[0][0]})
                        })
                      end else do
                        error(exn)
                      end end 
                    end else do
                      error(exn)
                    end end 
                  end end)
                  if (principal.contents) then do
                    end_def(--[[ () ]]0);
                    generalize_structure_1(current_level.contents, exp.exp_type);
                  end
                   end 
                  match_9 = enter_val(cl_num_1, vars_1, false, lab.txt, mut, --[[ Concrete ]]1, exp.exp_type, val_env, met_env, par_env, loc);
                  met_env$prime = match_9[2];
                  id = match_9[0];
                  return --[[ tuple ]]{
                          match_9[1],
                          met_env$prime,
                          match_9[3],
                          --[[ :: ]]{
                            Caml_obj.caml_lazy_make((function(param) do
                                    return mkcf(--[[ Tcf_val ]]Block.__(1, {
                                                  lab,
                                                  mut,
                                                  id,
                                                  --[[ Tcfk_concrete ]]Block.__(1, {
                                                      ovf_1,
                                                      exp
                                                    }),
                                                  met_env == met_env$prime
                                                }));
                                  end end)),
                            fields
                          },
                          concr_meths,
                          add_2(lab.txt, warn_vals),
                          inher,
                          local_meths,
                          add_2(lab.txt, local_vals)
                        };
                end else do
                  if (principal.contents) then do
                    begin_def(--[[ () ]]0);
                  end
                   end 
                  cty = transl_simple_type(val_env, false, match_7[0]);
                  ty = cty.ctyp_type;
                  if (principal.contents) then do
                    end_def(--[[ () ]]0);
                    generalize_structure_1(current_level.contents, ty);
                  end
                   end 
                  match_10 = enter_val(cl_num_1, vars_1, false, lab.txt, mut, --[[ Virtual ]]0, ty, val_env, met_env, par_env, loc);
                  met_env$prime_1 = match_10[2];
                  id_1 = match_10[0];
                  return --[[ tuple ]]{
                          match_10[1],
                          met_env$prime_1,
                          match_10[3],
                          --[[ :: ]]{
                            Caml_obj.caml_lazy_make((function(param) do
                                    return mkcf(--[[ Tcf_val ]]Block.__(1, {
                                                  lab,
                                                  mut,
                                                  id_1,
                                                  --[[ Tcfk_virtual ]]Block.__(0, {cty}),
                                                  met_env == met_env$prime_1
                                                }));
                                  end end)),
                            fields
                          },
                          concr_meths,
                          warn_vals,
                          inher,
                          local_meths,
                          local_vals
                        };
                end end  end end 
             if ___conditional___ == 2--[[ Pcf_method ]] then do
                match_11 = match[0];
                match_12 = match_11[2];
                priv = match_11[1];
                lab_1 = match_11[0];
                if (match_12.tag) then do
                  expr = match_12[1];
                  ovf_2 = match_12[0];
                  match_13 = expr.pexp_desc;
                  expr_1;
                  expr_1 = match_13.tag == --[[ Pexp_poly ]]28 and expr or Curry._4(Ast_helper_Exp.poly, expr.pexp_loc, undefined, expr, undefined);
                  if (mem_2(lab_1.txt, local_meths)) then do
                    error({
                      __Error_9,
                      loc,
                      val_env,
                      --[[ Duplicate ]]Block.__(24, {
                          "method",
                          lab_1.txt
                        })
                    })
                  end
                   end 
                  if (mem_2(lab_1.txt, concr_meths)) then do
                    if (ovf_2 == --[[ Fresh ]]1) then do
                      prerr_warning(loc, --[[ Method_override ]]Block.__(2, {--[[ :: ]]{
                                lab_1.txt,
                                --[[ [] ]]0
                              }}));
                    end
                     end 
                  end else if (ovf_2 == --[[ Override ]]0) then do
                    error({
                      __Error_9,
                      loc,
                      val_env,
                      --[[ No_overriding ]]Block.__(23, {
                          "method",
                          lab_1.txt
                        })
                    })
                  end
                   end  end 
                  match_14 = filter_self_method(val_env, lab_1.txt, priv, meths_1, self_type_1);
                  ty_1 = match_14[1];
                  xpcall(function() do
                    match_15 = expr_1.pexp_desc;
                    if (match_15.tag == --[[ Pexp_poly ]]28) then do
                      sty = match_15[1];
                      sbody = match_15[0];
                      if (sty ~= undefined) then do
                        sty_1 = force_poly(sty);
                        cty$prime = transl_simple_type(val_env, false, sty_1);
                        ty$prime = cty$prime.ctyp_type;
                        unify_2(val_env, ty$prime, ty_1);
                      end
                       end 
                      match_16 = repr(ty_1).desc;
                      if (typeof match_16 == "number") then do
                        error({
                          Caml_builtin_exceptions.assert_failure,
                          --[[ tuple ]]{
                            "typeclass.ml",
                            662,
                            17
                          }
                        })
                      end else do
                        local ___conditional___=(match_16.tag | 0);
                        do
                           if ___conditional___ == 0--[[ Tvar ]] then do
                              ty$prime_1 = newvar(undefined, --[[ () ]]0);
                              unify_2(val_env, newty2(current_level.contents, --[[ Tpoly ]]Block.__(10, {
                                          ty$prime_1,
                                          --[[ [] ]]0
                                        })), ty_1);
                              unify_2(val_env, type_approx(val_env, sbody), ty$prime_1); end else 
                           if ___conditional___ == 10--[[ Tpoly ]] then do
                              match_17 = instance_poly(undefined, false, match_16[1], match_16[0]);
                              ty2 = type_approx(val_env, sbody);
                              unify_2(val_env, ty2, match_17[1]); end else 
                           end end end end
                          error({
                              Caml_builtin_exceptions.assert_failure,
                              --[[ tuple ]]{
                                "typeclass.ml",
                                662,
                                17
                              }
                            })
                            
                        end
                      end end 
                    end else do
                      error({
                        Caml_builtin_exceptions.assert_failure,
                        --[[ tuple ]]{
                          "typeclass.ml",
                          664,
                          13
                        }
                      })
                    end end 
                  end end,function(raw_exn_1) do
                    exn_1 = Caml_js_exceptions.internalToOCamlException(raw_exn_1);
                    if (exn_1[0] == Unify) then do
                      error({
                        __Error_9,
                        loc,
                        val_env,
                        --[[ Field_type_mismatch ]]Block.__(1, {
                            "method",
                            lab_1.txt,
                            exn_1[1]
                          })
                      })
                    end
                     end 
                    error(exn_1)
                  end end)
                  meth_expr = make_method(self_loc_1, cl_num_1, expr_1);
                  vars_local = vars_1.contents;
                  field = Caml_obj.caml_lazy_make((function(param) do
                          meth_type = newty2(100000000, --[[ Tarrow ]]Block.__(1, {
                                  "",
                                  self_type_1,
                                  ty_1,
                                  --[[ Cok ]]0
                                }));
                          raise_nongen_level(--[[ () ]]0);
                          vars_1.contents = vars_local;
                          texp = type_expect(undefined, met_env, meth_expr, meth_type);
                          end_def(--[[ () ]]0);
                          return mkcf(--[[ Tcf_method ]]Block.__(2, {
                                        lab_1,
                                        priv,
                                        --[[ Tcfk_concrete ]]Block.__(1, {
                                            ovf_2,
                                            texp
                                          })
                                      }));
                        end end));
                  return --[[ tuple ]]{
                          val_env,
                          met_env,
                          par_env,
                          --[[ :: ]]{
                            field,
                            fields
                          },
                          add_2(lab_1.txt, concr_meths),
                          warn_vals,
                          inher,
                          add_2(lab_1.txt, local_meths),
                          local_vals
                        };
                end else do
                  cty_1 = virtual_method(val_env, meths_1, self_type_1, lab_1.txt, priv, match_12[0], loc);
                  return --[[ tuple ]]{
                          val_env,
                          met_env,
                          par_env,
                          --[[ :: ]]{
                            Caml_obj.caml_lazy_make((function(param) do
                                    return mkcf(--[[ Tcf_method ]]Block.__(2, {
                                                  lab_1,
                                                  priv,
                                                  --[[ Tcfk_virtual ]]Block.__(0, {cty_1})
                                                }));
                                  end end)),
                            fields
                          },
                          concr_meths,
                          warn_vals,
                          inher,
                          local_meths,
                          local_vals
                        };
                end end  end end 
             if ___conditional___ == 3--[[ Pcf_constraint ]] then do
                match_18 = match[0];
                match_19 = type_constraint(val_env, match_18[0], match_18[1], loc);
                cty$prime_1 = match_19[1];
                cty_2 = match_19[0];
                return --[[ tuple ]]{
                        val_env,
                        met_env,
                        par_env,
                        --[[ :: ]]{
                          Caml_obj.caml_lazy_make((function(param) do
                                  return mkcf(--[[ Tcf_constraint ]]Block.__(3, {
                                                cty_2,
                                                cty$prime_1
                                              }));
                                end end)),
                          fields
                        },
                        concr_meths,
                        warn_vals,
                        inher,
                        local_meths,
                        local_vals
                      }; end end 
             if ___conditional___ == 4--[[ Pcf_initializer ]] then do
                expr_2 = make_method(self_loc_1, cl_num_1, match[0]);
                vars_local_1 = vars_1.contents;
                field_1 = Caml_obj.caml_lazy_make((function(param) do
                        raise_nongen_level(--[[ () ]]0);
                        desc_002 = instance_def(type_unit);
                        desc = --[[ Tarrow ]]Block.__(1, {
                            "",
                            self_type_1,
                            desc_002,
                            --[[ Cok ]]0
                          });
                        meth_type = newty2(current_level.contents, desc);
                        vars_1.contents = vars_local_1;
                        texp = type_expect(undefined, met_env, expr_2, meth_type);
                        end_def(--[[ () ]]0);
                        return mkcf(--[[ Tcf_initializer ]]Block.__(4, {texp}));
                      end end));
                return --[[ tuple ]]{
                        val_env,
                        met_env,
                        par_env,
                        --[[ :: ]]{
                          field_1,
                          fields
                        },
                        concr_meths,
                        warn_vals,
                        inher,
                        local_meths,
                        local_vals
                      }; end end 
             if ___conditional___ == 5--[[ Pcf_attribute ]] then do
                x = match[0];
                warning_attribute(--[[ :: ]]{
                      x,
                      --[[ [] ]]0
                    });
                return --[[ tuple ]]{
                        val_env,
                        met_env,
                        par_env,
                        --[[ :: ]]{
                          Caml_obj.caml_lazy_make((function(param) do
                                  return mkcf(--[[ Tcf_attribute ]]Block.__(5, {x}));
                                end end)),
                          fields
                        },
                        concr_meths,
                        warn_vals,
                        inher,
                        local_meths,
                        local_vals
                      }; end end 
             if ___conditional___ == 6--[[ Pcf_extension ]] then do
                error({
                  Error_forward_2,
                  error_of_extension(match[0])
                }) end end 
            
          end
        end end), --[[ tuple ]]{
        val_env_1,
        match[4],
        match[5],
        --[[ [] ]]0,
        --[[ Empty ]]0,
        --[[ Empty ]]0,
        --[[ [] ]]0,
        --[[ Empty ]]0,
        --[[ Empty ]]0
      }, param.pcstr_fields);
  inher = match_1[6];
  concr_meths = match_1[4];
  warning_leave_scope(--[[ () ]]0);
  unify_2(val_env_1, self_type, newvar(undefined, --[[ () ]]0));
  sign_csig_vars = map((function(param) do
          return --[[ tuple ]]{
                  param[1],
                  param[2],
                  param[3]
                };
        end end), vars.contents);
  sign = do
    csig_self: public_self,
    csig_vars: sign_csig_vars,
    csig_concr: concr_meths,
    csig_inher: inher
  end;
  methods = get_methods(self_type);
  priv_meths = List.filter((function(param) do
            return field_kind_repr(param[1]) ~= --[[ Fpresent ]]0;
          end end))(methods);
  if (__final) then do
    close_object(self_type);
    mets = virtual_methods(do
          csig_self: self_type,
          csig_vars: sign_csig_vars,
          csig_concr: concr_meths,
          csig_inher: inher
        end);
    vals = fold((function(name, param, l) do
            if (param[1] == --[[ Virtual ]]0) then do
              return --[[ :: ]]{
                      name,
                      l
                    };
            end else do
              return l;
            end end 
          end end), sign_csig_vars, --[[ [] ]]0);
    if (mets ~= --[[ [] ]]0 or vals ~= --[[ [] ]]0) then do
      error({
        __Error_9,
        loc,
        val_env_1,
        --[[ Virtual_class ]]Block.__(10, {
            true,
            __final,
            mets,
            vals
          })
      })
    end
     end 
    self_methods = List.fold_right((function(param, rem) do
            kind = param[1];
            lab = param[0];
            if (lab == dummy_method) then do
              match = field_kind_repr(kind);
              if (typeof match == "number") then do
                return rem;
              end else do
                set_kind(match[0], --[[ Fabsent ]]1);
                return rem;
              end end 
            end else do
              desc_001 = copy_kind(kind);
              desc_002 = param[2];
              desc = --[[ Tfield ]]Block.__(5, {
                  lab,
                  desc_001,
                  desc_002,
                  rem
                });
              return newty2(current_level.contents, desc);
            end end 
          end end), methods, newty2(current_level.contents, --[[ Tnil ]]0));
    xpcall(function() do
      unify_2(val_env_1, private_self, newty2(current_level.contents, --[[ Tobject ]]Block.__(4, {
                  self_methods,
                  do
                    contents: undefined
                  end
                })));
      unify_2(val_env_1, public_self, self_type);
    end end,function(raw_exn_1) do
      exn_1 = Caml_js_exceptions.internalToOCamlException(raw_exn_1);
      if (exn_1[0] == Unify) then do
        error({
          __Error_9,
          loc,
          val_env_1,
          --[[ Final_self_clash ]]Block.__(21, {exn_1[1]})
        })
      end
       end 
      error(exn_1)
    end end)
  end
   end 
  if (principal.contents) then do
    List.iter((function(param) do
            return generalize_spine(param[2]);
          end end), methods);
  end
   end 
  fields = List.map(CamlinternalLazy.force, List.rev(match_1[3]));
  if (principal.contents) then do
    List.iter((function(param) do
            return unify_2(val_env_1, param[2], newvar(undefined, --[[ () ]]0));
          end end), methods);
  end
   end 
  meths_1 = map((function(param) do
          return param[0];
        end end), meths.contents);
  pub_meths$prime = List.filter((function(param) do
            return field_kind_repr(param[1]) == --[[ Fpresent ]]0;
          end end))(get_methods(public_self));
  names = function(param) do
    return List.map((function(param) do
                  return param[0];
                end end), param);
  end end;
  l1 = names(priv_meths);
  l2 = names(pub_meths$prime);
  added = List.filter((function(x) do
            return List.mem(x, l1);
          end end))(l2);
  if (added ~= --[[ [] ]]0) then do
    prerr_warning(loc, --[[ Implicit_public_methods ]]Block.__(6, {added}));
  end
   end 
  sign_1 = __final and sign or (do
        csig_self: expand_head(val_env_1, public_self),
        csig_vars: sign_csig_vars,
        csig_concr: concr_meths,
        csig_inher: inher
      end);
  return --[[ tuple ]]{
          do
            cstr_self: pat,
            cstr_fields: fields,
            cstr_type: sign_1,
            cstr_meths: meths_1
          end,
          sign_1
        };
end end

function class_expr(cl_num, val_env, met_env, _scl) do
  while(true) do
    scl = _scl;
    match = scl.pcl_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 0--[[ Pcl_constr ]] then do
          lid = match[0];
          match_1 = find_class_1(val_env, scl.pcl_loc, lid.txt);
          decl = match_1[1];
          path = match_1[0];
          if (same(decl.cty_path, unbound_class)) then do
            error({
              __Error_9,
              scl.pcl_loc,
              val_env,
              --[[ Unbound_class_2 ]]Block.__(6, {lid.txt})
            })
          end
           end 
          tyl = List.map((function(sty) do
                  return transl_simple_type(val_env, false, sty);
                end end), match[1]);
          match_2 = instance_class(decl.cty_params, decl.cty_type);
          clty = match_2[1];
          params = match_2[0];
          clty$prime = abbreviate_class_type(path, params, clty);
          if (List.length(params) ~= List.length(tyl)) then do
            error({
              __Error_9,
              scl.pcl_loc,
              val_env,
              --[[ Parameter_arity_mismatch ]]Block.__(11, {
                  lid.txt,
                  List.length(params),
                  List.length(tyl)
                })
            })
          end
           end 
          List.iter2((function(cty$prime, ty) do
                  ty$prime = cty$prime.ctyp_type;
                  xpcall(function() do
                    return unify_2(val_env, ty$prime, ty);
                  end end,function(raw_exn) do
                    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn[0] == Unify) then do
                      error({
                        __Error_9,
                        cty$prime.ctyp_loc,
                        val_env,
                        --[[ Parameter_mismatch ]]Block.__(12, {exn[1]})
                      })
                    end
                     end 
                    error(exn)
                  end end)
                end end), tyl, params);
          cl = rc(do
                cl_desc: --[[ Tcl_ident ]]Block.__(0, {
                    path,
                    lid,
                    tyl
                  }),
                cl_loc: scl.pcl_loc,
                cl_type: clty$prime,
                cl_env: val_env,
                cl_attributes: scl.pcl_attributes
              end);
          match_3 = extract_constraints(clty);
          return rc(do
                      cl_desc: --[[ Tcl_constraint ]]Block.__(5, {
                          cl,
                          undefined,
                          match_3[0],
                          match_3[1],
                          match_3[2]
                        }),
                      cl_loc: scl.pcl_loc,
                      cl_type: clty$prime,
                      cl_env: val_env,
                      cl_attributes: --[[ [] ]]0
                    end); end end 
       if ___conditional___ == 1--[[ Pcl_structure ]] then do
          match_4 = class_structure(cl_num, false, val_env, met_env, scl.pcl_loc, match[0]);
          return rc(do
                      cl_desc: --[[ Tcl_structure ]]Block.__(1, {match_4[0]}),
                      cl_loc: scl.pcl_loc,
                      cl_type: --[[ Cty_signature ]]Block.__(1, {match_4[1]}),
                      cl_env: val_env,
                      cl_attributes: scl.pcl_attributes
                    end); end end 
       if ___conditional___ == 2--[[ Pcl_fun ]] then do
          match_5 = match[1];
          l = match[0];
          if (match_5 ~= undefined) then do
            __default = match_5;
            loc = __default.pexp_loc;
            scases_000 = Curry._3(Ast_helper_Exp.__case, construct(loc, undefined, do
                      txt: --[[ Ldot ]]Block.__(1, {
                          --[[ Lident ]]Block.__(0, {"*predef*"}),
                          "Some"
                        }),
                      loc: none
                    end, __var_1(loc, undefined, do
                          txt: "*sth*",
                          loc: none
                        end)), undefined, Curry._3(Ast_helper_Exp.ident, loc, undefined, do
                      txt: --[[ Lident ]]Block.__(0, {"*sth*"}),
                      loc: none
                    end));
            scases_001 = --[[ :: ]]{
              Curry._3(Ast_helper_Exp.__case, construct(loc, undefined, do
                        txt: --[[ Ldot ]]Block.__(1, {
                            --[[ Lident ]]Block.__(0, {"*predef*"}),
                            "None"
                          }),
                        loc: none
                      end, undefined), undefined, __default),
              --[[ [] ]]0
            };
            scases = --[[ :: ]]{
              scases_000,
              scases_001
            };
            smatch = Curry._4(Ast_helper_Exp.match_, loc, undefined, Curry._3(Ast_helper_Exp.ident, loc, undefined, do
                      txt: --[[ Lident ]]Block.__(0, {"*opt*"}),
                      loc: none
                    end), scases);
            sfun = fun__1(scl.pcl_loc, undefined, l, undefined, __var_1(loc, undefined, do
                      txt: "*opt*",
                      loc: none
                    end), let__1(scl.pcl_loc, undefined, --[[ Nonrecursive ]]0, --[[ :: ]]{
                      mk_17(undefined, undefined, undefined, undefined, match[2], smatch),
                      --[[ [] ]]0
                    }, match[3]));
            _scl = sfun;
            ::continue:: ;
          end else do
            if (principal.contents) then do
              begin_def(--[[ () ]]0);
            end
             end 
            match_6 = type_class_arg_pattern(cl_num, val_env, met_env, l, match[2]);
            val_env$prime = match_6[2];
            pat = match_6[0];
            if (principal.contents) then do
              end_def(--[[ () ]]0);
              iter_pattern((function(param) do
                      return generalize_structure_1(current_level.contents, param.pat_type);
                    end end), pat);
            end
             end 
            pv = List.map((function(val_env$prime)do
                return function (param) do
                  id = param[0];
                  path = --[[ Pident ]]Block.__(0, {param[2]});
                  vd = find_value(path, val_env$prime);
                  return --[[ tuple ]]{
                          id,
                          param[1],
                          do
                            exp_desc: --[[ Texp_ident ]]Block.__(0, {
                                path,
                                do
                                  txt: --[[ Lident ]]Block.__(0, {id.name}),
                                  loc: none
                                end,
                                vd
                              }),
                            exp_loc: none,
                            exp_extra: --[[ [] ]]0,
                            exp_type: instance(undefined, val_env$prime, vd.val_type),
                            exp_env: val_env$prime,
                            exp_attributes: --[[ [] ]]0
                          end
                        };
                end end
                end end)(val_env$prime), match_6[1]);
            not_function = function(param) do
              local ___conditional___=(param.tag | 0);
              do
                 if ___conditional___ == 0--[[ Cty_constr ]]
                 or ___conditional___ == 1--[[ Cty_signature ]] then do
                    return true; end end 
                 if ___conditional___ == 2--[[ Cty_arrow ]] then do
                    return false; end end 
                
              end
            end end;
            partial = check_partial_1(undefined, val_env, pat.pat_type)(pat.pat_loc, --[[ :: ]]{
                  do
                    c_lhs: pat,
                    c_guard: undefined,
                    c_rhs: do
                      exp_desc: --[[ Texp_constant ]]Block.__(1, {--[[ Const_int ]]Block.__(0, {1})}),
                      exp_loc: none,
                      exp_extra: --[[ [] ]]0,
                      exp_type: none_2,
                      exp_env: empty,
                      exp_attributes: --[[ [] ]]0
                    end
                  end,
                  --[[ [] ]]0
                });
            raise_nongen_level(--[[ () ]]0);
            cl_1 = class_expr(cl_num, val_env$prime, match_6[3], match[3]);
            end_def(--[[ () ]]0);
            if (is_optional(l) and not_function(cl_1.cl_type)) then do
              prerr_warning(pat.pat_loc, --[[ Unerasable_optional_argument ]]8);
            end
             end 
            return rc(do
                        cl_desc: --[[ Tcl_fun ]]Block.__(2, {
                            l,
                            pat,
                            pv,
                            cl_1,
                            partial
                          }),
                        cl_loc: scl.pcl_loc,
                        cl_type: --[[ Cty_arrow ]]Block.__(2, {
                            l,
                            instance_def(pat.pat_type),
                            cl_1.cl_type
                          }),
                        cl_env: val_env,
                        cl_attributes: scl.pcl_attributes
                      end);
          end end  end end 
       if ___conditional___ == 3--[[ Pcl_apply ]] then do
          sargs = match[1];
          if (sargs == --[[ [] ]]0) then do
            ill_formed_ast(scl.pcl_loc, "Function application with no argument.");
          end
           end 
          if (principal.contents) then do
            begin_def(--[[ () ]]0);
          end
           end 
          cl_2 = class_expr(cl_num, val_env, met_env, match[0]);
          if (principal.contents) then do
            end_def(--[[ () ]]0);
            ((function(param) do
                    return generalize_class_type(generalize_structure_2, param);
                  end end)(cl_2.cl_type));
          end
           end 
          nonopt_labels = function(_ls, _ty_fun) do
            while(true) do
              ty_fun = _ty_fun;
              ls = _ls;
              local ___conditional___=(ty_fun.tag | 0);
              do
                 if ___conditional___ == 0--[[ Cty_constr ]]
                 or ___conditional___ == 1--[[ Cty_signature ]] then do
                    return ls; end end 
                 if ___conditional___ == 2--[[ Cty_arrow ]] then do
                    ty_res = ty_fun[2];
                    l = ty_fun[0];
                    if (is_optional(l)) then do
                      _ty_fun = ty_res;
                      ::continue:: ;
                    end else do
                      _ty_fun = ty_res;
                      _ls = --[[ :: ]]{
                        l,
                        ls
                      };
                      ::continue:: ;
                    end end  end end 
                
              end
            end;
          end end;
          ignore_labels = true;
          if (not classic.contents) then do
            labels = nonopt_labels(--[[ [] ]]0, cl_2.cl_type);
            ignore_labels = List.length(labels) == List.length(sargs) and List.for_all((function(param) do
                    return param[0] == "";
                  end end), sargs) and List.exists((function(l) do
                    return l ~= "";
                  end end), labels) and (prerr_warning(cl_2.cl_loc, --[[ Labels_omitted ]]3), true);
          end
           end 
          type_args = (function(cl_2,ignore_labels)do
          return function type_args(_args, _omitted, _ty_fun, _ty_fun0, _sargs, _more_sargs) do
            while(true) do
              more_sargs = _more_sargs;
              sargs = _sargs;
              ty_fun0 = _ty_fun0;
              ty_fun = _ty_fun;
              omitted = _omitted;
              args = _args;
              local ___conditional___=(ty_fun.tag | 0);
              do
                 if ___conditional___ == 0--[[ Cty_constr ]]
                 or ___conditional___ == 1--[[ Cty_signature ]]
                 or ___conditional___ == 2--[[ Cty_arrow ]] then do
                    ty = ty_fun[1];
                    l = ty_fun[0];
                    local ___conditional___=(ty_fun0.tag | 0);
                    do
                       if ___conditional___ == 0--[[ Cty_constr ]]
                       or ___conditional___ == 1--[[ Cty_signature ]]
                       or ___conditional___ == 2--[[ Cty_arrow ]] then do
                          if (sargs ~= --[[ [] ]]0 or more_sargs ~= --[[ [] ]]0) then do
                            ty0 = ty_fun0[1];
                            name = label_name(l);
                            optional = is_optional(l) and --[[ Optional ]]1 or --[[ Required ]]0;
                            match;
                            if (ignore_labels and not is_optional(l)) then do
                              if (sargs) then do
                                match_1 = sargs[0];
                                error({
                                  __Error_9,
                                  match_1[1].pexp_loc,
                                  val_env,
                                  --[[ Apply_wrong_label ]]Block.__(4, {match_1[0]})
                                })
                              end else if (more_sargs) then do
                                match_2 = more_sargs[0];
                                sarg0 = match_2[1];
                                l$prime = match_2[0];
                                if (l ~= l$prime and l$prime ~= "") then do
                                  error({
                                    __Error_9,
                                    sarg0.pexp_loc,
                                    val_env,
                                    --[[ Apply_wrong_label ]]Block.__(4, {l$prime})
                                  })
                                end
                                 end 
                                match = --[[ tuple ]]{
                                  --[[ [] ]]0,
                                  more_sargs[1],
                                  type_argument(val_env, sarg0, ty, ty0)
                                };
                              end else do
                                error({
                                  Caml_builtin_exceptions.assert_failure,
                                  --[[ tuple ]]{
                                    "typeclass.ml",
                                    1017,
                                    20
                                  }
                                })
                              end end  end 
                            end else do
                              xpcall(function() do
                                match_3;
                                xpcall(function() do
                                  match_4 = extract_label_aux(--[[ [] ]]0, name, sargs);
                                  match_3 = --[[ tuple ]]{
                                    match_4[0],
                                    match_4[1],
                                    Pervasives.$at(match_4[2], match_4[3]),
                                    more_sargs
                                  };
                                end end,function(exn) do
                                  if (exn == Caml_builtin_exceptions.not_found) then do
                                    match_5 = extract_label_aux(--[[ [] ]]0, name, more_sargs);
                                    match_3 = --[[ tuple ]]{
                                      match_5[0],
                                      match_5[1],
                                      Pervasives.$at(sargs, match_5[2]),
                                      match_5[3]
                                    };
                                  end else do
                                    error(exn)
                                  end end 
                                end end)
                                sarg0_1 = match_3[1];
                                l$prime_1 = match_3[0];
                                if (optional == --[[ Required ]]0 and is_optional(l$prime_1)) then do
                                  prerr_warning(sarg0_1.pexp_loc, --[[ Nonoptional_label ]]Block.__(26, {l}));
                                end
                                 end 
                                tmp;
                                if (optional == --[[ Required ]]0 or is_optional(l$prime_1)) then do
                                  tmp = type_argument(val_env, sarg0_1, ty, ty0);
                                end else do
                                  ty$prime = extract_option_type(val_env, ty);
                                  ty0$prime = extract_option_type(val_env, ty0);
                                  arg = type_argument(val_env, sarg0_1, ty$prime, ty0$prime);
                                  tmp = option_some(arg);
                                end end 
                                match = --[[ tuple ]]{
                                  match_3[2],
                                  match_3[3],
                                  tmp
                                };
                              end end,function(exn_1) do
                                if (exn_1 == Caml_builtin_exceptions.not_found) then do
                                  match = --[[ tuple ]]{
                                    sargs,
                                    more_sargs,
                                    is_optional(l) and (List.mem_assoc("", sargs) or List.mem_assoc("", more_sargs)) and option_none(ty0, none) or undefined
                                  };
                                end else do
                                  error(exn_1)
                                end end 
                              end end)
                            end end 
                            arg_1 = match[2];
                            omitted_1 = arg_1 == undefined and --[[ :: ]]{
                                --[[ tuple ]]{
                                  l,
                                  ty0
                                },
                                omitted
                              } or omitted;
                            _more_sargs = match[1];
                            _sargs = match[0];
                            _ty_fun0 = ty_fun0[2];
                            _ty_fun = ty_fun[2];
                            _omitted = omitted_1;
                            _args = --[[ :: ]]{
                              --[[ tuple ]]{
                                l,
                                arg_1,
                                optional
                              },
                              args
                            };
                            ::continue:: ;
                          end
                           end  end else 
                       end end
                      
                    end end else 
                 end end
                
              end
              match_6 = Pervasives.$at(sargs, more_sargs);
              if (match_6) then do
                if (omitted ~= --[[ [] ]]0) then do
                  match_7 = match_6[0];
                  error({
                    __Error_9,
                    match_7[1].pexp_loc,
                    val_env,
                    --[[ Apply_wrong_label ]]Block.__(4, {match_7[0]})
                  })
                end else do
                  error({
                    __Error_9,
                    cl_2.cl_loc,
                    val_env,
                    --[[ Cannot_apply ]]Block.__(3, {cl_2.cl_type})
                  })
                end end 
              end else do
                return --[[ tuple ]]{
                        List.rev(args),
                        List.fold_left((function(ty_fun, param) do
                                return --[[ Cty_arrow ]]Block.__(2, {
                                          param[0],
                                          param[1],
                                          ty_fun
                                        });
                              end end), ty_fun0, omitted)
                      };
              end end 
            end;
          end end
          end end)(cl_2,ignore_labels);
          match_7 = instance_class(--[[ [] ]]0, cl_2.cl_type);
          ty_fun0 = match_7[1];
          match_8 = ignore_labels and type_args(--[[ [] ]]0, --[[ [] ]]0, cl_2.cl_type, ty_fun0, --[[ [] ]]0, sargs) or type_args(--[[ [] ]]0, --[[ [] ]]0, cl_2.cl_type, ty_fun0, sargs, --[[ [] ]]0);
          return rc(do
                      cl_desc: --[[ Tcl_apply ]]Block.__(3, {
                          cl_2,
                          match_8[0]
                        }),
                      cl_loc: scl.pcl_loc,
                      cl_type: match_8[1],
                      cl_env: val_env,
                      cl_attributes: scl.pcl_attributes
                    end); end end 
       if ___conditional___ == 4--[[ Pcl_let ]] then do
          rec_flag = match[0];
          match_9;
          xpcall(function() do
            match_9 = type_let_1(val_env, rec_flag, match[1], undefined);
          end end,function(raw_exn) do
            exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn[0] == Unify) then do
              match_10 = exn[1];
              if (match_10) then do
                if (match_10[1]) then do
                  error(exn)
                end
                 end 
                error({
                  __Error_9,
                  scl.pcl_loc,
                  val_env,
                  --[[ Make_nongen_seltype ]]Block.__(17, {match_10[0][0]})
                })
              end else do
                error(exn)
              end end 
            end else do
              error(exn)
            end end 
          end end)
          val_env_1 = match_9[1];
          defs = match_9[0];
          match_11 = List.fold_right((function(val_env_1)do
              return function (param, param_1) do
                id = param[0];
                path = --[[ Pident ]]Block.__(0, {id});
                vd = find_value(path, val_env_1);
                begin_def(--[[ () ]]0);
                expr_exp_desc = --[[ Texp_ident ]]Block.__(0, {
                    path,
                    do
                      txt: --[[ Lident ]]Block.__(0, {id.name}),
                      loc: none
                    end,
                    vd
                  });
                expr_exp_type = instance(undefined, val_env_1, vd.val_type);
                expr = do
                  exp_desc: expr_exp_desc,
                  exp_loc: none,
                  exp_extra: --[[ [] ]]0,
                  exp_type: expr_exp_type,
                  exp_env: val_env_1,
                  exp_attributes: --[[ [] ]]0
                end;
                end_def(--[[ () ]]0);
                iter_generalize_1(do
                      contents: --[[ [] ]]0
                    end, expr_exp_type);
                desc_val_type = expr_exp_type;
                desc_val_kind = --[[ Val_ivar ]]Block.__(1, {
                    --[[ Immutable ]]0,
                    cl_num
                  });
                desc_val_loc = vd.val_loc;
                desc = do
                  val_type: desc_val_type,
                  val_kind: desc_val_kind,
                  val_loc: desc_val_loc,
                  val_attributes: --[[ [] ]]0
                end;
                id$prime = create(id.name);
                return --[[ tuple ]]{
                        --[[ :: ]]{
                          --[[ tuple ]]{
                            id$prime,
                            param[1],
                            expr
                          },
                          param_1[0]
                        },
                        add_value(undefined, id$prime, desc, param_1[1])
                      };
              end end
              end end)(val_env_1), List.rev(rev_let_bound_idents_with_loc(defs)), --[[ tuple ]]{
                --[[ [] ]]0,
                met_env
              });
          cl_3 = class_expr(cl_num, val_env_1, match_11[1], match[2]);
          return rc(do
                      cl_desc: --[[ Tcl_let ]]Block.__(4, {
                          rec_flag,
                          defs,
                          match_11[0],
                          cl_3
                        }),
                      cl_loc: scl.pcl_loc,
                      cl_type: cl_3.cl_type,
                      cl_env: val_env_1,
                      cl_attributes: scl.pcl_attributes
                    end); end end 
       if ___conditional___ == 5--[[ Pcl_constraint ]] then do
          begin_class_def(--[[ () ]]0);
          context = narrow(--[[ () ]]0);
          cl_4 = class_expr(cl_num, val_env, met_env, match[0]);
          widen(context);
          context_1 = narrow(--[[ () ]]0);
          clty_1 = class_type_4(val_env, match[1]);
          widen(context_1);
          end_def(--[[ () ]]0);
          limited_generalize_1(row_variable(repr(signature_of_class_type(cl_4.cl_type).csig_self)), cl_4.cl_type);
          limited_generalize_1(row_variable(repr(signature_of_class_type(clty_1.cltyp_type).csig_self)), clty_1.cltyp_type);
          error = class_types(val_env, cl_4.cl_type, clty_1.cltyp_type);
          if (error) then do
            error({
              __Error_9,
              cl_4.cl_loc,
              val_env,
              --[[ Class_match_failure ]]Block.__(14, {error})
            })
          end
           end 
          match_12 = extract_constraints(clty_1.cltyp_type);
          return rc(do
                      cl_desc: --[[ Tcl_constraint ]]Block.__(5, {
                          cl_4,
                          clty_1,
                          match_12[0],
                          match_12[1],
                          match_12[2]
                        }),
                      cl_loc: scl.pcl_loc,
                      cl_type: instance_class(--[[ [] ]]0, clty_1.cltyp_type)[1],
                      cl_env: val_env,
                      cl_attributes: scl.pcl_attributes
                    end); end end 
       if ___conditional___ == 6--[[ Pcl_extension ]] then do
          error({
            Error_forward_2,
            error_of_extension(match[0])
          }) end end 
      
    end
  end;
end end

var_option = type_option(newty2(100000000, --[[ Tvar ]]Block.__(0, {undefined})));

function approx_declaration(_cl) do
  while(true) do
    cl = _cl;
    match = cl.pcl_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 2--[[ Pcl_fun ]] then do
          l = match[0];
          arg = is_optional(l) and instance_def(var_option) or newvar(undefined, --[[ () ]]0);
          desc_002 = approx_declaration(match[3]);
          desc = --[[ Tarrow ]]Block.__(1, {
              l,
              arg,
              desc_002,
              --[[ Cok ]]0
            });
          return newty2(current_level.contents, desc); end end 
       if ___conditional___ == 4--[[ Pcl_let ]] then do
          _cl = match[2];
          ::continue:: ; end end 
       if ___conditional___ == 5--[[ Pcl_constraint ]] then do
          _cl = match[0];
          ::continue:: ; end end 
      return newvar(undefined, --[[ () ]]0);
        
    end
  end;
end end

function approx_description(ct) do
  match = ct.pcty_desc;
  if (match.tag == --[[ Pcty_arrow ]]2) then do
    l = match[0];
    arg = is_optional(l) and instance_def(var_option) or newvar(undefined, --[[ () ]]0);
    desc_002 = approx_description(match[2]);
    desc = --[[ Tarrow ]]Block.__(1, {
        l,
        arg,
        desc_002,
        --[[ Cok ]]0
      });
    return newty2(current_level.contents, desc);
  end else do
    return newvar(undefined, --[[ () ]]0);
  end end 
end end

function temp_abbrev(loc, env, id, arity) do
  params = --[[ [] ]]0;
  for _i = 1 , arity , 1 do
    params = --[[ :: ]]{
      newvar(undefined, --[[ () ]]0),
      params
    };
  end
  ty = newobj(newvar(undefined, --[[ () ]]0));
  env_1 = add_type_1(true, id, do
        type_params: params,
        type_arity: arity,
        type_kind: --[[ Type_abstract ]]0,
        type_private: --[[ Public ]]1,
        type_manifest: ty,
        type_variance: replicate_list(Types_Variance.full, arity),
        type_newtype_level: undefined,
        type_loc: loc,
        type_attributes: --[[ [] ]]0
      end, env);
  return --[[ tuple ]]{
          params,
          ty,
          env_1
        };
end end

function extract_type_decls(param, decls) do
  return --[[ :: ]]{
          --[[ tuple ]]{
            param[5],
            param[6],
            param[8],
            param[2],
            param[4],
            param[13]
          },
          decls
        };
end end

function merge_type_decls(param, param_1) do
  return --[[ tuple ]]{
          param[0],
          param[1],
          param_1[2],
          param[3],
          param_1[3],
          param[5],
          param_1[0],
          param[7],
          param_1[1],
          param[9],
          param[10],
          param[11],
          param[12],
          param[13]
        };
end end

function type_classes(define_class, approx, kind, env, cls) do
  cls_1 = List.map((function(cl) do
          return --[[ tuple ]]{
                  cl,
                  create(cl.pci_name.txt),
                  create(cl.pci_name.txt),
                  create(cl.pci_name.txt),
                  create("#" .. cl.pci_name.txt)
                };
        end end), cls);
  init_def(currentstamp.contents);
  begin_class_def(--[[ () ]]0);
  match = List.fold_left((function(param, param_1) do
          define_class_1 = define_class;
          approx_1 = approx;
          param_2 = param;
          param_3 = param_1;
          cl_id = param_3[4];
          obj_id = param_3[3];
          ty_id = param_3[2];
          id = param_3[1];
          cl = param_3[0];
          arity = List.length(cl.pci_params);
          match = temp_abbrev(cl.pci_loc, param_2[1], obj_id, arity);
          match_1 = temp_abbrev(cl.pci_loc, match[2], cl_id, arity);
          env = match_1[2];
          constr_type = Curry._1(approx_1, cl.pci_expr);
          if (principal.contents) then do
            generalize_spine(constr_type);
          end
           end 
          dummy_cty = --[[ Cty_signature ]]Block.__(1, {do
                csig_self: newvar(undefined, --[[ () ]]0),
                csig_vars: --[[ Empty ]]0,
                csig_concr: --[[ Empty ]]0,
                csig_inher: --[[ [] ]]0
              end});
          match_2 = cl.pci_virt;
          dummy_class = do
            cty_params: --[[ [] ]]0,
            cty_type: dummy_cty,
            cty_path: unbound_class,
            cty_new: match_2 and constr_type or undefined,
            cty_variance: --[[ [] ]]0,
            cty_loc: none,
            cty_attributes: --[[ [] ]]0
          end;
          env_1 = add_cltype(ty_id, do
                clty_params: --[[ [] ]]0,
                clty_type: dummy_cty,
                clty_path: unbound_class,
                clty_variance: --[[ [] ]]0,
                clty_loc: none,
                clty_attributes: --[[ [] ]]0
              end, define_class_1 and add_class(id, dummy_class, env) or env);
          return --[[ tuple ]]{
                  --[[ :: ]]{
                    --[[ tuple ]]{
                      cl,
                      id,
                      ty_id,
                      obj_id,
                      match[0],
                      match[1],
                      cl_id,
                      match_1[0],
                      match_1[1],
                      constr_type,
                      dummy_class
                    },
                    param_2[0]
                  },
                  env_1
                };
        end end), --[[ tuple ]]{
        --[[ [] ]]0,
        env
      }, cls_1);
  match_1 = List.fold_right((function(param, param_1) do
          define_class_1 = define_class;
          kind_1 = kind;
          param_2 = param;
          param_3 = param_1;
          env = param_3[1];
          constr_type = param_2[9];
          cl_ty = param_2[8];
          cl_params = param_2[7];
          cl_id = param_2[6];
          obj_ty = param_2[5];
          obj_params = param_2[4];
          obj_id = param_2[3];
          ty_id = param_2[2];
          id = param_2[1];
          cl = param_2[0];
          reset_type_variables(--[[ () ]]0);
          begin_class_def(--[[ () ]]0);
          make_param = function(param) do
            sty = param[0];
            xpcall(function() do
              return --[[ tuple ]]{
                      transl_type_param(env, sty),
                      param[1]
                    };
            end end,function(exn) do
              if (exn == Already_bound) then do
                error({
                  __Error_9,
                  sty.ptyp_loc,
                  env,
                  --[[ Repeated_parameter ]]0
                })
              end
               end 
              error(exn)
            end end)
          end end;
          ci_params = List.map(make_param, cl.pci_params);
          params = List.map((function(param) do
                  return param[0].ctyp_type;
                end end), ci_params);
          coercion_locs = do
            contents: --[[ [] ]]0
          end;
          match;
          xpcall(function() do
            self_coercion.contents = --[[ :: ]]{
              --[[ tuple ]]{
                --[[ Pident ]]Block.__(0, {obj_id}),
                coercion_locs
              },
              self_coercion.contents
            };
            res = Curry._2(kind_1, env, cl.pci_expr);
            self_coercion.contents = List.tl(self_coercion.contents);
            match = res;
          end end,function(exn) do
            self_coercion.contents = --[[ [] ]]0;
            error(exn)
          end end)
          typ = match[1];
          end_def(--[[ () ]]0);
          sty = repr(signature_of_class_type(typ).csig_self);
          match_1 = flatten_fields(object_fields(sty));
          List.iter((function(param) do
                  if (param[0] == dummy_method) then do
                    return iter_generalize_1(do
                                contents: --[[ [] ]]0
                              end, param[2]);
                  end else do
                    return 0;
                  end end 
                end end), match_1[0]);
          rv = row_variable(sty);
          List.iter((function(param) do
                  return limited_generalize(rv, param);
                end end), params);
          limited_generalize_1(rv, typ);
          match_2 = instance_class(params, typ);
          obj_type = match_2[1];
          obj_params$prime = match_2[0];
          constr = newconstr(--[[ Pident ]]Block.__(0, {obj_id}), obj_params);
          ty = repr(signature_of_class_type(obj_type).csig_self);
          hide_private_methods(ty);
          close_object(ty);
          xpcall(function() do
            List.iter2((function(param, param_1) do
                    return unify_2(env, param, param_1);
                  end end), obj_params, obj_params$prime);
          end end,function(raw_exn) do
            exn_1 = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn_1[0] == Unify) then do
              error({
                __Error_9,
                cl.pci_loc,
                env,
                --[[ Bad_parameters ]]Block.__(13, {
                    obj_id,
                    constr,
                    newconstr(--[[ Pident ]]Block.__(0, {obj_id}), obj_params$prime)
                  })
              })
            end
             end 
            error(exn_1)
          end end)
          xpcall(function() do
            unify_2(env, ty, constr);
          end end,function(raw_exn_1) do
            exn_2 = Caml_js_exceptions.internalToOCamlException(raw_exn_1);
            if (exn_2[0] == Unify) then do
              error({
                __Error_9,
                cl.pci_loc,
                env,
                --[[ Abbrev_type_clash ]]Block.__(8, {
                    constr,
                    ty,
                    expand_head(env, constr)
                  })
              })
            end
             end 
            error(exn_2)
          end end)
          match_3 = instance_class(params, typ);
          cl_params$prime = match_3[0];
          ty_1 = repr(signature_of_class_type(match_3[1]).csig_self);
          hide_private_methods(ty_1);
          set_object_name(obj_id, row_variable(ty_1), cl_params, ty_1);
          xpcall(function() do
            List.iter2((function(param, param_1) do
                    return unify_2(env, param, param_1);
                  end end), cl_params, cl_params$prime);
          end end,function(raw_exn_2) do
            exn_3 = Caml_js_exceptions.internalToOCamlException(raw_exn_2);
            if (exn_3[0] == Unify) then do
              error({
                __Error_9,
                cl.pci_loc,
                env,
                --[[ Bad_parameters ]]Block.__(13, {
                    cl_id,
                    newconstr(--[[ Pident ]]Block.__(0, {cl_id}), cl_params),
                    newconstr(--[[ Pident ]]Block.__(0, {cl_id}), cl_params$prime)
                  })
              })
            end
             end 
            error(exn_3)
          end end)
          xpcall(function() do
            unify_2(env, ty_1, cl_ty);
          end end,function(raw_exn_3) do
            exn_4 = Caml_js_exceptions.internalToOCamlException(raw_exn_3);
            if (exn_4[0] == Unify) then do
              constr_1 = newconstr(--[[ Pident ]]Block.__(0, {cl_id}), params);
              error({
                __Error_9,
                cl.pci_loc,
                env,
                --[[ Abbrev_type_clash ]]Block.__(8, {
                    constr_1,
                    ty_1,
                    cl_ty
                  })
              })
            end else do
              error(exn_4)
            end end 
          end end)
          xpcall(function() do
            unify_2(env, constructor_type(constr, obj_type), instance(undefined, env, constr_type));
          end end,function(raw_exn_4) do
            exn_5 = Caml_js_exceptions.internalToOCamlException(raw_exn_4);
            if (exn_5[0] == Unify) then do
              error({
                __Error_9,
                cl.pci_loc,
                env,
                --[[ Constructor_type_mismatch ]]Block.__(9, {
                    cl.pci_name.txt,
                    exn_5[1]
                  })
              })
            end
             end 
            error(exn_5)
          end end)
          cty_variance = List.map((function(param) do
                  return Types_Variance.full;
                end end), params);
          cltydef_clty_type = class_body(typ);
          cltydef_clty_path = --[[ Pident ]]Block.__(0, {obj_id});
          cltydef_clty_loc = cl.pci_loc;
          cltydef_clty_attributes = cl.pci_attributes;
          cltydef = do
            clty_params: params,
            clty_type: cltydef_clty_type,
            clty_path: cltydef_clty_path,
            clty_variance: cty_variance,
            clty_loc: cltydef_clty_loc,
            clty_attributes: cltydef_clty_attributes
          end;
          match_4 = cl.pci_virt;
          clty = do
            cty_params: params,
            cty_type: typ,
            cty_path: --[[ Pident ]]Block.__(0, {obj_id}),
            cty_new: match_4 and constr_type or undefined,
            cty_variance: cty_variance,
            cty_loc: cl.pci_loc,
            cty_attributes: cl.pci_attributes
          end;
          param_2[10].cty_type = typ;
          env_1 = add_cltype(ty_id, cltydef, define_class_1 and add_class(id, clty, env) or env);
          if (cl.pci_virt == --[[ Concrete ]]1) then do
            sign = signature_of_class_type(typ);
            mets = virtual_methods(sign);
            vals = fold((function(name, param, l) do
                    if (param[1] == --[[ Virtual ]]0) then do
                      return --[[ :: ]]{
                              name,
                              l
                            };
                    end else do
                      return l;
                    end end 
                  end end), sign.csig_vars, --[[ [] ]]0);
            if (mets ~= --[[ [] ]]0 or vals ~= --[[ [] ]]0) then do
              error({
                __Error_9,
                cl.pci_loc,
                env_1,
                --[[ Virtual_class ]]Block.__(10, {
                    define_class_1,
                    false,
                    mets,
                    vals
                  })
              })
            end
             end 
          end
           end 
          arity = class_type_arity(typ);
          match_5 = flatten_fields(object_fields(expand_head(env_1, obj_ty)));
          pub_meths = List.map((function(param) do
                  return param[0];
                end end), match_5[0]);
          match_6 = instance_class(params, typ);
          typ$prime = match_6[1];
          params$prime = match_6[0];
          cltydef_clty_type_1 = class_body(typ$prime);
          cltydef_clty_path_1 = --[[ Pident ]]Block.__(0, {obj_id});
          cltydef_clty_loc_1 = cl.pci_loc;
          cltydef_clty_attributes_1 = cl.pci_attributes;
          cltydef_1 = do
            clty_params: params$prime,
            clty_type: cltydef_clty_type_1,
            clty_path: cltydef_clty_path_1,
            clty_variance: cty_variance,
            clty_loc: cltydef_clty_loc_1,
            clty_attributes: cltydef_clty_attributes_1
          end;
          match_7 = cl.pci_virt;
          clty_1 = do
            cty_params: params$prime,
            cty_type: typ$prime,
            cty_path: --[[ Pident ]]Block.__(0, {obj_id}),
            cty_new: match_7 and instance(undefined, env_1, constr_type) or undefined,
            cty_variance: cty_variance,
            cty_loc: cl.pci_loc,
            cty_attributes: cl.pci_attributes
          end;
          obj_abbr_type_arity = List.length(obj_params);
          obj_abbr_type_manifest = obj_ty;
          obj_abbr_type_variance = List.map((function(param) do
                  return Types_Variance.full;
                end end), obj_params);
          obj_abbr_type_loc = cl.pci_loc;
          obj_abbr = do
            type_params: obj_params,
            type_arity: obj_abbr_type_arity,
            type_kind: --[[ Type_abstract ]]0,
            type_private: --[[ Public ]]1,
            type_manifest: obj_abbr_type_manifest,
            type_variance: obj_abbr_type_variance,
            type_newtype_level: undefined,
            type_loc: obj_abbr_type_loc,
            type_attributes: --[[ [] ]]0
          end;
          match_8 = instance_parameterized_type(undefined, params, repr(signature_of_class_type(typ).csig_self));
          cl_ty_1 = match_8[1];
          cl_params_1 = match_8[0];
          hide_private_methods(cl_ty_1);
          set_object_name(obj_id, row_variable(cl_ty_1), cl_params_1, cl_ty_1);
          cl_abbr_type_arity = List.length(cl_params_1);
          cl_abbr_type_manifest = cl_ty_1;
          cl_abbr_type_variance = List.map((function(param) do
                  return Types_Variance.full;
                end end), cl_params_1);
          cl_abbr_type_loc = cl.pci_loc;
          cl_abbr = do
            type_params: cl_params_1,
            type_arity: cl_abbr_type_arity,
            type_kind: --[[ Type_abstract ]]0,
            type_private: --[[ Public ]]1,
            type_manifest: cl_abbr_type_manifest,
            type_variance: cl_abbr_type_variance,
            type_newtype_level: undefined,
            type_loc: cl_abbr_type_loc,
            type_attributes: --[[ [] ]]0
          end;
          return --[[ tuple ]]{
                  --[[ :: ]]{
                    --[[ tuple ]]{
                      cl,
                      id,
                      clty_1,
                      ty_id,
                      cltydef_1,
                      obj_id,
                      obj_abbr,
                      cl_id,
                      cl_abbr,
                      ci_params,
                      arity,
                      pub_meths,
                      List.rev(coercion_locs.contents),
                      match[0]
                    },
                    param_3[0]
                  },
                  env_1
                };
        end end), match[0], --[[ tuple ]]{
        --[[ [] ]]0,
        match[1]
      });
  env_1 = match_1[1];
  end_def(--[[ () ]]0);
  res = List.rev_map((function(param) do
          env_2 = env_1;
          define_class_1 = define_class;
          param_1 = param;
          expr = param_1[13];
          cl_abbr = param_1[8];
          cl_id = param_1[7];
          obj_abbr = param_1[6];
          obj_id = param_1[5];
          cltydef = param_1[4];
          ty_id = param_1[3];
          clty = param_1[2];
          id = param_1[1];
          cl = param_1[0];
          xpcall(function() do
            collapse_conj_params(env_2, clty.cty_params);
          end end,function(raw_exn) do
            exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn[0] == Unify) then do
              error({
                __Error_9,
                cl.pci_loc,
                env_2,
                --[[ Non_collapsable_conjunction ]]Block.__(20, {
                    id,
                    clty,
                    exn[1]
                  })
              })
            end
             end 
            error(exn)
          end end)
          List.iter(generalize, clty.cty_params);
          ((function(param) do
                  return generalize_class_type(generalize, param);
                end end)(clty.cty_type));
          may(generalize, clty.cty_new);
          List.iter(generalize, obj_abbr.type_params);
          may(generalize, obj_abbr.type_manifest);
          List.iter(generalize, cl_abbr.type_params);
          may(generalize, cl_abbr.type_manifest);
          if (not closed_class_1(clty)) then do
            error({
              __Error_9,
              cl.pci_loc,
              env_2,
              --[[ Non_generalizable_class ]]Block.__(18, {
                  id,
                  clty
                })
            })
          end
           end 
          match = closed_class(clty.cty_params, signature_of_class_type(clty.cty_type));
          if (match ~= undefined) then do
            printer = define_class_1 and (function(ppf) do
                  return class_declaration_1(id, ppf, clty);
                end end) or (function(ppf) do
                  return cltype_declaration_1(id, ppf, cltydef);
                end end);
            error({
              __Error_9,
              cl.pci_loc,
              env_2,
              --[[ Unbound_type_var ]]Block.__(16, {
                  printer,
                  match
                })
            })
          end
           end 
          return --[[ tuple ]]{
                  id,
                  cl.pci_name,
                  clty,
                  ty_id,
                  cltydef,
                  obj_id,
                  obj_abbr,
                  cl_id,
                  cl_abbr,
                  param_1[10],
                  param_1[11],
                  param_1[12],
                  expr,
                  do
                    ci_virt: cl.pci_virt,
                    ci_params: param_1[9],
                    ci_id_name: cl.pci_name,
                    ci_id_class: id,
                    ci_id_class_type: ty_id,
                    ci_id_object: obj_id,
                    ci_id_typesharp: cl_id,
                    ci_expr: expr,
                    ci_decl: clty,
                    ci_type_decl: cltydef,
                    ci_loc: cl.pci_loc,
                    ci_attributes: cl.pci_attributes
                  end
                };
        end end), match_1[0]);
  decls = List.fold_right(extract_type_decls, res, --[[ [] ]]0);
  decls_1 = compute_variance_decls(env_1, decls);
  res_1 = List.map2(merge_type_decls, res, decls_1);
  env_2 = List.fold_left((function(param, param_1) do
          define_class_1 = define_class;
          env = param;
          param_2 = param_1;
          return add_type_1(true, param_2[5], type_declaration(identity, param_2[6]), add_type_1(true, param_2[7], type_declaration(identity, param_2[8]), add_cltype(param_2[3], cltype_declaration(identity, param_2[4]), define_class_1 and add_class(param_2[0], class_declaration(identity, param_2[2]), env) or env)));
        end end), env_1, res_1);
  res_2 = List.map((function(param) do
          env_3 = env_2;
          param_1 = param;
          coercion_locs = param_1[11];
          cl_abbr = param_1[8];
          obj_abbr = param_1[6];
          if (coercion_locs) then do
            loc = coercion_locs[0];
            match = cl_abbr.type_manifest;
            match_1 = obj_abbr.type_manifest;
            match_2;
            if (match ~= undefined) then do
              if (match_1 ~= undefined) then do
                match_3 = instance_parameterized_type(undefined, cl_abbr.type_params, match);
                match_4 = instance_parameterized_type(undefined, obj_abbr.type_params, match_1);
                List.iter2((function(param, param_1) do
                        return unify_2(env_3, param, param_1);
                      end end), match_3[0], match_4[0]);
                match_2 = --[[ tuple ]]{
                  match_3[1],
                  match_4[1]
                };
              end else do
                error({
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "typeclass.ml",
                    1562,
                    15
                  }
                })
              end end 
            end else do
              error({
                Caml_builtin_exceptions.assert_failure,
                --[[ tuple ]]{
                  "typeclass.ml",
                  1562,
                  15
                }
              })
            end end 
            obj_ty = match_2[1];
            cl_ty = match_2[0];
            xpcall(function() do
              subtype(env_3, cl_ty, obj_ty)(--[[ () ]]0);
            end end,function(raw_exn) do
              exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn[0] == Subtype) then do
                error({
                  __Error_7,
                  loc,
                  env_3,
                  --[[ Not_subtype ]]Block.__(23, {
                      exn[1],
                      exn[2]
                    })
                })
              end
               end 
              error(exn)
            end end)
            if (not opened_object(cl_ty)) then do
              error({
                __Error_9,
                loc,
                env_3,
                --[[ Cannot_coerce_self ]]Block.__(19, {obj_ty})
              })
            end
             end 
          end
           end 
          return --[[ tuple ]]{
                  param_1[0],
                  param_1[1],
                  param_1[2],
                  param_1[3],
                  param_1[4],
                  param_1[5],
                  obj_abbr,
                  param_1[7],
                  cl_abbr,
                  param_1[9],
                  param_1[10],
                  param_1[13]
                };
        end end), res_1);
  return --[[ tuple ]]{
          res_2,
          env_2
        };
end end

class_num = do
  contents: 0
end;

function class_declaration_2(env, sexpr) do
  class_num.contents = class_num.contents + 1 | 0;
  expr = class_expr(String(class_num.contents), env, env, sexpr);
  return --[[ tuple ]]{
          expr,
          expr.cl_type
        };
end end

function class_description(env, sexpr) do
  expr = class_type_4(env, sexpr);
  return --[[ tuple ]]{
          expr,
          expr.cltyp_type
        };
end end

function class_declarations_2(env, cls) do
  return type_classes(true, approx_declaration, class_declaration_2, env, cls);
end end

function class_descriptions(env, cls) do
  return type_classes(true, approx_description, class_description, env, cls);
end end

function class_type_declarations_2(env, cls) do
  match = type_classes(false, approx_description, class_description, env, cls);
  return --[[ tuple ]]{
          List.map((function(param) do
                  return --[[ tuple ]]{
                          param[3],
                          param[1],
                          param[4],
                          param[5],
                          param[6],
                          param[7],
                          param[8],
                          param[11]
                        };
                end end), match[0]),
          match[1]
        };
end end

function unify_parents_struct(env, ty, st) do
  return List.iter((function(param) do
                match = param.cf_desc;
                if (match.tag) then do
                  return --[[ () ]]0;
                end else do
                  env_1 = env;
                  ty_1 = ty;
                  _cl = match[1];
                  while(true) do
                    cl = _cl;
                    match_1 = cl.cl_desc;
                    local ___conditional___=(match_1.tag | 0);
                    do
                       if ___conditional___ == 0--[[ Tcl_ident ]] then do
                          xpcall(function() do
                            decl = find_class(match_1[0], env_1);
                            match_2 = find_cltype_for_path(env_1, decl.cty_path);
                            return unify_2(env_1, ty_1, instance(undefined, env_1, match_2[1]));
                          end end,function(exn) do
                            if (exn == Caml_builtin_exceptions.not_found) then do
                              return --[[ () ]]0;
                            end else do
                              error({
                                Caml_builtin_exceptions.assert_failure,
                                --[[ tuple ]]{
                                  "typeclass.ml",
                                  1639,
                                  15
                                }
                              })
                            end end 
                          end end) end end 
                       if ___conditional___ == 1--[[ Tcl_structure ]] then do
                          return unify_parents_struct(env_1, ty_1, match_1[0]); end end 
                       if ___conditional___ == 2--[[ Tcl_fun ]]
                       or ___conditional___ == 4--[[ Tcl_let ]] then do
                          _cl = match_1[3];
                          ::continue:: ; end end 
                       if ___conditional___ == 3--[[ Tcl_apply ]]
                       or ___conditional___ == 5--[[ Tcl_constraint ]] then do
                          _cl = match_1[0];
                          ::continue:: ; end end 
                      
                    end
                  end;
                end end 
              end end), st.cstr_fields);
end end

function type_object_1(env, loc, s) do
  class_num.contents = class_num.contents + 1 | 0;
  match = class_structure(String(class_num.contents), true, env, env, loc, s);
  sign = match[1];
  desc = match[0];
  sty = expand_head(env, sign.csig_self);
  hide_private_methods(sty);
  match_1 = flatten_fields(object_fields(sty));
  meths = List.map((function(param) do
          return param[0];
        end end), match_1[0]);
  unify_parents_struct(env, sign.csig_self, desc);
  return --[[ tuple ]]{
          desc,
          sign,
          meths
        };
end end

type_object.contents = type_object_1;

function approx_class(sdecl) do
  self$prime = mk(undefined, undefined, --[[ Ptyp_any ]]0);
  clty$prime = signature_1(sdecl.pci_expr.pcty_loc, undefined, do
        pcsig_self: self$prime,
        pcsig_fields: --[[ [] ]]0
      end);
  return do
          pci_virt: sdecl.pci_virt,
          pci_params: sdecl.pci_params,
          pci_name: sdecl.pci_name,
          pci_expr: clty$prime,
          pci_loc: sdecl.pci_loc,
          pci_attributes: sdecl.pci_attributes
        end;
end end

function approx_class_declarations(env, sdecls) do
  return class_type_declarations_2(env, List.map(approx_class, sdecls))[0];
end end

register_error_of_exn((function(param) do
        if (param[0] == __Error_9) then do
          env = param[2];
          return error_of_printer(param[1], (function(param, param_1) do
                        env_1 = env;
                        ppf = param;
                        err = param_1;
                        return wrap_printing_env(env_1, (function(param) do
                                      env_2 = env_1;
                                      ppf_1 = ppf;
                                      param_1 = err;
                                      if (typeof param_1 == "number") then do
                                        return Format.fprintf(ppf_1, --[[ Format ]]{
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "A type parameter occurs several times",
                                                        --[[ End_of_format ]]0
                                                      }),
                                                    "A type parameter occurs several times"
                                                  });
                                      end else do
                                        local ___conditional___=(param_1.tag | 0);
                                        do
                                           if ___conditional___ == 0--[[ Unconsistent_constraint ]] then do
                                              Format.fprintf(ppf_1, --[[ Format ]]{
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "The class constraints are not consistent.",
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Flush_newline ]]4,
                                                            --[[ End_of_format ]]0
                                                          })
                                                      }),
                                                    "The class constraints are not consistent.@."
                                                  });
                                              return report_unification_error(ppf_1, env_2, undefined, param_1[0], (function(ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "Type",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "Type"
                                                                      });
                                                          end end), (function(ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "is not compatible with type",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "is not compatible with type"
                                                                      });
                                                          end end)); end end 
                                           if ___conditional___ == 1--[[ Field_type_mismatch ]] then do
                                              m = param_1[1];
                                              k = param_1[0];
                                              return report_unification_error(ppf_1, env_2, undefined, param_1[2], (function(ppf) do
                                                            return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                                            --[[ String_literal ]]Block.__(11, {
                                                                                "The ",
                                                                                --[[ String ]]Block.__(2, {
                                                                                    --[[ No_padding ]]0,
                                                                                    --[[ Char_literal ]]Block.__(12, {
                                                                                        --[[ " " ]]32,
                                                                                        --[[ String ]]Block.__(2, {
                                                                                            --[[ No_padding ]]0,
                                                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                                                --[[ Break ]]Block.__(0, {
                                                                                                    "@ ",
                                                                                                    1,
                                                                                                    0
                                                                                                  }),
                                                                                                --[[ String_literal ]]Block.__(11, {
                                                                                                    "has type",
                                                                                                    --[[ End_of_format ]]0
                                                                                                  })
                                                                                              })
                                                                                          })
                                                                                      })
                                                                                  })
                                                                              }),
                                                                            "The %s %s@ has type"
                                                                          }), k, m);
                                                          end end), (function(ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "but is expected to have type",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "but is expected to have type"
                                                                      });
                                                          end end)); end end 
                                           if ___conditional___ == 2--[[ Structure_expected ]] then do
                                              return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "This class expression is not a class structure; it has type",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Close_box ]]0,
                                                                                  --[[ End_of_format ]]0
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[This class expression is not a class structure; it has type@ %a@]"
                                                            }), class_type_2, param_1[0]); end end 
                                           if ___conditional___ == 3--[[ Cannot_apply ]] then do
                                              return Format.fprintf(ppf_1, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "This class expression is not a class function, it cannot be applied",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "This class expression is not a class function, it cannot be applied"
                                                        }); end end 
                                           if ___conditional___ == 4--[[ Apply_wrong_label ]] then do
                                              mark_label = function(l) do
                                                if (l == "") then do
                                                  return "out label";
                                                end else do
                                                  return Curry._1(Format.sprintf(--[[ Format ]]{
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      " label ~",
                                                                      --[[ String ]]Block.__(2, {
                                                                          --[[ No_padding ]]0,
                                                                          --[[ End_of_format ]]0
                                                                        })
                                                                    }),
                                                                  " label ~%s"
                                                                }), l);
                                                end end 
                                              end end;
                                              return Curry._1(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "This argument cannot be applied with",
                                                                  --[[ String ]]Block.__(2, {
                                                                      --[[ No_padding ]]0,
                                                                      --[[ End_of_format ]]0
                                                                    })
                                                                }),
                                                              "This argument cannot be applied with%s"
                                                            }), mark_label(param_1[0])); end end 
                                           if ___conditional___ == 5--[[ Pattern_type_clash ]] then do
                                              ty = param_1[0];
                                              reset(--[[ () ]]0);
                                              mark_loops(ty);
                                              return Curry._3(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String ]]Block.__(2, {
                                                                      --[[ No_padding ]]0,
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Close_box ]]0,
                                                                                  --[[ End_of_format ]]0
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[%s@ %a@]"
                                                            }), "This pattern cannot match self: it only matches values of type", type_expr_1, ty); end end 
                                           if ___conditional___ == 6--[[ Unbound_class_2 ]] then do
                                              return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The class",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Break ]]Block.__(0, {
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    }),
                                                                                  --[[ String_literal ]]Block.__(11, {
                                                                                      "is not yet completely defined",
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Close_box ]]0,
                                                                                          --[[ End_of_format ]]0
                                                                                        })
                                                                                    })
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[The class@ %a@ is not yet completely defined@]"
                                                            }), longident, param_1[0]); end end 
                                           if ___conditional___ == 7--[[ Unbound_class_type_2 ]] then do
                                              return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The class type",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Break ]]Block.__(0, {
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    }),
                                                                                  --[[ String_literal ]]Block.__(11, {
                                                                                      "is not yet completely defined",
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Close_box ]]0,
                                                                                          --[[ End_of_format ]]0
                                                                                        })
                                                                                    })
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[The class type@ %a@ is not yet completely defined@]"
                                                            }), longident, param_1[0]); end end 
                                           if ___conditional___ == 8--[[ Abbrev_type_clash ]] then do
                                              expected = param_1[2];
                                              actual = param_1[1];
                                              abbrev = param_1[0];
                                              reset_and_mark_loops_list(--[[ :: ]]{
                                                    abbrev,
                                                    --[[ :: ]]{
                                                      actual,
                                                      --[[ :: ]]{
                                                        expected,
                                                        --[[ [] ]]0
                                                      }
                                                    }
                                                  });
                                              return Curry._6(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The abbreviation",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Break ]]Block.__(0, {
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    }),
                                                                                  --[[ String_literal ]]Block.__(11, {
                                                                                      "expands to type",
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Break ]]Block.__(0, {
                                                                                              "@ ",
                                                                                              1,
                                                                                              0
                                                                                            }),
                                                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                  --[[ Break ]]Block.__(0, {
                                                                                                      "@ ",
                                                                                                      1,
                                                                                                      0
                                                                                                    }),
                                                                                                  --[[ String_literal ]]Block.__(11, {
                                                                                                      "but is used with type",
                                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                                          --[[ Break ]]Block.__(0, {
                                                                                                              "@ ",
                                                                                                              1,
                                                                                                              0
                                                                                                            }),
                                                                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                                  --[[ Close_box ]]0,
                                                                                                                  --[[ End_of_format ]]0
                                                                                                                })})
                                                                                                        })
                                                                                                    })
                                                                                                })})
                                                                                        })
                                                                                    })
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[The abbreviation@ %a@ expands to type@ %a@ but is used with type@ %a@]"
                                                            }), type_expr_1, abbrev, type_expr_1, actual, type_expr_1, expected); end end 
                                           if ___conditional___ == 9--[[ Constructor_type_mismatch ]] then do
                                              c = param_1[0];
                                              return report_unification_error(ppf_1, env_2, undefined, param_1[1], (function(ppf) do
                                                            return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                                            --[[ String_literal ]]Block.__(11, {
                                                                                "The expression \"new ",
                                                                                --[[ String ]]Block.__(2, {
                                                                                    --[[ No_padding ]]0,
                                                                                    --[[ String_literal ]]Block.__(11, {
                                                                                        "\" has type",
                                                                                        --[[ End_of_format ]]0
                                                                                      })
                                                                                  })
                                                                              }),
                                                                            "The expression \"new %s\" has type"
                                                                          }), c);
                                                          end end), (function(ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "but is used with type",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "but is used with type"
                                                                      });
                                                          end end)); end end 
                                           if ___conditional___ == 10--[[ Virtual_class ]] then do
                                              vals = param_1[3];
                                              mets = param_1[2];
                                              imm = param_1[1];
                                              cl = param_1[0];
                                              print_mets = function(ppf, mets) do
                                                return List.iter((function(met) do
                                                              return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Break ]]Block.__(0, {
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    }),
                                                                                  --[[ String ]]Block.__(2, {
                                                                                      --[[ No_padding ]]0,
                                                                                      --[[ End_of_format ]]0
                                                                                    })
                                                                                }),
                                                                              "@ %s"
                                                                            }), met);
                                                            end end), mets);
                                              end end;
                                              missings = mets and (
                                                  vals and "methods and variables" or "methods"
                                                ) or "variables";
                                              print_msg = function(ppf) do
                                                if (imm) then do
                                                  return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "This object has virtual ",
                                                                      --[[ String ]]Block.__(2, {
                                                                          --[[ No_padding ]]0,
                                                                          --[[ End_of_format ]]0
                                                                        })
                                                                    }),
                                                                  "This object has virtual %s"
                                                                }), missings);
                                                end else if (cl) then do
                                                  return Format.fprintf(ppf, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "This class should be virtual",
                                                                  --[[ End_of_format ]]0
                                                                }),
                                                              "This class should be virtual"
                                                            });
                                                end else do
                                                  return Format.fprintf(ppf, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "This class type should be virtual",
                                                                  --[[ End_of_format ]]0
                                                                }),
                                                              "This class type should be virtual"
                                                            });
                                                end end  end 
                                              end end;
                                              return Curry._4(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ Theta ]]Block.__(16, {--[[ Char_literal ]]Block.__(12, {
                                                                          --[[ "." ]]46,
                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Break ]]Block.__(0, {
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                }),
                                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                                        --[[ String_literal ]]Block.__(11, {
                                                                                            "<2>",
                                                                                            --[[ End_of_format ]]0
                                                                                          }),
                                                                                        "<2>"
                                                                                      }}),
                                                                                  --[[ String_literal ]]Block.__(11, {
                                                                                      "The following ",
                                                                                      --[[ String ]]Block.__(2, {
                                                                                          --[[ No_padding ]]0,
                                                                                          --[[ String_literal ]]Block.__(11, {
                                                                                              " are undefined :",
                                                                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                      --[[ Close_box ]]0,
                                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                                          --[[ Close_box ]]0,
                                                                                                          --[[ End_of_format ]]0
                                                                                                        })
                                                                                                    })})
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })
                                                                            })
                                                                        })})
                                                                }),
                                                              "@[%t.@ @[<2>The following %s are undefined :%a@]@]"
                                                            }), print_msg, missings, print_mets, Pervasives.$at(mets, vals)); end end 
                                           if ___conditional___ == 11--[[ Parameter_arity_mismatch ]] then do
                                              return Curry._4(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The class constructor ",
                                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Break ]]Block.__(0, {
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                }),
                                                                              --[[ String_literal ]]Block.__(11, {
                                                                                  "expects ",
                                                                                  --[[ Int ]]Block.__(4, {
                                                                                      --[[ Int_i ]]3,
                                                                                      --[[ No_padding ]]0,
                                                                                      --[[ No_precision ]]0,
                                                                                      --[[ String_literal ]]Block.__(11, {
                                                                                          " type argument(s),",
                                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                                              --[[ Break ]]Block.__(0, {
                                                                                                  "@ ",
                                                                                                  1,
                                                                                                  0
                                                                                                }),
                                                                                              --[[ String_literal ]]Block.__(11, {
                                                                                                  "but is here applied to ",
                                                                                                  --[[ Int ]]Block.__(4, {
                                                                                                      --[[ Int_i ]]3,
                                                                                                      --[[ No_padding ]]0,
                                                                                                      --[[ No_precision ]]0,
                                                                                                      --[[ String_literal ]]Block.__(11, {
                                                                                                          " type argument(s)",
                                                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                                                              --[[ Close_box ]]0,
                                                                                                              --[[ End_of_format ]]0
                                                                                                            })
                                                                                                        })
                                                                                                    })
                                                                                                })
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })
                                                                            })})
                                                                    })
                                                                }),
                                                              "@[The class constructor %a@ expects %i type argument(s),@ but is here applied to %i type argument(s)@]"
                                                            }), longident, param_1[0], param_1[1], param_1[2]); end end 
                                           if ___conditional___ == 12--[[ Parameter_mismatch ]] then do
                                              return report_unification_error(ppf_1, env_2, undefined, param_1[0], (function(ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "The type parameter",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "The type parameter"
                                                                      });
                                                          end end), (function(ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "does not meet its constraint: it should be",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "does not meet its constraint: it should be"
                                                                      });
                                                          end end)); end end 
                                           if ___conditional___ == 13--[[ Bad_parameters ]] then do
                                              cstrs = param_1[2];
                                              params = param_1[1];
                                              reset_and_mark_loops_list(--[[ :: ]]{
                                                    params,
                                                    --[[ :: ]]{
                                                      cstrs,
                                                      --[[ [] ]]0
                                                    }
                                                  });
                                              return Curry._6(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The abbreviation ",
                                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Break ]]Block.__(0, {
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                }),
                                                                              --[[ String_literal ]]Block.__(11, {
                                                                                  "is used with parameters",
                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Break ]]Block.__(0, {
                                                                                          "@ ",
                                                                                          1,
                                                                                          0
                                                                                        }),
                                                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                              --[[ Break ]]Block.__(0, {
                                                                                                  "@ ",
                                                                                                  1,
                                                                                                  0
                                                                                                }),
                                                                                              --[[ String_literal ]]Block.__(11, {
                                                                                                  "wich are incompatible with constraints",
                                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                                      --[[ Break ]]Block.__(0, {
                                                                                                          "@ ",
                                                                                                          1,
                                                                                                          0
                                                                                                        }),
                                                                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                              --[[ Close_box ]]0,
                                                                                                              --[[ End_of_format ]]0
                                                                                                            })})
                                                                                                    })
                                                                                                })
                                                                                            })})
                                                                                    })
                                                                                })
                                                                            })})
                                                                    })
                                                                }),
                                                              "@[The abbreviation %a@ is used with parameters@ %a@ wich are incompatible with constraints@ %a@]"
                                                            }), ident_3, param_1[0], type_expr_1, params, type_expr_1, cstrs); end end 
                                           if ___conditional___ == 14--[[ Class_match_failure ]] then do
                                              return report_error_3(ppf_1, param_1[0]); end end 
                                           if ___conditional___ == 15--[[ Unbound_val ]] then do
                                              return Curry._1(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "Unbound instance variable ",
                                                                  --[[ String ]]Block.__(2, {
                                                                      --[[ No_padding ]]0,
                                                                      --[[ End_of_format ]]0
                                                                    })
                                                                }),
                                                              "Unbound instance variable %s"
                                                            }), param_1[0]); end end 
                                           if ___conditional___ == 16--[[ Unbound_type_var ]] then do
                                              print_common = function(ppf, kind, ty0, real, lab, ty) do
                                                ty1 = real and ty0 or newty2(100000000, --[[ Tobject ]]Block.__(4, {
                                                          ty0,
                                                          do
                                                            contents: undefined
                                                          end
                                                        }));
                                                mark_loops(ty1);
                                                return Curry._6(Format.fprintf(ppf, --[[ Format ]]{
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "The ",
                                                                    --[[ String ]]Block.__(2, {
                                                                        --[[ No_padding ]]0,
                                                                        --[[ Char_literal ]]Block.__(12, {
                                                                            --[[ " " ]]32,
                                                                            --[[ String ]]Block.__(2, {
                                                                                --[[ No_padding ]]0,
                                                                                --[[ Formatting_lit ]]Block.__(17, {
                                                                                    --[[ Break ]]Block.__(0, {
                                                                                        "@ ",
                                                                                        1,
                                                                                        0
                                                                                      }),
                                                                                    --[[ String_literal ]]Block.__(11, {
                                                                                        "has type",
                                                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                                                            --[[ Break ]]Block.__(0, {
                                                                                                "@;<1 2>",
                                                                                                1,
                                                                                                2
                                                                                              }),
                                                                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                    --[[ Break ]]Block.__(0, {
                                                                                                        "@ ",
                                                                                                        1,
                                                                                                        0
                                                                                                      }),
                                                                                                    --[[ String_literal ]]Block.__(11, {
                                                                                                        "where",
                                                                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                                                                            --[[ Break ]]Block.__(0, {
                                                                                                                "@ ",
                                                                                                                1,
                                                                                                                0
                                                                                                              }),
                                                                                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                                    --[[ Break ]]Block.__(0, {
                                                                                                                        "@ ",
                                                                                                                        1,
                                                                                                                        0
                                                                                                                      }),
                                                                                                                    --[[ String_literal ]]Block.__(11, {
                                                                                                                        "is unbound",
                                                                                                                        --[[ End_of_format ]]0
                                                                                                                      })
                                                                                                                  })})
                                                                                                          })
                                                                                                      })
                                                                                                  })})
                                                                                          })
                                                                                      })
                                                                                  })
                                                                              })
                                                                          })
                                                                      })
                                                                  }),
                                                                "The %s %s@ has type@;<1 2>%a@ where@ %a@ is unbound"
                                                              }), kind, lab, type_expr_1, ty, type_expr_1, ty0);
                                              end end;
                                              print_reason = function(ppf, param) do
                                                if (param.tag) then do
                                                  return print_common(ppf, "instance variable", param[0], param[1], param[2], param[3]);
                                                end else do
                                                  return print_common(ppf, "method", param[0], param[1], param[2], param[3]);
                                                end end 
                                              end end;
                                              reset(--[[ () ]]0);
                                              return Curry._3(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "<v>",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "<v>"
                                                                      }}),
                                                                  --[[ Formatting_gen ]]Block.__(18, {
                                                                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                            --[[ End_of_format ]]0,
                                                                            ""
                                                                          }}),
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          "Some type variables are unbound in this type:",
                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Break ]]Block.__(0, {
                                                                                  "@;<1 2>",
                                                                                  1,
                                                                                  2
                                                                                }),
                                                                              --[[ Theta ]]Block.__(16, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Close_box ]]0,
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Break ]]Block.__(0, {
                                                                                              "@ ",
                                                                                              1,
                                                                                              0
                                                                                            }),
                                                                                          --[[ Formatting_gen ]]Block.__(18, {
                                                                                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                                                    --[[ End_of_format ]]0,
                                                                                                    ""
                                                                                                  }}),
                                                                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                      --[[ Close_box ]]0,
                                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                                          --[[ Close_box ]]0,
                                                                                                          --[[ End_of_format ]]0
                                                                                                        })
                                                                                                    })})
                                                                                            })
                                                                                        })
                                                                                    })})
                                                                            })
                                                                        })
                                                                    })
                                                                }),
                                                              "@[<v>@[Some type variables are unbound in this type:@;<1 2>%t@]@ @[%a@]@]"
                                                            }), param_1[0], print_reason, param_1[1]); end end 
                                           if ___conditional___ == 17--[[ Make_nongen_seltype ]] then do
                                              return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "<v>",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "<v>"
                                                                      }}),
                                                                  --[[ Formatting_gen ]]Block.__(18, {
                                                                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                            --[[ End_of_format ]]0,
                                                                            ""
                                                                          }}),
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          "Self type should not occur in the non-generic type",
                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Break ]]Block.__(0, {
                                                                                  "@;<1 2>",
                                                                                  1,
                                                                                  2
                                                                                }),
                                                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Close_box ]]0,
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Break ]]Block.__(0, {
                                                                                              "@,",
                                                                                              0,
                                                                                              0
                                                                                            }),
                                                                                          --[[ String_literal ]]Block.__(11, {
                                                                                              "It would escape the scope of its class",
                                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                                  --[[ Close_box ]]0,
                                                                                                  --[[ End_of_format ]]0
                                                                                                })
                                                                                            })
                                                                                        })
                                                                                    })})
                                                                            })
                                                                        })
                                                                    })
                                                                }),
                                                              "@[<v>@[Self type should not occur in the non-generic type@;<1 2>%a@]@,It would escape the scope of its class@]"
                                                            }), type_scheme, param_1[0]); end end 
                                           if ___conditional___ == 18--[[ Non_generalizable_class ]] then do
                                              id = param_1[0];
                                              return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The type of this class,",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                                                  --[[ "," ]]44,
                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Break ]]Block.__(0, {
                                                                                          "@ ",
                                                                                          1,
                                                                                          0
                                                                                        }),
                                                                                      --[[ String_literal ]]Block.__(11, {
                                                                                          "contains type variables that cannot be generalized",
                                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                                              --[[ Close_box ]]0,
                                                                                              --[[ End_of_format ]]0
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[The type of this class,@ %a,@ contains type variables that cannot be generalized@]"
                                                            }), (function(param, param_1) do
                                                            return class_declaration_1(id, param, param_1);
                                                          end end), param_1[1]); end end 
                                           if ___conditional___ == 19--[[ Cannot_coerce_self ]] then do
                                              return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The type of self cannot be coerced to",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ String_literal ]]Block.__(11, {
                                                                              "the type of the current class:",
                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Break ]]Block.__(0, {
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    }),
                                                                                  --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                                                          --[[ "." ]]46,
                                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                                              --[[ Flush_newline ]]4,
                                                                                              --[[ String_literal ]]Block.__(11, {
                                                                                                  "Some occurrences are contravariant",
                                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                                      --[[ Close_box ]]0,
                                                                                                      --[[ End_of_format ]]0
                                                                                                    })
                                                                                                })
                                                                                            })
                                                                                        })})
                                                                                })
                                                                            })
                                                                        })
                                                                    })
                                                                }),
                                                              "@[The type of self cannot be coerced to@ the type of the current class:@ %a.@.Some occurrences are contravariant@]"
                                                            }), type_scheme, param_1[0]); end end 
                                           if ___conditional___ == 20--[[ Non_collapsable_conjunction ]] then do
                                              id_1 = param_1[0];
                                              Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                        --[[ Formatting_gen ]]Block.__(18, {
                                                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                  --[[ End_of_format ]]0,
                                                                  ""
                                                                }}),
                                                            --[[ String_literal ]]Block.__(11, {
                                                                "The type of this class,",
                                                                --[[ Formatting_lit ]]Block.__(17, {
                                                                    --[[ Break ]]Block.__(0, {
                                                                        "@ ",
                                                                        1,
                                                                        0
                                                                      }),
                                                                    --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                                            --[[ "," ]]44,
                                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                                --[[ Break ]]Block.__(0, {
                                                                                    "@ ",
                                                                                    1,
                                                                                    0
                                                                                  }),
                                                                                --[[ String_literal ]]Block.__(11, {
                                                                                    "contains non-collapsible conjunctive types in constraints",
                                                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                                                        --[[ Close_box ]]0,
                                                                                        --[[ End_of_format ]]0
                                                                                      })
                                                                                  })
                                                                              })
                                                                          })})
                                                                  })
                                                              })
                                                          }),
                                                        "@[The type of this class,@ %a,@ contains non-collapsible conjunctive types in constraints@]"
                                                      }), (function(param, param_1) do
                                                      return class_declaration_1(id_1, param, param_1);
                                                    end end), param_1[1]);
                                              return report_unification_error(ppf_1, env_2, undefined, param_1[2], (function(ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "Type",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "Type"
                                                                      });
                                                          end end), (function(ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "is not compatible with type",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "is not compatible with type"
                                                                      });
                                                          end end)); end end 
                                           if ___conditional___ == 21--[[ Final_self_clash ]] then do
                                              return report_unification_error(ppf_1, env_2, undefined, param_1[0], (function(ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "This object is expected to have type",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "This object is expected to have type"
                                                                      });
                                                          end end), (function(ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "but actually has type",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "but actually has type"
                                                                      });
                                                          end end)); end end 
                                           if ___conditional___ == 22--[[ Mutability_mismatch ]] then do
                                              match = param_1[1] == --[[ Immutable ]]0 and --[[ tuple ]]{
                                                  "mutable",
                                                  "immutable"
                                                } or --[[ tuple ]]{
                                                  "immutable",
                                                  "mutable"
                                                };
                                              return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The instance variable is ",
                                                                      --[[ String ]]Block.__(2, {
                                                                          --[[ No_padding ]]0,
                                                                          --[[ Char_literal ]]Block.__(12, {
                                                                              --[[ ";" ]]59,
                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Break ]]Block.__(0, {
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    }),
                                                                                  --[[ String_literal ]]Block.__(11, {
                                                                                      "it cannot be redefined as ",
                                                                                      --[[ String ]]Block.__(2, {
                                                                                          --[[ No_padding ]]0,
                                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                                              --[[ Close_box ]]0,
                                                                                              --[[ End_of_format ]]0
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })
                                                                            })
                                                                        })
                                                                    })
                                                                }),
                                                              "@[The instance variable is %s;@ it cannot be redefined as %s@]"
                                                            }), match[0], match[1]); end end 
                                           if ___conditional___ == 23--[[ No_overriding ]] then do
                                              name = param_1[1];
                                              if (name == "") then do
                                                return Curry._1(Format.fprintf(ppf_1, --[[ Format ]]{
                                                                --[[ Formatting_gen ]]Block.__(18, {
                                                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                          --[[ End_of_format ]]0,
                                                                          ""
                                                                        }}),
                                                                    --[[ String_literal ]]Block.__(11, {
                                                                        "This inheritance does not override any method",
                                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                                            --[[ Break ]]Block.__(0, {
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              }),
                                                                            --[[ String ]]Block.__(2, {
                                                                                --[[ No_padding ]]0,
                                                                                --[[ Formatting_lit ]]Block.__(17, {
                                                                                    --[[ Close_box ]]0,
                                                                                    --[[ End_of_format ]]0
                                                                                  })
                                                                              })
                                                                          })
                                                                      })
                                                                  }),
                                                                "@[This inheritance does not override any method@ %s@]"
                                                              }), "instance variable");
                                              end else do
                                                return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                                --[[ Formatting_gen ]]Block.__(18, {
                                                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                          --[[ End_of_format ]]0,
                                                                          ""
                                                                        }}),
                                                                    --[[ String_literal ]]Block.__(11, {
                                                                        "The ",
                                                                        --[[ String ]]Block.__(2, {
                                                                            --[[ No_padding ]]0,
                                                                            --[[ String_literal ]]Block.__(11, {
                                                                                " `",
                                                                                --[[ String ]]Block.__(2, {
                                                                                    --[[ No_padding ]]0,
                                                                                    --[[ Char_literal ]]Block.__(12, {
                                                                                        --[[ "'" ]]39,
                                                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                                                            --[[ Break ]]Block.__(0, {
                                                                                                "@ ",
                                                                                                1,
                                                                                                0
                                                                                              }),
                                                                                            --[[ String_literal ]]Block.__(11, {
                                                                                                "has no previous definition",
                                                                                                --[[ Formatting_lit ]]Block.__(17, {
                                                                                                    --[[ Close_box ]]0,
                                                                                                    --[[ End_of_format ]]0
                                                                                                  })
                                                                                              })
                                                                                          })
                                                                                      })
                                                                                  })
                                                                              })
                                                                          })
                                                                      })
                                                                  }),
                                                                "@[The %s `%s'@ has no previous definition@]"
                                                              }), param_1[0], name);
                                              end end  end end 
                                           if ___conditional___ == 24--[[ Duplicate ]] then do
                                              return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The ",
                                                                      --[[ String ]]Block.__(2, {
                                                                          --[[ No_padding ]]0,
                                                                          --[[ String_literal ]]Block.__(11, {
                                                                              " `",
                                                                              --[[ String ]]Block.__(2, {
                                                                                  --[[ No_padding ]]0,
                                                                                  --[[ Char_literal ]]Block.__(12, {
                                                                                      --[[ "'" ]]39,
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Break ]]Block.__(0, {
                                                                                              "@ ",
                                                                                              1,
                                                                                              0
                                                                                            }),
                                                                                          --[[ String_literal ]]Block.__(11, {
                                                                                              "has multiple definitions in this object",
                                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                                  --[[ Close_box ]]0,
                                                                                                  --[[ End_of_format ]]0
                                                                                                })
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })
                                                                            })
                                                                        })
                                                                    })
                                                                }),
                                                              "@[The %s `%s'@ has multiple definitions in this object@]"
                                                            }), param_1[0], param_1[1]); end end 
                                          
                                        end
                                      end end 
                                    end end));
                      end end), param[3]);
        end else if (param[0] == Error_forward_2) then do
          return param[1];
        end else do
          return ;
        end end  end 
      end end));

__Error_10 = Caml_exceptions.create("Ocaml_typedtree_test.Typemod.Error");

Error_forward_3 = Caml_exceptions.create("Ocaml_typedtree_test.Typemod.Error_forward");

function fst3(param) do
  return param[0];
end end

function path_concat(head, p) do
  local ___conditional___=(p.tag | 0);
  do
     if ___conditional___ == 0--[[ Pident ]] then do
        return --[[ Pdot ]]Block.__(1, {
                  --[[ Pident ]]Block.__(0, {head}),
                  p[0].name,
                  0
                }); end end 
     if ___conditional___ == 1--[[ Pdot ]] then do
        return --[[ Pdot ]]Block.__(1, {
                  path_concat(head, p[0]),
                  p[1],
                  p[2]
                }); end end 
     if ___conditional___ == 2--[[ Papply ]] then do
        error({
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "typemod.ml",
            54,
            16
          }
        }) end end 
    
  end
end end

function extract_sig(env, loc, mty) do
  match = scrape_alias(env, undefined, mty);
  if (match.tag == --[[ Mty_signature ]]1) then do
    return match[0];
  end else do
    error({
      __Error_10,
      loc,
      env,
      --[[ Signature_expected ]]0
    })
  end end 
end end

function extract_sig_open(env, loc, mty) do
  match = scrape_alias(env, undefined, mty);
  if (match.tag == --[[ Mty_signature ]]1) then do
    return match[0];
  end else do
    error({
      __Error_10,
      loc,
      env,
      --[[ Structure_expected ]]Block.__(3, {mty})
    })
  end end 
end end

function type_open_(toplevel, ovf, env, loc, lid) do
  match = find_module_1(env, lid.loc, lid.txt);
  path = match[0];
  sg = extract_sig_open(env, lid.loc, match[1].md_type);
  return --[[ tuple ]]{
          path,
          open_signature_1(loc, toplevel, ovf, path, sg, env)
        };
end end

function type_open_1(toplevel, env, sod) do
  match = type_open_(toplevel, sod.popen_override, env, sod.popen_loc, sod.popen_lid);
  path = match[0];
  od_open_txt = sod.popen_lid;
  od_open_override = sod.popen_override;
  od_open_loc = sod.popen_loc;
  od_open_attributes = sod.popen_attributes;
  od = do
    open_path: path,
    open_txt: od_open_txt,
    open_override: od_open_override,
    open_loc: od_open_loc,
    open_attributes: od_open_attributes
  end;
  return --[[ tuple ]]{
          path,
          match[1],
          od
        };
end end

type_module_type_of_fwd = do
  contents: (function(env, m) do
      error({
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "typemod.ml",
          99,
          22
        }
      })
    end end)
end;

function add_rec_types(_env, _param) do
  while(true) do
    param = _param;
    env = _env;
    if (param) then do
      match = param[0];
      if (match.tag == --[[ Sig_type ]]1 and match[2] >= 2) then do
        _param = param[1];
        _env = add_type_1(true, match[0], match[1], env);
        ::continue:: ;
      end else do
        return env;
      end end 
    end else do
      return env;
    end end 
  end;
end end

function check_type_decl(env, loc, id, row_id, newdecl, decl, rs, rem) do
  env_1 = add_type_1(true, id, newdecl, env);
  env_2 = row_id ~= undefined and add_type_1(true, row_id, newdecl, env_1) or env_1;
  env_3 = rs == --[[ Trec_not ]]0 and env_2 or add_rec_types(env_2, rem);
  type_declarations_3(env_3, id, newdecl, decl);
  return check_coherence(env_3, loc, id, newdecl);
end end

function update_rec_next(rs, rem) do
  if (rs >= 2 or not rem) then do
    return rem;
  end else do
    match = rem[0];
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 1--[[ Sig_type ]] then do
          if (match[2] >= 2) then do
            return --[[ :: ]]{
                    --[[ Sig_type ]]Block.__(1, {
                        match[0],
                        match[1],
                        rs
                      }),
                    rem[1]
                  };
          end else do
            return rem;
          end end  end end 
       if ___conditional___ == 3--[[ Sig_module ]] then do
          if (match[2] >= 2) then do
            return --[[ :: ]]{
                    --[[ Sig_module ]]Block.__(3, {
                        match[0],
                        match[1],
                        rs
                      }),
                    rem[1]
                  };
          end else do
            return rem;
          end end  end end 
      return rem;
        
    end
  end end 
end end

function merge_constraint(initial_env, loc, sg, constr) do
  lid;
  local ___conditional___=(constr.tag | 0);
  do
     if ___conditional___ == 0--[[ Pwith_type ]]
     or ___conditional___ == 1--[[ Pwith_module ]] then do
        lid = constr[0]; end else 
     if ___conditional___ == 2--[[ Pwith_typesubst ]] then do
        s = constr[0].ptype_name;
        lid = do
          txt: --[[ Lident ]]Block.__(0, {s.txt}),
          loc: s.loc
        end; end else 
     if ___conditional___ == 3--[[ Pwith_modsubst ]] then do
        s_1 = constr[0];
        lid = do
          txt: --[[ Lident ]]Block.__(0, {s_1.txt}),
          loc: s_1.loc
        end; end else 
     end end end end end end
    
  end
  real_id = do
    contents: undefined
  end;
  merge = function(env, _sg, namelist, _row_id) do
    while(true) do
      row_id = _row_id;
      sg = _sg;
      if (sg) then do
        item = sg[0];
        local ___conditional___=(item.tag | 0);
        do
           if ___conditional___ == 1--[[ Sig_type ]] then do
              if (namelist and not namelist[1]) then do
                s = namelist[0];
                rem = sg[1];
                rs = item[2];
                decl = item[1];
                id = item[0];
                exit = 0;
                local ___conditional___=(constr.tag | 0);
                do
                   if ___conditional___ == 0--[[ Pwith_type ]] then do
                      sdecl = constr[1];
                      match = sdecl.ptype_kind;
                      exit_1 = 0;
                      if (typeof match == "number" and not (match ~= 0 or not (id.name == s and is_fixed_type(sdecl)))) then do
                        decl_row_type_params = List.map((function(param) do
                                return newty2(100000000, --[[ Tvar ]]Block.__(0, {undefined}));
                              end end), sdecl.ptype_params);
                        decl_row_type_arity = List.length(sdecl.ptype_params);
                        decl_row_type_variance = List.map((function(param) do
                                match;
                                local ___conditional___=(param[1]);
                                do
                                   if ___conditional___ == 0--[[ Covariant ]] then do
                                      match = --[[ tuple ]]{
                                        true,
                                        false
                                      }; end else 
                                   if ___conditional___ == 1--[[ Contravariant ]] then do
                                      match = --[[ tuple ]]{
                                        false,
                                        true
                                      }; end else 
                                   if ___conditional___ == 2--[[ Invariant ]] then do
                                      match = --[[ tuple ]]{
                                        false,
                                        false
                                      }; end else 
                                   end end end end end end
                                  
                                end
                                p = not match[1];
                                n = not match[0];
                                i = false;
                                return Curry._3(Types_Variance.set, --[[ May_pos ]]0, p, Curry._3(Types_Variance.set, --[[ May_neg ]]1, n, Curry._3(Types_Variance.set, --[[ May_weak ]]2, n, Curry._3(Types_Variance.set, --[[ Inj ]]3, i, Types_Variance.__null))));
                              end end), sdecl.ptype_params);
                        decl_row_type_loc = sdecl.ptype_loc;
                        decl_row = do
                          type_params: decl_row_type_params,
                          type_arity: decl_row_type_arity,
                          type_kind: --[[ Type_abstract ]]0,
                          type_private: --[[ Private ]]0,
                          type_manifest: undefined,
                          type_variance: decl_row_type_variance,
                          type_newtype_level: undefined,
                          type_loc: decl_row_type_loc,
                          type_attributes: --[[ [] ]]0
                        end;
                        id_row = create(s .. "#row");
                        initial_env_1 = add_type_1(true, id_row, decl_row, initial_env);
                        tdecl = transl_with_constraint(initial_env_1, id, --[[ Pident ]]Block.__(0, {id_row}), decl, sdecl);
                        newdecl = tdecl.typ_type;
                        check_type_decl(env, sdecl.ptype_loc, id, row_id, newdecl, decl, rs, rem);
                        decl_row_type_params_1 = newdecl.type_params;
                        decl_row_type_arity_1 = decl_row_type_arity;
                        decl_row_type_variance_1 = decl_row_type_variance;
                        decl_row_type_loc_1 = decl_row_type_loc;
                        decl_row_1 = do
                          type_params: decl_row_type_params_1,
                          type_arity: decl_row_type_arity_1,
                          type_kind: --[[ Type_abstract ]]0,
                          type_private: --[[ Private ]]0,
                          type_manifest: undefined,
                          type_variance: decl_row_type_variance_1,
                          type_newtype_level: undefined,
                          type_loc: decl_row_type_loc_1,
                          type_attributes: --[[ [] ]]0
                        end;
                        rs$prime = rs == --[[ Trec_first ]]1 and --[[ Trec_not ]]0 or rs;
                        return --[[ tuple ]]{
                                --[[ tuple ]]{
                                  --[[ Pident ]]Block.__(0, {id}),
                                  lid,
                                  --[[ Twith_type ]]Block.__(0, {tdecl})
                                },
                                --[[ :: ]]{
                                  --[[ Sig_type ]]Block.__(1, {
                                      id_row,
                                      decl_row_1,
                                      rs$prime
                                    }),
                                  --[[ :: ]]{
                                    --[[ Sig_type ]]Block.__(1, {
                                        id,
                                        newdecl,
                                        rs
                                      }),
                                    rem
                                  }
                                }
                              };
                      end else do
                        exit_1 = 3;
                      end end 
                      if (exit_1 == 3) then do
                        if (id.name == s) then do
                          tdecl_1 = transl_with_constraint(initial_env, id, undefined, decl, sdecl);
                          newdecl_1 = tdecl_1.typ_type;
                          check_type_decl(env, sdecl.ptype_loc, id, row_id, newdecl_1, decl, rs, rem);
                          return --[[ tuple ]]{
                                  --[[ tuple ]]{
                                    --[[ Pident ]]Block.__(0, {id}),
                                    lid,
                                    --[[ Twith_type ]]Block.__(0, {tdecl_1})
                                  },
                                  --[[ :: ]]{
                                    --[[ Sig_type ]]Block.__(1, {
                                        id,
                                        newdecl_1,
                                        rs
                                      }),
                                    rem
                                  }
                                };
                        end else do
                          exit = 2;
                        end end 
                      end
                       end  end else 
                   if ___conditional___ == 2--[[ Pwith_typesubst ]] then do
                      exit = 2; end else 
                   if ___conditional___ == 1--[[ Pwith_module ]]
                   or ___conditional___ == 3--[[ Pwith_modsubst ]]
                   end end end end end
                  
                end
                if (exit == 2) then do
                  if (id.name == s .. "#row") then do
                    _row_id = id;
                    _sg = rem;
                    ::continue:: ;
                  end else if (constr.tag) then do
                    sdecl_1 = constr[0];
                    if (id.name == s) then do
                      tdecl_2 = transl_with_constraint(initial_env, id, undefined, decl, sdecl_1);
                      newdecl_2 = tdecl_2.typ_type;
                      check_type_decl(env, sdecl_1.ptype_loc, id, row_id, newdecl_2, decl, rs, rem);
                      real_id.contents = id;
                      return --[[ tuple ]]{
                              --[[ tuple ]]{
                                --[[ Pident ]]Block.__(0, {id}),
                                lid,
                                --[[ Twith_typesubst ]]Block.__(2, {tdecl_2})
                              },
                              update_rec_next(rs, rem)
                            };
                    end
                     end 
                  end
                   end  end 
                end
                 end 
              end
               end  end else 
           if ___conditional___ == 3--[[ Sig_module ]] then do
              if (namelist) then do
                namelist_1 = namelist[1];
                s_1 = namelist[0];
                rem_1 = sg[1];
                rs_1 = item[2];
                md = item[1];
                id_1 = item[0];
                exit_2 = 0;
                if (namelist_1) then do
                  exit_2 = 2;
                end else do
                  local ___conditional___=(constr.tag | 0);
                  do
                     if ___conditional___ == 1--[[ Pwith_module ]] then do
                        lid$prime = constr[1];
                        if (id_1.name == s_1) then do
                          match_1 = find_module_1(initial_env, loc, lid$prime.txt);
                          md$prime = match_1[1];
                          path = match_1[0];
                          md$prime$prime_md_type = remove_aliases_1(env, md$prime.md_type);
                          md$prime$prime_md_attributes = md$prime.md_attributes;
                          md$prime$prime_md_loc = md$prime.md_loc;
                          md$prime$prime = do
                            md_type: md$prime$prime_md_type,
                            md_attributes: md$prime$prime_md_attributes,
                            md_loc: md$prime$prime_md_loc
                          end;
                          newmd = strengthen_decl(env, md$prime$prime, path);
                          modtypes_1(env, newmd.md_type, md.md_type);
                          return --[[ tuple ]]{
                                  --[[ tuple ]]{
                                    --[[ Pident ]]Block.__(0, {id_1}),
                                    lid,
                                    --[[ Twith_module ]]Block.__(1, {
                                        path,
                                        lid$prime
                                      })
                                  },
                                  --[[ :: ]]{
                                    --[[ Sig_module ]]Block.__(3, {
                                        id_1,
                                        newmd,
                                        rs_1
                                      }),
                                    rem_1
                                  }
                                };
                        end else do
                          exit_2 = 2;
                        end end  end else 
                     if ___conditional___ == 0--[[ Pwith_type ]]
                     or ___conditional___ == 2--[[ Pwith_typesubst ]] then do
                        exit_2 = 2; end else 
                     if ___conditional___ == 3--[[ Pwith_modsubst ]] then do
                        lid$prime_1 = constr[1];
                        if (id_1.name == s_1) then do
                          match_2 = find_module_1(initial_env, loc, lid$prime_1.txt);
                          path_1 = match_2[0];
                          newmd_1 = strengthen_decl(env, match_2[1], path_1);
                          modtypes_1(env, newmd_1.md_type, md.md_type);
                          real_id.contents = id_1;
                          return --[[ tuple ]]{
                                  --[[ tuple ]]{
                                    --[[ Pident ]]Block.__(0, {id_1}),
                                    lid,
                                    --[[ Twith_modsubst ]]Block.__(3, {
                                        path_1,
                                        lid$prime_1
                                      })
                                  },
                                  update_rec_next(rs_1, rem_1)
                                };
                        end else do
                          exit_2 = 2;
                        end end  end else 
                     end end end end end end
                    
                  end
                end end 
                if (exit_2 == 2 and id_1.name == s_1) then do
                  match_3 = merge(env, extract_sig(env, loc, md.md_type), namelist_1, undefined);
                  match_4 = match_3[0];
                  return --[[ tuple ]]{
                          --[[ tuple ]]{
                            path_concat(id_1, match_4[0]),
                            lid,
                            match_4[2]
                          },
                          --[[ :: ]]{
                            --[[ Sig_module ]]Block.__(3, {
                                id_1,
                                do
                                  md_type: --[[ Mty_signature ]]Block.__(1, {match_3[1]}),
                                  md_attributes: md.md_attributes,
                                  md_loc: md.md_loc
                                end,
                                rs_1
                              }),
                            rem_1
                          }
                        };
                end
                 end 
              end
               end  end else 
           end end end end
          
        end
        match_5 = merge(add_item(item, env), sg[1], namelist, row_id);
        return --[[ tuple ]]{
                match_5[0],
                --[[ :: ]]{
                  item,
                  match_5[1]
                }
              };
      end else do
        error({
          __Error_10,
          loc,
          env,
          --[[ With_no_component ]]Block.__(4, {lid.txt})
        })
      end end 
    end;
  end end;
  xpcall(function() do
    names = flat(--[[ [] ]]0, lid.txt);
    match = merge(initial_env, sg, names, undefined);
    sg_1 = match[1];
    sg_2;
    if (names and not names[1]) then do
      local ___conditional___=(constr.tag | 0);
      do
         if ___conditional___ == 0--[[ Pwith_type ]]
         or ___conditional___ == 1--[[ Pwith_module ]] then do
            sg_2 = sg_1; end else 
         if ___conditional___ == 2--[[ Pwith_typesubst ]] then do
            sdecl = constr[0];
            match_1 = real_id.contents;
            id;
            if (match_1 ~= undefined) then do
              id = match_1;
            end else do
              error({
                Caml_builtin_exceptions.assert_failure,
                --[[ tuple ]]{
                  "typemod.ml",
                  246,
                  38
                }
              })
            end end 
            lid_1;
            xpcall(function() do
              match_2 = sdecl.ptype_manifest;
              if (match_2 ~= undefined) then do
                match_3 = match_2.ptyp_desc;
                if (typeof match_3 == "number") then do
                  error(Pervasives.Exit)
                end else if (match_3.tag == --[[ Ptyp_constr ]]3) then do
                  stl = match_3[1];
                  if (List.length(stl) == List.length(sdecl.ptype_params)) then do
                    List.iter2((function(x, param) do
                            match = x.ptyp_desc;
                            if (typeof match == "number") then do
                              error(Pervasives.Exit)
                            end else if (match.tag) then do
                              error(Pervasives.Exit)
                            end else do
                              match_1 = param[0].ptyp_desc;
                              if (typeof match_1 == "number") then do
                                error(Pervasives.Exit)
                              end else if (match_1.tag) then do
                                error(Pervasives.Exit)
                              end else if (match[0] == match_1[0]) then do
                                return --[[ () ]]0;
                              end else do
                                error(Pervasives.Exit)
                              end end  end  end 
                            end end  end 
                          end end), stl, sdecl.ptype_params);
                    lid_1 = match_3[0];
                  end else do
                    error(Pervasives.Exit)
                  end end 
                end else do
                  error(Pervasives.Exit)
                end end  end 
              end else do
                error(Pervasives.Exit)
              end end 
            end end,function(exn) do
              if (exn == Pervasives.Exit) then do
                error({
                  __Error_10,
                  sdecl.ptype_loc,
                  initial_env,
                  --[[ With_need_typeconstr ]]2
                })
              end
               end 
              error(exn)
            end end)
            match_4;
            xpcall(function() do
              match_4 = lookup_type_1(lid_1.txt, initial_env);
            end end,function(exn_1) do
              if (exn_1 == Caml_builtin_exceptions.not_found) then do
                error({
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "typemod.ml",
                    263,
                    68
                  }
                })
              end
               end 
              error(exn_1)
            end end)
            sub = add_type(id, match_4[0], identity);
            sg_2 = signature_2(sub, sg_1); end else 
         if ___conditional___ == 3--[[ Pwith_modsubst ]] then do
            match_5 = real_id.contents;
            id_1;
            if (match_5 ~= undefined) then do
              id_1 = match_5;
            end else do
              error({
                Caml_builtin_exceptions.assert_failure,
                --[[ tuple ]]{
                  "typemod.ml",
                  269,
                  38
                }
              })
            end end 
            path = lookup_module_1(undefined, initial_env, loc, constr[1].txt);
            sub_1 = add_module(id_1, path, identity);
            sg_2 = signature_2(sub_1, sg_1); end else 
         end end end end end end
        
      end
    end else do
      sg_2 = sg_1;
    end end 
    return --[[ tuple ]]{
            match[0],
            sg_2
          };
  end end,function(raw_exn) do
    exn_2 = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn_2[0] == __Error_5) then do
      error({
        __Error_10,
        loc,
        initial_env,
        --[[ With_mismatch ]]Block.__(5, {
            lid.txt,
            exn_2[1]
          })
      })
    end
     end 
    error(exn_2)
  end end)
end end

function map_rec(fn, decls, rem) do
  if (decls) then do
    return --[[ :: ]]{
            Curry._2(fn, --[[ Trec_first ]]1, decls[0]),
            map_end(Curry._1(fn, --[[ Trec_next ]]2), decls[1], rem)
          };
  end else do
    return rem;
  end end 
end end

function map_rec_type(rec_flag, fn, decls, rem) do
  if (decls) then do
    first = rec_flag and --[[ Trec_first ]]1 or --[[ Trec_not ]]0;
    return --[[ :: ]]{
            Curry._2(fn, first, decls[0]),
            map_end(Curry._1(fn, --[[ Trec_next ]]2), decls[1], rem)
          };
  end else do
    return rem;
  end end 
end end

function map_rec_type_with_row_types(rec_flag, fn, decls, rem) do
  if (decls) then do
    d1 = decls[0];
    if (is_row_name(d1.typ_id.name)) then do
      return --[[ :: ]]{
              Curry._2(fn, --[[ Trec_not ]]0, d1),
              map_rec_type_with_row_types(rec_flag, fn, decls[1], rem)
            };
    end else do
      return map_rec_type(rec_flag, fn, decls, rem);
    end end 
  end else do
    return rem;
  end end 
end end

function rec_flag_of_ptype_declarations(tds) do
  is_nonrec = List.exists((function(td) do
          return List.exists((function(param) do
                        return param[0].txt == "nonrec";
                      end end), td.ptype_attributes);
        end end), tds);
  if (is_nonrec) then do
    return --[[ Nonrecursive ]]0;
  end else do
    return --[[ Recursive ]]1;
  end end 
end end

function map_ext(fn, exts, rem) do
  if (exts) then do
    return --[[ :: ]]{
            Curry._2(fn, --[[ Text_first ]]0, exts[0]),
            map_end(Curry._1(fn, --[[ Text_next ]]1), exts[1], rem)
          };
  end else do
    return rem;
  end end 
end end

function approx_modtype(env, _smty) do
  while(true) do
    smty = _smty;
    match = smty.pmty_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 0--[[ Pmty_ident ]] then do
          match_1 = find_modtype_1(env, smty.pmty_loc, match[0].txt);
          return --[[ Mty_ident ]]Block.__(0, {match_1[0]}); end end 
       if ___conditional___ == 1--[[ Pmty_signature ]] then do
          return --[[ Mty_signature ]]Block.__(1, {approx_sig(env, match[0])}); end end 
       if ___conditional___ == 2--[[ Pmty_functor ]] then do
          arg = may_map((function(param) do
                  return approx_modtype(env, param);
                end end), match[1]);
          match_2 = enter_module(true, match[0].txt, default_mty(arg), env);
          res = approx_modtype(match_2[1], match[2]);
          return --[[ Mty_functor ]]Block.__(2, {
                    match_2[0],
                    arg,
                    res
                  }); end end 
       if ___conditional___ == 3--[[ Pmty_with ]] then do
          _smty = match[0];
          ::continue:: ; end end 
       if ___conditional___ == 4--[[ Pmty_typeof ]] then do
          return Curry._2(type_module_type_of_fwd.contents, env, match[0])[1]; end end 
       if ___conditional___ == 5--[[ Pmty_extension ]] then do
          error({
            Error_forward_3,
            error_of_extension(match[0])
          }) end end 
       if ___conditional___ == 6--[[ Pmty_alias ]] then do
          path = lookup_module_1(undefined, env, smty.pmty_loc, match[0].txt);
          return --[[ Mty_alias ]]Block.__(3, {path}); end end 
      
    end
  end;
end end

function approx_module_declaration(env, pmd) do
  return do
          md_type: approx_modtype(env, pmd.pmd_type),
          md_attributes: pmd.pmd_attributes,
          md_loc: pmd.pmd_loc
        end;
end end

function approx_sig(_env, _ssg) do
  while(true) do
    ssg = _ssg;
    env = _env;
    if (ssg) then do
      srem = ssg[1];
      match = ssg[0].psig_desc;
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 1--[[ Psig_type ]] then do
            sdecls = match[0];
            rec_flag = rec_flag_of_ptype_declarations(sdecls);
            decls = approx_type_decl(env, sdecls);
            rem = approx_sig(env, srem);
            return map_rec_type(rec_flag, (function(rs, param) do
                          return --[[ Sig_type ]]Block.__(1, {
                                    param[0],
                                    param[1],
                                    rs
                                  });
                        end end), decls, rem); end end 
         if ___conditional___ == 4--[[ Psig_module ]] then do
            pmd = match[0];
            md = approx_module_declaration(env, pmd);
            match_1 = enter_module_declaration(undefined, pmd.pmd_name.txt, md, env);
            return --[[ :: ]]{
                    --[[ Sig_module ]]Block.__(3, {
                        match_1[0],
                        md,
                        --[[ Trec_not ]]0
                      }),
                    approx_sig(match_1[1], srem)
                  }; end end 
         if ___conditional___ == 5--[[ Psig_recmodule ]] then do
            decls_1 = List.map((function(env)do
                return function (pmd) do
                  return --[[ tuple ]]{
                          create(pmd.pmd_name.txt),
                          approx_module_declaration(env, pmd)
                        };
                end end
                end end)(env), match[0]);
            newenv = List.fold_left((function(env, param) do
                    return add_module_declaration(undefined, param[0], param[1], env);
                  end end), env, decls_1);
            return map_rec((function(rs, param) do
                          return --[[ Sig_module ]]Block.__(3, {
                                    param[0],
                                    param[1],
                                    rs
                                  });
                        end end), decls_1, approx_sig(newenv, srem)); end end 
         if ___conditional___ == 6--[[ Psig_modtype ]] then do
            d = match[0];
            info = approx_modtype_info(env, d);
            match_2 = enter_modtype(d.pmtd_name.txt, info, env);
            return --[[ :: ]]{
                    --[[ Sig_modtype ]]Block.__(4, {
                        match_2[0],
                        info
                      }),
                    approx_sig(match_2[1], srem)
                  }; end end 
         if ___conditional___ == 7--[[ Psig_open ]] then do
            match_3 = type_open_1(undefined, env, match[0]);
            _ssg = srem;
            _env = match_3[1];
            ::continue:: ; end end 
         if ___conditional___ == 8--[[ Psig_include ]] then do
            smty = match[0].pincl_mod;
            mty = approx_modtype(env, smty);
            sg = signature_2(identity, extract_sig(env, smty.pmty_loc, mty));
            newenv_1 = add_signature(sg, env);
            return Pervasives.$at(sg, approx_sig(newenv_1, srem)); end end 
         if ___conditional___ == 9--[[ Psig_class ]]
         or ___conditional___ == 10--[[ Psig_class_type ]]
         end
        _ssg = srem;
          ::continue:: ;
          
      end
      decls_2 = approx_class_declarations(env, match[0]);
      rem_1 = approx_sig(env, srem);
      return List.flatten(map_rec((function(rs, param) do
                        return --[[ :: ]]{
                                --[[ Sig_class_type ]]Block.__(6, {
                                    param[0],
                                    param[2],
                                    rs
                                  }),
                                --[[ :: ]]{
                                  --[[ Sig_type ]]Block.__(1, {
                                      param[3],
                                      param[4],
                                      rs
                                    }),
                                  --[[ :: ]]{
                                    --[[ Sig_type ]]Block.__(1, {
                                        param[5],
                                        param[6],
                                        rs
                                      }),
                                    --[[ [] ]]0
                                  }
                                }
                              };
                      end end), decls_2, --[[ :: ]]{
                      rem_1,
                      --[[ [] ]]0
                    }));
    end else do
      return --[[ [] ]]0;
    end end 
  end;
end end

function approx_modtype_info(env, sinfo) do
  return do
          mtd_type: may_map((function(param) do
                  return approx_modtype(env, param);
                end end), sinfo.pmtd_type),
          mtd_attributes: sinfo.pmtd_attributes,
          mtd_loc: sinfo.pmtd_loc
        end;
end end

function check_recmod_typedecls(env, sdecls, decls) do
  recmod_ids = List.map(fst3, decls);
  return List.iter2((function(pmd, param) do
                mty = param[2].mty_type;
                return List.iter((function(path) do
                              env_1 = env;
                              loc = pmd.pmd_type.pmty_loc;
                              recmod_ids_1 = recmod_ids;
                              path_1 = path;
                              decl = find_type_full(path, env)[0];
                              to_check = function(path) do
                                return List.exists((function(id) do
                                              return isfree(id, path);
                                            end end), recmod_ids_1);
                              end end;
                              check_well_founded_decl(env_1, loc, path_1, decl, to_check);
                              return check_recursion(env_1, loc, path_1, decl, to_check);
                            end end), type_paths(env, --[[ Pident ]]Block.__(0, {param[0]}), mty));
              end end), sdecls, decls);
end end

function height_12(param) do
  if (param) then do
    return param[--[[ h ]]3];
  end else do
    return 0;
  end end 
end end

function create_13(l, v, r) do
  hl = l and l[--[[ h ]]3] or 0;
  hr = r and r[--[[ h ]]3] or 0;
  return --[[ Node ]]{
          --[[ l ]]l,
          --[[ v ]]v,
          --[[ r ]]r,
          --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
        };
end end

function bal_12(l, v, r) do
  hl = l and l[--[[ h ]]3] or 0;
  hr = r and r[--[[ h ]]3] or 0;
  if (hl > (hr + 2 | 0)) then do
    if (l) then do
      lr = l[--[[ r ]]2];
      lv = l[--[[ v ]]1];
      ll = l[--[[ l ]]0];
      if (height_12(ll) >= height_12(lr)) then do
        return create_13(ll, lv, create_13(lr, v, r));
      end else if (lr) then do
        return create_13(create_13(ll, lv, lr[--[[ l ]]0]), lr[--[[ v ]]1], create_13(lr[--[[ r ]]2], v, r));
      end else do
        error({
          Caml_builtin_exceptions.invalid_argument,
          "Set.bal"
        })
      end end  end 
    end else do
      error({
        Caml_builtin_exceptions.invalid_argument,
        "Set.bal"
      })
    end end 
  end else if (hr > (hl + 2 | 0)) then do
    if (r) then do
      rr = r[--[[ r ]]2];
      rv = r[--[[ v ]]1];
      rl = r[--[[ l ]]0];
      if (height_12(rr) >= height_12(rl)) then do
        return create_13(create_13(l, v, rl), rv, rr);
      end else if (rl) then do
        return create_13(create_13(l, v, rl[--[[ l ]]0]), rl[--[[ v ]]1], create_13(rl[--[[ r ]]2], rv, rr));
      end else do
        error({
          Caml_builtin_exceptions.invalid_argument,
          "Set.bal"
        })
      end end  end 
    end else do
      error({
        Caml_builtin_exceptions.invalid_argument,
        "Set.bal"
      })
    end end 
  end else do
    return --[[ Node ]]{
            --[[ l ]]l,
            --[[ v ]]v,
            --[[ r ]]r,
            --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
          };
  end end  end 
end end

function add_14(x, t) do
  if (t) then do
    r = t[--[[ r ]]2];
    v = t[--[[ v ]]1];
    l = t[--[[ l ]]0];
    c = Caml_primitive.caml_string_compare(x, v);
    if (c == 0) then do
      return t;
    end else if (c < 0) then do
      ll = add_14(x, l);
      if (l == ll) then do
        return t;
      end else do
        return bal_12(ll, v, r);
      end end 
    end else do
      rr = add_14(x, r);
      if (r == rr) then do
        return t;
      end else do
        return bal_12(l, v, rr);
      end end 
    end end  end 
  end else do
    return --[[ Node ]]{
            --[[ l : Empty ]]0,
            --[[ v ]]x,
            --[[ r : Empty ]]0,
            --[[ h ]]1
          };
  end end 
end end

function mem_7(x, _param) do
  while(true) do
    param = _param;
    if (param) then do
      c = Caml_primitive.caml_string_compare(x, param[--[[ v ]]1]);
      if (c == 0) then do
        return true;
      end else do
        _param = c < 0 and param[--[[ l ]]0] or param[--[[ r ]]2];
        ::continue:: ;
      end end 
    end else do
      return false;
    end end 
  end;
end end

function check(cl, loc, set_ref, name) do
  if (mem_7(name, set_ref.contents)) then do
    error({
      __Error_10,
      loc,
      empty,
      --[[ Repeated_name ]]Block.__(6, {
          cl,
          name
        })
    })
  end
   end 
  set_ref.contents = add_14(name, set_ref.contents);
  return --[[ () ]]0;
end end

function check_name(cl, set_ref, name) do
  return check(cl, name.loc, set_ref, name.txt);
end end

function check_sig_item(type_names, module_names, modtype_names, loc, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 1--[[ Sig_type ]] then do
        return check("type", loc, type_names, param[0].name); end end 
     if ___conditional___ == 3--[[ Sig_module ]] then do
        return check("module", loc, module_names, param[0].name); end end 
     if ___conditional___ == 4--[[ Sig_modtype ]] then do
        return check("module type", loc, modtype_names, param[0].name); end end 
    return --[[ () ]]0;
      
  end
end end

function remove_duplicates(val_ids, ext_ids, _param) do
  while(true) do
    param = _param;
    if (param) then do
      f = param[0];
      local ___conditional___=(f.tag | 0);
      do
         if ___conditional___ == 0--[[ Sig_value ]] then do
            id = f[0];
            if (List.exists((function(id)do
                  return function (param) do
                    return equal(id, param);
                  end end
                  end end)(id), val_ids)) then do
              _param = param[1];
              ::continue:: ;
            end
             end  end else 
         if ___conditional___ == 2--[[ Sig_typext ]] then do
            id_1 = f[0];
            exit = 0;
            if (f[2] ~= 0) then do
              exit = 2;
            end else do
              match = param[1];
              if (match) then do
                match_1 = match[0];
                if (match_1.tag == --[[ Sig_typext ]]2 and not (match_1[2] ~= 1 or not List.exists((function(id_1)do
                        return function (param) do
                          return equal(id_1, param);
                        end end
                        end end)(id_1), ext_ids))) then do
                  _param = --[[ :: ]]{
                    --[[ Sig_typext ]]Block.__(2, {
                        match_1[0],
                        match_1[1],
                        --[[ Text_first ]]0
                      }),
                    match[1]
                  };
                  ::continue:: ;
                end else do
                  exit = 2;
                end end 
              end else do
                exit = 2;
              end end 
            end end 
            if (exit == 2 and List.exists((function(id_1)do
                  return function (param) do
                    return equal(id_1, param);
                  end end
                  end end)(id_1), ext_ids)) then do
              _param = param[1];
              ::continue:: ;
            end
             end  end else 
         end end end end
        
      end
      return --[[ :: ]]{
              f,
              remove_duplicates(val_ids, ext_ids, param[1])
            };
    end else do
      return --[[ [] ]]0;
    end end 
  end;
end end

function get_values(_param) do
  while(true) do
    param = _param;
    if (param) then do
      f = param[0];
      if (f.tag) then do
        _param = param[1];
        ::continue:: ;
      end else do
        return --[[ :: ]]{
                f[0],
                get_values(param[1])
              };
      end end 
    end else do
      return --[[ [] ]]0;
    end end 
  end;
end end

function get_extension_constructors(_param) do
  while(true) do
    param = _param;
    if (param) then do
      f = param[0];
      if (f.tag == --[[ Sig_typext ]]2) then do
        return --[[ :: ]]{
                f[0],
                get_extension_constructors(param[1])
              };
      end else do
        _param = param[1];
        ::continue:: ;
      end end 
    end else do
      return --[[ [] ]]0;
    end end 
  end;
end end

function transl_modtype_longident_1(loc, env, lid) do
  return find_modtype_1(env, loc, lid)[0];
end end

function transl_module_alias(loc, env, lid) do
  return lookup_module_1(undefined, env, loc, lid);
end end

function mkmty_1(desc, typ, env, loc, attrs) do
  mty = do
    mty_desc: desc,
    mty_type: typ,
    mty_env: env,
    mty_loc: loc,
    mty_attributes: attrs
  end;
  add_saved_type(--[[ Partial_module_type ]]Block.__(7, {mty}));
  return mty;
end end

function mksig_1(desc, env, loc) do
  sg = do
    sig_desc: desc,
    sig_env: env,
    sig_loc: loc
  end;
  add_saved_type(--[[ Partial_signature_item ]]Block.__(6, {sg}));
  return sg;
end end

function transl_modtype_1(env, smty) do
  loc = smty.pmty_loc;
  match = smty.pmty_desc;
  local ___conditional___=(match.tag | 0);
  do
     if ___conditional___ == 0--[[ Pmty_ident ]] then do
        lid = match[0];
        path = transl_modtype_longident_1(loc, env, lid.txt);
        return mkmty_1(--[[ Tmty_ident ]]Block.__(0, {
                      path,
                      lid
                    }), --[[ Mty_ident ]]Block.__(0, {path}), env, loc, smty.pmty_attributes); end end 
     if ___conditional___ == 1--[[ Pmty_signature ]] then do
        sg = transl_signature(env, match[0]);
        return mkmty_1(--[[ Tmty_signature ]]Block.__(1, {sg}), --[[ Mty_signature ]]Block.__(1, {sg.sig_type}), env, loc, smty.pmty_attributes); end end 
     if ___conditional___ == 2--[[ Pmty_functor ]] then do
        param = match[0];
        arg = may_map((function(param) do
                return transl_modtype_1(env, param);
              end end), match[1]);
        ty_arg = may_map((function(m) do
                return m.mty_type;
              end end), arg);
        match_1 = enter_module(true, param.txt, default_mty(ty_arg), env);
        id = match_1[0];
        init_def(currentstamp.contents);
        res = transl_modtype_1(match_1[1], match[2]);
        return mkmty_1(--[[ Tmty_functor ]]Block.__(2, {
                      id,
                      param,
                      arg,
                      res
                    }), --[[ Mty_functor ]]Block.__(2, {
                      id,
                      ty_arg,
                      res.mty_type
                    }), env, loc, smty.pmty_attributes); end end 
     if ___conditional___ == 3--[[ Pmty_with ]] then do
        sbody = match[0];
        body = transl_modtype_1(env, sbody);
        init_sg = extract_sig(env, sbody.pmty_loc, body.mty_type);
        match_2 = List.fold_left((function(param, sdecl) do
                match = merge_constraint(env, smty.pmty_loc, param[1], sdecl);
                return --[[ tuple ]]{
                        --[[ :: ]]{
                          match[0],
                          param[0]
                        },
                        match[1]
                      };
              end end), --[[ tuple ]]{
              --[[ [] ]]0,
              init_sg
            }, match[1]);
        return mkmty_1(--[[ Tmty_with ]]Block.__(3, {
                      body,
                      List.rev(match_2[0])
                    }), modtype(identity, --[[ Mty_signature ]]Block.__(1, {match_2[1]})), env, loc, smty.pmty_attributes); end end 
     if ___conditional___ == 4--[[ Pmty_typeof ]] then do
        match_3 = Curry._2(type_module_type_of_fwd.contents, env, match[0]);
        return mkmty_1(--[[ Tmty_typeof ]]Block.__(4, {match_3[0]}), match_3[1], env, loc, smty.pmty_attributes); end end 
     if ___conditional___ == 5--[[ Pmty_extension ]] then do
        error({
          Error_forward_3,
          error_of_extension(match[0])
        }) end end 
     if ___conditional___ == 6--[[ Pmty_alias ]] then do
        lid_1 = match[0];
        path_1 = transl_module_alias(loc, env, lid_1.txt);
        return mkmty_1(--[[ Tmty_alias ]]Block.__(5, {
                      path_1,
                      lid_1
                    }), --[[ Mty_alias ]]Block.__(3, {path_1}), env, loc, smty.pmty_attributes); end end 
    
  end
end end

function transl_signature(env, sg) do
  type_names = do
    contents: --[[ Empty ]]0
  end;
  module_names = do
    contents: --[[ Empty ]]0
  end;
  modtype_names = do
    contents: --[[ Empty ]]0
  end;
  transl_sig = function(env, sg) do
    init_def(currentstamp.contents);
    if (sg) then do
      srem = sg[1];
      item = sg[0];
      loc = item.psig_loc;
      match = item.psig_desc;
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ == 0--[[ Psig_value ]] then do
            match_1 = transl_value_decl(env, item.psig_loc, match[0]);
            tdesc = match_1[0];
            match_2 = transl_sig(match_1[1], srem);
            rem = match_2[1];
            partial_arg = tdesc.val_id;
            return --[[ tuple ]]{
                    --[[ :: ]]{
                      mksig_1(--[[ Tsig_value ]]Block.__(0, {tdesc}), env, loc),
                      match_2[0]
                    },
                    List.exists((function(param) do
                            return equal(partial_arg, param);
                          end end), get_values(rem)) and rem or --[[ :: ]]{
                        --[[ Sig_value ]]Block.__(0, {
                            tdesc.val_id,
                            tdesc.val_val
                          }),
                        rem
                      },
                    match_2[2]
                  }; end end 
         if ___conditional___ == 1--[[ Psig_type ]] then do
            sdecls = match[0];
            rec_flag = rec_flag_of_ptype_declarations(sdecls);
            List.iter((function(decl) do
                    return check_name("type", type_names, decl.ptype_name);
                  end end), sdecls);
            match_3 = transl_type_decl(env, rec_flag, sdecls);
            decls = match_3[0];
            match_4 = transl_sig(match_3[1], srem);
            return --[[ tuple ]]{
                    --[[ :: ]]{
                      mksig_1(--[[ Tsig_type ]]Block.__(1, {decls}), env, loc),
                      match_4[0]
                    },
                    map_rec_type_with_row_types(rec_flag, (function(rs, td) do
                            return --[[ Sig_type ]]Block.__(1, {
                                      td.typ_id,
                                      td.typ_type,
                                      rs
                                    });
                          end end), decls, match_4[1]),
                    match_4[2]
                  }; end end 
         if ___conditional___ == 2--[[ Psig_typext ]] then do
            match_5 = transl_type_extension(false, env, item.psig_loc, match[0]);
            tyext = match_5[0];
            match_6 = transl_sig(match_5[1], srem);
            rem_1 = match_6[1];
            constructors = List.filter((function(ext) do
                      partial_arg = ext.ext_id;
                      return not List.exists((function(param) do
                                    return equal(partial_arg, param);
                                  end end), get_extension_constructors(rem_1));
                    end end))(tyext.tyext_constructors);
            return --[[ tuple ]]{
                    --[[ :: ]]{
                      mksig_1(--[[ Tsig_typext ]]Block.__(2, {tyext}), env, loc),
                      match_6[0]
                    },
                    map_ext((function(es, ext) do
                            return --[[ Sig_typext ]]Block.__(2, {
                                      ext.ext_id,
                                      ext.ext_type,
                                      es
                                    });
                          end end), constructors, rem_1),
                    match_6[2]
                  }; end end 
         if ___conditional___ == 3--[[ Psig_exception ]] then do
            match_7 = transl_exception(env, match[0]);
            ext = match_7[0];
            match_8 = transl_sig(match_7[1], srem);
            rem_2 = match_8[1];
            partial_arg_1 = ext.ext_id;
            shadowed = List.exists((function(param) do
                    return equal(partial_arg_1, param);
                  end end), get_extension_constructors(rem_2));
            return --[[ tuple ]]{
                    --[[ :: ]]{
                      mksig_1(--[[ Tsig_exception ]]Block.__(3, {ext}), env, loc),
                      match_8[0]
                    },
                    shadowed and rem_2 or --[[ :: ]]{
                        --[[ Sig_typext ]]Block.__(2, {
                            ext.ext_id,
                            ext.ext_type,
                            --[[ Text_exception ]]2
                          }),
                        rem_2
                      },
                    match_8[2]
                  }; end end 
         if ___conditional___ == 4--[[ Psig_module ]] then do
            pmd = match[0];
            check_name("module", module_names, pmd.pmd_name);
            tmty = transl_modtype_1(env, pmd.pmd_type);
            md_md_type = tmty.mty_type;
            md_md_attributes = pmd.pmd_attributes;
            md_md_loc = pmd.pmd_loc;
            md = do
              md_type: md_md_type,
              md_attributes: md_md_attributes,
              md_loc: md_md_loc
            end;
            match_9 = enter_module_declaration(undefined, pmd.pmd_name.txt, md, env);
            id = match_9[0];
            match_10 = transl_sig(match_9[1], srem);
            return --[[ tuple ]]{
                    --[[ :: ]]{
                      mksig_1(--[[ Tsig_module ]]Block.__(4, {do
                                md_id: id,
                                md_name: pmd.pmd_name,
                                md_type: tmty,
                                md_attributes: pmd.pmd_attributes,
                                md_loc: pmd.pmd_loc
                              end}), env, loc),
                      match_10[0]
                    },
                    --[[ :: ]]{
                      --[[ Sig_module ]]Block.__(3, {
                          id,
                          md,
                          --[[ Trec_not ]]0
                        }),
                      match_10[1]
                    },
                    match_10[2]
                  }; end end 
         if ___conditional___ == 5--[[ Psig_recmodule ]] then do
            sdecls_1 = match[0];
            List.iter((function(pmd) do
                    return check_name("module", module_names, pmd.pmd_name);
                  end end), sdecls_1);
            match_11 = transl_recmodule_modtypes(item.psig_loc, env, sdecls_1);
            decls_1 = match_11[0];
            match_12 = transl_sig(match_11[1], srem);
            return --[[ tuple ]]{
                    --[[ :: ]]{
                      mksig_1(--[[ Tsig_recmodule ]]Block.__(5, {decls_1}), env, loc),
                      match_12[0]
                    },
                    map_rec((function(rs, md) do
                            d_md_type = md.md_type.mty_type;
                            d_md_attributes = md.md_attributes;
                            d_md_loc = md.md_loc;
                            d = do
                              md_type: d_md_type,
                              md_attributes: d_md_attributes,
                              md_loc: d_md_loc
                            end;
                            return --[[ Sig_module ]]Block.__(3, {
                                      md.md_id,
                                      d,
                                      rs
                                    });
                          end end), decls_1, match_12[1]),
                    match_12[2]
                  }; end end 
         if ___conditional___ == 6--[[ Psig_modtype ]] then do
            match_13 = transl_modtype_decl(modtype_names, env, item.psig_loc, match[0]);
            match_14 = transl_sig(match_13[0], srem);
            return --[[ tuple ]]{
                    --[[ :: ]]{
                      mksig_1(--[[ Tsig_modtype ]]Block.__(6, {match_13[1]}), env, loc),
                      match_14[0]
                    },
                    --[[ :: ]]{
                      match_13[2],
                      match_14[1]
                    },
                    match_14[2]
                  }; end end 
         if ___conditional___ == 7--[[ Psig_open ]] then do
            match_15 = type_open_1(undefined, env, match[0]);
            match_16 = transl_sig(match_15[1], srem);
            return --[[ tuple ]]{
                    --[[ :: ]]{
                      mksig_1(--[[ Tsig_open ]]Block.__(7, {match_15[2]}), env, loc),
                      match_16[0]
                    },
                    match_16[1],
                    match_16[2]
                  }; end end 
         if ___conditional___ == 8--[[ Psig_include ]] then do
            sincl = match[0];
            smty = sincl.pincl_mod;
            tmty_1 = transl_modtype_1(env, smty);
            mty = tmty_1.mty_type;
            sg_1 = signature_2(identity, extract_sig(env, smty.pmty_loc, mty));
            partial_arg_2 = item.psig_loc;
            List.iter((function(param) do
                    return check_sig_item(type_names, module_names, modtype_names, partial_arg_2, param);
                  end end), sg_1);
            newenv = add_signature(sg_1, env);
            incl_incl_loc = sincl.pincl_loc;
            incl_incl_attributes = sincl.pincl_attributes;
            incl = do
              incl_mod: tmty_1,
              incl_type: sg_1,
              incl_loc: incl_incl_loc,
              incl_attributes: incl_incl_attributes
            end;
            match_17 = transl_sig(newenv, srem);
            rem_3 = match_17[1];
            return --[[ tuple ]]{
                    --[[ :: ]]{
                      mksig_1(--[[ Tsig_include ]]Block.__(8, {incl}), env, loc),
                      match_17[0]
                    },
                    Pervasives.$at(remove_duplicates(get_values(rem_3), get_extension_constructors(rem_3), sg_1), rem_3),
                    match_17[2]
                  }; end end 
         if ___conditional___ == 9--[[ Psig_class ]] then do
            cl = match[0];
            List.iter((function(param) do
                    return check_name("type", type_names, param.pci_name);
                  end end), cl);
            match_18 = class_descriptions(env, cl);
            classes = match_18[0];
            match_19 = transl_sig(match_18[1], srem);
            return --[[ tuple ]]{
                    --[[ :: ]]{
                      mksig_1(--[[ Tsig_class ]]Block.__(9, {List.map2((function(pcl, tcl) do
                                      return tcl[11];
                                    end end), cl, classes)}), env, loc),
                      match_19[0]
                    },
                    List.flatten(map_rec((function(rs, param) do
                                return --[[ :: ]]{
                                        --[[ Sig_class ]]Block.__(5, {
                                            param[0],
                                            param[2],
                                            rs
                                          }),
                                        --[[ :: ]]{
                                          --[[ Sig_class_type ]]Block.__(6, {
                                              param[3],
                                              param[4],
                                              rs
                                            }),
                                          --[[ :: ]]{
                                            --[[ Sig_type ]]Block.__(1, {
                                                param[5],
                                                param[6],
                                                rs
                                              }),
                                            --[[ :: ]]{
                                              --[[ Sig_type ]]Block.__(1, {
                                                  param[7],
                                                  param[8],
                                                  rs
                                                }),
                                              --[[ [] ]]0
                                            }
                                          }
                                        }
                                      };
                              end end), classes, --[[ :: ]]{
                              match_19[1],
                              --[[ [] ]]0
                            })),
                    match_19[2]
                  }; end end 
         if ___conditional___ == 10--[[ Psig_class_type ]] then do
            cl_1 = match[0];
            List.iter((function(param) do
                    return check_name("type", type_names, param.pci_name);
                  end end), cl_1);
            match_20 = class_type_declarations_2(env, cl_1);
            classes_1 = match_20[0];
            match_21 = transl_sig(match_20[1], srem);
            return --[[ tuple ]]{
                    --[[ :: ]]{
                      mksig_1(--[[ Tsig_class_type ]]Block.__(10, {List.map2((function(pcl, tcl) do
                                      return tcl[7];
                                    end end), cl_1, classes_1)}), env, loc),
                      match_21[0]
                    },
                    List.flatten(map_rec((function(rs, param) do
                                return --[[ :: ]]{
                                        --[[ Sig_class_type ]]Block.__(6, {
                                            param[0],
                                            param[2],
                                            rs
                                          }),
                                        --[[ :: ]]{
                                          --[[ Sig_type ]]Block.__(1, {
                                              param[3],
                                              param[4],
                                              rs
                                            }),
                                          --[[ :: ]]{
                                            --[[ Sig_type ]]Block.__(1, {
                                                param[5],
                                                param[6],
                                                rs
                                              }),
                                            --[[ [] ]]0
                                          }
                                        }
                                      };
                              end end), classes_1, --[[ :: ]]{
                              match_21[1],
                              --[[ [] ]]0
                            })),
                    match_21[2]
                  }; end end 
         if ___conditional___ == 11--[[ Psig_attribute ]] then do
            x = match[0];
            warning_attribute(--[[ :: ]]{
                  x,
                  --[[ [] ]]0
                });
            match_22 = transl_sig(env, srem);
            return --[[ tuple ]]{
                    --[[ :: ]]{
                      mksig_1(--[[ Tsig_attribute ]]Block.__(11, {x}), env, loc),
                      match_22[0]
                    },
                    match_22[1],
                    match_22[2]
                  }; end end 
         if ___conditional___ == 12--[[ Psig_extension ]] then do
            error({
              Error_forward_3,
              error_of_extension(match[0])
            }) end end 
        
      end
    end else do
      return --[[ tuple ]]{
              --[[ [] ]]0,
              --[[ [] ]]0,
              env
            };
    end end 
  end end;
  previous_saved_types = saved_types.contents;
  warning_enter_scope(--[[ () ]]0);
  match = transl_sig(in_signature(env), sg);
  sg_sig_items = match[0];
  sg_sig_type = match[1];
  sg_sig_final_env = match[2];
  sg_1 = do
    sig_items: sg_sig_items,
    sig_type: sg_sig_type,
    sig_final_env: sg_sig_final_env
  end;
  warning_leave_scope(--[[ () ]]0);
  saved_types.contents = --[[ :: ]]{
    --[[ Partial_signature ]]Block.__(5, {sg_1}),
    previous_saved_types
  };
  return sg_1;
end end

function transl_modtype_decl(modtype_names, env, loc, param) do
  pmtd_loc = param.pmtd_loc;
  pmtd_attributes = param.pmtd_attributes;
  pmtd_name = param.pmtd_name;
  check_name("module type", modtype_names, pmtd_name);
  tmty = may_map((function(param) do
          return transl_modtype_1(env, param);
        end end), param.pmtd_type);
  decl_mtd_type = may_map((function(t) do
          return t.mty_type;
        end end), tmty);
  decl = do
    mtd_type: decl_mtd_type,
    mtd_attributes: pmtd_attributes,
    mtd_loc: pmtd_loc
  end;
  match = enter_modtype(pmtd_name.txt, decl, env);
  id = match[0];
  mtd = do
    mtd_id: id,
    mtd_name: pmtd_name,
    mtd_type: tmty,
    mtd_attributes: pmtd_attributes,
    mtd_loc: pmtd_loc
  end;
  return --[[ tuple ]]{
          match[1],
          mtd,
          --[[ Sig_modtype ]]Block.__(4, {
              id,
              decl
            })
        };
end end

function transl_recmodule_modtypes(loc, env, sdecls) do
  make_env = function(curr) do
    return List.fold_left((function(env, param) do
                  return add_module_1(true, param[0], param[2], env);
                end end), env, curr);
  end end;
  make_env2 = function(curr) do
    return List.fold_left((function(env, param) do
                  return add_module_1(true, param[0], param[2].mty_type, env);
                end end), env, curr);
  end end;
  transition = function(env_c, curr) do
    return List.map2((function(pmd, param) do
                  return --[[ tuple ]]{
                          param[0],
                          param[1],
                          transl_modtype_1(env_c, pmd.pmd_type)
                        };
                end end), sdecls, curr);
  end end;
  ids = List.map((function(x) do
          return create(x.pmd_name.txt);
        end end), sdecls);
  approx_env = List.fold_left((function(env, id) do
          dummy = --[[ Mty_ident ]]Block.__(0, {--[[ Pident ]]Block.__(0, {create("#recmod#")})});
          return add_module_1(true, id, dummy, env);
        end end), env, ids);
  init = List.map2((function(id, pmd) do
          return --[[ tuple ]]{
                  id,
                  pmd.pmd_name,
                  approx_modtype(approx_env, pmd.pmd_type)
                };
        end end), ids, sdecls);
  env0 = make_env(init);
  dcl1 = transition(env0, init);
  env1 = make_env2(dcl1);
  check_recmod_typedecls(env1, sdecls, dcl1);
  dcl2 = transition(env1, dcl1);
  env2 = make_env2(dcl2);
  check_recmod_typedecls(env2, sdecls, dcl2);
  dcl2_1 = List.map2((function(pmd, param) do
          return do
                  md_id: param[0],
                  md_name: param[1],
                  md_type: param[2],
                  md_attributes: pmd.pmd_attributes,
                  md_loc: pmd.pmd_loc
                end;
        end end), sdecls, dcl2);
  return --[[ tuple ]]{
          dcl2_1,
          env2
        };
end end

function simplify_signature(sg) do
  aux = function(param) do
    if (param) then do
      component = param[0];
      local ___conditional___=(component.tag | 0);
      do
         if ___conditional___ == 0--[[ Sig_value ]] then do
            k = aux(param[1]);
            val_names = k[1];
            name = component[0].name;
            if (mem_7(name, val_names)) then do
              return k;
            end else do
              return --[[ tuple ]]{
                      --[[ :: ]]{
                        component,
                        k[0]
                      },
                      add_14(name, val_names),
                      k[2]
                    };
            end end  end end 
         if ___conditional___ == 2--[[ Sig_typext ]] then do
            k_1 = aux(param[1]);
            ext_names = k_1[2];
            val_names_1 = k_1[1];
            sg = k_1[0];
            name_1 = component[0].name;
            if (mem_7(name_1, ext_names)) then do
              if (component[2] ~= 0 or not sg) then do
                return k_1;
              end else do
                match = sg[0];
                if (match.tag == --[[ Sig_typext ]]2 and match[2] == 1) then do
                  return --[[ tuple ]]{
                          --[[ :: ]]{
                            --[[ Sig_typext ]]Block.__(2, {
                                match[0],
                                match[1],
                                --[[ Text_first ]]0
                              }),
                            sg[1]
                          },
                          val_names_1,
                          ext_names
                        };
                end else do
                  return k_1;
                end end 
              end end 
            end else do
              return --[[ tuple ]]{
                      --[[ :: ]]{
                        component,
                        sg
                      },
                      val_names_1,
                      add_14(name_1, ext_names)
                    };
            end end  end end 
        match_1 = aux(param[1]);
          return --[[ tuple ]]{
                  --[[ :: ]]{
                    component,
                    match_1[0]
                  },
                  match_1[1],
                  match_1[2]
                };
          
      end
    end else do
      return --[[ tuple ]]{
              --[[ [] ]]0,
              --[[ Empty ]]0,
              --[[ Empty ]]0
            };
    end end 
  end end;
  return aux(sg)[0];
end end

Not_a_path = Caml_exceptions.create("Ocaml_typedtree_test.Typemod.Not_a_path");

function path_of_module(_mexp) do
  while(true) do
    mexp = _mexp;
    match = mexp.mod_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ == 0--[[ Tmod_ident ]] then do
          return match[0]; end end 
       if ___conditional___ == 3--[[ Tmod_apply ]] then do
          if (applicative_functors.contents) then do
            return --[[ Papply ]]Block.__(2, {
                      path_of_module(match[0]),
                      path_of_module(match[1])
                    });
          end else do
            error(Not_a_path)
          end end  end end 
       if ___conditional___ == 4--[[ Tmod_constraint ]] then do
          _mexp = match[0];
          ::continue:: ; end end 
      error(Not_a_path)
        
    end
  end;
end end

function path_of_module_1(mexp) do
  xpcall(function() do
    return path_of_module(mexp);
  end end,function(exn) do
    if (exn == Not_a_path) then do
      return ;
    end else do
      error(exn)
    end end 
  end end)
end end

function closed_modtype(_param) do
  while(true) do
    param = _param;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ == 1--[[ Mty_signature ]] then do
          return List.for_all(closed_signature_item, param[0]); end end 
       if ___conditional___ == 2--[[ Mty_functor ]] then do
          _param = param[2];
          ::continue:: ; end end 
       if ___conditional___ == 0--[[ Mty_ident ]]
       or ___conditional___ == 3--[[ Mty_alias ]] then do
          return true; end end 
      
    end
  end;
end end

function closed_signature_item(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ == 0--[[ Sig_value ]] then do
        return closed_schema(param[1].val_type); end end 
     if ___conditional___ == 3--[[ Sig_module ]] then do
        return closed_modtype(param[1].md_type); end end 
    return true;
      
  end
end end

function anchor_submodule(name, anchor) do
  if (anchor ~= undefined) then do
    return --[[ Pdot ]]Block.__(1, {
              anchor,
              name,
              -1
            });
  end
   end 
end end

function enrich_type_decls(anchor, decls, oldenv, newenv) do
  if (anchor ~= undefined) then do
    p = anchor;
    return List.fold_left((function(e, info) do
                  id = info.typ_id;
                  info$prime = enrich_typedecl(oldenv, --[[ Pdot ]]Block.__(1, {
                          p,
                          id.name,
                          -1
                        }), info.typ_type);
                  return add_type_1(true, id, info$prime, e);
                end end), oldenv, decls);
  end else do
    return newenv;
  end end 
end end

function enrich_module_type(anchor, name, mty, env) do
  if (anchor ~= undefined) then do
    return enrich_modtype(env, --[[ Pdot ]]Block.__(1, {
                  anchor,
                  name,
                  -1
                }), mty);
  end else do
    return mty;
  end end 
end end

function check_recmodule_inclusion(env, bindings) do
  subst_and_strengthen = function(env, s, id, mty) do
    return strengthen_1(env, modtype(s, mty), module_path(s, --[[ Pident ]]Block.__(0, {id})));
  end end;
  _first_time = true;
  _n = List.length(bindings);
  _env = env;
  _s = identity;
  while(true) do
    s = _s;
    env_1 = _env;
    n = _n;
    first_time = _first_time;
    if (n > 0) then do
      bindings1 = List.map((function(param) do
              id = param[0];
              return --[[ tuple ]]{
                      id,
                      rename(id),
                      param[4]
                    };
            end end), bindings);
      env$prime = List.fold_left((function(first_time,s)do
          return function (env, param) do
            mty_actual = param[2];
            mty_actual$prime = first_time and mty_actual or subst_and_strengthen(env, s, param[0], mty_actual);
            return add_module_1(false, param[1], mty_actual$prime, env);
          end end
          end end)(first_time,s), env_1, bindings1);
      s$prime = List.fold_left((function(s, param) do
              return add_module(param[0], --[[ Pident ]]Block.__(0, {param[1]}), s);
            end end), identity, bindings1);
      _s = s$prime;
      _env = env$prime;
      _n = n - 1 | 0;
      _first_time = false;
      ::continue:: ;
    end else do
      check_inclusion = (function(env_1,s)do
      return function check_inclusion(param) do
        modl = param[3];
        mty_decl = param[2];
        id = param[0];
        mty_decl$prime = modtype(s, mty_decl.mty_type);
        mty_actual$prime = subst_and_strengthen(env_1, s, id, param[4]);
        coercion;
        xpcall(function() do
          coercion = modtypes_1(env_1, mty_actual$prime, mty_decl$prime);
        end end,function(raw_exn) do
          exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn[0] == __Error_5) then do
            error({
              __Error_10,
              modl.mod_loc,
              env_1,
              --[[ Not_included ]]Block.__(1, {exn[1]})
            })
          end
           end 
          error(exn)
        end end)
        modl$prime_mod_desc = --[[ Tmod_constraint ]]Block.__(4, {
            modl,
            mty_decl.mty_type,
            --[[ Tmodtype_explicit ]]{mty_decl},
            coercion
          });
        modl$prime_mod_loc = modl.mod_loc;
        modl$prime_mod_type = mty_decl.mty_type;
        modl$prime = do
          mod_desc: modl$prime_mod_desc,
          mod_loc: modl$prime_mod_loc,
          mod_type: modl$prime_mod_type,
          mod_env: env_1,
          mod_attributes: --[[ [] ]]0
        end;
        return do
                mb_id: id,
                mb_name: param[1],
                mb_expr: modl$prime,
                mb_attributes: param[5],
                mb_loc: param[6]
              end;
      end end
      end end)(env_1,s);
      return List.map(check_inclusion, bindings);
    end end 
  end;
end end

function package_constraints(env, loc, mty, constrs) do
  if (constrs == --[[ [] ]]0) then do
    return mty;
  end else do
    sg = extract_sig(env, loc, mty);
    sg$prime = List.map((function(item) do
            local ___conditional___=(item.tag | 0);
            do
               if ___conditional___ == 1--[[ Sig_type ]] then do
                  td = item[1];
                  if (td.type_params) then do
                    return item;
                  end else do
                    id = item[0];
                    if (List.mem_assoc(--[[ :: ]]{
                            id.name,
                            --[[ [] ]]0
                          }, constrs)) then do
                      ty = List.assoc(--[[ :: ]]{
                            id.name,
                            --[[ [] ]]0
                          }, constrs);
                      return --[[ Sig_type ]]Block.__(1, {
                                id,
                                do
                                  type_params: td.type_params,
                                  type_arity: td.type_arity,
                                  type_kind: td.type_kind,
                                  type_private: td.type_private,
                                  type_manifest: ty,
                                  type_variance: td.type_variance,
                                  type_newtype_level: td.type_newtype_level,
                                  type_loc: td.type_loc,
                                  type_attributes: td.type_attributes
                                end,
                                item[2]
                              });
                    end else do
                      return item;
                    end end 
                  end end  end end 
               if ___conditional___ == 3--[[ Sig_module ]] then do
                  md = item[1];
                  id_1 = item[0];
                  aux = function(_param) do
                    while(true) do
                      param = _param;
                      if (param) then do
                        match = param[0];
                        match_1 = match[0];
                        if (match_1) then do
                          l = match_1[1];
                          if (l) then do
                            if (match_1[0] == id_1.name) then do
                              return --[[ :: ]]{
                                      --[[ tuple ]]{
                                        l,
                                        match[1]
                                      },
                                      aux(param[1])
                                    };
                            end else do
                              _param = param[1];
                              ::continue:: ;
                            end end 
                          end else do
                            _param = param[1];
                            ::continue:: ;
                          end end 
                        end else do
                          _param = param[1];
                          ::continue:: ;
                        end end 
                      end else do
                        return --[[ [] ]]0;
                      end end 
                    end;
                  end end;
                  md_md_type = package_constraints(env, loc, md.md_type, aux(constrs));
                  md_md_attributes = md.md_attributes;
                  md_md_loc = md.md_loc;
                  md_1 = do
                    md_type: md_md_type,
                    md_attributes: md_md_attributes,
                    md_loc: md_md_loc
                  end;
                  return --[[ Sig_module ]]Block.__(3, {
                            id_1,
                            md_1,
                            item[2]
                          }); end end 
              return item;
                
            end
          end end), sg);
    return --[[ Mty_signature ]]Block.__(1, {sg$prime});
  end end 
end end

function modtype_of_package(env, loc, p, nl, tl) do
  xpcall(function() do
    match = find_modtype(p, env).mtd_type;
    exit = 0;
    if (match ~= undefined and nl ~= --[[ [] ]]0) then do
      return package_constraints(env, loc, match, List.combine(List.map(flatten, nl), tl));
    end else do
      exit = 1;
    end end 
    if (exit == 1) then do
      if (nl == --[[ [] ]]0) then do
        return --[[ Mty_ident ]]Block.__(0, {p});
      end else do
        error({
          __Error_10,
          loc,
          env,
          --[[ Signature_expected ]]0
        })
      end end 
    end
     end 
  end end,function(exn) do
    if (exn == Caml_builtin_exceptions.not_found) then do
      error = --[[ Unbound_modtype ]]Block.__(22, {lid_of_path(undefined, p)});
      error({
        __Error_6,
        loc,
        env,
        error
      })
    end else do
      error(exn)
    end end 
  end end)
end end

function package_subtype_1(env, p1, nl1, tl1, p2, nl2, tl2) do
  mkmty = function(p, nl, tl) do
    ntl = List.filter((function(param) do
              return free_variables_1(undefined, param[1]) == --[[ [] ]]0;
            end end))(List.combine(nl, tl));
    match = List.split(ntl);
    return modtype_of_package(env, none, p, match[0], match[1]);
  end end;
  mty1 = mkmty(p1, nl1, tl1);
  mty2 = mkmty(p2, nl2, tl2);
  xpcall(function() do
    return modtypes_1(env, mty1, mty2) == --[[ Tcoerce_none ]]0;
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == __Error_5) then do
      return false;
    end else do
      error(exn)
    end end 
  end end)
end end

package_subtype.contents = package_subtype_1;

function wrap_constraint(env, arg, mty, explicit) do
  coercion;
  xpcall(function() do
    coercion = modtypes_1(env, arg.mod_type, mty);
  end end,function(raw_exn) do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == __Error_5) then do
      error({
        __Error_10,
        arg.mod_loc,
        env,
        --[[ Not_included ]]Block.__(1, {exn[1]})
      })
    end
     end 
    error(exn)
  end end)
  return do
          mod_desc: --[[ Tmod_constraint ]]Block.__(4, {
              arg,
              mty,
              explicit,
              coercion
            }),
          mod_loc: arg.mod_loc,
          mod_type: mty,
          mod_env: env,
          mod_attributes: --[[ [] ]]0
        end;
end end

function type_module_1(aliasOpt, sttn, funct_body, anchor, env, smod) do
  alias = aliasOpt ~= undefined and aliasOpt or false;
  match = smod.pmod_desc;
  local ___conditional___=(match.tag | 0);
  do
     if ___conditional___ == 0--[[ Pmod_ident ]] then do
        lid = match[0];
        path = lookup_module_1(not alias, env, smod.pmod_loc, lid.txt);
        md_mod_desc = --[[ Tmod_ident ]]Block.__(0, {
            path,
            lid
          });
        md_mod_loc = smod.pmod_loc;
        md_mod_type = --[[ Mty_alias ]]Block.__(3, {path});
        md_mod_attributes = smod.pmod_attributes;
        md = do
          mod_desc: md_mod_desc,
          mod_loc: md_mod_loc,
          mod_type: md_mod_type,
          mod_env: env,
          mod_attributes: md_mod_attributes
        end;
        node;
        if (alias and not is_functor_arg(path, env)) then do
          add_required_global(head(path));
          node = md;
        end else do
          mty = find_module(false, path, env).md_type;
          exit = 0;
          if (mty.tag == --[[ Mty_alias ]]3 and not alias) then do
            p1 = normalize_path_1(smod.pmod_loc, env, mty[0]);
            mty_1 = expand_module_alias(env, --[[ [] ]]0, p1);
            node = do
              mod_desc: --[[ Tmod_constraint ]]Block.__(4, {
                  md,
                  mty_1,
                  --[[ Tmodtype_implicit ]]0,
                  --[[ Tcoerce_alias ]]Block.__(3, {
                      p1,
                      --[[ Tcoerce_none ]]0
                    })
                }),
              mod_loc: md_mod_loc,
              mod_type: sttn and strengthen_1(env, mty_1, p1) or mty_1,
              mod_env: env,
              mod_attributes: md_mod_attributes
            end;
          end else do
            exit = 1;
          end end 
          if (exit == 1) then do
            mty_2 = sttn and strengthen_1(env, mty, path) or mty;
            node = do
              mod_desc: md_mod_desc,
              mod_loc: md_mod_loc,
              mod_type: mty_2,
              mod_env: env,
              mod_attributes: md_mod_attributes
            end;
          end
           end 
        end end 
        record_2(--[[ Ti_mod ]]Block.__(3, {node}));
        return node; end end 
     if ___conditional___ == 1--[[ Pmod_structure ]] then do
        match_1 = type_structure(undefined, funct_body, anchor, env, match[0], smod.pmod_loc);
        sg = match_1[1];
        node_mod_desc = --[[ Tmod_structure ]]Block.__(1, {match_1[0]});
        node_mod_loc = smod.pmod_loc;
        node_mod_type = --[[ Mty_signature ]]Block.__(1, {sg});
        node_mod_attributes = smod.pmod_attributes;
        node_1 = do
          mod_desc: node_mod_desc,
          mod_loc: node_mod_loc,
          mod_type: node_mod_type,
          mod_env: env,
          mod_attributes: node_mod_attributes
        end;
        record_2(--[[ Ti_mod ]]Block.__(3, {node_1}));
        sg$prime = simplify_signature(sg);
        if (List.length(sg$prime) == List.length(sg)) then do
          return node_1;
        end else do
          return wrap_constraint(implicit_coercion(env), node_1, --[[ Mty_signature ]]Block.__(1, {sg$prime}), --[[ Tmodtype_implicit ]]0);
        end end  end end 
     if ___conditional___ == 2--[[ Pmod_functor ]] then do
        name = match[0];
        mty_3 = may_map((function(param) do
                return transl_modtype_1(env, param);
              end end), match[1]);
        ty_arg = may_map((function(m) do
                return m.mty_type;
              end end), mty_3);
        match_2 = ty_arg ~= undefined and --[[ tuple ]]{
            enter_module(true, name.txt, ty_arg, env),
            true
          } or --[[ tuple ]]{
            --[[ tuple ]]{
              create("*"),
              env
            },
            false
          };
        match_3 = match_2[0];
        id = match_3[0];
        body = type_module_1(undefined, sttn, match_2[1], undefined, match_3[1], match[2]);
        node_mod_desc_1 = --[[ Tmod_functor ]]Block.__(2, {
            id,
            name,
            mty_3,
            body
          });
        node_mod_loc_1 = smod.pmod_loc;
        node_mod_type_1 = --[[ Mty_functor ]]Block.__(2, {
            id,
            ty_arg,
            body.mod_type
          });
        node_mod_attributes_1 = smod.pmod_attributes;
        node_2 = do
          mod_desc: node_mod_desc_1,
          mod_loc: node_mod_loc_1,
          mod_type: node_mod_type_1,
          mod_env: env,
          mod_attributes: node_mod_attributes_1
        end;
        record_2(--[[ Ti_mod ]]Block.__(3, {node_2}));
        return node_2; end end 
     if ___conditional___ == 3--[[ Pmod_apply ]] then do
        sarg = match[1];
        sfunct = match[0];
        arg = type_module_1(undefined, true, funct_body, undefined, env, sarg);
        path_1 = path_of_module_1(arg);
        funct = type_module_1(undefined, sttn and path_1 ~= undefined, funct_body, undefined, env, sfunct);
        mty_functor = scrape_alias(env, undefined, funct.mod_type);
        if (mty_functor.tag == --[[ Mty_functor ]]2) then do
          mty_res = mty_functor[2];
          mty_param = mty_functor[1];
          param = mty_functor[0];
          generative = mty_param == undefined;
          mty_param_1 = default_mty(mty_param);
          if (generative) then do
            if (Caml_obj.caml_notequal(sarg.pmod_desc, --[[ Pmod_structure ]]Block.__(1, {--[[ [] ]]0}))) then do
              error({
                __Error_10,
                sfunct.pmod_loc,
                env,
                --[[ Apply_generative ]]4
              })
            end
             end 
            if (funct_body and contains_type_1(env, funct.mod_type)) then do
              error({
                __Error_10,
                smod.pmod_loc,
                env,
                --[[ Not_allowed_in_functor_body ]]1
              })
            end
             end 
          end
           end 
          coercion;
          xpcall(function() do
            coercion = modtypes_1(env, arg.mod_type, mty_param_1);
          end end,function(raw_exn) do
            exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn[0] == __Error_5) then do
              error({
                __Error_10,
                sarg.pmod_loc,
                env,
                --[[ Not_included ]]Block.__(1, {exn[1]})
              })
            end
             end 
            error(exn)
          end end)
          mty_appl;
          if (path_1 ~= undefined) then do
            mty_appl = modtype(add_module(param, path_1, identity), mty_res);
          end else if (generative) then do
            mty_appl = mty_res;
          end else do
            xpcall(function() do
              mty_appl = nondep_supertype(add_module_1(true, param, arg.mod_type, env), param, mty_res);
            end end,function(exn_1) do
              if (exn_1 == Caml_builtin_exceptions.not_found) then do
                error({
                  __Error_10,
                  smod.pmod_loc,
                  env,
                  --[[ Cannot_eliminate_dependency ]]Block.__(2, {mty_functor})
                })
              end
               end 
              error(exn_1)
            end end)
          end end  end 
          node_mod_desc_2 = --[[ Tmod_apply ]]Block.__(3, {
              funct,
              arg,
              coercion
            });
          node_mod_loc_2 = smod.pmod_loc;
          node_mod_attributes_2 = smod.pmod_attributes;
          node_3 = do
            mod_desc: node_mod_desc_2,
            mod_loc: node_mod_loc_2,
            mod_type: mty_appl,
            mod_env: env,
            mod_attributes: node_mod_attributes_2
          end;
          record_2(--[[ Ti_mod ]]Block.__(3, {node_3}));
          return node_3;
        end else do
          error({
            __Error_10,
            sfunct.pmod_loc,
            env,
            --[[ Cannot_apply ]]Block.__(0, {funct.mod_type})
          })
        end end  end end 
     if ___conditional___ == 4--[[ Pmod_constraint ]] then do
        arg_1 = type_module_1(alias, true, funct_body, anchor, env, match[0]);
        mty_4 = transl_modtype_1(env, match[1]);
        init = wrap_constraint(env, arg_1, mty_4.mty_type, --[[ Tmodtype_explicit ]]{mty_4});
        node_mod_desc_3 = init.mod_desc;
        node_mod_loc_3 = smod.pmod_loc;
        node_mod_type_2 = init.mod_type;
        node_mod_env = init.mod_env;
        node_mod_attributes_3 = smod.pmod_attributes;
        node_4 = do
          mod_desc: node_mod_desc_3,
          mod_loc: node_mod_loc_3,
          mod_type: node_mod_type_2,
          mod_env: node_mod_env,
          mod_attributes: node_mod_attributes_3
        end;
        record_2(--[[ Ti_mod ]]Block.__(3, {node_4}));
        return node_4; end end 
     if ___conditional___ == 5--[[ Pmod_unpack ]] then do
        if (principal.contents) then do
          begin_def(--[[ () ]]0);
        end
         end 
        exp = type_exp(env, match[0]);
        if (principal.contents) then do
          end_def(--[[ () ]]0);
          generalize_structure_1(current_level.contents, exp.exp_type);
        end
         end 
        match_4 = expand_head(env, exp.exp_type);
        match_5 = match_4.desc;
        mty_5;
        exit_1 = 0;
        if (typeof match_5 == "number") then do
          exit_1 = 1;
        end else do
          local ___conditional___=(match_5.tag | 0);
          do
             if ___conditional___ == 0--[[ Tvar ]] then do
                error({
                  __Error_7,
                  smod.pmod_loc,
                  env,
                  --[[ Cannot_infer_signature ]]3
                }) end end 
             if ___conditional___ == 11--[[ Tpackage ]] then do
                tl = match_5[2];
                if (List.exists((function(t) do
                          return free_variables_1(undefined, t) ~= --[[ [] ]]0;
                        end end), tl)) then do
                  error({
                    __Error_10,
                    smod.pmod_loc,
                    env,
                    --[[ Incomplete_packed_module ]]Block.__(13, {exp.exp_type})
                  })
                end
                 end 
                if (principal.contents and not generalizable(99999999, exp.exp_type)) then do
                  prerr_warning(smod.pmod_loc, --[[ Not_principal ]]Block.__(8, {"this module unpacking"}));
                end
                 end 
                mty_5 = modtype_of_package(env, smod.pmod_loc, match_5[0], match_5[1], tl); end else 
             end end
            exit_1 = 1;
              
          end
        end end 
        if (exit_1 == 1) then do
          error({
            __Error_10,
            smod.pmod_loc,
            env,
            --[[ Not_a_packed_module ]]Block.__(12, {exp.exp_type})
          })
        end
         end 
        if (funct_body and contains_type_1(env, mty_5)) then do
          error({
            __Error_10,
            smod.pmod_loc,
            env,
            --[[ Not_allowed_in_functor_body ]]1
          })
        end
         end 
        node_mod_desc_4 = --[[ Tmod_unpack ]]Block.__(5, {
            exp,
            mty_5
          });
        node_mod_loc_4 = smod.pmod_loc;
        node_mod_attributes_4 = smod.pmod_attributes;
        node_5 = do
          mod_desc: node_mod_desc_4,
          mod_loc: node_mod_loc_4,
          mod_type: mty_5,
          mod_env: env,
          mod_attributes: node_mod_attributes_4
        end;
        record_2(--[[ Ti_mod ]]Block.__(3, {node_5}));
        return node_5; end end 
     if ___conditional___ == 6--[[ Pmod_extension ]] then do
        error({
          Error_forward_3,
          error_of_extension(match[0])
        }) end end 
    
  end
end end

function type_structure(toplevelOpt, funct_body, anchor, env, sstr, scope) do
  toplevel = toplevelOpt ~= undefined and toplevelOpt or false;
  type_names = do
    contents: --[[ Empty ]]0
  end;
  module_names = do
    contents: --[[ Empty ]]0
  end;
  modtype_names = do
    contents: --[[ Empty ]]0
  end;
  type_str_item = function(env, srem, param) do
    loc = param.pstr_loc;
    desc = param.pstr_desc;
    local ___conditional___=(desc.tag | 0);
    do
       if ___conditional___ == 0--[[ Pstr_eval ]] then do
          expr = type_expression(env, desc[0]);
          return --[[ tuple ]]{
                  --[[ Tstr_eval ]]Block.__(0, {
                      expr,
                      desc[1]
                    }),
                  --[[ [] ]]0,
                  env
                }; end end 
       if ___conditional___ == 1--[[ Pstr_value ]] then do
          rec_flag = desc[0];
          scope_1;
          if (rec_flag) then do
            scope_1 = --[[ Idef ]]Block.__(1, {do
                  loc_start: loc.loc_start,
                  loc_end: scope.loc_end,
                  loc_ghost: scope.loc_ghost
                end});
          end else do
            start = srem and srem[0].pstr_loc.loc_start or loc.loc_end;
            scope_1 = --[[ Idef ]]Block.__(1, {do
                  loc_start: start,
                  loc_end: scope.loc_end,
                  loc_ghost: scope.loc_ghost
                end});
          end end 
          match = type_binding(env, rec_flag, desc[1], scope_1);
          newenv = match[1];
          defs = match[0];
          return --[[ tuple ]]{
                  --[[ Tstr_value ]]Block.__(1, {
                      rec_flag,
                      defs
                    }),
                  List.map((function(id) do
                          return --[[ Sig_value ]]Block.__(0, {
                                    id,
                                    find_value(--[[ Pident ]]Block.__(0, {id}), newenv)
                                  });
                        end end), let_bound_idents(defs)),
                  newenv
                }; end end 
       if ___conditional___ == 2--[[ Pstr_primitive ]] then do
          match_1 = transl_value_decl(env, loc, desc[0]);
          desc_1 = match_1[0];
          return --[[ tuple ]]{
                  --[[ Tstr_primitive ]]Block.__(2, {desc_1}),
                  --[[ :: ]]{
                    --[[ Sig_value ]]Block.__(0, {
                        desc_1.val_id,
                        desc_1.val_val
                      }),
                    --[[ [] ]]0
                  },
                  match_1[1]
                }; end end 
       if ___conditional___ == 3--[[ Pstr_type ]] then do
          sdecls = desc[0];
          rec_flag_1 = rec_flag_of_ptype_declarations(sdecls);
          List.iter((function(decl) do
                  return check_name("type", type_names, decl.ptype_name);
                end end), sdecls);
          match_2 = transl_type_decl(env, rec_flag_1, sdecls);
          decls = match_2[0];
          return --[[ tuple ]]{
                  --[[ Tstr_type ]]Block.__(3, {decls}),
                  map_rec_type_with_row_types(rec_flag_1, (function(rs, info) do
                          return --[[ Sig_type ]]Block.__(1, {
                                    info.typ_id,
                                    info.typ_type,
                                    rs
                                  });
                        end end), decls, --[[ [] ]]0),
                  enrich_type_decls(anchor, decls, env, match_2[1])
                }; end end 
       if ___conditional___ == 4--[[ Pstr_typext ]] then do
          match_3 = transl_type_extension(true, env, loc, desc[0]);
          tyext = match_3[0];
          return --[[ tuple ]]{
                  --[[ Tstr_typext ]]Block.__(4, {tyext}),
                  map_ext((function(es, ext) do
                          return --[[ Sig_typext ]]Block.__(2, {
                                    ext.ext_id,
                                    ext.ext_type,
                                    es
                                  });
                        end end), tyext.tyext_constructors, --[[ [] ]]0),
                  match_3[1]
                }; end end 
       if ___conditional___ == 5--[[ Pstr_exception ]] then do
          match_4 = transl_exception(env, desc[0]);
          ext = match_4[0];
          return --[[ tuple ]]{
                  --[[ Tstr_exception ]]Block.__(5, {ext}),
                  --[[ :: ]]{
                    --[[ Sig_typext ]]Block.__(2, {
                        ext.ext_id,
                        ext.ext_type,
                        --[[ Text_exception ]]2
                      }),
                    --[[ [] ]]0
                  },
                  match_4[1]
                }; end end 
       if ___conditional___ == 6--[[ Pstr_module ]] then do
          match_5 = desc[0];
          pmb_loc = match_5.pmb_loc;
          attrs = match_5.pmb_attributes;
          name = match_5.pmb_name;
          check_name("module", module_names, name);
          modl = type_module_1(true, true, funct_body, anchor_submodule(name.txt, anchor), env, match_5.pmb_expr);
          md_md_type = enrich_module_type(anchor, name.txt, modl.mod_type, env);
          md = do
            md_type: md_md_type,
            md_attributes: attrs,
            md_loc: pmb_loc
          end;
          match_6 = enter_module_declaration(undefined, name.txt, md, env);
          id = match_6[0];
          return --[[ tuple ]]{
                  --[[ Tstr_module ]]Block.__(6, {do
                        mb_id: id,
                        mb_name: name,
                        mb_expr: modl,
                        mb_attributes: attrs,
                        mb_loc: pmb_loc
                      end}),
                  --[[ :: ]]{
                    --[[ Sig_module ]]Block.__(3, {
                        id,
                        do
                          md_type: modl.mod_type,
                          md_attributes: attrs,
                          md_loc: pmb_loc
                        end,
                        --[[ Trec_not ]]0
                      }),
                    --[[ [] ]]0
                  },
                  match_6[1]
                }; end end 
       if ___conditional___ == 7--[[ Pstr_recmodule ]] then do
          sbind = List.map((function(mb) do
                  match = mb.pmb_expr.pmod_desc;
                  if (match.tag == --[[ Pmod_constraint ]]4) then do
                    return --[[ tuple ]]{
                            mb.pmb_name,
                            match[1],
                            match[0],
                            mb.pmb_attributes,
                            mb.pmb_loc
                          };
                  end else do
                    error({
                      __Error_10,
                      mb.pmb_expr.pmod_loc,
                      env,
                      --[[ Recursive_module_require_explicit_type ]]3
                    })
                  end end 
                end end), desc[0]);
          List.iter((function(param) do
                  return check_name("module", module_names, param[0]);
                end end), sbind);
          match_7 = transl_recmodule_modtypes(loc, env, List.map((function(param) do
                      return do
                              pmd_name: param[0],
                              pmd_type: param[1],
                              pmd_attributes: param[3],
                              pmd_loc: param[4]
                            end;
                    end end), sbind));
          newenv_1 = match_7[1];
          decls_1 = match_7[0];
          bindings1 = List.map2((function(param, param_1) do
                  id = param.md_id;
                  modl = type_module_1(undefined, true, funct_body, --[[ Pident ]]Block.__(0, {id}), newenv_1, param_1[2]);
                  mty$prime = enrich_module_type(anchor, id.name, modl.mod_type, newenv_1);
                  return --[[ tuple ]]{
                          id,
                          param_1[0],
                          param.md_type,
                          modl,
                          mty$prime,
                          param_1[3],
                          param_1[4]
                        };
                end end), decls_1, sbind);
          newenv_2 = List.fold_left((function(env, md) do
                  mdecl_md_type = md.md_type.mty_type;
                  mdecl_md_attributes = md.md_attributes;
                  mdecl_md_loc = md.md_loc;
                  mdecl = do
                    md_type: mdecl_md_type,
                    md_attributes: mdecl_md_attributes,
                    md_loc: mdecl_md_loc
                  end;
                  return add_module_declaration(undefined, md.md_id, mdecl, env);
                end end), env, decls_1);
          bindings2 = check_recmodule_inclusion(newenv_2, bindings1);
          return --[[ tuple ]]{
                  --[[ Tstr_recmodule ]]Block.__(7, {bindings2}),
                  map_rec((function(rs, mb) do
                          return --[[ Sig_module ]]Block.__(3, {
                                    mb.mb_id,
                                    do
                                      md_type: mb.mb_expr.mod_type,
                                      md_attributes: mb.mb_attributes,
                                      md_loc: mb.mb_loc
                                    end,
                                    rs
                                  });
                        end end), bindings2, --[[ [] ]]0),
                  newenv_2
                }; end end 
       if ___conditional___ == 8--[[ Pstr_modtype ]] then do
          match_8 = transl_modtype_decl(modtype_names, env, loc, desc[0]);
          return --[[ tuple ]]{
                  --[[ Tstr_modtype ]]Block.__(8, {match_8[1]}),
                  --[[ :: ]]{
                    match_8[2],
                    --[[ [] ]]0
                  },
                  match_8[0]
                }; end end 
       if ___conditional___ == 9--[[ Pstr_open ]] then do
          match_9 = type_open_1(toplevel, env, desc[0]);
          return --[[ tuple ]]{
                  --[[ Tstr_open ]]Block.__(9, {match_9[2]}),
                  --[[ [] ]]0,
                  match_9[1]
                }; end end 
       if ___conditional___ == 10--[[ Pstr_class ]] then do
          cl = desc[0];
          List.iter((function(param) do
                  return check_name("type", type_names, param.pci_name);
                end end), cl);
          match_10 = class_declarations_2(env, cl);
          classes = match_10[0];
          return --[[ tuple ]]{
                  --[[ Tstr_class ]]Block.__(10, {List.map((function(param) do
                              vf = param[2].cty_new == undefined and --[[ Virtual ]]0 or --[[ Concrete ]]1;
                              return --[[ tuple ]]{
                                      param[11],
                                      param[10],
                                      vf
                                    };
                            end end), classes)}),
                  List.flatten(map_rec((function(rs, param) do
                              return --[[ :: ]]{
                                      --[[ Sig_class ]]Block.__(5, {
                                          param[0],
                                          param[2],
                                          rs
                                        }),
                                      --[[ :: ]]{
                                        --[[ Sig_class_type ]]Block.__(6, {
                                            param[3],
                                            param[4],
                                            rs
                                          }),
                                        --[[ :: ]]{
                                          --[[ Sig_type ]]Block.__(1, {
                                              param[5],
                                              param[6],
                                              rs
                                            }),
                                          --[[ :: ]]{
                                            --[[ Sig_type ]]Block.__(1, {
                                                param[7],
                                                param[8],
                                                rs
                                              }),
                                            --[[ [] ]]0
                                          }
                                        }
                                      }
                                    };
                            end end), classes, --[[ [] ]]0)),
                  match_10[1]
                }; end end 
       if ___conditional___ == 11--[[ Pstr_class_type ]] then do
          cl_1 = desc[0];
          List.iter((function(param) do
                  return check_name("type", type_names, param.pci_name);
                end end), cl_1);
          match_11 = class_type_declarations_2(env, cl_1);
          classes_1 = match_11[0];
          return --[[ tuple ]]{
                  --[[ Tstr_class_type ]]Block.__(11, {List.map((function(param) do
                              return --[[ tuple ]]{
                                      param[0],
                                      param[1],
                                      param[7]
                                    };
                            end end), classes_1)}),
                  List.flatten(map_rec((function(rs, param) do
                              return --[[ :: ]]{
                                      --[[ Sig_class_type ]]Block.__(6, {
                                          param[0],
                                          param[2],
                                          rs
                                        }),
                                      --[[ :: ]]{
                                        --[[ Sig_type ]]Block.__(1, {
                                            param[3],
                                            param[4],
                                            rs
                                          }),
                                        --[[ :: ]]{
                                          --[[ Sig_type ]]Block.__(1, {
                                              param[5],
                                              param[6],
                                              rs
                                            }),
                                          --[[ [] ]]0
                                        }
                                      }
                                    };
                            end end), classes_1, --[[ [] ]]0)),
                  match_11[1]
                }; end end 
       if ___conditional___ == 12--[[ Pstr_include ]] then do
          sincl = desc[0];
          smodl = sincl.pincl_mod;
          modl_1 = type_module_1(undefined, true, funct_body, undefined, env, smodl);
          sg = signature_2(identity, extract_sig_open(env, smodl.pmod_loc, modl_1.mod_type));
          match_12 = modl_1.mod_desc;
          sg_1;
          if (match_12.tag) then do
            sg_1 = sg;
          end else do
            p = match_12[0];
            if (is_functor_arg(p, env)) then do
              sg_1 = sg;
            end else do
              add_required_global(head(p));
              pos = do
                contents: 0
              end;
              sg_1 = List.map((function(it) do
                      local ___conditional___=(it.tag | 0);
                      do
                         if ___conditional___ == 0--[[ Sig_value ]] then do
                            match = it[1].val_kind;
                            if (typeof match == "number" and match == 0) then do
                              pos.contents = pos.contents + 1 | 0;
                              return it;
                            end else do
                              return it;
                            end end  end end 
                         if ___conditional___ == 3--[[ Sig_module ]] then do
                            md = it[1];
                            id = it[0];
                            n = pos.contents;
                            pos.contents = pos.contents + 1 | 0;
                            return --[[ Sig_module ]]Block.__(3, {
                                      id,
                                      do
                                        md_type: --[[ Mty_alias ]]Block.__(3, {--[[ Pdot ]]Block.__(1, {
                                                p,
                                                id.name,
                                                n
                                              })}),
                                        md_attributes: md.md_attributes,
                                        md_loc: md.md_loc
                                      end,
                                      it[2]
                                    }); end end 
                         if ___conditional___ == 2--[[ Sig_typext ]]
                         or ___conditional___ == 5--[[ Sig_class ]] then do
                            pos.contents = pos.contents + 1 | 0;
                            return it; end end 
                        return it;
                          
                      end
                    end end), sg);
            end end 
          end end 
          List.iter((function(param) do
                  return check_sig_item(type_names, module_names, modtype_names, loc, param);
                end end), sg_1);
          new_env = add_signature(sg_1, env);
          incl_incl_loc = sincl.pincl_loc;
          incl_incl_attributes = sincl.pincl_attributes;
          incl = do
            incl_mod: modl_1,
            incl_type: sg_1,
            incl_loc: incl_incl_loc,
            incl_attributes: incl_incl_attributes
          end;
          return --[[ tuple ]]{
                  --[[ Tstr_include ]]Block.__(12, {incl}),
                  sg_1,
                  new_env
                }; end end 
       if ___conditional___ == 13--[[ Pstr_attribute ]] then do
          x = desc[0];
          warning_attribute(--[[ :: ]]{
                x,
                --[[ [] ]]0
              });
          return --[[ tuple ]]{
                  --[[ Tstr_attribute ]]Block.__(13, {x}),
                  --[[ [] ]]0,
                  env
                }; end end 
       if ___conditional___ == 14--[[ Pstr_extension ]] then do
          error({
            Error_forward_3,
            error_of_extension(desc[0])
          }) end end 
      
    end
  end end;
  type_struct = function(env, sstr) do
    init_def(currentstamp.contents);
    if (sstr) then do
      srem = sstr[1];
      pstr = sstr[0];
      previous_saved_types = saved_types.contents;
      match = type_str_item(env, srem, pstr);
      str_str_desc = match[0];
      str_str_loc = pstr.pstr_loc;
      str = do
        str_desc: str_str_desc,
        str_loc: str_str_loc,
        str_env: env
      end;
      saved_types.contents = --[[ :: ]]{
        --[[ Partial_structure_item ]]Block.__(1, {str}),
        previous_saved_types
      };
      match_1 = type_struct(match[2], srem);
      return --[[ tuple ]]{
              --[[ :: ]]{
                str,
                match_1[0]
              },
              Pervasives.$at(match[1], match_1[1]),
              match_1[2]
            };
    end else do
      return --[[ tuple ]]{
              --[[ [] ]]0,
              --[[ [] ]]0,
              env
            };
    end end 
  end end;
  if (annotations.contents) then do
    List.iter((function(param) do
            loc = param.pstr_loc;
            if (annotations.contents) then do
              phrases.contents = --[[ :: ]]{
                loc,
                phrases.contents
              };
              return --[[ () ]]0;
            end else do
              return 0;
            end end 
          end end), sstr);
  end
   end 
  previous_saved_types = saved_types.contents;
  warning_enter_scope(--[[ () ]]0);
  match = type_struct(env, sstr);
  final_env = match[2];
  sg = match[1];
  str_str_items = match[0];
  str = do
    str_items: str_str_items,
    str_type: sg,
    str_final_env: final_env
  end;
  warning_leave_scope(--[[ () ]]0);
  saved_types.contents = --[[ :: ]]{
    --[[ Partial_structure ]]Block.__(0, {str}),
    previous_saved_types
  };
  return --[[ tuple ]]{
          str,
          sg,
          final_env
        };
end end

function type_module_2(param, param_1) do
  return type_module_1(undefined, true, false, undefined, param, param_1);
end end

function type_structure_1(param, param_1, param_2) do
  return type_structure(undefined, false, undefined, param, param_1, param_2);
end end

function normalize_signature(env) do
  return (function(param) do
      return List.iter((function(param) do
                    env_1 = env;
                    param_1 = param;
                    local ___conditional___=(param_1.tag | 0);
                    do
                       if ___conditional___ == 0--[[ Sig_value ]] then do
                          return normalize_type(env_1, param_1[1].val_type); end end 
                       if ___conditional___ == 3--[[ Sig_module ]] then do
                          env_2 = env_1;
                          _param = param_1[1].md_type;
                          while(true) do
                            param_2 = _param;
                            local ___conditional___=(param_2.tag | 0);
                            do
                               if ___conditional___ == 1--[[ Mty_signature ]] then do
                                  return normalize_signature(env_2)(param_2[0]); end end 
                               if ___conditional___ == 2--[[ Mty_functor ]] then do
                                  _param = param_2[2];
                                  ::continue:: ; end end 
                               if ___conditional___ == 0--[[ Mty_ident ]]
                               or ___conditional___ == 3--[[ Mty_alias ]] then do
                                  return --[[ () ]]0; end end 
                              
                            end
                          end; end end 
                      return --[[ () ]]0;
                        
                    end
                  end end), param);
    end end);
end end

function type_module_type_of(env, smod) do
  match = smod.pmod_desc;
  tmty;
  if (match.tag) then do
    tmty = type_module_2(env, smod);
  end else do
    lid = match[0];
    match_1 = find_module_1(env, smod.pmod_loc, lid.txt);
    node_mod_desc = --[[ Tmod_ident ]]Block.__(0, {
        match_1[0],
        lid
      });
    node_mod_loc = smod.pmod_loc;
    node_mod_type = match_1[1].md_type;
    node_mod_attributes = smod.pmod_attributes;
    node = do
      mod_desc: node_mod_desc,
      mod_loc: node_mod_loc,
      mod_type: node_mod_type,
      mod_env: env,
      mod_attributes: node_mod_attributes
    end;
    record_2(--[[ Ti_mod ]]Block.__(3, {node}));
    tmty = node;
  end end 
  mty = tmty.mod_type;
  mty_1 = remove_aliases_1(env, mty);
  if (not closed_modtype(mty_1)) then do
    error({
      __Error_10,
      smod.pmod_loc,
      env,
      --[[ Non_generalizable_module ]]Block.__(9, {mty_1})
    })
  end
   end 
  return --[[ tuple ]]{
          tmty,
          mty_1
        };
end end

function type_package_1(env, m, p, nl, tl) do
  lv = current_level.contents;
  begin_def(--[[ () ]]0);
  set_current_time(lv);
  context = narrow(--[[ () ]]0);
  modl = type_module_2(env, m);
  init_def(currentstamp.contents);
  widen(context);
  match = modl.mod_desc;
  match_1;
  if (match.tag) then do
    match_2 = enter_module(true, "%M", modl.mod_type, env);
    match_1 = --[[ tuple ]]{
      --[[ Pident ]]Block.__(0, {match_2[0]}),
      match_2[1]
    };
  end else do
    match_1 = --[[ tuple ]]{
      match[0],
      env
    };
  end end 
  env_1 = match_1[1];
  mp = match_1[0];
  mkpath = function(mp, param) do
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ == 0--[[ Lident ]] then do
          return --[[ Pdot ]]Block.__(1, {
                    mp,
                    param[0],
                    -1
                  }); end end 
       if ___conditional___ == 1--[[ Ldot ]] then do
          return --[[ Pdot ]]Block.__(1, {
                    mkpath(mp, param[0]),
                    param[1],
                    -1
                  }); end end 
       if ___conditional___ == 2--[[ Lapply ]] then do
          error({
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "typemod.ml",
              1565,
              11
            }
          }) end end 
      
    end
  end end;
  tl$prime = List.map((function(name) do
          return newty2(100000000, --[[ Tconstr ]]Block.__(3, {
                        mkpath(mp, name),
                        --[[ [] ]]0,
                        do
                          contents: --[[ Mnil ]]0
                        end
                      }));
        end end), nl);
  end_def(--[[ () ]]0);
  if (nl == --[[ [] ]]0) then do
    return --[[ tuple ]]{
            wrap_constraint(env_1, modl, --[[ Mty_ident ]]Block.__(0, {p}), --[[ Tmodtype_implicit ]]0),
            --[[ [] ]]0
          };
  end else do
    mty = modtype_of_package(env_1, modl.mod_loc, p, nl, tl$prime);
    List.iter2((function(n, ty) do
            xpcall(function() do
              return unify_2(env_1, ty, newvar(undefined, --[[ () ]]0));
            end end,function(raw_exn) do
              exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn[0] == Unify) then do
                error({
                  __Error_10,
                  m.pmod_loc,
                  env_1,
                  --[[ Scoping_pack ]]Block.__(14, {
                      n,
                      ty
                    })
                })
              end
               end 
              error(exn)
            end end)
          end end), nl, tl$prime);
    return --[[ tuple ]]{
            wrap_constraint(env_1, modl, mty, --[[ Tmodtype_implicit ]]0),
            tl$prime
          };
  end end 
end end

type_module.contents = type_module_2;

transl_modtype_longident.contents = transl_modtype_longident_1;

transl_modtype.contents = transl_modtype_1;

type_open.contents = (function(param, param_1, param_2, param_3) do
    return type_open_(undefined, param, param_1, param_2, param_3);
  end end);

type_package.contents = type_package_1;

type_module_type_of_fwd.contents = type_module_type_of;

function type_implementation_more(sourcefile, outputprefix, modulename, initial_env, ast) do
  clear(--[[ () ]]0);
  xpcall(function() do
    delayed_checks.contents = --[[ [] ]]0;
    required_globals.contents = --[[ [] ]]0;
    Curry._2(newrecord_1.structure, newrecord_1, ast);
    match = type_structure_1(initial_env, ast, in_file(sourcefile));
    finalenv = match[2];
    sg = match[1];
    str = match[0];
    simple_sg = simplify_signature(sg);
    if (print_types.contents) then do
      wrap_printing_env(initial_env, (function(param) do
              return Curry._2(Format.fprintf(Format.std_formatter, --[[ Format ]]{
                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Flush_newline ]]4,
                                      --[[ End_of_format ]]0
                                    })}),
                              "%a@."
                            }), signature_3, simple_sg);
            end end));
      return --[[ tuple ]]{
              str,
              --[[ Tcoerce_none ]]0,
              finalenv,
              simple_sg
            };
    end else do
      sourceintf = chop_extension_if_any(sourcefile) .. interface_suffix.contents;
      mli_status = assume_no_mli.contents;
      if (mli_status == --[[ Mli_na ]]0 and Caml_external_polyfill.resolve("caml_sys_file_exists")(sourceintf) or mli_status == --[[ Mli_exists ]]1) then do
        intf_file;
        xpcall(function() do
          intf_file = find_in_path_uncap(load_path.contents, modulename .. ".cmi");
        end end,function(exn) do
          if (exn == Caml_builtin_exceptions.not_found) then do
            error({
              __Error_10,
              in_file(sourcefile),
              empty,
              --[[ Interface_not_compiled ]]Block.__(11, {sourceintf})
            })
          end
           end 
          error(exn)
        end end)
        dclsig = read_signature(modulename, intf_file);
        coercion = compunit(initial_env, sourcefile, sg, intf_file, dclsig);
        force_delayed_checks(--[[ () ]]0);
        save_cmt(outputprefix .. ".cmt", modulename, --[[ Implementation ]]Block.__(1, {str}), sourcefile, initial_env, undefined);
        return --[[ tuple ]]{
                str,
                coercion,
                finalenv,
                dclsig
              };
      end else do
        List.iter((function(param) do
                env = finalenv;
                str = param;
                match = str.str_desc;
                local ___conditional___=(match.tag | 0);
                do
                   if ___conditional___ == 1--[[ Tstr_value ]] then do
                      return List.iter((function(param) do
                                    exp = param.vb_expr;
                                    if (closed_schema(exp.exp_type)) then do
                                      return 0;
                                    end else do
                                      error({
                                        __Error_10,
                                        exp.exp_loc,
                                        env,
                                        --[[ Non_generalizable ]]Block.__(7, {exp.exp_type})
                                      })
                                    end end 
                                  end end), match[1]); end end 
                   if ___conditional___ == 6--[[ Tstr_module ]] then do
                      md = match[0].mb_expr;
                      if (closed_modtype(md.mod_type)) then do
                        return 0;
                      end else do
                        error({
                          __Error_10,
                          md.mod_loc,
                          env,
                          --[[ Non_generalizable_module ]]Block.__(9, {md.mod_type})
                        })
                      end end  end end 
                  return --[[ () ]]0;
                    
                end
              end end), str.str_items);
        normalize_signature(finalenv)(simple_sg);
        coercion_1 = compunit(initial_env, sourcefile, sg, "(inferred signature)", simple_sg);
        force_delayed_checks(--[[ () ]]0);
        if (not dont_write_files.contents) then do
          sg_1 = save_signature(simple_sg, modulename, outputprefix .. ".cmi");
          save_cmt(outputprefix .. ".cmt", modulename, --[[ Implementation ]]Block.__(1, {str}), sourcefile, initial_env, sg_1);
        end
         end 
        return --[[ tuple ]]{
                str,
                coercion_1,
                finalenv,
                simple_sg
              };
      end end 
    end end 
  end end,function(e) do
    save_cmt(outputprefix .. ".cmt", modulename, --[[ Partial_implementation ]]Block.__(3, {__Array.of_list(saved_types.contents)}), sourcefile, initial_env, undefined);
    error(e)
  end end)
end end

function type_implementation(sourcefile, outputprefix, modulename, initial_env, ast) do
  match = type_implementation_more(sourcefile, outputprefix, modulename, initial_env, ast);
  return --[[ tuple ]]{
          match[0],
          match[1]
        };
end end

register_error_of_exn((function(param) do
        if (param[0] == __Error_10) then do
          env = param[2];
          return error_of_printer(param[1], (function(param, param_1) do
                        env_1 = env;
                        ppf = param;
                        err = param_1;
                        return wrap_printing_env(env_1, (function(param) do
                                      ppf_1 = ppf;
                                      param_1 = err;
                                      if (typeof param_1 == "number") then do
                                        local ___conditional___=(param_1);
                                        do
                                           if ___conditional___ == 0--[[ Signature_expected ]] then do
                                              return Format.fprintf(ppf_1, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "This module type is not a signature",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "This module type is not a signature"
                                                        }); end end 
                                           if ___conditional___ == 1--[[ Not_allowed_in_functor_body ]] then do
                                              return Curry._1(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "This expression creates fresh types.",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ String ]]Block.__(2, {
                                                                              --[[ No_padding ]]0,
                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Close_box ]]0,
                                                                                  --[[ End_of_format ]]0
                                                                                })
                                                                            })
                                                                        })
                                                                    })
                                                                }),
                                                              "@[This expression creates fresh types.@ %s@]"
                                                            }), "It is not allowed inside applicative functors."); end end 
                                           if ___conditional___ == 2--[[ With_need_typeconstr ]] then do
                                              return Format.fprintf(ppf_1, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "Only type constructors with identical parameters can be substituted.",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "Only type constructors with identical parameters can be substituted."
                                                        }); end end 
                                           if ___conditional___ == 3--[[ Recursive_module_require_explicit_type ]] then do
                                              return Format.fprintf(ppf_1, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "Recursive modules require an explicit module type.",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "Recursive modules require an explicit module type."
                                                        }); end end 
                                           if ___conditional___ == 4--[[ Apply_generative ]] then do
                                              return Format.fprintf(ppf_1, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "This is a generative functor. It can only be applied to ()",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "This is a generative functor. It can only be applied to ()"
                                                        }); end end 
                                          
                                        end
                                      end else do
                                        local ___conditional___=(param_1.tag | 0);
                                        do
                                           if ___conditional___ == 0--[[ Cannot_apply ]] then do
                                              return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "This module is not a functor; it has type",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Close_box ]]0,
                                                                                  --[[ End_of_format ]]0
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[This module is not a functor; it has type@ %a@]"
                                                            }), modtype_1, param_1[0]); end end 
                                           if ___conditional___ == 1--[[ Not_included ]] then do
                                              return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "<v>",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "<v>"
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "Signature mismatch:",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Close_box ]]0,
                                                                                  --[[ End_of_format ]]0
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[<v>Signature mismatch:@ %a@]"
                                                            }), report_error_4, param_1[0]); end end 
                                           if ___conditional___ == 2--[[ Cannot_eliminate_dependency ]] then do
                                              return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "This functor has type",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Break ]]Block.__(0, {
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    }),
                                                                                  --[[ String_literal ]]Block.__(11, {
                                                                                      "The parameter cannot be eliminated in the result type.",
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Break ]]Block.__(0, {
                                                                                              "@ ",
                                                                                              1,
                                                                                              0
                                                                                            }),
                                                                                          --[[ String_literal ]]Block.__(11, {
                                                                                              " Please bind the argument to a module identifier.",
                                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                                  --[[ Close_box ]]0,
                                                                                                  --[[ End_of_format ]]0
                                                                                                })
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[This functor has type@ %a@ The parameter cannot be eliminated in the result type.@  Please bind the argument to a module identifier.@]"
                                                            }), modtype_1, param_1[0]); end end 
                                           if ___conditional___ == 3--[[ Structure_expected ]] then do
                                              return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "This module is not a structure; it has type",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[This module is not a structure; it has type@ %a"
                                                            }), modtype_1, param_1[0]); end end 
                                           if ___conditional___ == 4--[[ With_no_component ]] then do
                                              return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The signature constrained by `with' has no component named ",
                                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Close_box ]]0,
                                                                              --[[ End_of_format ]]0
                                                                            })})
                                                                    })
                                                                }),
                                                              "@[The signature constrained by `with' has no component named %a@]"
                                                            }), longident, param_1[0]); end end 
                                           if ___conditional___ == 5--[[ With_mismatch ]] then do
                                              return Curry._4(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "<v>",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "<v>"
                                                                      }}),
                                                                  --[[ Formatting_gen ]]Block.__(18, {
                                                                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                            --[[ End_of_format ]]0,
                                                                            ""
                                                                          }}),
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          "In this `with' constraint, the new definition of ",
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Break ]]Block.__(0, {
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    }),
                                                                                  --[[ String_literal ]]Block.__(11, {
                                                                                      "does not match its original definition",
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Break ]]Block.__(0, {
                                                                                              "@ ",
                                                                                              1,
                                                                                              0
                                                                                            }),
                                                                                          --[[ String_literal ]]Block.__(11, {
                                                                                              "in the constrained signature:",
                                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                                  --[[ Close_box ]]0,
                                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                                      --[[ Break ]]Block.__(0, {
                                                                                                          "@ ",
                                                                                                          1,
                                                                                                          0
                                                                                                        }),
                                                                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                              --[[ Close_box ]]0,
                                                                                                              --[[ End_of_format ]]0
                                                                                                            })})
                                                                                                    })
                                                                                                })
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[<v>@[In this `with' constraint, the new definition of %a@ does not match its original definition@ in the constrained signature:@]@ %a@]"
                                                            }), longident, param_1[0], report_error_4, param_1[1]); end end 
                                           if ___conditional___ == 6--[[ Repeated_name ]] then do
                                              return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "Multiple definition of the ",
                                                                      --[[ String ]]Block.__(2, {
                                                                          --[[ No_padding ]]0,
                                                                          --[[ String_literal ]]Block.__(11, {
                                                                              " name ",
                                                                              --[[ String ]]Block.__(2, {
                                                                                  --[[ No_padding ]]0,
                                                                                  --[[ Char_literal ]]Block.__(12, {
                                                                                      --[[ "." ]]46,
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Break ]]Block.__(0, {
                                                                                              "@ ",
                                                                                              1,
                                                                                              0
                                                                                            }),
                                                                                          --[[ String_literal ]]Block.__(11, {
                                                                                              "Names must be unique in a given structure or signature.",
                                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                                  --[[ Close_box ]]0,
                                                                                                  --[[ End_of_format ]]0
                                                                                                })
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })
                                                                            })
                                                                        })
                                                                    })
                                                                }),
                                                              "@[Multiple definition of the %s name %s.@ Names must be unique in a given structure or signature.@]"
                                                            }), param_1[0], param_1[1]); end end 
                                           if ___conditional___ == 7--[[ Non_generalizable ]] then do
                                              return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The type of this expression,",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                                                  --[[ "," ]]44,
                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Break ]]Block.__(0, {
                                                                                          "@ ",
                                                                                          1,
                                                                                          0
                                                                                        }),
                                                                                      --[[ String_literal ]]Block.__(11, {
                                                                                          "contains type variables that cannot be generalized",
                                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                                              --[[ Close_box ]]0,
                                                                                              --[[ End_of_format ]]0
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[The type of this expression,@ %a,@ contains type variables that cannot be generalized@]"
                                                            }), type_scheme, param_1[0]); end end 
                                           if ___conditional___ == 8--[[ Non_generalizable_class ]] then do
                                              id = param_1[0];
                                              return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The type of this class,",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                                                  --[[ "," ]]44,
                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Break ]]Block.__(0, {
                                                                                          "@ ",
                                                                                          1,
                                                                                          0
                                                                                        }),
                                                                                      --[[ String_literal ]]Block.__(11, {
                                                                                          "contains type variables that cannot be generalized",
                                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                                              --[[ Close_box ]]0,
                                                                                              --[[ End_of_format ]]0
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[The type of this class,@ %a,@ contains type variables that cannot be generalized@]"
                                                            }), (function(param, param_1) do
                                                            return class_declaration_1(id, param, param_1);
                                                          end end), param_1[1]); end end 
                                           if ___conditional___ == 9--[[ Non_generalizable_module ]] then do
                                              return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The type of this module,",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                                                  --[[ "," ]]44,
                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Break ]]Block.__(0, {
                                                                                          "@ ",
                                                                                          1,
                                                                                          0
                                                                                        }),
                                                                                      --[[ String_literal ]]Block.__(11, {
                                                                                          "contains type variables that cannot be generalized",
                                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                                              --[[ Close_box ]]0,
                                                                                              --[[ End_of_format ]]0
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[The type of this module,@ %a,@ contains type variables that cannot be generalized@]"
                                                            }), modtype_1, param_1[0]); end end 
                                           if ___conditional___ == 10--[[ Implementation_is_required ]] then do
                                              return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The interface ",
                                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Break ]]Block.__(0, {
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                }),
                                                                              --[[ String_literal ]]Block.__(11, {
                                                                                  "declares values, not just types.",
                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Break ]]Block.__(0, {
                                                                                          "@ ",
                                                                                          1,
                                                                                          0
                                                                                        }),
                                                                                      --[[ String_literal ]]Block.__(11, {
                                                                                          "An implementation must be provided.",
                                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                                              --[[ Close_box ]]0,
                                                                                              --[[ End_of_format ]]0
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })
                                                                            })})
                                                                    })
                                                                }),
                                                              "@[The interface %a@ declares values, not just types.@ An implementation must be provided.@]"
                                                            }), print_filename, param_1[0]); end end 
                                           if ___conditional___ == 11--[[ Interface_not_compiled ]] then do
                                              return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "Could not find the .cmi file for interface",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                                                  --[[ "." ]]46,
                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Close_box ]]0,
                                                                                      --[[ End_of_format ]]0
                                                                                    })
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[Could not find the .cmi file for interface@ %a.@]"
                                                            }), print_filename, param_1[0]); end end 
                                           if ___conditional___ == 12--[[ Not_a_packed_module ]] then do
                                              return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "This expression is not a packed module. It has type",
                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Break ]]Block.__(0, {
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        }),
                                                                      --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                                    })
                                                                }),
                                                              "This expression is not a packed module. It has type@ %a"
                                                            }), type_expr_1, param_1[0]); end end 
                                           if ___conditional___ == 13--[[ Incomplete_packed_module ]] then do
                                              return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "The type of this packed module contains variables:",
                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Break ]]Block.__(0, {
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        }),
                                                                      --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                                    })
                                                                }),
                                                              "The type of this packed module contains variables:@ %a"
                                                            }), type_expr_1, param_1[0]); end end 
                                           if ___conditional___ == 14--[[ Scoping_pack ]] then do
                                              Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                        --[[ String_literal ]]Block.__(11, {
                                                            "The type ",
                                                            --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                                                    " in this module cannot be exported.",
                                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                                        --[[ Break ]]Block.__(0, {
                                                                            "@ ",
                                                                            1,
                                                                            0
                                                                          }),
                                                                        --[[ End_of_format ]]0
                                                                      })
                                                                  })})
                                                          }),
                                                        "The type %a in this module cannot be exported.@ "
                                                      }), longident, param_1[0]);
                                              return Curry._2(Format.fprintf(ppf_1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "Its type contains local dependencies:",
                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Break ]]Block.__(0, {
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        }),
                                                                      --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                                    })
                                                                }),
                                                              "Its type contains local dependencies:@ %a"
                                                            }), type_expr_1, param_1[1]); end end 
                                          
                                        end
                                      end end 
                                    end end));
                      end end), param[3]);
        end else if (param[0] == Error_forward_3) then do
          return param[1];
        end else do
          return ;
        end end  end 
      end end));

suites = do
  contents: --[[ [] ]]0
end;

test_id = do
  contents: 0
end;

function eq(loc, x, y) do
  test_id.contents = test_id.contents + 1 | 0;
  suites.contents = --[[ :: ]]{
    --[[ tuple ]]{
      loc .. (" id " .. String(test_id.contents)),
      (function(param) do
          return --[[ Eq ]]Block.__(0, {
                    x,
                    y
                  });
        end end)
    },
    suites.contents
  };
  return --[[ () ]]0;
end end

dont_write_files.contents = true;

unsafe_string = false;

debug = true;

record_event_when_debug = false;

binary_annotations.contents = false;

nopervasives = true;

assume_no_mli.contents = --[[ Mli_non_exists ]]2;

modulename = "Test";

x = type_implementation(modulename, modulename, modulename, empty, wrap_1(implementation, Lexing.from_string("\ntype int\nexternal ( ~- ) : int -> int = \"%negint\"\nexternal ( ~+ ) : int -> int = \"%identity\"\nexternal succ : int -> int = \"%succint\"\nexternal pred : int -> int = \"%predint\"\nexternal ( + ) : int -> int -> int = \"%addint\"\nexternal ( - ) : int -> int -> int = \"%subint\"\nexternal ( * ) : int -> int -> int = \"%mulint\"\nexternal ( / ) : int -> int -> int = \"%divint\"\nexternal ( mod ) : int -> int -> int = \"%modint\"\n let f x y = x + y")));

match_1 = x[0].str_items;

if (match_1) then do
  match_2 = match_1[0];
  match_3 = match_2.str_desc;
  if (match_3.tag == --[[ Tstr_type ]]3) then do
    match_4 = match_3[0];
    if (match_4) then do
      match_5 = match_4[0];
      match_6 = match_5.typ_id;
      if (match_6.name == "int") then do
        match_7 = match_6.flags;
        if (match_7 ~= 0) then do
          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
        end else do
          match_8 = match_5.typ_name;
          if (match_8.txt == "int") then do
            match_9 = match_8.loc;
            match_10 = match_9.loc_start;
            if (match_10.pos_fname == "" and not (match_10.pos_lnum ~= 2 or match_10.pos_bol ~= 1 or match_10.pos_cnum ~= 6)) then do
              match_11 = match_9.loc_end;
              if (match_11.pos_fname == "" and not (match_11.pos_lnum ~= 2 or match_11.pos_bol ~= 1 or match_11.pos_cnum ~= 9 or match_9.loc_ghost or match_5.typ_params)) then do
                match_12 = match_5.typ_type;
                if (match_12.type_params or match_12.type_arity ~= 0) then do
                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                end else do
                  match_13 = match_12.type_kind;
                  if (typeof match_13 == "number" and not (match_13 ~= 0 or not (match_12.type_private and not (match_12.type_manifest ~= undefined or match_12.type_variance or match_12.type_newtype_level ~= undefined)))) then do
                    match_14 = match_12.type_loc;
                    match_15 = match_14.loc_start;
                    if (match_15.pos_fname == "" and not (match_15.pos_lnum ~= 2 or match_15.pos_bol ~= 1 or match_15.pos_cnum ~= 1)) then do
                      match_16 = match_14.loc_end;
                      if (match_16.pos_fname == "" and not (match_16.pos_lnum ~= 2 or match_16.pos_bol ~= 1 or match_16.pos_cnum ~= 9 or match_14.loc_ghost or match_12.type_attributes or match_5.typ_cstrs)) then do
                        match_17 = match_5.typ_kind;
                        if (typeof match_17 == "number" and not (match_17 ~= 0 or not (match_5.typ_private and match_5.typ_manifest == undefined))) then do
                          match_18 = match_5.typ_loc;
                          match_19 = match_18.loc_start;
                          if (match_19.pos_fname == "" and not (match_19.pos_lnum ~= 2 or match_19.pos_bol ~= 1 or match_19.pos_cnum ~= 1)) then do
                            match_20 = match_18.loc_end;
                            if (match_20.pos_fname == "" and not (match_20.pos_lnum ~= 2 or match_20.pos_bol ~= 1 or match_20.pos_cnum ~= 9 or match_18.loc_ghost or match_5.typ_attributes or match_4[1])) then do
                              match_21 = match_2.str_loc;
                              match_22 = match_21.loc_start;
                              if (match_22.pos_fname == "" and not (match_22.pos_lnum ~= 2 or match_22.pos_bol ~= 1 or match_22.pos_cnum ~= 1)) then do
                                match_23 = match_21.loc_end;
                                if (match_23.pos_fname == "" and not (match_23.pos_lnum ~= 2 or match_23.pos_bol ~= 1 or match_23.pos_cnum ~= 9 or match_21.loc_ghost)) then do
                                  match_24 = match_1[1];
                                  if (match_24) then do
                                    match_25 = match_24[0].str_desc;
                                    if (match_25.tag == --[[ Tstr_primitive ]]2) then do
                                      match_26 = match_25[0];
                                      match_27 = match_26.val_id;
                                      if (match_27.name == "~-") then do
                                        match_28 = match_27.flags;
                                        if (match_28 ~= 0) then do
                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                        end else do
                                          match_29 = match_26.val_name;
                                          if (match_29.txt == "~-") then do
                                            match_30 = match_29.loc;
                                            match_31 = match_30.loc_start;
                                            if (match_31.pos_fname == "" and not (match_31.pos_lnum ~= 3 or match_31.pos_bol ~= 10 or match_31.pos_cnum ~= 19)) then do
                                              match_32 = match_30.loc_end;
                                              if (match_32.pos_fname == "" and not (match_32.pos_lnum ~= 3 or match_32.pos_bol ~= 10 or match_32.pos_cnum ~= 25 or match_30.loc_ghost)) then do
                                                match_33 = match_26.val_desc;
                                                match_34 = match_33.ctyp_desc;
                                                if (typeof match_34 == "number" or not (match_34.tag == --[[ Ttyp_arrow ]]1 and match_34[0] == "")) then do
                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                end else do
                                                  match_35 = match_34[1];
                                                  match_36 = match_35.ctyp_desc;
                                                  if (typeof match_36 == "number" or match_36.tag ~= --[[ Ttyp_constr ]]3) then do
                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                  end else do
                                                    match_37 = match_36[0];
                                                    local ___conditional___=(match_37.tag | 0);
                                                    do
                                                       if ___conditional___ == 0--[[ Pident ]] then do
                                                          match_38 = match_37[0];
                                                          if (match_38.name == "int") then do
                                                            match_39 = match_38.flags;
                                                            if (match_39 ~= 0) then do
                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                            end else do
                                                              match_40 = match_36[1];
                                                              match_41 = match_40.txt;
                                                              local ___conditional___=(match_41.tag | 0);
                                                              do
                                                                 if ___conditional___ == 0--[[ Lident ]] then do
                                                                    if (match_41[0] == "int") then do
                                                                      match_42 = match_40.loc;
                                                                      match_43 = match_42.loc_start;
                                                                      if (match_43.pos_fname == "" and not (match_43.pos_lnum ~= 3 or match_43.pos_bol ~= 10 or match_43.pos_cnum ~= 28)) then do
                                                                        match_44 = match_42.loc_end;
                                                                        if (match_44.pos_fname == "" and not (match_44.pos_lnum ~= 3 or match_44.pos_bol ~= 10 or match_44.pos_cnum ~= 31 or match_42.loc_ghost or match_36[2])) then do
                                                                          match_45 = match_35.ctyp_type;
                                                                          match_46 = match_45.desc;
                                                                          if (typeof match_46 == "number" or match_46.tag ~= --[[ Tconstr ]]3) then do
                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                          end else do
                                                                            match_47 = match_46[0];
                                                                            local ___conditional___=(match_47.tag | 0);
                                                                            do
                                                                               if ___conditional___ == 0--[[ Pident ]] then do
                                                                                  match_48 = match_47[0];
                                                                                  if (match_48.name == "int") then do
                                                                                    match_49 = match_48.flags;
                                                                                    if (match_49 ~= 0 or match_46[1]) then do
                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                    end else do
                                                                                      match_50 = match_46[2].contents;
                                                                                      if (typeof match_50 == "number") then do
                                                                                        match_51 = match_35.ctyp_loc;
                                                                                        match_52 = match_51.loc_start;
                                                                                        if (match_52.pos_fname == "" and not (match_52.pos_lnum ~= 3 or match_52.pos_bol ~= 10 or match_52.pos_cnum ~= 28)) then do
                                                                                          match_53 = match_51.loc_end;
                                                                                          if (match_53.pos_fname == "" and not (match_53.pos_lnum ~= 3 or match_53.pos_bol ~= 10 or match_53.pos_cnum ~= 31 or match_51.loc_ghost or match_35.ctyp_attributes)) then do
                                                                                            match_54 = match_34[2];
                                                                                            match_55 = match_54.ctyp_desc;
                                                                                            if (typeof match_55 == "number" or match_55.tag ~= --[[ Ttyp_constr ]]3) then do
                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                            end else do
                                                                                              match_56 = match_55[0];
                                                                                              local ___conditional___=(match_56.tag | 0);
                                                                                              do
                                                                                                 if ___conditional___ == 0--[[ Pident ]] then do
                                                                                                    match_57 = match_56[0];
                                                                                                    if (match_57.name == "int") then do
                                                                                                      match_58 = match_57.flags;
                                                                                                      if (match_58 ~= 0) then do
                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                      end else do
                                                                                                        match_59 = match_55[1];
                                                                                                        match_60 = match_59.txt;
                                                                                                        local ___conditional___=(match_60.tag | 0);
                                                                                                        do
                                                                                                           if ___conditional___ == 0--[[ Lident ]] then do
                                                                                                              if (match_60[0] == "int") then do
                                                                                                                match_61 = match_59.loc;
                                                                                                                match_62 = match_61.loc_start;
                                                                                                                if (match_62.pos_fname == "" and not (match_62.pos_lnum ~= 3 or match_62.pos_bol ~= 10 or match_62.pos_cnum ~= 35)) then do
                                                                                                                  match_63 = match_61.loc_end;
                                                                                                                  if (match_63.pos_fname == "" and not (match_63.pos_lnum ~= 3 or match_63.pos_bol ~= 10 or match_63.pos_cnum ~= 38 or match_61.loc_ghost or match_55[2])) then do
                                                                                                                    match_64 = match_54.ctyp_type;
                                                                                                                    match_65 = match_64.desc;
                                                                                                                    if (typeof match_65 == "number" or match_65.tag ~= --[[ Tconstr ]]3) then do
                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                    end else do
                                                                                                                      match_66 = match_65[0];
                                                                                                                      local ___conditional___=(match_66.tag | 0);
                                                                                                                      do
                                                                                                                         if ___conditional___ == 0--[[ Pident ]] then do
                                                                                                                            match_67 = match_66[0];
                                                                                                                            if (match_67.name == "int") then do
                                                                                                                              match_68 = match_67.flags;
                                                                                                                              if (match_68 ~= 0 or match_65[1]) then do
                                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                              end else do
                                                                                                                                match_69 = match_65[2].contents;
                                                                                                                                if (typeof match_69 == "number") then do
                                                                                                                                  match_70 = match_54.ctyp_loc;
                                                                                                                                  match_71 = match_70.loc_start;
                                                                                                                                  if (match_71.pos_fname == "" and not (match_71.pos_lnum ~= 3 or match_71.pos_bol ~= 10 or match_71.pos_cnum ~= 35)) then do
                                                                                                                                    match_72 = match_70.loc_end;
                                                                                                                                    if (match_72.pos_fname == "" and not (match_72.pos_lnum ~= 3 or match_72.pos_bol ~= 10 or match_72.pos_cnum ~= 38 or match_70.loc_ghost or match_54.ctyp_attributes)) then do
                                                                                                                                      match_73 = match_33.ctyp_type;
                                                                                                                                      match_74 = match_73.desc;
                                                                                                                                      if (typeof match_74 == "number" or not (match_74.tag == --[[ Tarrow ]]1 and match_74[0] == "")) then do
                                                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                      end else do
                                                                                                                                        match_75 = match_74[1].desc;
                                                                                                                                        if (typeof match_75 == "number" or match_75.tag ~= --[[ Tconstr ]]3) then do
                                                                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                        end else do
                                                                                                                                          match_76 = match_75[0];
                                                                                                                                          local ___conditional___=(match_76.tag | 0);
                                                                                                                                          do
                                                                                                                                             if ___conditional___ == 0--[[ Pident ]] then do
                                                                                                                                                match_77 = match_76[0];
                                                                                                                                                if (match_77.name == "int") then do
                                                                                                                                                  match_78 = match_77.flags;
                                                                                                                                                  if (match_78 ~= 0 or match_75[1]) then do
                                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                  end else do
                                                                                                                                                    match_79 = match_75[2].contents;
                                                                                                                                                    if (typeof match_79 == "number") then do
                                                                                                                                                      match_80 = match_74[2].desc;
                                                                                                                                                      if (typeof match_80 == "number" or match_80.tag ~= --[[ Tconstr ]]3) then do
                                                                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                      end else do
                                                                                                                                                        match_81 = match_80[0];
                                                                                                                                                        local ___conditional___=(match_81.tag | 0);
                                                                                                                                                        do
                                                                                                                                                           if ___conditional___ == 0--[[ Pident ]] then do
                                                                                                                                                              match_82 = match_81[0];
                                                                                                                                                              if (match_82.name == "int") then do
                                                                                                                                                                match_83 = match_82.flags;
                                                                                                                                                                if (match_83 ~= 0 or match_80[1]) then do
                                                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                end else do
                                                                                                                                                                  match_84 = match_80[2].contents;
                                                                                                                                                                  if (typeof match_84 == "number") then do
                                                                                                                                                                    match_85 = match_74[3];
                                                                                                                                                                    if (typeof match_85 == "number" and match_85 == 0) then do
                                                                                                                                                                      match_86 = match_33.ctyp_loc;
                                                                                                                                                                      match_87 = match_86.loc_start;
                                                                                                                                                                      if (match_87.pos_fname == "" and not (match_87.pos_lnum ~= 3 or match_87.pos_bol ~= 10 or match_87.pos_cnum ~= 28)) then do
                                                                                                                                                                        match_88 = match_86.loc_end;
                                                                                                                                                                        if (match_88.pos_fname == "" and not (match_88.pos_lnum ~= 3 or match_88.pos_bol ~= 10 or match_88.pos_cnum ~= 38 or match_86.loc_ghost or match_33.ctyp_attributes)) then do
                                                                                                                                                                          match_89 = match_26.val_val;
                                                                                                                                                                          match_90 = match_89.val_type.desc;
                                                                                                                                                                          if (typeof match_90 == "number" or not (match_90.tag == --[[ Tarrow ]]1 and match_90[0] == "")) then do
                                                                                                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                          end else do
                                                                                                                                                                            match_91 = match_90[1].desc;
                                                                                                                                                                            if (typeof match_91 == "number" or match_91.tag ~= --[[ Tconstr ]]3) then do
                                                                                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                            end else do
                                                                                                                                                                              match_92 = match_91[0];
                                                                                                                                                                              local ___conditional___=(match_92.tag | 0);
                                                                                                                                                                              do
                                                                                                                                                                                 if ___conditional___ == 0--[[ Pident ]] then do
                                                                                                                                                                                    match_93 = match_92[0];
                                                                                                                                                                                    if (match_93.name == "int") then do
                                                                                                                                                                                      match_94 = match_93.flags;
                                                                                                                                                                                      if (match_94 ~= 0 or match_91[1]) then do
                                                                                                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                      end else do
                                                                                                                                                                                        match_95 = match_91[2].contents;
                                                                                                                                                                                        if (typeof match_95 == "number") then do
                                                                                                                                                                                          match_96 = match_90[2].desc;
                                                                                                                                                                                          if (typeof match_96 == "number" or match_96.tag ~= --[[ Tconstr ]]3) then do
                                                                                                                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                          end else do
                                                                                                                                                                                            match_97 = match_96[0];
                                                                                                                                                                                            local ___conditional___=(match_97.tag | 0);
                                                                                                                                                                                            do
                                                                                                                                                                                               if ___conditional___ == 0--[[ Pident ]] then do
                                                                                                                                                                                                  match_98 = match_97[0];
                                                                                                                                                                                                  if (match_98.name == "int") then do
                                                                                                                                                                                                    match_99 = match_98.flags;
                                                                                                                                                                                                    if (match_99 ~= 0 or match_96[1]) then do
                                                                                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                                    end else do
                                                                                                                                                                                                      match_100 = match_96[2].contents;
                                                                                                                                                                                                      if (typeof match_100 == "number") then do
                                                                                                                                                                                                        match_101 = match_90[3];
                                                                                                                                                                                                        if (typeof match_101 == "number" and match_101 == 0) then do
                                                                                                                                                                                                          match_102 = match_89.val_kind;
                                                                                                                                                                                                          if (typeof match_102 == "number" or match_102.tag) then do
                                                                                                                                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                                          end else do
                                                                                                                                                                                                            match_103 = match_102[0];
                                                                                                                                                                                                            if (match_103.prim_name == "%negint" and not (match_103.prim_arity ~= 1 or not (match_103.prim_alloc and match_103.prim_native_name == "" and not match_103.prim_native_float))) then do
                                                                                                                                                                                                              match_104 = match_89.val_loc;
                                                                                                                                                                                                              match_105 = match_104.loc_start;
                                                                                                                                                                                                              if (match_105.pos_fname == "" and not (match_105.pos_lnum ~= 3 or match_105.pos_bol ~= 10 or match_105.pos_cnum ~= 10)) then do
                                                                                                                                                                                                                match_106 = match_104.loc_end;
                                                                                                                                                                                                                if (match_106.pos_fname == "" and not (match_106.pos_lnum ~= 3 or match_106.pos_bol ~= 10 or match_106.pos_cnum ~= 50 or match_104.loc_ghost or match_89.val_attributes)) then do
                                                                                                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 220, characters 14-21", true, true);
                                                                                                                                                                                                                end else do
                                                                                                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                                                end end 
                                                                                                                                                                                                              end else do
                                                                                                                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                                              end end 
                                                                                                                                                                                                            end else do
                                                                                                                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                                            end end 
                                                                                                                                                                                                          end end 
                                                                                                                                                                                                        end else do
                                                                                                                                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                                        end end 
                                                                                                                                                                                                      end else do
                                                                                                                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                                      end end 
                                                                                                                                                                                                    end end 
                                                                                                                                                                                                  end else do
                                                                                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                                  end end  end else 
                                                                                                                                                                                               if ___conditional___ == 1--[[ Pdot ]]
                                                                                                                                                                                               or ___conditional___ == 2--[[ Papply ]] then do
                                                                                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false); end else 
                                                                                                                                                                                               end end end end
                                                                                                                                                                                              
                                                                                                                                                                                            end
                                                                                                                                                                                          end end 
                                                                                                                                                                                        end else do
                                                                                                                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                        end end 
                                                                                                                                                                                      end end 
                                                                                                                                                                                    end else do
                                                                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                    end end  end else 
                                                                                                                                                                                 if ___conditional___ == 1--[[ Pdot ]]
                                                                                                                                                                                 or ___conditional___ == 2--[[ Papply ]] then do
                                                                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false); end else 
                                                                                                                                                                                 end end end end
                                                                                                                                                                                
                                                                                                                                                                              end
                                                                                                                                                                            end end 
                                                                                                                                                                          end end 
                                                                                                                                                                        end else do
                                                                                                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                        end end 
                                                                                                                                                                      end else do
                                                                                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                      end end 
                                                                                                                                                                    end else do
                                                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                    end end 
                                                                                                                                                                  end else do
                                                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                  end end 
                                                                                                                                                                end end 
                                                                                                                                                              end else do
                                                                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                              end end  end else 
                                                                                                                                                           if ___conditional___ == 1--[[ Pdot ]]
                                                                                                                                                           or ___conditional___ == 2--[[ Papply ]] then do
                                                                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false); end else 
                                                                                                                                                           end end end end
                                                                                                                                                          
                                                                                                                                                        end
                                                                                                                                                      end end 
                                                                                                                                                    end else do
                                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                    end end 
                                                                                                                                                  end end 
                                                                                                                                                end else do
                                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                end end  end else 
                                                                                                                                             if ___conditional___ == 1--[[ Pdot ]]
                                                                                                                                             or ___conditional___ == 2--[[ Papply ]] then do
                                                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false); end else 
                                                                                                                                             end end end end
                                                                                                                                            
                                                                                                                                          end
                                                                                                                                        end end 
                                                                                                                                      end end 
                                                                                                                                    end else do
                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                    end end 
                                                                                                                                  end else do
                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                  end end 
                                                                                                                                end else do
                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                end end 
                                                                                                                              end end 
                                                                                                                            end else do
                                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                            end end  end else 
                                                                                                                         if ___conditional___ == 1--[[ Pdot ]]
                                                                                                                         or ___conditional___ == 2--[[ Papply ]] then do
                                                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false); end else 
                                                                                                                         end end end end
                                                                                                                        
                                                                                                                      end
                                                                                                                    end end 
                                                                                                                  end else do
                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                  end end 
                                                                                                                end else do
                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                end end 
                                                                                                              end else do
                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                              end end  end else 
                                                                                                           if ___conditional___ == 1--[[ Ldot ]]
                                                                                                           or ___conditional___ == 2--[[ Lapply ]] then do
                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false); end else 
                                                                                                           end end end end
                                                                                                          
                                                                                                        end
                                                                                                      end end 
                                                                                                    end else do
                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                    end end  end else 
                                                                                                 if ___conditional___ == 1--[[ Pdot ]]
                                                                                                 or ___conditional___ == 2--[[ Papply ]] then do
                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false); end else 
                                                                                                 end end end end
                                                                                                
                                                                                              end
                                                                                            end end 
                                                                                          end else do
                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                          end end 
                                                                                        end else do
                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                        end end 
                                                                                      end else do
                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                      end end 
                                                                                    end end 
                                                                                  end else do
                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                  end end  end else 
                                                                               if ___conditional___ == 1--[[ Pdot ]]
                                                                               or ___conditional___ == 2--[[ Papply ]] then do
                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false); end else 
                                                                               end end end end
                                                                              
                                                                            end
                                                                          end end 
                                                                        end else do
                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                        end end 
                                                                      end else do
                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                      end end 
                                                                    end else do
                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                    end end  end else 
                                                                 if ___conditional___ == 1--[[ Ldot ]]
                                                                 or ___conditional___ == 2--[[ Lapply ]] then do
                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false); end else 
                                                                 end end end end
                                                                
                                                              end
                                                            end end 
                                                          end else do
                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                          end end  end else 
                                                       if ___conditional___ == 1--[[ Pdot ]]
                                                       or ___conditional___ == 2--[[ Papply ]] then do
                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false); end else 
                                                       end end end end
                                                      
                                                    end
                                                  end end 
                                                end end 
                                              end else do
                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                              end end 
                                            end else do
                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                            end end 
                                          end else do
                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                          end end 
                                        end end 
                                      end else do
                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                      end end 
                                    end else do
                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                    end end 
                                  end else do
                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                  end end 
                                end else do
                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                end end 
                              end else do
                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                              end end 
                            end else do
                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                            end end 
                          end else do
                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                          end end 
                        end else do
                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                        end end 
                      end else do
                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                      end end 
                    end else do
                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                    end end 
                  end else do
                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                  end end 
                end end 
              end else do
                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
              end end 
            end else do
              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
            end end 
          end else do
            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
          end end 
        end end 
      end else do
        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
      end end 
    end else do
      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
    end end 
  end else do
    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
  end end 
end else do
  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
end end 

from_pair_suites("Ocaml_typedtree_test", suites.contents);

exports = {}
--[[  Not a pure module ]]
