--[['use strict';]]

Arg = require "../../lib/js/arg.lua";
Sys = require "../../lib/js/sys.lua";
Char = require "../../lib/js/char.lua";
List = require "../../lib/js/list.lua";
Path = require "path";
__Array = require "../../lib/js/array.lua";
Block = require "../../lib/js/block.lua";
Bytes = require "../../lib/js/bytes.lua";
Curry = require "../../lib/js/curry.lua";
Int32 = require "../../lib/js/int32.lua";
Int64 = require "../../lib/js/int64.lua";
__Buffer = require "../../lib/js/buffer.lua";
Digest = require "../../lib/js/digest.lua";
Format = require "../../lib/js/format.lua";
Lexing = require "../../lib/js/lexing.lua";
Printf = require "../../lib/js/printf.lua";
__String = require "../../lib/js/string.lua";
Assert = require "assert";
Caml_io = require "../../lib/js/caml_io.lua";
Hashtbl = require "../../lib/js/hashtbl.lua";
Marshal = require "../../lib/js/marshal.lua";
Parsing = require "../../lib/js/parsing.lua";
Process = require "process";
Caml_obj = require "../../lib/js/caml_obj.lua";
Caml_sys = require "../../lib/js/caml_sys.lua";
Filename = require "../../lib/js/filename.lua";
Caml_weak = require "../../lib/js/caml_weak.lua";
Nativeint = require "../../lib/js/nativeint.lua";
Caml_array = require "../../lib/js/caml_array.lua";
Caml_bytes = require "../../lib/js/caml_bytes.lua";
Caml_int32 = require "../../lib/js/caml_int32.lua";
Caml_int64 = require "../../lib/js/caml_int64.lua";
Pervasives = require "../../lib/js/pervasives.lua";
Caml_format = require "../../lib/js/caml_format.lua";
Caml_option = require "../../lib/js/caml_option.lua";
Caml_string = require "../../lib/js/caml_string.lua";
Caml_primitive = require "../../lib/js/caml_primitive.lua";
Caml_exceptions = require "../../lib/js/caml_exceptions.lua";
CamlinternalLazy = require "../../lib/js/camlinternalLazy.lua";
Caml_js_exceptions = require "../../lib/js/caml_js_exceptions.lua";
Caml_external_polyfill = require "../../lib/js/caml_external_polyfill.lua";
Caml_builtin_exceptions = require "../../lib/js/caml_builtin_exceptions.lua";

cmi_magic_number = "Caml1999I017";

load_path = do
  contents: --[[ [] ]]0
end;

interface_suffix = do
  contents: ".mli"
end;

print_types = do
  contents: false
end;

debug = false;

fast = do
  contents: false
end;

classic = do
  contents: false
end;

nopervasives = false;

annotations = do
  contents: false
end;

binary_annotations = do
  contents: false
end;

principal = do
  contents: false
end;

real_paths = do
  contents: true
end;

recursive_types = do
  contents: false
end;

strict_sequence = do
  contents: false
end;

applicative_functors = do
  contents: true
end;

error_size = do
  contents: 500
end;

transparent_modules = do
  contents: false
end;

native_code = do
  contents: false
end;

dont_write_files = do
  contents: false
end;

keep_docs = do
  contents: false
end;

keep_locs = do
  contents: false
end;

unsafe_string = true;

assume_no_mli = do
  contents: --[[ Mli_na ]]0
end;

record_event_when_debug = true;

bs_vscode;

try do
  Caml_sys.caml_sys_getenv("BS_VSCODE");
  bs_vscode = true;
end
catch (exn)do
  bs_vscode = false;
end

dont_record_crc_unit = do
  contents: undefined
end;

bs_only = do
  contents: false
end;

color = do
  contents: undefined
end;

Fatal_error = Caml_exceptions.create("Ocaml_typedtree_test.Misc.Fatal_error");

function fatal_error(msg) do
  Pervasives.prerr_string(">> Fatal error: ");
  console.error(msg);
  throw Fatal_error;
end end

function try_finally(work, cleanup) do
  result;
  try do
    result = Curry._1(work, --[[ () ]]0);
  end
  catch (e)do
    Curry._1(cleanup, --[[ () ]]0);
    throw e;
  end
  Curry._1(cleanup, --[[ () ]]0);
  return result;
end end

function map_end(f, l1, l2) do
  if (l1) then do
    return --[[ :: ]]{
            Curry._1(f, l1[0]),
            map_end(f, l1[1], l2)
          };
  end else do
    return l2;
  end end 
end end

function for_all2(pred, _l1, _l2) do
  while(true) do
    l2 = _l2;
    l1 = _l1;
    if (l1) then do
      if (l2 and Curry._2(pred, l1[0], l2[0])) then do
        _l2 = l2[1];
        _l1 = l1[1];
        continue ;
      end else do
        return false;
      end end 
    end else if (l2) then do
      return false;
    end else do
      return true;
    end end  end 
  end;
end end

function replicate_list(elem, n) do
  if (n <= 0) then do
    return --[[ [] ]]0;
  end else do
    return --[[ :: ]]{
            elem,
            replicate_list(elem, n - 1 | 0)
          };
  end end 
end end

function split_last(param) do
  if (param) then do
    tl = param[1];
    x = param[0];
    if (tl) then do
      match = split_last(tl);
      return --[[ tuple ]]{
              --[[ :: ]]{
                x,
                match[0]
              },
              match[1]
            };
    end else do
      return --[[ tuple ]]{
              --[[ [] ]]0,
              x
            };
    end end 
  end else do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "misc.ml",
            54,
            10
          }
        };
  end end 
end end

function may(f, param) do
  if (param ~= undefined) then do
    return Curry._1(f, Caml_option.valFromOption(param));
  end else do
    return --[[ () ]]0;
  end end 
end end

function may_map(f, param) do
  if (param ~= undefined) then do
    return Caml_option.some(Curry._1(f, Caml_option.valFromOption(param)));
  end
   end 
end end

function find_in_path_uncap(path, name) do
  uname = Caml_bytes.bytes_to_string(Bytes.uncapitalize(Caml_bytes.bytes_of_string(name)));
  _param = path;
  while(true) do
    param = _param;
    if (param) then do
      dir = param[0];
      fullname = Filename.concat(dir, name);
      ufullname = Filename.concat(dir, uname);
      if (Caml_external_polyfill.resolve("caml_sys_file_exists")(ufullname)) then do
        return ufullname;
      end else if (Caml_external_polyfill.resolve("caml_sys_file_exists")(fullname)) then do
        return fullname;
      end else do
        _param = param[1];
        continue ;
      end end  end 
    end else do
      throw Caml_builtin_exceptions.not_found;
    end end 
  end;
end end

function remove_file(filename) do
  try do
    return Caml_external_polyfill.resolve("caml_sys_remove")(filename);
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Caml_builtin_exceptions.sys_error) then do
      return --[[ () ]]0;
    end else do
      throw exn;
    end end 
  end
end end

function create_hashtable(size, init) do
  tbl = Hashtbl.create(undefined, size);
  List.iter((function (param) do
          return Hashtbl.add(tbl, param[0], param[1]);
        end end), init);
  return tbl;
end end

function chop_extension_if_any(fname) do
  try do
    return Filename.chop_extension(fname);
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Caml_builtin_exceptions.invalid_argument) then do
      return fname;
    end else do
      throw exn;
    end end 
  end
end end

function get_ref(r) do
  v = r.contents;
  r.contents = --[[ [] ]]0;
  return v;
end end

function edit_distance(a, b, cutoff) do
  la = #a;
  lb = #b;
  cutoff$1 = Caml_primitive.caml_int_min(la > lb and la or lb, cutoff);
  if (Pervasives.abs(la - lb | 0) > cutoff$1) then do
    return ;
  end else do
    m = __Array.make_matrix(la + 1 | 0, lb + 1 | 0, cutoff$1 + 1 | 0);
    Caml_array.caml_array_set(Caml_array.caml_array_get(m, 0), 0, 0);
    for i = 1 , la , 1 do
      Caml_array.caml_array_set(Caml_array.caml_array_get(m, i), 0, i);
    end
    for j = 1 , lb , 1 do
      Caml_array.caml_array_set(Caml_array.caml_array_get(m, 0), j, j);
    end
    for i$1 = 1 , la , 1 do
      for j$1 = Caml_primitive.caml_int_max(1, (i$1 - cutoff$1 | 0) - 1 | 0) , Caml_primitive.caml_int_min(lb, (i$1 + cutoff$1 | 0) + 1 | 0) , 1 do
        cost = Caml_string.get(a, i$1 - 1 | 0) == Caml_string.get(b, j$1 - 1 | 0) and 0 or 1;
        best = Caml_primitive.caml_int_min(1 + Caml_primitive.caml_int_min(Caml_array.caml_array_get(Caml_array.caml_array_get(m, i$1 - 1 | 0), j$1), Caml_array.caml_array_get(Caml_array.caml_array_get(m, i$1), j$1 - 1 | 0)) | 0, Caml_array.caml_array_get(Caml_array.caml_array_get(m, i$1 - 1 | 0), j$1 - 1 | 0) + cost | 0);
        best$1 = i$1 > 1 and j$1 > 1 and Caml_string.get(a, i$1 - 1 | 0) == Caml_string.get(b, j$1 - 2 | 0) and Caml_string.get(a, i$1 - 2 | 0) == Caml_string.get(b, j$1 - 1 | 0) and Caml_primitive.caml_int_min(best, Caml_array.caml_array_get(Caml_array.caml_array_get(m, i$1 - 2 | 0), j$1 - 2 | 0) + cost | 0) or best;
        Caml_array.caml_array_set(Caml_array.caml_array_get(m, i$1), j$1, best$1);
      end
    end
    result = Caml_array.caml_array_get(Caml_array.caml_array_get(m, la), lb);
    if (result > cutoff$1) then do
      return ;
    end else do
      return result;
    end end 
  end end 
end end

function ansi_of_color(param) do
  local ___conditional___=(param);
  do
     if ___conditional___ = 0--[[ Black ]] then do
        return "0";end end end 
     if ___conditional___ = 1--[[ Red ]] then do
        return "1";end end end 
     if ___conditional___ = 2--[[ Green ]] then do
        return "2";end end end 
     if ___conditional___ = 3--[[ Yellow ]] then do
        return "3";end end end 
     if ___conditional___ = 4--[[ Blue ]] then do
        return "4";end end end 
     if ___conditional___ = 5--[[ Magenta ]] then do
        return "5";end end end 
     if ___conditional___ = 6--[[ Cyan ]] then do
        return "6";end end end 
     if ___conditional___ = 7--[[ White ]] then do
        return "7";end end end 
     do
    
  end
end end

function code_of_style(param) do
  if (typeof param == "number") then do
    local ___conditional___=(param);
    do
       if ___conditional___ = 0--[[ Bold ]] then do
          return "1";end end end 
       if ___conditional___ = 1--[[ Reset ]] then do
          return "0";end end end 
       if ___conditional___ = 2--[[ Dim ]] then do
          return "2";end end end 
       do
      
    end
  end else if (param.tag) then do
    return "4" .. ansi_of_color(param[0]);
  end else do
    return "3" .. ansi_of_color(param[0]);
  end end  end 
end end

function ansi_of_style_l(l) do
  s = l and (
      l[1] and __String.concat(";", List.map(code_of_style, l)) or code_of_style(l[0])
    ) or "0";
  return "\x1b[" .. (s .. "m");
end end

default_styles = do
  error: --[[ :: ]]{
    --[[ Bold ]]0,
    --[[ :: ]]{
      --[[ FG ]]Block.__(0, {--[[ Red ]]1}),
      --[[ [] ]]0
    }
  },
  warning: --[[ :: ]]{
    --[[ Bold ]]0,
    --[[ :: ]]{
      --[[ FG ]]Block.__(0, {--[[ Magenta ]]5}),
      --[[ [] ]]0
    }
  },
  loc: --[[ :: ]]{
    --[[ Bold ]]0,
    --[[ [] ]]0
  }
end;

cur_styles = do
  contents: default_styles
end;

function get_styles(param) do
  return cur_styles.contents;
end end

function set_styles(s) do
  cur_styles.contents = s;
  return --[[ () ]]0;
end end

function style_of_tag(s) do
  local ___conditional___=(s);
  do
     if ___conditional___ = "dim" then do
        return --[[ :: ]]{
                --[[ Dim ]]2,
                --[[ [] ]]0
              };end end end 
     if ___conditional___ = "error" then do
        return cur_styles.contents.error;end end end 
     if ___conditional___ = "filename" then do
        return --[[ :: ]]{
                --[[ FG ]]Block.__(0, {--[[ Cyan ]]6}),
                --[[ [] ]]0
              };end end end 
     if ___conditional___ = "info" then do
        return --[[ :: ]]{
                --[[ Bold ]]0,
                --[[ :: ]]{
                  --[[ FG ]]Block.__(0, {--[[ Yellow ]]3}),
                  --[[ [] ]]0
                }
              };end end end 
     if ___conditional___ = "loc" then do
        return cur_styles.contents.loc;end end end 
     if ___conditional___ = "warning" then do
        return cur_styles.contents.warning;end end end 
     do
    else do
      throw Caml_builtin_exceptions.not_found;
      end end
      
  end
end end

color_enabled = do
  contents: true
end;

function set_color_tag_handling(ppf) do
  functions = Format.pp_get_formatter_tag_functions(ppf, --[[ () ]]0);
  partial_arg = functions.mark_open_tag;
  partial_arg$1 = functions.mark_close_tag;
  functions$prime_mark_open_tag = function (param) do
    or_else = partial_arg;
    s = param;
    try do
      style = style_of_tag(s);
      if (color_enabled.contents) then do
        return ansi_of_style_l(style);
      end else do
        return "";
      end end 
    end
    catch (exn)do
      if (exn == Caml_builtin_exceptions.not_found) then do
        return Curry._1(or_else, s);
      end else do
        throw exn;
      end end 
    end
  end end;
  functions$prime_mark_close_tag = function (param) do
    or_else = partial_arg$1;
    s = param;
    try do
      style_of_tag(s);
      if (color_enabled.contents) then do
        return ansi_of_style_l(--[[ :: ]]{
                    --[[ Reset ]]1,
                    --[[ [] ]]0
                  });
      end else do
        return "";
      end end 
    end
    catch (exn)do
      if (exn == Caml_builtin_exceptions.not_found) then do
        return Curry._1(or_else, s);
      end else do
        throw exn;
      end end 
    end
  end end;
  functions$prime_print_open_tag = functions.print_open_tag;
  functions$prime_print_close_tag = functions.print_close_tag;
  functions$prime = do
    mark_open_tag: functions$prime_mark_open_tag,
    mark_close_tag: functions$prime_mark_close_tag,
    print_open_tag: functions$prime_print_open_tag,
    print_close_tag: functions$prime_print_close_tag
  end;
  ppf.pp_mark_tags = true;
  return Format.pp_set_formatter_tag_functions(ppf, functions$prime);
end end

first = do
  contents: true
end;

formatter_l_001 = --[[ :: ]]{
  Format.err_formatter,
  --[[ :: ]]{
    Format.str_formatter,
    --[[ [] ]]0
  }
};

formatter_l = --[[ :: ]]{
  Format.std_formatter,
  formatter_l_001
};

function setup(o) do
  if (first.contents) then do
    first.contents = false;
    Format.set_mark_tags(true);
    List.iter(set_color_tag_handling, formatter_l);
    tmp;
    if (o ~= undefined) then do
      local ___conditional___=(o);
      do
         if ___conditional___ = 1--[[ Always ]] then do
            tmp = true;end else 
         if ___conditional___ = 0--[[ Auto ]]
         or ___conditional___ = 2--[[ Never ]] then do
            tmp = false;end else 
         do end end end
        
      end
    end else do
      tmp = false;
    end end 
    color_enabled.contents = tmp;
  end
   end 
  return --[[ () ]]0;
end end

Misc_Color = do
  ansi_of_style_l: ansi_of_style_l,
  default_styles: default_styles,
  get_styles: get_styles,
  set_styles: set_styles,
  setup: setup,
  set_color_tag_handling: set_color_tag_handling
end;

function number(param) do
  if (typeof param == "number") then do
    local ___conditional___=(param);
    do
       if ___conditional___ = 0--[[ Comment_start ]] then do
          return 1;end end end 
       if ___conditional___ = 1--[[ Comment_not_end ]] then do
          return 2;end end end 
       if ___conditional___ = 2--[[ Partial_application ]] then do
          return 5;end end end 
       if ___conditional___ = 3--[[ Labels_omitted ]] then do
          return 6;end end end 
       if ___conditional___ = 4--[[ Statement_type ]] then do
          return 10;end end end 
       if ___conditional___ = 5--[[ Unused_match ]] then do
          return 11;end end end 
       if ___conditional___ = 6--[[ Unused_pat ]] then do
          return 12;end end end 
       if ___conditional___ = 7--[[ Illegal_backslash ]] then do
          return 14;end end end 
       if ___conditional___ = 8--[[ Unerasable_optional_argument ]] then do
          return 16;end end end 
       if ___conditional___ = 9--[[ Unused_argument ]] then do
          return 20;end end end 
       if ___conditional___ = 10--[[ Nonreturning_statement ]] then do
          return 21;end end end 
       if ___conditional___ = 11--[[ Useless_record_with ]] then do
          return 23;end end end 
       if ___conditional___ = 12--[[ All_clauses_guarded ]] then do
          return 25;end end end 
       if ___conditional___ = 13--[[ Wildcard_arg_to_constant_constr ]] then do
          return 28;end end end 
       if ___conditional___ = 14--[[ Eol_in_string ]] then do
          return 29;end end end 
       if ___conditional___ = 15--[[ Unused_rec_flag ]] then do
          return 39;end end end 
       if ___conditional___ = 16--[[ Bs_polymorphic_comparison ]] then do
          return 102;end end end 
       do
      
    end
  end else do
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ = 0--[[ Deprecated ]] then do
          return 3;end end end 
       if ___conditional___ = 1--[[ Fragile_match ]] then do
          return 4;end end end 
       if ___conditional___ = 2--[[ Method_override ]] then do
          return 7;end end end 
       if ___conditional___ = 3--[[ Partial_match ]] then do
          return 8;end end end 
       if ___conditional___ = 4--[[ Non_closed_record_pattern ]] then do
          return 9;end end end 
       if ___conditional___ = 5--[[ Instance_variable_override ]] then do
          return 13;end end end 
       if ___conditional___ = 6--[[ Implicit_public_methods ]] then do
          return 15;end end end 
       if ___conditional___ = 7--[[ Undeclared_virtual_method ]] then do
          return 17;end end end 
       if ___conditional___ = 8--[[ Not_principal ]] then do
          return 18;end end end 
       if ___conditional___ = 9--[[ Without_principality ]] then do
          return 19;end end end 
       if ___conditional___ = 10--[[ Preprocessor ]] then do
          return 22;end end end 
       if ___conditional___ = 11--[[ Bad_module_name ]] then do
          return 24;end end end 
       if ___conditional___ = 12--[[ Unused_var ]] then do
          return 26;end end end 
       if ___conditional___ = 13--[[ Unused_var_strict ]] then do
          return 27;end end end 
       if ___conditional___ = 14--[[ Duplicate_definitions ]] then do
          return 30;end end end 
       if ___conditional___ = 15--[[ Multiple_definition ]] then do
          return 31;end end end 
       if ___conditional___ = 16--[[ Unused_value_declaration ]] then do
          return 32;end end end 
       if ___conditional___ = 17--[[ Unused_open ]] then do
          return 33;end end end 
       if ___conditional___ = 18--[[ Unused_type_declaration ]] then do
          return 34;end end end 
       if ___conditional___ = 19--[[ Unused_for_index ]] then do
          return 35;end end end 
       if ___conditional___ = 20--[[ Unused_ancestor ]] then do
          return 36;end end end 
       if ___conditional___ = 21--[[ Unused_constructor ]] then do
          return 37;end end end 
       if ___conditional___ = 22--[[ Unused_extension ]] then do
          return 38;end end end 
       if ___conditional___ = 23--[[ Name_out_of_scope ]] then do
          return 40;end end end 
       if ___conditional___ = 24--[[ Ambiguous_name ]] then do
          return 41;end end end 
       if ___conditional___ = 25--[[ Disambiguated_name ]] then do
          return 42;end end end 
       if ___conditional___ = 26--[[ Nonoptional_label ]] then do
          return 43;end end end 
       if ___conditional___ = 27--[[ Open_shadow_identifier ]] then do
          return 44;end end end 
       if ___conditional___ = 28--[[ Open_shadow_label_constructor ]] then do
          return 45;end end end 
       if ___conditional___ = 29--[[ Bad_env_variable ]] then do
          return 46;end end end 
       if ___conditional___ = 30--[[ Attribute_payload ]] then do
          return 47;end end end 
       if ___conditional___ = 31--[[ Eliminated_optional_arguments ]] then do
          return 48;end end end 
       if ___conditional___ = 32--[[ No_cmi_file ]] then do
          return 49;end end end 
       if ___conditional___ = 33--[[ Bad_docstring ]] then do
          return 50;end end end 
       if ___conditional___ = 34--[[ Bs_unused_attribute ]] then do
          return 101;end end end 
       if ___conditional___ = 35--[[ Bs_ffi_warning ]] then do
          return 103;end end end 
       if ___conditional___ = 36--[[ Bs_derive_warning ]] then do
          return 104;end end end 
       do
      
    end
  end end 
end end

function loop(i) do
  if (i == 0) then do
    return --[[ [] ]]0;
  end else do
    return --[[ :: ]]{
            i,
            loop(i - 1 | 0)
          };
  end end 
end end

letter_all = loop(104);

function letter(param) do
  local ___conditional___=(param);
  do
     if ___conditional___ = 97 then do
        return letter_all;end end end 
     if ___conditional___ = 99 then do
        return --[[ :: ]]{
                1,
                --[[ :: ]]{
                  2,
                  --[[ [] ]]0
                }
              };end end end 
     if ___conditional___ = 100 then do
        return --[[ :: ]]{
                3,
                --[[ [] ]]0
              };end end end 
     if ___conditional___ = 101 then do
        return --[[ :: ]]{
                4,
                --[[ [] ]]0
              };end end end 
     if ___conditional___ = 102 then do
        return --[[ :: ]]{
                5,
                --[[ [] ]]0
              };end end end 
     if ___conditional___ = 107 then do
        return --[[ :: ]]{
                32,
                --[[ :: ]]{
                  33,
                  --[[ :: ]]{
                    34,
                    --[[ :: ]]{
                      35,
                      --[[ :: ]]{
                        36,
                        --[[ :: ]]{
                          37,
                          --[[ :: ]]{
                            38,
                            --[[ :: ]]{
                              39,
                              --[[ [] ]]0
                            }
                          }
                        }
                      }
                    }
                  }
                }
              };end end end 
     if ___conditional___ = 108 then do
        return --[[ :: ]]{
                6,
                --[[ [] ]]0
              };end end end 
     if ___conditional___ = 109 then do
        return --[[ :: ]]{
                7,
                --[[ [] ]]0
              };end end end 
     if ___conditional___ = 112 then do
        return --[[ :: ]]{
                8,
                --[[ [] ]]0
              };end end end 
     if ___conditional___ = 114 then do
        return --[[ :: ]]{
                9,
                --[[ [] ]]0
              };end end end 
     if ___conditional___ = 115 then do
        return --[[ :: ]]{
                10,
                --[[ [] ]]0
              };end end end 
     if ___conditional___ = 117 then do
        return --[[ :: ]]{
                11,
                --[[ :: ]]{
                  12,
                  --[[ [] ]]0
                }
              };end end end 
     if ___conditional___ = 118 then do
        return --[[ :: ]]{
                13,
                --[[ [] ]]0
              };end end end 
     if ___conditional___ = 98
     or ___conditional___ = 103
     or ___conditional___ = 104
     or ___conditional___ = 105
     or ___conditional___ = 106
     or ___conditional___ = 110
     or ___conditional___ = 111
     or ___conditional___ = 113
     or ___conditional___ = 116
     or ___conditional___ = 119 then do
        return --[[ [] ]]0;end end end 
     if ___conditional___ = 120 then do
        return --[[ :: ]]{
                14,
                --[[ :: ]]{
                  15,
                  --[[ :: ]]{
                    16,
                    --[[ :: ]]{
                      17,
                      --[[ :: ]]{
                        18,
                        --[[ :: ]]{
                          19,
                          --[[ :: ]]{
                            20,
                            --[[ :: ]]{
                              21,
                              --[[ :: ]]{
                                22,
                                --[[ :: ]]{
                                  23,
                                  --[[ :: ]]{
                                    24,
                                    --[[ :: ]]{
                                      25,
                                      --[[ :: ]]{
                                        30,
                                        --[[ [] ]]0
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              };end end end 
     if ___conditional___ = 121 then do
        return --[[ :: ]]{
                26,
                --[[ [] ]]0
              };end end end 
     if ___conditional___ = 122 then do
        return --[[ :: ]]{
                27,
                --[[ [] ]]0
              };end end end 
     do
    else do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "warnings.ml",
              176,
              9
            }
          };
      end end
      
  end
end end

current = do
  contents: do
    active: Caml_array.caml_make_vect(105, true),
    error: Caml_array.caml_make_vect(105, false)
  end
end;

function is_active(x) do
  return Caml_array.caml_array_get(current.contents.active, number(x));
end end

function parse_opt(error, active, flags, s) do
  set = function (i) do
    return Caml_array.caml_array_set(flags, i, true);
  end end;
  clear = function (i) do
    return Caml_array.caml_array_set(flags, i, false);
  end end;
  set_all = function (i) do
    Caml_array.caml_array_set(active, i, true);
    return Caml_array.caml_array_set(error, i, true);
  end end;
  get_num = function (_n, _i) do
    while(true) do
      i = _i;
      n = _n;
      if (i >= #s) then do
        return --[[ tuple ]]{
                i,
                n
              };
      end else do
        match = Caml_string.get(s, i);
        if (match > 57 or match < 48) then do
          return --[[ tuple ]]{
                  i,
                  n
                };
        end else do
          _i = i + 1 | 0;
          _n = (Caml_int32.imul(10, n) + Caml_string.get(s, i) | 0) - --[[ "0" ]]48 | 0;
          continue ;
        end end 
      end end 
    end;
  end end;
  get_range = function (i) do
    match = get_num(0, i);
    n1 = match[1];
    i$1 = match[0];
    if ((i$1 + 2 | 0) < #s and Caml_string.get(s, i$1) == --[[ "." ]]46 and Caml_string.get(s, i$1 + 1 | 0) == --[[ "." ]]46) then do
      match$1 = get_num(0, i$1 + 2 | 0);
      n2 = match$1[1];
      if (n2 < n1) then do
        throw {
              Arg.Bad,
              "Ill-formed list of warnings"
            };
      end
       end 
      return --[[ tuple ]]{
              match$1[0],
              n1,
              n2
            };
    end else do
      return --[[ tuple ]]{
              i$1,
              n1,
              n1
            };
    end end 
  end end;
  loop = function (_i) do
    while(true) do
      i = _i;
      if (i >= #s) then do
        return --[[ () ]]0;
      end else do
        c = Caml_string.get(s, i);
        if (c >= 65) then do
          if (c >= 97) then do
            if (c >= 123) then do
              throw {
                    Arg.Bad,
                    "Ill-formed list of warnings"
                  };
            end
             end 
            List.iter(clear, letter(Caml_string.get(s, i)));
            _i = i + 1 | 0;
            continue ;
          end else do
            if (c >= 91) then do
              throw {
                    Arg.Bad,
                    "Ill-formed list of warnings"
                  };
            end
             end 
            List.iter(set, letter(Char.lowercase(Caml_string.get(s, i))));
            _i = i + 1 | 0;
            continue ;
          end end 
        end else if (c >= 46) then do
          if (c >= 64) then do
            return loop_letter_num(set_all, i + 1 | 0);
          end else do
            throw {
                  Arg.Bad,
                  "Ill-formed list of warnings"
                };
          end end 
        end else if (c >= 43) then do
          local ___conditional___=(c - 43 | 0);
          do
             if ___conditional___ = 0 then do
                return loop_letter_num(set, i + 1 | 0);end end end 
             if ___conditional___ = 1 then do
                throw {
                      Arg.Bad,
                      "Ill-formed list of warnings"
                    };end end end 
             if ___conditional___ = 2 then do
                return loop_letter_num(clear, i + 1 | 0);end end end 
             do
            
          end
        end else do
          throw {
                Arg.Bad,
                "Ill-formed list of warnings"
              };
        end end  end  end 
      end end 
    end;
  end end;
  loop_letter_num = function (myset, i) do
    if (i >= #s) then do
      throw {
            Arg.Bad,
            "Ill-formed list of warnings"
          };
    end
     end 
    match = Caml_string.get(s, i);
    if (match >= 65) then do
      if (match >= 97) then do
        if (match >= 123) then do
          throw {
                Arg.Bad,
                "Ill-formed list of warnings"
              };
        end
         end 
        List.iter(myset, letter(Caml_string.get(s, i)));
        return loop(i + 1 | 0);
      end else do
        if (match >= 91) then do
          throw {
                Arg.Bad,
                "Ill-formed list of warnings"
              };
        end
         end 
        List.iter(myset, letter(Char.lowercase(Caml_string.get(s, i))));
        return loop(i + 1 | 0);
      end end 
    end else do
      if (match > 57 or match < 48) then do
        throw {
              Arg.Bad,
              "Ill-formed list of warnings"
            };
      end
       end 
      match$1 = get_range(i);
      for n = match$1[1] , Caml_primitive.caml_int_min(match$1[2], 104) , 1 do
        Curry._1(myset, n);
      end
      return loop(match$1[0]);
    end end 
  end end;
  return loop(0);
end end

function parse_options(errflag, s) do
  error = __Array.copy(current.contents.error);
  active = __Array.copy(current.contents.active);
  parse_opt(error, active, errflag and error or active, s);
  current.contents = do
    active: active,
    error: error
  end;
  return --[[ () ]]0;
end end

parse_options(false, "+a-4-6-7-9-27-29-32..39-41..42-44-45-48-50-102");

parse_options(true, "-a");

function message(param) do
  if (typeof param == "number") then do
    local ___conditional___=(param);
    do
       if ___conditional___ = 0--[[ Comment_start ]] then do
          return "this is the start of a comment.";end end end 
       if ___conditional___ = 1--[[ Comment_not_end ]] then do
          return "this is not the end of a comment.";end end end 
       if ___conditional___ = 2--[[ Partial_application ]] then do
          return "this function application is partial,\nmaybe some arguments are missing.";end end end 
       if ___conditional___ = 3--[[ Labels_omitted ]] then do
          return "labels were omitted in the application of this function.";end end end 
       if ___conditional___ = 4--[[ Statement_type ]] then do
          return "this expression should have type unit.";end end end 
       if ___conditional___ = 5--[[ Unused_match ]] then do
          return "this match case is unused.";end end end 
       if ___conditional___ = 6--[[ Unused_pat ]] then do
          return "this sub-pattern is unused.";end end end 
       if ___conditional___ = 7--[[ Illegal_backslash ]] then do
          return "illegal backslash escape in string.";end end end 
       if ___conditional___ = 8--[[ Unerasable_optional_argument ]] then do
          return "this optional argument cannot be erased.";end end end 
       if ___conditional___ = 9--[[ Unused_argument ]] then do
          return "this argument will not be used by the function.";end end end 
       if ___conditional___ = 10--[[ Nonreturning_statement ]] then do
          return "this statement never returns (or has an unsound type.)";end end end 
       if ___conditional___ = 11--[[ Useless_record_with ]] then do
          return "all the fields are explicitly listed in this record:\nthe 'with' clause is useless.";end end end 
       if ___conditional___ = 12--[[ All_clauses_guarded ]] then do
          return "bad style, all clauses in this pattern-matching are guarded.";end end end 
       if ___conditional___ = 13--[[ Wildcard_arg_to_constant_constr ]] then do
          return "wildcard pattern given as argument to a constant constructor";end end end 
       if ___conditional___ = 14--[[ Eol_in_string ]] then do
          return "unescaped end-of-line in a string constant (non-portable code)";end end end 
       if ___conditional___ = 15--[[ Unused_rec_flag ]] then do
          return "unused rec flag.";end end end 
       if ___conditional___ = 16--[[ Bs_polymorphic_comparison ]] then do
          return "polymorphic comparison introduced (maybe unsafe)";end end end 
       do
      
    end
  end else do
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ = 0--[[ Deprecated ]] then do
          return "deprecated: " .. param[0];end end end 
       if ___conditional___ = 1--[[ Fragile_match ]] then do
          s = param[0];
          if (s == "") then do
            return "this pattern-matching is fragile.";
          end else do
            return "this pattern-matching is fragile.\nIt will remain exhaustive when constructors are added to type " .. (s .. ".");
          end end end end end 
       if ___conditional___ = 2--[[ Method_override ]] then do
          match = param[0];
          if (match) then do
            slist = match[1];
            lab = match[0];
            if (slist) then do
              return __String.concat(" ", --[[ :: ]]{
                          "the following methods are overridden by the class",
                          --[[ :: ]]{
                            lab,
                            --[[ :: ]]{
                              ":\n ",
                              slist
                            }
                          }
                        });
            end else do
              return "the method " .. (lab .. " is overridden.");
            end end 
          end else do
            throw {
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "warnings.ml",
                    283,
                    26
                  }
                };
          end end end end end 
       if ___conditional___ = 3--[[ Partial_match ]] then do
          s$1 = param[0];
          if (s$1 == "") then do
            return "this pattern-matching is not exhaustive.";
          end else do
            return "this pattern-matching is not exhaustive.\nHere is an example of a value that is not matched:\n" .. s$1;
          end end end end end 
       if ___conditional___ = 4--[[ Non_closed_record_pattern ]] then do
          return "the following labels are not bound in this record pattern:\n" .. (param[0] .. "\nEither bind these labels explicitly or add '; _' to the pattern.");end end end 
       if ___conditional___ = 5--[[ Instance_variable_override ]] then do
          match$1 = param[0];
          if (match$1) then do
            slist$1 = match$1[1];
            lab$1 = match$1[0];
            if (slist$1) then do
              return __String.concat(" ", --[[ :: ]]{
                          "the following instance variables are overridden by the class",
                          --[[ :: ]]{
                            lab$1,
                            --[[ :: ]]{
                              ":\n ",
                              slist$1
                            }
                          }
                        }) .. "\nThe behaviour changed in ocaml 3.10 (previous behaviour was hiding.)";
            end else do
              return "the instance variable " .. (lab$1 .. " is overridden.\nThe behaviour changed in ocaml 3.10 (previous behaviour was hiding.)");
            end end 
          end else do
            throw {
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "warnings.ml",
                    303,
                    37
                  }
                };
          end end end end end 
       if ___conditional___ = 6--[[ Implicit_public_methods ]] then do
          return "the following private methods were made public implicitly:\n " .. (__String.concat(" ", param[0]) .. ".");end end end 
       if ___conditional___ = 7--[[ Undeclared_virtual_method ]] then do
          return "the virtual method " .. (param[0] .. " is not declared.");end end end 
       if ___conditional___ = 8--[[ Not_principal ]] then do
          return param[0] .. " is not principal.";end end end 
       if ___conditional___ = 9--[[ Without_principality ]] then do
          return param[0] .. " without principality.";end end end 
       if ___conditional___ = 10--[[ Preprocessor ]] then do
          return param[0];end end end 
       if ___conditional___ = 11--[[ Bad_module_name ]] then do
          return "bad source file name: \"" .. (param[0] .. "\" is not a valid module name.");end end end 
       if ___conditional___ = 12--[[ Unused_var ]]
       or ___conditional___ = 13--[[ Unused_var_strict ]] then do
          return "unused variable " .. (param[0] .. ".");end end end 
       if ___conditional___ = 14--[[ Duplicate_definitions ]] then do
          return Curry._4(Printf.sprintf(--[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "the ",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ Char_literal ]]Block.__(12, {
                                      --[[ " " ]]32,
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ String_literal ]]Block.__(11, {
                                              " is defined in both types ",
                                              --[[ String ]]Block.__(2, {
                                                  --[[ No_padding ]]0,
                                                  --[[ String_literal ]]Block.__(11, {
                                                      " and ",
                                                      --[[ String ]]Block.__(2, {
                                                          --[[ No_padding ]]0,
                                                          --[[ Char_literal ]]Block.__(12, {
                                                              --[[ "." ]]46,
                                                              --[[ End_of_format ]]0
                                                            })
                                                        })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            }),
                          "the %s %s is defined in both types %s and %s."
                        }), param[0], param[1], param[2], param[3]);end end end 
       if ___conditional___ = 15--[[ Multiple_definition ]] then do
          return Curry._3(Printf.sprintf(--[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "files ",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ String_literal ]]Block.__(11, {
                                      " and ",
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ String_literal ]]Block.__(11, {
                                              " both define a module named ",
                                              --[[ String ]]Block.__(2, {
                                                  --[[ No_padding ]]0,
                                                  --[[ End_of_format ]]0
                                                })
                                            })
                                        })
                                    })
                                })
                            }),
                          "files %s and %s both define a module named %s"
                        }), param[1], param[2], param[0]);end end end 
       if ___conditional___ = 16--[[ Unused_value_declaration ]] then do
          return "unused value " .. (param[0] .. ".");end end end 
       if ___conditional___ = 17--[[ Unused_open ]] then do
          return "unused open " .. (param[0] .. ".");end end end 
       if ___conditional___ = 18--[[ Unused_type_declaration ]] then do
          return "unused type " .. (param[0] .. ".");end end end 
       if ___conditional___ = 19--[[ Unused_for_index ]] then do
          return "unused for-loop index " .. (param[0] .. ".");end end end 
       if ___conditional___ = 20--[[ Unused_ancestor ]] then do
          return "unused ancestor variable " .. (param[0] .. ".");end end end 
       if ___conditional___ = 21--[[ Unused_constructor ]] then do
          s$2 = param[0];
          if (param[1]) then do
            return "constructor " .. (s$2 .. " is never used to build values.\n(However, this constructor appears in patterns.)");
          end else if (param[2]) then do
            return "constructor " .. (s$2 .. " is never used to build values.\nIts type is exported as a private type.");
          end else do
            return "unused constructor " .. (s$2 .. ".");
          end end  end end end end 
       if ___conditional___ = 22--[[ Unused_extension ]] then do
          s$3 = param[0];
          if (param[1]) then do
            return "extension constructor " .. (s$3 .. " is never used to build values.\n(However, this constructor appears in patterns.)");
          end else if (param[2]) then do
            return "extension constructor " .. (s$3 .. " is never used to build values.\nIt is exported or rebound as a private extension.");
          end else do
            return "unused extension constructor " .. (s$3 .. ".");
          end end  end end end end 
       if ___conditional___ = 23--[[ Name_out_of_scope ]] then do
          slist$2 = param[1];
          ty = param[0];
          if (slist$2 and not slist$2[1] and not param[2]) then do
            return slist$2[0] .. (" was selected from type " .. (ty .. ".\nIt is not visible in the current scope, and will not \nbe selected if the type becomes unknown."));
          end
           end 
          if (param[2]) then do
            return "this record of type " .. (ty .. (" contains fields that are \nnot visible in the current scope: " .. (__String.concat(" ", slist$2) .. ".\nThey will not be selected if the type becomes unknown.")));
          end else do
            throw {
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "warnings.ml",
                    365,
                    39
                  }
                };
          end end end else 
       if ___conditional___ = 24--[[ Ambiguous_name ]] then do
          slist$3 = param[0];
          if (slist$3 and not slist$3[1] and not param[2]) then do
            return slist$3[0] .. (" belongs to several types: " .. (__String.concat(" ", param[1]) .. "\nThe first one was selected. Please disambiguate if this is wrong."));
          end
           end 
          if (param[2]) then do
            return "these field labels belong to several types: " .. (__String.concat(" ", param[1]) .. "\nThe first one was selected. Please disambiguate if this is wrong.");
          end else do
            throw {
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "warnings.ml",
                    374,
                    36
                  }
                };
          end end end else 
       if ___conditional___ = 25--[[ Disambiguated_name ]] then do
          return "this use of " .. (param[0] .. " required disambiguation.");end end end 
       if ___conditional___ = 26--[[ Nonoptional_label ]] then do
          return "the label " .. (param[0] .. " is not optional.");end end end 
       if ___conditional___ = 27--[[ Open_shadow_identifier ]] then do
          return Curry._2(Printf.sprintf(--[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "this open statement shadows the ",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ String_literal ]]Block.__(11, {
                                      " identifier ",
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ String_literal ]]Block.__(11, {
                                              " (which is later used)",
                                              --[[ End_of_format ]]0
                                            })
                                        })
                                    })
                                })
                            }),
                          "this open statement shadows the %s identifier %s (which is later used)"
                        }), param[0], param[1]);end end end 
       if ___conditional___ = 28--[[ Open_shadow_label_constructor ]] then do
          return Curry._2(Printf.sprintf(--[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "this open statement shadows the ",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ Char_literal ]]Block.__(12, {
                                      --[[ " " ]]32,
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ String_literal ]]Block.__(11, {
                                              " (which is later used)",
                                              --[[ End_of_format ]]0
                                            })
                                        })
                                    })
                                })
                            }),
                          "this open statement shadows the %s %s (which is later used)"
                        }), param[0], param[1]);end end end 
       if ___conditional___ = 29--[[ Bad_env_variable ]] then do
          return Curry._2(Printf.sprintf(--[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "illegal environment variable ",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ String_literal ]]Block.__(11, {
                                      " : ",
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ End_of_format ]]0
                                        })
                                    })
                                })
                            }),
                          "illegal environment variable %s : %s"
                        }), param[0], param[1]);end end end 
       if ___conditional___ = 30--[[ Attribute_payload ]] then do
          return Curry._2(Printf.sprintf(--[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "illegal payload for attribute '",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ String_literal ]]Block.__(11, {
                                      "'.\n",
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ End_of_format ]]0
                                        })
                                    })
                                })
                            }),
                          "illegal payload for attribute '%s'.\n%s"
                        }), param[0], param[1]);end end end 
       if ___conditional___ = 31--[[ Eliminated_optional_arguments ]] then do
          sl = param[0];
          return Curry._2(Printf.sprintf(--[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "implicit elimination of optional argument",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ Char_literal ]]Block.__(12, {
                                      --[[ " " ]]32,
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ End_of_format ]]0
                                        })
                                    })
                                })
                            }),
                          "implicit elimination of optional argument%s %s"
                        }), List.length(sl) == 1 and "" or "s", __String.concat(", ", sl));end end end 
       if ___conditional___ = 32--[[ No_cmi_file ]] then do
          return "no cmi file was found in path for module " .. param[0];end end end 
       if ___conditional___ = 33--[[ Bad_docstring ]] then do
          if (param[0]) then do
            return "unattached documentation comment (ignored)";
          end else do
            return "ambiguous documentation comment";
          end end end end end 
       if ___conditional___ = 34--[[ Bs_unused_attribute ]] then do
          return "Unused BuckleScript attribute: " .. param[0];end end end 
       if ___conditional___ = 35--[[ Bs_ffi_warning ]] then do
          return "BuckleScript FFI warning: " .. param[0];end end end 
       if ___conditional___ = 36--[[ Bs_derive_warning ]] then do
          return "BuckleScript bs.deriving warning: " .. param[0];end end end 
       do
      
    end
  end end 
end end

nerrors = do
  contents: 0
end;

function print(ppf, w) do
  msg = message(w);
  num = number(w);
  Curry._2(Format.fprintf(ppf, --[[ Format ]]{
            --[[ Int ]]Block.__(4, {
                --[[ Int_d ]]0,
                --[[ No_padding ]]0,
                --[[ No_precision ]]0,
                --[[ String_literal ]]Block.__(11, {
                    ": ",
                    --[[ String ]]Block.__(2, {
                        --[[ No_padding ]]0,
                        --[[ End_of_format ]]0
                      })
                  })
              }),
            "%d: %s"
          }), num, msg);
  Format.pp_print_flush(ppf, --[[ () ]]0);
  if (Caml_array.caml_array_get(current.contents.error, num)) then do
    nerrors.contents = nerrors.contents + 1 | 0;
    return --[[ () ]]0;
  end else do
    return 0;
  end end 
end end

Errors = Caml_exceptions.create("Ocaml_typedtree_test.Warnings.Errors");

absname = do
  contents: false
end;

function in_file(name) do
  loc = do
    pos_fname: name,
    pos_lnum: 1,
    pos_bol: 0,
    pos_cnum: -1
  end;
  return do
          loc_start: loc,
          loc_end: loc,
          loc_ghost: true
        end;
end end

none = in_file("_none_");

function curr(lexbuf) do
  return do
          loc_start: lexbuf.lex_start_p,
          loc_end: lexbuf.lex_curr_p,
          loc_ghost: false
        end;
end end

function symbol_rloc(param) do
  return do
          loc_start: Parsing.symbol_start_pos(--[[ () ]]0),
          loc_end: Parsing.symbol_end_pos(--[[ () ]]0),
          loc_ghost: false
        end;
end end

function symbol_gloc(param) do
  return do
          loc_start: Parsing.symbol_start_pos(--[[ () ]]0),
          loc_end: Parsing.symbol_end_pos(--[[ () ]]0),
          loc_ghost: true
        end;
end end

function rhs_loc(n) do
  return do
          loc_start: Parsing.rhs_start_pos(n),
          loc_end: Parsing.rhs_end_pos(n),
          loc_ghost: false
        end;
end end

input_name = do
  contents: "_none_"
end;

input_lexbuf = do
  contents: undefined
end;

status = do
  contents: --[[ Uninitialised ]]0
end;

num_loc_lines = do
  contents: 0
end;

function highlight_terminfo(ppf, num_lines, lb, locs) do
  Format.pp_print_flush(ppf, --[[ () ]]0);
  pos0 = -lb.lex_abs_pos | 0;
  if (pos0 < 0) then do
    throw Pervasives.Exit;
  end
   end 
  lines = num_loc_lines.contents;
  for i = pos0 , lb.lex_buffer_len - 1 | 0 , 1 do
    if (Caml_bytes.get(lb.lex_buffer, i) == --[[ "\n" ]]10) then do
      lines = lines + 1 | 0;
    end
     end 
  end
  if (lines >= (num_lines - 2 | 0)) then do
    throw Pervasives.Exit;
  end
   end 
  Caml_io.caml_ml_flush(Pervasives.stdout);
  Caml_external_polyfill.resolve("caml_terminfo_backup")(lines);
  bol = false;
  Pervasives.print_string("# ");
  for pos = 0 , (lb.lex_buffer_len - pos0 | 0) - 1 | 0 , 1 do
    if (bol) then do
      Pervasives.print_string("  ");
      bol = false;
    end
     end 
    if (List.exists((function(pos)do
          return function (loc) do
            return pos == loc.loc_start.pos_cnum;
          end end
          end(pos)), locs)) then do
      Caml_external_polyfill.resolve("caml_terminfo_standout")(true);
    end
     end 
    if (List.exists((function(pos)do
          return function (loc) do
            return pos == loc.loc_end.pos_cnum;
          end end
          end(pos)), locs)) then do
      Caml_external_polyfill.resolve("caml_terminfo_standout")(false);
    end
     end 
    c = Caml_bytes.get(lb.lex_buffer, pos + pos0 | 0);
    Pervasives.print_char(c);
    bol = c == --[[ "\n" ]]10;
  end
  Caml_external_polyfill.resolve("caml_terminfo_standout")(false);
  Caml_external_polyfill.resolve("caml_terminfo_resume")(num_loc_lines.contents);
  return Caml_io.caml_ml_flush(Pervasives.stdout);
end end

function highlight_dumb(ppf, lb, loc) do
  pos0 = -lb.lex_abs_pos | 0;
  if (pos0 < 0) then do
    throw Pervasives.Exit;
  end
   end 
  end_pos = (lb.lex_buffer_len - pos0 | 0) - 1 | 0;
  line_start = 0;
  line_end = 0;
  for pos = 0 , end_pos , 1 do
    if (Caml_bytes.get(lb.lex_buffer, pos + pos0 | 0) == --[[ "\n" ]]10) then do
      if (loc.loc_start.pos_cnum > pos) then do
        line_start = line_start + 1 | 0;
      end
       end 
      if (loc.loc_end.pos_cnum > pos) then do
        line_end = line_end + 1 | 0;
      end
       end 
    end
     end 
  end
  Curry._2(Format.fprintf(ppf, --[[ Format ]]{
            --[[ String_literal ]]Block.__(11, {
                "Characters ",
                --[[ Int ]]Block.__(4, {
                    --[[ Int_i ]]3,
                    --[[ No_padding ]]0,
                    --[[ No_precision ]]0,
                    --[[ Char_literal ]]Block.__(12, {
                        --[[ "-" ]]45,
                        --[[ Int ]]Block.__(4, {
                            --[[ Int_i ]]3,
                            --[[ No_padding ]]0,
                            --[[ No_precision ]]0,
                            --[[ Char_literal ]]Block.__(12, {
                                --[[ ":" ]]58,
                                --[[ Formatting_lit ]]Block.__(17, {
                                    --[[ Flush_newline ]]4,
                                    --[[ End_of_format ]]0
                                  })
                              })
                          })
                      })
                  })
              }),
            "Characters %i-%i:@."
          }), loc.loc_start.pos_cnum, loc.loc_end.pos_cnum);
  Format.pp_print_string(ppf, "  ");
  line = 0;
  pos_at_bol = 0;
  for pos$1 = 0 , end_pos , 1 do
    c = Caml_bytes.get(lb.lex_buffer, pos$1 + pos0 | 0);
    if (c ~= 10) then do
      if (c ~= 13) then do
        if (line == line_start and line == line_end) then do
          Format.pp_print_char(ppf, c);
        end else if (line == line_start) then do
          if (pos$1 < loc.loc_start.pos_cnum) then do
            Format.pp_print_char(ppf, --[[ "." ]]46);
          end else do
            Format.pp_print_char(ppf, c);
          end end 
        end else if (line == line_end) then do
          if (pos$1 < loc.loc_end.pos_cnum) then do
            Format.pp_print_char(ppf, c);
          end else do
            Format.pp_print_char(ppf, --[[ "." ]]46);
          end end 
        end else if (line > line_start and line < line_end) then do
          Format.pp_print_char(ppf, c);
        end
         end  end  end  end 
      end
       end 
    end else do
      if (line == line_start and line == line_end) then do
        Format.fprintf(ppf, --[[ Format ]]{
              --[[ Formatting_lit ]]Block.__(17, {
                  --[[ Flush_newline ]]4,
                  --[[ String_literal ]]Block.__(11, {
                      "  ",
                      --[[ End_of_format ]]0
                    })
                }),
              "@.  "
            });
        for _i = pos_at_bol , loc.loc_start.pos_cnum - 1 | 0 , 1 do
          Format.pp_print_char(ppf, --[[ " " ]]32);
        end
        for _i$1 = loc.loc_start.pos_cnum , loc.loc_end.pos_cnum - 1 | 0 , 1 do
          Format.pp_print_char(ppf, --[[ "^" ]]94);
        end
      end
       end 
      if (line >= line_start and line <= line_end) then do
        Format.fprintf(ppf, --[[ Format ]]{
              --[[ Formatting_lit ]]Block.__(17, {
                  --[[ Flush_newline ]]4,
                  --[[ End_of_format ]]0
                }),
              "@."
            });
        if (pos$1 < loc.loc_end.pos_cnum) then do
          Format.pp_print_string(ppf, "  ");
        end
         end 
      end
       end 
      line = line + 1 | 0;
      pos_at_bol = pos$1 + 1 | 0;
    end end 
  end
  return --[[ () ]]0;
end end

function highlight_locations(ppf, locs) do
  while(true) do
    match = status.contents;
    if (typeof match == "number") then do
      if (match ~= 0) then do
        match$1 = input_lexbuf.contents;
        if (match$1 ~= undefined) then do
          norepeat;
          try do
            norepeat = Caml_sys.caml_sys_getenv("TERM") == "norepeat";
          end
          catch (exn)do
            if (exn == Caml_builtin_exceptions.not_found) then do
              norepeat = false;
            end else do
              throw exn;
            end end 
          end
          if (norepeat) then do
            return false;
          end else do
            loc1 = List.hd(locs);
            try do
              highlight_dumb(ppf, match$1, loc1);
              return true;
            end
            catch (exn$1)do
              if (exn$1 == Pervasives.Exit) then do
                return false;
              end else do
                throw exn$1;
              end end 
            end
          end end 
        end else do
          return false;
        end end 
      end else do
        status.contents = Caml_external_polyfill.resolve("caml_terminfo_setup")(Pervasives.stdout);
        continue ;
      end end 
    end else do
      match$2 = input_lexbuf.contents;
      if (match$2 ~= undefined) then do
        try do
          highlight_terminfo(ppf, match[0], match$2, locs);
          return true;
        end
        catch (exn$2)do
          if (exn$2 == Pervasives.Exit) then do
            return false;
          end else do
            throw exn$2;
          end end 
        end
      end else do
        return false;
      end end 
    end end 
  end;
end end

function show_filename(file) do
  if (absname.contents) then do
    s = file;
    s$1 = Curry._1(Filename.is_relative, s) and Filename.concat(Caml_sys.caml_sys_getcwd(--[[ () ]]0), s) or s;
    aux = function (_s) do
      while(true) do
        s = _s;
        base = Curry._1(Filename.basename, s);
        dir = Curry._1(Filename.dirname, s);
        if (dir == s) then do
          return dir;
        end else if (base == Filename.current_dir_name) then do
          _s = dir;
          continue ;
        end else if (base == Filename.parent_dir_name) then do
          return Curry._1(Filename.dirname, aux(dir));
        end else do
          return Filename.concat(aux(dir), base);
        end end  end  end 
      end;
    end end;
    return aux(s$1);
  end else do
    return file;
  end end 
end end

function print_filename(ppf, file) do
  return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                  --[[ String ]]Block.__(2, {
                      --[[ No_padding ]]0,
                      --[[ End_of_format ]]0
                    }),
                  "%s"
                }), show_filename(file));
end end

function get_pos_info(pos) do
  return --[[ tuple ]]{
          pos.pos_fname,
          pos.pos_lnum,
          pos.pos_cnum - pos.pos_bol | 0
        };
end end

function print_loc(ppf, loc) do
  Curry._1(Misc_Color.setup, color.contents);
  match = get_pos_info(loc.loc_start);
  startchar = match[2];
  file = match[0];
  startchar$1 = bs_vscode and startchar + 1 | 0 or startchar;
  endchar = (loc.loc_end.pos_cnum - loc.loc_start.pos_cnum | 0) + startchar$1 | 0;
  if (file == "//toplevel//") then do
    if (highlight_locations(ppf, --[[ :: ]]{
            loc,
            --[[ [] ]]0
          })) then do
      return --[[ () ]]0;
    end else do
      return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "Characters ",
                          --[[ Int ]]Block.__(4, {
                              --[[ Int_i ]]3,
                              --[[ No_padding ]]0,
                              --[[ No_precision ]]0,
                              --[[ Char_literal ]]Block.__(12, {
                                  --[[ "-" ]]45,
                                  --[[ Int ]]Block.__(4, {
                                      --[[ Int_i ]]3,
                                      --[[ No_padding ]]0,
                                      --[[ No_precision ]]0,
                                      --[[ End_of_format ]]0
                                    })
                                })
                            })
                        }),
                      "Characters %i-%i"
                    }), loc.loc_start.pos_cnum, loc.loc_end.pos_cnum);
    end end 
  end else do
    Curry._5(Format.fprintf(ppf, --[[ Format ]]{
              --[[ String ]]Block.__(2, {
                  --[[ No_padding ]]0,
                  --[[ Formatting_gen ]]Block.__(18, {
                      --[[ Open_tag ]]Block.__(0, {--[[ Format ]]{
                            --[[ String_literal ]]Block.__(11, {
                                "<loc>",
                                --[[ End_of_format ]]0
                              }),
                            "<loc>"
                          }}),
                      --[[ Alpha ]]Block.__(15, {--[[ String ]]Block.__(2, {
                              --[[ No_padding ]]0,
                              --[[ Int ]]Block.__(4, {
                                  --[[ Int_i ]]3,
                                  --[[ No_padding ]]0,
                                  --[[ No_precision ]]0,
                                  --[[ End_of_format ]]0
                                })
                            })})
                    })
                }),
              "%s@{<loc>%a%s%i"
            }), "File \"", print_filename, file, "\", line ", match[1]);
    if (startchar$1 >= 0) then do
      Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                --[[ String ]]Block.__(2, {
                    --[[ No_padding ]]0,
                    --[[ Int ]]Block.__(4, {
                        --[[ Int_i ]]3,
                        --[[ No_padding ]]0,
                        --[[ No_precision ]]0,
                        --[[ String ]]Block.__(2, {
                            --[[ No_padding ]]0,
                            --[[ Int ]]Block.__(4, {
                                --[[ Int_i ]]3,
                                --[[ No_padding ]]0,
                                --[[ No_precision ]]0,
                                --[[ End_of_format ]]0
                              })
                          })
                      })
                  }),
                "%s%i%s%i"
              }), ", characters ", startchar$1, "-", endchar);
    end
     end 
    return Format.fprintf(ppf, --[[ Format ]]{
                --[[ Formatting_lit ]]Block.__(17, {
                    --[[ Close_tag ]]1,
                    --[[ End_of_format ]]0
                  }),
                "@}"
              });
  end end 
end end

function print$1(ppf, loc) do
  Curry._1(Misc_Color.setup, color.contents);
  if (loc.loc_start.pos_fname == "//toplevel//" and highlight_locations(ppf, --[[ :: ]]{
          loc,
          --[[ [] ]]0
        })) then do
    return --[[ () ]]0;
  end else do
    return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_tag ]]Block.__(0, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<loc>",
                                  --[[ End_of_format ]]0
                                }),
                              "<loc>"
                            }}),
                        --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                --[[ Close_tag ]]1,
                                --[[ String ]]Block.__(2, {
                                    --[[ No_padding ]]0,
                                    --[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Flush_newline ]]4,
                                        --[[ End_of_format ]]0
                                      })
                                  })
                              })})
                      }),
                    "@{<loc>%a@}%s@."
                  }), print_loc, loc, ":");
  end end 
end end

error_prefix = "Error";

function print_error(ppf, loc) do
  print$1(ppf, loc);
  ppf$1 = ppf;
  Curry._1(Misc_Color.setup, color.contents);
  Curry._1(Format.fprintf(ppf$1, --[[ Format ]]{
            --[[ Formatting_gen ]]Block.__(18, {
                --[[ Open_tag ]]Block.__(0, {--[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "<error>",
                          --[[ End_of_format ]]0
                        }),
                      "<error>"
                    }}),
                --[[ String ]]Block.__(2, {
                    --[[ No_padding ]]0,
                    --[[ Formatting_lit ]]Block.__(17, {
                        --[[ Close_tag ]]1,
                        --[[ Char_literal ]]Block.__(12, {
                            --[[ ":" ]]58,
                            --[[ End_of_format ]]0
                          })
                      })
                  })
              }),
            "@{<error>%s@}:"
          }), error_prefix);
  return --[[ () ]]0;
end end

function default_warning_printer(loc, ppf, w) do
  if (is_active(w)) then do
    Curry._1(Misc_Color.setup, color.contents);
    print$1(ppf, loc);
    return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_tag ]]Block.__(0, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<warning>",
                                  --[[ End_of_format ]]0
                                }),
                              "<warning>"
                            }}),
                        --[[ String ]]Block.__(2, {
                            --[[ No_padding ]]0,
                            --[[ Formatting_lit ]]Block.__(17, {
                                --[[ Close_tag ]]1,
                                --[[ Char_literal ]]Block.__(12, {
                                    --[[ " " ]]32,
                                    --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Flush_newline ]]4,
                                            --[[ End_of_format ]]0
                                          })})
                                  })
                              })
                          })
                      }),
                    "@{<warning>%s@} %a@."
                  }), "Warning", print, w);
  end else do
    return 0;
  end end 
end end

warning_printer = do
  contents: default_warning_printer
end;

formatter_for_warnings = do
  contents: Format.err_formatter
end;

function prerr_warning(loc, w) do
  loc$1 = loc;
  ppf = formatter_for_warnings.contents;
  w$1 = w;
  ppf$1 = ppf;
  f = Curry._1(warning_printer.contents, loc$1);
  arg = w$1;
  out_functions = Format.pp_get_formatter_out_functions(ppf$1, --[[ () ]]0);
  out_string = function (str, start, len) do
    count = function (_i, _c) do
      while(true) do
        c = _c;
        i = _i;
        if (i == (start + len | 0)) then do
          return c;
        end else if (Caml_string.get(str, i) == --[[ "\n" ]]10) then do
          _c = c + 1 | 0;
          _i = i + 1 | 0;
          continue ;
        end else do
          _i = i + 1 | 0;
          continue ;
        end end  end 
      end;
    end end;
    num_loc_lines.contents = num_loc_lines.contents + count(start, 0) | 0;
    return Curry._3(out_functions.out_string, str, start, len);
  end end;
  Format.pp_set_formatter_out_functions(ppf$1, do
        out_string: out_string,
        out_flush: out_functions.out_flush,
        out_newline: out_functions.out_newline,
        out_spaces: out_functions.out_spaces,
        out_indent: out_functions.out_indent
      end);
  Curry._2(f, ppf$1, arg);
  Format.pp_print_flush(ppf$1, --[[ () ]]0);
  return Format.pp_set_formatter_out_functions(ppf$1, out_functions);
end end

function print_phanton_error_prefix(ppf) do
  return Format.pp_print_as(ppf, #error_prefix + 2 | 0, "");
end end

function errorf(locOpt, subOpt, if_highlightOpt, fmt) do
  loc = locOpt ~= undefined and locOpt or none;
  sub = subOpt ~= undefined and subOpt or --[[ [] ]]0;
  if_highlight = if_highlightOpt ~= undefined and if_highlightOpt or "";
  before = print_phanton_error_prefix;
  k = function (msg) do
    return do
            loc: loc,
            msg: msg,
            sub: sub,
            if_highlight: if_highlight
          end;
  end end;
  fmt$1 = fmt;
  buf = __Buffer.create(64);
  ppf = Format.formatter_of_buffer(buf);
  Curry._1(Misc_Color.set_color_tag_handling, ppf);
  if (before ~= undefined) then do
    Curry._1(before, ppf);
  end
   end 
  return Format.kfprintf((function (param) do
                Format.pp_print_flush(ppf, --[[ () ]]0);
                return Curry._1(k, __Buffer.contents(buf));
              end end), ppf, fmt$1);
end end

function error(locOpt, subOpt, if_highlightOpt, msg) do
  loc = locOpt ~= undefined and locOpt or none;
  sub = subOpt ~= undefined and subOpt or --[[ [] ]]0;
  if_highlight = if_highlightOpt ~= undefined and if_highlightOpt or "";
  return do
          loc: loc,
          msg: msg,
          sub: sub,
          if_highlight: if_highlight
        end;
end end

error_of_exn = do
  contents: --[[ [] ]]0
end;

function register_error_of_exn(f) do
  error_of_exn.contents = --[[ :: ]]{
    f,
    error_of_exn.contents
  };
  return --[[ () ]]0;
end end

function error_of_printer(loc, print, x) do
  return Curry._2(errorf(loc, undefined, undefined, --[[ Format ]]{
                  --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                          --[[ FFlush ]]2,
                          --[[ End_of_format ]]0
                        })}),
                  "%a@?"
                }), print, x);
end end

function error_of_printer_file(print, x) do
  return error_of_printer(in_file(input_name.contents), print, x);
end end

register_error_of_exn((function (param) do
        if (param[0] == Caml_builtin_exceptions.sys_error) then do
          return Curry._1(errorf(in_file(input_name.contents), undefined, undefined, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "I/O error: ",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ End_of_format ]]0
                                })
                            }),
                          "I/O error: %s"
                        }), param[1]);
        end else if (param[0] == Errors) then do
          return Curry._1(errorf(in_file(input_name.contents), undefined, undefined, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "Some fatal warnings were triggered (",
                              --[[ Int ]]Block.__(4, {
                                  --[[ Int_d ]]0,
                                  --[[ No_padding ]]0,
                                  --[[ No_precision ]]0,
                                  --[[ String_literal ]]Block.__(11, {
                                      " occurrences)",
                                      --[[ End_of_format ]]0
                                    })
                                })
                            }),
                          "Some fatal warnings were triggered (%d occurrences)"
                        }), param[1]);
        end else do
          return ;
        end end  end 
      end end));

__Error = Caml_exceptions.create("Ocaml_typedtree_test.Location.Error");

register_error_of_exn((function (param) do
        if (param[0] == __Error) then do
          return param[1];
        end
         end 
      end end));

currentstamp = do
  contents: 0
end;

function create(s) do
  currentstamp.contents = currentstamp.contents + 1 | 0;
  return do
          stamp: currentstamp.contents,
          name: s,
          flags: 0
        end;
end end

function create_predef_exn(s) do
  currentstamp.contents = currentstamp.contents + 1 | 0;
  return do
          stamp: currentstamp.contents,
          name: s,
          flags: 2
        end;
end end

function rename(i) do
  currentstamp.contents = currentstamp.contents + 1 | 0;
  return do
          stamp: currentstamp.contents,
          name: i.name,
          flags: i.flags
        end;
end end

function unique_toplevel_name(i) do
  return i.name .. ("/" .. String(i.stamp));
end end

function equal(i1, i2) do
  return i1.name == i2.name;
end end

function set_current_time(t) do
  currentstamp.contents = currentstamp.contents > t and currentstamp.contents or t;
  return --[[ () ]]0;
end end

function hide(i) do
  return do
          stamp: -1,
          name: i.name,
          flags: i.flags
        end;
end end

function make_global(i) do
  i.flags = i.flags | 1;
  return --[[ () ]]0;
end end

function __global(i) do
  return (i.flags & 1) ~= 0;
end end

function print$2(ppf, i) do
  n = i.stamp;
  if (n ~= -1) then do
    if (n ~= 0) then do
      return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String ]]Block.__(2, {
                          --[[ No_padding ]]0,
                          --[[ Char_literal ]]Block.__(12, {
                              --[[ "/" ]]47,
                              --[[ Int ]]Block.__(4, {
                                  --[[ Int_i ]]3,
                                  --[[ No_padding ]]0,
                                  --[[ No_precision ]]0,
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ End_of_format ]]0
                                    })
                                })
                            })
                        }),
                      "%s/%i%s"
                    }), i.name, n, __global(i) and "g" or "");
    end else do
      return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String ]]Block.__(2, {
                          --[[ No_padding ]]0,
                          --[[ Char_literal ]]Block.__(12, {
                              --[[ "!" ]]33,
                              --[[ End_of_format ]]0
                            })
                        }),
                      "%s!"
                    }), i.name);
    end end 
  end else do
    return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ String ]]Block.__(2, {
                        --[[ No_padding ]]0,
                        --[[ Char_literal ]]Block.__(12, {
                            --[[ "#" ]]35,
                            --[[ End_of_format ]]0
                          })
                      }),
                    "%s#"
                  }), i.name);
  end end 
end end

function mknode(l, d, r) do
  hl = l and l[3] or 0;
  hr = r and r[3] or 0;
  return --[[ Node ]]{
          l,
          d,
          r,
          hl >= hr and hl + 1 | 0 or hr + 1 | 0
        };
end end

function balance(l, d, r) do
  hl = l and l[3] or 0;
  hr = r and r[3] or 0;
  if (hl > (hr + 1 | 0)) then do
    if (l) then do
      lr = l[2];
      ld = l[1];
      ll = l[0];
      if ((
          ll and ll[3] or 0
        ) >= (
          lr and lr[3] or 0
        )) then do
        return mknode(ll, ld, mknode(lr, d, r));
      end else if (lr) then do
        return mknode(mknode(ll, ld, lr[0]), lr[1], mknode(lr[2], d, r));
      end else do
        throw {
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "ident.ml",
                120,
                11
              }
            };
      end end  end 
    end else do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "ident.ml",
              120,
              11
            }
          };
    end end 
  end else if (hr > (hl + 1 | 0)) then do
    if (r) then do
      rl = r[0];
      rr = r[2];
      if ((
          rr and rr[3] or 0
        ) >= (
          rl and rl[3] or 0
        )) then do
        return mknode(mknode(l, d, rl), r[1], rr);
      end else if (rl) then do
        return mknode(mknode(l, d, rl[0]), rl[1], mknode(rl[2], r[1], r[2]));
      end else do
        throw {
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "ident.ml",
                129,
                11
              }
            };
      end end  end 
    end else do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "ident.ml",
              129,
              11
            }
          };
    end end 
  end else do
    return mknode(l, d, r);
  end end  end 
end end

function add(id, data, param) do
  if (param) then do
    r = param[2];
    k = param[1];
    l = param[0];
    c = Caml_primitive.caml_string_compare(id.name, k.ident.name);
    if (c == 0) then do
      return --[[ Node ]]{
              l,
              do
                ident: id,
                data: data,
                previous: k
              end,
              r,
              param[3]
            };
    end else if (c < 0) then do
      return balance(add(id, data, l), k, r);
    end else do
      return balance(l, k, add(id, data, r));
    end end  end 
  end else do
    return --[[ Node ]]{
            --[[ Empty ]]0,
            do
              ident: id,
              data: data,
              previous: undefined
            end,
            --[[ Empty ]]0,
            1
          };
  end end 
end end

function find_same(id, _param) do
  while(true) do
    param = _param;
    if (param) then do
      k = param[1];
      c = Caml_primitive.caml_string_compare(id.name, k.ident.name);
      if (c == 0) then do
        if (id.stamp == k.ident.stamp) then do
          return k.data;
        end else do
          s = id.stamp;
          _param$1 = k.previous;
          while(true) do
            param$1 = _param$1;
            if (param$1 ~= undefined) then do
              k$1 = param$1;
              if (k$1.ident.stamp == s) then do
                return k$1.data;
              end else do
                _param$1 = k$1.previous;
                continue ;
              end end 
            end else do
              throw Caml_builtin_exceptions.not_found;
            end end 
          end;
        end end 
      end else do
        _param = c < 0 and param[0] or param[2];
        continue ;
      end end 
    end else do
      throw Caml_builtin_exceptions.not_found;
    end end 
  end;
end end

function find_name(name, _param) do
  while(true) do
    param = _param;
    if (param) then do
      k = param[1];
      c = Caml_primitive.caml_string_compare(name, k.ident.name);
      if (c == 0) then do
        return k.data;
      end else do
        _param = c < 0 and param[0] or param[2];
        continue ;
      end end 
    end else do
      throw Caml_builtin_exceptions.not_found;
    end end 
  end;
end end

function get_all(param) do
  if (param ~= undefined) then do
    k = param;
    return --[[ :: ]]{
            k.data,
            get_all(k.previous)
          };
  end else do
    return --[[ [] ]]0;
  end end 
end end

function find_all(name, _param) do
  while(true) do
    param = _param;
    if (param) then do
      k = param[1];
      c = Caml_primitive.caml_string_compare(name, k.ident.name);
      if (c == 0) then do
        return --[[ :: ]]{
                k.data,
                get_all(k.previous)
              };
      end else do
        _param = c < 0 and param[0] or param[2];
        continue ;
      end end 
    end else do
      return --[[ [] ]]0;
    end end 
  end;
end end

function iter(f, _param) do
  while(true) do
    param = _param;
    if (param) then do
      k = param[1];
      iter(f, param[0]);
      Curry._2(f, k.ident, k.data);
      _param = param[2];
      continue ;
    end else do
      return --[[ () ]]0;
    end end 
  end;
end end

function same(_p1, _p2) do
  while(true) do
    p2 = _p2;
    p1 = _p1;
    local ___conditional___=(p1.tag | 0);
    do
       if ___conditional___ = 0--[[ Pident ]] then do
          local ___conditional___=(p2.tag | 0);
          do
             if ___conditional___ = 0--[[ Pident ]] then do
                return Caml_obj.caml_equal(p1[0], p2[0]);end end end 
             if ___conditional___ = 1--[[ Pdot ]]
             or ___conditional___ = 2--[[ Papply ]] then do
                return false;end end end 
             do
            
          endend end end 
       if ___conditional___ = 1--[[ Pdot ]] then do
          local ___conditional___=(p2.tag | 0);
          do
             if ___conditional___ = 1--[[ Pdot ]] then do
                if (p1[1] == p2[1]) then do
                  _p2 = p2[0];
                  _p1 = p1[0];
                  continue ;
                end else do
                  return false;
                end end end end end 
             if ___conditional___ = 0--[[ Pident ]]
             or ___conditional___ = 2--[[ Papply ]] then do
                return false;end end end 
             do
            
          endend end end 
       if ___conditional___ = 2--[[ Papply ]] then do
          local ___conditional___=(p2.tag | 0);
          do
             if ___conditional___ = 0--[[ Pident ]]
             or ___conditional___ = 1--[[ Pdot ]] then do
                return false;end end end 
             if ___conditional___ = 2--[[ Papply ]] then do
                if (same(p1[0], p2[0])) then do
                  _p2 = p2[1];
                  _p1 = p1[1];
                  continue ;
                end else do
                  return false;
                end end end end end 
             do
            
          endend end end 
       do
      
    end
  end;
end end

function isfree(id, _param) do
  while(true) do
    param = _param;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ = 0--[[ Pident ]] then do
          return Caml_obj.caml_equal(id, param[0]);end end end 
       if ___conditional___ = 1--[[ Pdot ]] then do
          _param = param[0];
          continue ;end end end 
       if ___conditional___ = 2--[[ Papply ]] then do
          if (isfree(id, param[0])) then do
            return true;
          end else do
            _param = param[1];
            continue ;
          end end end end end 
       do
      
    end
  end;
end end

function binding_time(_param) do
  while(true) do
    param = _param;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ = 0--[[ Pident ]] then do
          return param[0].stamp;end end end 
       if ___conditional___ = 1--[[ Pdot ]] then do
          _param = param[0];
          continue ;end end end 
       if ___conditional___ = 2--[[ Papply ]] then do
          return Caml_primitive.caml_int_max(binding_time(param[0]), binding_time(param[1]));end end end 
       do
      
    end
  end;
end end

function kfalse(x) do
  return false;
end end

function name($staropt$star, param) do
  paren = $staropt$star ~= undefined and $staropt$star or kfalse;
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Pident ]] then do
        return param[0].name;end end end 
     if ___conditional___ = 1--[[ Pdot ]] then do
        s = param[1];
        return name(paren, param[0]) .. (
                Curry._1(paren, s) and ".( " .. (s .. " )") or "." .. s
              );end end end 
     if ___conditional___ = 2--[[ Papply ]] then do
        return name(paren, param[0]) .. ("(" .. (name(paren, param[1]) .. ")"));end end end 
     do
    
  end
end end

function head(_param) do
  while(true) do
    param = _param;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ = 0--[[ Pident ]] then do
          return param[0];end end end 
       if ___conditional___ = 1--[[ Pdot ]] then do
          _param = param[0];
          continue ;end end end 
       if ___conditional___ = 2--[[ Papply ]] then do
          throw {
                Caml_builtin_exceptions.assert_failure,
                --[[ tuple ]]{
                  "path.ml",
                  49,
                  22
                }
              };end end end 
       do
      
    end
  end;
end end

function last(_param) do
  while(true) do
    param = _param;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ = 0--[[ Pident ]] then do
          return param[0].name;end end end 
       if ___conditional___ = 1--[[ Pdot ]] then do
          return param[1];end end end 
       if ___conditional___ = 2--[[ Papply ]] then do
          _param = param[1];
          continue ;end end end 
       do
      
    end
  end;
end end

function flat(_accu, _param) do
  while(true) do
    param = _param;
    accu = _accu;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ = 0--[[ Lident ]] then do
          return --[[ :: ]]{
                  param[0],
                  accu
                };end end end 
       if ___conditional___ = 1--[[ Ldot ]] then do
          _param = param[0];
          _accu = --[[ :: ]]{
            param[1],
            accu
          };
          continue ;end end end 
       if ___conditional___ = 2--[[ Lapply ]] then do
          return fatal_error("Longident.flat");end end end 
       do
      
    end
  end;
end end

function flatten(lid) do
  return flat(--[[ [] ]]0, lid);
end end

function last$1(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Lident ]] then do
        return param[0];end end end 
     if ___conditional___ = 1--[[ Ldot ]] then do
        return param[1];end end end 
     if ___conditional___ = 2--[[ Lapply ]] then do
        return fatal_error("Longident.last");end end end 
     do
    
  end
end end

function parse_declaration(arity, decl) do
  if (decl) then do
    match = decl[1];
    name = decl[0];
    if (match) then do
      name2 = match[0];
      if (name2 == "noalloc") then do
        match$1 = match[1];
        if (match$1) then do
          match$2 = match$1[1];
          name2$1 = match$1[0];
          if (match$2 and match$2[0] == "float") then do
            return do
                    prim_name: name,
                    prim_arity: arity,
                    prim_alloc: false,
                    prim_native_name: name2$1,
                    prim_native_float: true
                  end;
          end else do
            return do
                    prim_name: name,
                    prim_arity: arity,
                    prim_alloc: false,
                    prim_native_name: name2$1,
                    prim_native_float: false
                  end;
          end end 
        end
         end 
      end else do
        match$3 = match[1];
        if (match$3 and match$3[0] == "float") then do
          return do
                  prim_name: name,
                  prim_arity: arity,
                  prim_alloc: true,
                  prim_native_name: name2,
                  prim_native_float: true
                end;
        end
         end 
      end end 
      if (name2 == "noalloc") then do
        return do
                prim_name: name,
                prim_arity: arity,
                prim_alloc: false,
                prim_native_name: "",
                prim_native_float: false
              end;
      end else do
        return do
                prim_name: name,
                prim_arity: arity,
                prim_alloc: true,
                prim_native_name: name2,
                prim_native_float: false
              end;
      end end 
    end else do
      return do
              prim_name: name,
              prim_arity: arity,
              prim_alloc: true,
              prim_native_name: "",
              prim_native_float: false
            end;
    end end 
  end else do
    return fatal_error("Primitive.parse_declaration");
  end end 
end end

function description_list(p) do
  list_000 = p.prim_name;
  list = --[[ :: ]]{
    list_000,
    --[[ [] ]]0
  };
  list$1 = p.prim_alloc and list or --[[ :: ]]{
      "noalloc",
      list
    };
  list$2 = p.prim_native_name ~= "" and --[[ :: ]]{
      p.prim_native_name,
      list$1
    } or list$1;
  return List.rev(p.prim_native_float and --[[ :: ]]{
                "float",
                list$2
              } or list$2);
end end

function compare(t1, t2) do
  return t1.id - t2.id | 0;
end end

function hash(t) do
  return t.id;
end end

function equal$1(t1, t2) do
  return t1 == t2;
end end

function height(param) do
  if (param) then do
    return param[--[[ h ]]4];
  end else do
    return 0;
  end end 
end end

function create$1(l, x, d, r) do
  hl = height(l);
  hr = height(r);
  return --[[ Node ]]{
          --[[ l ]]l,
          --[[ v ]]x,
          --[[ d ]]d,
          --[[ r ]]r,
          --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
        };
end end

function bal(l, x, d, r) do
  hl = l and l[--[[ h ]]4] or 0;
  hr = r and r[--[[ h ]]4] or 0;
  if (hl > (hr + 2 | 0)) then do
    if (l) then do
      lr = l[--[[ r ]]3];
      ld = l[--[[ d ]]2];
      lv = l[--[[ v ]]1];
      ll = l[--[[ l ]]0];
      if (height(ll) >= height(lr)) then do
        return create$1(ll, lv, ld, create$1(lr, x, d, r));
      end else if (lr) then do
        return create$1(create$1(ll, lv, ld, lr[--[[ l ]]0]), lr[--[[ v ]]1], lr[--[[ d ]]2], create$1(lr[--[[ r ]]3], x, d, r));
      end else do
        throw {
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            };
      end end  end 
    end else do
      throw {
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          };
    end end 
  end else if (hr > (hl + 2 | 0)) then do
    if (r) then do
      rr = r[--[[ r ]]3];
      rd = r[--[[ d ]]2];
      rv = r[--[[ v ]]1];
      rl = r[--[[ l ]]0];
      if (height(rr) >= height(rl)) then do
        return create$1(create$1(l, x, d, rl), rv, rd, rr);
      end else if (rl) then do
        return create$1(create$1(l, x, d, rl[--[[ l ]]0]), rl[--[[ v ]]1], rl[--[[ d ]]2], create$1(rl[--[[ r ]]3], rv, rd, rr));
      end else do
        throw {
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            };
      end end  end 
    end else do
      throw {
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          };
    end end 
  end else do
    return --[[ Node ]]{
            --[[ l ]]l,
            --[[ v ]]x,
            --[[ d ]]d,
            --[[ r ]]r,
            --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
          };
  end end  end 
end end

function add$1(x, data, m) do
  if (m) then do
    r = m[--[[ r ]]3];
    d = m[--[[ d ]]2];
    v = m[--[[ v ]]1];
    l = m[--[[ l ]]0];
    c = Caml_primitive.caml_string_compare(x, v);
    if (c == 0) then do
      if (d == data) then do
        return m;
      end else do
        return --[[ Node ]]{
                --[[ l ]]l,
                --[[ v ]]x,
                --[[ d ]]data,
                --[[ r ]]r,
                --[[ h ]]m[--[[ h ]]4]
              };
      end end 
    end else if (c < 0) then do
      ll = add$1(x, data, l);
      if (l == ll) then do
        return m;
      end else do
        return bal(ll, v, d, r);
      end end 
    end else do
      rr = add$1(x, data, r);
      if (r == rr) then do
        return m;
      end else do
        return bal(l, v, d, rr);
      end end 
    end end  end 
  end else do
    return --[[ Node ]]{
            --[[ l : Empty ]]0,
            --[[ v ]]x,
            --[[ d ]]data,
            --[[ r : Empty ]]0,
            --[[ h ]]1
          };
  end end 
end end

function find(x, _param) do
  while(true) do
    param = _param;
    if (param) then do
      c = Caml_primitive.caml_string_compare(x, param[--[[ v ]]1]);
      if (c == 0) then do
        return param[--[[ d ]]2];
      end else do
        _param = c < 0 and param[--[[ l ]]0] or param[--[[ r ]]3];
        continue ;
      end end 
    end else do
      throw Caml_builtin_exceptions.not_found;
    end end 
  end;
end end

function mem(x, _param) do
  while(true) do
    param = _param;
    if (param) then do
      c = Caml_primitive.caml_string_compare(x, param[--[[ v ]]1]);
      if (c == 0) then do
        return true;
      end else do
        _param = c < 0 and param[--[[ l ]]0] or param[--[[ r ]]3];
        continue ;
      end end 
    end else do
      return false;
    end end 
  end;
end end

function iter$1(f, _param) do
  while(true) do
    param = _param;
    if (param) then do
      iter$1(f, param[--[[ l ]]0]);
      Curry._2(f, param[--[[ v ]]1], param[--[[ d ]]2]);
      _param = param[--[[ r ]]3];
      continue ;
    end else do
      return --[[ () ]]0;
    end end 
  end;
end end

function map(f, param) do
  if (param) then do
    l$prime = map(f, param[--[[ l ]]0]);
    d$prime = Curry._1(f, param[--[[ d ]]2]);
    r$prime = map(f, param[--[[ r ]]3]);
    return --[[ Node ]]{
            --[[ l ]]l$prime,
            --[[ v ]]param[--[[ v ]]1],
            --[[ d ]]d$prime,
            --[[ r ]]r$prime,
            --[[ h ]]param[--[[ h ]]4]
          };
  end else do
    return --[[ Empty ]]0;
  end end 
end end

function fold(f, _m, _accu) do
  while(true) do
    accu = _accu;
    m = _m;
    if (m) then do
      _accu = Curry._3(f, m[--[[ v ]]1], m[--[[ d ]]2], fold(f, m[--[[ l ]]0], accu));
      _m = m[--[[ r ]]3];
      continue ;
    end else do
      return accu;
    end end 
  end;
end end

function single(param) do
  local ___conditional___=(param);
  do
     if ___conditional___ = 0--[[ May_pos ]] then do
        return 1;end end end 
     if ___conditional___ = 1--[[ May_neg ]] then do
        return 2;end end end 
     if ___conditional___ = 2--[[ May_weak ]] then do
        return 4;end end end 
     if ___conditional___ = 3--[[ Inj ]] then do
        return 8;end end end 
     if ___conditional___ = 4--[[ Pos ]] then do
        return 16;end end end 
     if ___conditional___ = 5--[[ Neg ]] then do
        return 32;end end end 
     if ___conditional___ = 6--[[ Inv ]] then do
        return 64;end end end 
     do
    
  end
end end

function union(v1, v2) do
  return v1 | v2;
end end

function inter(v1, v2) do
  return v1 & v2;
end end

function subset(v1, v2) do
  return (v1 & v2) == v1;
end end

function set(x, b, v) do
  if (b) then do
    return v | single(x);
  end else do
    return v & (single(x) ^ -1);
  end end 
end end

function mem$1(x) do
  partial_arg = single(x);
  return (function (param) do
      return subset(partial_arg, param);
    end end);
end end

function swap(f1, f2, v) do
  v$prime = set(f1, mem$1(f2)(v), v);
  return set(f2, mem$1(f1)(v), v$prime);
end end

function conjugate(v) do
  return swap(--[[ May_pos ]]0, --[[ May_neg ]]1, swap(--[[ Pos ]]4, --[[ Neg ]]5, v));
end end

function get_upper(v) do
  return --[[ tuple ]]{
          mem$1(--[[ May_pos ]]0)(v),
          mem$1(--[[ May_neg ]]1)(v)
        };
end end

function get_lower(v) do
  return --[[ tuple ]]{
          mem$1(--[[ Pos ]]4)(v),
          mem$1(--[[ Neg ]]5)(v),
          mem$1(--[[ Inv ]]6)(v),
          mem$1(--[[ Inj ]]3)(v)
        };
end end

function height$1(param) do
  if (param) then do
    return param[--[[ h ]]3];
  end else do
    return 0;
  end end 
end end

function create$2(l, v, r) do
  hl = l and l[--[[ h ]]3] or 0;
  hr = r and r[--[[ h ]]3] or 0;
  return --[[ Node ]]{
          --[[ l ]]l,
          --[[ v ]]v,
          --[[ r ]]r,
          --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
        };
end end

function bal$1(l, v, r) do
  hl = l and l[--[[ h ]]3] or 0;
  hr = r and r[--[[ h ]]3] or 0;
  if (hl > (hr + 2 | 0)) then do
    if (l) then do
      lr = l[--[[ r ]]2];
      lv = l[--[[ v ]]1];
      ll = l[--[[ l ]]0];
      if (height$1(ll) >= height$1(lr)) then do
        return create$2(ll, lv, create$2(lr, v, r));
      end else if (lr) then do
        return create$2(create$2(ll, lv, lr[--[[ l ]]0]), lr[--[[ v ]]1], create$2(lr[--[[ r ]]2], v, r));
      end else do
        throw {
              Caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            };
      end end  end 
    end else do
      throw {
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          };
    end end 
  end else if (hr > (hl + 2 | 0)) then do
    if (r) then do
      rr = r[--[[ r ]]2];
      rv = r[--[[ v ]]1];
      rl = r[--[[ l ]]0];
      if (height$1(rr) >= height$1(rl)) then do
        return create$2(create$2(l, v, rl), rv, rr);
      end else if (rl) then do
        return create$2(create$2(l, v, rl[--[[ l ]]0]), rl[--[[ v ]]1], create$2(rl[--[[ r ]]2], rv, rr));
      end else do
        throw {
              Caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            };
      end end  end 
    end else do
      throw {
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          };
    end end 
  end else do
    return --[[ Node ]]{
            --[[ l ]]l,
            --[[ v ]]v,
            --[[ r ]]r,
            --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
          };
  end end  end 
end end

function add$2(x, t) do
  if (t) then do
    r = t[--[[ r ]]2];
    v = t[--[[ v ]]1];
    l = t[--[[ l ]]0];
    c = Caml_primitive.caml_string_compare(x, v);
    if (c == 0) then do
      return t;
    end else if (c < 0) then do
      ll = add$2(x, l);
      if (l == ll) then do
        return t;
      end else do
        return bal$1(ll, v, r);
      end end 
    end else do
      rr = add$2(x, r);
      if (r == rr) then do
        return t;
      end else do
        return bal$1(l, v, rr);
      end end 
    end end  end 
  end else do
    return --[[ Node ]]{
            --[[ l : Empty ]]0,
            --[[ v ]]x,
            --[[ r : Empty ]]0,
            --[[ h ]]1
          };
  end end 
end end

function singleton(x) do
  return --[[ Node ]]{
          --[[ l : Empty ]]0,
          --[[ v ]]x,
          --[[ r : Empty ]]0,
          --[[ h ]]1
        };
end end

function add_min_element(x, param) do
  if (param) then do
    return bal$1(add_min_element(x, param[--[[ l ]]0]), param[--[[ v ]]1], param[--[[ r ]]2]);
  end else do
    return singleton(x);
  end end 
end end

function add_max_element(x, param) do
  if (param) then do
    return bal$1(param[--[[ l ]]0], param[--[[ v ]]1], add_max_element(x, param[--[[ r ]]2]));
  end else do
    return singleton(x);
  end end 
end end

function join(l, v, r) do
  if (l) then do
    if (r) then do
      rh = r[--[[ h ]]3];
      lh = l[--[[ h ]]3];
      if (lh > (rh + 2 | 0)) then do
        return bal$1(l[--[[ l ]]0], l[--[[ v ]]1], join(l[--[[ r ]]2], v, r));
      end else if (rh > (lh + 2 | 0)) then do
        return bal$1(join(l, v, r[--[[ l ]]0]), r[--[[ v ]]1], r[--[[ r ]]2]);
      end else do
        return create$2(l, v, r);
      end end  end 
    end else do
      return add_max_element(v, l);
    end end 
  end else do
    return add_min_element(v, r);
  end end 
end end

function min_elt(_param) do
  while(true) do
    param = _param;
    if (param) then do
      l = param[--[[ l ]]0];
      if (l) then do
        _param = l;
        continue ;
      end else do
        return param[--[[ v ]]1];
      end end 
    end else do
      throw Caml_builtin_exceptions.not_found;
    end end 
  end;
end end

function remove_min_elt(param) do
  if (param) then do
    l = param[--[[ l ]]0];
    if (l) then do
      return bal$1(remove_min_elt(l), param[--[[ v ]]1], param[--[[ r ]]2]);
    end else do
      return param[--[[ r ]]2];
    end end 
  end else do
    throw {
          Caml_builtin_exceptions.invalid_argument,
          "Set.remove_min_elt"
        };
  end end 
end end

function concat(t1, t2) do
  if (t1) then do
    if (t2) then do
      return join(t1, min_elt(t2), remove_min_elt(t2));
    end else do
      return t1;
    end end 
  end else do
    return t2;
  end end 
end end

function split(x, param) do
  if (param) then do
    r = param[--[[ r ]]2];
    v = param[--[[ v ]]1];
    l = param[--[[ l ]]0];
    c = Caml_primitive.caml_string_compare(x, v);
    if (c == 0) then do
      return --[[ tuple ]]{
              l,
              true,
              r
            };
    end else if (c < 0) then do
      match = split(x, l);
      return --[[ tuple ]]{
              match[0],
              match[1],
              join(match[2], v, r)
            };
    end else do
      match$1 = split(x, r);
      return --[[ tuple ]]{
              join(l, v, match$1[0]),
              match$1[1],
              match$1[2]
            };
    end end  end 
  end else do
    return --[[ tuple ]]{
            --[[ Empty ]]0,
            false,
            --[[ Empty ]]0
          };
  end end 
end end

function mem$2(x, _param) do
  while(true) do
    param = _param;
    if (param) then do
      c = Caml_primitive.caml_string_compare(x, param[--[[ v ]]1]);
      if (c == 0) then do
        return true;
      end else do
        _param = c < 0 and param[--[[ l ]]0] or param[--[[ r ]]2];
        continue ;
      end end 
    end else do
      return false;
    end end 
  end;
end end

function union$1(s1, s2) do
  if (s1) then do
    if (s2) then do
      h2 = s2[--[[ h ]]3];
      v2 = s2[--[[ v ]]1];
      h1 = s1[--[[ h ]]3];
      v1 = s1[--[[ v ]]1];
      if (h1 >= h2) then do
        if (h2 == 1) then do
          return add$2(v2, s1);
        end else do
          match = split(v1, s2);
          return join(union$1(s1[--[[ l ]]0], match[0]), v1, union$1(s1[--[[ r ]]2], match[2]));
        end end 
      end else if (h1 == 1) then do
        return add$2(v1, s2);
      end else do
        match$1 = split(v2, s1);
        return join(union$1(match$1[0], s2[--[[ l ]]0]), v2, union$1(match$1[2], s2[--[[ r ]]2]));
      end end  end 
    end else do
      return s1;
    end end 
  end else do
    return s2;
  end end 
end end

function inter$1(s1, s2) do
  if (s1 and s2) then do
    r1 = s1[--[[ r ]]2];
    v1 = s1[--[[ v ]]1];
    l1 = s1[--[[ l ]]0];
    match = split(v1, s2);
    l2 = match[0];
    if (match[1]) then do
      return join(inter$1(l1, l2), v1, inter$1(r1, match[2]));
    end else do
      return concat(inter$1(l1, l2), inter$1(r1, match[2]));
    end end 
  end else do
    return --[[ Empty ]]0;
  end end 
end end

function diff(s1, s2) do
  if (s1) then do
    if (s2) then do
      r1 = s1[--[[ r ]]2];
      v1 = s1[--[[ v ]]1];
      l1 = s1[--[[ l ]]0];
      match = split(v1, s2);
      l2 = match[0];
      if (match[1]) then do
        return concat(diff(l1, l2), diff(r1, match[2]));
      end else do
        return join(diff(l1, l2), v1, diff(r1, match[2]));
      end end 
    end else do
      return s1;
    end end 
  end else do
    return --[[ Empty ]]0;
  end end 
end end

function cons_enum(_s, _e) do
  while(true) do
    e = _e;
    s = _s;
    if (s) then do
      _e = --[[ More ]]{
        s[--[[ v ]]1],
        s[--[[ r ]]2],
        e
      };
      _s = s[--[[ l ]]0];
      continue ;
    end else do
      return e;
    end end 
  end;
end end

function compare$1(s1, s2) do
  _e1 = cons_enum(s1, --[[ End ]]0);
  _e2 = cons_enum(s2, --[[ End ]]0);
  while(true) do
    e2 = _e2;
    e1 = _e1;
    if (e1) then do
      if (e2) then do
        c = Caml_primitive.caml_string_compare(e1[0], e2[0]);
        if (c ~= 0) then do
          return c;
        end else do
          _e2 = cons_enum(e2[1], e2[2]);
          _e1 = cons_enum(e1[1], e1[2]);
          continue ;
        end end 
      end else do
        return 1;
      end end 
    end else if (e2) then do
      return -1;
    end else do
      return 0;
    end end  end 
  end;
end end

function equal$2(s1, s2) do
  return compare$1(s1, s2) == 0;
end end

function fold$1(f, _s, _accu) do
  while(true) do
    accu = _accu;
    s = _s;
    if (s) then do
      _accu = Curry._2(f, s[--[[ v ]]1], fold$1(f, s[--[[ l ]]0], accu));
      _s = s[--[[ r ]]2];
      continue ;
    end else do
      return accu;
    end end 
  end;
end end

function elements_aux(_accu, _param) do
  while(true) do
    param = _param;
    accu = _accu;
    if (param) then do
      _param = param[--[[ l ]]0];
      _accu = --[[ :: ]]{
        param[--[[ v ]]1],
        elements_aux(accu, param[--[[ r ]]2])
      };
      continue ;
    end else do
      return accu;
    end end 
  end;
end end

function equal_tag(t1, t2) do
  local ___conditional___=(t1.tag | 0);
  do
     if ___conditional___ = 0--[[ Cstr_constant ]] then do
        local ___conditional___=(t2.tag | 0);
        do
           if ___conditional___ = 0--[[ Cstr_constant ]] then do
              return t2[0] == t1[0];end end end 
           if ___conditional___ = 1--[[ Cstr_block ]]
           or ___conditional___ = 2--[[ Cstr_extension ]] then do
              return false;end end end 
           do
          
        endend end end 
     if ___conditional___ = 1--[[ Cstr_block ]] then do
        local ___conditional___=(t2.tag | 0);
        do
           if ___conditional___ = 1--[[ Cstr_block ]] then do
              return t2[0] == t1[0];end end end 
           if ___conditional___ = 0--[[ Cstr_constant ]]
           or ___conditional___ = 2--[[ Cstr_extension ]] then do
              return false;end end end 
           do
          
        endend end end 
     if ___conditional___ = 2--[[ Cstr_extension ]] then do
        local ___conditional___=(t2.tag | 0);
        do
           if ___conditional___ = 0--[[ Cstr_constant ]]
           or ___conditional___ = 1--[[ Cstr_block ]] then do
              return false;end end end 
           if ___conditional___ = 2--[[ Cstr_extension ]] then do
              if (same(t1[0], t2[0])) then do
                return t1[1] == t2[1];
              end else do
                return false;
              end end end end end 
           do
          
        endend end end 
     do
    
  end
end end

Types_TypeOps = do
  compare: compare,
  equal: equal$1,
  hash: hash
end;

Types_Variance = do
  __null: 0,
  full: 127,
  covariant: 25,
  may_inv: 7,
  union: union,
  inter: inter,
  subset: subset,
  set: set,
  mem: mem$1,
  conjugate: conjugate,
  get_upper: get_upper,
  get_lower: get_lower
end;

funarg = Types_TypeOps;

function height$2(param) do
  if (param) then do
    return param[--[[ h ]]3];
  end else do
    return 0;
  end end 
end end

function create$3(l, v, r) do
  hl = l and l[--[[ h ]]3] or 0;
  hr = r and r[--[[ h ]]3] or 0;
  return --[[ Node ]]{
          --[[ l ]]l,
          --[[ v ]]v,
          --[[ r ]]r,
          --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
        };
end end

function bal$2(l, v, r) do
  hl = l and l[--[[ h ]]3] or 0;
  hr = r and r[--[[ h ]]3] or 0;
  if (hl > (hr + 2 | 0)) then do
    if (l) then do
      lr = l[--[[ r ]]2];
      lv = l[--[[ v ]]1];
      ll = l[--[[ l ]]0];
      if (height$2(ll) >= height$2(lr)) then do
        return create$3(ll, lv, create$3(lr, v, r));
      end else if (lr) then do
        return create$3(create$3(ll, lv, lr[--[[ l ]]0]), lr[--[[ v ]]1], create$3(lr[--[[ r ]]2], v, r));
      end else do
        throw {
              Caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            };
      end end  end 
    end else do
      throw {
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          };
    end end 
  end else if (hr > (hl + 2 | 0)) then do
    if (r) then do
      rr = r[--[[ r ]]2];
      rv = r[--[[ v ]]1];
      rl = r[--[[ l ]]0];
      if (height$2(rr) >= height$2(rl)) then do
        return create$3(create$3(l, v, rl), rv, rr);
      end else if (rl) then do
        return create$3(create$3(l, v, rl[--[[ l ]]0]), rl[--[[ v ]]1], create$3(rl[--[[ r ]]2], rv, rr));
      end else do
        throw {
              Caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            };
      end end  end 
    end else do
      throw {
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          };
    end end 
  end else do
    return --[[ Node ]]{
            --[[ l ]]l,
            --[[ v ]]v,
            --[[ r ]]r,
            --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
          };
  end end  end 
end end

function add$3(x, t) do
  if (t) then do
    r = t[--[[ r ]]2];
    v = t[--[[ v ]]1];
    l = t[--[[ l ]]0];
    c = Curry._2(funarg.compare, x, v);
    if (c == 0) then do
      return t;
    end else if (c < 0) then do
      ll = add$3(x, l);
      if (l == ll) then do
        return t;
      end else do
        return bal$2(ll, v, r);
      end end 
    end else do
      rr = add$3(x, r);
      if (r == rr) then do
        return t;
      end else do
        return bal$2(l, v, rr);
      end end 
    end end  end 
  end else do
    return --[[ Node ]]{
            --[[ l : Empty ]]0,
            --[[ v ]]x,
            --[[ r : Empty ]]0,
            --[[ h ]]1
          };
  end end 
end end

function singleton$1(x) do
  return --[[ Node ]]{
          --[[ l : Empty ]]0,
          --[[ v ]]x,
          --[[ r : Empty ]]0,
          --[[ h ]]1
        };
end end

function add_min_element$1(x, param) do
  if (param) then do
    return bal$2(add_min_element$1(x, param[--[[ l ]]0]), param[--[[ v ]]1], param[--[[ r ]]2]);
  end else do
    return singleton$1(x);
  end end 
end end

function add_max_element$1(x, param) do
  if (param) then do
    return bal$2(param[--[[ l ]]0], param[--[[ v ]]1], add_max_element$1(x, param[--[[ r ]]2]));
  end else do
    return singleton$1(x);
  end end 
end end

function join$1(l, v, r) do
  if (l) then do
    if (r) then do
      rh = r[--[[ h ]]3];
      lh = l[--[[ h ]]3];
      if (lh > (rh + 2 | 0)) then do
        return bal$2(l[--[[ l ]]0], l[--[[ v ]]1], join$1(l[--[[ r ]]2], v, r));
      end else if (rh > (lh + 2 | 0)) then do
        return bal$2(join$1(l, v, r[--[[ l ]]0]), r[--[[ v ]]1], r[--[[ r ]]2]);
      end else do
        return create$3(l, v, r);
      end end  end 
    end else do
      return add_max_element$1(v, l);
    end end 
  end else do
    return add_min_element$1(v, r);
  end end 
end end

function min_elt$1(_param) do
  while(true) do
    param = _param;
    if (param) then do
      l = param[--[[ l ]]0];
      if (l) then do
        _param = l;
        continue ;
      end else do
        return param[--[[ v ]]1];
      end end 
    end else do
      throw Caml_builtin_exceptions.not_found;
    end end 
  end;
end end

function remove_min_elt$1(param) do
  if (param) then do
    l = param[--[[ l ]]0];
    if (l) then do
      return bal$2(remove_min_elt$1(l), param[--[[ v ]]1], param[--[[ r ]]2]);
    end else do
      return param[--[[ r ]]2];
    end end 
  end else do
    throw {
          Caml_builtin_exceptions.invalid_argument,
          "Set.remove_min_elt"
        };
  end end 
end end

function concat$1(t1, t2) do
  if (t1) then do
    if (t2) then do
      return join$1(t1, min_elt$1(t2), remove_min_elt$1(t2));
    end else do
      return t1;
    end end 
  end else do
    return t2;
  end end 
end end

function split$1(x, param) do
  if (param) then do
    r = param[--[[ r ]]2];
    v = param[--[[ v ]]1];
    l = param[--[[ l ]]0];
    c = Curry._2(funarg.compare, x, v);
    if (c == 0) then do
      return --[[ tuple ]]{
              l,
              true,
              r
            };
    end else if (c < 0) then do
      match = split$1(x, l);
      return --[[ tuple ]]{
              match[0],
              match[1],
              join$1(match[2], v, r)
            };
    end else do
      match$1 = split$1(x, r);
      return --[[ tuple ]]{
              join$1(l, v, match$1[0]),
              match$1[1],
              match$1[2]
            };
    end end  end 
  end else do
    return --[[ tuple ]]{
            --[[ Empty ]]0,
            false,
            --[[ Empty ]]0
          };
  end end 
end end

function mem$3(x, _param) do
  while(true) do
    param = _param;
    if (param) then do
      c = Curry._2(funarg.compare, x, param[--[[ v ]]1]);
      if (c == 0) then do
        return true;
      end else do
        _param = c < 0 and param[--[[ l ]]0] or param[--[[ r ]]2];
        continue ;
      end end 
    end else do
      return false;
    end end 
  end;
end end

function union$2(s1, s2) do
  if (s1) then do
    if (s2) then do
      h2 = s2[--[[ h ]]3];
      v2 = s2[--[[ v ]]1];
      h1 = s1[--[[ h ]]3];
      v1 = s1[--[[ v ]]1];
      if (h1 >= h2) then do
        if (h2 == 1) then do
          return add$3(v2, s1);
        end else do
          match = split$1(v1, s2);
          return join$1(union$2(s1[--[[ l ]]0], match[0]), v1, union$2(s1[--[[ r ]]2], match[2]));
        end end 
      end else if (h1 == 1) then do
        return add$3(v1, s2);
      end else do
        match$1 = split$1(v2, s1);
        return join$1(union$2(match$1[0], s2[--[[ l ]]0]), v2, union$2(match$1[2], s2[--[[ r ]]2]));
      end end  end 
    end else do
      return s1;
    end end 
  end else do
    return s2;
  end end 
end end

function inter$2(s1, s2) do
  if (s1 and s2) then do
    r1 = s1[--[[ r ]]2];
    v1 = s1[--[[ v ]]1];
    l1 = s1[--[[ l ]]0];
    match = split$1(v1, s2);
    l2 = match[0];
    if (match[1]) then do
      return join$1(inter$2(l1, l2), v1, inter$2(r1, match[2]));
    end else do
      return concat$1(inter$2(l1, l2), inter$2(r1, match[2]));
    end end 
  end else do
    return --[[ Empty ]]0;
  end end 
end end

function diff$1(s1, s2) do
  if (s1) then do
    if (s2) then do
      r1 = s1[--[[ r ]]2];
      v1 = s1[--[[ v ]]1];
      l1 = s1[--[[ l ]]0];
      match = split$1(v1, s2);
      l2 = match[0];
      if (match[1]) then do
        return concat$1(diff$1(l1, l2), diff$1(r1, match[2]));
      end else do
        return join$1(diff$1(l1, l2), v1, diff$1(r1, match[2]));
      end end 
    end else do
      return s1;
    end end 
  end else do
    return --[[ Empty ]]0;
  end end 
end end

function subset$1(_s1, _s2) do
  while(true) do
    s2 = _s2;
    s1 = _s1;
    if (s1) then do
      if (s2) then do
        r2 = s2[--[[ r ]]2];
        l2 = s2[--[[ l ]]0];
        r1 = s1[--[[ r ]]2];
        v1 = s1[--[[ v ]]1];
        l1 = s1[--[[ l ]]0];
        c = Curry._2(funarg.compare, v1, s2[--[[ v ]]1]);
        if (c == 0) then do
          if (subset$1(l1, l2)) then do
            _s2 = r2;
            _s1 = r1;
            continue ;
          end else do
            return false;
          end end 
        end else if (c < 0) then do
          if (subset$1(--[[ Node ]]{
                  --[[ l ]]l1,
                  --[[ v ]]v1,
                  --[[ r : Empty ]]0,
                  --[[ h ]]0
                }, l2)) then do
            _s1 = r1;
            continue ;
          end else do
            return false;
          end end 
        end else if (subset$1(--[[ Node ]]{
                --[[ l : Empty ]]0,
                --[[ v ]]v1,
                --[[ r ]]r1,
                --[[ h ]]0
              }, r2)) then do
          _s1 = l1;
          continue ;
        end else do
          return false;
        end end  end  end 
      end else do
        return false;
      end end 
    end else do
      return true;
    end end 
  end;
end end

function fold$2(f, _s, _accu) do
  while(true) do
    accu = _accu;
    s = _s;
    if (s) then do
      _accu = Curry._2(f, s[--[[ v ]]1], fold$2(f, s[--[[ l ]]0], accu));
      _s = s[--[[ r ]]2];
      continue ;
    end else do
      return accu;
    end end 
  end;
end end

function exists(p, _param) do
  while(true) do
    param = _param;
    if (param) then do
      if (Curry._1(p, param[--[[ v ]]1]) or exists(p, param[--[[ l ]]0])) then do
        return true;
      end else do
        _param = param[--[[ r ]]2];
        continue ;
      end end 
    end else do
      return false;
    end end 
  end;
end end

function elements_aux$1(_accu, _param) do
  while(true) do
    param = _param;
    accu = _accu;
    if (param) then do
      _param = param[--[[ l ]]0];
      _accu = --[[ :: ]]{
        param[--[[ v ]]1],
        elements_aux$1(accu, param[--[[ r ]]2])
      };
      continue ;
    end else do
      return accu;
    end end 
  end;
end end

funarg$1 = Types_TypeOps;

function height$3(param) do
  if (param) then do
    return param[--[[ h ]]4];
  end else do
    return 0;
  end end 
end end

function create$4(l, x, d, r) do
  hl = height$3(l);
  hr = height$3(r);
  return --[[ Node ]]{
          --[[ l ]]l,
          --[[ v ]]x,
          --[[ d ]]d,
          --[[ r ]]r,
          --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
        };
end end

function bal$3(l, x, d, r) do
  hl = l and l[--[[ h ]]4] or 0;
  hr = r and r[--[[ h ]]4] or 0;
  if (hl > (hr + 2 | 0)) then do
    if (l) then do
      lr = l[--[[ r ]]3];
      ld = l[--[[ d ]]2];
      lv = l[--[[ v ]]1];
      ll = l[--[[ l ]]0];
      if (height$3(ll) >= height$3(lr)) then do
        return create$4(ll, lv, ld, create$4(lr, x, d, r));
      end else if (lr) then do
        return create$4(create$4(ll, lv, ld, lr[--[[ l ]]0]), lr[--[[ v ]]1], lr[--[[ d ]]2], create$4(lr[--[[ r ]]3], x, d, r));
      end else do
        throw {
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            };
      end end  end 
    end else do
      throw {
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          };
    end end 
  end else if (hr > (hl + 2 | 0)) then do
    if (r) then do
      rr = r[--[[ r ]]3];
      rd = r[--[[ d ]]2];
      rv = r[--[[ v ]]1];
      rl = r[--[[ l ]]0];
      if (height$3(rr) >= height$3(rl)) then do
        return create$4(create$4(l, x, d, rl), rv, rd, rr);
      end else if (rl) then do
        return create$4(create$4(l, x, d, rl[--[[ l ]]0]), rl[--[[ v ]]1], rl[--[[ d ]]2], create$4(rl[--[[ r ]]3], rv, rd, rr));
      end else do
        throw {
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            };
      end end  end 
    end else do
      throw {
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          };
    end end 
  end else do
    return --[[ Node ]]{
            --[[ l ]]l,
            --[[ v ]]x,
            --[[ d ]]d,
            --[[ r ]]r,
            --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
          };
  end end  end 
end end

function add$4(x, data, m) do
  if (m) then do
    r = m[--[[ r ]]3];
    d = m[--[[ d ]]2];
    v = m[--[[ v ]]1];
    l = m[--[[ l ]]0];
    c = Curry._2(funarg$1.compare, x, v);
    if (c == 0) then do
      if (d == data) then do
        return m;
      end else do
        return --[[ Node ]]{
                --[[ l ]]l,
                --[[ v ]]x,
                --[[ d ]]data,
                --[[ r ]]r,
                --[[ h ]]m[--[[ h ]]4]
              };
      end end 
    end else if (c < 0) then do
      ll = add$4(x, data, l);
      if (l == ll) then do
        return m;
      end else do
        return bal$3(ll, v, d, r);
      end end 
    end else do
      rr = add$4(x, data, r);
      if (r == rr) then do
        return m;
      end else do
        return bal$3(l, v, d, rr);
      end end 
    end end  end 
  end else do
    return --[[ Node ]]{
            --[[ l : Empty ]]0,
            --[[ v ]]x,
            --[[ d ]]data,
            --[[ r : Empty ]]0,
            --[[ h ]]1
          };
  end end 
end end

function find$1(x, _param) do
  while(true) do
    param = _param;
    if (param) then do
      c = Curry._2(funarg$1.compare, x, param[--[[ v ]]1]);
      if (c == 0) then do
        return param[--[[ d ]]2];
      end else do
        _param = c < 0 and param[--[[ l ]]0] or param[--[[ r ]]3];
        continue ;
      end end 
    end else do
      throw Caml_builtin_exceptions.not_found;
    end end 
  end;
end end

function fold$3(f, _m, _accu) do
  while(true) do
    accu = _accu;
    m = _m;
    if (m) then do
      _accu = Curry._3(f, m[--[[ v ]]1], m[--[[ d ]]2], fold$3(f, m[--[[ l ]]0], accu));
      _m = m[--[[ r ]]3];
      continue ;
    end else do
      return accu;
    end end 
  end;
end end

__let = Types_TypeOps;

TypeHash = Hashtbl.Make(do
      equal: __let.equal,
      hash: __let.hash
    end);

function print_raw(param) do
  throw {
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "btype.ml",
          27,
          16
        }
      };
end end

pivot_level = -1;

new_id = do
  contents: -1
end;

function newty2(level, desc) do
  new_id.contents = new_id.contents + 1 | 0;
  return do
          desc: desc,
          level: level,
          id: new_id.contents
        end;
end end

function is_Tvar(param) do
  match = param.desc;
  if (typeof match == "number" or match.tag) then do
    return false;
  end else do
    return true;
  end end 
end end

function is_Tunivar(param) do
  match = param.desc;
  if (typeof match == "number" or match.tag ~= --[[ Tunivar ]]9) then do
    return false;
  end else do
    return true;
  end end 
end end

dummy_method = "*dummy method*";

function default_mty(param) do
  if (param ~= undefined) then do
    return param;
  end else do
    return --[[ Mty_signature ]]Block.__(1, {--[[ [] ]]0});
  end end 
end end

function field_kind_repr(_kind) do
  while(true) do
    kind = _kind;
    if (typeof kind == "number") then do
      return kind;
    end else do
      match = kind[0].contents;
      if (match ~= undefined) then do
        _kind = match;
        continue ;
      end else do
        return kind;
      end end 
    end end 
  end;
end end

function repr(_t) do
  while(true) do
    t = _t;
    match = t.desc;
    if (typeof match == "number") then do
      return t;
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 5--[[ Tfield ]] then do
            if (field_kind_repr(match[1]) == --[[ Fabsent ]]1) then do
              _t = match[3];
              continue ;
            end else do
              return t;
            end end end end end 
         if ___conditional___ = 6--[[ Tlink ]] then do
            _t = match[0];
            continue ;end end end 
         do
        else do
          return t;
          end end
          
      end
    end end 
  end;
end end

function commu_repr(_c) do
  while(true) do
    c = _c;
    if (typeof c == "number") then do
      return c;
    end else do
      r = c[0];
      if (r.contents ~= --[[ Cunknown ]]1) then do
        _c = r.contents;
        continue ;
      end else do
        return c;
      end end 
    end end 
  end;
end end

function row_field_repr_aux(_tl, _fi) do
  while(true) do
    fi = _fi;
    tl = _tl;
    if (typeof fi == "number") then do
      return fi;
    end else if (fi.tag) then do
      r = fi[3];
      tl$prime = fi[1];
      match = r.contents;
      if (match ~= undefined) then do
        _fi = match;
        _tl = Pervasives.$at(tl, tl$prime);
        continue ;
      end else do
        return --[[ Reither ]]Block.__(1, {
                  fi[0],
                  Pervasives.$at(tl, tl$prime),
                  fi[2],
                  r
                });
      end end 
    end else if (fi[0] ~= undefined and tl ~= --[[ [] ]]0) then do
      return --[[ Rpresent ]]Block.__(0, {List.hd(tl)});
    end else do
      return fi;
    end end  end  end 
  end;
end end

function rev_concat(_l, _ll) do
  while(true) do
    ll = _ll;
    l = _l;
    if (ll) then do
      _ll = ll[1];
      _l = Pervasives.$at(ll[0], l);
      continue ;
    end else do
      return l;
    end end 
  end;
end end

function row_repr_aux(_ll, _row) do
  while(true) do
    row = _row;
    ll = _ll;
    match = repr(row.row_more).desc;
    if (typeof match ~= "number" and match.tag == --[[ Tvariant ]]8) then do
      f = row.row_fields;
      _row = match[0];
      _ll = f == --[[ [] ]]0 and ll or --[[ :: ]]{
          f,
          ll
        };
      continue ;
    end
     end 
    if (ll == --[[ [] ]]0) then do
      return row;
    end else do
      return do
              row_fields: rev_concat(row.row_fields, ll),
              row_more: row.row_more,
              row_bound: row.row_bound,
              row_closed: row.row_closed,
              row_fixed: row.row_fixed,
              row_name: row.row_name
            end;
    end end 
  end;
end end

function row_field(tag, row) do
  _param = row.row_fields;
  while(true) do
    param = _param;
    if (param) then do
      match = param[0];
      if (tag == match[0]) then do
        return row_field_repr_aux(--[[ [] ]]0, match[1]);
      end else do
        _param = param[1];
        continue ;
      end end 
    end else do
      match$1 = repr(row.row_more);
      match$2 = match$1.desc;
      if (typeof match$2 == "number" or match$2.tag ~= --[[ Tvariant ]]8) then do
        return --[[ Rabsent ]]0;
      end else do
        return row_field(tag, match$2[0]);
      end end 
    end end 
  end;
end end

function row_more(_row) do
  while(true) do
    row = _row;
    ty = repr(row.row_more);
    match = ty.desc;
    if (typeof match == "number" or match.tag ~= --[[ Tvariant ]]8) then do
      return ty;
    end else do
      _row = match[0];
      continue ;
    end end 
  end;
end end

function row_fixed(row) do
  row$1 = row_repr_aux(--[[ [] ]]0, row);
  if (row$1.row_fixed) then do
    return true;
  end else do
    match = repr(row$1.row_more).desc;
    if (typeof match == "number") then do
      return false;
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 0--[[ Tvar ]] then do
            return false;end end end 
         if ___conditional___ = 3--[[ Tconstr ]]
         or ___conditional___ = 9--[[ Tunivar ]] then do
            return true;end end end 
         do
        else do
          throw {
                Caml_builtin_exceptions.assert_failure,
                --[[ tuple ]]{
                  "btype.ml",
                  137,
                  9
                }
              };
          end end
          
      end
    end end 
  end end 
end end

function static_row(row) do
  row$1 = row_repr_aux(--[[ [] ]]0, row);
  if (row$1.row_closed) then do
    return List.for_all((function (param) do
                  match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                  if (typeof match == "number" or not match.tag) then do
                    return true;
                  end else do
                    return false;
                  end end 
                end end), row$1.row_fields);
  end else do
    return false;
  end end 
end end

function hash_variant(s) do
  accu = 0;
  for i = 0 , #s - 1 | 0 , 1 do
    accu = Caml_int32.imul(223, accu) + Caml_string.get(s, i) | 0;
  end
  accu = accu & 2147483647;
  if (accu > 1073741823) then do
    return accu - -2147483648 | 0;
  end else do
    return accu;
  end end 
end end

function proxy(ty) do
  ty0 = repr(ty);
  match = ty0.desc;
  if (typeof match == "number") then do
    return ty0;
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 4--[[ Tobject ]] then do
          _ty = match[0];
          while(true) do
            ty$1 = _ty;
            match$1 = ty$1.desc;
            if (typeof match$1 == "number") then do
              return ty0;
            end else do
              local ___conditional___=(match$1.tag | 0);
              do
                 if ___conditional___ = 5--[[ Tfield ]] then do
                    _ty = match$1[3];
                    continue ;end end end 
                 if ___conditional___ = 6--[[ Tlink ]] then do
                    _ty = match$1[0];
                    continue ;end end end 
                 if ___conditional___ = 0--[[ Tvar ]]
                 or ___conditional___ = 3--[[ Tconstr ]]
                 or ___conditional___ = 9--[[ Tunivar ]] then do
                    return ty$1;end end end 
                 do
                else do
                  throw {
                        Caml_builtin_exceptions.assert_failure,
                        --[[ tuple ]]{
                          "btype.ml",
                          167,
                          15
                        }
                      };
                  end end
                  
              end
            end end 
          end;end end end 
       if ___conditional___ = 8--[[ Tvariant ]] then do
          row = match[0];
          if (static_row(row)) then do
            return ty0;
          end else do
            return row_more(row);
          end end end end end 
       do
      else do
        return ty0;
        end end
        
    end
  end end 
end end

function has_constr_row(t) do
  match = repr(t).desc;
  if (typeof match == "number") then do
    return false;
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 4--[[ Tobject ]] then do
          _t = match[0];
          while(true) do
            t$1 = _t;
            match$1 = repr(t$1).desc;
            if (typeof match$1 == "number") then do
              return false;
            end else do
              local ___conditional___=(match$1.tag | 0);
              do
                 if ___conditional___ = 3--[[ Tconstr ]] then do
                    return true;end end end 
                 if ___conditional___ = 5--[[ Tfield ]] then do
                    _t = match$1[3];
                    continue ;end end end 
                 do
                else do
                  return false;
                  end end
                  
              end
            end end 
          end;end end end 
       if ___conditional___ = 8--[[ Tvariant ]] then do
          match$2 = row_more(match[0]);
          match$3 = match$2.desc;
          if (typeof match$3 == "number" or match$3.tag ~= --[[ Tconstr ]]3) then do
            return false;
          end else do
            return true;
          end end end end end 
       do
      else do
        return false;
        end end
        
    end
  end end 
end end

function is_row_name(s) do
  l = #s;
  if (l < 4) then do
    return false;
  end else do
    return __String.sub(s, l - 4 | 0, 4) == "#row";
  end end 
end end

function is_constr_row(t) do
  match = t.desc;
  if (typeof match == "number" or match.tag ~= --[[ Tconstr ]]3) then do
    return false;
  end else do
    match$1 = match[0];
    local ___conditional___=(match$1.tag | 0);
    do
       if ___conditional___ = 0--[[ Pident ]] then do
          return is_row_name(match$1[0].name);end end end 
       if ___conditional___ = 1--[[ Pdot ]] then do
          return is_row_name(match$1[1]);end end end 
       if ___conditional___ = 2--[[ Papply ]] then do
          return false;end end end 
       do
      
    end
  end end 
end end

function iter_row(f, _row) do
  while(true) do
    row = _row;
    List.iter((function (param) do
            match = row_field_repr_aux(--[[ [] ]]0, param[1]);
            if (typeof match == "number") then do
              return --[[ () ]]0;
            end else if (match.tag) then do
              return List.iter(f, match[1]);
            end else do
              match$1 = match[0];
              if (match$1 ~= undefined) then do
                return Curry._1(f, match$1);
              end else do
                return --[[ () ]]0;
              end end 
            end end  end 
          end end), row.row_fields);
    match = repr(row.row_more).desc;
    if (typeof match ~= "number") then do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 8--[[ Tvariant ]] then do
            _row = match[0];
            continue ;end end end 
         if ___conditional___ = 0--[[ Tvar ]]
         or ___conditional___ = 3--[[ Tconstr ]]
         or ___conditional___ = 7--[[ Tsubst ]]
         or ___conditional___ = 9--[[ Tunivar ]]
         do
        else do
          throw {
                Caml_builtin_exceptions.assert_failure,
                --[[ tuple ]]{
                  "btype.ml",
                  214,
                  9
                }
              };
          end end
          
      end
    end
     end 
    return may((function (param) do
                  return List.iter(f, param[1]);
                end end), row.row_name);
  end;
end end

function iter_type_expr(f, ty) do
  match = ty.desc;
  if (typeof match == "number") then do
    return --[[ () ]]0;
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 1--[[ Tarrow ]] then do
          Curry._1(f, match[1]);
          return Curry._1(f, match[2]);end end end 
       if ___conditional___ = 2--[[ Ttuple ]] then do
          return List.iter(f, match[0]);end end end 
       if ___conditional___ = 3--[[ Tconstr ]] then do
          return List.iter(f, match[1]);end end end 
       if ___conditional___ = 4--[[ Tobject ]] then do
          ty$1 = match[0];
          match$1 = match[1].contents;
          if (match$1 ~= undefined) then do
            Curry._1(f, ty$1);
            return List.iter(f, match$1[1]);
          end else do
            return Curry._1(f, ty$1);
          end end end end end 
       if ___conditional___ = 5--[[ Tfield ]] then do
          Curry._1(f, match[2]);
          return Curry._1(f, match[3]);end end end 
       if ___conditional___ = 6--[[ Tlink ]]
       or ___conditional___ = 7--[[ Tsubst ]] then do
          return Curry._1(f, match[0]);end end end 
       if ___conditional___ = 8--[[ Tvariant ]] then do
          row = match[0];
          iter_row(f, row);
          return Curry._1(f, row_more(row));end end end 
       if ___conditional___ = 10--[[ Tpoly ]] then do
          Curry._1(f, match[0]);
          return List.iter(f, match[1]);end end end 
       if ___conditional___ = 11--[[ Tpackage ]] then do
          return List.iter(f, match[2]);end end end 
       do
      else do
        return --[[ () ]]0;
        end end
        
    end
  end end 
end end

function iter_abbrev(f, _param) do
  while(true) do
    param = _param;
    if (typeof param == "number") then do
      return --[[ () ]]0;
    end else if (param.tag) then do
      _param = param[0].contents;
      continue ;
    end else do
      Curry._1(f, param[2]);
      Curry._1(f, param[3]);
      _param = param[4];
      continue ;
    end end  end 
  end;
end end

function it_signature(it) do
  partial_arg = Curry._1(it.it_signature_item, it);
  return (function (param) do
      return List.iter(partial_arg, param);
    end end);
end end

function it_signature_item(it, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Sig_value ]] then do
        return Curry._2(it.it_value_description, it, param[1]);end end end 
     if ___conditional___ = 1--[[ Sig_type ]] then do
        return Curry._2(it.it_type_declaration, it, param[1]);end end end 
     if ___conditional___ = 2--[[ Sig_typext ]] then do
        return Curry._2(it.it_extension_constructor, it, param[1]);end end end 
     if ___conditional___ = 3--[[ Sig_module ]] then do
        return Curry._2(it.it_module_declaration, it, param[1]);end end end 
     if ___conditional___ = 4--[[ Sig_modtype ]] then do
        return Curry._2(it.it_modtype_declaration, it, param[1]);end end end 
     if ___conditional___ = 5--[[ Sig_class ]] then do
        return Curry._2(it.it_class_declaration, it, param[1]);end end end 
     if ___conditional___ = 6--[[ Sig_class_type ]] then do
        return Curry._2(it.it_class_type_declaration, it, param[1]);end end end 
     do
    
  end
end end

function it_value_description(it, vd) do
  return Curry._2(it.it_type_expr, it, vd.val_type);
end end

function it_type_declaration(it, td) do
  List.iter(Curry._1(it.it_type_expr, it), td.type_params);
  may(Curry._1(it.it_type_expr, it), td.type_manifest);
  return Curry._2(it.it_type_kind, it, td.type_kind);
end end

function it_extension_constructor(it, td) do
  Curry._1(it.it_path, td.ext_type_path);
  List.iter(Curry._1(it.it_type_expr, it), td.ext_type_params);
  List.iter(Curry._1(it.it_type_expr, it), td.ext_args);
  return may(Curry._1(it.it_type_expr, it), td.ext_ret_type);
end end

function it_module_declaration(it, md) do
  return Curry._2(it.it_module_type, it, md.md_type);
end end

function it_modtype_declaration(it, mtd) do
  return may(Curry._1(it.it_module_type, it), mtd.mtd_type);
end end

function it_class_declaration(it, cd) do
  List.iter(Curry._1(it.it_type_expr, it), cd.cty_params);
  Curry._2(it.it_class_type, it, cd.cty_type);
  may(Curry._1(it.it_type_expr, it), cd.cty_new);
  return Curry._1(it.it_path, cd.cty_path);
end end

function it_class_type_declaration(it, ctd) do
  List.iter(Curry._1(it.it_type_expr, it), ctd.clty_params);
  Curry._2(it.it_class_type, it, ctd.clty_type);
  return Curry._1(it.it_path, ctd.clty_path);
end end

function it_module_type(it, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 1--[[ Mty_signature ]] then do
        return Curry._2(it.it_signature, it, param[0]);end end end 
     if ___conditional___ = 2--[[ Mty_functor ]] then do
        may(Curry._1(it.it_module_type, it), param[1]);
        return Curry._2(it.it_module_type, it, param[2]);end end end 
     if ___conditional___ = 0--[[ Mty_ident ]]
     or ___conditional___ = 3--[[ Mty_alias ]] then do
        return Curry._1(it.it_path, param[0]);end end end 
     do
    
  end
end end

function it_class_type(it, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Cty_constr ]] then do
        Curry._1(it.it_path, param[0]);
        List.iter(Curry._1(it.it_type_expr, it), param[1]);
        return Curry._2(it.it_class_type, it, param[2]);end end end 
     if ___conditional___ = 1--[[ Cty_signature ]] then do
        cs = param[0];
        Curry._2(it.it_type_expr, it, cs.csig_self);
        iter$1((function (param, param$1) do
                return Curry._2(it.it_type_expr, it, param$1[2]);
              end end), cs.csig_vars);
        return List.iter((function (param) do
                      Curry._1(it.it_path, param[0]);
                      return List.iter(Curry._1(it.it_type_expr, it), param[1]);
                    end end), cs.csig_inher);end end end 
     if ___conditional___ = 2--[[ Cty_arrow ]] then do
        Curry._2(it.it_type_expr, it, param[1]);
        return Curry._2(it.it_class_type, it, param[2]);end end end 
     do
    
  end
end end

function it_type_kind(it, param) do
  if (typeof param == "number") then do
    return --[[ () ]]0;
  end else if (param.tag) then do
    return List.iter((function (cd) do
                  List.iter(Curry._1(it.it_type_expr, it), cd.cd_args);
                  return may(Curry._1(it.it_type_expr, it), cd.cd_res);
                end end), param[0]);
  end else do
    return List.iter((function (ld) do
                  return Curry._2(it.it_type_expr, it, ld.ld_type);
                end end), param[0]);
  end end  end 
end end

function it_do_type_expr(it, ty) do
  iter_type_expr(Curry._1(it.it_type_expr, it), ty);
  match = ty.desc;
  if (typeof match == "number") then do
    return --[[ () ]]0;
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 4--[[ Tobject ]] then do
          match$1 = match[1].contents;
          if (match$1 ~= undefined) then do
            return Curry._1(it.it_path, match$1[0]);
          end else do
            return --[[ () ]]0;
          end end end end end 
       if ___conditional___ = 8--[[ Tvariant ]] then do
          return may((function (param) do
                        return Curry._1(it.it_path, param[0]);
                      end end), row_repr_aux(--[[ [] ]]0, match[0]).row_name);end end end 
       if ___conditional___ = 3--[[ Tconstr ]]
       or ___conditional___ = 11--[[ Tpackage ]] then do
          return Curry._1(it.it_path, match[0]);end end end 
       do
      else do
        return --[[ () ]]0;
        end end
        
    end
  end end 
end end

function it_path(p) do
  return --[[ () ]]0;
end end

function copy_row(f, fixed, row, keep, more) do
  fields = List.map((function (param) do
          fi = param[1];
          match = row_field_repr_aux(--[[ [] ]]0, fi);
          tmp;
          if (typeof match == "number") then do
            tmp = fi;
          end else if (match.tag) then do
            e = keep and match[3] or (do
                  contents: undefined
                end);
            m = row.row_fixed and fixed or match[2];
            tl = List.map(f, match[1]);
            tmp = --[[ Reither ]]Block.__(1, {
                match[0],
                tl,
                m,
                e
              });
          end else do
            match$1 = match[0];
            tmp = match$1 ~= undefined and --[[ Rpresent ]]Block.__(0, {Curry._1(f, match$1)}) or fi;
          end end  end 
          return --[[ tuple ]]{
                  param[0],
                  tmp
                };
        end end), row.row_fields);
  match = row.row_name;
  name;
  if (match ~= undefined) then do
    match$1 = match;
    name = --[[ tuple ]]{
      match$1[0],
      List.map(f, match$1[1])
    };
  end else do
    name = undefined;
  end end 
  return do
          row_fields: fields,
          row_more: more,
          row_bound: --[[ () ]]0,
          row_closed: row.row_closed,
          row_fixed: row.row_fixed and fixed,
          row_name: name
        end;
end end

function copy_kind(_param) do
  while(true) do
    param = _param;
    if (typeof param == "number") then do
      if (param ~= 0) then do
        throw {
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "btype.ml",
                363,
                16
              }
            };
      end else do
        return --[[ Fpresent ]]0;
      end end 
    end else do
      match = param[0].contents;
      if (match ~= undefined) then do
        _param = match;
        continue ;
      end else do
        return --[[ Fvar ]]{do
                  contents: undefined
                end};
      end end 
    end end 
  end;
end end

function copy_commu(c) do
  if (commu_repr(c) == --[[ Cok ]]0) then do
    return --[[ Cok ]]0;
  end else do
    return --[[ Clink ]]{do
              contents: --[[ Cunknown ]]1
            end};
  end end 
end end

function copy_type_desc(_keep_namesOpt, f, _ty) do
  while(true) do
    keep_namesOpt = _keep_namesOpt;
    ty = _ty;
    keep_names = keep_namesOpt ~= undefined and keep_namesOpt or false;
    if (typeof ty == "number") then do
      return --[[ Tnil ]]0;
    end else do
      local ___conditional___=(ty.tag | 0);
      do
         if ___conditional___ = 0--[[ Tvar ]] then do
            if (keep_names) then do
              return ty;
            end else do
              return --[[ Tvar ]]Block.__(0, {undefined});
            end end end end end 
         if ___conditional___ = 1--[[ Tarrow ]] then do
            return --[[ Tarrow ]]Block.__(1, {
                      ty[0],
                      Curry._1(f, ty[1]),
                      Curry._1(f, ty[2]),
                      copy_commu(ty[3])
                    });end end end 
         if ___conditional___ = 2--[[ Ttuple ]] then do
            return --[[ Ttuple ]]Block.__(2, {List.map(f, ty[0])});end end end 
         if ___conditional___ = 3--[[ Tconstr ]] then do
            return --[[ Tconstr ]]Block.__(3, {
                      ty[0],
                      List.map(f, ty[1]),
                      do
                        contents: --[[ Mnil ]]0
                      end
                    });end end end 
         if ___conditional___ = 4--[[ Tobject ]] then do
            ty$1 = ty[0];
            match = ty[1].contents;
            if (match ~= undefined) then do
              match$1 = match;
              return --[[ Tobject ]]Block.__(4, {
                        Curry._1(f, ty$1),
                        do
                          contents: --[[ tuple ]]{
                            match$1[0],
                            List.map(f, match$1[1])
                          }
                        end
                      });
            end else do
              return --[[ Tobject ]]Block.__(4, {
                        Curry._1(f, ty$1),
                        do
                          contents: undefined
                        end
                      });
            end end end end end 
         if ___conditional___ = 5--[[ Tfield ]] then do
            return --[[ Tfield ]]Block.__(5, {
                      ty[0],
                      field_kind_repr(ty[1]),
                      Curry._1(f, ty[2]),
                      Curry._1(f, ty[3])
                    });end end end 
         if ___conditional___ = 6--[[ Tlink ]] then do
            _ty = ty[0].desc;
            _keep_namesOpt = undefined;
            continue ;end end end 
         if ___conditional___ = 7--[[ Tsubst ]] then do
            throw {
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "btype.ml",
                    390,
                    27
                  }
                };end end end 
         if ___conditional___ = 8--[[ Tvariant ]] then do
            throw {
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "btype.ml",
                    385,
                    27
                  }
                };end end end 
         if ___conditional___ = 9--[[ Tunivar ]] then do
            return ty;end end end 
         if ___conditional___ = 10--[[ Tpoly ]] then do
            tyl = List.map((function (x) do
                    _ty = Curry._1(f, x);
                    while(true) do
                      ty = _ty;
                      match = ty.desc;
                      if (typeof match ~= "number") then do
                        local ___conditional___=(match.tag | 0);
                        do
                           if ___conditional___ = 2--[[ Ttuple ]] then do
                              match$1 = match[0];
                              if (match$1) then do
                                _ty = match$1[0];
                                continue ;
                              end
                               end end else 
                           if ___conditional___ = 6--[[ Tlink ]] then do
                              _ty = match[0];
                              continue ;end end end 
                           if ___conditional___ = 7--[[ Tsubst ]]
                           or ___conditional___ = 9--[[ Tunivar ]] then do
                              return ty;end end end 
                           do
                          else do
                            end end
                            
                        end
                      end
                       end 
                      throw {
                            Caml_builtin_exceptions.assert_failure,
                            --[[ tuple ]]{
                              "btype.ml",
                              375,
                              26
                            }
                          };
                    end;
                  end end), ty[1]);
            return --[[ Tpoly ]]Block.__(10, {
                      Curry._1(f, ty[0]),
                      tyl
                    });end end end 
         if ___conditional___ = 11--[[ Tpackage ]] then do
            return --[[ Tpackage ]]Block.__(11, {
                      ty[0],
                      ty[1],
                      List.map(f, ty[2])
                    });end end end 
         do
        
      end
    end end 
  end;
end end

saved_desc = do
  contents: --[[ [] ]]0
end;

function save_desc(ty, desc) do
  saved_desc.contents = --[[ :: ]]{
    --[[ tuple ]]{
      ty,
      desc
    },
    saved_desc.contents
  };
  return --[[ () ]]0;
end end

saved_kinds = do
  contents: --[[ [] ]]0
end;

new_kinds = do
  contents: --[[ [] ]]0
end;

function dup_kind(r) do
  match = r.contents;
  if (match ~= undefined) then do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "btype.ml",
            408,
            40
          }
        };
  end
   end 
  if (List.memq(r, new_kinds.contents)) then do
    return 0;
  end else do
    saved_kinds.contents = --[[ :: ]]{
      r,
      saved_kinds.contents
    };
    r$prime = do
      contents: undefined
    end;
    new_kinds.contents = --[[ :: ]]{
      r$prime,
      new_kinds.contents
    };
    r.contents = --[[ Fvar ]]{r$prime};
    return --[[ () ]]0;
  end end 
end end

function cleanup_types(param) do
  List.iter((function (param) do
          param[0].desc = param[1];
          return --[[ () ]]0;
        end end), saved_desc.contents);
  List.iter((function (r) do
          r.contents = undefined;
          return --[[ () ]]0;
        end end), saved_kinds.contents);
  saved_desc.contents = --[[ [] ]]0;
  saved_kinds.contents = --[[ [] ]]0;
  new_kinds.contents = --[[ [] ]]0;
  return --[[ () ]]0;
end end

function mark_type(ty) do
  ty$1 = repr(ty);
  if (ty$1.level >= 0) then do
    ty$1.level = pivot_level - ty$1.level | 0;
    return iter_type_expr(mark_type, ty$1);
  end else do
    return 0;
  end end 
end end

function mark_type_node(ty) do
  ty$1 = repr(ty);
  if (ty$1.level >= 0) then do
    ty$1.level = pivot_level - ty$1.level | 0;
    return --[[ () ]]0;
  end else do
    return 0;
  end end 
end end

function it_type_expr(it, ty) do
  ty$1 = repr(ty);
  if (ty$1.level >= 0) then do
    mark_type_node(ty$1);
    return Curry._2(it.it_do_type_expr, it, ty$1);
  end else do
    return 0;
  end end 
end end

function unmark_type(ty) do
  ty$1 = repr(ty);
  if (ty$1.level < 0) then do
    ty$1.level = pivot_level - ty$1.level | 0;
    return iter_type_expr(unmark_type, ty$1);
  end else do
    return 0;
  end end 
end end

function it_type_expr$1(it, ty) do
  return unmark_type(ty);
end end

unmark_iterators = do
  it_signature: it_signature,
  it_signature_item: it_signature_item,
  it_value_description: it_value_description,
  it_type_declaration: it_type_declaration,
  it_extension_constructor: it_extension_constructor,
  it_module_declaration: it_module_declaration,
  it_modtype_declaration: it_modtype_declaration,
  it_class_declaration: it_class_declaration,
  it_class_type_declaration: it_class_type_declaration,
  it_module_type: it_module_type,
  it_class_type: it_class_type,
  it_type_kind: it_type_kind,
  it_do_type_expr: it_do_type_expr,
  it_type_expr: it_type_expr$1,
  it_path: it_path
end;

function unmark_extension_constructor(ext) do
  List.iter(unmark_type, ext.ext_type_params);
  List.iter(unmark_type, ext.ext_args);
  return may(unmark_type, ext.ext_ret_type);
end end

function unmark_class_signature(sign) do
  unmark_type(sign.csig_self);
  return iter$1((function (l, param) do
                return unmark_type(param[2]);
              end end), sign.csig_vars);
end end

function find_expans(priv, p1, _param) do
  while(true) do
    param = _param;
    if (typeof param == "number") then do
      return ;
    end else if (param.tag) then do
      rem = param[0].contents;
      _param = rem;
      continue ;
    end else if (param[0] >= priv and same(p1, param[1])) then do
      return param[3];
    end else do
      _param = param[4];
      continue ;
    end end  end  end 
  end;
end end

memo = do
  contents: --[[ [] ]]0
end;

function cleanup_abbrev(param) do
  List.iter((function (abbr) do
          abbr.contents = --[[ Mnil ]]0;
          return --[[ () ]]0;
        end end), memo.contents);
  memo.contents = --[[ [] ]]0;
  return --[[ () ]]0;
end end

function memorize_abbrev(mem, priv, path, v, v$prime) do
  mem.contents = --[[ Mcons ]]Block.__(0, {
      priv,
      path,
      v,
      v$prime,
      mem.contents
    });
  memo.contents = --[[ :: ]]{
    mem,
    memo.contents
  };
  return --[[ () ]]0;
end end

function forget_abbrev_rec(mem, path) do
  if (typeof mem == "number") then do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "btype.ml",
            520,
            6
          }
        };
  end else if (mem.tag) then do
    mem$prime = mem[0];
    mem$prime.contents = forget_abbrev_rec(mem$prime.contents, path);
    throw Pervasives.Exit;
  end else do
    rem = mem[4];
    path$prime = mem[1];
    if (same(path, path$prime)) then do
      return rem;
    end else do
      return --[[ Mcons ]]Block.__(0, {
                mem[0],
                path$prime,
                mem[2],
                mem[3],
                forget_abbrev_rec(rem, path)
              });
    end end 
  end end  end 
end end

function forget_abbrev(mem, path) do
  try do
    mem.contents = forget_abbrev_rec(mem.contents, path);
    return --[[ () ]]0;
  end
  catch (exn)do
    if (exn == Pervasives.Exit) then do
      return --[[ () ]]0;
    end else do
      throw exn;
    end end 
  end
end end

function is_optional(l) do
  if (#l ~= 0) then do
    return Caml_string.get(l, 0) == --[[ "?" ]]63;
  end else do
    return false;
  end end 
end end

function label_name(l) do
  if (is_optional(l)) then do
    return __String.sub(l, 1, #l - 1 | 0);
  end else do
    return l;
  end end 
end end

function prefixed_label_name(l) do
  if (is_optional(l)) then do
    return l;
  end else do
    return "~" .. l;
  end end 
end end

function extract_label_aux(_hd, l, _param) do
  while(true) do
    param = _param;
    hd = _hd;
    if (param) then do
      ls = param[1];
      p = param[0];
      l$prime = p[0];
      if (label_name(l$prime) == l) then do
        return --[[ tuple ]]{
                l$prime,
                p[1],
                List.rev(hd),
                ls
              };
      end else do
        _param = ls;
        _hd = --[[ :: ]]{
          p,
          hd
        };
        continue ;
      end end 
    end else do
      throw Caml_builtin_exceptions.not_found;
    end end 
  end;
end end

function undo_change(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Ctype ]] then do
        param[0].desc = param[1];
        return --[[ () ]]0;end end end 
     if ___conditional___ = 1--[[ Clevel ]] then do
        param[0].level = param[1];
        return --[[ () ]]0;end end end 
     do
    else do
      param[0].contents = param[1];
      return --[[ () ]]0;
      end end
      
  end
end end

trail = Caml_weak.caml_weak_create(1);

last_snapshot = do
  contents: 0
end;

function log_change(ch) do
  match = Caml_weak.caml_weak_get(trail, 0);
  if (match ~= undefined) then do
    r$prime = do
      contents: --[[ Unchanged ]]0
    end;
    match.contents = --[[ Change ]]{
      ch,
      r$prime
    };
    return Caml_weak.caml_weak_set(trail, 0, r$prime);
  end else do
    return --[[ () ]]0;
  end end 
end end

function log_type(ty) do
  if (ty.id <= last_snapshot.contents) then do
    return log_change(--[[ Ctype ]]Block.__(0, {
                  ty,
                  ty.desc
                }));
  end else do
    return 0;
  end end 
end end

function link_type(ty, ty$prime) do
  log_type(ty);
  desc = ty.desc;
  ty.desc = --[[ Tlink ]]Block.__(6, {ty$prime});
  match = ty$prime.desc;
  if (typeof desc == "number" or desc.tag or typeof match == "number" or match.tag) then do
    return --[[ () ]]0;
  end else do
    name = desc[0];
    if (name ~= undefined and not (match[0] ~= undefined and ty.level >= ty$prime.level)) then do
      log_type(ty$prime);
      ty$prime.desc = --[[ Tvar ]]Block.__(0, {name});
      return --[[ () ]]0;
    end else do
      return --[[ () ]]0;
    end end 
  end end 
end end

function set_level(ty, level) do
  if (ty.id <= last_snapshot.contents) then do
    log_change(--[[ Clevel ]]Block.__(1, {
            ty,
            ty.level
          }));
  end
   end 
  ty.level = level;
  return --[[ () ]]0;
end end

function set_univar(rty, ty) do
  log_change(--[[ Cuniv ]]Block.__(6, {
          rty,
          rty.contents
        }));
  rty.contents = ty;
  return --[[ () ]]0;
end end

function set_name(nm, v) do
  log_change(--[[ Cname ]]Block.__(2, {
          nm,
          nm.contents
        }));
  nm.contents = v;
  return --[[ () ]]0;
end end

function set_row_field(e, v) do
  log_change(--[[ Crow ]]Block.__(3, {
          e,
          e.contents
        }));
  e.contents = v;
  return --[[ () ]]0;
end end

function set_kind(rk, k) do
  log_change(--[[ Ckind ]]Block.__(4, {
          rk,
          rk.contents
        }));
  rk.contents = k;
  return --[[ () ]]0;
end end

function set_commu(rc, c) do
  log_change(--[[ Ccommu ]]Block.__(5, {
          rc,
          rc.contents
        }));
  rc.contents = c;
  return --[[ () ]]0;
end end

function set_typeset(rs, s) do
  log_change(--[[ Ctypeset ]]Block.__(7, {
          rs,
          rs.contents
        }));
  rs.contents = s;
  return --[[ () ]]0;
end end

function snapshot(param) do
  old = last_snapshot.contents;
  last_snapshot.contents = new_id.contents;
  match = Caml_weak.caml_weak_get(trail, 0);
  if (match ~= undefined) then do
    return --[[ tuple ]]{
            match,
            old
          };
  end else do
    r = do
      contents: --[[ Unchanged ]]0
    end;
    Caml_weak.caml_weak_set(trail, 0, r);
    return --[[ tuple ]]{
            r,
            old
          };
  end end 
end end

function rev_log(_accu, _param) do
  while(true) do
    param = _param;
    accu = _accu;
    if (typeof param == "number") then do
      if (param ~= 0) then do
        throw {
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "btype.ml",
                656,
                15
              }
            };
      end
       end 
      return accu;
    end else do
      next = param[1];
      d = next.contents;
      next.contents = --[[ Invalid ]]1;
      _param = d;
      _accu = --[[ :: ]]{
        param[0],
        accu
      };
      continue ;
    end end 
  end;
end end

function backtrack(param) do
  old = param[1];
  changes = param[0];
  change = changes.contents;
  if (typeof change == "number") then do
    if (change ~= 0) then do
      throw {
            Caml_builtin_exceptions.failure,
            "Btype.backtrack"
          };
    end
     end 
    last_snapshot.contents = old;
    return --[[ () ]]0;
  end else do
    cleanup_abbrev(--[[ () ]]0);
    backlog = rev_log(--[[ [] ]]0, change);
    List.iter(undo_change, backlog);
    changes.contents = --[[ Unchanged ]]0;
    last_snapshot.contents = old;
    return Caml_weak.caml_weak_set(trail, 0, changes);
  end end 
end end

__Error$1 = Caml_exceptions.create("Ocaml_typedtree_test.Cmi_format.Error");

function input_cmi(ic) do
  match = Caml_external_polyfill.resolve("caml_input_value")(ic);
  crcs = Caml_external_polyfill.resolve("caml_input_value")(ic);
  flags = Caml_external_polyfill.resolve("caml_input_value")(ic);
  return do
          cmi_name: match[0],
          cmi_sign: match[1],
          cmi_crcs: crcs,
          cmi_flags: flags
        end;
end end

function read_cmi(filename) do
  ic = Pervasives.open_in_bin(filename);
  try do
    buffer = Pervasives.really_input_string(ic, #cmi_magic_number);
    if (buffer ~= cmi_magic_number) then do
      Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
      pre_len = #cmi_magic_number - 3 | 0;
      if (__String.sub(buffer, 0, pre_len) == __String.sub(cmi_magic_number, 0, pre_len)) then do
        msg = buffer < cmi_magic_number and "an older" or "a newer";
        throw {
              __Error$1,
              --[[ Wrong_version_interface ]]Block.__(1, {
                  filename,
                  msg
                })
            };
      end else do
        throw {
              __Error$1,
              --[[ Not_an_interface ]]Block.__(0, {filename})
            };
      end end 
    end
     end 
    cmi = input_cmi(ic);
    Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
    return cmi;
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn == Caml_builtin_exceptions.end_of_file) then do
      Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
      throw {
            __Error$1,
            --[[ Corrupted_interface ]]Block.__(2, {filename})
          };
    end else if (exn[0] == Caml_builtin_exceptions.failure) then do
      Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
      throw {
            __Error$1,
            --[[ Corrupted_interface ]]Block.__(2, {filename})
          };
    end else if (exn[0] == __Error$1) then do
      Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
      throw {
            __Error$1,
            exn[1]
          };
    end else do
      throw exn;
    end end  end  end 
  end
end end

function output_cmi(filename, oc, cmi) do
  Pervasives.output_string(oc, cmi_magic_number);
  Caml_external_polyfill.resolve("caml_output_value")(oc, --[[ tuple ]]{
        cmi.cmi_name,
        cmi.cmi_sign
      }, --[[ [] ]]0);
  Caml_io.caml_ml_flush(oc);
  crc = Digest.file(filename);
  crcs_000 = --[[ tuple ]]{
    cmi.cmi_name,
    crc
  };
  crcs_001 = cmi.cmi_crcs;
  crcs = --[[ :: ]]{
    crcs_000,
    crcs_001
  };
  Caml_external_polyfill.resolve("caml_output_value")(oc, crcs, --[[ [] ]]0);
  Caml_external_polyfill.resolve("caml_output_value")(oc, cmi.cmi_flags, --[[ [] ]]0);
  return crc;
end end

function report_error(ppf, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Not_an_interface ]] then do
        return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@ ",
                                    1,
                                    0
                                  }),
                                --[[ String_literal ]]Block.__(11, {
                                    "is not a compiled interface",
                                    --[[ End_of_format ]]0
                                  })
                              })}),
                        "%a@ is not a compiled interface"
                      }), print_filename, param[0]);end end end 
     if ___conditional___ = 1--[[ Wrong_version_interface ]] then do
        return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@ ",
                                    1,
                                    0
                                  }),
                                --[[ String_literal ]]Block.__(11, {
                                    "is not a compiled interface for this version of OCaml.",
                                    --[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Flush_newline ]]4,
                                        --[[ String_literal ]]Block.__(11, {
                                            "It seems to be for ",
                                            --[[ String ]]Block.__(2, {
                                                --[[ No_padding ]]0,
                                                --[[ String_literal ]]Block.__(11, {
                                                    " version of OCaml.",
                                                    --[[ End_of_format ]]0
                                                  })
                                              })
                                          })
                                      })
                                  })
                              })}),
                        "%a@ is not a compiled interface for this version of OCaml.@.It seems to be for %s version of OCaml."
                      }), print_filename, param[0], param[1]);end end end 
     if ___conditional___ = 2--[[ Corrupted_interface ]] then do
        return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ String_literal ]]Block.__(11, {
                            "Corrupted compiled interface",
                            --[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@ ",
                                    1,
                                    0
                                  }),
                                --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                              })
                          }),
                        "Corrupted compiled interface@ %a"
                      }), print_filename, param[0]);end end end 
     do
    
  end
end end

register_error_of_exn((function (param) do
        if (param[0] == __Error$1) then do
          return error_of_printer_file(report_error, param[1]);
        end
         end 
      end end));

Inconsistency = Caml_exceptions.create("Ocaml_typedtree_test.Consistbl.Inconsistency");

function set$1(tbl, name, crc, source) do
  return Hashtbl.add(tbl, name, --[[ tuple ]]{
              crc,
              source
            });
end end

function extract(l, tbl) do
  l$1 = List.sort_uniq(__String.compare, l);
  return List.fold_left((function (assc, name) do
                try do
                  match = Hashtbl.find(tbl, name);
                  return --[[ :: ]]{
                          --[[ tuple ]]{
                            name,
                            Caml_option.some(match[0])
                          },
                          assc
                        };
                end
                catch (exn)do
                  if (exn == Caml_builtin_exceptions.not_found) then do
                    return --[[ :: ]]{
                            --[[ tuple ]]{
                              name,
                              undefined
                            },
                            assc
                          };
                  end else do
                    throw exn;
                  end end 
                end
              end end), --[[ [] ]]0, l$1);
end end

function free_vars(ty) do
  ret = do
    contents: --[[ Empty ]]0
  end;
  loop = function (_ty) do
    while(true) do
      ty = _ty;
      ty$1 = repr(ty);
      if (ty$1.level >= 0) then do
        ty$1.level = pivot_level - ty$1.level | 0;
        match = ty$1.desc;
        if (typeof match == "number") then do
          return iter_type_expr(loop, ty$1);
        end else do
          local ___conditional___=(match.tag | 0);
          do
             if ___conditional___ = 0--[[ Tvar ]] then do
                ret.contents = add$3(ty$1, ret.contents);
                return --[[ () ]]0;end end end 
             if ___conditional___ = 8--[[ Tvariant ]] then do
                row = row_repr_aux(--[[ [] ]]0, match[0]);
                iter_row(loop, row);
                if (static_row(row)) then do
                  return 0;
                end else do
                  _ty = row.row_more;
                  continue ;
                end end end end end 
             do
            else do
              return iter_type_expr(loop, ty$1);
              end end
              
          end
        end end 
      end else do
        return 0;
      end end 
    end;
  end end;
  loop(ty);
  unmark_type(ty);
  return ret.contents;
end end

optional_shape_000 = do
  txt: "internal.optional",
  loc: none
end;

optional_shape_001 = --[[ PStr ]]Block.__(0, {--[[ [] ]]0});

optional_shape = --[[ tuple ]]{
  optional_shape_000,
  optional_shape_001
};

function extension_descr(path_ext, ext) do
  match = ext.ext_ret_type;
  ty_res = match ~= undefined and match or newty2(100000000, --[[ Tconstr ]]Block.__(3, {
            ext.ext_type_path,
            ext.ext_type_params,
            do
              contents: --[[ Mnil ]]0
            end
          }));
  tag_001 = ext.ext_args == --[[ [] ]]0;
  tag = --[[ Cstr_extension ]]Block.__(2, {
      path_ext,
      tag_001
    });
  match$1 = ext.ext_ret_type;
  existentials;
  if (match$1 ~= undefined) then do
    ret_vars = free_vars(match$1);
    arg_vars = free_vars(newty2(100000000, --[[ Ttuple ]]Block.__(2, {ext.ext_args})));
    existentials = elements_aux$1(--[[ [] ]]0, diff$1(arg_vars, ret_vars));
  end else do
    existentials = --[[ [] ]]0;
  end end 
  return do
          cstr_name: last(path_ext),
          cstr_res: ty_res,
          cstr_existentials: existentials,
          cstr_args: ext.ext_args,
          cstr_arity: List.length(ext.ext_args),
          cstr_tag: tag,
          cstr_consts: -1,
          cstr_nonconsts: -1,
          cstr_normal: -1,
          cstr_generalized: ext.ext_ret_type ~= undefined,
          cstr_private: ext.ext_private,
          cstr_loc: ext.ext_loc,
          cstr_attributes: ext.ext_attributes
        end;
end end

none$1 = do
  desc: --[[ Ttuple ]]Block.__(2, {--[[ [] ]]0}),
  level: -1,
  id: -1
end;

dummy_label_lbl_all = {};

dummy_label = do
  lbl_name: "",
  lbl_res: none$1,
  lbl_arg: none$1,
  lbl_mut: --[[ Immutable ]]0,
  lbl_pos: -1,
  lbl_all: dummy_label_lbl_all,
  lbl_repres: --[[ Record_regular ]]0,
  lbl_private: --[[ Public ]]1,
  lbl_loc: none,
  lbl_attributes: --[[ [] ]]0
end;

builtin_idents = do
  contents: --[[ [] ]]0
end;

function wrap(create, s) do
  id = Curry._1(create, s);
  builtin_idents.contents = --[[ :: ]]{
    --[[ tuple ]]{
      s,
      id
    },
    builtin_idents.contents
  };
  return id;
end end

ident_int = wrap(create, "int");

ident_char = wrap(create, "char");

ident_string = wrap(create, "string");

ident_float = wrap(create, "float");

ident_bool = wrap(create, "bool");

ident_unit = wrap(create, "unit");

ident_exn = wrap(create, "exn");

ident_array = wrap(create, "array");

ident_list = wrap(create, "list");

ident_option = wrap(create, "option");

ident_nativeint = wrap(create, "nativeint");

ident_int32 = wrap(create, "int32");

ident_int64 = wrap(create, "int64");

ident_lazy_t = wrap(create, "lazy_t");

ident_bytes = wrap(create, "bytes");

path_int = --[[ Pident ]]Block.__(0, {ident_int});

path_char = --[[ Pident ]]Block.__(0, {ident_char});

path_string = --[[ Pident ]]Block.__(0, {ident_string});

path_float = --[[ Pident ]]Block.__(0, {ident_float});

path_bool = --[[ Pident ]]Block.__(0, {ident_bool});

path_unit = --[[ Pident ]]Block.__(0, {ident_unit});

path_exn = --[[ Pident ]]Block.__(0, {ident_exn});

path_array = --[[ Pident ]]Block.__(0, {ident_array});

path_list = --[[ Pident ]]Block.__(0, {ident_list});

path_option = --[[ Pident ]]Block.__(0, {ident_option});

path_nativeint = --[[ Pident ]]Block.__(0, {ident_nativeint});

path_int32 = --[[ Pident ]]Block.__(0, {ident_int32});

path_int64 = --[[ Pident ]]Block.__(0, {ident_int64});

path_lazy_t = --[[ Pident ]]Block.__(0, {ident_lazy_t});

path_bytes = --[[ Pident ]]Block.__(0, {ident_bytes});

type_int = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
        path_int,
        --[[ [] ]]0,
        do
          contents: --[[ Mnil ]]0
        end
      }));

type_char = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
        path_char,
        --[[ [] ]]0,
        do
          contents: --[[ Mnil ]]0
        end
      }));

type_string = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
        path_string,
        --[[ [] ]]0,
        do
          contents: --[[ Mnil ]]0
        end
      }));

type_float = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
        path_float,
        --[[ [] ]]0,
        do
          contents: --[[ Mnil ]]0
        end
      }));

type_bool = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
        path_bool,
        --[[ [] ]]0,
        do
          contents: --[[ Mnil ]]0
        end
      }));

type_unit = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
        path_unit,
        --[[ [] ]]0,
        do
          contents: --[[ Mnil ]]0
        end
      }));

type_exn = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
        path_exn,
        --[[ [] ]]0,
        do
          contents: --[[ Mnil ]]0
        end
      }));

function type_array(t) do
  return newty2(100000000, --[[ Tconstr ]]Block.__(3, {
                path_array,
                --[[ :: ]]{
                  t,
                  --[[ [] ]]0
                },
                do
                  contents: --[[ Mnil ]]0
                end
              }));
end end

function type_list(t) do
  return newty2(100000000, --[[ Tconstr ]]Block.__(3, {
                path_list,
                --[[ :: ]]{
                  t,
                  --[[ [] ]]0
                },
                do
                  contents: --[[ Mnil ]]0
                end
              }));
end end

function type_option(t) do
  return newty2(100000000, --[[ Tconstr ]]Block.__(3, {
                path_option,
                --[[ :: ]]{
                  t,
                  --[[ [] ]]0
                },
                do
                  contents: --[[ Mnil ]]0
                end
              }));
end end

type_nativeint = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
        path_nativeint,
        --[[ [] ]]0,
        do
          contents: --[[ Mnil ]]0
        end
      }));

type_int32 = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
        path_int32,
        --[[ [] ]]0,
        do
          contents: --[[ Mnil ]]0
        end
      }));

type_int64 = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
        path_int64,
        --[[ [] ]]0,
        do
          contents: --[[ Mnil ]]0
        end
      }));

function type_lazy_t(t) do
  return newty2(100000000, --[[ Tconstr ]]Block.__(3, {
                path_lazy_t,
                --[[ :: ]]{
                  t,
                  --[[ [] ]]0
                },
                do
                  contents: --[[ Mnil ]]0
                end
              }));
end end

newty2(100000000, --[[ Tconstr ]]Block.__(3, {
        path_bytes,
        --[[ [] ]]0,
        do
          contents: --[[ Mnil ]]0
        end
      }));

ident_match_failure = wrap(create_predef_exn, "Match_failure");

ident_out_of_memory = wrap(create_predef_exn, "Out_of_memory");

ident_invalid_argument = wrap(create_predef_exn, "Invalid_argument");

ident_failure = wrap(create_predef_exn, "Failure");

ident_not_found = wrap(create_predef_exn, "Not_found");

ident_sys_error = wrap(create_predef_exn, "Sys_error");

ident_end_of_file = wrap(create_predef_exn, "End_of_file");

ident_division_by_zero = wrap(create_predef_exn, "Division_by_zero");

ident_stack_overflow = wrap(create_predef_exn, "Stack_overflow");

ident_sys_blocked_io = wrap(create_predef_exn, "Sys_blocked_io");

ident_assert_failure = wrap(create_predef_exn, "Assert_failure");

ident_undefined_recursive_module = wrap(create_predef_exn, "Undefined_recursive_module");

decl_abstr = do
  type_params: --[[ [] ]]0,
  type_arity: 0,
  type_kind: --[[ Type_abstract ]]0,
  type_private: --[[ Public ]]1,
  type_manifest: undefined,
  type_variance: --[[ [] ]]0,
  type_newtype_level: undefined,
  type_loc: none,
  type_attributes: --[[ [] ]]0
end;

function cstr(id, args) do
  return do
          cd_id: id,
          cd_args: args,
          cd_res: undefined,
          cd_loc: none,
          cd_attributes: --[[ [] ]]0
        end;
end end

ident_false = wrap(create, "false");

ident_true = wrap(create, "true");

ident_void = wrap(create, "()");

ident_nil = wrap(create, "[]");

ident_cons = wrap(create, "::");

ident_none = wrap(create, "None");

ident_some = wrap(create, "Some");

function common_initial_env(add_type, add_extension, empty_env) do
  decl_bool_type_kind = --[[ Type_variant ]]Block.__(1, {--[[ :: ]]{
        cstr(ident_false, --[[ [] ]]0),
        --[[ :: ]]{
          cstr(ident_true, --[[ [] ]]0),
          --[[ [] ]]0
        }
      }});
  decl_bool = do
    type_params: --[[ [] ]]0,
    type_arity: 0,
    type_kind: decl_bool_type_kind,
    type_private: --[[ Public ]]1,
    type_manifest: undefined,
    type_variance: --[[ [] ]]0,
    type_newtype_level: undefined,
    type_loc: none,
    type_attributes: --[[ [] ]]0
  end;
  decl_unit_type_kind = --[[ Type_variant ]]Block.__(1, {--[[ :: ]]{
        cstr(ident_void, --[[ [] ]]0),
        --[[ [] ]]0
      }});
  decl_unit = do
    type_params: --[[ [] ]]0,
    type_arity: 0,
    type_kind: decl_unit_type_kind,
    type_private: --[[ Public ]]1,
    type_manifest: undefined,
    type_variance: --[[ [] ]]0,
    type_newtype_level: undefined,
    type_loc: none,
    type_attributes: --[[ [] ]]0
  end;
  decl_exn = do
    type_params: --[[ [] ]]0,
    type_arity: 0,
    type_kind: --[[ Type_open ]]1,
    type_private: --[[ Public ]]1,
    type_manifest: undefined,
    type_variance: --[[ [] ]]0,
    type_newtype_level: undefined,
    type_loc: none,
    type_attributes: --[[ [] ]]0
  end;
  tvar = newty2(100000000, --[[ Tvar ]]Block.__(0, {undefined}));
  decl_array_type_params = --[[ :: ]]{
    tvar,
    --[[ [] ]]0
  };
  decl_array_type_variance = --[[ :: ]]{
    Types_Variance.full,
    --[[ [] ]]0
  };
  decl_array = do
    type_params: decl_array_type_params,
    type_arity: 1,
    type_kind: --[[ Type_abstract ]]0,
    type_private: --[[ Public ]]1,
    type_manifest: undefined,
    type_variance: decl_array_type_variance,
    type_newtype_level: undefined,
    type_loc: none,
    type_attributes: --[[ [] ]]0
  end;
  tvar$1 = newty2(100000000, --[[ Tvar ]]Block.__(0, {undefined}));
  decl_list_type_params = --[[ :: ]]{
    tvar$1,
    --[[ [] ]]0
  };
  decl_list_type_kind = --[[ Type_variant ]]Block.__(1, {--[[ :: ]]{
        cstr(ident_nil, --[[ [] ]]0),
        --[[ :: ]]{
          cstr(ident_cons, --[[ :: ]]{
                tvar$1,
                --[[ :: ]]{
                  type_list(tvar$1),
                  --[[ [] ]]0
                }
              }),
          --[[ [] ]]0
        }
      }});
  decl_list_type_variance = --[[ :: ]]{
    Types_Variance.covariant,
    --[[ [] ]]0
  };
  decl_list = do
    type_params: decl_list_type_params,
    type_arity: 1,
    type_kind: decl_list_type_kind,
    type_private: --[[ Public ]]1,
    type_manifest: undefined,
    type_variance: decl_list_type_variance,
    type_newtype_level: undefined,
    type_loc: none,
    type_attributes: --[[ [] ]]0
  end;
  tvar$2 = newty2(100000000, --[[ Tvar ]]Block.__(0, {undefined}));
  decl_option_type_params = --[[ :: ]]{
    tvar$2,
    --[[ [] ]]0
  };
  decl_option_type_kind = --[[ Type_variant ]]Block.__(1, {--[[ :: ]]{
        cstr(ident_none, --[[ [] ]]0),
        --[[ :: ]]{
          cstr(ident_some, --[[ :: ]]{
                tvar$2,
                --[[ [] ]]0
              }),
          --[[ [] ]]0
        }
      }});
  decl_option_type_variance = --[[ :: ]]{
    Types_Variance.covariant,
    --[[ [] ]]0
  };
  decl_option = do
    type_params: decl_option_type_params,
    type_arity: 1,
    type_kind: decl_option_type_kind,
    type_private: --[[ Public ]]1,
    type_manifest: undefined,
    type_variance: decl_option_type_variance,
    type_newtype_level: undefined,
    type_loc: none,
    type_attributes: --[[ [] ]]0
  end;
  tvar$3 = newty2(100000000, --[[ Tvar ]]Block.__(0, {undefined}));
  decl_lazy_t_type_params = --[[ :: ]]{
    tvar$3,
    --[[ [] ]]0
  };
  decl_lazy_t_type_variance = --[[ :: ]]{
    Types_Variance.covariant,
    --[[ [] ]]0
  };
  decl_lazy_t = do
    type_params: decl_lazy_t_type_params,
    type_arity: 1,
    type_kind: --[[ Type_abstract ]]0,
    type_private: --[[ Public ]]1,
    type_manifest: undefined,
    type_variance: decl_lazy_t_type_variance,
    type_newtype_level: undefined,
    type_loc: none,
    type_attributes: --[[ [] ]]0
  end;
  add_extension$1 = function (id, l) do
    return Curry._2(add_extension, id, do
                ext_type_path: path_exn,
                ext_type_params: --[[ [] ]]0,
                ext_args: l,
                ext_ret_type: undefined,
                ext_private: --[[ Public ]]1,
                ext_loc: none,
                ext_attributes: --[[ [] ]]0
              end);
  end end;
  return Curry._1(add_extension$1(ident_match_failure, --[[ :: ]]{
                  newty2(100000000, --[[ Ttuple ]]Block.__(2, {--[[ :: ]]{
                            type_string,
                            --[[ :: ]]{
                              type_int,
                              --[[ :: ]]{
                                type_int,
                                --[[ [] ]]0
                              }
                            }
                          }})),
                  --[[ [] ]]0
                }), Curry._1(add_extension$1(ident_out_of_memory, --[[ [] ]]0), Curry._1(add_extension$1(ident_stack_overflow, --[[ [] ]]0), Curry._1(add_extension$1(ident_invalid_argument, --[[ :: ]]{
                              type_string,
                              --[[ [] ]]0
                            }), Curry._1(add_extension$1(ident_failure, --[[ :: ]]{
                                  type_string,
                                  --[[ [] ]]0
                                }), Curry._1(add_extension$1(ident_not_found, --[[ [] ]]0), Curry._1(add_extension$1(ident_sys_blocked_io, --[[ [] ]]0), Curry._1(add_extension$1(ident_sys_error, --[[ :: ]]{
                                              type_string,
                                              --[[ [] ]]0
                                            }), Curry._1(add_extension$1(ident_end_of_file, --[[ [] ]]0), Curry._1(add_extension$1(ident_division_by_zero, --[[ [] ]]0), Curry._1(add_extension$1(ident_assert_failure, --[[ :: ]]{
                                                          newty2(100000000, --[[ Ttuple ]]Block.__(2, {--[[ :: ]]{
                                                                    type_string,
                                                                    --[[ :: ]]{
                                                                      type_int,
                                                                      --[[ :: ]]{
                                                                        type_int,
                                                                        --[[ [] ]]0
                                                                      }
                                                                    }
                                                                  }})),
                                                          --[[ [] ]]0
                                                        }), Curry._1(add_extension$1(ident_undefined_recursive_module, --[[ :: ]]{
                                                              newty2(100000000, --[[ Ttuple ]]Block.__(2, {--[[ :: ]]{
                                                                        type_string,
                                                                        --[[ :: ]]{
                                                                          type_int,
                                                                          --[[ :: ]]{
                                                                            type_int,
                                                                            --[[ [] ]]0
                                                                          }
                                                                        }
                                                                      }})),
                                                              --[[ [] ]]0
                                                            }), Curry._3(add_type, ident_int64, decl_abstr, Curry._3(add_type, ident_int32, decl_abstr, Curry._3(add_type, ident_nativeint, decl_abstr, Curry._3(add_type, ident_lazy_t, decl_lazy_t, Curry._3(add_type, ident_option, decl_option, Curry._3(add_type, ident_list, decl_list, Curry._3(add_type, ident_array, decl_array, Curry._3(add_type, ident_exn, decl_exn, Curry._3(add_type, ident_unit, decl_unit, Curry._3(add_type, ident_bool, decl_bool, Curry._3(add_type, ident_float, decl_abstr, Curry._3(add_type, ident_string, decl_abstr, Curry._3(add_type, ident_char, decl_abstr, Curry._3(add_type, ident_int, decl_abstr, empty_env))))))))))))))))))))))))));
end end

function build_initial_env(add_type, add_exception, empty_env) do
  common = common_initial_env(add_type, add_exception, empty_env);
  safe_string = Curry._3(add_type, ident_bytes, decl_abstr, common);
  decl_bytes_unsafe_type_manifest = type_string;
  decl_bytes_unsafe = do
    type_params: --[[ [] ]]0,
    type_arity: 0,
    type_kind: --[[ Type_abstract ]]0,
    type_private: --[[ Public ]]1,
    type_manifest: decl_bytes_unsafe_type_manifest,
    type_variance: --[[ [] ]]0,
    type_newtype_level: undefined,
    type_loc: none,
    type_attributes: --[[ [] ]]0
  end;
  unsafe_string = Curry._3(add_type, ident_bytes, decl_bytes_unsafe, common);
  return --[[ tuple ]]{
          safe_string,
          unsafe_string
        };
end end

List.map((function (id) do
        make_global(id);
        return --[[ tuple ]]{
                id.name,
                id
              };
      end end), --[[ :: ]]{
      ident_match_failure,
      --[[ :: ]]{
        ident_out_of_memory,
        --[[ :: ]]{
          ident_stack_overflow,
          --[[ :: ]]{
            ident_invalid_argument,
            --[[ :: ]]{
              ident_failure,
              --[[ :: ]]{
                ident_not_found,
                --[[ :: ]]{
                  ident_sys_error,
                  --[[ :: ]]{
                    ident_end_of_file,
                    --[[ :: ]]{
                      ident_division_by_zero,
                      --[[ :: ]]{
                        ident_sys_blocked_io,
                        --[[ :: ]]{
                          ident_assert_failure,
                          --[[ :: ]]{
                            ident_undefined_recursive_module,
                            --[[ [] ]]0
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    });

set_current_time(999);

List.rev(builtin_idents.contents);

docstrings = do
  contents: --[[ [] ]]0
end;

function warn_bad_docstrings(param) do
  if (is_active(--[[ Bad_docstring ]]Block.__(33, {true}))) then do
    return List.iter((function (ds) do
                  match = ds.ds_attached;
                  local ___conditional___=(match);
                  do
                     if ___conditional___ = 0--[[ Unattached ]] then do
                        return prerr_warning(ds.ds_loc, --[[ Bad_docstring ]]Block.__(33, {true}));end end end 
                     if ___conditional___ = 1--[[ Info ]] then do
                        return --[[ () ]]0;end end end 
                     if ___conditional___ = 2--[[ Docs ]] then do
                        match$1 = ds.ds_associated;
                        if (match$1 >= 2) then do
                          return prerr_warning(ds.ds_loc, --[[ Bad_docstring ]]Block.__(33, {false}));
                        end else do
                          return --[[ () ]]0;
                        end end end end end 
                     do
                    
                  end
                end end), List.rev(docstrings.contents));
  end else do
    return 0;
  end end 
end end

function docstring(body, loc) do
  ds = do
    ds_body: body,
    ds_loc: loc,
    ds_attached: --[[ Unattached ]]0,
    ds_associated: --[[ Zero ]]0
  end;
  docstrings.contents = --[[ :: ]]{
    ds,
    docstrings.contents
  };
  return ds;
end end

empty_docs = do
  docs_pre: undefined,
  docs_post: undefined
end;

doc_loc = do
  txt: "ocaml.doc",
  loc: none
end;

function docs_attr(ds) do
  exp_pexp_desc = --[[ Pexp_constant ]]Block.__(1, {--[[ Const_string ]]Block.__(2, {
          ds.ds_body,
          undefined
        })});
  exp_pexp_loc = ds.ds_loc;
  exp = do
    pexp_desc: exp_pexp_desc,
    pexp_loc: exp_pexp_loc,
    pexp_attributes: --[[ [] ]]0
  end;
  item_pstr_desc = --[[ Pstr_eval ]]Block.__(0, {
      exp,
      --[[ [] ]]0
    });
  item_pstr_loc = exp_pexp_loc;
  item = do
    pstr_desc: item_pstr_desc,
    pstr_loc: item_pstr_loc
  end;
  return --[[ tuple ]]{
          doc_loc,
          --[[ PStr ]]Block.__(0, {--[[ :: ]]{
                item,
                --[[ [] ]]0
              }})
        };
end end

function add_docs_attrs(docs, attrs) do
  match = docs.docs_pre;
  attrs$1 = match ~= undefined and --[[ :: ]]{
      docs_attr(match),
      attrs
    } or attrs;
  match$1 = docs.docs_post;
  if (match$1 ~= undefined) then do
    return Pervasives.$at(attrs$1, --[[ :: ]]{
                docs_attr(match$1),
                --[[ [] ]]0
              });
  end else do
    return attrs$1;
  end end 
end end

function add_info_attrs(info, attrs) do
  if (info ~= undefined) then do
    return Pervasives.$at(attrs, --[[ :: ]]{
                docs_attr(info),
                --[[ [] ]]0
              });
  end else do
    return attrs;
  end end 
end end

text_loc = do
  txt: "ocaml.text",
  loc: none
end;

function text_attr(ds) do
  exp_pexp_desc = --[[ Pexp_constant ]]Block.__(1, {--[[ Const_string ]]Block.__(2, {
          ds.ds_body,
          undefined
        })});
  exp_pexp_loc = ds.ds_loc;
  exp = do
    pexp_desc: exp_pexp_desc,
    pexp_loc: exp_pexp_loc,
    pexp_attributes: --[[ [] ]]0
  end;
  item_pstr_desc = --[[ Pstr_eval ]]Block.__(0, {
      exp,
      --[[ [] ]]0
    });
  item_pstr_loc = exp_pexp_loc;
  item = do
    pstr_desc: item_pstr_desc,
    pstr_loc: item_pstr_loc
  end;
  return --[[ tuple ]]{
          text_loc,
          --[[ PStr ]]Block.__(0, {--[[ :: ]]{
                item,
                --[[ [] ]]0
              }})
        };
end end

function add_text_attrs(dsl, attrs) do
  return Pervasives.$at(List.map(text_attr, dsl), attrs);
end end

function get_docstring(info, dsl) do
  _param = dsl;
  while(true) do
    param = _param;
    if (param) then do
      ds = param[0];
      match = ds.ds_attached;
      if (match ~= 1) then do
        ds.ds_attached = info and --[[ Info ]]1 or --[[ Docs ]]2;
        return ds;
      end else do
        _param = param[1];
        continue ;
      end end 
    end else do
      return ;
    end end 
  end;
end end

function get_docstrings(dsl) do
  _acc = --[[ [] ]]0;
  _param = dsl;
  while(true) do
    param = _param;
    acc = _acc;
    if (param) then do
      ds = param[0];
      match = ds.ds_attached;
      if (match ~= 1) then do
        ds.ds_attached = --[[ Docs ]]2;
        _param = param[1];
        _acc = --[[ :: ]]{
          ds,
          acc
        };
        continue ;
      end else do
        _param = param[1];
        continue ;
      end end 
    end else do
      return List.rev(acc);
    end end 
  end;
end end

function associate_docstrings(dsl) do
  return List.iter((function (ds) do
                match = ds.ds_associated;
                if (match ~= 0) then do
                  ds.ds_associated = --[[ Many ]]2;
                  return --[[ () ]]0;
                end else do
                  ds.ds_associated = --[[ One ]]1;
                  return --[[ () ]]0;
                end end 
              end end), dsl);
end end

pre_table = Hashtbl.create(undefined, 50);

function set_pre_docstrings(pos, dsl) do
  if (dsl ~= --[[ [] ]]0) then do
    return Hashtbl.add(pre_table, pos, dsl);
  end else do
    return 0;
  end end 
end end

function get_pre_docs(pos) do
  try do
    dsl = Hashtbl.find(pre_table, pos);
    associate_docstrings(dsl);
    return get_docstring(false, dsl);
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return ;
    end else do
      throw exn;
    end end 
  end
end end

function mark_pre_docs(pos) do
  try do
    return associate_docstrings(Hashtbl.find(pre_table, pos));
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return --[[ () ]]0;
    end else do
      throw exn;
    end end 
  end
end end

post_table = Hashtbl.create(undefined, 50);

function set_post_docstrings(pos, dsl) do
  if (dsl ~= --[[ [] ]]0) then do
    return Hashtbl.add(post_table, pos, dsl);
  end else do
    return 0;
  end end 
end end

function get_post_docs(pos) do
  try do
    dsl = Hashtbl.find(post_table, pos);
    associate_docstrings(dsl);
    return get_docstring(false, dsl);
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return ;
    end else do
      throw exn;
    end end 
  end
end end

function mark_post_docs(pos) do
  try do
    return associate_docstrings(Hashtbl.find(post_table, pos));
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return --[[ () ]]0;
    end else do
      throw exn;
    end end 
  end
end end

function get_info(pos) do
  try do
    dsl = Hashtbl.find(post_table, pos);
    return get_docstring(true, dsl);
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return ;
    end else do
      throw exn;
    end end 
  end
end end

floating_table = Hashtbl.create(undefined, 50);

function set_floating_docstrings(pos, dsl) do
  if (dsl ~= --[[ [] ]]0) then do
    return Hashtbl.add(floating_table, pos, dsl);
  end else do
    return 0;
  end end 
end end

function get_text(pos) do
  try do
    return get_docstrings(Hashtbl.find(floating_table, pos));
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return --[[ [] ]]0;
    end else do
      throw exn;
    end end 
  end
end end

pre_extra_table = Hashtbl.create(undefined, 50);

function set_pre_extra_docstrings(pos, dsl) do
  if (dsl ~= --[[ [] ]]0) then do
    return Hashtbl.add(pre_extra_table, pos, dsl);
  end else do
    return 0;
  end end 
end end

function get_pre_extra_text(pos) do
  try do
    return get_docstrings(Hashtbl.find(pre_extra_table, pos));
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return --[[ [] ]]0;
    end else do
      throw exn;
    end end 
  end
end end

post_extra_table = Hashtbl.create(undefined, 50);

function set_post_extra_docstrings(pos, dsl) do
  if (dsl ~= --[[ [] ]]0) then do
    return Hashtbl.add(post_extra_table, pos, dsl);
  end else do
    return 0;
  end end 
end end

function get_post_extra_text(pos) do
  try do
    return get_docstrings(Hashtbl.find(post_extra_table, pos));
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return --[[ [] ]]0;
    end else do
      throw exn;
    end end 
  end
end end

function symbol_docs(param) do
  return do
          docs_pre: get_pre_docs(Parsing.symbol_start_pos(--[[ () ]]0)),
          docs_post: get_post_docs(Parsing.symbol_end_pos(--[[ () ]]0))
        end;
end end

function symbol_docs_lazy(param) do
  p1 = Parsing.symbol_start_pos(--[[ () ]]0);
  p2 = Parsing.symbol_end_pos(--[[ () ]]0);
  return Caml_obj.caml_lazy_make((function (param) do
                return do
                        docs_pre: get_pre_docs(p1),
                        docs_post: get_post_docs(p2)
                      end;
              end end));
end end

function mark_symbol_docs(param) do
  mark_pre_docs(Parsing.symbol_start_pos(--[[ () ]]0));
  return mark_post_docs(Parsing.symbol_end_pos(--[[ () ]]0));
end end

function mark_rhs_docs(pos1, pos2) do
  mark_pre_docs(Parsing.rhs_start_pos(pos1));
  return mark_post_docs(Parsing.rhs_end_pos(pos2));
end end

function symbol_text_lazy(param) do
  pos = Parsing.symbol_start_pos(--[[ () ]]0);
  return Caml_obj.caml_lazy_make((function (param) do
                return get_text(pos);
              end end));
end end

function init(param) do
  docstrings.contents = --[[ [] ]]0;
  Hashtbl.reset(pre_table);
  Hashtbl.reset(post_table);
  Hashtbl.reset(floating_table);
  Hashtbl.reset(pre_extra_table);
  return Hashtbl.reset(post_extra_table);
end end

default_loc = do
  contents: none
end;

function mk(locOpt, attrsOpt, d) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  return do
          ptyp_desc: d,
          ptyp_loc: loc,
          ptyp_attributes: attrs
        end;
end end

function attr(d, a) do
  return do
          ptyp_desc: d.ptyp_desc,
          ptyp_loc: d.ptyp_loc,
          ptyp_attributes: Pervasives.$at(d.ptyp_attributes, --[[ :: ]]{
                a,
                --[[ [] ]]0
              })
        end;
end end

function __var(loc, attrs, a) do
  return mk(loc, attrs, --[[ Ptyp_var ]]Block.__(0, {a}));
end end

function arrow(loc, attrs, a, b, c) do
  return mk(loc, attrs, --[[ Ptyp_arrow ]]Block.__(1, {
                a,
                b,
                c
              }));
end end

function tuple(loc, attrs, a) do
  return mk(loc, attrs, --[[ Ptyp_tuple ]]Block.__(2, {a}));
end end

function constr(loc, attrs, a, b) do
  return mk(loc, attrs, --[[ Ptyp_constr ]]Block.__(3, {
                a,
                b
              }));
end end

function object_(loc, attrs, a, b) do
  return mk(loc, attrs, --[[ Ptyp_object ]]Block.__(4, {
                a,
                b
              }));
end end

function class_(loc, attrs, a, b) do
  return mk(loc, attrs, --[[ Ptyp_class ]]Block.__(5, {
                a,
                b
              }));
end end

function alias(loc, attrs, a, b) do
  return mk(loc, attrs, --[[ Ptyp_alias ]]Block.__(6, {
                a,
                b
              }));
end end

function variant(loc, attrs, a, b, c) do
  return mk(loc, attrs, --[[ Ptyp_variant ]]Block.__(7, {
                a,
                b,
                c
              }));
end end

function poly(loc, attrs, a, b) do
  return mk(loc, attrs, --[[ Ptyp_poly ]]Block.__(8, {
                a,
                b
              }));
end end

function __package(loc, attrs, a, b) do
  return mk(loc, attrs, --[[ Ptyp_package ]]Block.__(9, {--[[ tuple ]]{
                  a,
                  b
                }}));
end end

function extension(loc, attrs, a) do
  return mk(loc, attrs, --[[ Ptyp_extension ]]Block.__(10, {a}));
end end

function force_poly(t) do
  match = t.ptyp_desc;
  if (typeof match ~= "number" and match.tag == --[[ Ptyp_poly ]]8) then do
    return t;
  end
   end 
  return poly(t.ptyp_loc, undefined, --[[ [] ]]0, t);
end end

function mk$1(locOpt, attrsOpt, d) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  return do
          ppat_desc: d,
          ppat_loc: loc,
          ppat_attributes: attrs
        end;
end end

function attr$1(d, a) do
  return do
          ppat_desc: d.ppat_desc,
          ppat_loc: d.ppat_loc,
          ppat_attributes: Pervasives.$at(d.ppat_attributes, --[[ :: ]]{
                a,
                --[[ [] ]]0
              })
        end;
end end

function __var$1(loc, attrs, a) do
  return mk$1(loc, attrs, --[[ Ppat_var ]]Block.__(0, {a}));
end end

function alias$1(loc, attrs, a, b) do
  return mk$1(loc, attrs, --[[ Ppat_alias ]]Block.__(1, {
                a,
                b
              }));
end end

function constant(loc, attrs, a) do
  return mk$1(loc, attrs, --[[ Ppat_constant ]]Block.__(2, {a}));
end end

function interval(loc, attrs, a, b) do
  return mk$1(loc, attrs, --[[ Ppat_interval ]]Block.__(3, {
                a,
                b
              }));
end end

function tuple$1(loc, attrs, a) do
  return mk$1(loc, attrs, --[[ Ppat_tuple ]]Block.__(4, {a}));
end end

function construct(loc, attrs, a, b) do
  return mk$1(loc, attrs, --[[ Ppat_construct ]]Block.__(5, {
                a,
                b
              }));
end end

function variant$1(loc, attrs, a, b) do
  return mk$1(loc, attrs, --[[ Ppat_variant ]]Block.__(6, {
                a,
                b
              }));
end end

function record(loc, attrs, a, b) do
  return mk$1(loc, attrs, --[[ Ppat_record ]]Block.__(7, {
                a,
                b
              }));
end end

function array(loc, attrs, a) do
  return mk$1(loc, attrs, --[[ Ppat_array ]]Block.__(8, {a}));
end end

function or_(loc, attrs, a, b) do
  return mk$1(loc, attrs, --[[ Ppat_or ]]Block.__(9, {
                a,
                b
              }));
end end

function constraint_(loc, attrs, a, b) do
  return mk$1(loc, attrs, --[[ Ppat_constraint ]]Block.__(10, {
                a,
                b
              }));
end end

function type_(loc, attrs, a) do
  return mk$1(loc, attrs, --[[ Ppat_type ]]Block.__(11, {a}));
end end

function lazy_(loc, attrs, a) do
  return mk$1(loc, attrs, --[[ Ppat_lazy ]]Block.__(12, {a}));
end end

function unpack(loc, attrs, a) do
  return mk$1(loc, attrs, --[[ Ppat_unpack ]]Block.__(13, {a}));
end end

function exception_(loc, attrs, a) do
  return mk$1(loc, attrs, --[[ Ppat_exception ]]Block.__(14, {a}));
end end

function extension$1(loc, attrs, a) do
  return mk$1(loc, attrs, --[[ Ppat_extension ]]Block.__(15, {a}));
end end

function mk$2(locOpt, attrsOpt, d) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  return do
          pexp_desc: d,
          pexp_loc: loc,
          pexp_attributes: attrs
        end;
end end

function attr$2(d, a) do
  return do
          pexp_desc: d.pexp_desc,
          pexp_loc: d.pexp_loc,
          pexp_attributes: Pervasives.$at(d.pexp_attributes, --[[ :: ]]{
                a,
                --[[ [] ]]0
              })
        end;
end end

function ident(loc, attrs, a) do
  return mk$2(loc, attrs, --[[ Pexp_ident ]]Block.__(0, {a}));
end end

function constant$1(loc, attrs, a) do
  return mk$2(loc, attrs, --[[ Pexp_constant ]]Block.__(1, {a}));
end end

function let_(loc, attrs, a, b, c) do
  return mk$2(loc, attrs, --[[ Pexp_let ]]Block.__(2, {
                a,
                b,
                c
              }));
end end

function fun_(loc, attrs, a, b, c, d) do
  return mk$2(loc, attrs, --[[ Pexp_fun ]]Block.__(4, {
                a,
                b,
                c,
                d
              }));
end end

function function_(loc, attrs, a) do
  return mk$2(loc, attrs, --[[ Pexp_function ]]Block.__(3, {a}));
end end

function apply(loc, attrs, a, b) do
  return mk$2(loc, attrs, --[[ Pexp_apply ]]Block.__(5, {
                a,
                b
              }));
end end

function match_(loc, attrs, a, b) do
  return mk$2(loc, attrs, --[[ Pexp_match ]]Block.__(6, {
                a,
                b
              }));
end end

function try_(loc, attrs, a, b) do
  return mk$2(loc, attrs, --[[ Pexp_try ]]Block.__(7, {
                a,
                b
              }));
end end

function tuple$2(loc, attrs, a) do
  return mk$2(loc, attrs, --[[ Pexp_tuple ]]Block.__(8, {a}));
end end

function construct$1(loc, attrs, a, b) do
  return mk$2(loc, attrs, --[[ Pexp_construct ]]Block.__(9, {
                a,
                b
              }));
end end

function variant$2(loc, attrs, a, b) do
  return mk$2(loc, attrs, --[[ Pexp_variant ]]Block.__(10, {
                a,
                b
              }));
end end

function record$1(loc, attrs, a, b) do
  return mk$2(loc, attrs, --[[ Pexp_record ]]Block.__(11, {
                a,
                b
              }));
end end

function field(loc, attrs, a, b) do
  return mk$2(loc, attrs, --[[ Pexp_field ]]Block.__(12, {
                a,
                b
              }));
end end

function setfield(loc, attrs, a, b, c) do
  return mk$2(loc, attrs, --[[ Pexp_setfield ]]Block.__(13, {
                a,
                b,
                c
              }));
end end

function array$1(loc, attrs, a) do
  return mk$2(loc, attrs, --[[ Pexp_array ]]Block.__(14, {a}));
end end

function ifthenelse(loc, attrs, a, b, c) do
  return mk$2(loc, attrs, --[[ Pexp_ifthenelse ]]Block.__(15, {
                a,
                b,
                c
              }));
end end

function sequence(loc, attrs, a, b) do
  return mk$2(loc, attrs, --[[ Pexp_sequence ]]Block.__(16, {
                a,
                b
              }));
end end

function while_(loc, attrs, a, b) do
  return mk$2(loc, attrs, --[[ Pexp_while ]]Block.__(17, {
                a,
                b
              }));
end end

function for_(loc, attrs, a, b, c, d, e) do
  return mk$2(loc, attrs, --[[ Pexp_for ]]Block.__(18, {
                a,
                b,
                c,
                d,
                e
              }));
end end

function constraint_$1(loc, attrs, a, b) do
  return mk$2(loc, attrs, --[[ Pexp_constraint ]]Block.__(19, {
                a,
                b
              }));
end end

function coerce(loc, attrs, a, b, c) do
  return mk$2(loc, attrs, --[[ Pexp_coerce ]]Block.__(20, {
                a,
                b,
                c
              }));
end end

function send(loc, attrs, a, b) do
  return mk$2(loc, attrs, --[[ Pexp_send ]]Block.__(21, {
                a,
                b
              }));
end end

function new_(loc, attrs, a) do
  return mk$2(loc, attrs, --[[ Pexp_new ]]Block.__(22, {a}));
end end

function setinstvar(loc, attrs, a, b) do
  return mk$2(loc, attrs, --[[ Pexp_setinstvar ]]Block.__(23, {
                a,
                b
              }));
end end

function override(loc, attrs, a) do
  return mk$2(loc, attrs, --[[ Pexp_override ]]Block.__(24, {a}));
end end

function letmodule(loc, attrs, a, b, c) do
  return mk$2(loc, attrs, --[[ Pexp_letmodule ]]Block.__(25, {
                a,
                b,
                c
              }));
end end

function assert_(loc, attrs, a) do
  return mk$2(loc, attrs, --[[ Pexp_assert ]]Block.__(26, {a}));
end end

function lazy_$1(loc, attrs, a) do
  return mk$2(loc, attrs, --[[ Pexp_lazy ]]Block.__(27, {a}));
end end

function poly$1(loc, attrs, a, b) do
  return mk$2(loc, attrs, --[[ Pexp_poly ]]Block.__(28, {
                a,
                b
              }));
end end

function object_$1(loc, attrs, a) do
  return mk$2(loc, attrs, --[[ Pexp_object ]]Block.__(29, {a}));
end end

function newtype(loc, attrs, a, b) do
  return mk$2(loc, attrs, --[[ Pexp_newtype ]]Block.__(30, {
                a,
                b
              }));
end end

function pack(loc, attrs, a) do
  return mk$2(loc, attrs, --[[ Pexp_pack ]]Block.__(31, {a}));
end end

function open_(loc, attrs, a, b, c) do
  return mk$2(loc, attrs, --[[ Pexp_open ]]Block.__(32, {
                a,
                b,
                c
              }));
end end

function extension$2(loc, attrs, a) do
  return mk$2(loc, attrs, --[[ Pexp_extension ]]Block.__(33, {a}));
end end

function __case(lhs, guard, rhs) do
  return do
          pc_lhs: lhs,
          pc_guard: guard,
          pc_rhs: rhs
        end;
end end

function mk$3(locOpt, attrsOpt, d) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  return do
          pmty_desc: d,
          pmty_loc: loc,
          pmty_attributes: attrs
        end;
end end

function attr$3(d, a) do
  return do
          pmty_desc: d.pmty_desc,
          pmty_loc: d.pmty_loc,
          pmty_attributes: Pervasives.$at(d.pmty_attributes, --[[ :: ]]{
                a,
                --[[ [] ]]0
              })
        end;
end end

function ident$1(loc, attrs, a) do
  return mk$3(loc, attrs, --[[ Pmty_ident ]]Block.__(0, {a}));
end end

function alias$2(loc, attrs, a) do
  return mk$3(loc, attrs, --[[ Pmty_alias ]]Block.__(6, {a}));
end end

function signature(loc, attrs, a) do
  return mk$3(loc, attrs, --[[ Pmty_signature ]]Block.__(1, {a}));
end end

function functor_(loc, attrs, a, b, c) do
  return mk$3(loc, attrs, --[[ Pmty_functor ]]Block.__(2, {
                a,
                b,
                c
              }));
end end

function with_(loc, attrs, a, b) do
  return mk$3(loc, attrs, --[[ Pmty_with ]]Block.__(3, {
                a,
                b
              }));
end end

function typeof_(loc, attrs, a) do
  return mk$3(loc, attrs, --[[ Pmty_typeof ]]Block.__(4, {a}));
end end

function extension$3(loc, attrs, a) do
  return mk$3(loc, attrs, --[[ Pmty_extension ]]Block.__(5, {a}));
end end

function mk$4(locOpt, attrsOpt, d) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  return do
          pmod_desc: d,
          pmod_loc: loc,
          pmod_attributes: attrs
        end;
end end

function attr$4(d, a) do
  return do
          pmod_desc: d.pmod_desc,
          pmod_loc: d.pmod_loc,
          pmod_attributes: Pervasives.$at(d.pmod_attributes, --[[ :: ]]{
                a,
                --[[ [] ]]0
              })
        end;
end end

function ident$2(loc, attrs, x) do
  return mk$4(loc, attrs, --[[ Pmod_ident ]]Block.__(0, {x}));
end end

function structure(loc, attrs, x) do
  return mk$4(loc, attrs, --[[ Pmod_structure ]]Block.__(1, {x}));
end end

function functor_$1(loc, attrs, arg, arg_ty, body) do
  return mk$4(loc, attrs, --[[ Pmod_functor ]]Block.__(2, {
                arg,
                arg_ty,
                body
              }));
end end

function apply$1(loc, attrs, m1, m2) do
  return mk$4(loc, attrs, --[[ Pmod_apply ]]Block.__(3, {
                m1,
                m2
              }));
end end

function constraint_$2(loc, attrs, m, mty) do
  return mk$4(loc, attrs, --[[ Pmod_constraint ]]Block.__(4, {
                m,
                mty
              }));
end end

function unpack$1(loc, attrs, e) do
  return mk$4(loc, attrs, --[[ Pmod_unpack ]]Block.__(5, {e}));
end end

function extension$4(loc, attrs, a) do
  return mk$4(loc, attrs, --[[ Pmod_extension ]]Block.__(6, {a}));
end end

function mk$5(locOpt, d) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  return do
          psig_desc: d,
          psig_loc: loc
        end;
end end

function extension$5(loc, attrsOpt, a) do
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  return mk$5(loc, --[[ Psig_extension ]]Block.__(12, {
                a,
                attrs
              }));
end end

function text(txt) do
  return List.map((function (ds) do
                a = text_attr(ds);
                loc = ds.ds_loc;
                return mk$5(loc, --[[ Psig_attribute ]]Block.__(11, {a}));
              end end), txt);
end end

function mk$6(locOpt, d) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  return do
          pstr_desc: d,
          pstr_loc: loc
        end;
end end

function __eval(loc, attrsOpt, a) do
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  return mk$6(loc, --[[ Pstr_eval ]]Block.__(0, {
                a,
                attrs
              }));
end end

function value(loc, a, b) do
  return mk$6(loc, --[[ Pstr_value ]]Block.__(1, {
                a,
                b
              }));
end end

function extension$6(loc, attrsOpt, a) do
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  return mk$6(loc, --[[ Pstr_extension ]]Block.__(14, {
                a,
                attrs
              }));
end end

function text$1(txt) do
  return List.map((function (ds) do
                a = text_attr(ds);
                loc = ds.ds_loc;
                return mk$6(loc, --[[ Pstr_attribute ]]Block.__(13, {a}));
              end end), txt);
end end

function mk$7(locOpt, attrsOpt, d) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  return do
          pcl_desc: d,
          pcl_loc: loc,
          pcl_attributes: attrs
        end;
end end

function attr$5(d, a) do
  return do
          pcl_desc: d.pcl_desc,
          pcl_loc: d.pcl_loc,
          pcl_attributes: Pervasives.$at(d.pcl_attributes, --[[ :: ]]{
                a,
                --[[ [] ]]0
              })
        end;
end end

function constr$1(loc, attrs, a, b) do
  return mk$7(loc, attrs, --[[ Pcl_constr ]]Block.__(0, {
                a,
                b
              }));
end end

function structure$1(loc, attrs, a) do
  return mk$7(loc, attrs, --[[ Pcl_structure ]]Block.__(1, {a}));
end end

function fun_$1(loc, attrs, a, b, c, d) do
  return mk$7(loc, attrs, --[[ Pcl_fun ]]Block.__(2, {
                a,
                b,
                c,
                d
              }));
end end

function apply$2(loc, attrs, a, b) do
  return mk$7(loc, attrs, --[[ Pcl_apply ]]Block.__(3, {
                a,
                b
              }));
end end

function let_$1(loc, attrs, a, b, c) do
  return mk$7(loc, attrs, --[[ Pcl_let ]]Block.__(4, {
                a,
                b,
                c
              }));
end end

function constraint_$3(loc, attrs, a, b) do
  return mk$7(loc, attrs, --[[ Pcl_constraint ]]Block.__(5, {
                a,
                b
              }));
end end

function extension$7(loc, attrs, a) do
  return mk$7(loc, attrs, --[[ Pcl_extension ]]Block.__(6, {a}));
end end

function mk$8(locOpt, attrsOpt, d) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  return do
          pcty_desc: d,
          pcty_loc: loc,
          pcty_attributes: attrs
        end;
end end

function attr$6(d, a) do
  return do
          pcty_desc: d.pcty_desc,
          pcty_loc: d.pcty_loc,
          pcty_attributes: Pervasives.$at(d.pcty_attributes, --[[ :: ]]{
                a,
                --[[ [] ]]0
              })
        end;
end end

function constr$2(loc, attrs, a, b) do
  return mk$8(loc, attrs, --[[ Pcty_constr ]]Block.__(0, {
                a,
                b
              }));
end end

function signature$1(loc, attrs, a) do
  return mk$8(loc, attrs, --[[ Pcty_signature ]]Block.__(1, {a}));
end end

function arrow$1(loc, attrs, a, b, c) do
  return mk$8(loc, attrs, --[[ Pcty_arrow ]]Block.__(2, {
                a,
                b,
                c
              }));
end end

function extension$8(loc, attrs, a) do
  return mk$8(loc, attrs, --[[ Pcty_extension ]]Block.__(3, {a}));
end end

function mk$9(locOpt, attrsOpt, docsOpt, d) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  return do
          pctf_desc: d,
          pctf_loc: loc,
          pctf_attributes: add_docs_attrs(docs, attrs)
        end;
end end

function inherit_(loc, attrs, a) do
  return mk$9(loc, attrs, undefined, --[[ Pctf_inherit ]]Block.__(0, {a}));
end end

function val_(loc, attrs, a, b, c, d) do
  return mk$9(loc, attrs, undefined, --[[ Pctf_val ]]Block.__(1, {--[[ tuple ]]{
                  a,
                  b,
                  c,
                  d
                }}));
end end

function method_(loc, attrs, a, b, c, d) do
  return mk$9(loc, attrs, undefined, --[[ Pctf_method ]]Block.__(2, {--[[ tuple ]]{
                  a,
                  b,
                  c,
                  d
                }}));
end end

function constraint_$4(loc, attrs, a, b) do
  return mk$9(loc, attrs, undefined, --[[ Pctf_constraint ]]Block.__(3, {--[[ tuple ]]{
                  a,
                  b
                }}));
end end

function extension$9(loc, attrs, a) do
  return mk$9(loc, attrs, undefined, --[[ Pctf_extension ]]Block.__(5, {a}));
end end

function attribute(loc, a) do
  return mk$9(loc, undefined, undefined, --[[ Pctf_attribute ]]Block.__(4, {a}));
end end

function text$2(txt) do
  return List.map((function (ds) do
                return attribute(ds.ds_loc, text_attr(ds));
              end end), txt);
end end

function attr$7(d, a) do
  return do
          pctf_desc: d.pctf_desc,
          pctf_loc: d.pctf_loc,
          pctf_attributes: Pervasives.$at(d.pctf_attributes, --[[ :: ]]{
                a,
                --[[ [] ]]0
              })
        end;
end end

function mk$10(locOpt, attrsOpt, docsOpt, d) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  return do
          pcf_desc: d,
          pcf_loc: loc,
          pcf_attributes: add_docs_attrs(docs, attrs)
        end;
end end

function inherit_$1(loc, attrs, a, b, c) do
  return mk$10(loc, attrs, undefined, --[[ Pcf_inherit ]]Block.__(0, {
                a,
                b,
                c
              }));
end end

function val_$1(loc, attrs, a, b, c) do
  return mk$10(loc, attrs, undefined, --[[ Pcf_val ]]Block.__(1, {--[[ tuple ]]{
                  a,
                  b,
                  c
                }}));
end end

function method_$1(loc, attrs, a, b, c) do
  return mk$10(loc, attrs, undefined, --[[ Pcf_method ]]Block.__(2, {--[[ tuple ]]{
                  a,
                  b,
                  c
                }}));
end end

function constraint_$5(loc, attrs, a, b) do
  return mk$10(loc, attrs, undefined, --[[ Pcf_constraint ]]Block.__(3, {--[[ tuple ]]{
                  a,
                  b
                }}));
end end

function initializer_(loc, attrs, a) do
  return mk$10(loc, attrs, undefined, --[[ Pcf_initializer ]]Block.__(4, {a}));
end end

function extension$10(loc, attrs, a) do
  return mk$10(loc, attrs, undefined, --[[ Pcf_extension ]]Block.__(6, {a}));
end end

function attribute$1(loc, a) do
  return mk$10(loc, undefined, undefined, --[[ Pcf_attribute ]]Block.__(5, {a}));
end end

function text$3(txt) do
  return List.map((function (ds) do
                return attribute$1(ds.ds_loc, text_attr(ds));
              end end), txt);
end end

function virtual_(ct) do
  return --[[ Cfk_virtual ]]Block.__(0, {ct});
end end

function concrete(o, e) do
  return --[[ Cfk_concrete ]]Block.__(1, {
            o,
            e
          });
end end

function attr$8(d, a) do
  return do
          pcf_desc: d.pcf_desc,
          pcf_loc: d.pcf_loc,
          pcf_attributes: Pervasives.$at(d.pcf_attributes, --[[ :: ]]{
                a,
                --[[ [] ]]0
              })
        end;
end end

function mk$11(locOpt, attrsOpt, docsOpt, primOpt, name, typ) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  prim = primOpt ~= undefined and primOpt or --[[ [] ]]0;
  return do
          pval_name: name,
          pval_type: typ,
          pval_prim: prim,
          pval_attributes: add_docs_attrs(docs, attrs),
          pval_loc: loc
        end;
end end

function mk$12(locOpt, attrsOpt, docsOpt, textOpt, name, typ) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  text = textOpt ~= undefined and textOpt or --[[ [] ]]0;
  return do
          pmd_name: name,
          pmd_type: typ,
          pmd_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs)),
          pmd_loc: loc
        end;
end end

function mk$13(locOpt, attrsOpt, docsOpt, textOpt, typ, name) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  text = textOpt ~= undefined and textOpt or --[[ [] ]]0;
  return do
          pmtd_name: name,
          pmtd_type: typ,
          pmtd_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs)),
          pmtd_loc: loc
        end;
end end

function mk$14(locOpt, attrsOpt, docsOpt, textOpt, name, expr) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  text = textOpt ~= undefined and textOpt or --[[ [] ]]0;
  return do
          pmb_name: name,
          pmb_expr: expr,
          pmb_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs)),
          pmb_loc: loc
        end;
end end

function mk$15(locOpt, attrsOpt, docsOpt, overrideOpt, lid) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  override = overrideOpt ~= undefined and overrideOpt or --[[ Fresh ]]1;
  return do
          popen_lid: lid,
          popen_override: override,
          popen_loc: loc,
          popen_attributes: add_docs_attrs(docs, attrs)
        end;
end end

function mk$16(locOpt, attrsOpt, docsOpt, mexpr) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  return do
          pincl_mod: mexpr,
          pincl_loc: loc,
          pincl_attributes: add_docs_attrs(docs, attrs)
        end;
end end

function mk$17(locOpt, attrsOpt, docsOpt, textOpt, pat, expr) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  text = textOpt ~= undefined and textOpt or --[[ [] ]]0;
  return do
          pvb_pat: pat,
          pvb_expr: expr,
          pvb_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs)),
          pvb_loc: loc
        end;
end end

function mk$18(locOpt, attrsOpt, docsOpt, textOpt, virtOpt, paramsOpt, name, expr) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  text = textOpt ~= undefined and textOpt or --[[ [] ]]0;
  virt = virtOpt ~= undefined and virtOpt or --[[ Concrete ]]1;
  params = paramsOpt ~= undefined and paramsOpt or --[[ [] ]]0;
  return do
          pci_virt: virt,
          pci_params: params,
          pci_name: name,
          pci_expr: expr,
          pci_loc: loc,
          pci_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs))
        end;
end end

function mk$19(locOpt, attrsOpt, docsOpt, textOpt, paramsOpt, cstrsOpt, kindOpt, privOpt, manifest, name) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  text = textOpt ~= undefined and textOpt or --[[ [] ]]0;
  params = paramsOpt ~= undefined and paramsOpt or --[[ [] ]]0;
  cstrs = cstrsOpt ~= undefined and cstrsOpt or --[[ [] ]]0;
  kind = kindOpt ~= undefined and kindOpt or --[[ Ptype_abstract ]]0;
  priv = privOpt ~= undefined and privOpt or --[[ Public ]]1;
  return do
          ptype_name: name,
          ptype_params: params,
          ptype_cstrs: cstrs,
          ptype_kind: kind,
          ptype_private: priv,
          ptype_manifest: manifest,
          ptype_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs)),
          ptype_loc: loc
        end;
end end

function constructor(locOpt, attrsOpt, infoOpt, argsOpt, res, name) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  info = infoOpt ~= undefined and Caml_option.valFromOption(infoOpt) or undefined;
  args = argsOpt ~= undefined and argsOpt or --[[ [] ]]0;
  return do
          pcd_name: name,
          pcd_args: args,
          pcd_res: res,
          pcd_loc: loc,
          pcd_attributes: add_info_attrs(info, attrs)
        end;
end end

function field$1(locOpt, attrsOpt, infoOpt, mutOpt, name, typ) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  info = infoOpt ~= undefined and Caml_option.valFromOption(infoOpt) or undefined;
  mut = mutOpt ~= undefined and mutOpt or --[[ Immutable ]]0;
  return do
          pld_name: name,
          pld_mutable: mut,
          pld_type: typ,
          pld_loc: loc,
          pld_attributes: add_info_attrs(info, attrs)
        end;
end end

function mk$20(attrsOpt, docsOpt, paramsOpt, privOpt, path, constructors) do
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  params = paramsOpt ~= undefined and paramsOpt or --[[ [] ]]0;
  priv = privOpt ~= undefined and privOpt or --[[ Public ]]1;
  return do
          ptyext_path: path,
          ptyext_params: params,
          ptyext_constructors: constructors,
          ptyext_private: priv,
          ptyext_attributes: add_docs_attrs(docs, attrs)
        end;
end end

function constructor$1(locOpt, attrsOpt, docsOpt, infoOpt, name, kind) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  info = infoOpt ~= undefined and Caml_option.valFromOption(infoOpt) or undefined;
  return do
          pext_name: name,
          pext_kind: kind,
          pext_loc: loc,
          pext_attributes: add_docs_attrs(docs, add_info_attrs(info, attrs))
        end;
end end

function decl(locOpt, attrsOpt, docsOpt, infoOpt, argsOpt, res, name) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  info = infoOpt ~= undefined and Caml_option.valFromOption(infoOpt) or undefined;
  args = argsOpt ~= undefined and argsOpt or --[[ [] ]]0;
  return do
          pext_name: name,
          pext_kind: --[[ Pext_decl ]]Block.__(0, {
              args,
              res
            }),
          pext_loc: loc,
          pext_attributes: add_docs_attrs(docs, add_info_attrs(info, attrs))
        end;
end end

function rebind(locOpt, attrsOpt, docsOpt, infoOpt, name, lid) do
  loc = locOpt ~= undefined and locOpt or default_loc.contents;
  attrs = attrsOpt ~= undefined and attrsOpt or --[[ [] ]]0;
  docs = docsOpt ~= undefined and docsOpt or empty_docs;
  info = infoOpt ~= undefined and Caml_option.valFromOption(infoOpt) or undefined;
  return do
          pext_name: name,
          pext_kind: --[[ Pext_rebind ]]Block.__(1, {lid}),
          pext_loc: loc,
          pext_attributes: add_docs_attrs(docs, add_info_attrs(info, attrs))
        end;
end end

Ast_helper_Exp = do
  mk: mk$2,
  attr: attr$2,
  ident: ident,
  constant: constant$1,
  let_: let_,
  fun_: fun_,
  function_: function_,
  apply: apply,
  match_: match_,
  try_: try_,
  tuple: tuple$2,
  construct: construct$1,
  variant: variant$2,
  record: record$1,
  field: field,
  setfield: setfield,
  array: array$1,
  ifthenelse: ifthenelse,
  sequence: sequence,
  while_: while_,
  for_: for_,
  coerce: coerce,
  constraint_: constraint_$1,
  send: send,
  new_: new_,
  setinstvar: setinstvar,
  override: override,
  letmodule: letmodule,
  assert_: assert_,
  lazy_: lazy_$1,
  poly: poly$1,
  object_: object_$1,
  newtype: newtype,
  pack: pack,
  open_: open_,
  extension: extension$2,
  __case: __case
end;

Ast_helper_Ctf = do
  mk: mk$9,
  attr: attr$7,
  inherit_: inherit_,
  val_: val_,
  method_: method_,
  constraint_: constraint_$4,
  extension: extension$9,
  attribute: attribute,
  text: text$2
end;

Ast_helper_Cf = do
  mk: mk$10,
  attr: attr$8,
  inherit_: inherit_$1,
  val_: val_$1,
  method_: method_$1,
  constraint_: constraint_$5,
  initializer_: initializer_,
  extension: extension$10,
  attribute: attribute$1,
  text: text$3,
  virtual_: virtual_,
  concrete: concrete
end;

function map_fst(f, param) do
  return --[[ tuple ]]{
          Curry._1(f, param[0]),
          param[1]
        };
end end

function map_snd(f, param) do
  return --[[ tuple ]]{
          param[0],
          Curry._1(f, param[1])
        };
end end

function map_tuple(f1, f2, param) do
  return --[[ tuple ]]{
          Curry._1(f1, param[0]),
          Curry._1(f2, param[1])
        };
end end

function map_opt(f, param) do
  if (param ~= undefined) then do
    return Caml_option.some(Curry._1(f, Caml_option.valFromOption(param)));
  end
   end 
end end

function map_loc(sub, param) do
  return do
          txt: param.txt,
          loc: Curry._2(sub.location, sub, param.loc)
        end;
end end

function map$1(sub, param) do
  desc = param.ptyp_desc;
  loc = Curry._2(sub.location, sub, param.ptyp_loc);
  attrs = Curry._2(sub.attributes, sub, param.ptyp_attributes);
  if (typeof desc == "number") then do
    return mk(loc, attrs, --[[ Ptyp_any ]]0);
  end else do
    local ___conditional___=(desc.tag | 0);
    do
       if ___conditional___ = 0--[[ Ptyp_var ]] then do
          return __var(loc, attrs, desc[0]);end end end 
       if ___conditional___ = 1--[[ Ptyp_arrow ]] then do
          return arrow(loc, attrs, desc[0], Curry._2(sub.typ, sub, desc[1]), Curry._2(sub.typ, sub, desc[2]));end end end 
       if ___conditional___ = 2--[[ Ptyp_tuple ]] then do
          return tuple(loc, attrs, List.map(Curry._1(sub.typ, sub), desc[0]));end end end 
       if ___conditional___ = 3--[[ Ptyp_constr ]] then do
          return constr(loc, attrs, map_loc(sub, desc[0]), List.map(Curry._1(sub.typ, sub), desc[1]));end end end 
       if ___conditional___ = 4--[[ Ptyp_object ]] then do
          f = function (param) do
            return --[[ tuple ]]{
                    param[0],
                    Curry._2(sub.attributes, sub, param[1]),
                    Curry._2(sub.typ, sub, param[2])
                  };
          end end;
          return object_(loc, attrs, List.map(f, desc[0]), desc[1]);end end end 
       if ___conditional___ = 5--[[ Ptyp_class ]] then do
          return class_(loc, attrs, map_loc(sub, desc[0]), List.map(Curry._1(sub.typ, sub), desc[1]));end end end 
       if ___conditional___ = 6--[[ Ptyp_alias ]] then do
          return alias(loc, attrs, Curry._2(sub.typ, sub, desc[0]), desc[1]);end end end 
       if ___conditional___ = 7--[[ Ptyp_variant ]] then do
          return variant(loc, attrs, List.map((function (param) do
                            sub$1 = sub;
                            param$1 = param;
                            if (param$1.tag) then do
                              return --[[ Rinherit ]]Block.__(1, {Curry._2(sub$1.typ, sub$1, param$1[0])});
                            end else do
                              return --[[ Rtag ]]Block.__(0, {
                                        param$1[0],
                                        Curry._2(sub$1.attributes, sub$1, param$1[1]),
                                        param$1[2],
                                        List.map(Curry._1(sub$1.typ, sub$1), param$1[3])
                                      });
                            end end 
                          end end), desc[0]), desc[1], desc[2]);end end end 
       if ___conditional___ = 8--[[ Ptyp_poly ]] then do
          return poly(loc, attrs, desc[0], Curry._2(sub.typ, sub, desc[1]));end end end 
       if ___conditional___ = 9--[[ Ptyp_package ]] then do
          match = desc[0];
          partial_arg = Curry._1(sub.typ, sub);
          return __package(loc, attrs, map_loc(sub, match[0]), List.map((function (param) do
                            return map_tuple((function (param) do
                                          return map_loc(sub, param);
                                        end end), partial_arg, param);
                          end end), match[1]));end end end 
       if ___conditional___ = 10--[[ Ptyp_extension ]] then do
          return extension(loc, attrs, Curry._2(sub.extension, sub, desc[0]));end end end 
       do
      
    end
  end end 
end end

function map_type_declaration(sub, param) do
  partial_arg = Curry._1(sub.typ, sub);
  partial_arg$1 = Curry._1(sub.location, sub);
  partial_arg$2 = Curry._1(sub.typ, sub);
  partial_arg$3 = Curry._1(sub.typ, sub);
  return mk$19(Curry._2(sub.location, sub, param.ptype_loc), Curry._2(sub.attributes, sub, param.ptype_attributes), undefined, undefined, List.map((function (param) do
                    return map_fst(partial_arg, param);
                  end end), param.ptype_params), List.map((function (param) do
                    f1 = partial_arg$3;
                    f2 = partial_arg$2;
                    f3 = partial_arg$1;
                    param$1 = param;
                    return --[[ tuple ]]{
                            Curry._1(f1, param$1[0]),
                            Curry._1(f2, param$1[1]),
                            Curry._1(f3, param$1[2])
                          };
                  end end), param.ptype_cstrs), Curry._2(sub.type_kind, sub, param.ptype_kind), param.ptype_private, map_opt(Curry._1(sub.typ, sub), param.ptype_manifest), map_loc(sub, param.ptype_name));
end end

function map_type_kind(sub, param) do
  if (typeof param == "number") then do
    if (param == --[[ Ptype_abstract ]]0) then do
      return --[[ Ptype_abstract ]]0;
    end else do
      return --[[ Ptype_open ]]1;
    end end 
  end else if (param.tag) then do
    return --[[ Ptype_record ]]Block.__(1, {List.map(Curry._1(sub.label_declaration, sub), param[0])});
  end else do
    return --[[ Ptype_variant ]]Block.__(0, {List.map(Curry._1(sub.constructor_declaration, sub), param[0])});
  end end  end 
end end

function map_type_extension(sub, param) do
  partial_arg = Curry._1(sub.typ, sub);
  return mk$20(Curry._2(sub.attributes, sub, param.ptyext_attributes), undefined, List.map((function (param) do
                    return map_fst(partial_arg, param);
                  end end), param.ptyext_params), param.ptyext_private, map_loc(sub, param.ptyext_path), List.map(Curry._1(sub.extension_constructor, sub), param.ptyext_constructors));
end end

function map_extension_constructor_kind(sub, param) do
  if (param.tag) then do
    return --[[ Pext_rebind ]]Block.__(1, {map_loc(sub, param[0])});
  end else do
    return --[[ Pext_decl ]]Block.__(0, {
              List.map(Curry._1(sub.typ, sub), param[0]),
              map_opt(Curry._1(sub.typ, sub), param[1])
            });
  end end 
end end

function map_extension_constructor(sub, param) do
  return constructor$1(Curry._2(sub.location, sub, param.pext_loc), Curry._2(sub.attributes, sub, param.pext_attributes), undefined, undefined, map_loc(sub, param.pext_name), map_extension_constructor_kind(sub, param.pext_kind));
end end

function map$2(sub, param) do
  desc = param.pcty_desc;
  loc = Curry._2(sub.location, sub, param.pcty_loc);
  attrs = Curry._2(sub.attributes, sub, param.pcty_attributes);
  local ___conditional___=(desc.tag | 0);
  do
     if ___conditional___ = 0--[[ Pcty_constr ]] then do
        return constr$2(loc, attrs, map_loc(sub, desc[0]), List.map(Curry._1(sub.typ, sub), desc[1]));end end end 
     if ___conditional___ = 1--[[ Pcty_signature ]] then do
        return signature$1(loc, attrs, Curry._2(sub.class_signature, sub, desc[0]));end end end 
     if ___conditional___ = 2--[[ Pcty_arrow ]] then do
        return arrow$1(loc, attrs, desc[0], Curry._2(sub.typ, sub, desc[1]), Curry._2(sub.class_type, sub, desc[2]));end end end 
     if ___conditional___ = 3--[[ Pcty_extension ]] then do
        return extension$8(loc, attrs, Curry._2(sub.extension, sub, desc[0]));end end end 
     do
    
  end
end end

function map_field(sub, param) do
  desc = param.pctf_desc;
  loc = Curry._2(sub.location, sub, param.pctf_loc);
  attrs = Curry._2(sub.attributes, sub, param.pctf_attributes);
  local ___conditional___=(desc.tag | 0);
  do
     if ___conditional___ = 0--[[ Pctf_inherit ]] then do
        return Curry._3(Ast_helper_Ctf.inherit_, loc, attrs, Curry._2(sub.class_type, sub, desc[0]));end end end 
     if ___conditional___ = 1--[[ Pctf_val ]] then do
        match = desc[0];
        return Curry._6(Ast_helper_Ctf.val_, loc, attrs, match[0], match[1], match[2], Curry._2(sub.typ, sub, match[3]));end end end 
     if ___conditional___ = 2--[[ Pctf_method ]] then do
        match$1 = desc[0];
        return Curry._6(Ast_helper_Ctf.method_, loc, attrs, match$1[0], match$1[1], match$1[2], Curry._2(sub.typ, sub, match$1[3]));end end end 
     if ___conditional___ = 3--[[ Pctf_constraint ]] then do
        match$2 = desc[0];
        return Curry._4(Ast_helper_Ctf.constraint_, loc, attrs, Curry._2(sub.typ, sub, match$2[0]), Curry._2(sub.typ, sub, match$2[1]));end end end 
     if ___conditional___ = 4--[[ Pctf_attribute ]] then do
        return Curry._2(Ast_helper_Ctf.attribute, loc, Curry._2(sub.attribute, sub, desc[0]));end end end 
     if ___conditional___ = 5--[[ Pctf_extension ]] then do
        return Curry._3(Ast_helper_Ctf.extension, loc, attrs, Curry._2(sub.extension, sub, desc[0]));end end end 
     do
    
  end
end end

function map_signature(sub, param) do
  return do
          pcsig_self: Curry._2(sub.typ, sub, param.pcsig_self),
          pcsig_fields: List.map(Curry._1(sub.class_type_field, sub), param.pcsig_fields)
        end;
end end

function map$3(sub, param) do
  desc = param.pmty_desc;
  loc = Curry._2(sub.location, sub, param.pmty_loc);
  attrs = Curry._2(sub.attributes, sub, param.pmty_attributes);
  local ___conditional___=(desc.tag | 0);
  do
     if ___conditional___ = 0--[[ Pmty_ident ]] then do
        return ident$1(loc, attrs, map_loc(sub, desc[0]));end end end 
     if ___conditional___ = 1--[[ Pmty_signature ]] then do
        return signature(loc, attrs, Curry._2(sub.signature, sub, desc[0]));end end end 
     if ___conditional___ = 2--[[ Pmty_functor ]] then do
        return functor_(loc, attrs, map_loc(sub, desc[0]), may_map(Curry._1(sub.module_type, sub), desc[1]), Curry._2(sub.module_type, sub, desc[2]));end end end 
     if ___conditional___ = 3--[[ Pmty_with ]] then do
        return with_(loc, attrs, Curry._2(sub.module_type, sub, desc[0]), List.map(Curry._1(sub.with_constraint, sub), desc[1]));end end end 
     if ___conditional___ = 4--[[ Pmty_typeof ]] then do
        return typeof_(loc, attrs, Curry._2(sub.module_expr, sub, desc[0]));end end end 
     if ___conditional___ = 5--[[ Pmty_extension ]] then do
        return extension$3(loc, attrs, Curry._2(sub.extension, sub, desc[0]));end end end 
     if ___conditional___ = 6--[[ Pmty_alias ]] then do
        return alias$2(loc, attrs, map_loc(sub, desc[0]));end end end 
     do
    
  end
end end

function map_with_constraint(sub, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Pwith_type ]] then do
        return --[[ Pwith_type ]]Block.__(0, {
                  map_loc(sub, param[0]),
                  Curry._2(sub.type_declaration, sub, param[1])
                });end end end 
     if ___conditional___ = 1--[[ Pwith_module ]] then do
        return --[[ Pwith_module ]]Block.__(1, {
                  map_loc(sub, param[0]),
                  map_loc(sub, param[1])
                });end end end 
     if ___conditional___ = 2--[[ Pwith_typesubst ]] then do
        return --[[ Pwith_typesubst ]]Block.__(2, {Curry._2(sub.type_declaration, sub, param[0])});end end end 
     if ___conditional___ = 3--[[ Pwith_modsubst ]] then do
        return --[[ Pwith_modsubst ]]Block.__(3, {
                  map_loc(sub, param[0]),
                  map_loc(sub, param[1])
                });end end end 
     do
    
  end
end end

function map_signature_item(sub, param) do
  desc = param.psig_desc;
  loc = Curry._2(sub.location, sub, param.psig_loc);
  local ___conditional___=(desc.tag | 0);
  do
     if ___conditional___ = 0--[[ Psig_value ]] then do
        a = Curry._2(sub.value_description, sub, desc[0]);
        return mk$5(loc, --[[ Psig_value ]]Block.__(0, {a}));end end end 
     if ___conditional___ = 1--[[ Psig_type ]] then do
        a$1 = List.map(Curry._1(sub.type_declaration, sub), desc[0]);
        return mk$5(loc, --[[ Psig_type ]]Block.__(1, {a$1}));end end end 
     if ___conditional___ = 2--[[ Psig_typext ]] then do
        a$2 = Curry._2(sub.type_extension, sub, desc[0]);
        return mk$5(loc, --[[ Psig_typext ]]Block.__(2, {a$2}));end end end 
     if ___conditional___ = 3--[[ Psig_exception ]] then do
        a$3 = Curry._2(sub.extension_constructor, sub, desc[0]);
        return mk$5(loc, --[[ Psig_exception ]]Block.__(3, {a$3}));end end end 
     if ___conditional___ = 4--[[ Psig_module ]] then do
        a$4 = Curry._2(sub.module_declaration, sub, desc[0]);
        return mk$5(loc, --[[ Psig_module ]]Block.__(4, {a$4}));end end end 
     if ___conditional___ = 5--[[ Psig_recmodule ]] then do
        a$5 = List.map(Curry._1(sub.module_declaration, sub), desc[0]);
        return mk$5(loc, --[[ Psig_recmodule ]]Block.__(5, {a$5}));end end end 
     if ___conditional___ = 6--[[ Psig_modtype ]] then do
        a$6 = Curry._2(sub.module_type_declaration, sub, desc[0]);
        return mk$5(loc, --[[ Psig_modtype ]]Block.__(6, {a$6}));end end end 
     if ___conditional___ = 7--[[ Psig_open ]] then do
        a$7 = Curry._2(sub.open_description, sub, desc[0]);
        return mk$5(loc, --[[ Psig_open ]]Block.__(7, {a$7}));end end end 
     if ___conditional___ = 8--[[ Psig_include ]] then do
        a$8 = Curry._2(sub.include_description, sub, desc[0]);
        return mk$5(loc, --[[ Psig_include ]]Block.__(8, {a$8}));end end end 
     if ___conditional___ = 9--[[ Psig_class ]] then do
        a$9 = List.map(Curry._1(sub.class_description, sub), desc[0]);
        return mk$5(loc, --[[ Psig_class ]]Block.__(9, {a$9}));end end end 
     if ___conditional___ = 10--[[ Psig_class_type ]] then do
        a$10 = List.map(Curry._1(sub.class_type_declaration, sub), desc[0]);
        return mk$5(loc, --[[ Psig_class_type ]]Block.__(10, {a$10}));end end end 
     if ___conditional___ = 11--[[ Psig_attribute ]] then do
        a$11 = Curry._2(sub.attribute, sub, desc[0]);
        return mk$5(loc, --[[ Psig_attribute ]]Block.__(11, {a$11}));end end end 
     if ___conditional___ = 12--[[ Psig_extension ]] then do
        return extension$5(loc, Curry._2(sub.attributes, sub, desc[1]), Curry._2(sub.extension, sub, desc[0]));end end end 
     do
    
  end
end end

function map$4(sub, param) do
  desc = param.pmod_desc;
  loc = Curry._2(sub.location, sub, param.pmod_loc);
  attrs = Curry._2(sub.attributes, sub, param.pmod_attributes);
  local ___conditional___=(desc.tag | 0);
  do
     if ___conditional___ = 0--[[ Pmod_ident ]] then do
        return ident$2(loc, attrs, map_loc(sub, desc[0]));end end end 
     if ___conditional___ = 1--[[ Pmod_structure ]] then do
        return structure(loc, attrs, Curry._2(sub.structure, sub, desc[0]));end end end 
     if ___conditional___ = 2--[[ Pmod_functor ]] then do
        return functor_$1(loc, attrs, map_loc(sub, desc[0]), may_map(Curry._1(sub.module_type, sub), desc[1]), Curry._2(sub.module_expr, sub, desc[2]));end end end 
     if ___conditional___ = 3--[[ Pmod_apply ]] then do
        return apply$1(loc, attrs, Curry._2(sub.module_expr, sub, desc[0]), Curry._2(sub.module_expr, sub, desc[1]));end end end 
     if ___conditional___ = 4--[[ Pmod_constraint ]] then do
        return constraint_$2(loc, attrs, Curry._2(sub.module_expr, sub, desc[0]), Curry._2(sub.module_type, sub, desc[1]));end end end 
     if ___conditional___ = 5--[[ Pmod_unpack ]] then do
        return unpack$1(loc, attrs, Curry._2(sub.expr, sub, desc[0]));end end end 
     if ___conditional___ = 6--[[ Pmod_extension ]] then do
        return extension$4(loc, attrs, Curry._2(sub.extension, sub, desc[0]));end end end 
     do
    
  end
end end

function map_structure_item(sub, param) do
  desc = param.pstr_desc;
  loc = Curry._2(sub.location, sub, param.pstr_loc);
  local ___conditional___=(desc.tag | 0);
  do
     if ___conditional___ = 0--[[ Pstr_eval ]] then do
        return __eval(loc, Curry._2(sub.attributes, sub, desc[1]), Curry._2(sub.expr, sub, desc[0]));end end end 
     if ___conditional___ = 1--[[ Pstr_value ]] then do
        return value(loc, desc[0], List.map(Curry._1(sub.value_binding, sub), desc[1]));end end end 
     if ___conditional___ = 2--[[ Pstr_primitive ]] then do
        a = Curry._2(sub.value_description, sub, desc[0]);
        return mk$6(loc, --[[ Pstr_primitive ]]Block.__(2, {a}));end end end 
     if ___conditional___ = 3--[[ Pstr_type ]] then do
        a$1 = List.map(Curry._1(sub.type_declaration, sub), desc[0]);
        return mk$6(loc, --[[ Pstr_type ]]Block.__(3, {a$1}));end end end 
     if ___conditional___ = 4--[[ Pstr_typext ]] then do
        a$2 = Curry._2(sub.type_extension, sub, desc[0]);
        return mk$6(loc, --[[ Pstr_typext ]]Block.__(4, {a$2}));end end end 
     if ___conditional___ = 5--[[ Pstr_exception ]] then do
        a$3 = Curry._2(sub.extension_constructor, sub, desc[0]);
        return mk$6(loc, --[[ Pstr_exception ]]Block.__(5, {a$3}));end end end 
     if ___conditional___ = 6--[[ Pstr_module ]] then do
        a$4 = Curry._2(sub.module_binding, sub, desc[0]);
        return mk$6(loc, --[[ Pstr_module ]]Block.__(6, {a$4}));end end end 
     if ___conditional___ = 7--[[ Pstr_recmodule ]] then do
        a$5 = List.map(Curry._1(sub.module_binding, sub), desc[0]);
        return mk$6(loc, --[[ Pstr_recmodule ]]Block.__(7, {a$5}));end end end 
     if ___conditional___ = 8--[[ Pstr_modtype ]] then do
        a$6 = Curry._2(sub.module_type_declaration, sub, desc[0]);
        return mk$6(loc, --[[ Pstr_modtype ]]Block.__(8, {a$6}));end end end 
     if ___conditional___ = 9--[[ Pstr_open ]] then do
        a$7 = Curry._2(sub.open_description, sub, desc[0]);
        return mk$6(loc, --[[ Pstr_open ]]Block.__(9, {a$7}));end end end 
     if ___conditional___ = 10--[[ Pstr_class ]] then do
        a$8 = List.map(Curry._1(sub.class_declaration, sub), desc[0]);
        return mk$6(loc, --[[ Pstr_class ]]Block.__(10, {a$8}));end end end 
     if ___conditional___ = 11--[[ Pstr_class_type ]] then do
        a$9 = List.map(Curry._1(sub.class_type_declaration, sub), desc[0]);
        return mk$6(loc, --[[ Pstr_class_type ]]Block.__(11, {a$9}));end end end 
     if ___conditional___ = 12--[[ Pstr_include ]] then do
        a$10 = Curry._2(sub.include_declaration, sub, desc[0]);
        return mk$6(loc, --[[ Pstr_include ]]Block.__(12, {a$10}));end end end 
     if ___conditional___ = 13--[[ Pstr_attribute ]] then do
        a$11 = Curry._2(sub.attribute, sub, desc[0]);
        return mk$6(loc, --[[ Pstr_attribute ]]Block.__(13, {a$11}));end end end 
     if ___conditional___ = 14--[[ Pstr_extension ]] then do
        return extension$6(loc, Curry._2(sub.attributes, sub, desc[1]), Curry._2(sub.extension, sub, desc[0]));end end end 
     do
    
  end
end end

function map$5(sub, param) do
  desc = param.pexp_desc;
  loc = Curry._2(sub.location, sub, param.pexp_loc);
  attrs = Curry._2(sub.attributes, sub, param.pexp_attributes);
  local ___conditional___=(desc.tag | 0);
  do
     if ___conditional___ = 0--[[ Pexp_ident ]] then do
        return Curry._3(Ast_helper_Exp.ident, loc, attrs, map_loc(sub, desc[0]));end end end 
     if ___conditional___ = 1--[[ Pexp_constant ]] then do
        return Curry._3(Ast_helper_Exp.constant, loc, attrs, desc[0]);end end end 
     if ___conditional___ = 2--[[ Pexp_let ]] then do
        return Curry._5(Ast_helper_Exp.let_, loc, attrs, desc[0], List.map(Curry._1(sub.value_binding, sub), desc[1]), Curry._2(sub.expr, sub, desc[2]));end end end 
     if ___conditional___ = 3--[[ Pexp_function ]] then do
        return Curry._3(Ast_helper_Exp.function_, loc, attrs, Curry._2(sub.cases, sub, desc[0]));end end end 
     if ___conditional___ = 4--[[ Pexp_fun ]] then do
        return Curry._6(Ast_helper_Exp.fun_, loc, attrs, desc[0], map_opt(Curry._1(sub.expr, sub), desc[1]), Curry._2(sub.pat, sub, desc[2]), Curry._2(sub.expr, sub, desc[3]));end end end 
     if ___conditional___ = 5--[[ Pexp_apply ]] then do
        partial_arg = Curry._1(sub.expr, sub);
        return Curry._4(Ast_helper_Exp.apply, loc, attrs, Curry._2(sub.expr, sub, desc[0]), List.map((function (param) do
                          return map_snd(partial_arg, param);
                        end end), desc[1]));end end end 
     if ___conditional___ = 6--[[ Pexp_match ]] then do
        return Curry._4(Ast_helper_Exp.match_, loc, attrs, Curry._2(sub.expr, sub, desc[0]), Curry._2(sub.cases, sub, desc[1]));end end end 
     if ___conditional___ = 7--[[ Pexp_try ]] then do
        return Curry._4(Ast_helper_Exp.try_, loc, attrs, Curry._2(sub.expr, sub, desc[0]), Curry._2(sub.cases, sub, desc[1]));end end end 
     if ___conditional___ = 8--[[ Pexp_tuple ]] then do
        return Curry._3(Ast_helper_Exp.tuple, loc, attrs, List.map(Curry._1(sub.expr, sub), desc[0]));end end end 
     if ___conditional___ = 9--[[ Pexp_construct ]] then do
        return Curry._4(Ast_helper_Exp.construct, loc, attrs, map_loc(sub, desc[0]), map_opt(Curry._1(sub.expr, sub), desc[1]));end end end 
     if ___conditional___ = 10--[[ Pexp_variant ]] then do
        return Curry._4(Ast_helper_Exp.variant, loc, attrs, desc[0], map_opt(Curry._1(sub.expr, sub), desc[1]));end end end 
     if ___conditional___ = 11--[[ Pexp_record ]] then do
        partial_arg$1 = Curry._1(sub.expr, sub);
        return Curry._4(Ast_helper_Exp.record, loc, attrs, List.map((function (param) do
                          return map_tuple((function (param) do
                                        return map_loc(sub, param);
                                      end end), partial_arg$1, param);
                        end end), desc[0]), map_opt(Curry._1(sub.expr, sub), desc[1]));end end end 
     if ___conditional___ = 12--[[ Pexp_field ]] then do
        return Curry._4(Ast_helper_Exp.field, loc, attrs, Curry._2(sub.expr, sub, desc[0]), map_loc(sub, desc[1]));end end end 
     if ___conditional___ = 13--[[ Pexp_setfield ]] then do
        return Curry._5(Ast_helper_Exp.setfield, loc, attrs, Curry._2(sub.expr, sub, desc[0]), map_loc(sub, desc[1]), Curry._2(sub.expr, sub, desc[2]));end end end 
     if ___conditional___ = 14--[[ Pexp_array ]] then do
        return Curry._3(Ast_helper_Exp.array, loc, attrs, List.map(Curry._1(sub.expr, sub), desc[0]));end end end 
     if ___conditional___ = 15--[[ Pexp_ifthenelse ]] then do
        return Curry._5(Ast_helper_Exp.ifthenelse, loc, attrs, Curry._2(sub.expr, sub, desc[0]), Curry._2(sub.expr, sub, desc[1]), map_opt(Curry._1(sub.expr, sub), desc[2]));end end end 
     if ___conditional___ = 16--[[ Pexp_sequence ]] then do
        return Curry._4(Ast_helper_Exp.sequence, loc, attrs, Curry._2(sub.expr, sub, desc[0]), Curry._2(sub.expr, sub, desc[1]));end end end 
     if ___conditional___ = 17--[[ Pexp_while ]] then do
        return Curry._4(Ast_helper_Exp.while_, loc, attrs, Curry._2(sub.expr, sub, desc[0]), Curry._2(sub.expr, sub, desc[1]));end end end 
     if ___conditional___ = 18--[[ Pexp_for ]] then do
        return Curry._7(Ast_helper_Exp.for_, loc, attrs, Curry._2(sub.pat, sub, desc[0]), Curry._2(sub.expr, sub, desc[1]), Curry._2(sub.expr, sub, desc[2]), desc[3], Curry._2(sub.expr, sub, desc[4]));end end end 
     if ___conditional___ = 19--[[ Pexp_constraint ]] then do
        return Curry._4(Ast_helper_Exp.constraint_, loc, attrs, Curry._2(sub.expr, sub, desc[0]), Curry._2(sub.typ, sub, desc[1]));end end end 
     if ___conditional___ = 20--[[ Pexp_coerce ]] then do
        return Curry._5(Ast_helper_Exp.coerce, loc, attrs, Curry._2(sub.expr, sub, desc[0]), map_opt(Curry._1(sub.typ, sub), desc[1]), Curry._2(sub.typ, sub, desc[2]));end end end 
     if ___conditional___ = 21--[[ Pexp_send ]] then do
        return Curry._4(Ast_helper_Exp.send, loc, attrs, Curry._2(sub.expr, sub, desc[0]), desc[1]);end end end 
     if ___conditional___ = 22--[[ Pexp_new ]] then do
        return Curry._3(Ast_helper_Exp.new_, loc, attrs, map_loc(sub, desc[0]));end end end 
     if ___conditional___ = 23--[[ Pexp_setinstvar ]] then do
        return Curry._4(Ast_helper_Exp.setinstvar, loc, attrs, map_loc(sub, desc[0]), Curry._2(sub.expr, sub, desc[1]));end end end 
     if ___conditional___ = 24--[[ Pexp_override ]] then do
        partial_arg$2 = Curry._1(sub.expr, sub);
        return Curry._3(Ast_helper_Exp.override, loc, attrs, List.map((function (param) do
                          return map_tuple((function (param) do
                                        return map_loc(sub, param);
                                      end end), partial_arg$2, param);
                        end end), desc[0]));end end end 
     if ___conditional___ = 25--[[ Pexp_letmodule ]] then do
        return Curry._5(Ast_helper_Exp.letmodule, loc, attrs, map_loc(sub, desc[0]), Curry._2(sub.module_expr, sub, desc[1]), Curry._2(sub.expr, sub, desc[2]));end end end 
     if ___conditional___ = 26--[[ Pexp_assert ]] then do
        return Curry._3(Ast_helper_Exp.assert_, loc, attrs, Curry._2(sub.expr, sub, desc[0]));end end end 
     if ___conditional___ = 27--[[ Pexp_lazy ]] then do
        return Curry._3(Ast_helper_Exp.lazy_, loc, attrs, Curry._2(sub.expr, sub, desc[0]));end end end 
     if ___conditional___ = 28--[[ Pexp_poly ]] then do
        return Curry._4(Ast_helper_Exp.poly, loc, attrs, Curry._2(sub.expr, sub, desc[0]), map_opt(Curry._1(sub.typ, sub), desc[1]));end end end 
     if ___conditional___ = 29--[[ Pexp_object ]] then do
        return Curry._3(Ast_helper_Exp.object_, loc, attrs, Curry._2(sub.class_structure, sub, desc[0]));end end end 
     if ___conditional___ = 30--[[ Pexp_newtype ]] then do
        return Curry._4(Ast_helper_Exp.newtype, loc, attrs, desc[0], Curry._2(sub.expr, sub, desc[1]));end end end 
     if ___conditional___ = 31--[[ Pexp_pack ]] then do
        return Curry._3(Ast_helper_Exp.pack, loc, attrs, Curry._2(sub.module_expr, sub, desc[0]));end end end 
     if ___conditional___ = 32--[[ Pexp_open ]] then do
        return Curry._5(Ast_helper_Exp.open_, loc, attrs, desc[0], map_loc(sub, desc[1]), Curry._2(sub.expr, sub, desc[2]));end end end 
     if ___conditional___ = 33--[[ Pexp_extension ]] then do
        return Curry._3(Ast_helper_Exp.extension, loc, attrs, Curry._2(sub.extension, sub, desc[0]));end end end 
     do
    
  end
end end

function map$6(sub, param) do
  desc = param.ppat_desc;
  loc = Curry._2(sub.location, sub, param.ppat_loc);
  attrs = Curry._2(sub.attributes, sub, param.ppat_attributes);
  if (typeof desc == "number") then do
    return mk$1(loc, attrs, --[[ Ppat_any ]]0);
  end else do
    local ___conditional___=(desc.tag | 0);
    do
       if ___conditional___ = 0--[[ Ppat_var ]] then do
          return __var$1(loc, attrs, map_loc(sub, desc[0]));end end end 
       if ___conditional___ = 1--[[ Ppat_alias ]] then do
          return alias$1(loc, attrs, Curry._2(sub.pat, sub, desc[0]), map_loc(sub, desc[1]));end end end 
       if ___conditional___ = 2--[[ Ppat_constant ]] then do
          return constant(loc, attrs, desc[0]);end end end 
       if ___conditional___ = 3--[[ Ppat_interval ]] then do
          return interval(loc, attrs, desc[0], desc[1]);end end end 
       if ___conditional___ = 4--[[ Ppat_tuple ]] then do
          return tuple$1(loc, attrs, List.map(Curry._1(sub.pat, sub), desc[0]));end end end 
       if ___conditional___ = 5--[[ Ppat_construct ]] then do
          return construct(loc, attrs, map_loc(sub, desc[0]), map_opt(Curry._1(sub.pat, sub), desc[1]));end end end 
       if ___conditional___ = 6--[[ Ppat_variant ]] then do
          return variant$1(loc, attrs, desc[0], map_opt(Curry._1(sub.pat, sub), desc[1]));end end end 
       if ___conditional___ = 7--[[ Ppat_record ]] then do
          partial_arg = Curry._1(sub.pat, sub);
          return record(loc, attrs, List.map((function (param) do
                            return map_tuple((function (param) do
                                          return map_loc(sub, param);
                                        end end), partial_arg, param);
                          end end), desc[0]), desc[1]);end end end 
       if ___conditional___ = 8--[[ Ppat_array ]] then do
          return array(loc, attrs, List.map(Curry._1(sub.pat, sub), desc[0]));end end end 
       if ___conditional___ = 9--[[ Ppat_or ]] then do
          return or_(loc, attrs, Curry._2(sub.pat, sub, desc[0]), Curry._2(sub.pat, sub, desc[1]));end end end 
       if ___conditional___ = 10--[[ Ppat_constraint ]] then do
          return constraint_(loc, attrs, Curry._2(sub.pat, sub, desc[0]), Curry._2(sub.typ, sub, desc[1]));end end end 
       if ___conditional___ = 11--[[ Ppat_type ]] then do
          return type_(loc, attrs, map_loc(sub, desc[0]));end end end 
       if ___conditional___ = 12--[[ Ppat_lazy ]] then do
          return lazy_(loc, attrs, Curry._2(sub.pat, sub, desc[0]));end end end 
       if ___conditional___ = 13--[[ Ppat_unpack ]] then do
          return unpack(loc, attrs, map_loc(sub, desc[0]));end end end 
       if ___conditional___ = 14--[[ Ppat_exception ]] then do
          return exception_(loc, attrs, Curry._2(sub.pat, sub, desc[0]));end end end 
       if ___conditional___ = 15--[[ Ppat_extension ]] then do
          return extension$1(loc, attrs, Curry._2(sub.extension, sub, desc[0]));end end end 
       do
      
    end
  end end 
end end

function map$7(sub, param) do
  desc = param.pcl_desc;
  loc = Curry._2(sub.location, sub, param.pcl_loc);
  attrs = Curry._2(sub.attributes, sub, param.pcl_attributes);
  local ___conditional___=(desc.tag | 0);
  do
     if ___conditional___ = 0--[[ Pcl_constr ]] then do
        return constr$1(loc, attrs, map_loc(sub, desc[0]), List.map(Curry._1(sub.typ, sub), desc[1]));end end end 
     if ___conditional___ = 1--[[ Pcl_structure ]] then do
        return structure$1(loc, attrs, Curry._2(sub.class_structure, sub, desc[0]));end end end 
     if ___conditional___ = 2--[[ Pcl_fun ]] then do
        return fun_$1(loc, attrs, desc[0], map_opt(Curry._1(sub.expr, sub), desc[1]), Curry._2(sub.pat, sub, desc[2]), Curry._2(sub.class_expr, sub, desc[3]));end end end 
     if ___conditional___ = 3--[[ Pcl_apply ]] then do
        partial_arg = Curry._1(sub.expr, sub);
        return apply$2(loc, attrs, Curry._2(sub.class_expr, sub, desc[0]), List.map((function (param) do
                          return map_snd(partial_arg, param);
                        end end), desc[1]));end end end 
     if ___conditional___ = 4--[[ Pcl_let ]] then do
        return let_$1(loc, attrs, desc[0], List.map(Curry._1(sub.value_binding, sub), desc[1]), Curry._2(sub.class_expr, sub, desc[2]));end end end 
     if ___conditional___ = 5--[[ Pcl_constraint ]] then do
        return constraint_$3(loc, attrs, Curry._2(sub.class_expr, sub, desc[0]), Curry._2(sub.class_type, sub, desc[1]));end end end 
     if ___conditional___ = 6--[[ Pcl_extension ]] then do
        return extension$7(loc, attrs, Curry._2(sub.extension, sub, desc[0]));end end end 
     do
    
  end
end end

function map_kind(sub, param) do
  if (param.tag) then do
    return --[[ Cfk_concrete ]]Block.__(1, {
              param[0],
              Curry._2(sub.expr, sub, param[1])
            });
  end else do
    return --[[ Cfk_virtual ]]Block.__(0, {Curry._2(sub.typ, sub, param[0])});
  end end 
end end

function map_field$1(sub, param) do
  desc = param.pcf_desc;
  loc = Curry._2(sub.location, sub, param.pcf_loc);
  attrs = Curry._2(sub.attributes, sub, param.pcf_attributes);
  local ___conditional___=(desc.tag | 0);
  do
     if ___conditional___ = 0--[[ Pcf_inherit ]] then do
        return Curry._5(Ast_helper_Cf.inherit_, loc, attrs, desc[0], Curry._2(sub.class_expr, sub, desc[1]), desc[2]);end end end 
     if ___conditional___ = 1--[[ Pcf_val ]] then do
        match = desc[0];
        return Curry._5(Ast_helper_Cf.val_, loc, attrs, map_loc(sub, match[0]), match[1], map_kind(sub, match[2]));end end end 
     if ___conditional___ = 2--[[ Pcf_method ]] then do
        match$1 = desc[0];
        return Curry._5(Ast_helper_Cf.method_, loc, attrs, map_loc(sub, match$1[0]), match$1[1], map_kind(sub, match$1[2]));end end end 
     if ___conditional___ = 3--[[ Pcf_constraint ]] then do
        match$2 = desc[0];
        return Curry._4(Ast_helper_Cf.constraint_, loc, attrs, Curry._2(sub.typ, sub, match$2[0]), Curry._2(sub.typ, sub, match$2[1]));end end end 
     if ___conditional___ = 4--[[ Pcf_initializer ]] then do
        return Curry._3(Ast_helper_Cf.initializer_, loc, attrs, Curry._2(sub.expr, sub, desc[0]));end end end 
     if ___conditional___ = 5--[[ Pcf_attribute ]] then do
        return Curry._2(Ast_helper_Cf.attribute, loc, Curry._2(sub.attribute, sub, desc[0]));end end end 
     if ___conditional___ = 6--[[ Pcf_extension ]] then do
        return Curry._3(Ast_helper_Cf.extension, loc, attrs, Curry._2(sub.extension, sub, desc[0]));end end end 
     do
    
  end
end end

function map_structure(sub, param) do
  return do
          pcstr_self: Curry._2(sub.pat, sub, param.pcstr_self),
          pcstr_fields: List.map(Curry._1(sub.class_field, sub), param.pcstr_fields)
        end;
end end

function class_infos(sub, f, param) do
  partial_arg = Curry._1(sub.typ, sub);
  return mk$18(Curry._2(sub.location, sub, param.pci_loc), Curry._2(sub.attributes, sub, param.pci_attributes), undefined, undefined, param.pci_virt, List.map((function (param) do
                    return map_fst(partial_arg, param);
                  end end), param.pci_params), map_loc(sub, param.pci_name), Curry._1(f, param.pci_expr));
end end

function default_mapper_attribute(__this, param) do
  return --[[ tuple ]]{
          map_loc(__this, param[0]),
          Curry._2(__this.payload, __this, param[1])
        };
end end

function default_mapper_attributes(__this, l) do
  return List.map(Curry._1(__this.attribute, __this), l);
end end

function default_mapper_case(__this, param) do
  return do
          pc_lhs: Curry._2(__this.pat, __this, param.pc_lhs),
          pc_guard: map_opt(Curry._1(__this.expr, __this), param.pc_guard),
          pc_rhs: Curry._2(__this.expr, __this, param.pc_rhs)
        end;
end end

function default_mapper_cases(__this, l) do
  return List.map(Curry._1(__this.case, __this), l);
end end

function default_mapper_class_declaration(__this) do
  partial_arg = Curry._1(__this.class_expr, __this);
  return (function (param) do
      return class_infos(__this, partial_arg, param);
    end end);
end end

function default_mapper_class_description(__this) do
  partial_arg = Curry._1(__this.class_type, __this);
  return (function (param) do
      return class_infos(__this, partial_arg, param);
    end end);
end end

function default_mapper_class_type_declaration(__this) do
  partial_arg = Curry._1(__this.class_type, __this);
  return (function (param) do
      return class_infos(__this, partial_arg, param);
    end end);
end end

function default_mapper_constructor_declaration(__this, param) do
  return constructor(Curry._2(__this.location, __this, param.pcd_loc), Curry._2(__this.attributes, __this, param.pcd_attributes), undefined, List.map(Curry._1(__this.typ, __this), param.pcd_args), map_opt(Curry._1(__this.typ, __this), param.pcd_res), map_loc(__this, param.pcd_name));
end end

function default_mapper_extension(__this, param) do
  return --[[ tuple ]]{
          map_loc(__this, param[0]),
          Curry._2(__this.payload, __this, param[1])
        };
end end

function default_mapper_include_declaration(__this, param) do
  return mk$16(Curry._2(__this.location, __this, param.pincl_loc), Curry._2(__this.attributes, __this, param.pincl_attributes), undefined, Curry._2(__this.module_expr, __this, param.pincl_mod));
end end

function default_mapper_include_description(__this, param) do
  return mk$16(Curry._2(__this.location, __this, param.pincl_loc), Curry._2(__this.attributes, __this, param.pincl_attributes), undefined, Curry._2(__this.module_type, __this, param.pincl_mod));
end end

function default_mapper_label_declaration(__this, param) do
  return field$1(Curry._2(__this.location, __this, param.pld_loc), Curry._2(__this.attributes, __this, param.pld_attributes), undefined, param.pld_mutable, map_loc(__this, param.pld_name), Curry._2(__this.typ, __this, param.pld_type));
end end

function default_mapper_location(__this, l) do
  return l;
end end

function default_mapper_module_binding(__this, param) do
  return mk$14(Curry._2(__this.location, __this, param.pmb_loc), Curry._2(__this.attributes, __this, param.pmb_attributes), undefined, undefined, map_loc(__this, param.pmb_name), Curry._2(__this.module_expr, __this, param.pmb_expr));
end end

function default_mapper_module_declaration(__this, param) do
  return mk$12(Curry._2(__this.location, __this, param.pmd_loc), Curry._2(__this.attributes, __this, param.pmd_attributes), undefined, undefined, map_loc(__this, param.pmd_name), Curry._2(__this.module_type, __this, param.pmd_type));
end end

function default_mapper_module_type_declaration(__this, param) do
  return mk$13(Curry._2(__this.location, __this, param.pmtd_loc), Curry._2(__this.attributes, __this, param.pmtd_attributes), undefined, undefined, map_opt(Curry._1(__this.module_type, __this), param.pmtd_type), map_loc(__this, param.pmtd_name));
end end

function default_mapper_open_description(__this, param) do
  return mk$15(Curry._2(__this.location, __this, param.popen_loc), Curry._2(__this.attributes, __this, param.popen_attributes), undefined, param.popen_override, map_loc(__this, param.popen_lid));
end end

function default_mapper_payload(__this, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ PStr ]] then do
        return --[[ PStr ]]Block.__(0, {Curry._2(__this.structure, __this, param[0])});end end end 
     if ___conditional___ = 1--[[ PTyp ]] then do
        return --[[ PTyp ]]Block.__(1, {Curry._2(__this.typ, __this, param[0])});end end end 
     if ___conditional___ = 2--[[ PPat ]] then do
        return --[[ PPat ]]Block.__(2, {
                  Curry._2(__this.pat, __this, param[0]),
                  map_opt(Curry._1(__this.expr, __this), param[1])
                });end end end 
     do
    
  end
end end

function default_mapper_signature(__this, l) do
  return List.map(Curry._1(__this.signature_item, __this), l);
end end

function default_mapper_structure(__this, l) do
  return List.map(Curry._1(__this.structure_item, __this), l);
end end

function default_mapper_value_binding(__this, param) do
  return mk$17(Curry._2(__this.location, __this, param.pvb_loc), Curry._2(__this.attributes, __this, param.pvb_attributes), undefined, undefined, Curry._2(__this.pat, __this, param.pvb_pat), Curry._2(__this.expr, __this, param.pvb_expr));
end end

function default_mapper_value_description(__this, param) do
  return mk$11(Curry._2(__this.location, __this, param.pval_loc), Curry._2(__this.attributes, __this, param.pval_attributes), undefined, param.pval_prim, map_loc(__this, param.pval_name), Curry._2(__this.typ, __this, param.pval_type));
end end

default_mapper = do
  attribute: default_mapper_attribute,
  attributes: default_mapper_attributes,
  case: default_mapper_case,
  cases: default_mapper_cases,
  class_declaration: default_mapper_class_declaration,
  class_description: default_mapper_class_description,
  class_expr: map$7,
  class_field: map_field$1,
  class_signature: map_signature,
  class_structure: map_structure,
  class_type: map$2,
  class_type_declaration: default_mapper_class_type_declaration,
  class_type_field: map_field,
  constructor_declaration: default_mapper_constructor_declaration,
  expr: map$5,
  extension: default_mapper_extension,
  extension_constructor: map_extension_constructor,
  include_declaration: default_mapper_include_declaration,
  include_description: default_mapper_include_description,
  label_declaration: default_mapper_label_declaration,
  location: default_mapper_location,
  module_binding: default_mapper_module_binding,
  module_declaration: default_mapper_module_declaration,
  module_expr: map$4,
  module_type: map$3,
  module_type_declaration: default_mapper_module_type_declaration,
  open_description: default_mapper_open_description,
  pat: map$6,
  payload: default_mapper_payload,
  signature: default_mapper_signature,
  signature_item: map_signature_item,
  structure: default_mapper_structure,
  structure_item: map_structure_item,
  typ: map$1,
  type_declaration: map_type_declaration,
  type_extension: map_type_extension,
  type_kind: map_type_kind,
  value_binding: default_mapper_value_binding,
  value_description: default_mapper_value_description,
  with_constraint: map_with_constraint
end;

function height$4(param) do
  if (param) then do
    return param[4];
  end else do
    return 0;
  end end 
end end

function create$5(l, x, d, r) do
  hl = height$4(l);
  hr = height$4(r);
  return --[[ Node ]]{
          l,
          x,
          d,
          r,
          hl >= hr and hl + 1 | 0 or hr + 1 | 0
        };
end end

function bal$4(l, x, d, r) do
  hl = height$4(l);
  hr = height$4(r);
  if (hl > (hr + 1 | 0)) then do
    if (l) then do
      lr = l[3];
      ld = l[2];
      lv = l[1];
      ll = l[0];
      if (height$4(ll) >= height$4(lr)) then do
        return create$5(ll, lv, ld, create$5(lr, x, d, r));
      end else if (lr) then do
        return create$5(create$5(ll, lv, ld, lr[0]), lr[1], lr[2], create$5(lr[3], x, d, r));
      end else do
        throw {
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "tbl.ml",
                35,
                11
              }
            };
      end end  end 
    end else do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "tbl.ml",
              35,
              11
            }
          };
    end end 
  end else if (hr > (hl + 1 | 0)) then do
    if (r) then do
      rl = r[0];
      rr = r[3];
      if (height$4(rr) >= height$4(rl)) then do
        return create$5(create$5(l, x, d, rl), r[1], r[2], rr);
      end else if (rl) then do
        return create$5(create$5(l, x, d, rl[0]), rl[1], rl[2], create$5(rl[3], r[1], r[2], r[3]));
      end else do
        throw {
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "tbl.ml",
                42,
                11
              }
            };
      end end  end 
    end else do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "tbl.ml",
              42,
              11
            }
          };
    end end 
  end else do
    return create$5(l, x, d, r);
  end end  end 
end end

function add$5(x, data, param) do
  if (param) then do
    r = param[3];
    d = param[2];
    v = param[1];
    l = param[0];
    c = Caml_obj.caml_compare(x, v);
    if (c == 0) then do
      return --[[ Node ]]{
              l,
              x,
              data,
              r,
              param[4]
            };
    end else if (c < 0) then do
      return bal$4(add$5(x, data, l), v, d, r);
    end else do
      return bal$4(l, v, d, add$5(x, data, r));
    end end  end 
  end else do
    return --[[ Node ]]{
            --[[ Empty ]]0,
            x,
            data,
            --[[ Empty ]]0,
            1
          };
  end end 
end end

function find$2(x, _param) do
  while(true) do
    param = _param;
    if (param) then do
      c = Caml_obj.caml_compare(x, param[1]);
      if (c == 0) then do
        return param[2];
      end else do
        _param = c < 0 and param[0] or param[3];
        continue ;
      end end 
    end else do
      throw Caml_builtin_exceptions.not_found;
    end end 
  end;
end end

function mem$4(x, _param) do
  while(true) do
    param = _param;
    if (param) then do
      c = Caml_obj.caml_compare(x, param[1]);
      if (c == 0) then do
        return true;
      end else do
        _param = c < 0 and param[0] or param[3];
        continue ;
      end end 
    end else do
      return false;
    end end 
  end;
end end

function iter$2(f, _param) do
  while(true) do
    param = _param;
    if (param) then do
      iter$2(f, param[0]);
      Curry._2(f, param[1], param[2]);
      _param = param[3];
      continue ;
    end else do
      return --[[ () ]]0;
    end end 
  end;
end end

function fold$4(f, _m, _accu) do
  while(true) do
    accu = _accu;
    m = _m;
    if (m) then do
      _accu = Curry._3(f, m[1], m[2], fold$4(f, m[0], accu));
      _m = m[3];
      continue ;
    end else do
      return accu;
    end end 
  end;
end end

identity = do
  types: --[[ Empty ]]0,
  modules: --[[ Empty ]]0,
  modtypes: --[[ Empty ]]0,
  for_saving: false
end;

function add_type(id, p, s) do
  return do
          types: add$5(id, p, s.types),
          modules: s.modules,
          modtypes: s.modtypes,
          for_saving: s.for_saving
        end;
end end

function add_module(id, p, s) do
  return do
          types: s.types,
          modules: add$5(id, p, s.modules),
          modtypes: s.modtypes,
          for_saving: s.for_saving
        end;
end end

function add_modtype(id, ty, s) do
  return do
          types: s.types,
          modules: s.modules,
          modtypes: add$5(id, ty, s.modtypes),
          for_saving: s.for_saving
        end;
end end

function for_saving(s) do
  return do
          types: s.types,
          modules: s.modules,
          modtypes: s.modtypes,
          for_saving: true
        end;
end end

function loc(s, x) do
  if (s.for_saving and not keep_locs.contents) then do
    return none;
  end else do
    return x;
  end end 
end end

newrecord = Caml_obj.caml_obj_dup(default_mapper);

newrecord.location = (function (_this, _loc) do
    return none;
  end end);

function is_not_doc(param) do
  local ___conditional___=(param[0].txt);
  do
     if ___conditional___ = "doc"
     or ___conditional___ = "ocaml.doc"
     or ___conditional___ = "ocaml.text"
     or ___conditional___ = "text" then do
        return false;end end end 
     do
    else do
      return true;
      end end
      
  end
end end

function attrs(s, x) do
  x$1 = s.for_saving and not keep_docs.contents and List.filter(is_not_doc)(x) or x;
  if (s.for_saving and not keep_locs.contents) then do
    return Curry._2(newrecord.attributes, newrecord, x$1);
  end else do
    return x$1;
  end end 
end end

function module_path(s, p) do
  local ___conditional___=(p.tag | 0);
  do
     if ___conditional___ = 0--[[ Pident ]] then do
        try do
          return find$2(p[0], s.modules);
        end
        catch (exn)do
          if (exn == Caml_builtin_exceptions.not_found) then do
            return p;
          end else do
            throw exn;
          end end 
        endend end end 
     if ___conditional___ = 1--[[ Pdot ]] then do
        return --[[ Pdot ]]Block.__(1, {
                  module_path(s, p[0]),
                  p[1],
                  p[2]
                });end end end 
     if ___conditional___ = 2--[[ Papply ]] then do
        return --[[ Papply ]]Block.__(2, {
                  module_path(s, p[0]),
                  module_path(s, p[1])
                });end end end 
     do
    
  end
end end

function modtype_path(s, p) do
  local ___conditional___=(p.tag | 0);
  do
     if ___conditional___ = 0--[[ Pident ]] then do
        try do
          match = find$2(p[0], s.modtypes);
          if (match.tag) then do
            return fatal_error("Subst.modtype_path");
          end else do
            return match[0];
          end end 
        end
        catch (exn)do
          if (exn == Caml_builtin_exceptions.not_found) then do
            return p;
          end else do
            throw exn;
          end end 
        endend end end 
     if ___conditional___ = 1--[[ Pdot ]] then do
        return --[[ Pdot ]]Block.__(1, {
                  module_path(s, p[0]),
                  p[1],
                  p[2]
                });end end end 
     if ___conditional___ = 2--[[ Papply ]] then do
        return fatal_error("Subst.modtype_path");end end end 
     do
    
  end
end end

function type_path(s, p) do
  local ___conditional___=(p.tag | 0);
  do
     if ___conditional___ = 0--[[ Pident ]] then do
        try do
          return find$2(p[0], s.types);
        end
        catch (exn)do
          if (exn == Caml_builtin_exceptions.not_found) then do
            return p;
          end else do
            throw exn;
          end end 
        endend end end 
     if ___conditional___ = 1--[[ Pdot ]] then do
        return --[[ Pdot ]]Block.__(1, {
                  module_path(s, p[0]),
                  p[1],
                  p[2]
                });end end end 
     if ___conditional___ = 2--[[ Papply ]] then do
        return fatal_error("Subst.type_path");end end end 
     do
    
  end
end end

new_id$1 = do
  contents: -1
end;

function newpersty(desc) do
  new_id$1.contents = new_id$1.contents - 1 | 0;
  return do
          desc: desc,
          level: 100000000,
          id: new_id$1.contents
        end;
end end

function norm(d) do
  if (typeof d == "number") then do
    return d;
  end else do
    local ___conditional___=(d.tag | 0);
    do
       if ___conditional___ = 0--[[ Tvar ]] then do
          if (d[0] ~= undefined) then do
            return d;
          end else do
            return --[[ Tvar ]]Block.__(0, {undefined});
          end end end end end 
       if ___conditional___ = 9--[[ Tunivar ]] then do
          if (d[0] ~= undefined) then do
            return d;
          end else do
            return --[[ Tunivar ]]Block.__(9, {undefined});
          end end end end end 
       do
      else do
        return d;
        end end
        
    end
  end end 
end end

function typexp(s, ty) do
  ty$1 = repr(ty);
  desc = ty$1.desc;
  exit = 0;
  if (typeof desc == "number") then do
    exit = 1;
  end else do
    local ___conditional___=(desc.tag | 0);
    do
       if ___conditional___ = 7--[[ Tsubst ]] then do
          return desc[0];end end end 
       if ___conditional___ = 0--[[ Tvar ]]
       or ___conditional___ = 9--[[ Tunivar ]] then do
          exit = 2;end else 
       do end
      else do
        exit = 1;
        end end
        
    end
  end end 
  local ___conditional___=(exit);
  do
     if ___conditional___ = 1 then do
        desc$1 = ty$1.desc;
        save_desc(ty$1, desc$1);
        ty$prime = s.for_saving and newpersty(--[[ Tvar ]]Block.__(0, {undefined})) or newty2(100000000, --[[ Tvar ]]Block.__(0, {undefined}));
        ty$1.desc = --[[ Tsubst ]]Block.__(7, {ty$prime});
        tmp;
        exit$1 = 0;
        if (typeof desc$1 == "number") then do
          exit$1 = 3;
        end else do
          local ___conditional___=(desc$1.tag | 0);
          do
             if ___conditional___ = 3--[[ Tconstr ]] then do
                tmp = --[[ Tconstr ]]Block.__(3, {
                    type_path(s, desc$1[0]),
                    List.map((function (param) do
                            return typexp(s, param);
                          end end), desc$1[1]),
                    do
                      contents: --[[ Mnil ]]0
                    end
                  });end else 
             if ___conditional___ = 4--[[ Tobject ]] then do
                match = desc$1[1].contents;
                tmp$1;
                if (match ~= undefined) then do
                  match$1 = match;
                  tmp$1 = --[[ tuple ]]{
                    type_path(s, match$1[0]),
                    List.map((function (param) do
                            return typexp(s, param);
                          end end), match$1[1])
                  };
                end else do
                  tmp$1 = undefined;
                end end 
                tmp = --[[ Tobject ]]Block.__(4, {
                    typexp(s, desc$1[0]),
                    do
                      contents: tmp$1
                    end
                  });end else 
             if ___conditional___ = 5--[[ Tfield ]] then do
                t2 = desc$1[3];
                k = desc$1[1];
                m = desc$1[0];
                if (s == identity and ty$1.level < 100000000 and m == dummy_method) then do
                  tmp = --[[ Tfield ]]Block.__(5, {
                      m,
                      k,
                      desc$1[2],
                      typexp(s, t2)
                    });
                end else if (field_kind_repr(k) == --[[ Fabsent ]]1) then do
                  tmp = --[[ Tlink ]]Block.__(6, {typexp(s, t2)});
                end else do
                  exit$1 = 3;
                end end  end end else 
             if ___conditional___ = 8--[[ Tvariant ]] then do
                row = row_repr_aux(--[[ [] ]]0, desc$1[0]);
                more = repr(row.row_more);
                match$2 = more.desc;
                exit$2 = 0;
                if (typeof match$2 == "number" or match$2.tag ~= --[[ Tsubst ]]7) then do
                  exit$2 = 4;
                end else do
                  match$3 = match$2[0].desc;
                  if (typeof match$3 == "number" or match$3.tag ~= --[[ Ttuple ]]2) then do
                    exit$2 = 4;
                  end else do
                    match$4 = match$3[0];
                    if (match$4) then do
                      match$5 = match$4[1];
                      if (match$5 and not match$5[1]) then do
                        ty2 = match$5[0];
                        ty$1.desc = --[[ Tsubst ]]Block.__(7, {ty2});
                        tmp = --[[ Tlink ]]Block.__(6, {ty2});
                      end else do
                        exit$2 = 4;
                      end end 
                    end else do
                      exit$2 = 4;
                    end end 
                  end end 
                end end 
                if (exit$2 == 4) then do
                  dup = true;
                  if (not s.for_saving) then do
                    tmp$2 = true;
                    if (more.level ~= 100000000) then do
                      tmp$3 = true;
                      if (not static_row(row)) then do
                        match$6 = more.desc;
                        tmp$4;
                        tmp$4 = typeof match$6 == "number" or match$6.tag ~= --[[ Tconstr ]]3 and false or true;
                        tmp$3 = tmp$4;
                      end
                       end 
                      tmp$2 = tmp$3;
                    end
                     end 
                    dup = tmp$2;
                  end
                   end 
                  match$7 = more.desc;
                  more$prime;
                  exit$3 = 0;
                  if (typeof match$7 == "number") then do
                    more$prime = typexp(s, more);
                  end else do
                    local ___conditional___=(match$7.tag | 0);
                    do
                       if ___conditional___ = 3--[[ Tconstr ]] then do
                          more$prime = typexp(s, more);end else 
                       if ___conditional___ = 7--[[ Tsubst ]] then do
                          more$prime = match$7[0];end else 
                       if ___conditional___ = 0--[[ Tvar ]]
                       or ___conditional___ = 9--[[ Tunivar ]] then do
                          exit$3 = 5;end else 
                       do end end end end
                      else do
                        throw {
                              Caml_builtin_exceptions.assert_failure,
                              --[[ tuple ]]{
                                "subst.ml",
                                170,
                                23
                              }
                            };
                        end end
                        
                    end
                  end end 
                  if (exit$3 == 5) then do
                    save_desc(more, more.desc);
                    more$prime = s.for_saving and newpersty(norm(more.desc)) or (
                        dup and is_Tvar(more) and newty2(100000000, more.desc) or more
                      );
                  end
                   end 
                  more.desc = --[[ Tsubst ]]Block.__(7, {newty2(100000000, --[[ Ttuple ]]Block.__(2, {--[[ :: ]]{
                                more$prime,
                                --[[ :: ]]{
                                  ty$prime,
                                  --[[ [] ]]0
                                }
                              }}))});
                  row$1 = copy_row((function (param) do
                          return typexp(s, param);
                        end end), true, row, not dup, more$prime);
                  match$8 = row$1.row_name;
                  if (match$8 ~= undefined) then do
                    match$9 = match$8;
                    tmp = --[[ Tvariant ]]Block.__(8, {do
                          row_fields: row$1.row_fields,
                          row_more: row$1.row_more,
                          row_bound: row$1.row_bound,
                          row_closed: row$1.row_closed,
                          row_fixed: row$1.row_fixed,
                          row_name: --[[ tuple ]]{
                            type_path(s, match$9[0]),
                            match$9[1]
                          }
                        end});
                  end else do
                    tmp = --[[ Tvariant ]]Block.__(8, {row$1});
                  end end 
                end
                 end end else 
             if ___conditional___ = 11--[[ Tpackage ]] then do
                tmp = --[[ Tpackage ]]Block.__(11, {
                    modtype_path(s, desc$1[0]),
                    desc$1[1],
                    List.map((function (param) do
                            return typexp(s, param);
                          end end), desc$1[2])
                  });end else 
             do end end end end end end
            else do
              exit$1 = 3;
              end end
              
          end
        end end 
        if (exit$1 == 3) then do
          tmp = copy_type_desc(undefined, (function (param) do
                  return typexp(s, param);
                end end), desc$1);
        end
         end 
        ty$prime.desc = tmp;
        return ty$prime;end end end 
     if ___conditional___ = 2 then do
        if (s.for_saving or ty$1.id < 0) then do
          ty$prime$1 = s.for_saving and newpersty(norm(desc)) or newty2(ty$1.level, desc);
          save_desc(ty$1, desc);
          ty$1.desc = --[[ Tsubst ]]Block.__(7, {ty$prime$1});
          return ty$prime$1;
        end else do
          return ty$1;
        end end end end end 
     do
    
  end
end end

function type_expr(s, ty) do
  ty$prime = typexp(s, ty);
  cleanup_types(--[[ () ]]0);
  return ty$prime;
end end

function type_declaration(s, decl) do
  match = decl.type_kind;
  tmp;
  tmp = typeof match == "number" and (
      match == --[[ Type_abstract ]]0 and --[[ Type_abstract ]]0 or --[[ Type_open ]]1
    ) or (
      match.tag and --[[ Type_variant ]]Block.__(1, {List.map((function (c) do
                    return do
                            cd_id: c.cd_id,
                            cd_args: List.map((function (param) do
                                    return typexp(s, param);
                                  end end), c.cd_args),
                            cd_res: may_map((function (param) do
                                    return typexp(s, param);
                                  end end), c.cd_res),
                            cd_loc: loc(s, c.cd_loc),
                            cd_attributes: attrs(s, c.cd_attributes)
                          end;
                  end end), match[0])}) or --[[ Type_record ]]Block.__(0, {
            List.map((function (l) do
                    return do
                            ld_id: l.ld_id,
                            ld_mutable: l.ld_mutable,
                            ld_type: typexp(s, l.ld_type),
                            ld_loc: loc(s, l.ld_loc),
                            ld_attributes: attrs(s, l.ld_attributes)
                          end;
                  end end), match[0]),
            match[1]
          })
    );
  match$1 = decl.type_manifest;
  decl_type_params = List.map((function (param) do
          return typexp(s, param);
        end end), decl.type_params);
  decl_type_arity = decl.type_arity;
  decl_type_private = decl.type_private;
  decl_type_manifest = match$1 ~= undefined and typexp(s, match$1) or undefined;
  decl_type_variance = decl.type_variance;
  decl_type_loc = loc(s, decl.type_loc);
  decl_type_attributes = attrs(s, decl.type_attributes);
  decl$1 = do
    type_params: decl_type_params,
    type_arity: decl_type_arity,
    type_kind: tmp,
    type_private: decl_type_private,
    type_manifest: decl_type_manifest,
    type_variance: decl_type_variance,
    type_newtype_level: undefined,
    type_loc: decl_type_loc,
    type_attributes: decl_type_attributes
  end;
  cleanup_types(--[[ () ]]0);
  return decl$1;
end end

function class_signature(s, sign) do
  return do
          csig_self: typexp(s, sign.csig_self),
          csig_vars: map((function (param) do
                  return --[[ tuple ]]{
                          param[0],
                          param[1],
                          typexp(s, param[2])
                        };
                end end), sign.csig_vars),
          csig_concr: sign.csig_concr,
          csig_inher: List.map((function (param) do
                  return --[[ tuple ]]{
                          type_path(s, param[0]),
                          List.map((function (param) do
                                  return typexp(s, param);
                                end end), param[1])
                        };
                end end), sign.csig_inher)
        end;
end end

function class_type(s, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Cty_constr ]] then do
        return --[[ Cty_constr ]]Block.__(0, {
                  type_path(s, param[0]),
                  List.map((function (param) do
                          return typexp(s, param);
                        end end), param[1]),
                  class_type(s, param[2])
                });end end end 
     if ___conditional___ = 1--[[ Cty_signature ]] then do
        return --[[ Cty_signature ]]Block.__(1, {class_signature(s, param[0])});end end end 
     if ___conditional___ = 2--[[ Cty_arrow ]] then do
        return --[[ Cty_arrow ]]Block.__(2, {
                  param[0],
                  typexp(s, param[1]),
                  class_type(s, param[2])
                });end end end 
     do
    
  end
end end

function class_declaration(s, decl) do
  match = decl.cty_new;
  decl$1 = do
    cty_params: List.map((function (param) do
            return typexp(s, param);
          end end), decl.cty_params),
    cty_type: class_type(s, decl.cty_type),
    cty_path: type_path(s, decl.cty_path),
    cty_new: match ~= undefined and typexp(s, match) or undefined,
    cty_variance: decl.cty_variance,
    cty_loc: loc(s, decl.cty_loc),
    cty_attributes: attrs(s, decl.cty_attributes)
  end;
  if (not s.for_saving) then do
    cleanup_types(--[[ () ]]0);
  end
   end 
  return decl$1;
end end

function cltype_declaration(s, decl) do
  decl_clty_params = List.map((function (param) do
          return typexp(s, param);
        end end), decl.clty_params);
  decl_clty_type = class_type(s, decl.clty_type);
  decl_clty_path = type_path(s, decl.clty_path);
  decl_clty_variance = decl.clty_variance;
  decl_clty_loc = loc(s, decl.clty_loc);
  decl_clty_attributes = attrs(s, decl.clty_attributes);
  decl$1 = do
    clty_params: decl_clty_params,
    clty_type: decl_clty_type,
    clty_path: decl_clty_path,
    clty_variance: decl_clty_variance,
    clty_loc: decl_clty_loc,
    clty_attributes: decl_clty_attributes
  end;
  cleanup_types(--[[ () ]]0);
  return decl$1;
end end

function class_type$1(s, cty) do
  cty$1 = class_type(s, cty);
  cleanup_types(--[[ () ]]0);
  return cty$1;
end end

function value_description(s, descr) do
  return do
          val_type: type_expr(s, descr.val_type),
          val_kind: descr.val_kind,
          val_loc: loc(s, descr.val_loc),
          val_attributes: attrs(s, descr.val_attributes)
        end;
end end

function extension_constructor(s, ext) do
  ext_ext_type_path = type_path(s, ext.ext_type_path);
  ext_ext_type_params = List.map((function (param) do
          return typexp(s, param);
        end end), ext.ext_type_params);
  ext_ext_args = List.map((function (param) do
          return typexp(s, param);
        end end), ext.ext_args);
  ext_ext_ret_type = may_map((function (param) do
          return typexp(s, param);
        end end), ext.ext_ret_type);
  ext_ext_private = ext.ext_private;
  ext_ext_loc = s.for_saving and none or ext.ext_loc;
  ext_ext_attributes = attrs(s, ext.ext_attributes);
  ext$1 = do
    ext_type_path: ext_ext_type_path,
    ext_type_params: ext_ext_type_params,
    ext_args: ext_ext_args,
    ext_ret_type: ext_ext_ret_type,
    ext_private: ext_ext_private,
    ext_loc: ext_ext_loc,
    ext_attributes: ext_ext_attributes
  end;
  cleanup_types(--[[ () ]]0);
  return ext$1;
end end

function rename_bound_idents(_s, _idents, _param) do
  while(true) do
    param = _param;
    idents = _idents;
    s = _s;
    if (param) then do
      match = param[0];
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 1--[[ Sig_type ]] then do
            id = match[0];
            id$prime = rename(id);
            _param = param[1];
            _idents = --[[ :: ]]{
              id$prime,
              idents
            };
            _s = add_type(id, --[[ Pident ]]Block.__(0, {id$prime}), s);
            continue ;end end end 
         if ___conditional___ = 3--[[ Sig_module ]] then do
            id$1 = match[0];
            id$prime$1 = rename(id$1);
            _param = param[1];
            _idents = --[[ :: ]]{
              id$prime$1,
              idents
            };
            _s = add_module(id$1, --[[ Pident ]]Block.__(0, {id$prime$1}), s);
            continue ;end end end 
         if ___conditional___ = 4--[[ Sig_modtype ]] then do
            id$2 = match[0];
            id$prime$2 = rename(id$2);
            _param = param[1];
            _idents = --[[ :: ]]{
              id$prime$2,
              idents
            };
            _s = add_modtype(id$2, --[[ Mty_ident ]]Block.__(0, {--[[ Pident ]]Block.__(0, {id$prime$2})}), s);
            continue ;end end end 
         do
        else do
          id$prime$3 = rename(match[0]);
          _param = param[1];
          _idents = --[[ :: ]]{
            id$prime$3,
            idents
          };
          continue ;
          end end
          
      end
    end else do
      return --[[ tuple ]]{
              List.rev(idents),
              s
            };
    end end 
  end;
end end

function modtype(s, mty) do
  local ___conditional___=(mty.tag | 0);
  do
     if ___conditional___ = 0--[[ Mty_ident ]] then do
        p = mty[0];
        local ___conditional___=(p.tag | 0);
        do
           if ___conditional___ = 0--[[ Pident ]] then do
              try do
                return find$2(p[0], s.modtypes);
              end
              catch (exn)do
                if (exn == Caml_builtin_exceptions.not_found) then do
                  return mty;
                end else do
                  throw exn;
                end end 
              endend end end 
           if ___conditional___ = 1--[[ Pdot ]] then do
              return --[[ Mty_ident ]]Block.__(0, {--[[ Pdot ]]Block.__(1, {
                            module_path(s, p[0]),
                            p[1],
                            p[2]
                          })});end end end 
           if ___conditional___ = 2--[[ Papply ]] then do
              return fatal_error("Subst.modtype");end end end 
           do
          
        endend end end 
     if ___conditional___ = 1--[[ Mty_signature ]] then do
        return --[[ Mty_signature ]]Block.__(1, {signature$2(s, mty[0])});end end end 
     if ___conditional___ = 2--[[ Mty_functor ]] then do
        id = mty[0];
        id$prime = rename(id);
        return --[[ Mty_functor ]]Block.__(2, {
                  id$prime,
                  may_map((function (param) do
                          return modtype(s, param);
                        end end), mty[1]),
                  modtype(add_module(id, --[[ Pident ]]Block.__(0, {id$prime}), s), mty[2])
                });end end end 
     if ___conditional___ = 3--[[ Mty_alias ]] then do
        return --[[ Mty_alias ]]Block.__(3, {module_path(s, mty[0])});end end end 
     do
    
  end
end end

function signature$2(s, sg) do
  match = rename_bound_idents(s, --[[ [] ]]0, sg);
  s$prime = match[1];
  return List.map2((function (param, param$1) do
                s = s$prime;
                comp = param;
                newid = param$1;
                local ___conditional___=(comp.tag | 0);
                do
                   if ___conditional___ = 0--[[ Sig_value ]] then do
                      return --[[ Sig_value ]]Block.__(0, {
                                newid,
                                value_description(s, comp[1])
                              });end end end 
                   if ___conditional___ = 1--[[ Sig_type ]] then do
                      return --[[ Sig_type ]]Block.__(1, {
                                newid,
                                type_declaration(s, comp[1]),
                                comp[2]
                              });end end end 
                   if ___conditional___ = 2--[[ Sig_typext ]] then do
                      return --[[ Sig_typext ]]Block.__(2, {
                                newid,
                                extension_constructor(s, comp[1]),
                                comp[2]
                              });end end end 
                   if ___conditional___ = 3--[[ Sig_module ]] then do
                      return --[[ Sig_module ]]Block.__(3, {
                                newid,
                                module_declaration(s, comp[1]),
                                comp[2]
                              });end end end 
                   if ___conditional___ = 4--[[ Sig_modtype ]] then do
                      return --[[ Sig_modtype ]]Block.__(4, {
                                newid,
                                modtype_declaration(s, comp[1])
                              });end end end 
                   if ___conditional___ = 5--[[ Sig_class ]] then do
                      return --[[ Sig_class ]]Block.__(5, {
                                newid,
                                class_declaration(s, comp[1]),
                                comp[2]
                              });end end end 
                   if ___conditional___ = 6--[[ Sig_class_type ]] then do
                      return --[[ Sig_class_type ]]Block.__(6, {
                                newid,
                                cltype_declaration(s, comp[1]),
                                comp[2]
                              });end end end 
                   do
                  
                end
              end end), sg, match[0]);
end end

function module_declaration(s, decl) do
  return do
          md_type: modtype(s, decl.md_type),
          md_attributes: attrs(s, decl.md_attributes),
          md_loc: loc(s, decl.md_loc)
        end;
end end

function modtype_declaration(s, decl) do
  return do
          mtd_type: may_map((function (param) do
                  return modtype(s, param);
                end end), decl.mtd_type),
          mtd_attributes: attrs(s, decl.mtd_attributes),
          mtd_loc: loc(s, decl.mtd_loc)
        end;
end end

add_delayed_check_forward = do
  contents: (function (param) do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "env.ml",
              24,
              46
            }
          };
    end end)
end;

value_declarations = Hashtbl.create(undefined, 16);

type_declarations = Hashtbl.create(undefined, 16);

function add_constructor_usage(cu, param) do
  local ___conditional___=(param);
  do
     if ___conditional___ = 0--[[ Positive ]] then do
        cu.cu_positive = true;
        return --[[ () ]]0;end end end 
     if ___conditional___ = 1--[[ Pattern ]] then do
        cu.cu_pattern = true;
        return --[[ () ]]0;end end end 
     if ___conditional___ = 2--[[ Privatize ]] then do
        cu.cu_privatize = true;
        return --[[ () ]]0;end end end 
     do
    
  end
end end

used_constructors = Hashtbl.create(undefined, 16);

prefixed_sg = Hashtbl.create(undefined, 113);

__Error$2 = Caml_exceptions.create("Ocaml_typedtree_test.Env.Error");

function force(f, x) do
  match = x.contents;
  local ___conditional___=(match.tag | 0);
  do
     if ___conditional___ = 0--[[ Done ]] then do
        return match[0];end end end 
     if ___conditional___ = 1--[[ Raise ]] then do
        throw match[0];end end end 
     if ___conditional___ = 2--[[ Thunk ]] then do
        try do
          y = Curry._1(f, match[0]);
          x.contents = --[[ Done ]]Block.__(0, {y});
          return y;
        end
        catch (raw_e)do
          e = Caml_js_exceptions.internalToOCamlException(raw_e);
          x.contents = --[[ Raise ]]Block.__(1, {e});
          throw e;
        endend end end 
     do
    
  end
end end

function get_arg(x) do
  match = x.contents;
  local ___conditional___=(match.tag | 0);
  do
     if ___conditional___ = 0--[[ Done ]]
     or ___conditional___ = 1--[[ Raise ]] then do
        return ;end end end 
     if ___conditional___ = 2--[[ Thunk ]] then do
        return Caml_option.some(match[0]);end end end 
     do
    
  end
end end

function nothing(param) do
  return --[[ () ]]0;
end end

function already_defined(s, tbl) do
  try do
    find_name(s, tbl);
    return true;
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return false;
    end else do
      throw exn;
    end end 
  end
end end

function add$6(kind, slot, id, x, tbl, ref_tbl) do
  slot$1;
  if (slot ~= undefined) then do
    f = slot;
    slot$1 = (function (param) do
        s = id.name;
        return Curry._3(f, kind, s, already_defined(s, ref_tbl));
      end end);
  end else do
    slot$1 = nothing;
  end end 
  return add(id, --[[ tuple ]]{
              x,
              slot$1
            }, tbl);
end end

function find_same$1(id, tbl) do
  match = find_same(id, tbl);
  Curry._1(match[1], --[[ () ]]0);
  return match[0];
end end

function find_name$1(s, tbl) do
  match = find_name(s, tbl);
  Curry._1(match[1], --[[ () ]]0);
  return match[0];
end end

function fold_name(f) do
  return (function (param, param$1) do
      f$1 = function (k, param) do
        return Curry._2(f, k, param[0]);
      end end;
      tbl = param;
      accu = param$1;
      f$2 = function (k) do
        return Curry._2(f$1, k.ident, k.data);
      end end;
      _stack = --[[ [] ]]0;
      _accu = accu;
      _param = tbl;
      while(true) do
        param$2 = _param;
        accu$1 = _accu;
        stack = _stack;
        if (param$2) then do
          _param = param$2[2];
          _accu = Curry._2(f$2, param$2[1], accu$1);
          _stack = --[[ :: ]]{
            param$2[0],
            stack
          };
          continue ;
        end else if (stack) then do
          _param = stack[0];
          _stack = stack[1];
          continue ;
        end else do
          return accu$1;
        end end  end 
      end;
    end end);
end end

function subst_modtype_maker(param) do
  return modtype(param[0], param[1]);
end end

empty = do
  values: --[[ Empty ]]0,
  constrs: --[[ Empty ]]0,
  labels: --[[ Empty ]]0,
  types: --[[ Empty ]]0,
  modules: --[[ Empty ]]0,
  modtypes: --[[ Empty ]]0,
  components: --[[ Empty ]]0,
  classes: --[[ Empty ]]0,
  cltypes: --[[ Empty ]]0,
  functor_args: --[[ Empty ]]0,
  summary: --[[ Env_empty ]]0,
  local_constraints: false,
  gadt_instances: --[[ [] ]]0,
  flags: 0
end;

function in_signature(env) do
  return do
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: env.summary,
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags | 1
        end;
end end

function implicit_coercion(env) do
  return do
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: env.summary,
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags | 2
        end;
end end

function is_in_signature(env) do
  return (env.flags & 1) ~= 0;
end end

function is_implicit_coercion(env) do
  return (env.flags & 2) ~= 0;
end end

components_of_module$prime = do
  contents: (function (env, sub, path, mty) do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "env.ml",
              272,
              32
            }
          };
    end end)
end;

components_of_module_maker$prime = do
  contents: (function (param) do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "env.ml",
              275,
              37
            }
          };
    end end)
end;

components_of_functor_appl$prime = do
  contents: (function (f, p1, p2) do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "env.ml",
              278,
              23
            }
          };
    end end)
end;

check_modtype_inclusion = do
  contents: (function (env, mty1, path1, mty2) do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "env.ml",
              282,
              35
            }
          };
    end end)
end;

strengthen = do
  contents: (function (env, mty, path) do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "env.ml",
              286,
              28
            }
          };
    end end)
end;

current_unit = do
  contents: ""
end;

persistent_structures = Hashtbl.create(undefined, 17);

crc_units = Hashtbl.create(undefined, 13);

function height$5(param) do
  if (param) then do
    return param[--[[ h ]]3];
  end else do
    return 0;
  end end 
end end

function create$6(l, v, r) do
  hl = l and l[--[[ h ]]3] or 0;
  hr = r and r[--[[ h ]]3] or 0;
  return --[[ Node ]]{
          --[[ l ]]l,
          --[[ v ]]v,
          --[[ r ]]r,
          --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
        };
end end

function bal$5(l, v, r) do
  hl = l and l[--[[ h ]]3] or 0;
  hr = r and r[--[[ h ]]3] or 0;
  if (hl > (hr + 2 | 0)) then do
    if (l) then do
      lr = l[--[[ r ]]2];
      lv = l[--[[ v ]]1];
      ll = l[--[[ l ]]0];
      if (height$5(ll) >= height$5(lr)) then do
        return create$6(ll, lv, create$6(lr, v, r));
      end else if (lr) then do
        return create$6(create$6(ll, lv, lr[--[[ l ]]0]), lr[--[[ v ]]1], create$6(lr[--[[ r ]]2], v, r));
      end else do
        throw {
              Caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            };
      end end  end 
    end else do
      throw {
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          };
    end end 
  end else if (hr > (hl + 2 | 0)) then do
    if (r) then do
      rr = r[--[[ r ]]2];
      rv = r[--[[ v ]]1];
      rl = r[--[[ l ]]0];
      if (height$5(rr) >= height$5(rl)) then do
        return create$6(create$6(l, v, rl), rv, rr);
      end else if (rl) then do
        return create$6(create$6(l, v, rl[--[[ l ]]0]), rl[--[[ v ]]1], create$6(rl[--[[ r ]]2], rv, rr));
      end else do
        throw {
              Caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            };
      end end  end 
    end else do
      throw {
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          };
    end end 
  end else do
    return --[[ Node ]]{
            --[[ l ]]l,
            --[[ v ]]v,
            --[[ r ]]r,
            --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
          };
  end end  end 
end end

function add$7(x, t) do
  if (t) then do
    r = t[--[[ r ]]2];
    v = t[--[[ v ]]1];
    l = t[--[[ l ]]0];
    c = Caml_primitive.caml_string_compare(x, v);
    if (c == 0) then do
      return t;
    end else if (c < 0) then do
      ll = add$7(x, l);
      if (l == ll) then do
        return t;
      end else do
        return bal$5(ll, v, r);
      end end 
    end else do
      rr = add$7(x, r);
      if (r == rr) then do
        return t;
      end else do
        return bal$5(l, v, rr);
      end end 
    end end  end 
  end else do
    return --[[ Node ]]{
            --[[ l : Empty ]]0,
            --[[ v ]]x,
            --[[ r : Empty ]]0,
            --[[ h ]]1
          };
  end end 
end end

function fold$5(f, _s, _accu) do
  while(true) do
    accu = _accu;
    s = _s;
    if (s) then do
      _accu = Curry._2(f, s[--[[ v ]]1], fold$5(f, s[--[[ l ]]0], accu));
      _s = s[--[[ r ]]2];
      continue ;
    end else do
      return accu;
    end end 
  end;
end end

function elements_aux$2(_accu, _param) do
  while(true) do
    param = _param;
    accu = _accu;
    if (param) then do
      _param = param[--[[ l ]]0];
      _accu = --[[ :: ]]{
        param[--[[ v ]]1],
        elements_aux$2(accu, param[--[[ r ]]2])
      };
      continue ;
    end else do
      return accu;
    end end 
  end;
end end

imported_units = do
  contents: --[[ Empty ]]0
end;

function add_import(s) do
  imported_units.contents = add$7(s, imported_units.contents);
  return --[[ () ]]0;
end end

function check_consistency(ps) do
  if (ps.ps_crcs_checked) then do
    return 0;
  end else do
    try do
      List.iter((function (param) do
              crco = param[1];
              if (crco ~= undefined) then do
                name = param[0];
                add_import(name);
                tbl = crc_units;
                name$1 = name;
                crc = crco;
                source = ps.ps_filename;
                try do
                  match = Hashtbl.find(tbl, name$1);
                  if (Caml_obj.caml_notequal(crc, match[0])) then do
                    throw {
                          Inconsistency,
                          name$1,
                          source,
                          match[1]
                        };
                  end else do
                    return 0;
                  end end 
                end
                catch (exn)do
                  if (exn == Caml_builtin_exceptions.not_found) then do
                    return Hashtbl.add(tbl, name$1, --[[ tuple ]]{
                                crc,
                                source
                              });
                  end else do
                    throw exn;
                  end end 
                end
              end else do
                return --[[ () ]]0;
              end end 
            end end), ps.ps_crcs);
      ps.ps_crcs_checked = true;
      return --[[ () ]]0;
    end
    catch (raw_exn)do
      exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] == Inconsistency) then do
        throw {
              __Error$2,
              --[[ Inconsistent_import ]]Block.__(1, {
                  exn[1],
                  exn[3],
                  exn[2]
                })
            };
      end
       end 
      throw exn;
    end
  end end 
end end

function save_pers_struct(crc, ps) do
  modname = ps.ps_name;
  Hashtbl.add(persistent_structures, modname, ps);
  set$1(crc_units, modname, crc, ps.ps_filename);
  return add_import(modname);
end end

function read_pers_struct(modname, filename) do
  cmi = read_cmi(filename);
  name = cmi.cmi_name;
  sign = cmi.cmi_sign;
  crcs = cmi.cmi_crcs;
  flags = cmi.cmi_flags;
  comps = Curry._4(components_of_module$prime.contents, empty, identity, --[[ Pident ]]Block.__(0, {do
            stamp: 0,
            name: name,
            flags: 1
          end}), --[[ Mty_signature ]]Block.__(1, {sign}));
  ps = do
    ps_name: name,
    ps_sig: sign,
    ps_comps: comps,
    ps_crcs: crcs,
    ps_crcs_checked: false,
    ps_filename: filename,
    ps_flags: flags
  end;
  if (ps.ps_name ~= modname) then do
    throw {
          __Error$2,
          --[[ Illegal_renaming ]]Block.__(0, {
              modname,
              ps.ps_name,
              filename
            })
        };
  end
   end 
  add_import(name);
  List.iter((function (param) do
          if (recursive_types.contents) then do
            return 0;
          end else do
            throw {
                  __Error$2,
                  --[[ Need_recursive_types ]]Block.__(2, {
                      ps.ps_name,
                      current_unit.contents
                    })
                };
          end end 
        end end), ps.ps_flags);
  Hashtbl.add(persistent_structures, modname, ps);
  return ps;
end end

function find_pers_struct(checkOpt, name) do
  check = checkOpt ~= undefined and checkOpt or true;
  if (name == "*predef*") then do
    throw Caml_builtin_exceptions.not_found;
  end
   end 
  r;
  try do
    r = Caml_option.some(Hashtbl.find(persistent_structures, name));
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      r = undefined;
    end else do
      throw exn;
    end end 
  end
  ps;
  if (r ~= undefined) then do
    match = Caml_option.valFromOption(r);
    if (match ~= undefined) then do
      ps = match;
    end else do
      throw Caml_builtin_exceptions.not_found;
    end end 
  end else do
    add_import(name);
    filename;
    try do
      filename = find_in_path_uncap(load_path.contents, name .. ".cmi");
    end
    catch (exn$1)do
      if (exn$1 == Caml_builtin_exceptions.not_found) then do
        Hashtbl.add(persistent_structures, name, undefined);
        throw Caml_builtin_exceptions.not_found;
      end else do
        throw exn$1;
      end end 
    end
    ps = read_pers_struct(name, filename);
  end end 
  if (check) then do
    check_consistency(ps);
  end
   end 
  return ps;
end end

function find_module_descr(path, env) do
  local ___conditional___=(path.tag | 0);
  do
     if ___conditional___ = 0--[[ Pident ]] then do
        id = path[0];
        try do
          return find_same$1(id, env.components)[1];
        end
        catch (exn)do
          if (exn == Caml_builtin_exceptions.not_found) then do
            if (id.stamp == 0 and id.name ~= current_unit.contents) then do
              return find_pers_struct(undefined, id.name).ps_comps;
            end else do
              throw Caml_builtin_exceptions.not_found;
            end end 
          end else do
            throw exn;
          end end 
        endend end end 
     if ___conditional___ = 1--[[ Pdot ]] then do
        match = force(components_of_module_maker$prime.contents, find_module_descr(path[0], env));
        if (match.tag) then do
          throw Caml_builtin_exceptions.not_found;
        end else do
          return find$2(path[1], match[0].comp_components)[0];
        end end end end end 
     if ___conditional___ = 2--[[ Papply ]] then do
        p1 = path[0];
        match$1 = force(components_of_module_maker$prime.contents, find_module_descr(p1, env));
        if (match$1.tag) then do
          return Curry._3(components_of_functor_appl$prime.contents, match$1[0], p1, path[1]);
        end else do
          throw Caml_builtin_exceptions.not_found;
        end end end end end 
     do
    
  end
end end

function find$3(proj1, proj2, path, env) do
  local ___conditional___=(path.tag | 0);
  do
     if ___conditional___ = 0--[[ Pident ]] then do
        return find_same$1(path[0], Curry._1(proj1, env))[1];end end end 
     if ___conditional___ = 1--[[ Pdot ]] then do
        match = force(components_of_module_maker$prime.contents, find_module_descr(path[0], env));
        if (match.tag) then do
          throw Caml_builtin_exceptions.not_found;
        end else do
          return find$2(path[1], Curry._1(proj2, match[0]))[0];
        end end end end end 
     if ___conditional___ = 2--[[ Papply ]] then do
        throw Caml_builtin_exceptions.not_found;end end end 
     do
    
  end
end end

function find_value(param, param$1) do
  return find$3((function (env) do
                return env.values;
              end end), (function (sc) do
                return sc.comp_values;
              end end), param, param$1);
end end

function find_type_full(param, param$1) do
  return find$3((function (env) do
                return env.types;
              end end), (function (sc) do
                return sc.comp_types;
              end end), param, param$1);
end end

function find_modtype(param, param$1) do
  return find$3((function (env) do
                return env.modtypes;
              end end), (function (sc) do
                return sc.comp_modtypes;
              end end), param, param$1);
end end

function find_class(param, param$1) do
  return find$3((function (env) do
                return env.classes;
              end end), (function (sc) do
                return sc.comp_classes;
              end end), param, param$1);
end end

function find_module(alias, path, env) do
  local ___conditional___=(path.tag | 0);
  do
     if ___conditional___ = 0--[[ Pident ]] then do
        id = path[0];
        try do
          return find_same$1(id, env.modules)[1];
        end
        catch (exn)do
          if (exn == Caml_builtin_exceptions.not_found) then do
            if (id.stamp == 0 and id.name ~= current_unit.contents) then do
              ps = find_pers_struct(undefined, id.name);
              return do
                      md_type: --[[ Mty_signature ]]Block.__(1, {ps.ps_sig}),
                      md_attributes: --[[ [] ]]0,
                      md_loc: none
                    end;
            end else do
              throw Caml_builtin_exceptions.not_found;
            end end 
          end else do
            throw exn;
          end end 
        endend end end 
     if ___conditional___ = 1--[[ Pdot ]] then do
        match = force(components_of_module_maker$prime.contents, find_module_descr(path[0], env));
        if (match.tag) then do
          throw Caml_builtin_exceptions.not_found;
        end else do
          match$1 = find$2(path[1], match[0].comp_modules);
          md_type = force(subst_modtype_maker, match$1[0]);
          return do
                  md_type: md_type,
                  md_attributes: --[[ [] ]]0,
                  md_loc: none
                end;
        end end end end end 
     if ___conditional___ = 2--[[ Papply ]] then do
        p2 = path[1];
        desc1 = find_module_descr(path[0], env);
        match$2 = force(components_of_module_maker$prime.contents, desc1);
        if (match$2.tag) then do
          f = match$2[0];
          mty = f.fcomp_res;
          md_type$1;
          if (mty.tag == --[[ Mty_alias ]]3) then do
            md_type$1 = --[[ Mty_alias ]]Block.__(3, {module_path(f.fcomp_subst, mty[0])});
          end else if (alias) then do
            md_type$1 = mty;
          end else do
            try do
              md_type$1 = Hashtbl.find(f.fcomp_subst_cache, p2);
            end
            catch (exn$1)do
              if (exn$1 == Caml_builtin_exceptions.not_found) then do
                mty$1 = modtype(add_module(f.fcomp_param, p2, f.fcomp_subst), f.fcomp_res);
                Hashtbl.add(f.fcomp_subst_cache, p2, mty$1);
                md_type$1 = mty$1;
              end else do
                throw exn$1;
              end end 
            end
          end end  end 
          return do
                  md_type: md_type$1,
                  md_attributes: --[[ [] ]]0,
                  md_loc: none
                end;
        end else do
          throw Caml_builtin_exceptions.not_found;
        end end end end end 
     do
    
  end
end end

required_globals = do
  contents: --[[ [] ]]0
end;

function add_required_global(id) do
  if (__global(id) and not transparent_modules.contents and not List.exists((function (param) do
            return Caml_obj.caml_equal(id, param);
          end end), required_globals.contents)) then do
    required_globals.contents = --[[ :: ]]{
      id,
      required_globals.contents
    };
    return --[[ () ]]0;
  end else do
    return 0;
  end end 
end end

function normalize_path(lax, env, path) do
  path$1;
  local ___conditional___=(path.tag | 0);
  do
     if ___conditional___ = 0--[[ Pident ]] then do
        path$1 = path;end else 
     if ___conditional___ = 1--[[ Pdot ]] then do
        path$1 = --[[ Pdot ]]Block.__(1, {
            normalize_path(lax, env, path[0]),
            path[1],
            path[2]
          });end else 
     if ___conditional___ = 2--[[ Papply ]] then do
        path$1 = --[[ Papply ]]Block.__(2, {
            normalize_path(lax, env, path[0]),
            normalize_path(true, env, path[1])
          });end else 
     do end end end end
    
  end
  try do
    match = find_module(true, path$1, env);
    match$1 = match.md_type;
    if (match$1.tag == --[[ Mty_alias ]]3) then do
      path$prime = normalize_path(lax, env, match$1[0]);
      if (lax or transparent_modules.contents) then do
        return path$prime;
      end else do
        id = head(path$1);
        if (__global(id) and not Caml_obj.caml_equal(id, head(path$prime))) then do
          add_required_global(id);
        end
         end 
        return path$prime;
      end end 
    end else do
      return path$1;
    end end 
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      tmp = true;
      if (not lax) then do
        tmp$1;
        local ___conditional___=(path$1.tag | 0);
        do
           if ___conditional___ = 0--[[ Pident ]] then do
              tmp$1 = path$1[0].stamp ~= 0;end else 
           if ___conditional___ = 1--[[ Pdot ]]
           or ___conditional___ = 2--[[ Papply ]] then do
              tmp$1 = true;end else 
           do end end end
          
        end
        tmp = tmp$1;
      end
       end 
      if (tmp) then do
        return path$1;
      end else do
        throw exn;
      end end 
    end else do
      throw exn;
    end end 
  end
end end

function normalize_path$1(oloc, env, path) do
  try do
    return normalize_path(oloc == undefined, env, path);
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      if (oloc ~= undefined) then do
        throw {
              __Error$2,
              --[[ Missing_module ]]Block.__(3, {
                  oloc,
                  path,
                  normalize_path(true, env, path)
                })
            };
      end
       end 
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "env.ml",
              579,
              28
            }
          };
    end else do
      throw exn;
    end end 
  end
end end

function find_type_expansion(path, env) do
  decl = find_type_full(path, env)[0];
  match = decl.type_manifest;
  if (match ~= undefined) then do
    body = match;
    if (decl.type_private == --[[ Public ]]1 or decl.type_kind ~= --[[ Type_abstract ]]0 or has_constr_row(body)) then do
      return --[[ tuple ]]{
              decl.type_params,
              body,
              may_map((function (prim) do
                      return prim[1];
                    end end), decl.type_newtype_level)
            };
    end
     end 
  end
   end 
  path$prime = normalize_path$1(undefined, env, path);
  if (same(path, path$prime)) then do
    throw Caml_builtin_exceptions.not_found;
  end
   end 
  return --[[ tuple ]]{
          decl.type_params,
          newty2(100000000, --[[ Tconstr ]]Block.__(3, {
                  path$prime,
                  decl.type_params,
                  do
                    contents: --[[ Mnil ]]0
                  end
                })),
          may_map((function (prim) do
                  return prim[1];
                end end), decl.type_newtype_level)
        };
end end

function find_type_expansion_opt(path, env) do
  decl = find_type_full(path, env)[0];
  match = decl.type_manifest;
  if (match ~= undefined) then do
    return --[[ tuple ]]{
            decl.type_params,
            match,
            may_map((function (prim) do
                    return prim[1];
                  end end), decl.type_newtype_level)
          };
  end else do
    path$prime = normalize_path$1(undefined, env, path);
    if (same(path, path$prime)) then do
      throw Caml_builtin_exceptions.not_found;
    end
     end 
    return --[[ tuple ]]{
            decl.type_params,
            newty2(100000000, --[[ Tconstr ]]Block.__(3, {
                    path$prime,
                    decl.type_params,
                    do
                      contents: --[[ Mnil ]]0
                    end
                  })),
            may_map((function (prim) do
                    return prim[1];
                  end end), decl.type_newtype_level)
          };
  end end 
end end

function find_modtype_expansion(path, env) do
  match = find_modtype(path, env).mtd_type;
  if (match ~= undefined) then do
    return match;
  end else do
    throw Caml_builtin_exceptions.not_found;
  end end 
end end

function is_functor_arg(_path, env) do
  while(true) do
    path = _path;
    local ___conditional___=(path.tag | 0);
    do
       if ___conditional___ = 0--[[ Pident ]] then do
          try do
            find_same(path[0], env.functor_args);
            return true;
          end
          catch (exn)do
            if (exn == Caml_builtin_exceptions.not_found) then do
              return false;
            end else do
              throw exn;
            end end 
          endend end end 
       if ___conditional___ = 1--[[ Pdot ]] then do
          _path = path[0];
          continue ;end end end 
       if ___conditional___ = 2--[[ Papply ]] then do
          return true;end end end 
       do
      
    end
  end;
end end

Recmodule = Caml_exceptions.create("Ocaml_typedtree_test.Env.Recmodule");

function lookup_module_descr(lid, env) do
  local ___conditional___=(lid.tag | 0);
  do
     if ___conditional___ = 0--[[ Lident ]] then do
        s = lid[0];
        try do
          return find_name$1(s, env.components);
        end
        catch (exn)do
          if (exn == Caml_builtin_exceptions.not_found) then do
            if (s == current_unit.contents) then do
              throw Caml_builtin_exceptions.not_found;
            end
             end 
            ps = find_pers_struct(undefined, s);
            return --[[ tuple ]]{
                    --[[ Pident ]]Block.__(0, {do
                          stamp: 0,
                          name: s,
                          flags: 1
                        end}),
                    ps.ps_comps
                  };
          end else do
            throw exn;
          end end 
        endend end end 
     if ___conditional___ = 1--[[ Ldot ]] then do
        s$1 = lid[1];
        match = lookup_module_descr(lid[0], env);
        match$1 = force(components_of_module_maker$prime.contents, match[1]);
        if (match$1.tag) then do
          throw Caml_builtin_exceptions.not_found;
        end else do
          match$2 = find$2(s$1, match$1[0].comp_components);
          return --[[ tuple ]]{
                  --[[ Pdot ]]Block.__(1, {
                      match[0],
                      s$1,
                      match$2[1]
                    }),
                  match$2[0]
                };
        end end end end end 
     if ___conditional___ = 2--[[ Lapply ]] then do
        match$3 = lookup_module_descr(lid[0], env);
        p1 = match$3[0];
        p2 = lookup_module(true, lid[1], env);
        match$4 = find_module(false, p2, env);
        match$5 = force(components_of_module_maker$prime.contents, match$3[1]);
        if (match$5.tag) then do
          f = match$5[0];
          may(Curry._3(check_modtype_inclusion.contents, env, match$4.md_type, p2), f.fcomp_arg);
          return --[[ tuple ]]{
                  --[[ Papply ]]Block.__(2, {
                      p1,
                      p2
                    }),
                  Curry._3(components_of_functor_appl$prime.contents, f, p1, p2)
                };
        end else do
          throw Caml_builtin_exceptions.not_found;
        end end end end end 
     do
    
  end
end end

function lookup_module(load, lid, env) do
  local ___conditional___=(lid.tag | 0);
  do
     if ___conditional___ = 0--[[ Lident ]] then do
        s = lid[0];
        try do
          r = find_name$1(s, env.modules);
          md_type = r[1].md_type;
          if (not md_type.tag) then do
            match = md_type[0];
            local ___conditional___=(match.tag | 0);
            do
               if ___conditional___ = 0--[[ Pident ]] then do
                  if (match[0].name == "#recmod#") then do
                    throw Recmodule;
                  end
                   end end else 
               if ___conditional___ = 1--[[ Pdot ]]
               or ___conditional___ = 2--[[ Papply ]]
               do end end
              
            end
          end
           end 
          return r[0];
        end
        catch (exn)do
          if (exn == Caml_builtin_exceptions.not_found) then do
            if (s == current_unit.contents) then do
              throw Caml_builtin_exceptions.not_found;
            end
             end 
            if (transparent_modules.contents and not load) then do
              try do
                find_pers_struct(false, s);
              end
              catch (exn$1)do
                if (exn$1 == Caml_builtin_exceptions.not_found) then do
                  prerr_warning(none, --[[ No_cmi_file ]]Block.__(32, {s}));
                end else do
                  throw exn$1;
                end end 
              end
            end else do
              find_pers_struct(undefined, s);
            end end 
            return --[[ Pident ]]Block.__(0, {do
                        stamp: 0,
                        name: s,
                        flags: 1
                      end});
          end else do
            throw exn;
          end end 
        endend end end 
     if ___conditional___ = 1--[[ Ldot ]] then do
        s$1 = lid[1];
        match$1 = lookup_module_descr(lid[0], env);
        match$2 = force(components_of_module_maker$prime.contents, match$1[1]);
        if (match$2.tag) then do
          throw Caml_builtin_exceptions.not_found;
        end else do
          match$3 = find$2(s$1, match$2[0].comp_modules);
          return --[[ Pdot ]]Block.__(1, {
                    match$1[0],
                    s$1,
                    match$3[1]
                  });
        end end end end end 
     if ___conditional___ = 2--[[ Lapply ]] then do
        match$4 = lookup_module_descr(lid[0], env);
        p2 = lookup_module(true, lid[1], env);
        match$5 = find_module(false, p2, env);
        p_000 = match$4[0];
        p = --[[ Papply ]]Block.__(2, {
            p_000,
            p2
          });
        match$6 = force(components_of_module_maker$prime.contents, match$4[1]);
        if (match$6.tag) then do
          may(Curry._3(check_modtype_inclusion.contents, env, match$5.md_type, p2), match$6[0].fcomp_arg);
          return p;
        end else do
          throw Caml_builtin_exceptions.not_found;
        end end end end end 
     do
    
  end
end end

function lookup(proj1, proj2, lid, env) do
  local ___conditional___=(lid.tag | 0);
  do
     if ___conditional___ = 0--[[ Lident ]] then do
        return find_name$1(lid[0], Curry._1(proj1, env));end end end 
     if ___conditional___ = 1--[[ Ldot ]] then do
        s = lid[1];
        match = lookup_module_descr(lid[0], env);
        match$1 = force(components_of_module_maker$prime.contents, match[1]);
        if (match$1.tag) then do
          throw Caml_builtin_exceptions.not_found;
        end else do
          match$2 = find$2(s, Curry._1(proj2, match$1[0]));
          return --[[ tuple ]]{
                  --[[ Pdot ]]Block.__(1, {
                      match[0],
                      s,
                      match$2[1]
                    }),
                  match$2[0]
                };
        end end end end end 
     if ___conditional___ = 2--[[ Lapply ]] then do
        throw Caml_builtin_exceptions.not_found;end end end 
     do
    
  end
end end

function lookup_all_simple(proj1, proj2, shadow, lid, env) do
  local ___conditional___=(lid.tag | 0);
  do
     if ___conditional___ = 0--[[ Lident ]] then do
        xl = find_all(lid[0], Curry._1(proj1, env));
        do_shadow = function (param) do
          if (param) then do
            match = param[0];
            x = match[0];
            return --[[ :: ]]{
                    --[[ tuple ]]{
                      x,
                      match[1]
                    },
                    do_shadow(List.filter((function (param) do
                                  return not Curry._2(shadow, x, param[0]);
                                end end))(param[1]))
                  };
          end else do
            return --[[ [] ]]0;
          end end 
        end end;
        return do_shadow(xl);end end end 
     if ___conditional___ = 1--[[ Ldot ]] then do
        match = lookup_module_descr(lid[0], env);
        match$1 = force(components_of_module_maker$prime.contents, match[1]);
        if (match$1.tag) then do
          throw Caml_builtin_exceptions.not_found;
        end else do
          comps;
          try do
            comps = find$2(lid[1], Curry._1(proj2, match$1[0]));
          end
          catch (exn)do
            if (exn == Caml_builtin_exceptions.not_found) then do
              comps = --[[ [] ]]0;
            end else do
              throw exn;
            end end 
          end
          return List.map((function (param) do
                        return --[[ tuple ]]{
                                param[0],
                                (function (param) do
                                    return --[[ () ]]0;
                                  end end)
                              };
                      end end), comps);
        end end end end end 
     if ___conditional___ = 2--[[ Lapply ]] then do
        throw Caml_builtin_exceptions.not_found;end end end 
     do
    
  end
end end

function cstr_shadow(cstr1, cstr2) do
  match = cstr1.cstr_tag;
  match$1 = cstr2.cstr_tag;
  local ___conditional___=(match.tag | 0);
  do
     if ___conditional___ = 0--[[ Cstr_constant ]]
     or ___conditional___ = 1--[[ Cstr_block ]] then do
        return false;end end end 
     if ___conditional___ = 2--[[ Cstr_extension ]] then do
        local ___conditional___=(match$1.tag | 0);
        do
           if ___conditional___ = 0--[[ Cstr_constant ]]
           or ___conditional___ = 1--[[ Cstr_block ]] then do
              return false;end end end 
           if ___conditional___ = 2--[[ Cstr_extension ]] then do
              return true;end end end 
           do
          
        endend end end 
     do
    
  end
end end

function lbl_shadow(lbl1, lbl2) do
  return false;
end end

function lookup_value(param, param$1) do
  return lookup((function (env) do
                return env.values;
              end end), (function (sc) do
                return sc.comp_values;
              end end), param, param$1);
end end

function lookup_all_constructors(param, param$1) do
  return lookup_all_simple((function (env) do
                return env.constrs;
              end end), (function (sc) do
                return sc.comp_constrs;
              end end), cstr_shadow, param, param$1);
end end

function lookup_all_labels(param, param$1) do
  return lookup_all_simple((function (env) do
                return env.labels;
              end end), (function (sc) do
                return sc.comp_labels;
              end end), lbl_shadow, param, param$1);
end end

function lookup_type(param, param$1) do
  return lookup((function (env) do
                return env.types;
              end end), (function (sc) do
                return sc.comp_types;
              end end), param, param$1);
end end

function lookup_modtype(param, param$1) do
  return lookup((function (env) do
                return env.modtypes;
              end end), (function (sc) do
                return sc.comp_modtypes;
              end end), param, param$1);
end end

function lookup_class(param, param$1) do
  return lookup((function (env) do
                return env.classes;
              end end), (function (sc) do
                return sc.comp_classes;
              end end), param, param$1);
end end

function lookup_cltype(param, param$1) do
  return lookup((function (env) do
                return env.cltypes;
              end end), (function (sc) do
                return sc.comp_cltypes;
              end end), param, param$1);
end end

function mark_value_used(env, name, vd) do
  if (is_implicit_coercion(env)) then do
    return 0;
  end else do
    try do
      return Curry._1(Hashtbl.find(value_declarations, --[[ tuple ]]{
                      name,
                      vd.val_loc
                    }), --[[ () ]]0);
    end
    catch (exn)do
      if (exn == Caml_builtin_exceptions.not_found) then do
        return --[[ () ]]0;
      end else do
        throw exn;
      end end 
    end
  end end 
end end

function mark_type_used(env, name, vd) do
  if (is_implicit_coercion(env)) then do
    return 0;
  end else do
    try do
      return Curry._1(Hashtbl.find(type_declarations, --[[ tuple ]]{
                      name,
                      vd.type_loc
                    }), --[[ () ]]0);
    end
    catch (exn)do
      if (exn == Caml_builtin_exceptions.not_found) then do
        return --[[ () ]]0;
      end else do
        throw exn;
      end end 
    end
  end end 
end end

function mark_constructor_used(usage, env, name, vd, constr) do
  if (is_implicit_coercion(env)) then do
    return 0;
  end else do
    try do
      return Curry._1(Hashtbl.find(used_constructors, --[[ tuple ]]{
                      name,
                      vd.type_loc,
                      constr
                    }), usage);
    end
    catch (exn)do
      if (exn == Caml_builtin_exceptions.not_found) then do
        return --[[ () ]]0;
      end else do
        throw exn;
      end end 
    end
  end end 
end end

function mark_extension_used(usage, env, ext, name) do
  if (is_implicit_coercion(env)) then do
    return 0;
  end else do
    ty_name = last(ext.ext_type_path);
    try do
      return Curry._1(Hashtbl.find(used_constructors, --[[ tuple ]]{
                      ty_name,
                      ext.ext_loc,
                      name
                    }), usage);
    end
    catch (exn)do
      if (exn == Caml_builtin_exceptions.not_found) then do
        return --[[ () ]]0;
      end else do
        throw exn;
      end end 
    end
  end end 
end end

function set_type_used_callback(name, td, callback) do
  loc = td.type_loc;
  if (loc.loc_ghost) then do
    return --[[ () ]]0;
  end else do
    key = --[[ tuple ]]{
      name,
      loc
    };
    old;
    try do
      old = Hashtbl.find(type_declarations, key);
    end
    catch (exn)do
      if (exn == Caml_builtin_exceptions.not_found) then do
        throw {
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "env.ml",
                841,
                22
              }
            };
      end
       end 
      throw exn;
    end
    return Hashtbl.replace(type_declarations, key, (function (param) do
                  return Curry._1(callback, old);
                end end));
  end end 
end end

function lookup_value$1(lid, env) do
  r = lookup_value(lid, env);
  mark_value_used(env, last$1(lid), r[1]);
  return r;
end end

function lookup_type$1(lid, env) do
  match = lookup_type(lid, env);
  decl = match[1][0];
  mark_type_used(env, last$1(lid), decl);
  return --[[ tuple ]]{
          match[0],
          decl
        };
end end

function mark_type_path(env, path) do
  try do
    decl = find_type_full(path, env)[0];
    return mark_type_used(env, last(path), decl);
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return --[[ () ]]0;
    end else do
      throw exn;
    end end 
  end
end end

function ty_path(t) do
  match = repr(t);
  match$1 = match.desc;
  if (typeof match$1 == "number") then do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "env.ml",
            871,
            9
          }
        };
  end else if (match$1.tag == --[[ Tconstr ]]3) then do
    return match$1[0];
  end else do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "env.ml",
            871,
            9
          }
        };
  end end  end 
end end

function lookup_constructor(lid, env) do
  match = lookup_all_constructors(lid, env);
  if (match) then do
    match$1 = match[0];
    desc = match$1[0];
    mark_type_path(env, ty_path(desc.cstr_res));
    Curry._1(match$1[1], --[[ () ]]0);
    return desc;
  end else do
    throw Caml_builtin_exceptions.not_found;
  end end 
end end

function is_lident(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Lident ]] then do
        return true;end end end 
     if ___conditional___ = 1--[[ Ldot ]]
     or ___conditional___ = 2--[[ Lapply ]] then do
        return false;end end end 
     do
    
  end
end end

function lookup_all_constructors$1(lid, env) do
  try do
    cstrs = lookup_all_constructors(lid, env);
    return List.map((function (param) do
                  use = param[1];
                  cstr = param[0];
                  return --[[ tuple ]]{
                          cstr,
                          (function (param) do
                              desc = cstr;
                              use$1 = use;
                              mark_type_path(env, ty_path(desc.cstr_res));
                              return Curry._1(use$1, --[[ () ]]0);
                            end end)
                        };
                end end), cstrs);
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      if (is_lident(lid)) then do
        return --[[ [] ]]0;
      end else do
        throw exn;
      end end 
    end else do
      throw exn;
    end end 
  end
end end

function mark_constructor(usage, env, name, desc) do
  if (is_implicit_coercion(env)) then do
    return 0;
  end else do
    match = desc.cstr_tag;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 0--[[ Cstr_constant ]]
       or ___conditional___ = 1--[[ Cstr_block ]]
       or ___conditional___ = 2--[[ Cstr_extension ]] then do
          ty_path$1 = ty_path(desc.cstr_res);
          ty_name = last(ty_path$1);
          try do
            return Curry._1(Hashtbl.find(used_constructors, --[[ tuple ]]{
                            ty_name,
                            desc.cstr_loc,
                            name
                          }), usage);
          end
          catch (exn)do
            if (exn == Caml_builtin_exceptions.not_found) then do
              return --[[ () ]]0;
            end else do
              throw exn;
            end end 
          endend end end 
       do
      
    end
    ty_path$2 = ty_path(desc.cstr_res);
    ty_decl;
    try do
      ty_decl = find_type_full(ty_path$2, env)[0];
    end
    catch (exn$1)do
      if (exn$1 == Caml_builtin_exceptions.not_found) then do
        throw {
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "env.ml",
                908,
                64
              }
            };
      end
       end 
      throw exn$1;
    end
    ty_name$1 = last(ty_path$2);
    return mark_constructor_used(usage, env, ty_name$1, ty_decl, name);
  end end 
end end

function lookup_all_labels$1(lid, env) do
  try do
    lbls = lookup_all_labels(lid, env);
    return List.map((function (param) do
                  use = param[1];
                  lbl = param[0];
                  return --[[ tuple ]]{
                          lbl,
                          (function (param) do
                              desc = lbl;
                              use$1 = use;
                              mark_type_path(env, ty_path(desc.lbl_res));
                              return Curry._1(use$1, --[[ () ]]0);
                            end end)
                        };
                end end), lbls);
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      if (is_lident(lid)) then do
        return --[[ [] ]]0;
      end else do
        throw exn;
      end end 
    end else do
      throw exn;
    end end 
  end
end end

function lookup_class$1(lid, env) do
  r = lookup_class(lid, env);
  desc = r[1];
  if (name(undefined, desc.cty_path) == "") then do
    lookup_type$1(lid, env);
  end else do
    mark_type_path(env, desc.cty_path);
  end end 
  return r;
end end

function lookup_cltype$1(lid, env) do
  r = lookup_cltype(lid, env);
  desc = r[1];
  if (name(undefined, desc.clty_path) == "") then do
    lookup_type$1(lid, env);
  end else do
    mark_type_path(env, desc.clty_path);
  end end 
  mark_type_path(env, desc.clty_path);
  return r;
end end

iter_env_cont = do
  contents: --[[ [] ]]0
end;

function scrape_alias_safe(env, _mty) do
  while(true) do
    mty = _mty;
    if (mty.tag == --[[ Mty_alias ]]3) then do
      path = mty[0];
      local ___conditional___=(path.tag | 0);
      do
         if ___conditional___ = 0--[[ Pident ]] then do
            if (path[0].stamp == 0) then do
              return false;
            end
             end end else 
         if ___conditional___ = 1--[[ Pdot ]]
         or ___conditional___ = 2--[[ Papply ]]
         do end end
        
      end
      _mty = find_module(false, path, env).md_type;
      continue ;
    end else do
      return true;
    end end 
  end;
end end

function run_iter_cont(l) do
  iter_env_cont.contents = --[[ [] ]]0;
  List.iter((function (c) do
          return Curry._1(c, --[[ () ]]0);
        end end), l);
  cont = List.rev(iter_env_cont.contents);
  iter_env_cont.contents = --[[ [] ]]0;
  return cont;
end end

function iter_types(f) do
  return (function (param, param$1) do
      proj1 = function (env) do
        return env.types;
      end end;
      proj2 = function (sc) do
        return sc.comp_types;
      end end;
      f$1 = f;
      env = param;
      iter((function (id, param) do
              return Curry._2(f$1, --[[ Pident ]]Block.__(0, {id}), param[0]);
            end end), Curry._1(proj1, env));
      iter_components = function (path, path$prime, mcomps) do
        cont = function (param) do
          match = get_arg(mcomps);
          safe;
          if (match ~= undefined) then do
            match$1 = match;
            try do
              safe = scrape_alias_safe(match$1[0], match$1[3]);
            end
            catch (exn)do
              if (exn == Caml_builtin_exceptions.not_found) then do
                safe = false;
              end else do
                throw exn;
              end end 
            end
          end else do
            safe = true;
          end end 
          if (safe) then do
            match$2 = force(components_of_module_maker$prime.contents, mcomps);
            if (match$2.tag) then do
              return --[[ () ]]0;
            end else do
              comps = match$2[0];
              iter$2((function (s, param) do
                      n = param[1];
                      return Curry._2(f$1, --[[ Pdot ]]Block.__(1, {
                                    path,
                                    s,
                                    n
                                  }), --[[ tuple ]]{
                                  --[[ Pdot ]]Block.__(1, {
                                      path$prime,
                                      s,
                                      n
                                    }),
                                  param[0]
                                });
                    end end), Curry._1(proj2, comps));
              return iter$2((function (s, param) do
                            n = param[1];
                            return iter_components(--[[ Pdot ]]Block.__(1, {
                                          path,
                                          s,
                                          n
                                        }), --[[ Pdot ]]Block.__(1, {
                                          path$prime,
                                          s,
                                          n
                                        }), param[0]);
                          end end), comps.comp_components);
            end end 
          end else do
            return --[[ () ]]0;
          end end 
        end end;
        iter_env_cont.contents = --[[ :: ]]{
          --[[ tuple ]]{
            path,
            cont
          },
          iter_env_cont.contents
        };
        return --[[ () ]]0;
      end end;
      Hashtbl.iter((function (s, pso) do
              if (pso ~= undefined) then do
                id = --[[ Pident ]]Block.__(0, {do
                      stamp: 0,
                      name: s,
                      flags: 1
                    end});
                return iter_components(id, id, pso.ps_comps);
              end else do
                return --[[ () ]]0;
              end end 
            end end), persistent_structures);
      return iter((function (id, param) do
                    match = param[0];
                    return iter_components(--[[ Pident ]]Block.__(0, {id}), match[0], match[1]);
                  end end), env.components);
    end end);
end end

function same_types(env1, env2) do
  if (env1.types == env2.types) then do
    return env1.components == env2.components;
  end else do
    return false;
  end end 
end end

function used_persistent(param) do
  r = do
    contents: --[[ Empty ]]0
  end;
  Hashtbl.iter((function (s, pso) do
          if (pso ~= undefined) then do
            r.contents = add$2(s, r.contents);
            return --[[ () ]]0;
          end else do
            return 0;
          end end 
        end end), persistent_structures);
  return r.contents;
end end

function find_all_comps(proj, s, param) do
  match = force(components_of_module_maker$prime.contents, param[1]);
  if (match.tag) then do
    return --[[ [] ]]0;
  end else do
    try do
      match$1 = find$2(s, Curry._1(proj, match[0]));
      return --[[ :: ]]{
              --[[ tuple ]]{
                --[[ Pdot ]]Block.__(1, {
                    param[0],
                    s,
                    match$1[1]
                  }),
                match$1[0]
              },
              --[[ [] ]]0
            };
    end
    catch (exn)do
      if (exn == Caml_builtin_exceptions.not_found) then do
        return --[[ [] ]]0;
      end else do
        throw exn;
      end end 
    end
  end end 
end end

function find_shadowed_comps(path, env) do
  local ___conditional___=(path.tag | 0);
  do
     if ___conditional___ = 0--[[ Pident ]] then do
        return List.map((function (prim) do
                      return prim[0];
                    end end), find_all(path[0].name, env.components));end end end 
     if ___conditional___ = 1--[[ Pdot ]] then do
        s = path[1];
        l = find_shadowed_comps(path[0], env);
        return List.flatten(List.map((function (param) do
                          return find_all_comps((function (comps) do
                                        return comps.comp_components;
                                      end end), s, param);
                        end end), l));end end end 
     if ___conditional___ = 2--[[ Papply ]] then do
        return --[[ [] ]]0;end end end 
     do
    
  end
end end

function find_shadowed(proj1, proj2, path, env) do
  local ___conditional___=(path.tag | 0);
  do
     if ___conditional___ = 0--[[ Pident ]] then do
        return List.map((function (prim) do
                      return prim[0];
                    end end), find_all(path[0].name, Curry._1(proj1, env)));end end end 
     if ___conditional___ = 1--[[ Pdot ]] then do
        s = path[1];
        l = find_shadowed_comps(path[0], env);
        return List.flatten(List.map((function (param) do
                          return find_all_comps(proj2, s, param);
                        end end), l));end end end 
     if ___conditional___ = 2--[[ Papply ]] then do
        return --[[ [] ]]0;end end end 
     do
    
  end
end end

function find_shadowed_types(path, env) do
  l = find_shadowed((function (env) do
          return env.types;
        end end), (function (comps) do
          return comps.comp_types;
        end end), path, env);
  return List.map((function (prim) do
                return prim[0];
              end end), l);
end end

function add_gadt_instance_level(lv, env) do
  return do
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: env.summary,
          local_constraints: env.local_constraints,
          gadt_instances: --[[ :: ]]{
            --[[ tuple ]]{
              lv,
              do
                contents: --[[ Empty ]]0
              end
            },
            env.gadt_instances
          },
          flags: env.flags
        end;
end end

function is_Tlink(param) do
  match = param.desc;
  if (typeof match == "number" or match.tag ~= --[[ Tlink ]]6) then do
    return false;
  end else do
    return true;
  end end 
end end

function gadt_instance_level(env, t) do
  _param = env.gadt_instances;
  while(true) do
    param = _param;
    if (param) then do
      match = param[0];
      r = match[1];
      if (exists(is_Tlink, r.contents)) then do
        r.contents = fold$2((function (ty) do
                partial_arg = repr(ty);
                return (function (param) do
                    return add$3(partial_arg, param);
                  end end);
              end end), r.contents, --[[ Empty ]]0);
      end
       end 
      if (mem$3(t, r.contents)) then do
        return Caml_option.some(match[0]);
      end else do
        _param = param[1];
        continue ;
      end end 
    end else do
      return ;
    end end 
  end;
end end

function add_gadt_instances(env, lv, tl) do
  r;
  try do
    r = List.assoc(lv, env.gadt_instances);
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "env.ml",
              1066,
              59
            }
          };
    end
     end 
    throw exn;
  end
  return set_typeset(r, List.fold_right(add$3, tl, r.contents));
end end

function add_gadt_instance_chain(env, lv, t) do
  r;
  try do
    r = List.assoc(lv, env.gadt_instances);
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "env.ml",
              1075,
              59
            }
          };
    end
     end 
    throw exn;
  end
  add_instance = function (t) do
    t$1 = repr(t);
    if (mem$3(t$1, r.contents)) then do
      return 0;
    end else do
      set_typeset(r, add$3(t$1, r.contents));
      match = t$1.desc;
      if (typeof match == "number" or match.tag ~= --[[ Tconstr ]]3) then do
        return --[[ () ]]0;
      end else do
        return may(add_instance, find_expans(--[[ Private ]]0, match[0], match[2].contents));
      end end 
    end end 
  end end;
  return add_instance(t);
end end

function scrape_alias(env, path, mty) do
  local ___conditional___=(mty.tag | 0);
  do
     if ___conditional___ = 0--[[ Mty_ident ]] then do
        try do
          return scrape_alias(env, path, find_modtype_expansion(mty[0], env));
        end
        catch (exn)do
          if (exn == Caml_builtin_exceptions.not_found) then do
            return mty;
          end else do
            throw exn;
          end end 
        endend end end 
     if ___conditional___ = 1--[[ Mty_signature ]]
     or ___conditional___ = 2--[[ Mty_functor ]]
     or ___conditional___ = 3--[[ Mty_alias ]] then do
        path$1 = mty[0];
        try do
          return scrape_alias(env, path$1, find_module(false, path$1, env).md_type);
        end
        catch (exn$1)do
          if (exn$1 == Caml_builtin_exceptions.not_found) then do
            return mty;
          end else do
            throw exn$1;
          end end 
        endend end end 
     do
    
  end
  if (path ~= undefined) then do
    return Curry._3(strengthen.contents, env, mty, path);
  end else do
    return mty;
  end end 
end end

function constructors_of_type(ty_path, decl) do
  match = decl.type_kind;
  if (typeof match == "number" or match.tag ~= --[[ Type_variant ]]1) then do
    return --[[ [] ]]0;
  end else do
    cstrs = match[0];
    ty_res = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
            ty_path,
            decl.type_params,
            do
              contents: --[[ Mnil ]]0
            end
          }));
    cstrs$1 = cstrs;
    priv = decl.type_private;
    num_consts = do
      contents: 0
    end;
    num_nonconsts = do
      contents: 0
    end;
    num_normal = do
      contents: 0
    end;
    List.iter((function (param) do
            if (param.cd_args == --[[ [] ]]0) then do
              num_consts.contents = num_consts.contents + 1 | 0;
            end else do
              num_nonconsts.contents = num_nonconsts.contents + 1 | 0;
            end end 
            if (param.cd_res == undefined) then do
              num_normal.contents = num_normal.contents + 1 | 0;
              return --[[ () ]]0;
            end else do
              return 0;
            end end 
          end end), cstrs$1);
    describe_constructors = function (idx_const, idx_nonconst, param) do
      if (param) then do
        rem = param[1];
        match = param[0];
        cd_res = match.cd_res;
        cd_args = match.cd_args;
        cd_id = match.cd_id;
        ty_res$1 = cd_res ~= undefined and cd_res or ty_res;
        match$1 = cd_args and --[[ tuple ]]{
            --[[ Cstr_block ]]Block.__(1, {idx_nonconst}),
            describe_constructors(idx_const, idx_nonconst + 1 | 0, rem)
          } or --[[ tuple ]]{
            --[[ Cstr_constant ]]Block.__(0, {idx_const}),
            describe_constructors(idx_const + 1 | 0, idx_nonconst, rem)
          };
        existentials;
        if (cd_res ~= undefined) then do
          res_vars = free_vars(cd_res);
          arg_vars = free_vars(newty2(100000000, --[[ Ttuple ]]Block.__(2, {cd_args})));
          existentials = elements_aux$1(--[[ [] ]]0, diff$1(arg_vars, res_vars));
        end else do
          existentials = --[[ [] ]]0;
        end end 
        cstr_cstr_name = cd_id.name;
        cstr_cstr_arity = List.length(cd_args);
        cstr_cstr_tag = match$1[0];
        cstr_cstr_consts = num_consts.contents;
        cstr_cstr_nonconsts = num_nonconsts.contents;
        cstr_cstr_normal = num_normal.contents;
        cstr_cstr_generalized = cd_res ~= undefined;
        cstr_cstr_loc = match.cd_loc;
        cstr_cstr_attributes = match.cd_attributes;
        cstr = do
          cstr_name: cstr_cstr_name,
          cstr_res: ty_res$1,
          cstr_existentials: existentials,
          cstr_args: cd_args,
          cstr_arity: cstr_cstr_arity,
          cstr_tag: cstr_cstr_tag,
          cstr_consts: cstr_cstr_consts,
          cstr_nonconsts: cstr_cstr_nonconsts,
          cstr_normal: cstr_cstr_normal,
          cstr_generalized: cstr_cstr_generalized,
          cstr_private: priv,
          cstr_loc: cstr_cstr_loc,
          cstr_attributes: cstr_cstr_attributes
        end;
        return --[[ :: ]]{
                --[[ tuple ]]{
                  cd_id,
                  cstr
                },
                match$1[1]
              };
      end else do
        return --[[ [] ]]0;
      end end 
    end end;
    result = describe_constructors(0, 0, cstrs$1);
    a_id;
    a_descr;
    b_id;
    b_descr;
    if (result) then do
      match$1 = result[0];
      a_id$1 = match$1[0];
      local ___conditional___=(a_id$1.name);
      do
         if ___conditional___ = "None" then do
            a_descr$1 = match$1[1];
            if (a_descr$1.cstr_args) then do
              return result;
            end else do
              match$2 = result[1];
              if (match$2) then do
                match$3 = match$2[0];
                b_id$1 = match$3[0];
                if (b_id$1.name == "Some") then do
                  b_descr$1 = match$3[1];
                  match$4 = b_descr$1.cstr_args;
                  if (match$4 and not (match$4[1] or match$2[1])) then do
                    a_id = a_id$1;
                    a_descr = a_descr$1;
                    b_id = b_id$1;
                    b_descr = b_descr$1;
                  end else do
                    return result;
                  end end 
                end else do
                  return result;
                end end 
              end else do
                return result;
              end end 
            end end end else 
         if ___conditional___ = "Some" then do
            a_descr$2 = match$1[1];
            match$5 = a_descr$2.cstr_args;
            if (match$5 and not match$5[1]) then do
              match$6 = result[1];
              if (match$6) then do
                match$7 = match$6[0];
                b_id$2 = match$7[0];
                if (b_id$2.name == "None") then do
                  b_descr$2 = match$7[1];
                  if (b_descr$2.cstr_args or match$6[1]) then do
                    return result;
                  end else do
                    a_id = a_id$1;
                    a_descr = a_descr$2;
                    b_id = b_id$2;
                    b_descr = b_descr$2;
                  end end 
                end else do
                  return result;
                end end 
              end else do
                return result;
              end end 
            end else do
              return result;
            end end end else 
         do end end end
        else do
          return result;
          end end
          
      end
    end else do
      return result;
    end end 
    return --[[ :: ]]{
            --[[ tuple ]]{
              a_id,
              do
                cstr_name: a_descr.cstr_name,
                cstr_res: a_descr.cstr_res,
                cstr_existentials: a_descr.cstr_existentials,
                cstr_args: a_descr.cstr_args,
                cstr_arity: a_descr.cstr_arity,
                cstr_tag: a_descr.cstr_tag,
                cstr_consts: a_descr.cstr_consts,
                cstr_nonconsts: a_descr.cstr_nonconsts,
                cstr_normal: a_descr.cstr_normal,
                cstr_generalized: a_descr.cstr_generalized,
                cstr_private: a_descr.cstr_private,
                cstr_loc: a_descr.cstr_loc,
                cstr_attributes: --[[ :: ]]{
                  optional_shape,
                  a_descr.cstr_attributes
                }
              end
            },
            --[[ :: ]]{
              --[[ tuple ]]{
                b_id,
                do
                  cstr_name: b_descr.cstr_name,
                  cstr_res: b_descr.cstr_res,
                  cstr_existentials: b_descr.cstr_existentials,
                  cstr_args: b_descr.cstr_args,
                  cstr_arity: b_descr.cstr_arity,
                  cstr_tag: b_descr.cstr_tag,
                  cstr_consts: b_descr.cstr_consts,
                  cstr_nonconsts: b_descr.cstr_nonconsts,
                  cstr_normal: b_descr.cstr_normal,
                  cstr_generalized: b_descr.cstr_generalized,
                  cstr_private: b_descr.cstr_private,
                  cstr_loc: b_descr.cstr_loc,
                  cstr_attributes: --[[ :: ]]{
                    optional_shape,
                    b_descr.cstr_attributes
                  }
                end
              },
              --[[ [] ]]0
            }
          };
  end end 
end end

function labels_of_type(ty_path, decl) do
  match = decl.type_kind;
  if (typeof match == "number" or match.tag) then do
    return --[[ [] ]]0;
  end else do
    ty_res = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
            ty_path,
            decl.type_params,
            do
              contents: --[[ Mnil ]]0
            end
          }));
    lbls = match[0];
    repres = match[1];
    priv = decl.type_private;
    all_labels = Caml_array.caml_make_vect(List.length(lbls), dummy_label);
    describe_labels = function (num, param) do
      if (param) then do
        l = param[0];
        lbl_lbl_name = l.ld_id.name;
        lbl_lbl_arg = l.ld_type;
        lbl_lbl_mut = l.ld_mutable;
        lbl_lbl_loc = l.ld_loc;
        lbl_lbl_attributes = l.ld_attributes;
        lbl = do
          lbl_name: lbl_lbl_name,
          lbl_res: ty_res,
          lbl_arg: lbl_lbl_arg,
          lbl_mut: lbl_lbl_mut,
          lbl_pos: num,
          lbl_all: all_labels,
          lbl_repres: repres,
          lbl_private: priv,
          lbl_loc: lbl_lbl_loc,
          lbl_attributes: lbl_lbl_attributes
        end;
        Caml_array.caml_array_set(all_labels, num, lbl);
        return --[[ :: ]]{
                --[[ tuple ]]{
                  l.ld_id,
                  lbl
                },
                describe_labels(num + 1 | 0, param[1])
              };
      end else do
        return --[[ [] ]]0;
      end end 
    end end;
    return describe_labels(0, lbls);
  end end 
end end

function prefix_idents(root, pos, sub, param) do
  if (param) then do
    match = param[0];
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 0--[[ Sig_value ]] then do
          p_001 = match[0].name;
          p = --[[ Pdot ]]Block.__(1, {
              root,
              p_001,
              pos
            });
          match$1 = match[1].val_kind;
          nextpos;
          nextpos = typeof match$1 == "number" or match$1.tag and pos + 1 | 0 or pos;
          match$2 = prefix_idents(root, nextpos, sub, param[1]);
          return --[[ tuple ]]{
                  --[[ :: ]]{
                    p,
                    match$2[0]
                  },
                  match$2[1]
                };end end end 
       if ___conditional___ = 1--[[ Sig_type ]] then do
          id = match[0];
          p_001$1 = id.name;
          p$1 = --[[ Pdot ]]Block.__(1, {
              root,
              p_001$1,
              -1
            });
          match$3 = prefix_idents(root, pos, add_type(id, p$1, sub), param[1]);
          return --[[ tuple ]]{
                  --[[ :: ]]{
                    p$1,
                    match$3[0]
                  },
                  match$3[1]
                };end end end 
       if ___conditional___ = 2--[[ Sig_typext ]] then do
          p_001$2 = match[0].name;
          p$2 = --[[ Pdot ]]Block.__(1, {
              root,
              p_001$2,
              pos
            });
          match$4 = prefix_idents(root, pos + 1 | 0, sub, param[1]);
          return --[[ tuple ]]{
                  --[[ :: ]]{
                    p$2,
                    match$4[0]
                  },
                  match$4[1]
                };end end end 
       if ___conditional___ = 3--[[ Sig_module ]] then do
          id$1 = match[0];
          p_001$3 = id$1.name;
          p$3 = --[[ Pdot ]]Block.__(1, {
              root,
              p_001$3,
              pos
            });
          match$5 = prefix_idents(root, pos + 1 | 0, add_module(id$1, p$3, sub), param[1]);
          return --[[ tuple ]]{
                  --[[ :: ]]{
                    p$3,
                    match$5[0]
                  },
                  match$5[1]
                };end end end 
       if ___conditional___ = 4--[[ Sig_modtype ]] then do
          id$2 = match[0];
          p_001$4 = id$2.name;
          p$4 = --[[ Pdot ]]Block.__(1, {
              root,
              p_001$4,
              -1
            });
          match$6 = prefix_idents(root, pos, add_modtype(id$2, --[[ Mty_ident ]]Block.__(0, {p$4}), sub), param[1]);
          return --[[ tuple ]]{
                  --[[ :: ]]{
                    p$4,
                    match$6[0]
                  },
                  match$6[1]
                };end end end 
       if ___conditional___ = 5--[[ Sig_class ]] then do
          p_001$5 = match[0].name;
          p$5 = --[[ Pdot ]]Block.__(1, {
              root,
              p_001$5,
              pos
            });
          match$7 = prefix_idents(root, pos + 1 | 0, sub, param[1]);
          return --[[ tuple ]]{
                  --[[ :: ]]{
                    p$5,
                    match$7[0]
                  },
                  match$7[1]
                };end end end 
       if ___conditional___ = 6--[[ Sig_class_type ]] then do
          p_001$6 = match[0].name;
          p$6 = --[[ Pdot ]]Block.__(1, {
              root,
              p_001$6,
              -1
            });
          match$8 = prefix_idents(root, pos, sub, param[1]);
          return --[[ tuple ]]{
                  --[[ :: ]]{
                    p$6,
                    match$8[0]
                  },
                  match$8[1]
                };end end end 
       do
      
    end
  end else do
    return --[[ tuple ]]{
            --[[ [] ]]0,
            sub
          };
  end end 
end end

function prefix_idents_and_subst(root, sub, sg) do
  match = prefix_idents(root, 0, sub, sg);
  sub$1 = match[1];
  return --[[ tuple ]]{
          match[0],
          sub$1,
          Caml_obj.caml_lazy_make((function (param) do
                  sub$2 = sub$1;
                  sg$1 = sg;
                  return List.map((function (item) do
                                local ___conditional___=(item.tag | 0);
                                do
                                   if ___conditional___ = 0--[[ Sig_value ]] then do
                                      return --[[ Sig_value ]]Block.__(0, {
                                                item[0],
                                                value_description(sub$2, item[1])
                                              });end end end 
                                   if ___conditional___ = 1--[[ Sig_type ]] then do
                                      return --[[ Sig_type ]]Block.__(1, {
                                                item[0],
                                                type_declaration(sub$2, item[1]),
                                                item[2]
                                              });end end end 
                                   if ___conditional___ = 2--[[ Sig_typext ]] then do
                                      return --[[ Sig_typext ]]Block.__(2, {
                                                item[0],
                                                extension_constructor(sub$2, item[1]),
                                                item[2]
                                              });end end end 
                                   if ___conditional___ = 3--[[ Sig_module ]] then do
                                      return --[[ Sig_module ]]Block.__(3, {
                                                item[0],
                                                module_declaration(sub$2, item[1]),
                                                item[2]
                                              });end end end 
                                   if ___conditional___ = 4--[[ Sig_modtype ]] then do
                                      return --[[ Sig_modtype ]]Block.__(4, {
                                                item[0],
                                                modtype_declaration(sub$2, item[1])
                                              });end end end 
                                   if ___conditional___ = 5--[[ Sig_class ]] then do
                                      return --[[ Sig_class ]]Block.__(5, {
                                                item[0],
                                                class_declaration(sub$2, item[1]),
                                                item[2]
                                              });end end end 
                                   if ___conditional___ = 6--[[ Sig_class_type ]] then do
                                      return --[[ Sig_class_type ]]Block.__(6, {
                                                item[0],
                                                cltype_declaration(sub$2, item[1]),
                                                item[2]
                                              });end end end 
                                   do
                                  
                                end
                              end end), sg$1);
                end end))
        };
end end

function prefix_idents_and_subst$1(root, sub, sg) do
  if (Caml_obj.caml_equal(sub, identity)) then do
    sgs;
    try do
      sgs = Hashtbl.find(prefixed_sg, root);
    end
    catch (exn)do
      if (exn == Caml_builtin_exceptions.not_found) then do
        sgs$1 = do
          contents: --[[ [] ]]0
        end;
        Hashtbl.add(prefixed_sg, root, sgs$1);
        sgs = sgs$1;
      end else do
        throw exn;
      end end 
    end
    try do
      return List.assq(sg, sgs.contents);
    end
    catch (exn$1)do
      if (exn$1 == Caml_builtin_exceptions.not_found) then do
        r = prefix_idents_and_subst(root, sub, sg);
        sgs.contents = --[[ :: ]]{
          --[[ tuple ]]{
            sg,
            r
          },
          sgs.contents
        };
        return r;
      end else do
        throw exn$1;
      end end 
    end
  end else do
    return prefix_idents_and_subst(root, sub, sg);
  end end 
end end

function add_to_tbl(id, decl, tbl) do
  decls;
  try do
    decls = find$2(id, tbl);
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      decls = --[[ [] ]]0;
    end else do
      throw exn;
    end end 
  end
  return add$5(id, --[[ :: ]]{
              decl,
              decls
            }, tbl);
end end

function components_of_module(env, sub, path, mty) do
  return do
          contents: --[[ Thunk ]]Block.__(2, {--[[ tuple ]]{
                env,
                sub,
                path,
                mty
              }})
        end;
end end

function check_usage(loc, id, warn, tbl) do
  if (not loc.loc_ghost and is_active(Curry._1(warn, ""))) then do
    name = id.name;
    key = --[[ tuple ]]{
      name,
      loc
    };
    if (Hashtbl.mem(tbl, key)) then do
      return --[[ () ]]0;
    end else do
      used = do
        contents: false
      end;
      Hashtbl.add(tbl, key, (function (param) do
              used.contents = true;
              return --[[ () ]]0;
            end end));
      if (name == "" or Caml_string.get(name, 0) == --[[ "_" ]]95 or Caml_string.get(name, 0) == --[[ "#" ]]35) then do
        return 0;
      end else do
        return Curry._1(add_delayed_check_forward.contents, (function (param) do
                      if (used.contents) then do
                        return 0;
                      end else do
                        return prerr_warning(loc, Curry._1(warn, name));
                      end end 
                    end end));
      end end 
    end end 
  end else do
    return 0;
  end end 
end end

function check_value_name(name, loc) do
  if (bs_only.contents and name == "|.") then do
    throw {
          __Error$2,
          --[[ Illegal_value_name ]]Block.__(4, {
              loc,
              name
            })
        };
  end
   end 
  if (#name ~= 0 and Caml_string.get(name, 0) == --[[ "#" ]]35) then do
    for i = 1 , #name - 1 | 0 , 1 do
      if (Caml_string.get(name, i) == --[[ "#" ]]35) then do
        throw {
              __Error$2,
              --[[ Illegal_value_name ]]Block.__(4, {
                  loc,
                  name
                })
            };
      end
       end 
    end
    return --[[ () ]]0;
  end else do
    return 0;
  end end 
end end

function store_modtype(slot, id, path, info, env, renv) do
  return do
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: add$6("module type", slot, id, --[[ tuple ]]{
                path,
                info
              }, env.modtypes, renv.modtypes),
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: --[[ Env_modtype ]]Block.__(4, {
              env.summary,
              id,
              info
            }),
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        end;
end end

function store_type_infos(slot, id, path, info, env, renv) do
  return do
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: add$6("type", slot, id, --[[ tuple ]]{
                path,
                --[[ tuple ]]{
                  info,
                  --[[ tuple ]]{
                    --[[ [] ]]0,
                    --[[ [] ]]0
                  }
                }
              }, env.types, renv.types),
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: --[[ Env_type ]]Block.__(1, {
              env.summary,
              id,
              info
            }),
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        end;
end end

function store_module(slot, id, path, md, env, renv) do
  return do
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: add$6("module", slot, id, --[[ tuple ]]{
                path,
                md
              }, env.modules, renv.modules),
          modtypes: env.modtypes,
          components: add$6("module", slot, id, --[[ tuple ]]{
                path,
                components_of_module(env, identity, path, md.md_type)
              }, env.components, renv.components),
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: --[[ Env_module ]]Block.__(3, {
              env.summary,
              id,
              md
            }),
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        end;
end end

function components_of_module_maker(param) do
  sub = param[1];
  env = param[0];
  match = scrape_alias(env, undefined, param[3]);
  local ___conditional___=(match.tag | 0);
  do
     if ___conditional___ = 1--[[ Mty_signature ]] then do
        sg = match[0];
        c = do
          comp_values: --[[ Empty ]]0,
          comp_constrs: --[[ Empty ]]0,
          comp_labels: --[[ Empty ]]0,
          comp_types: --[[ Empty ]]0,
          comp_modules: --[[ Empty ]]0,
          comp_modtypes: --[[ Empty ]]0,
          comp_components: --[[ Empty ]]0,
          comp_classes: --[[ Empty ]]0,
          comp_cltypes: --[[ Empty ]]0
        end;
        match$1 = prefix_idents_and_subst$1(param[2], sub, sg);
        sub$1 = match$1[1];
        env$1 = do
          contents: env
        end;
        pos = do
          contents: 0
        end;
        List.iter2((function (item, path) do
                local ___conditional___=(item.tag | 0);
                do
                   if ___conditional___ = 0--[[ Sig_value ]] then do
                      decl = item[1];
                      decl$prime = value_description(sub$1, decl);
                      c.comp_values = add$5(item[0].name, --[[ tuple ]]{
                            decl$prime,
                            pos.contents
                          }, c.comp_values);
                      match = decl.val_kind;
                      if (typeof match == "number" or match.tag) then do
                        pos.contents = pos.contents + 1 | 0;
                        return --[[ () ]]0;
                      end else do
                        return --[[ () ]]0;
                      end end end end end 
                   if ___conditional___ = 1--[[ Sig_type ]] then do
                      decl$1 = item[1];
                      id = item[0];
                      decl$prime$1 = type_declaration(sub$1, decl$1);
                      constructors = List.map((function (prim) do
                              return prim[1];
                            end end), constructors_of_type(path, decl$prime$1));
                      labels = List.map((function (prim) do
                              return prim[1];
                            end end), labels_of_type(path, decl$prime$1));
                      c.comp_types = add$5(id.name, --[[ tuple ]]{
                            --[[ tuple ]]{
                              decl$prime$1,
                              --[[ tuple ]]{
                                constructors,
                                labels
                              }
                            },
                            -1
                          }, c.comp_types);
                      List.iter((function (descr) do
                              c.comp_constrs = add_to_tbl(descr.cstr_name, --[[ tuple ]]{
                                    descr,
                                    -1
                                  }, c.comp_constrs);
                              return --[[ () ]]0;
                            end end), constructors);
                      List.iter((function (descr) do
                              c.comp_labels = add_to_tbl(descr.lbl_name, --[[ tuple ]]{
                                    descr,
                                    -1
                                  }, c.comp_labels);
                              return --[[ () ]]0;
                            end end), labels);
                      env$1.contents = store_type_infos(undefined, id, --[[ Pident ]]Block.__(0, {id}), decl$1, env$1.contents, env$1.contents);
                      return --[[ () ]]0;end end end 
                   if ___conditional___ = 2--[[ Sig_typext ]] then do
                      ext$prime = extension_constructor(sub$1, item[1]);
                      descr = extension_descr(path, ext$prime);
                      c.comp_constrs = add_to_tbl(item[0].name, --[[ tuple ]]{
                            descr,
                            pos.contents
                          }, c.comp_constrs);
                      pos.contents = pos.contents + 1 | 0;
                      return --[[ () ]]0;end end end 
                   if ___conditional___ = 3--[[ Sig_module ]] then do
                      md = item[1];
                      id$1 = item[0];
                      mty = md.md_type;
                      mty$prime = do
                        contents: --[[ Thunk ]]Block.__(2, {--[[ tuple ]]{
                              sub$1,
                              mty
                            }})
                      end;
                      c.comp_modules = add$5(id$1.name, --[[ tuple ]]{
                            mty$prime,
                            pos.contents
                          }, c.comp_modules);
                      comps = components_of_module(env$1.contents, sub$1, path, mty);
                      c.comp_components = add$5(id$1.name, --[[ tuple ]]{
                            comps,
                            pos.contents
                          }, c.comp_components);
                      env$1.contents = store_module(undefined, id$1, --[[ Pident ]]Block.__(0, {id$1}), md, env$1.contents, env$1.contents);
                      pos.contents = pos.contents + 1 | 0;
                      return --[[ () ]]0;end end end 
                   if ___conditional___ = 4--[[ Sig_modtype ]] then do
                      decl$2 = item[1];
                      id$2 = item[0];
                      decl$prime$2 = modtype_declaration(sub$1, decl$2);
                      c.comp_modtypes = add$5(id$2.name, --[[ tuple ]]{
                            decl$prime$2,
                            -1
                          }, c.comp_modtypes);
                      env$1.contents = store_modtype(undefined, id$2, --[[ Pident ]]Block.__(0, {id$2}), decl$2, env$1.contents, env$1.contents);
                      return --[[ () ]]0;end end end 
                   if ___conditional___ = 5--[[ Sig_class ]] then do
                      decl$prime$3 = class_declaration(sub$1, item[1]);
                      c.comp_classes = add$5(item[0].name, --[[ tuple ]]{
                            decl$prime$3,
                            pos.contents
                          }, c.comp_classes);
                      pos.contents = pos.contents + 1 | 0;
                      return --[[ () ]]0;end end end 
                   if ___conditional___ = 6--[[ Sig_class_type ]] then do
                      decl$prime$4 = cltype_declaration(sub$1, item[1]);
                      c.comp_cltypes = add$5(item[0].name, --[[ tuple ]]{
                            decl$prime$4,
                            pos.contents
                          }, c.comp_cltypes);
                      return --[[ () ]]0;end end end 
                   do
                  
                end
              end end), sg, match$1[0]);
        return --[[ Structure_comps ]]Block.__(0, {c});end end end 
     if ___conditional___ = 2--[[ Mty_functor ]] then do
        return --[[ Functor_comps ]]Block.__(1, {do
                    fcomp_param: match[0],
                    fcomp_arg: may_map((function (param) do
                            return modtype(sub, param);
                          end end), match[1]),
                    fcomp_res: match[2],
                    fcomp_env: env,
                    fcomp_subst: sub,
                    fcomp_cache: Hashtbl.create(undefined, 17),
                    fcomp_subst_cache: Hashtbl.create(undefined, 17)
                  end});end end end 
     if ___conditional___ = 0--[[ Mty_ident ]]
     or ___conditional___ = 3--[[ Mty_alias ]]
     do
    
  end
  return --[[ Structure_comps ]]Block.__(0, {do
              comp_values: --[[ Empty ]]0,
              comp_constrs: --[[ Empty ]]0,
              comp_labels: --[[ Empty ]]0,
              comp_types: --[[ Empty ]]0,
              comp_modules: --[[ Empty ]]0,
              comp_modtypes: --[[ Empty ]]0,
              comp_components: --[[ Empty ]]0,
              comp_classes: --[[ Empty ]]0,
              comp_cltypes: --[[ Empty ]]0
            end});
end end

function store_value(check, slot, id, path, decl, env, renv) do
  check_value_name(id.name, decl.val_loc);
  may((function (f) do
          return check_usage(decl.val_loc, id, f, value_declarations);
        end end), check);
  return do
          values: add$6("value", slot, id, --[[ tuple ]]{
                path,
                decl
              }, env.values, renv.values),
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: --[[ Env_value ]]Block.__(0, {
              env.summary,
              id,
              decl
            }),
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        end;
end end

function store_type(check, slot, id, path, info, env, renv) do
  loc = info.type_loc;
  if (check) then do
    check_usage(loc, id, (function (s) do
            return --[[ Unused_type_declaration ]]Block.__(18, {s});
          end end), type_declarations);
  end
   end 
  constructors = constructors_of_type(path, info);
  labels = labels_of_type(path, info);
  descrs_000 = List.map((function (prim) do
          return prim[1];
        end end), constructors);
  descrs_001 = List.map((function (prim) do
          return prim[1];
        end end), labels);
  descrs = --[[ tuple ]]{
    descrs_000,
    descrs_001
  };
  if (check and not loc.loc_ghost and is_active(--[[ Unused_constructor ]]Block.__(21, {
            "",
            false,
            false
          }))) then do
    ty = id.name;
    List.iter((function (param) do
            c = param[1].cstr_name;
            k = --[[ tuple ]]{
              ty,
              loc,
              c
            };
            if (Hashtbl.mem(used_constructors, k)) then do
              return 0;
            end else do
              used = do
                cu_positive: false,
                cu_pattern: false,
                cu_privatize: false
              end;
              Hashtbl.add(used_constructors, k, (function (param) do
                      return add_constructor_usage(used, param);
                    end end));
              if (ty == "" or Caml_string.get(ty, 0) == --[[ "_" ]]95) then do
                return 0;
              end else do
                return Curry._1(add_delayed_check_forward.contents, (function (param) do
                              if (not is_in_signature(env) and not used.cu_positive) then do
                                return prerr_warning(loc, --[[ Unused_constructor ]]Block.__(21, {
                                              c,
                                              used.cu_pattern,
                                              used.cu_privatize
                                            }));
                              end else do
                                return 0;
                              end end 
                            end end));
              end end 
            end end 
          end end), constructors);
  end
   end 
  return do
          values: env.values,
          constrs: List.fold_right((function (param, constrs) do
                  return add$6("constructor", slot, param[0], param[1], constrs, renv.constrs);
                end end), constructors, env.constrs),
          labels: List.fold_right((function (param, labels) do
                  return add$6("label", slot, param[0], param[1], labels, renv.labels);
                end end), labels, env.labels),
          types: add$6("type", slot, id, --[[ tuple ]]{
                path,
                --[[ tuple ]]{
                  info,
                  descrs
                }
              }, env.types, renv.types),
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: --[[ Env_type ]]Block.__(1, {
              env.summary,
              id,
              info
            }),
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        end;
end end

function store_extension(check, slot, id, path, ext, env, renv) do
  loc = ext.ext_loc;
  if (check and not loc.loc_ghost and is_active(--[[ Unused_extension ]]Block.__(22, {
            "",
            false,
            false
          }))) then do
    ty = last(ext.ext_type_path);
    n = id.name;
    k = --[[ tuple ]]{
      ty,
      loc,
      n
    };
    if (not Hashtbl.mem(used_constructors, k)) then do
      used = do
        cu_positive: false,
        cu_pattern: false,
        cu_privatize: false
      end;
      Hashtbl.add(used_constructors, k, (function (param) do
              return add_constructor_usage(used, param);
            end end));
      Curry._1(add_delayed_check_forward.contents, (function (param) do
              if (not is_in_signature(env) and not used.cu_positive) then do
                return prerr_warning(loc, --[[ Unused_extension ]]Block.__(22, {
                              n,
                              used.cu_pattern,
                              used.cu_privatize
                            }));
              end else do
                return 0;
              end end 
            end end));
    end
     end 
  end
   end 
  return do
          values: env.values,
          constrs: add$6("constructor", slot, id, extension_descr(path, ext), env.constrs, renv.constrs),
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: --[[ Env_extension ]]Block.__(2, {
              env.summary,
              id,
              ext
            }),
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        end;
end end

function store_class(slot, id, path, desc, env, renv) do
  return do
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: add$6("class", slot, id, --[[ tuple ]]{
                path,
                desc
              }, env.classes, renv.classes),
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: --[[ Env_class ]]Block.__(5, {
              env.summary,
              id,
              desc
            }),
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        end;
end end

function store_cltype(slot, id, path, desc, env, renv) do
  return do
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: add$6("class type", slot, id, --[[ tuple ]]{
                path,
                desc
              }, env.cltypes, renv.cltypes),
          functor_args: env.functor_args,
          summary: --[[ Env_cltype ]]Block.__(6, {
              env.summary,
              id,
              desc
            }),
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        end;
end end

function components_of_functor_appl(f, p1, p2) do
  try do
    return Hashtbl.find(f.fcomp_cache, p2);
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      p = --[[ Papply ]]Block.__(2, {
          p1,
          p2
        });
      mty = modtype(add_module(f.fcomp_param, p2, identity), f.fcomp_res);
      comps = components_of_module(f.fcomp_env, f.fcomp_subst, p, mty);
      Hashtbl.add(f.fcomp_cache, p2, comps);
      return comps;
    end else do
      throw exn;
    end end 
  end
end end

components_of_module$prime.contents = components_of_module;

components_of_functor_appl$prime.contents = components_of_functor_appl;

components_of_module_maker$prime.contents = components_of_module_maker;

function add_value(check, id, desc, env) do
  return store_value(check, undefined, id, --[[ Pident ]]Block.__(0, {id}), desc, env, env);
end end

function add_type$1(check, id, info, env) do
  return store_type(check, undefined, id, --[[ Pident ]]Block.__(0, {id}), info, env, env);
end end

function add_extension(check, id, ext, env) do
  return store_extension(check, undefined, id, --[[ Pident ]]Block.__(0, {id}), ext, env, env);
end end

function add_module_declaration(arg, id, md, env) do
  path = --[[ Pident ]]Block.__(0, {id});
  env$1 = store_module(undefined, id, path, md, env, env);
  argOpt = arg;
  id$1 = id;
  env$2 = env$1;
  arg$1 = argOpt ~= undefined and argOpt or false;
  if (arg$1) then do
    return do
            values: env$2.values,
            constrs: env$2.constrs,
            labels: env$2.labels,
            types: env$2.types,
            modules: env$2.modules,
            modtypes: env$2.modtypes,
            components: env$2.components,
            classes: env$2.classes,
            cltypes: env$2.cltypes,
            functor_args: add(id$1, --[[ () ]]0, env$2.functor_args),
            summary: --[[ Env_functor_arg ]]Block.__(8, {
                env$2.summary,
                id$1
              }),
            local_constraints: env$2.local_constraints,
            gadt_instances: env$2.gadt_instances,
            flags: env$2.flags
          end;
  end else do
    return env$2;
  end end 
end end

function add_modtype$1(id, info, env) do
  return store_modtype(undefined, id, --[[ Pident ]]Block.__(0, {id}), info, env, env);
end end

function add_class(id, ty, env) do
  return store_class(undefined, id, --[[ Pident ]]Block.__(0, {id}), ty, env, env);
end end

function add_cltype(id, ty, env) do
  return store_cltype(undefined, id, --[[ Pident ]]Block.__(0, {id}), ty, env, env);
end end

function add_module$1(arg, id, mty, env) do
  return add_module_declaration(arg, id, do
              md_type: mty,
              md_attributes: --[[ [] ]]0,
              md_loc: none
            end, env);
end end

function add_local_constraint(id, info, elv, env) do
  if (info.type_manifest ~= undefined) then do
    match = info.type_newtype_level;
    if (match ~= undefined) then do
      env$1 = add_type$1(false, id, do
            type_params: info.type_params,
            type_arity: info.type_arity,
            type_kind: info.type_kind,
            type_private: info.type_private,
            type_manifest: info.type_manifest,
            type_variance: info.type_variance,
            type_newtype_level: --[[ tuple ]]{
              match[0],
              elv
            },
            type_loc: info.type_loc,
            type_attributes: info.type_attributes
          end, env);
      return do
              values: env$1.values,
              constrs: env$1.constrs,
              labels: env$1.labels,
              types: env$1.types,
              modules: env$1.modules,
              modtypes: env$1.modtypes,
              components: env$1.components,
              classes: env$1.classes,
              cltypes: env$1.cltypes,
              functor_args: env$1.functor_args,
              summary: env$1.summary,
              local_constraints: true,
              gadt_instances: env$1.gadt_instances,
              flags: env$1.flags
            end;
    end else do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "env.ml",
              1538,
              9
            }
          };
    end end 
  end else do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "env.ml",
            1538,
            9
          }
        };
  end end 
end end

function enter(store_fun, name, data, env) do
  id = create(name);
  return --[[ tuple ]]{
          id,
          Curry._6(store_fun, undefined, id, --[[ Pident ]]Block.__(0, {id}), data, env, env)
        };
end end

function enter_value(check) do
  return (function (param, param$1, param$2) do
      return enter((function (param, param$1, param$2, param$3, param$4, param$5) do
                    return store_value(check, param, param$1, param$2, param$3, param$4, param$5);
                  end end), param, param$1, param$2);
    end end);
end end

function enter_type(param, param$1, param$2) do
  return enter((function (param, param$1, param$2, param$3, param$4, param$5) do
                return store_type(true, param, param$1, param$2, param$3, param$4, param$5);
              end end), param, param$1, param$2);
end end

function enter_module_declaration(arg, name, md, env) do
  id = create(name);
  return --[[ tuple ]]{
          id,
          add_module_declaration(arg, id, md, env)
        };
end end

function enter_modtype(param, param$1, param$2) do
  return enter(store_modtype, param, param$1, param$2);
end end

function enter_module(arg, s, mty, env) do
  return enter_module_declaration(arg, s, do
              md_type: mty,
              md_attributes: --[[ [] ]]0,
              md_loc: none
            end, env);
end end

function add_item(comp, env) do
  local ___conditional___=(comp.tag | 0);
  do
     if ___conditional___ = 0--[[ Sig_value ]] then do
        return add_value(undefined, comp[0], comp[1], env);end end end 
     if ___conditional___ = 1--[[ Sig_type ]] then do
        return add_type$1(false, comp[0], comp[1], env);end end end 
     if ___conditional___ = 2--[[ Sig_typext ]] then do
        return add_extension(false, comp[0], comp[1], env);end end end 
     if ___conditional___ = 3--[[ Sig_module ]] then do
        return add_module_declaration(undefined, comp[0], comp[1], env);end end end 
     if ___conditional___ = 4--[[ Sig_modtype ]] then do
        return add_modtype$1(comp[0], comp[1], env);end end end 
     if ___conditional___ = 5--[[ Sig_class ]] then do
        return add_class(comp[0], comp[1], env);end end end 
     if ___conditional___ = 6--[[ Sig_class_type ]] then do
        return add_cltype(comp[0], comp[1], env);end end end 
     do
    
  end
end end

function add_signature(_sg, _env) do
  while(true) do
    env = _env;
    sg = _sg;
    if (sg) then do
      _env = add_item(sg[0], env);
      _sg = sg[1];
      continue ;
    end else do
      return env;
    end end 
  end;
end end

function open_signature(slot, root, sg, env0) do
  match = prefix_idents_and_subst$1(root, identity, sg);
  sg$1 = CamlinternalLazy.force(match[2]);
  newenv = List.fold_left2((function (env, item, p) do
          local ___conditional___=(item.tag | 0);
          do
             if ___conditional___ = 0--[[ Sig_value ]] then do
                return store_value(undefined, slot, hide(item[0]), p, item[1], env, env0);end end end 
             if ___conditional___ = 1--[[ Sig_type ]] then do
                return store_type(false, slot, hide(item[0]), p, item[1], env, env0);end end end 
             if ___conditional___ = 2--[[ Sig_typext ]] then do
                return store_extension(false, slot, hide(item[0]), p, item[1], env, env0);end end end 
             if ___conditional___ = 3--[[ Sig_module ]] then do
                return store_module(slot, hide(item[0]), p, item[1], env, env0);end end end 
             if ___conditional___ = 4--[[ Sig_modtype ]] then do
                return store_modtype(slot, hide(item[0]), p, item[1], env, env0);end end end 
             if ___conditional___ = 5--[[ Sig_class ]] then do
                return store_class(slot, hide(item[0]), p, item[1], env, env0);end end end 
             if ___conditional___ = 6--[[ Sig_class_type ]] then do
                return store_cltype(slot, hide(item[0]), p, item[1], env, env0);end end end 
             do
            
          end
        end end), env0, sg$1, match[0]);
  return do
          values: newenv.values,
          constrs: newenv.constrs,
          labels: newenv.labels,
          types: newenv.types,
          modules: newenv.modules,
          modtypes: newenv.modtypes,
          components: newenv.components,
          classes: newenv.classes,
          cltypes: newenv.cltypes,
          functor_args: newenv.functor_args,
          summary: --[[ Env_open ]]Block.__(7, {
              env0.summary,
              root
            }),
          local_constraints: newenv.local_constraints,
          gadt_instances: newenv.gadt_instances,
          flags: newenv.flags
        end;
end end

function open_signature$1(locOpt, toplevelOpt, ovf, root, sg, env) do
  loc = locOpt ~= undefined and locOpt or none;
  toplevel = toplevelOpt ~= undefined and toplevelOpt or false;
  if (not toplevel and ovf == --[[ Fresh ]]1 and not loc.loc_ghost and (is_active(--[[ Unused_open ]]Block.__(17, {""})) or is_active(--[[ Open_shadow_identifier ]]Block.__(27, {
              "",
              ""
            })) or is_active(--[[ Open_shadow_label_constructor ]]Block.__(28, {
              "",
              ""
            })))) then do
    used = do
      contents: false
    end;
    Curry._1(add_delayed_check_forward.contents, (function (param) do
            if (used.contents) then do
              return 0;
            end else do
              return prerr_warning(loc, --[[ Unused_open ]]Block.__(17, {name(undefined, root)}));
            end end 
          end end));
    shadowed = do
      contents: --[[ [] ]]0
    end;
    slot = function (kind, s, b) do
      if (b and not List.mem(--[[ tuple ]]{
              kind,
              s
            }, shadowed.contents)) then do
        shadowed.contents = --[[ :: ]]{
          --[[ tuple ]]{
            kind,
            s
          },
          shadowed.contents
        };
        w;
        local ___conditional___=(kind);
        do
           if ___conditional___ = "constructor"
           or ___conditional___ = "label" then do
              w = --[[ Open_shadow_label_constructor ]]Block.__(28, {
                  kind,
                  s
                });end else 
           do end end
          else do
            w = --[[ Open_shadow_identifier ]]Block.__(27, {
                kind,
                s
              });
            end end
            
        end
        prerr_warning(loc, w);
      end
       end 
      used.contents = true;
      return --[[ () ]]0;
    end end;
    return open_signature(slot, root, sg, env);
  end else do
    return open_signature(undefined, root, sg, env);
  end end 
end end

function read_signature(modname, filename) do
  ps = read_pers_struct(modname, filename);
  check_consistency(ps);
  return ps.ps_sig;
end end

function imports(param) do
  dont_record_crc_unit$1 = dont_record_crc_unit.contents;
  if (dont_record_crc_unit$1 ~= undefined) then do
    x = dont_record_crc_unit$1;
    return extract(fold$5((function (m, acc) do
                      if (m == x) then do
                        return acc;
                      end else do
                        return --[[ :: ]]{
                                m,
                                acc
                              };
                      end end 
                    end end), imported_units.contents, --[[ [] ]]0), crc_units);
  end else do
    return extract(elements_aux$2(--[[ [] ]]0, imported_units.contents), crc_units);
  end end 
end end

function save_signature(sg, modname, filename) do
  sg$1 = sg;
  modname$1 = modname;
  filename$1 = filename;
  imports$1 = imports(--[[ () ]]0);
  cleanup_abbrev(--[[ () ]]0);
  new_id$1.contents = -1;
  sg$2 = signature$2(for_saving(identity), sg$1);
  oc = Pervasives.open_out_bin(filename$1);
  try do
    cmi_cmi_flags = recursive_types.contents and --[[ :: ]]{
        --[[ Rectypes ]]0,
        --[[ [] ]]0
      } or --[[ [] ]]0;
    cmi = do
      cmi_name: modname$1,
      cmi_sign: sg$2,
      cmi_crcs: imports$1,
      cmi_flags: cmi_cmi_flags
    end;
    crc = output_cmi(filename$1, oc, cmi);
    Caml_io.caml_ml_flush(oc);
    Caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
    comps = components_of_module(empty, identity, --[[ Pident ]]Block.__(0, {do
              stamp: 0,
              name: modname$1,
              flags: 1
            end}), --[[ Mty_signature ]]Block.__(1, {sg$2}));
    ps = do
      ps_name: modname$1,
      ps_sig: sg$2,
      ps_comps: comps,
      ps_crcs: --[[ :: ]]{
        --[[ tuple ]]{
          modname$1,
          crc
        },
        imports$1
      },
      ps_crcs_checked: false,
      ps_filename: filename$1,
      ps_flags: cmi_cmi_flags
    end;
    save_pers_struct(crc, ps);
    return sg$2;
  end
  catch (exn)do
    Caml_io.caml_ml_flush(oc);
    Caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
    remove_file(filename$1);
    throw exn;
  end
end end

function find_all$1(proj1, proj2, f, lid, env, acc) do
  if (lid ~= undefined) then do
    match = lookup_module_descr(lid, env);
    p = match[0];
    match$1 = force(components_of_module_maker, match[1]);
    if (match$1.tag) then do
      return acc;
    end else do
      return fold$4((function (s, param, acc) do
                    return Curry._4(f, s, --[[ Pdot ]]Block.__(1, {
                                  p,
                                  s,
                                  param[1]
                                }), param[0], acc);
                  end end), Curry._1(proj2, match$1[0]), acc);
    end end 
  end else do
    return fold_name((function (id, param, acc) do
                    return Curry._4(f, id.name, param[0], param[1], acc);
                  end end))(Curry._1(proj1, env), acc);
  end end 
end end

function find_all_simple_list(proj1, proj2, f, lid, env, acc) do
  if (lid ~= undefined) then do
    match = lookup_module_descr(lid, env);
    match$1 = force(components_of_module_maker, match[1]);
    if (match$1.tag) then do
      return acc;
    end else do
      return fold$4((function (s, comps, acc) do
                    if (comps) then do
                      return Curry._2(f, comps[0][0], acc);
                    end else do
                      return acc;
                    end end 
                  end end), Curry._1(proj2, match$1[0]), acc);
    end end 
  end else do
    return fold_name((function (id, data, acc) do
                    return Curry._2(f, data, acc);
                  end end))(Curry._1(proj1, env), acc);
  end end 
end end

function fold_modules(f, lid, env, acc) do
  if (lid ~= undefined) then do
    match = lookup_module_descr(lid, env);
    p = match[0];
    match$1 = force(components_of_module_maker, match[1]);
    if (match$1.tag) then do
      return acc;
    end else do
      return fold$4((function (s, param, acc) do
                    md_type = force(subst_modtype_maker, param[0]);
                    return Curry._4(f, s, --[[ Pdot ]]Block.__(1, {
                                  p,
                                  s,
                                  param[1]
                                }), do
                                md_type: md_type,
                                md_attributes: --[[ [] ]]0,
                                md_loc: none
                              end, acc);
                  end end), match$1[0].comp_modules, acc);
    end end 
  end else do
    acc$1 = fold_name((function (id, param, acc) do
              return Curry._4(f, id.name, param[0], param[1], acc);
            end end))(env.modules, acc);
    return Hashtbl.fold((function (name, ps, acc) do
                  if (ps ~= undefined) then do
                    return Curry._4(f, name, --[[ Pident ]]Block.__(0, {do
                                    stamp: 0,
                                    name: name,
                                    flags: 1
                                  end}), do
                                md_type: --[[ Mty_signature ]]Block.__(1, {ps.ps_sig}),
                                md_attributes: --[[ [] ]]0,
                                md_loc: none
                              end, acc);
                  end else do
                    return acc;
                  end end 
                end end), persistent_structures, acc$1);
  end end 
end end

function fold_values(f) do
  return (function (param, param$1, param$2) do
      return find_all$1((function (env) do
                    return env.values;
                  end end), (function (sc) do
                    return sc.comp_values;
                  end end), f, param, param$1, param$2);
    end end);
end end

function fold_constructors(f) do
  return (function (param, param$1, param$2) do
      return find_all_simple_list((function (env) do
                    return env.constrs;
                  end end), (function (sc) do
                    return sc.comp_constrs;
                  end end), f, param, param$1, param$2);
    end end);
end end

function fold_labels(f) do
  return (function (param, param$1, param$2) do
      return find_all_simple_list((function (env) do
                    return env.labels;
                  end end), (function (sc) do
                    return sc.comp_labels;
                  end end), f, param, param$1, param$2);
    end end);
end end

function fold_types(f) do
  return (function (param, param$1, param$2) do
      return find_all$1((function (env) do
                    return env.types;
                  end end), (function (sc) do
                    return sc.comp_types;
                  end end), f, param, param$1, param$2);
    end end);
end end

function fold_modtypes(f) do
  return (function (param, param$1, param$2) do
      return find_all$1((function (env) do
                    return env.modtypes;
                  end end), (function (sc) do
                    return sc.comp_modtypes;
                  end end), f, param, param$1, param$2);
    end end);
end end

function fold_classs(f) do
  return (function (param, param$1, param$2) do
      return find_all$1((function (env) do
                    return env.classes;
                  end end), (function (sc) do
                    return sc.comp_classes;
                  end end), f, param, param$1, param$2);
    end end);
end end

function fold_cltypes(f) do
  return (function (param, param$1, param$2) do
      return find_all$1((function (env) do
                    return env.cltypes;
                  end end), (function (sc) do
                    return sc.comp_cltypes;
                  end end), f, param, param$1, param$2);
    end end);
end end

match = build_initial_env((function (param, param$1, param$2) do
        return add_type$1(false, param, param$1, param$2);
      end end), (function (param, param$1, param$2) do
        return add_extension(false, param, param$1, param$2);
      end end), empty);

initial_safe_string = match[0];

last_env = do
  contents: empty
end;

last_reduced_env = do
  contents: empty
end;

function keep_only_summary(env) do
  if (last_env.contents == env) then do
    return last_reduced_env.contents;
  end else do
    new_env_summary = env.summary;
    new_env_local_constraints = env.local_constraints;
    new_env_flags = env.flags;
    new_env = do
      values: --[[ Empty ]]0,
      constrs: --[[ Empty ]]0,
      labels: --[[ Empty ]]0,
      types: --[[ Empty ]]0,
      modules: --[[ Empty ]]0,
      modtypes: --[[ Empty ]]0,
      components: --[[ Empty ]]0,
      classes: --[[ Empty ]]0,
      cltypes: --[[ Empty ]]0,
      functor_args: --[[ Empty ]]0,
      summary: new_env_summary,
      local_constraints: new_env_local_constraints,
      gadt_instances: --[[ [] ]]0,
      flags: new_env_flags
    end;
    last_env.contents = env;
    last_reduced_env.contents = new_env;
    return new_env;
  end end 
end end

function report_error$1(ppf, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Illegal_renaming ]] then do
        return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ String_literal ]]Block.__(11, {
                            "Wrong file naming: ",
                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                    --[[ Break ]]Block.__(0, {
                                        "@ ",
                                        1,
                                        0
                                      }),
                                    --[[ String_literal ]]Block.__(11, {
                                        "contains the compiled interface for ",
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ String ]]Block.__(2, {
                                                --[[ No_padding ]]0,
                                                --[[ String_literal ]]Block.__(11, {
                                                    " when ",
                                                    --[[ String ]]Block.__(2, {
                                                        --[[ No_padding ]]0,
                                                        --[[ String_literal ]]Block.__(11, {
                                                            " was expected",
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })
                                                  })
                                              })
                                          })
                                      })
                                  })})
                          }),
                        "Wrong file naming: %a@ contains the compiled interface for @ %s when %s was expected"
                      }), print_filename, param[2], param[0], param[1]);end end end 
     if ___conditional___ = 1--[[ Inconsistent_import ]] then do
        return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      "<hov>",
                                      --[[ End_of_format ]]0
                                    }),
                                  "<hov>"
                                }}),
                            --[[ String_literal ]]Block.__(11, {
                                "The files ",
                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Break ]]Block.__(0, {
                                            "@ ",
                                            1,
                                            0
                                          }),
                                        --[[ String_literal ]]Block.__(11, {
                                            "and ",
                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "make inconsistent assumptions",
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Break ]]Block.__(0, {
                                                                "@ ",
                                                                1,
                                                                0
                                                              }),
                                                            --[[ String_literal ]]Block.__(11, {
                                                                "over interface ",
                                                                --[[ String ]]Block.__(2, {
                                                                    --[[ No_padding ]]0,
                                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                                        --[[ Close_box ]]0,
                                                                        --[[ End_of_format ]]0
                                                                      })
                                                                  })
                                                              })
                                                          })
                                                      })
                                                  })})
                                          })
                                      })})
                              })
                          }),
                        "@[<hov>The files %a@ and %a@ make inconsistent assumptions@ over interface %s@]"
                      }), print_filename, param[1], print_filename, param[2], param[0]);end end end 
     if ___conditional___ = 2--[[ Need_recursive_types ]] then do
        return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      "<hov>",
                                      --[[ End_of_format ]]0
                                    }),
                                  "<hov>"
                                }}),
                            --[[ String_literal ]]Block.__(11, {
                                "Unit ",
                                --[[ String ]]Block.__(2, {
                                    --[[ No_padding ]]0,
                                    --[[ String_literal ]]Block.__(11, {
                                        " imports from ",
                                        --[[ String ]]Block.__(2, {
                                            --[[ No_padding ]]0,
                                            --[[ String_literal ]]Block.__(11, {
                                                ", which uses recursive types.",
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ String ]]Block.__(2, {
                                                        --[[ No_padding ]]0,
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Close_box ]]0,
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })
                                                  })
                                              })
                                          })
                                      })
                                  })
                              })
                          }),
                        "@[<hov>Unit %s imports from %s, which uses recursive types.@ %s@]"
                      }), param[1], param[0], "The compilation flag -rectypes is required");end end end 
     if ___conditional___ = 3--[[ Missing_module ]] then do
        path2 = param[2];
        path1 = param[1];
        Format.fprintf(ppf, --[[ Format ]]{
              --[[ Formatting_gen ]]Block.__(18, {
                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                        --[[ End_of_format ]]0,
                        ""
                      }}),
                  --[[ Formatting_gen ]]Block.__(18, {
                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                            --[[ String_literal ]]Block.__(11, {
                                "<hov>",
                                --[[ End_of_format ]]0
                              }),
                            "<hov>"
                          }}),
                      --[[ End_of_format ]]0
                    })
                }),
              "@[@[<hov>"
            });
        if (same(path1, path2)) then do
          Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ String_literal ]]Block.__(11, {
                        "Internal path",
                        --[[ Formatting_lit ]]Block.__(17, {
                            --[[ Break ]]Block.__(0, {
                                "@ ",
                                1,
                                0
                              }),
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ Formatting_lit ]]Block.__(17, {
                                    --[[ Break ]]Block.__(0, {
                                        "@ ",
                                        1,
                                        0
                                      }),
                                    --[[ String_literal ]]Block.__(11, {
                                        "is dangling.",
                                        --[[ End_of_format ]]0
                                      })
                                  })
                              })
                          })
                      }),
                    "Internal path@ %s@ is dangling."
                  }), name(undefined, path1));
        end else do
          Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ String_literal ]]Block.__(11, {
                        "Internal path",
                        --[[ Formatting_lit ]]Block.__(17, {
                            --[[ Break ]]Block.__(0, {
                                "@ ",
                                1,
                                0
                              }),
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ Formatting_lit ]]Block.__(17, {
                                    --[[ Break ]]Block.__(0, {
                                        "@ ",
                                        1,
                                        0
                                      }),
                                    --[[ String_literal ]]Block.__(11, {
                                        "expands to",
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ String ]]Block.__(2, {
                                                --[[ No_padding ]]0,
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "which is dangling.",
                                                        --[[ End_of_format ]]0
                                                      })
                                                  })
                                              })
                                          })
                                      })
                                  })
                              })
                          })
                      }),
                    "Internal path@ %s@ expands to@ %s@ which is dangling."
                  }), name(undefined, path1), name(undefined, path2));
        end end 
        return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_lit ]]Block.__(17, {
                            --[[ Close_box ]]0,
                            --[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@ ",
                                    1,
                                    0
                                  }),
                                --[[ Formatting_gen ]]Block.__(18, {
                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                          --[[ End_of_format ]]0,
                                          ""
                                        }}),
                                    --[[ String ]]Block.__(2, {
                                        --[[ No_padding ]]0,
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ String ]]Block.__(2, {
                                                --[[ No_padding ]]0,
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ String ]]Block.__(2, {
                                                        --[[ No_padding ]]0,
                                                        --[[ Char_literal ]]Block.__(12, {
                                                            --[[ "." ]]46,
                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                --[[ Close_box ]]0,
                                                                --[[ Formatting_lit ]]Block.__(17, {
                                                                    --[[ Close_box ]]0,
                                                                    --[[ End_of_format ]]0
                                                                  })
                                                              })
                                                          })
                                                      })
                                                  })
                                              })
                                          })
                                      })
                                  })
                              })
                          }),
                        "@]@ @[%s@ %s@ %s.@]@]"
                      }), "The compiled interface for module", head(path2).name, "was not found");end end end 
     if ___conditional___ = 4--[[ Illegal_value_name ]] then do
        return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Char_literal ]]Block.__(12, {
                            --[[ "'" ]]39,
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ String_literal ]]Block.__(11, {
                                    "' is not a valid value identifier.",
                                    --[[ End_of_format ]]0
                                  })
                              })
                          }),
                        "'%s' is not a valid value identifier."
                      }), param[1]);end end end 
     do
    
  end
end end

register_error_of_exn((function (param) do
        if (param[0] == __Error$2) then do
          err = param[1];
          local ___conditional___=(err.tag | 0);
          do
             if ___conditional___ = 3--[[ Missing_module ]]
             or ___conditional___ = 4--[[ Illegal_value_name ]]
             do end
            else do
              return error_of_printer_file(report_error$1, err);
              end end
              
          end
          loc = err[0];
          if (Caml_obj.caml_notequal(loc, none)) then do
            return error_of_printer(loc, report_error$1, err);
          end else do
            return error_of_printer_file(report_error$1, err);
          end end 
        end
         end 
      end end));

function assert_fail(msg) do
  Assert.fail(--[[ () ]]0, --[[ () ]]0, msg, "");
  return --[[ () ]]0;
end end

function is_mocha(param) do
  match = __Array.to_list(Process.argv);
  if (match) then do
    match$1 = match[1];
    if (match$1) then do
      exec = Path.basename(match$1[0]);
      if (exec == "mocha") then do
        return true;
      end else do
        return exec == "_mocha";
      end end 
    end else do
      return false;
    end end 
  end else do
    return false;
  end end 
end end

function close_enough(thresholdOpt, a, b) do
  threshold = thresholdOpt ~= undefined and thresholdOpt or 0.0000001;
  return Math.abs(a - b) < threshold;
end end

function from_pair_suites(name, suites) do
  match = __Array.to_list(Process.argv);
  if (match) then do
    if (is_mocha(--[[ () ]]0)) then do
      describe(name, (function () do
              return List.iter((function (param) do
                            code = param[1];
                            it(param[0], (function () do
                                    spec = Curry._1(code, --[[ () ]]0);
                                    local ___conditional___=(spec.tag | 0);
                                    do
                                       if ___conditional___ = 0--[[ Eq ]] then do
                                          Assert.deepEqual(spec[0], spec[1]);
                                          return --[[ () ]]0;end end end 
                                       if ___conditional___ = 1--[[ Neq ]] then do
                                          Assert.notDeepEqual(spec[0], spec[1]);
                                          return --[[ () ]]0;end end end 
                                       if ___conditional___ = 2--[[ StrictEq ]] then do
                                          Assert.strictEqual(spec[0], spec[1]);
                                          return --[[ () ]]0;end end end 
                                       if ___conditional___ = 3--[[ StrictNeq ]] then do
                                          Assert.notStrictEqual(spec[0], spec[1]);
                                          return --[[ () ]]0;end end end 
                                       if ___conditional___ = 4--[[ Ok ]] then do
                                          Assert.ok(spec[0]);
                                          return --[[ () ]]0;end end end 
                                       if ___conditional___ = 5--[[ Approx ]] then do
                                          b = spec[1];
                                          a = spec[0];
                                          if (close_enough(undefined, a, b)) then do
                                            return 0;
                                          end else do
                                            Assert.deepEqual(a, b);
                                            return --[[ () ]]0;
                                          end end end end end 
                                       if ___conditional___ = 6--[[ ApproxThreshold ]] then do
                                          b$1 = spec[2];
                                          a$1 = spec[1];
                                          if (close_enough(spec[0], a$1, b$1)) then do
                                            return 0;
                                          end else do
                                            Assert.deepEqual(a$1, b$1);
                                            return --[[ () ]]0;
                                          end end end end end 
                                       if ___conditional___ = 7--[[ ThrowAny ]] then do
                                          Assert.throws(spec[0]);
                                          return --[[ () ]]0;end end end 
                                       if ___conditional___ = 8--[[ Fail ]] then do
                                          return assert_fail("failed");end end end 
                                       if ___conditional___ = 9--[[ FailWith ]] then do
                                          return assert_fail(spec[0]);end end end 
                                       do
                                      
                                    end
                                  end end));
                            return --[[ () ]]0;
                          end end), suites);
            end end));
      return --[[ () ]]0;
    end else do
      name$1 = name;
      suites$1 = suites;
      console.log(--[[ tuple ]]{
            name$1,
            "testing"
          });
      return List.iter((function (param) do
                    name = param[0];
                    match = Curry._1(param[1], --[[ () ]]0);
                    local ___conditional___=(match.tag | 0);
                    do
                       if ___conditional___ = 0--[[ Eq ]] then do
                          console.log(--[[ tuple ]]{
                                name,
                                match[0],
                                "eq?",
                                match[1]
                              });
                          return --[[ () ]]0;end end end 
                       if ___conditional___ = 1--[[ Neq ]] then do
                          console.log(--[[ tuple ]]{
                                name,
                                match[0],
                                "neq?",
                                match[1]
                              });
                          return --[[ () ]]0;end end end 
                       if ___conditional___ = 2--[[ StrictEq ]] then do
                          console.log(--[[ tuple ]]{
                                name,
                                match[0],
                                "strict_eq?",
                                match[1]
                              });
                          return --[[ () ]]0;end end end 
                       if ___conditional___ = 3--[[ StrictNeq ]] then do
                          console.log(--[[ tuple ]]{
                                name,
                                match[0],
                                "strict_neq?",
                                match[1]
                              });
                          return --[[ () ]]0;end end end 
                       if ___conditional___ = 4--[[ Ok ]] then do
                          console.log(--[[ tuple ]]{
                                name,
                                match[0],
                                "ok?"
                              });
                          return --[[ () ]]0;end end end 
                       if ___conditional___ = 5--[[ Approx ]] then do
                          console.log(--[[ tuple ]]{
                                name,
                                match[0],
                                "~",
                                match[1]
                              });
                          return --[[ () ]]0;end end end 
                       if ___conditional___ = 6--[[ ApproxThreshold ]] then do
                          console.log(--[[ tuple ]]{
                                name,
                                match[1],
                                "~",
                                match[2],
                                " (",
                                match[0],
                                ")"
                              });
                          return --[[ () ]]0;end end end 
                       if ___conditional___ = 7--[[ ThrowAny ]] then do
                          return --[[ () ]]0;end end end 
                       if ___conditional___ = 8--[[ Fail ]] then do
                          console.log("failed");
                          return --[[ () ]]0;end end end 
                       if ___conditional___ = 9--[[ FailWith ]] then do
                          console.log("failed: " .. match[0]);
                          return --[[ () ]]0;end end end 
                       do
                      
                    end
                  end end), suites$1);
    end end 
  end else do
    return --[[ () ]]0;
  end end 
end end

Promise.resolve(--[[ () ]]0);

__Error$3 = Caml_exceptions.create("Ocaml_typedtree_test.Syntaxerr.Error");

Escape_error = Caml_exceptions.create("Ocaml_typedtree_test.Syntaxerr.Escape_error");

function prepare_error(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Unclosed ]] then do
        closing = param[3];
        opening = param[1];
        return Curry._1(errorf(param[2], --[[ :: ]]{
                        Curry._1(errorf(param[0], undefined, undefined, --[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      "This '",
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ String_literal ]]Block.__(11, {
                                              "' might be unmatched",
                                              --[[ End_of_format ]]0
                                            })
                                        })
                                    }),
                                  "This '%s' might be unmatched"
                                }), opening),
                        --[[ [] ]]0
                      }, Curry._2(Printf.sprintf(--[[ Format ]]{
                                --[[ String_literal ]]Block.__(11, {
                                    "Syntax error: '",
                                    --[[ String ]]Block.__(2, {
                                        --[[ No_padding ]]0,
                                        --[[ String_literal ]]Block.__(11, {
                                            "' expected, the highlighted '",
                                            --[[ String ]]Block.__(2, {
                                                --[[ No_padding ]]0,
                                                --[[ String_literal ]]Block.__(11, {
                                                    "' might be unmatched",
                                                    --[[ End_of_format ]]0
                                                  })
                                              })
                                          })
                                      })
                                  }),
                                "Syntax error: '%s' expected, the highlighted '%s' might be unmatched"
                              }), closing, opening), --[[ Format ]]{
                        --[[ String_literal ]]Block.__(11, {
                            "Syntax error: '",
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ String_literal ]]Block.__(11, {
                                    "' expected",
                                    --[[ End_of_format ]]0
                                  })
                              })
                          }),
                        "Syntax error: '%s' expected"
                      }), closing);end end end 
     if ___conditional___ = 1--[[ Expecting ]] then do
        return Curry._1(errorf(param[0], undefined, undefined, --[[ Format ]]{
                        --[[ String_literal ]]Block.__(11, {
                            "Syntax error: ",
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ String_literal ]]Block.__(11, {
                                    " expected.",
                                    --[[ End_of_format ]]0
                                  })
                              })
                          }),
                        "Syntax error: %s expected."
                      }), param[1]);end end end 
     if ___conditional___ = 2--[[ Not_expecting ]] then do
        return Curry._1(errorf(param[0], undefined, undefined, --[[ Format ]]{
                        --[[ String_literal ]]Block.__(11, {
                            "Syntax error: ",
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ String_literal ]]Block.__(11, {
                                    " not expected.",
                                    --[[ End_of_format ]]0
                                  })
                              })
                          }),
                        "Syntax error: %s not expected."
                      }), param[1]);end end end 
     if ___conditional___ = 3--[[ Applicative_path ]] then do
        return errorf(param[0], undefined, undefined, --[[ Format ]]{
                    --[[ String_literal ]]Block.__(11, {
                        "Syntax error: applicative paths of the form F(X).t are not supported when the option -no-app-func is set.",
                        --[[ End_of_format ]]0
                      }),
                    "Syntax error: applicative paths of the form F(X).t are not supported when the option -no-app-func is set."
                  });end end end 
     if ___conditional___ = 4--[[ Variable_in_scope ]] then do
        __var = param[1];
        return Curry._2(errorf(param[0], undefined, undefined, --[[ Format ]]{
                        --[[ String_literal ]]Block.__(11, {
                            "In this scoped type, variable '",
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ String_literal ]]Block.__(11, {
                                    " is reserved for the local type ",
                                    --[[ String ]]Block.__(2, {
                                        --[[ No_padding ]]0,
                                        --[[ Char_literal ]]Block.__(12, {
                                            --[[ "." ]]46,
                                            --[[ End_of_format ]]0
                                          })
                                      })
                                  })
                              })
                          }),
                        "In this scoped type, variable '%s is reserved for the local type %s."
                      }), __var, __var);end end end 
     if ___conditional___ = 5--[[ Other ]] then do
        return errorf(param[0], undefined, undefined, --[[ Format ]]{
                    --[[ String_literal ]]Block.__(11, {
                        "Syntax error",
                        --[[ End_of_format ]]0
                      }),
                    "Syntax error"
                  });end end end 
     if ___conditional___ = 6--[[ Ill_formed_ast ]] then do
        return Curry._1(errorf(param[0], undefined, undefined, --[[ Format ]]{
                        --[[ String_literal ]]Block.__(11, {
                            "broken invariant in parsetree: ",
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ End_of_format ]]0
                              })
                          }),
                        "broken invariant in parsetree: %s"
                      }), param[1]);end end end 
     do
    
  end
end end

register_error_of_exn((function (param) do
        if (param[0] == __Error$3) then do
          return prepare_error(param[1]);
        end
         end 
      end end));

function ill_formed_ast(loc, s) do
  throw {
        __Error$3,
        --[[ Ill_formed_ast ]]Block.__(6, {
            loc,
            s
          })
      };
end end

function mktyp(d) do
  return mk(symbol_rloc(--[[ () ]]0), undefined, d);
end end

function mkpat(d) do
  return mk$1(symbol_rloc(--[[ () ]]0), undefined, d);
end end

function mkexp(d) do
  return Curry._3(Ast_helper_Exp.mk, symbol_rloc(--[[ () ]]0), undefined, d);
end end

function mkmty(d) do
  return mk$3(symbol_rloc(--[[ () ]]0), undefined, d);
end end

function mksig(d) do
  return mk$5(symbol_rloc(--[[ () ]]0), d);
end end

function mkmod(d) do
  return mk$4(symbol_rloc(--[[ () ]]0), undefined, d);
end end

function mkstr(d) do
  return mk$6(symbol_rloc(--[[ () ]]0), d);
end end

function mkclass(d) do
  return mk$7(symbol_rloc(--[[ () ]]0), undefined, d);
end end

function mkcty(d) do
  return mk$8(symbol_rloc(--[[ () ]]0), undefined, d);
end end

function mkctf(attrs, docs, d) do
  return Curry._4(Ast_helper_Ctf.mk, symbol_rloc(--[[ () ]]0), attrs, docs, d);
end end

function mkcf(attrs, docs, d) do
  return Curry._4(Ast_helper_Cf.mk, symbol_rloc(--[[ () ]]0), attrs, docs, d);
end end

function mkoption(d) do
  init = d.ptyp_loc;
  loc_loc_start = init.loc_start;
  loc_loc_end = init.loc_end;
  loc = do
    loc_start: loc_loc_start,
    loc_end: loc_loc_end,
    loc_ghost: true
  end;
  return mk(loc, undefined, --[[ Ptyp_constr ]]Block.__(3, {
                do
                  txt: --[[ Ldot ]]Block.__(1, {
                      --[[ Lident ]]Block.__(0, {"*predef*"}),
                      "option"
                    }),
                  loc: loc
                end,
                --[[ :: ]]{
                  d,
                  --[[ [] ]]0
                }
              }));
end end

function reloc_pat(x) do
  return do
          ppat_desc: x.ppat_desc,
          ppat_loc: symbol_rloc(--[[ () ]]0),
          ppat_attributes: x.ppat_attributes
        end;
end end

function reloc_exp(x) do
  return do
          pexp_desc: x.pexp_desc,
          pexp_loc: symbol_rloc(--[[ () ]]0),
          pexp_attributes: x.pexp_attributes
        end;
end end

function mkoperator(name, pos) do
  loc = rhs_loc(pos);
  return Curry._3(Ast_helper_Exp.mk, loc, undefined, --[[ Pexp_ident ]]Block.__(0, {do
                  txt: --[[ Lident ]]Block.__(0, {name}),
                  loc: loc
                end}));
end end

function mkpatvar(name, pos) do
  return mk$1(rhs_loc(pos), undefined, --[[ Ppat_var ]]Block.__(0, {do
                  txt: name,
                  loc: rhs_loc(pos)
                end}));
end end

function ghexp(d) do
  return Curry._3(Ast_helper_Exp.mk, symbol_gloc(--[[ () ]]0), undefined, d);
end end

function ghpat(d) do
  return mk$1(symbol_gloc(--[[ () ]]0), undefined, d);
end end

function ghtyp(d) do
  return mk(symbol_gloc(--[[ () ]]0), undefined, d);
end end

function mkinfix(arg1, name, arg2) do
  return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                mkoperator(name, 2),
                --[[ :: ]]{
                  --[[ tuple ]]{
                    "",
                    arg1
                  },
                  --[[ :: ]]{
                    --[[ tuple ]]{
                      "",
                      arg2
                    },
                    --[[ [] ]]0
                  }
                }
              }));
end end

function neg_float_string(f) do
  if (#f ~= 0 and Caml_string.get(f, 0) == --[[ "-" ]]45) then do
    return __String.sub(f, 1, #f - 1 | 0);
  end else do
    return "-" .. f;
  end end 
end end

function mkexp_cons(consloc, args, loc) do
  return Curry._3(Ast_helper_Exp.mk, loc, undefined, --[[ Pexp_construct ]]Block.__(9, {
                do
                  txt: --[[ Lident ]]Block.__(0, {"::"}),
                  loc: consloc
                end,
                args
              }));
end end

function mkpat_cons(consloc, args, loc) do
  return mk$1(loc, undefined, --[[ Ppat_construct ]]Block.__(5, {
                do
                  txt: --[[ Lident ]]Block.__(0, {"::"}),
                  loc: consloc
                end,
                args
              }));
end end

function mktailexp(nilloc, param) do
  if (param) then do
    e1 = param[0];
    exp_el = mktailexp(nilloc, param[1]);
    loc_loc_start = e1.pexp_loc.loc_start;
    loc_loc_end = exp_el.pexp_loc.loc_end;
    loc = do
      loc_start: loc_loc_start,
      loc_end: loc_loc_end,
      loc_ghost: true
    end;
    arg = Curry._3(Ast_helper_Exp.mk, loc, undefined, --[[ Pexp_tuple ]]Block.__(8, {--[[ :: ]]{
              e1,
              --[[ :: ]]{
                exp_el,
                --[[ [] ]]0
              }
            }}));
    return mkexp_cons(do
                loc_start: loc_loc_start,
                loc_end: loc_loc_end,
                loc_ghost: true
              end, arg, loc);
  end else do
    loc_loc_start$1 = nilloc.loc_start;
    loc_loc_end$1 = nilloc.loc_end;
    loc$1 = do
      loc_start: loc_loc_start$1,
      loc_end: loc_loc_end$1,
      loc_ghost: true
    end;
    nil_txt = --[[ Lident ]]Block.__(0, {"[]"});
    nil = do
      txt: nil_txt,
      loc: loc$1
    end;
    return Curry._3(Ast_helper_Exp.mk, loc$1, undefined, --[[ Pexp_construct ]]Block.__(9, {
                  nil,
                  undefined
                }));
  end end 
end end

function mktailpat(nilloc, param) do
  if (param) then do
    p1 = param[0];
    pat_pl = mktailpat(nilloc, param[1]);
    loc_loc_start = p1.ppat_loc.loc_start;
    loc_loc_end = pat_pl.ppat_loc.loc_end;
    loc = do
      loc_start: loc_loc_start,
      loc_end: loc_loc_end,
      loc_ghost: true
    end;
    arg = mk$1(loc, undefined, --[[ Ppat_tuple ]]Block.__(4, {--[[ :: ]]{
              p1,
              --[[ :: ]]{
                pat_pl,
                --[[ [] ]]0
              }
            }}));
    return mkpat_cons(do
                loc_start: loc_loc_start,
                loc_end: loc_loc_end,
                loc_ghost: true
              end, arg, loc);
  end else do
    loc_loc_start$1 = nilloc.loc_start;
    loc_loc_end$1 = nilloc.loc_end;
    loc$1 = do
      loc_start: loc_loc_start$1,
      loc_end: loc_loc_end$1,
      loc_ghost: true
    end;
    nil_txt = --[[ Lident ]]Block.__(0, {"[]"});
    nil = do
      txt: nil_txt,
      loc: loc$1
    end;
    return mk$1(loc$1, undefined, --[[ Ppat_construct ]]Block.__(5, {
                  nil,
                  undefined
                }));
  end end 
end end

function mkstrexp(e, attrs) do
  return do
          pstr_desc: --[[ Pstr_eval ]]Block.__(0, {
              e,
              attrs
            }),
          pstr_loc: e.pexp_loc
        end;
end end

function mkexp_constraint(e, param) do
  t2 = param[1];
  t1 = param[0];
  if (t1 ~= undefined) then do
    if (t2 ~= undefined) then do
      return ghexp(--[[ Pexp_coerce ]]Block.__(20, {
                    e,
                    t1,
                    t2
                  }));
    end else do
      return ghexp(--[[ Pexp_constraint ]]Block.__(19, {
                    e,
                    t1
                  }));
    end end 
  end else if (t2 ~= undefined) then do
    return ghexp(--[[ Pexp_coerce ]]Block.__(20, {
                  e,
                  t1,
                  t2
                }));
  end else do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "parser.mly",
            153,
            18
          }
        };
  end end  end 
end end

function array_function(str, name) do
  return do
          txt: --[[ Ldot ]]Block.__(1, {
              --[[ Lident ]]Block.__(0, {str}),
              fast.contents and "unsafe_" .. name or name
            }),
          loc: symbol_gloc(--[[ () ]]0)
        end;
end end

function unclosed(opening_name, opening_num, closing_name, closing_num) do
  throw {
        __Error$3,
        --[[ Unclosed ]]Block.__(0, {
            rhs_loc(opening_num),
            opening_name,
            rhs_loc(closing_num),
            closing_name
          })
      };
end end

function expecting(pos, nonterm) do
  throw {
        __Error$3,
        --[[ Expecting ]]Block.__(1, {
            rhs_loc(pos),
            nonterm
          })
      };
end end

function not_expecting(pos, nonterm) do
  throw {
        __Error$3,
        --[[ Not_expecting ]]Block.__(2, {
            rhs_loc(pos),
            nonterm
          })
      };
end end

function bigarray_function(str, name) do
  return do
          txt: --[[ Ldot ]]Block.__(1, {
              --[[ Ldot ]]Block.__(1, {
                  --[[ Lident ]]Block.__(0, {"Bigarray"}),
                  str
                }),
              name
            }),
          loc: symbol_gloc(--[[ () ]]0)
        end;
end end

function bigarray_untuplify(exp) do
  match = exp.pexp_desc;
  if (match.tag == --[[ Pexp_tuple ]]8) then do
    return match[0];
  end else do
    return --[[ :: ]]{
            exp,
            --[[ [] ]]0
          };
  end end 
end end

function exp_of_label(lbl, pos) do
  rhs = --[[ Lident ]]Block.__(0, {last$1(lbl)});
  return mkexp(--[[ Pexp_ident ]]Block.__(0, {do
                  txt: rhs,
                  loc: rhs_loc(pos)
                end}));
end end

function pat_of_label(lbl, pos) do
  rhs = last$1(lbl);
  return mkpat(--[[ Ppat_var ]]Block.__(0, {do
                  txt: rhs,
                  loc: rhs_loc(pos)
                end}));
end end

function check_variable(vl, loc, v) do
  if (List.mem(v, vl)) then do
    throw {
          __Error$3,
          --[[ Variable_in_scope ]]Block.__(4, {
              loc,
              v
            })
        };
  end else do
    return 0;
  end end 
end end

function varify_constructors(var_names, t) do
  loop = function (t) do
    match = t.ptyp_desc;
    desc;
    if (typeof match == "number") then do
      desc = --[[ Ptyp_any ]]0;
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 0--[[ Ptyp_var ]] then do
            x = match[0];
            check_variable(var_names, t.ptyp_loc, x);
            desc = --[[ Ptyp_var ]]Block.__(0, {x});end else 
         if ___conditional___ = 1--[[ Ptyp_arrow ]] then do
            desc = --[[ Ptyp_arrow ]]Block.__(1, {
                match[0],
                loop(match[1]),
                loop(match[2])
              });end else 
         if ___conditional___ = 2--[[ Ptyp_tuple ]] then do
            desc = --[[ Ptyp_tuple ]]Block.__(2, {List.map(loop, match[0])});end else 
         if ___conditional___ = 3--[[ Ptyp_constr ]] then do
            longident = match[0];
            match$1 = longident.txt;
            exit = 0;
            local ___conditional___=(match$1.tag | 0);
            do
               if ___conditional___ = 0--[[ Lident ]] then do
                  if (match[1]) then do
                    exit = 1;
                  end else do
                    s = match$1[0];
                    if (List.mem(s, var_names)) then do
                      desc = --[[ Ptyp_var ]]Block.__(0, {s});
                    end else do
                      exit = 1;
                    end end 
                  end end end else 
               if ___conditional___ = 1--[[ Ldot ]]
               or ___conditional___ = 2--[[ Lapply ]] then do
                  exit = 1;end else 
               do end end end
              
            end
            if (exit == 1) then do
              desc = --[[ Ptyp_constr ]]Block.__(3, {
                  longident,
                  List.map(loop, match[1])
                });
            end
             end end else 
         if ___conditional___ = 4--[[ Ptyp_object ]] then do
            desc = --[[ Ptyp_object ]]Block.__(4, {
                List.map((function (param) do
                        return --[[ tuple ]]{
                                param[0],
                                param[1],
                                loop(param[2])
                              };
                      end end), match[0]),
                match[1]
              });end else 
         if ___conditional___ = 5--[[ Ptyp_class ]] then do
            desc = --[[ Ptyp_class ]]Block.__(5, {
                match[0],
                List.map(loop, match[1])
              });end else 
         if ___conditional___ = 6--[[ Ptyp_alias ]] then do
            string = match[1];
            check_variable(var_names, t.ptyp_loc, string);
            desc = --[[ Ptyp_alias ]]Block.__(6, {
                loop(match[0]),
                string
              });end else 
         if ___conditional___ = 7--[[ Ptyp_variant ]] then do
            desc = --[[ Ptyp_variant ]]Block.__(7, {
                List.map(loop_row_field, match[0]),
                match[1],
                match[2]
              });end else 
         if ___conditional___ = 8--[[ Ptyp_poly ]] then do
            string_lst = match[0];
            partial_arg = t.ptyp_loc;
            List.iter((function (param) do
                    return check_variable(var_names, partial_arg, param);
                  end end), string_lst);
            desc = --[[ Ptyp_poly ]]Block.__(8, {
                string_lst,
                loop(match[1])
              });end else 
         if ___conditional___ = 9--[[ Ptyp_package ]] then do
            match$2 = match[0];
            desc = --[[ Ptyp_package ]]Block.__(9, {--[[ tuple ]]{
                  match$2[0],
                  List.map((function (param) do
                          return --[[ tuple ]]{
                                  param[0],
                                  loop(param[1])
                                };
                        end end), match$2[1])
                }});end else 
         if ___conditional___ = 10--[[ Ptyp_extension ]] then do
            match$3 = match[0];
            desc = --[[ Ptyp_extension ]]Block.__(10, {--[[ tuple ]]{
                  match$3[0],
                  match$3[1]
                }});end else 
         do end end end end end end end end end end end end
        
      end
    end end 
    return do
            ptyp_desc: desc,
            ptyp_loc: t.ptyp_loc,
            ptyp_attributes: t.ptyp_attributes
          end;
  end end;
  loop_row_field = function (param) do
    if (param.tag) then do
      return --[[ Rinherit ]]Block.__(1, {loop(param[0])});
    end else do
      return --[[ Rtag ]]Block.__(0, {
                param[0],
                param[1],
                param[2],
                List.map(loop, param[3])
              });
    end end 
  end end;
  return loop(t);
end end

function wrap_type_annotation(newtypes, core_type, body) do
  exp = mkexp(--[[ Pexp_constraint ]]Block.__(19, {
          body,
          core_type
        }));
  exp$1 = List.fold_right((function (newtype, exp) do
          return mkexp(--[[ Pexp_newtype ]]Block.__(30, {
                        newtype,
                        exp
                      }));
        end end), newtypes, exp);
  return --[[ tuple ]]{
          exp$1,
          ghtyp(--[[ Ptyp_poly ]]Block.__(8, {
                  newtypes,
                  varify_constructors(newtypes, core_type)
                }))
        };
end end

function wrap_exp_attrs(body, param) do
  ext = param[0];
  body_pexp_desc = body.pexp_desc;
  body_pexp_loc = body.pexp_loc;
  body_pexp_attributes = Pervasives.$at(param[1], body.pexp_attributes);
  body$1 = do
    pexp_desc: body_pexp_desc,
    pexp_loc: body_pexp_loc,
    pexp_attributes: body_pexp_attributes
  end;
  if (ext ~= undefined) then do
    return ghexp(--[[ Pexp_extension ]]Block.__(33, {--[[ tuple ]]{
                    ext,
                    --[[ PStr ]]Block.__(0, {--[[ :: ]]{
                          mkstrexp(body$1, --[[ [] ]]0),
                          --[[ [] ]]0
                        }})
                  }}));
  end else do
    return body$1;
  end end 
end end

function text_def(pos) do
  return --[[ :: ]]{
          --[[ Ptop_def ]]Block.__(0, {text$1(get_text(Parsing.rhs_start_pos(pos)))}),
          --[[ [] ]]0
        };
end end

function extra_text(text, pos, items) do
  pre_extras = get_pre_extra_text(Parsing.rhs_start_pos(pos));
  post_extras = get_post_extra_text(Parsing.rhs_end_pos(pos));
  return Pervasives.$at(Curry._1(text, pre_extras), Pervasives.$at(items, Curry._1(text, post_extras)));
end end

function extra_cstr(pos, items) do
  return extra_text(Ast_helper_Cf.text, pos, items);
end end

function extra_csig(pos, items) do
  return extra_text(Ast_helper_Ctf.text, pos, items);
end end

function add_nonrec(rf, attrs, pos) do
  if (rf) then do
    return attrs;
  end else do
    name_loc = rhs_loc(pos);
    name = do
      txt: "nonrec",
      loc: name_loc
    end;
    return --[[ :: ]]{
            --[[ tuple ]]{
              name,
              --[[ PStr ]]Block.__(0, {--[[ [] ]]0})
            },
            attrs
          };
  end end 
end end

function mklb(param, attrs) do
  return do
          lb_pattern: param[0],
          lb_expression: param[1],
          lb_attributes: attrs,
          lb_docs: symbol_docs_lazy(--[[ () ]]0),
          lb_text: symbol_text_lazy(--[[ () ]]0),
          lb_loc: symbol_rloc(--[[ () ]]0)
        end;
end end

yytransl_const = {
  257,
  258,
  259,
  260,
  261,
  262,
  263,
  264,
  265,
  266,
  267,
  269,
  270,
  271,
  272,
  273,
  274,
  275,
  276,
  277,
  278,
  279,
  280,
  281,
  282,
  0,
  283,
  284,
  285,
  286,
  288,
  289,
  290,
  291,
  292,
  293,
  294,
  295,
  296,
  297,
  303,
  304,
  309,
  310,
  311,
  312,
  313,
  314,
  315,
  316,
  317,
  318,
  319,
  320,
  322,
  323,
  324,
  325,
  326,
  327,
  328,
  329,
  330,
  331,
  332,
  334,
  335,
  336,
  337,
  338,
  340,
  341,
  342,
  343,
  344,
  346,
  347,
  348,
  349,
  350,
  351,
  352,
  353,
  354,
  355,
  357,
  358,
  360,
  361,
  362,
  363,
  364,
  365,
  366,
  368,
  369,
  370,
  371,
  372,
  373,
  376,
  0
};

yytransl_block = {
  268,
  287,
  298,
  299,
  300,
  301,
  302,
  305,
  306,
  307,
  308,
  321,
  333,
  339,
  345,
  356,
  359,
  367,
  374,
  375,
  0
};

yyact = {
  (function (param) do
      throw {
            Caml_builtin_exceptions.failure,
            "parser"
          };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      return extra_text(text$1, 1, _1);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      return extra_text(text, 1, _1);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ Ptop_def ]]Block.__(0, {extra_text(text$1, 1, _1)});
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 1);
    end end),
  (function (__caml_parser_env) do
      throw Caml_builtin_exceptions.end_of_file;
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text$1(get_text(Parsing.rhs_start_pos(1))), --[[ :: ]]{
                  mkstrexp(_1, _2),
                  --[[ [] ]]0
                });
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      return --[[ [] ]]0;
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text$1(get_text(Parsing.rhs_start_pos(1))), --[[ :: ]]{
                  _1,
                  _2
                });
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      pos = 1;
      items = _1;
      return extra_text((function (txt) do
                    return --[[ :: ]]{
                            --[[ Ptop_def ]]Block.__(0, {text$1(txt)}),
                            --[[ [] ]]0
                          };
                  end end), pos, items);
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text_def(1), --[[ :: ]]{
                  --[[ Ptop_def ]]Block.__(0, {--[[ :: ]]{
                        mkstrexp(_1, _2),
                        --[[ [] ]]0
                      }}),
                  _3
                });
    end end),
  (function (__caml_parser_env) do
      return --[[ [] ]]0;
    end end),
  (function (__caml_parser_env) do
      return text_def(1);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      mark_rhs_docs(2, 3);
      return Pervasives.$at(text_def(1), Pervasives.$at(text_def(2), --[[ :: ]]{
                      --[[ Ptop_def ]]Block.__(0, {--[[ :: ]]{
                            mkstrexp(_2, _3),
                            --[[ [] ]]0
                          }}),
                      _4
                    }));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text_def(1), Pervasives.$at(text_def(2), --[[ :: ]]{
                      --[[ Ptop_def ]]Block.__(0, {--[[ :: ]]{
                            _2,
                            --[[ [] ]]0
                          }}),
                      _3
                    }));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      mark_rhs_docs(2, 3);
      return Pervasives.$at(text_def(1), Pervasives.$at(text_def(2), --[[ :: ]]{
                      _2,
                      _3
                    }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text_def(1), --[[ :: ]]{
                  --[[ Ptop_def ]]Block.__(0, {--[[ :: ]]{
                        _1,
                        --[[ [] ]]0
                      }}),
                  _2
                });
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      mark_rhs_docs(1, 1);
      return Pervasives.$at(text_def(1), --[[ :: ]]{
                  _1,
                  _2
                });
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 1);
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 1);
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 1);
    end end),
  (function (__caml_parser_env) do
      return --[[ tuple ]]{
              do
                txt: "*",
                loc: rhs_loc(2)
              end,
              undefined
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ tuple ]]{
              do
                txt: _2,
                loc: rhs_loc(2)
              end,
              _4
            };
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      return "_";
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _2,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmod(--[[ Pmod_ident ]]Block.__(0, {do
                      txt: _1,
                      loc: rhs_loc(1)
                    end}));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmod(--[[ Pmod_structure ]]Block.__(1, {extra_text(text$1, 2, _2)}));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("struct", 1, "end", 3);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return List.fold_left((function (acc, param) do
                    return mkmod(--[[ Pmod_functor ]]Block.__(2, {
                                  param[0],
                                  param[1],
                                  acc
                                }));
                  end end), _4, _2);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 3);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmod(--[[ Pmod_apply ]]Block.__(3, {
                    _1,
                    _3
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      return mkmod(--[[ Pmod_apply ]]Block.__(3, {
                    _1,
                    mkmod(--[[ Pmod_structure ]]Block.__(1, {--[[ [] ]]0}))
                  }));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 2, ")", 4);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmod(--[[ Pmod_constraint ]]Block.__(4, {
                    _2,
                    _4
                  }));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 5);
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 1);
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    end end),
  (function (__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmod(--[[ Pmod_unpack ]]Block.__(5, {_3}));
    end end),
  (function (__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      _5 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmod(--[[ Pmod_unpack ]]Block.__(5, {ghexp(--[[ Pexp_constraint ]]Block.__(19, {
                            _3,
                            ghtyp(--[[ Ptyp_package ]]Block.__(9, {_5}))
                          }))}));
    end end),
  (function (__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 5);
      _5 = Parsing.peek_val(__caml_parser_env, 3);
      _7 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmod(--[[ Pmod_unpack ]]Block.__(5, {ghexp(--[[ Pexp_coerce ]]Block.__(20, {
                            _3,
                            ghtyp(--[[ Ptyp_package ]]Block.__(9, {_5})),
                            ghtyp(--[[ Ptyp_package ]]Block.__(9, {_7}))
                          }))}));
    end end),
  (function (__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      _5 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmod(--[[ Pmod_unpack ]]Block.__(5, {ghexp(--[[ Pexp_coerce ]]Block.__(20, {
                            _3,
                            undefined,
                            ghtyp(--[[ Ptyp_package ]]Block.__(9, {_5}))
                          }))}));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      return unclosed("(", 1, ")", 5);
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      return unclosed("(", 1, ")", 5);
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 4);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return attr$4(_1, _2);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmod(--[[ Pmod_extension ]]Block.__(6, {_1}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      mark_rhs_docs(1, 2);
      return Pervasives.$at(text$1(get_text(Parsing.rhs_start_pos(1))), --[[ :: ]]{
                  mkstrexp(_1, _2),
                  _3
                });
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      return --[[ [] ]]0;
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text$1(get_text(Parsing.rhs_start_pos(1))), _2);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text$1(get_text(Parsing.rhs_start_pos(1))), --[[ :: ]]{
                  _1,
                  _2
                });
    end end),
  (function (__caml_parser_env) do
      lbs = Parsing.peek_val(__caml_parser_env, 0);
      bindings = lbs.lbs_bindings;
      str;
      exit = 0;
      if (bindings) then do
        lb = bindings[0];
        if (typeof lb.lb_pattern.ppat_desc == "number" and not bindings[1]) then do
          exp = wrap_exp_attrs(lb.lb_expression, --[[ tuple ]]{
                undefined,
                lbs.lbs_attributes
              });
          str = mkstr(--[[ Pstr_eval ]]Block.__(0, {
                  exp,
                  lb.lb_attributes
                }));
        end else do
          exit = 1;
        end end 
      end else do
        exit = 1;
      end end 
      if (exit == 1) then do
        if (lbs.lbs_attributes ~= --[[ [] ]]0) then do
          throw {
                __Error$3,
                --[[ Not_expecting ]]Block.__(2, {
                    lbs.lbs_loc,
                    "attributes"
                  })
              };
        end
         end 
        bindings$1 = List.map((function (lb) do
                return mk$17(lb.lb_loc, lb.lb_attributes, CamlinternalLazy.force(lb.lb_docs), CamlinternalLazy.force(lb.lb_text), lb.lb_pattern, lb.lb_expression);
              end end), bindings);
        str = mkstr(--[[ Pstr_value ]]Block.__(1, {
                lbs.lbs_rec,
                List.rev(bindings$1)
              }));
      end
       end 
      match = lbs.lbs_extension;
      if (match ~= undefined) then do
        d = --[[ Pstr_extension ]]Block.__(14, {
            --[[ tuple ]]{
              match,
              --[[ PStr ]]Block.__(0, {--[[ :: ]]{
                    str,
                    --[[ [] ]]0
                  }})
            },
            --[[ [] ]]0
          });
        return mk$6(symbol_gloc(--[[ () ]]0), d);
      end else do
        return str;
      end end 
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(--[[ Pstr_primitive ]]Block.__(2, {_1}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(--[[ Pstr_type ]]Block.__(3, {List.rev(_1)}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(--[[ Pstr_typext ]]Block.__(4, {_1}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(--[[ Pstr_exception ]]Block.__(5, {_1}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(--[[ Pstr_module ]]Block.__(6, {_1}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(--[[ Pstr_recmodule ]]Block.__(7, {List.rev(_1)}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(--[[ Pstr_modtype ]]Block.__(8, {_1}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(--[[ Pstr_open ]]Block.__(9, {_1}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(--[[ Pstr_class ]]Block.__(10, {List.rev(_1)}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(--[[ Pstr_class_type ]]Block.__(11, {List.rev(_1)}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(--[[ Pstr_include ]]Block.__(12, {_1}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(--[[ Pstr_extension ]]Block.__(14, {
                    _1,
                    add_docs_attrs(symbol_docs(--[[ () ]]0), _2)
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      mark_symbol_docs(--[[ () ]]0);
      return mkstr(--[[ Pstr_attribute ]]Block.__(13, {_1}));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$16(symbol_rloc(--[[ () ]]0), _3, symbol_docs(--[[ () ]]0), _2);
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmod(--[[ Pmod_constraint ]]Block.__(4, {
                    _4,
                    _2
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmod(--[[ Pmod_functor ]]Block.__(2, {
                    _1[0],
                    _1[1],
                    _2
                  }));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$14(symbol_rloc(--[[ () ]]0), _4, symbol_docs(--[[ () ]]0), undefined, do
                  txt: _2,
                  loc: rhs_loc(2)
                end, _3);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _2,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$14(symbol_rloc(--[[ () ]]0), _5, symbol_docs(--[[ () ]]0), undefined, do
                  txt: _3,
                  loc: rhs_loc(3)
                end, _4);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$14(symbol_rloc(--[[ () ]]0), _4, symbol_docs(--[[ () ]]0), get_text(Parsing.symbol_start_pos(--[[ () ]]0)), do
                  txt: _2,
                  loc: rhs_loc(2)
                end, _3);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmty(--[[ Pmty_ident ]]Block.__(0, {do
                      txt: _1,
                      loc: rhs_loc(1)
                    end}));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmty(--[[ Pmty_signature ]]Block.__(1, {extra_text(text, 2, _2)}));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("sig", 1, "end", 3);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return List.fold_left((function (acc, param) do
                    return mkmty(--[[ Pmty_functor ]]Block.__(2, {
                                  param[0],
                                  param[1],
                                  acc
                                }));
                  end end), _4, _2);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmty(--[[ Pmty_with ]]Block.__(3, {
                    _1,
                    List.rev(_3)
                  }));
    end end),
  (function (__caml_parser_env) do
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmty(--[[ Pmty_typeof ]]Block.__(4, {_4}));
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 1);
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmty(--[[ Pmty_extension ]]Block.__(5, {_1}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return attr$3(_1, _2);
    end end),
  (function (__caml_parser_env) do
      return --[[ [] ]]0;
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text(get_text(Parsing.rhs_start_pos(1))), _2);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text(get_text(Parsing.rhs_start_pos(1))), --[[ :: ]]{
                  _1,
                  _2
                });
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(--[[ Psig_value ]]Block.__(0, {_1}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(--[[ Psig_value ]]Block.__(0, {_1}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(--[[ Psig_type ]]Block.__(1, {List.rev(_1)}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(--[[ Psig_typext ]]Block.__(2, {_1}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(--[[ Psig_exception ]]Block.__(3, {_1}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(--[[ Psig_module ]]Block.__(4, {_1}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(--[[ Psig_module ]]Block.__(4, {_1}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(--[[ Psig_recmodule ]]Block.__(5, {List.rev(_1)}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(--[[ Psig_modtype ]]Block.__(6, {_1}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(--[[ Psig_open ]]Block.__(7, {_1}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(--[[ Psig_include ]]Block.__(8, {_1}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(--[[ Psig_class ]]Block.__(9, {List.rev(_1)}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(--[[ Psig_class_type ]]Block.__(10, {List.rev(_1)}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(--[[ Psig_extension ]]Block.__(12, {
                    _1,
                    add_docs_attrs(symbol_docs(--[[ () ]]0), _2)
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      mark_symbol_docs(--[[ () ]]0);
      return mksig(--[[ Psig_attribute ]]Block.__(11, {_1}));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$15(symbol_rloc(--[[ () ]]0), _4, symbol_docs(--[[ () ]]0), _2, do
                  txt: _3,
                  loc: rhs_loc(3)
                end);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$16(symbol_rloc(--[[ () ]]0), _3, symbol_docs(--[[ () ]]0), _2);
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmty(--[[ Pmty_functor ]]Block.__(2, {
                    do
                      txt: _2,
                      loc: rhs_loc(2)
                    end,
                    _4,
                    _6
                  }));
    end end),
  (function (__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmty(--[[ Pmty_functor ]]Block.__(2, {
                    do
                      txt: "*",
                      loc: rhs_loc(1)
                    end,
                    undefined,
                    _3
                  }));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$12(symbol_rloc(--[[ () ]]0), _4, symbol_docs(--[[ () ]]0), undefined, do
                  txt: _2,
                  loc: rhs_loc(2)
                end, _3);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$12(symbol_rloc(--[[ () ]]0), _5, symbol_docs(--[[ () ]]0), undefined, do
                  txt: _2,
                  loc: rhs_loc(2)
                end, alias$2(rhs_loc(4), undefined, do
                      txt: _4,
                      loc: rhs_loc(4)
                    end));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _2,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      _5 = Parsing.peek_val(__caml_parser_env, 1);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$12(symbol_rloc(--[[ () ]]0), _6, symbol_docs(--[[ () ]]0), undefined, do
                  txt: _3,
                  loc: rhs_loc(3)
                end, _5);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$12(symbol_rloc(--[[ () ]]0), _5, symbol_docs(--[[ () ]]0), get_text(Parsing.symbol_start_pos(--[[ () ]]0)), do
                  txt: _2,
                  loc: rhs_loc(2)
                end, _4);
    end end),
  (function (__caml_parser_env) do
      return ;
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$13(symbol_rloc(--[[ () ]]0), _5, symbol_docs(--[[ () ]]0), undefined, _4, do
                  txt: _3,
                  loc: rhs_loc(3)
                end);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _2,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 1);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$18(symbol_rloc(--[[ () ]]0), _6, symbol_docs(--[[ () ]]0), undefined, _2, _3, do
                  txt: _4,
                  loc: rhs_loc(4)
                end, _5);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 1);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$18(symbol_rloc(--[[ () ]]0), _6, symbol_docs(--[[ () ]]0), get_text(Parsing.symbol_start_pos(--[[ () ]]0)), _2, _3, do
                  txt: _4,
                  loc: rhs_loc(4)
                end, _5);
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(--[[ Pcl_constraint ]]Block.__(5, {
                    _4,
                    _2
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(--[[ Pcl_fun ]]Block.__(2, {
                    _1[0],
                    _1[1],
                    _1[2],
                    _2
                  }));
    end end),
  (function (__caml_parser_env) do
      return --[[ [] ]]0;
    end end),
  (function (__caml_parser_env) do
      return List.rev(Parsing.peek_val(__caml_parser_env, 1));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(--[[ Pcl_fun ]]Block.__(2, {
                    _1[0],
                    _1[1],
                    _1[2],
                    _3
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(--[[ Pcl_fun ]]Block.__(2, {
                    _1[0],
                    _1[1],
                    _1[2],
                    _2
                  }));
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(--[[ Pcl_apply ]]Block.__(3, {
                    _1,
                    List.rev(_2)
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      lbs = _1;
      body = _3;
      bindings = List.map((function (lb) do
              if (lb.lb_attributes ~= --[[ [] ]]0) then do
                throw {
                      __Error$3,
                      --[[ Not_expecting ]]Block.__(2, {
                          lb.lb_loc,
                          "item attribute"
                        })
                    };
              end
               end 
              return mk$17(lb.lb_loc, undefined, undefined, undefined, lb.lb_pattern, lb.lb_expression);
            end end), lbs.lbs_bindings);
      if (lbs.lbs_extension ~= undefined) then do
        throw {
              __Error$3,
              --[[ Not_expecting ]]Block.__(2, {
                  lbs.lbs_loc,
                  "extension"
                })
            };
      end
       end 
      if (lbs.lbs_attributes ~= --[[ [] ]]0) then do
        throw {
              __Error$3,
              --[[ Not_expecting ]]Block.__(2, {
                  lbs.lbs_loc,
                  "attributes"
                })
            };
      end
       end 
      return mkclass(--[[ Pcl_let ]]Block.__(4, {
                    lbs.lbs_rec,
                    List.rev(bindings),
                    body
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return attr$5(_1, _2);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(--[[ Pcl_extension ]]Block.__(6, {_1}));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(--[[ Pcl_constr ]]Block.__(0, {
                    do
                      txt: _4,
                      loc: rhs_loc(4)
                    end,
                    List.rev(_2)
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(--[[ Pcl_constr ]]Block.__(0, {
                    do
                      txt: _1,
                      loc: rhs_loc(1)
                    end,
                    --[[ [] ]]0
                  }));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mkclass(--[[ Pcl_structure ]]Block.__(1, {_2}));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("object", 1, "end", 3);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mkclass(--[[ Pcl_constraint ]]Block.__(5, {
                    _2,
                    _4
                  }));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 5);
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 1);
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return do
              pcstr_self: _1,
              pcstr_fields: extra_cstr(2, List.rev(_2))
            end;
    end end),
  (function (__caml_parser_env) do
      return reloc_pat(Parsing.peek_val(__caml_parser_env, 1));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mkpat(--[[ Ppat_constraint ]]Block.__(10, {
                    _2,
                    _4
                  }));
    end end),
  (function (__caml_parser_env) do
      return ghpat(--[[ Ppat_any ]]0);
    end end),
  (function (__caml_parser_env) do
      return --[[ [] ]]0;
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(--[[ :: ]]{
                  _2,
                  Curry._1(Ast_helper_Cf.text, get_text(Parsing.rhs_start_pos(2)))
                }, _1);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(_5, symbol_docs(--[[ () ]]0), --[[ Pcf_inherit ]]Block.__(0, {
                    _2,
                    _3,
                    _4
                  }));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(_3, symbol_docs(--[[ () ]]0), --[[ Pcf_val ]]Block.__(1, {_2}));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(_3, symbol_docs(--[[ () ]]0), --[[ Pcf_method ]]Block.__(2, {_2}));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(_3, symbol_docs(--[[ () ]]0), --[[ Pcf_constraint ]]Block.__(3, {_2}));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(_3, symbol_docs(--[[ () ]]0), --[[ Pcf_initializer ]]Block.__(4, {_2}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(_2, symbol_docs(--[[ () ]]0), --[[ Pcf_extension ]]Block.__(6, {_1}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      mark_symbol_docs(--[[ () ]]0);
      return mkcf(undefined, undefined, --[[ Pcf_attribute ]]Block.__(5, {_1}));
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      return ;
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 5);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      if (_1 == --[[ Override ]]0) then do
        throw Escape_error;
      end
       end 
      return --[[ tuple ]]{
              do
                txt: _4,
                loc: rhs_loc(4)
              end,
              --[[ Mutable ]]1,
              --[[ Cfk_virtual ]]Block.__(0, {_6})
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              do
                txt: _3,
                loc: rhs_loc(3)
              end,
              _2,
              --[[ Cfk_virtual ]]Block.__(0, {_5})
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              do
                txt: _3,
                loc: rhs_loc(3)
              end,
              _2,
              --[[ Cfk_concrete ]]Block.__(1, {
                  _1,
                  _5
                })
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 5);
      _2 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      e = mkexp_constraint(_6, _4);
      return --[[ tuple ]]{
              do
                txt: _3,
                loc: rhs_loc(3)
              end,
              _2,
              --[[ Cfk_concrete ]]Block.__(1, {
                  _1,
                  e
                })
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 5);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      if (_1 == --[[ Override ]]0) then do
        throw Escape_error;
      end
       end 
      return --[[ tuple ]]{
              do
                txt: _4,
                loc: rhs_loc(4)
              end,
              --[[ Private ]]0,
              --[[ Cfk_virtual ]]Block.__(0, {_6})
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 5);
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      if (_1 == --[[ Override ]]0) then do
        throw Escape_error;
      end
       end 
      return --[[ tuple ]]{
              do
                txt: _4,
                loc: rhs_loc(4)
              end,
              _3,
              --[[ Cfk_virtual ]]Block.__(0, {_6})
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 3);
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              do
                txt: _3,
                loc: rhs_loc(3)
              end,
              _2,
              --[[ Cfk_concrete ]]Block.__(1, {
                  _1,
                  ghexp(--[[ Pexp_poly ]]Block.__(28, {
                          _4,
                          undefined
                        }))
                })
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 6);
      _2 = Parsing.peek_val(__caml_parser_env, 5);
      _3 = Parsing.peek_val(__caml_parser_env, 4);
      _5 = Parsing.peek_val(__caml_parser_env, 2);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              do
                txt: _3,
                loc: rhs_loc(3)
              end,
              _2,
              --[[ Cfk_concrete ]]Block.__(1, {
                  _1,
                  ghexp(--[[ Pexp_poly ]]Block.__(28, {
                          _7,
                          _5
                        }))
                })
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 9);
      _2 = Parsing.peek_val(__caml_parser_env, 8);
      _3 = Parsing.peek_val(__caml_parser_env, 7);
      _6 = Parsing.peek_val(__caml_parser_env, 4);
      _8 = Parsing.peek_val(__caml_parser_env, 2);
      _10 = Parsing.peek_val(__caml_parser_env, 0);
      match = wrap_type_annotation(_6, _8, _10);
      return --[[ tuple ]]{
              do
                txt: _3,
                loc: rhs_loc(3)
              end,
              _2,
              --[[ Cfk_concrete ]]Block.__(1, {
                  _1,
                  ghexp(--[[ Pexp_poly ]]Block.__(28, {
                          match[0],
                          match[1]
                        }))
                })
            };
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcty(--[[ Pcty_arrow ]]Block.__(2, {
                    "?" .. _2,
                    mkoption(_4),
                    _6
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 3);
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcty(--[[ Pcty_arrow ]]Block.__(2, {
                    "?" .. _1,
                    mkoption(_2),
                    _4
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcty(--[[ Pcty_arrow ]]Block.__(2, {
                    _1,
                    _3,
                    _5
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcty(--[[ Pcty_arrow ]]Block.__(2, {
                    "",
                    _1,
                    _3
                  }));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcty(--[[ Pcty_constr ]]Block.__(0, {
                    do
                      txt: _4,
                      loc: rhs_loc(4)
                    end,
                    List.rev(_2)
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcty(--[[ Pcty_constr ]]Block.__(0, {
                    do
                      txt: _1,
                      loc: rhs_loc(1)
                    end,
                    --[[ [] ]]0
                  }));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mkcty(--[[ Pcty_signature ]]Block.__(1, {_2}));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("object", 1, "end", 3);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return attr$6(_1, _2);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcty(--[[ Pcty_extension ]]Block.__(3, {_1}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return do
              pcsig_self: _1,
              pcsig_fields: extra_csig(2, List.rev(_2))
            end;
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 1);
    end end),
  (function (__caml_parser_env) do
      return mktyp(--[[ Ptyp_any ]]0);
    end end),
  (function (__caml_parser_env) do
      return --[[ [] ]]0;
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(--[[ :: ]]{
                  _2,
                  Curry._1(Ast_helper_Ctf.text, get_text(Parsing.rhs_start_pos(2)))
                }, _1);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkctf(_3, symbol_docs(--[[ () ]]0), --[[ Pctf_inherit ]]Block.__(0, {_2}));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkctf(_3, symbol_docs(--[[ () ]]0), --[[ Pctf_val ]]Block.__(1, {_2}));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      _5 = Parsing.peek_val(__caml_parser_env, 1);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mkctf(_6, symbol_docs(--[[ () ]]0), --[[ Pctf_method ]]Block.__(2, {--[[ tuple ]]{
                      _3,
                      _2[0],
                      _2[1],
                      _5
                    }}));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkctf(_3, symbol_docs(--[[ () ]]0), --[[ Pctf_constraint ]]Block.__(3, {_2}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkctf(_2, symbol_docs(--[[ () ]]0), --[[ Pctf_extension ]]Block.__(5, {_1}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      mark_symbol_docs(--[[ () ]]0);
      return mkctf(undefined, undefined, --[[ Pctf_attribute ]]Block.__(4, {_1}));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _3,
              _2,
              --[[ Virtual ]]0,
              _5
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _3,
              --[[ Mutable ]]1,
              _2,
              _5
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _1,
              --[[ Immutable ]]0,
              --[[ Concrete ]]1,
              _3
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _1,
              _3,
              symbol_rloc(--[[ () ]]0)
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _1,
              _3
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _2,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 5);
      _3 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 3);
      _6 = Parsing.peek_val(__caml_parser_env, 1);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$18(symbol_rloc(--[[ () ]]0), _7, symbol_docs(--[[ () ]]0), undefined, _2, _3, do
                  txt: _4,
                  loc: rhs_loc(4)
                end, _6);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 5);
      _3 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 3);
      _6 = Parsing.peek_val(__caml_parser_env, 1);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$18(symbol_rloc(--[[ () ]]0), _7, symbol_docs(--[[ () ]]0), get_text(Parsing.symbol_start_pos(--[[ () ]]0)), _2, _3, do
                  txt: _4,
                  loc: rhs_loc(4)
                end, _6);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _2,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 5);
      _4 = Parsing.peek_val(__caml_parser_env, 4);
      _5 = Parsing.peek_val(__caml_parser_env, 3);
      _7 = Parsing.peek_val(__caml_parser_env, 1);
      _8 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$18(symbol_rloc(--[[ () ]]0), _8, symbol_docs(--[[ () ]]0), undefined, _3, _4, do
                  txt: _5,
                  loc: rhs_loc(5)
                end, _7);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 5);
      _3 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 3);
      _6 = Parsing.peek_val(__caml_parser_env, 1);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$18(symbol_rloc(--[[ () ]]0), _7, symbol_docs(--[[ () ]]0), get_text(Parsing.symbol_start_pos(--[[ () ]]0)), _2, _3, do
                  txt: _4,
                  loc: rhs_loc(4)
                end, _6);
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      return reloc_exp(Parsing.peek_val(__caml_parser_env, 1));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_sequence ]]Block.__(16, {
                    _1,
                    _3
                  }));
    end end),
  (function (__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ tuple ]]{
              "?" .. _3[0],
              _4,
              _3[1]
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              "?" .. _2[0],
              undefined,
              _2[1]
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ tuple ]]{
              "?" .. _1,
              _4,
              _3
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              "?" .. _1,
              undefined,
              _2
            };
    end end),
  (function (__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ tuple ]]{
              _3[0],
              undefined,
              _3[1]
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _2[0],
              undefined,
              _2[1]
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _1,
              undefined,
              _2
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              "",
              undefined,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_var ]]Block.__(0, {do
                      txt: _1,
                      loc: rhs_loc(1)
                    end}));
    end end),
  (function (__caml_parser_env) do
      return mkpat(--[[ Ppat_any ]]0);
    end end),
  (function (__caml_parser_env) do
      return ;
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _1[0],
              mkpat(--[[ Ppat_constraint ]]Block.__(10, {
                      _1[1],
                      _3
                    }))
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _1,
              mkpat(--[[ Ppat_var ]]Block.__(0, {do
                        txt: _1,
                        loc: rhs_loc(1)
                      end}))
            };
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_constraint ]]Block.__(10, {
                    _1,
                    _3
                  }));
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                    _1,
                    List.rev(_2)
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      lbs = _1;
      body = _3;
      bindings = List.map((function (lb) do
              if (lb.lb_attributes ~= --[[ [] ]]0) then do
                throw {
                      __Error$3,
                      --[[ Not_expecting ]]Block.__(2, {
                          lb.lb_loc,
                          "item attribute"
                        })
                    };
              end
               end 
              return mk$17(lb.lb_loc, undefined, undefined, undefined, lb.lb_pattern, lb.lb_expression);
            end end), lbs.lbs_bindings);
      d_000 = lbs.lbs_rec;
      d_001 = List.rev(bindings);
      d = --[[ Pexp_let ]]Block.__(2, {
          d_000,
          d_001,
          body
        });
      return wrap_exp_attrs(mkexp(d), --[[ tuple ]]{
                  lbs.lbs_extension,
                  lbs.lbs_attributes
                });
    end end),
  (function (__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 3);
      _5 = Parsing.peek_val(__caml_parser_env, 2);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      d_000 = do
        txt: _4,
        loc: rhs_loc(4)
      end;
      d = --[[ Pexp_letmodule ]]Block.__(25, {
          d_000,
          _5,
          _7
        });
      return wrap_exp_attrs(mkexp(d), _3);
    end end),
  (function (__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 3);
      _5 = Parsing.peek_val(__caml_parser_env, 2);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      d_001 = do
        txt: _5,
        loc: rhs_loc(5)
      end;
      d = --[[ Pexp_open ]]Block.__(32, {
          _3,
          d_001,
          _7
        });
      return wrap_exp_attrs(mkexp(d), _4);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      d = --[[ Pexp_function ]]Block.__(3, {List.rev(_4)});
      return wrap_exp_attrs(mkexp(d), _2);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp(--[[ Pexp_fun ]]Block.__(4, {
                        _3[0],
                        _3[1],
                        _3[2],
                        _4
                      })), _2);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 5);
      _5 = Parsing.peek_val(__caml_parser_env, 2);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp(--[[ Pexp_newtype ]]Block.__(30, {
                        _5,
                        _7
                      })), _2);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      d_001 = List.rev(_6);
      d = --[[ Pexp_match ]]Block.__(6, {
          _3,
          d_001
        });
      return wrap_exp_attrs(mkexp(d), _2);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      d_001 = List.rev(_6);
      d = --[[ Pexp_try ]]Block.__(7, {
          _3,
          d_001
        });
      return wrap_exp_attrs(mkexp(d), _2);
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 2);
      throw Escape_error;
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_tuple ]]Block.__(8, {List.rev(_1)}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_construct ]]Block.__(9, {
                    do
                      txt: _1,
                      loc: rhs_loc(1)
                    end,
                    _2
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_variant ]]Block.__(10, {
                    _1,
                    _2
                  }));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 5);
      _3 = Parsing.peek_val(__caml_parser_env, 4);
      _5 = Parsing.peek_val(__caml_parser_env, 2);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp(--[[ Pexp_ifthenelse ]]Block.__(15, {
                        _3,
                        _5,
                        _7
                      })), _2);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp(--[[ Pexp_ifthenelse ]]Block.__(15, {
                        _3,
                        _5,
                        undefined
                      })), _2);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      _5 = Parsing.peek_val(__caml_parser_env, 1);
      return wrap_exp_attrs(mkexp(--[[ Pexp_while ]]Block.__(17, {
                        _3,
                        _5
                      })), _2);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 8);
      _3 = Parsing.peek_val(__caml_parser_env, 7);
      _5 = Parsing.peek_val(__caml_parser_env, 5);
      _6 = Parsing.peek_val(__caml_parser_env, 4);
      _7 = Parsing.peek_val(__caml_parser_env, 3);
      _9 = Parsing.peek_val(__caml_parser_env, 1);
      return wrap_exp_attrs(mkexp(--[[ Pexp_for ]]Block.__(18, {
                        _3,
                        _5,
                        _7,
                        _6,
                        _9
                      })), _2);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp_cons(rhs_loc(2), ghexp(--[[ Pexp_tuple ]]Block.__(8, {--[[ :: ]]{
                          _1,
                          --[[ :: ]]{
                            _3,
                            --[[ [] ]]0
                          }
                        }})), symbol_rloc(--[[ () ]]0));
    end end),
  (function (__caml_parser_env) do
      _5 = Parsing.peek_val(__caml_parser_env, 3);
      _7 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp_cons(rhs_loc(2), ghexp(--[[ Pexp_tuple ]]Block.__(8, {--[[ :: ]]{
                          _5,
                          --[[ :: ]]{
                            _7,
                            --[[ [] ]]0
                          }
                        }})), symbol_rloc(--[[ () ]]0));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "+", _3);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "+.", _3);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "+=", _3);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "-", _3);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "-.", _3);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "*", _3);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "%", _3);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "=", _3);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "<", _3);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, ">", _3);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "or", _3);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "||", _3);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "&", _3);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "&&", _3);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, ":=", _3);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      name = _1;
      arg = _2;
      match = arg.pexp_desc;
      exit = 0;
      local ___conditional___=(name);
      do
         if ___conditional___ = "-" then do
            if (match.tag == --[[ Pexp_constant ]]1) then do
              match$1 = match[0];
              local ___conditional___=(match$1.tag | 0);
              do
                 if ___conditional___ = 0--[[ Const_int ]] then do
                    return mkexp(--[[ Pexp_constant ]]Block.__(1, {--[[ Const_int ]]Block.__(0, {-match$1[0] | 0})}));end end end 
                 if ___conditional___ = 4--[[ Const_int32 ]] then do
                    return mkexp(--[[ Pexp_constant ]]Block.__(1, {--[[ Const_int32 ]]Block.__(4, {-match$1[0] | 0})}));end end end 
                 if ___conditional___ = 5--[[ Const_int64 ]] then do
                    return mkexp(--[[ Pexp_constant ]]Block.__(1, {--[[ Const_int64 ]]Block.__(5, {Caml_int64.neg(match$1[0])})}));end end end 
                 if ___conditional___ = 6--[[ Const_nativeint ]] then do
                    return mkexp(--[[ Pexp_constant ]]Block.__(1, {--[[ Const_nativeint ]]Block.__(6, {-match$1[0]})}));end end end 
                 do
                else do
                  exit = 2;
                  end end
                  
              end
            end else do
              exit = 2;
            end end end else 
         if ___conditional___ = "-." then do
            exit = 2;end else 
         do end end end
        else do
          end end
          
      end
      if (exit == 2 and match.tag == --[[ Pexp_constant ]]1) then do
        match$2 = match[0];
        if (match$2.tag == --[[ Const_float ]]3) then do
          return mkexp(--[[ Pexp_constant ]]Block.__(1, {--[[ Const_float ]]Block.__(3, {neg_float_string(match$2[0])})}));
        end
         end 
      end
       end 
      return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                    mkoperator("~" .. name, 1),
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        "",
                        arg
                      },
                      --[[ [] ]]0
                    }
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      name = _1;
      arg = _2;
      desc = arg.pexp_desc;
      exit = 0;
      local ___conditional___=(name);
      do
         if ___conditional___ = "+" then do
            if (desc.tag == --[[ Pexp_constant ]]1) then do
              local ___conditional___=(desc[0].tag | 0);
              do
                 if ___conditional___ = 1--[[ Const_char ]]
                 or ___conditional___ = 2--[[ Const_string ]]
                 or ___conditional___ = 3--[[ Const_float ]] then do
                    exit = 2;end else 
                 do end end
                else do
                  return mkexp(desc);
                  end end
                  
              end
            end else do
              exit = 2;
            end end end else 
         if ___conditional___ = "+." then do
            exit = 2;end else 
         do end end end
        else do
          end end
          
      end
      if (exit == 2 and desc.tag == --[[ Pexp_constant ]]1 and desc[0].tag == --[[ Const_float ]]3) then do
        return mkexp(desc);
      end
       end 
      return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                    mkoperator("~" .. name, 1),
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        "",
                        arg
                      },
                      --[[ [] ]]0
                    }
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_setfield ]]Block.__(13, {
                    _1,
                    do
                      txt: _3,
                      loc: rhs_loc(3)
                    end,
                    _5
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 6);
      _4 = Parsing.peek_val(__caml_parser_env, 3);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                    ghexp(--[[ Pexp_ident ]]Block.__(0, {array_function("Array", "set")})),
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        "",
                        _1
                      },
                      --[[ :: ]]{
                        --[[ tuple ]]{
                          "",
                          _4
                        },
                        --[[ :: ]]{
                          --[[ tuple ]]{
                            "",
                            _7
                          },
                          --[[ [] ]]0
                        }
                      }
                    }
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 6);
      _4 = Parsing.peek_val(__caml_parser_env, 3);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                    ghexp(--[[ Pexp_ident ]]Block.__(0, {array_function("String", "set")})),
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        "",
                        _1
                      },
                      --[[ :: ]]{
                        --[[ tuple ]]{
                          "",
                          _4
                        },
                        --[[ :: ]]{
                          --[[ tuple ]]{
                            "",
                            _7
                          },
                          --[[ [] ]]0
                        }
                      }
                    }
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 6);
      _4 = Parsing.peek_val(__caml_parser_env, 3);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      arr = _1;
      arg = _4;
      newval = _7;
      set = fast.contents and "unsafe_set" or "set";
      coords = bigarray_untuplify(arg);
      if (coords) then do
        match = coords[1];
        c1 = coords[0];
        if (match) then do
          match$1 = match[1];
          c2 = match[0];
          if (match$1) then do
            if (not match$1[1]) then do
              return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                            ghexp(--[[ Pexp_ident ]]Block.__(0, {bigarray_function("Array3", set)})),
                            --[[ :: ]]{
                              --[[ tuple ]]{
                                "",
                                arr
                              },
                              --[[ :: ]]{
                                --[[ tuple ]]{
                                  "",
                                  c1
                                },
                                --[[ :: ]]{
                                  --[[ tuple ]]{
                                    "",
                                    c2
                                  },
                                  --[[ :: ]]{
                                    --[[ tuple ]]{
                                      "",
                                      match$1[0]
                                    },
                                    --[[ :: ]]{
                                      --[[ tuple ]]{
                                        "",
                                        newval
                                      },
                                      --[[ [] ]]0
                                    }
                                  }
                                }
                              }
                            }
                          }));
            end
             end 
          end else do
            return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                          ghexp(--[[ Pexp_ident ]]Block.__(0, {bigarray_function("Array2", set)})),
                          --[[ :: ]]{
                            --[[ tuple ]]{
                              "",
                              arr
                            },
                            --[[ :: ]]{
                              --[[ tuple ]]{
                                "",
                                c1
                              },
                              --[[ :: ]]{
                                --[[ tuple ]]{
                                  "",
                                  c2
                                },
                                --[[ :: ]]{
                                  --[[ tuple ]]{
                                    "",
                                    newval
                                  },
                                  --[[ [] ]]0
                                }
                              }
                            }
                          }
                        }));
          end end 
        end else do
          return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                        ghexp(--[[ Pexp_ident ]]Block.__(0, {bigarray_function("Array1", set)})),
                        --[[ :: ]]{
                          --[[ tuple ]]{
                            "",
                            arr
                          },
                          --[[ :: ]]{
                            --[[ tuple ]]{
                              "",
                              c1
                            },
                            --[[ :: ]]{
                              --[[ tuple ]]{
                                "",
                                newval
                              },
                              --[[ [] ]]0
                            }
                          }
                        }
                      }));
        end end 
      end
       end 
      return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                    ghexp(--[[ Pexp_ident ]]Block.__(0, {bigarray_function("Genarray", "set")})),
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        "",
                        arr
                      },
                      --[[ :: ]]{
                        --[[ tuple ]]{
                          "",
                          ghexp(--[[ Pexp_array ]]Block.__(14, {coords}))
                        },
                        --[[ :: ]]{
                          --[[ tuple ]]{
                            "",
                            newval
                          },
                          --[[ [] ]]0
                        }
                      }
                    }
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_setinstvar ]]Block.__(23, {
                    do
                      txt: _1,
                      loc: rhs_loc(1)
                    end,
                    _3
                  }));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp(--[[ Pexp_assert ]]Block.__(26, {_3})), _2);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp(--[[ Pexp_lazy ]]Block.__(27, {_3})), _2);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return wrap_exp_attrs(mkexp(--[[ Pexp_object ]]Block.__(29, {_3})), _2);
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("object", 1, "end", 4);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Curry._2(Ast_helper_Exp.attr, _1, _2);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_ident ]]Block.__(0, {do
                      txt: _1,
                      loc: rhs_loc(1)
                    end}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_constant ]]Block.__(1, {_1}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_construct ]]Block.__(9, {
                    do
                      txt: _1,
                      loc: rhs_loc(1)
                    end,
                    undefined
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_variant ]]Block.__(10, {
                    _1,
                    undefined
                  }));
    end end),
  (function (__caml_parser_env) do
      return reloc_exp(Parsing.peek_val(__caml_parser_env, 1));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return wrap_exp_attrs(reloc_exp(_3), _2);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      d_000 = do
        txt: --[[ Lident ]]Block.__(0, {"()"}),
        loc: symbol_rloc(--[[ () ]]0)
      end;
      d = --[[ Pexp_construct ]]Block.__(9, {
          d_000,
          undefined
        });
      return wrap_exp_attrs(mkexp(d), _2);
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("begin", 1, "end", 3);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp_constraint(_2, _3);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_field ]]Block.__(12, {
                    _1,
                    do
                      txt: _3,
                      loc: rhs_loc(3)
                    end
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(--[[ Pexp_open ]]Block.__(32, {
                    --[[ Fresh ]]1,
                    do
                      txt: _1,
                      loc: rhs_loc(1)
                    end,
                    _4
                  }));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 4);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 3, ")", 5);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                    ghexp(--[[ Pexp_ident ]]Block.__(0, {array_function("Array", "get")})),
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        "",
                        _1
                      },
                      --[[ :: ]]{
                        --[[ tuple ]]{
                          "",
                          _4
                        },
                        --[[ [] ]]0
                      }
                    }
                  }));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 4);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 3, ")", 5);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                    ghexp(--[[ Pexp_ident ]]Block.__(0, {array_function("String", "get")})),
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        "",
                        _1
                      },
                      --[[ :: ]]{
                        --[[ tuple ]]{
                          "",
                          _4
                        },
                        --[[ [] ]]0
                      }
                    }
                  }));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 4);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[", 3, "]", 5);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      arr = _1;
      arg = _4;
      get = fast.contents and "unsafe_get" or "get";
      coords = bigarray_untuplify(arg);
      if (coords) then do
        match = coords[1];
        c1 = coords[0];
        if (match) then do
          match$1 = match[1];
          c2 = match[0];
          if (match$1) then do
            if (not match$1[1]) then do
              return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                            ghexp(--[[ Pexp_ident ]]Block.__(0, {bigarray_function("Array3", get)})),
                            --[[ :: ]]{
                              --[[ tuple ]]{
                                "",
                                arr
                              },
                              --[[ :: ]]{
                                --[[ tuple ]]{
                                  "",
                                  c1
                                },
                                --[[ :: ]]{
                                  --[[ tuple ]]{
                                    "",
                                    c2
                                  },
                                  --[[ :: ]]{
                                    --[[ tuple ]]{
                                      "",
                                      match$1[0]
                                    },
                                    --[[ [] ]]0
                                  }
                                }
                              }
                            }
                          }));
            end
             end 
          end else do
            return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                          ghexp(--[[ Pexp_ident ]]Block.__(0, {bigarray_function("Array2", get)})),
                          --[[ :: ]]{
                            --[[ tuple ]]{
                              "",
                              arr
                            },
                            --[[ :: ]]{
                              --[[ tuple ]]{
                                "",
                                c1
                              },
                              --[[ :: ]]{
                                --[[ tuple ]]{
                                  "",
                                  c2
                                },
                                --[[ [] ]]0
                              }
                            }
                          }
                        }));
          end end 
        end else do
          return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                        ghexp(--[[ Pexp_ident ]]Block.__(0, {bigarray_function("Array1", get)})),
                        --[[ :: ]]{
                          --[[ tuple ]]{
                            "",
                            arr
                          },
                          --[[ :: ]]{
                            --[[ tuple ]]{
                              "",
                              c1
                            },
                            --[[ [] ]]0
                          }
                        }
                      }));
        end end 
      end
       end 
      return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                    ghexp(--[[ Pexp_ident ]]Block.__(0, {bigarray_function("Genarray", "get")})),
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        "",
                        arr
                      },
                      --[[ :: ]]{
                        --[[ tuple ]]{
                          "",
                          ghexp(--[[ Pexp_array ]]Block.__(14, {coords}))
                        },
                        --[[ [] ]]0
                      }
                    }
                  }));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 4);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{", 3, "}", 5);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(--[[ Pexp_record ]]Block.__(11, {
                    _2[1],
                    _2[0]
                  }));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{", 1, "}", 3);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      rec_exp = mkexp(--[[ Pexp_record ]]Block.__(11, {
              _4[1],
              _4[0]
            }));
      return mkexp(--[[ Pexp_open ]]Block.__(32, {
                    --[[ Fresh ]]1,
                    do
                      txt: _1,
                      loc: rhs_loc(1)
                    end,
                    rec_exp
                  }));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 4);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{", 3, "}", 5);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(--[[ Pexp_array ]]Block.__(14, {List.rev(_2)}));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[|", 1, "|]", 4);
    end end),
  (function (__caml_parser_env) do
      return mkexp(--[[ Pexp_array ]]Block.__(14, {--[[ [] ]]0}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 5);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(--[[ Pexp_open ]]Block.__(32, {
                    --[[ Fresh ]]1,
                    do
                      txt: _1,
                      loc: rhs_loc(1)
                    end,
                    mkexp(--[[ Pexp_array ]]Block.__(14, {List.rev(_4)}))
                  }));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 5);
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[|", 3, "|]", 6);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return reloc_exp(mktailexp(rhs_loc(4), List.rev(_2)));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[", 1, "]", 4);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 5);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      list_exp = reloc_exp(mktailexp(rhs_loc(6), List.rev(_4)));
      return mkexp(--[[ Pexp_open ]]Block.__(32, {
                    --[[ Fresh ]]1,
                    do
                      txt: _1,
                      loc: rhs_loc(1)
                    end,
                    list_exp
                  }));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 5);
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[", 3, "]", 6);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                    mkoperator(_1, 1),
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        "",
                        _2
                      },
                      --[[ [] ]]0
                    }
                  }));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_apply ]]Block.__(5, {
                    mkoperator("!", 1),
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        "",
                        _2
                      },
                      --[[ [] ]]0
                    }
                  }));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      d = --[[ Pexp_new ]]Block.__(22, {do
            txt: _3,
            loc: rhs_loc(3)
          end});
      return wrap_exp_attrs(mkexp(d), _2);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(--[[ Pexp_override ]]Block.__(24, {List.rev(_2)}));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{<", 1, ">}", 4);
    end end),
  (function (__caml_parser_env) do
      return mkexp(--[[ Pexp_override ]]Block.__(24, {--[[ [] ]]0}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 5);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(--[[ Pexp_open ]]Block.__(32, {
                    --[[ Fresh ]]1,
                    do
                      txt: _1,
                      loc: rhs_loc(1)
                    end,
                    mkexp(--[[ Pexp_override ]]Block.__(24, {List.rev(_4)}))
                  }));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 5);
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{<", 3, ">}", 6);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_send ]]Block.__(21, {
                    _1,
                    _3
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    end end),
  (function (__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(--[[ Pexp_pack ]]Block.__(31, {_3}));
    end end),
  (function (__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      _5 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(--[[ Pexp_constraint ]]Block.__(19, {
                    ghexp(--[[ Pexp_pack ]]Block.__(31, {_3})),
                    ghtyp(--[[ Ptyp_package ]]Block.__(9, {_5}))
                  }));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      return unclosed("(", 1, ")", 5);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 7);
      _5 = Parsing.peek_val(__caml_parser_env, 3);
      _7 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(--[[ Pexp_open ]]Block.__(32, {
                    --[[ Fresh ]]1,
                    do
                      txt: _1,
                      loc: rhs_loc(1)
                    end,
                    mkexp(--[[ Pexp_constraint ]]Block.__(19, {
                            ghexp(--[[ Pexp_pack ]]Block.__(31, {_5})),
                            ghtyp(--[[ Ptyp_package ]]Block.__(9, {_7}))
                          }))
                  }));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 6);
      Parsing.peek_val(__caml_parser_env, 2);
      return unclosed("(", 3, ")", 7);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_extension ]]Block.__(33, {_1}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _2,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              "",
              _1
            };
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _1,
              _2
            };
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              "?" .. _2[0],
              _2[1]
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              "?" .. _1,
              _2
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _1,
              mkexp(--[[ Pexp_ident ]]Block.__(0, {do
                        txt: --[[ Lident ]]Block.__(0, {_1}),
                        loc: rhs_loc(1)
                      end}))
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              _2
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              mkpatvar(_1, 1),
              _2
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 6);
      _3 = Parsing.peek_val(__caml_parser_env, 4);
      _5 = Parsing.peek_val(__caml_parser_env, 2);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              ghpat(--[[ Ppat_constraint ]]Block.__(10, {
                      mkpatvar(_1, 1),
                      ghtyp(--[[ Ptyp_poly ]]Block.__(8, {
                              List.rev(_3),
                              _5
                            }))
                    })),
              _7
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 7);
      _4 = Parsing.peek_val(__caml_parser_env, 4);
      _6 = Parsing.peek_val(__caml_parser_env, 2);
      _8 = Parsing.peek_val(__caml_parser_env, 0);
      match = wrap_type_annotation(_4, _6, _8);
      return --[[ tuple ]]{
              ghpat(--[[ Ppat_constraint ]]Block.__(10, {
                      mkpatvar(_1, 1),
                      match[1]
                    })),
              match[0]
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _1,
              _3
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              ghpat(--[[ Ppat_constraint ]]Block.__(10, {
                      _1,
                      _3
                    })),
              _5
            };
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      lbs = _1;
      lb = _2;
      return do
              lbs_bindings: --[[ :: ]]{
                lb,
                lbs.lbs_bindings
              },
              lbs_rec: lbs.lbs_rec,
              lbs_extension: lbs.lbs_extension,
              lbs_attributes: lbs.lbs_attributes,
              lbs_loc: lbs.lbs_loc
            end;
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      param = _2;
      rf = _3;
      lb = mklb(_4, _5);
      return do
              lbs_bindings: --[[ :: ]]{
                lb,
                --[[ [] ]]0
              },
              lbs_rec: rf,
              lbs_extension: param[0],
              lbs_attributes: param[1],
              lbs_loc: symbol_rloc(--[[ () ]]0)
            end;
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mklb(_2, _3);
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp_constraint(_3, _1);
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return ghexp(--[[ Pexp_fun ]]Block.__(4, {
                    _1[0],
                    _1[1],
                    _1[2],
                    _2
                  }));
    end end),
  (function (__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_newtype ]]Block.__(30, {
                    _3,
                    _5
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return Curry._3(Ast_helper_Exp.__case, _1, undefined, _3);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return Curry._3(Ast_helper_Exp.__case, _1, _3, _5);
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return ghexp(--[[ Pexp_fun ]]Block.__(4, {
                    _1[0],
                    _1[1],
                    _1[2],
                    _2
                  }));
    end end),
  (function (__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(--[[ Pexp_newtype ]]Block.__(30, {
                    _3,
                    _5
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              --[[ :: ]]{
                _1,
                --[[ [] ]]0
              }
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _1,
              _3
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              undefined,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              _3
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              do
                txt: _1,
                loc: rhs_loc(1)
              end,
              _3
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              do
                txt: _1,
                loc: rhs_loc(1)
              end,
              exp_of_label(_1, 1)
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              --[[ tuple ]]{
                do
                  txt: _1,
                  loc: rhs_loc(1)
                end,
                _3
              },
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              --[[ tuple ]]{
                do
                  txt: _3,
                  loc: rhs_loc(3)
                end,
                _5
              },
              _1
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _2,
              undefined
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _2,
              _4
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              undefined,
              _2
            };
    end end),
  (function (__caml_parser_env) do
      throw Escape_error;
    end end),
  (function (__caml_parser_env) do
      throw Escape_error;
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_alias ]]Block.__(1, {
                    _1,
                    do
                      txt: _3,
                      loc: rhs_loc(3)
                    end
                  }));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      return expecting(3, "identifier");
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_tuple ]]Block.__(4, {List.rev(_1)}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_construct ]]Block.__(5, {
                    do
                      txt: _1,
                      loc: rhs_loc(1)
                    end,
                    _2
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_variant ]]Block.__(6, {
                    _1,
                    _2
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat_cons(rhs_loc(2), ghpat(--[[ Ppat_tuple ]]Block.__(4, {--[[ :: ]]{
                          _1,
                          --[[ :: ]]{
                            _3,
                            --[[ [] ]]0
                          }
                        }})), symbol_rloc(--[[ () ]]0));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      return expecting(3, "pattern");
    end end),
  (function (__caml_parser_env) do
      _5 = Parsing.peek_val(__caml_parser_env, 3);
      _7 = Parsing.peek_val(__caml_parser_env, 1);
      return mkpat_cons(rhs_loc(2), ghpat(--[[ Ppat_tuple ]]Block.__(4, {--[[ :: ]]{
                          _5,
                          --[[ :: ]]{
                            _7,
                            --[[ [] ]]0
                          }
                        }})), symbol_rloc(--[[ () ]]0));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 4, ")", 8);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_or ]]Block.__(9, {
                    _1,
                    _3
                  }));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      return expecting(3, "pattern");
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_lazy ]]Block.__(12, {_2}));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_exception ]]Block.__(14, {_2}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return attr$1(_1, _2);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_var ]]Block.__(0, {do
                      txt: _1,
                      loc: rhs_loc(1)
                    end}));
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      return mkpat(--[[ Ppat_any ]]0);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_constant ]]Block.__(2, {_1}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_interval ]]Block.__(3, {
                    _1,
                    _3
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_construct ]]Block.__(5, {
                    do
                      txt: _1,
                      loc: rhs_loc(1)
                    end,
                    undefined
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_variant ]]Block.__(6, {
                    _1,
                    undefined
                  }));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_type ]]Block.__(11, {do
                      txt: _2,
                      loc: rhs_loc(2)
                    end}));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mkpat(--[[ Ppat_record ]]Block.__(7, {
                    _2[0],
                    _2[1]
                  }));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{", 1, "}", 3);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return reloc_pat(mktailpat(rhs_loc(4), List.rev(_2)));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[", 1, "]", 4);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return mkpat(--[[ Ppat_array ]]Block.__(8, {List.rev(_2)}));
    end end),
  (function (__caml_parser_env) do
      return mkpat(--[[ Ppat_array ]]Block.__(8, {--[[ [] ]]0}));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[|", 1, "|]", 4);
    end end),
  (function (__caml_parser_env) do
      return reloc_pat(Parsing.peek_val(__caml_parser_env, 1));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mkpat(--[[ Ppat_constraint ]]Block.__(10, {
                    _2,
                    _4
                  }));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 5);
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      return expecting(4, "type");
    end end),
  (function (__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mkpat(--[[ Ppat_unpack ]]Block.__(13, {do
                      txt: _3,
                      loc: rhs_loc(3)
                    end}));
    end end),
  (function (__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      _5 = Parsing.peek_val(__caml_parser_env, 1);
      return mkpat(--[[ Ppat_constraint ]]Block.__(10, {
                    mkpat(--[[ Ppat_unpack ]]Block.__(13, {do
                              txt: _3,
                              loc: rhs_loc(3)
                            end})),
                    ghtyp(--[[ Ptyp_package ]]Block.__(9, {_5}))
                  }));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 6);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(--[[ Ppat_extension ]]Block.__(15, {_1}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              --[[ :: ]]{
                _1,
                --[[ [] ]]0
              }
            };
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      return expecting(3, "pattern");
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              --[[ :: ]]{
                _1,
                --[[ [] ]]0
              },
              --[[ Closed ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ tuple ]]{
              --[[ :: ]]{
                _1,
                --[[ [] ]]0
              },
              --[[ Closed ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              --[[ :: ]]{
                _1,
                --[[ [] ]]0
              },
              --[[ Open ]]1
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              --[[ :: ]]{
                _1,
                _3[0]
              },
              _3[1]
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              do
                txt: _1,
                loc: rhs_loc(1)
              end,
              _3
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              do
                txt: _1,
                loc: rhs_loc(1)
              end,
              pat_of_label(_1, 1)
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$11(symbol_rloc(--[[ () ]]0), _5, symbol_docs(--[[ () ]]0), undefined, do
                  txt: _2,
                  loc: rhs_loc(2)
                end, _4);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1[0],
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1[0],
              _2
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 5);
      _4 = Parsing.peek_val(__caml_parser_env, 3);
      _6 = Parsing.peek_val(__caml_parser_env, 1);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$11(symbol_rloc(--[[ () ]]0), _7, symbol_docs(--[[ () ]]0), _6, do
                  txt: _2,
                  loc: rhs_loc(2)
                end, _4);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _2,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 5);
      _3 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 3);
      _5 = Parsing.peek_val(__caml_parser_env, 2);
      _6 = Parsing.peek_val(__caml_parser_env, 1);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$19(symbol_rloc(--[[ () ]]0), add_nonrec(_2, _7, 2), symbol_docs(--[[ () ]]0), undefined, _3, List.rev(_6), _5[0], _5[1], _5[2], do
                  txt: _4,
                  loc: rhs_loc(4)
                end);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 1);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$19(symbol_rloc(--[[ () ]]0), _6, symbol_docs(--[[ () ]]0), get_text(Parsing.symbol_start_pos(--[[ () ]]0)), _2, List.rev(_5), _4[0], _4[1], _4[2], do
                  txt: _3,
                  loc: rhs_loc(3)
                end);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      return --[[ [] ]]0;
    end end),
  (function (__caml_parser_env) do
      return --[[ tuple ]]{
              --[[ Ptype_abstract ]]0,
              --[[ Public ]]1,
              undefined
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              --[[ Ptype_abstract ]]0,
              --[[ Public ]]1,
              _2
            };
    end end),
  (function (__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              --[[ Ptype_abstract ]]0,
              --[[ Private ]]0,
              _3
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              --[[ Ptype_variant ]]Block.__(0, {List.rev(_2)}),
              --[[ Public ]]1,
              undefined
            };
    end end),
  (function (__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              --[[ Ptype_variant ]]Block.__(0, {List.rev(_3)}),
              --[[ Private ]]0,
              undefined
            };
    end end),
  (function (__caml_parser_env) do
      return --[[ tuple ]]{
              --[[ Ptype_open ]]1,
              --[[ Public ]]1,
              undefined
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ tuple ]]{
              --[[ Ptype_record ]]Block.__(1, {_4}),
              _2,
              undefined
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              --[[ Ptype_variant ]]Block.__(0, {List.rev(_5)}),
              _4,
              _2
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      return --[[ tuple ]]{
              --[[ Ptype_open ]]1,
              --[[ Public ]]1,
              _2
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 5);
      _4 = Parsing.peek_val(__caml_parser_env, 3);
      _6 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ tuple ]]{
              --[[ Ptype_record ]]Block.__(1, {_6}),
              _4,
              _2
            };
    end end),
  (function (__caml_parser_env) do
      return --[[ [] ]]0;
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      return List.rev(Parsing.peek_val(__caml_parser_env, 1));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _2,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_var ]]Block.__(0, {_2}));
    end end),
  (function (__caml_parser_env) do
      return mktyp(--[[ Ptyp_any ]]0);
    end end),
  (function (__caml_parser_env) do
      return --[[ [] ]]0;
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      return List.rev(Parsing.peek_val(__caml_parser_env, 1));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _2,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      return --[[ Invariant ]]2;
    end end),
  (function (__caml_parser_env) do
      return --[[ Covariant ]]0;
    end end),
  (function (__caml_parser_env) do
      return --[[ Contravariant ]]1;
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_var ]]Block.__(0, {_2}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _2,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return constructor(symbol_rloc(--[[ () ]]0), _3, Caml_option.some(get_info(Parsing.symbol_end_pos(--[[ () ]]0))), _2[0], _2[1], do
                  txt: _1,
                  loc: rhs_loc(1)
                end);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return constructor(symbol_rloc(--[[ () ]]0), _4, Caml_option.some(get_info(Parsing.symbol_end_pos(--[[ () ]]0))), _3[0], _3[1], do
                  txt: _2,
                  loc: rhs_loc(2)
                end);
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 1);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      return rebind(symbol_rloc(--[[ () ]]0), Pervasives.$at(_5, _6), symbol_docs(--[[ () ]]0), undefined, do
                  txt: _2,
                  loc: rhs_loc(2)
                end, do
                  txt: _4,
                  loc: rhs_loc(4)
                end);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return decl(symbol_rloc(--[[ () ]]0), Pervasives.$at(_4, _5), symbol_docs(--[[ () ]]0), undefined, _3[0], _3[1], do
                  txt: _2,
                  loc: rhs_loc(2)
                end);
    end end),
  (function (__caml_parser_env) do
      return --[[ tuple ]]{
              --[[ [] ]]0,
              undefined
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              List.rev(_2),
              undefined
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              List.rev(_2),
              _4
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              --[[ [] ]]0,
              _2
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              _2
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return field$1(symbol_rloc(--[[ () ]]0), _5, Caml_option.some(get_info(Parsing.symbol_end_pos(--[[ () ]]0))), _1, do
                  txt: _2,
                  loc: rhs_loc(2)
                end, _4);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 6);
      _2 = Parsing.peek_val(__caml_parser_env, 5);
      _4 = Parsing.peek_val(__caml_parser_env, 3);
      _5 = Parsing.peek_val(__caml_parser_env, 2);
      _7 = Parsing.peek_val(__caml_parser_env, 0);
      info_before_semi = get_info(Parsing.rhs_end_pos(5));
      info = info_before_semi ~= undefined and info_before_semi or get_info(Parsing.symbol_end_pos(--[[ () ]]0));
      return field$1(symbol_rloc(--[[ () ]]0), Pervasives.$at(_5, _7), Caml_option.some(info), _1, do
                  txt: _2,
                  loc: rhs_loc(2)
                end, _4);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 6);
      _3 = Parsing.peek_val(__caml_parser_env, 5);
      _4 = Parsing.peek_val(__caml_parser_env, 4);
      _6 = Parsing.peek_val(__caml_parser_env, 2);
      _7 = Parsing.peek_val(__caml_parser_env, 1);
      _8 = Parsing.peek_val(__caml_parser_env, 0);
      if (_2 ~= --[[ Recursive ]]1) then do
        not_expecting(2, "nonrec flag");
      end
       end 
      return mk$20(_8, symbol_docs(--[[ () ]]0), _3, _6, do
                  txt: _4,
                  loc: rhs_loc(4)
                end, List.rev(_7));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 6);
      _3 = Parsing.peek_val(__caml_parser_env, 5);
      _4 = Parsing.peek_val(__caml_parser_env, 4);
      _6 = Parsing.peek_val(__caml_parser_env, 2);
      _7 = Parsing.peek_val(__caml_parser_env, 1);
      _8 = Parsing.peek_val(__caml_parser_env, 0);
      if (_2 ~= --[[ Recursive ]]1) then do
        not_expecting(2, "nonrec flag");
      end
       end 
      return mk$20(_8, symbol_docs(--[[ () ]]0), _3, _6, do
                  txt: _4,
                  loc: rhs_loc(4)
                end, List.rev(_7));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _2,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _2,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _2,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return decl(symbol_rloc(--[[ () ]]0), _3, undefined, Caml_option.some(get_info(Parsing.symbol_end_pos(--[[ () ]]0))), _2[0], _2[1], do
                  txt: _1,
                  loc: rhs_loc(1)
                end);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return decl(symbol_rloc(--[[ () ]]0), _4, undefined, Caml_option.some(get_info(Parsing.symbol_end_pos(--[[ () ]]0))), _3[0], _3[1], do
                  txt: _2,
                  loc: rhs_loc(2)
                end);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 3);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return rebind(symbol_rloc(--[[ () ]]0), _4, undefined, Caml_option.some(get_info(Parsing.symbol_end_pos(--[[ () ]]0))), do
                  txt: _1,
                  loc: rhs_loc(1)
                end, do
                  txt: _3,
                  loc: rhs_loc(3)
                end);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return rebind(symbol_rloc(--[[ () ]]0), _5, undefined, Caml_option.some(get_info(Parsing.symbol_end_pos(--[[ () ]]0))), do
                  txt: _2,
                  loc: rhs_loc(2)
                end, do
                  txt: _4,
                  loc: rhs_loc(4)
                end);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 1);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      rhs = last$1(_3);
      return --[[ Pwith_type ]]Block.__(0, {
                do
                  txt: _3,
                  loc: rhs_loc(3)
                end,
                mk$19(symbol_rloc(--[[ () ]]0), undefined, undefined, undefined, _2, List.rev(_6), undefined, _4, _5, do
                      txt: rhs,
                      loc: rhs_loc(3)
                    end)
              });
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Pwith_typesubst ]]Block.__(2, {mk$19(symbol_rloc(--[[ () ]]0), undefined, undefined, undefined, _2, undefined, undefined, undefined, _5, do
                      txt: _3,
                      loc: rhs_loc(3)
                    end)});
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Pwith_module ]]Block.__(1, {
                do
                  txt: _2,
                  loc: rhs_loc(2)
                end,
                do
                  txt: _4,
                  loc: rhs_loc(4)
                end
              });
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Pwith_modsubst ]]Block.__(3, {
                do
                  txt: _2,
                  loc: rhs_loc(2)
                end,
                do
                  txt: _4,
                  loc: rhs_loc(4)
                end
              });
    end end),
  (function (__caml_parser_env) do
      return --[[ Public ]]1;
    end end),
  (function (__caml_parser_env) do
      return --[[ Private ]]0;
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _2,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_poly ]]Block.__(8, {
                    List.rev(_1),
                    _3
                  }));
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_poly ]]Block.__(8, {
                    List.rev(_1),
                    _3
                  }));
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return attr(_1, _2);
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_alias ]]Block.__(6, {
                    _1,
                    _4
                  }));
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 4);
      _4 = Parsing.peek_val(__caml_parser_env, 2);
      _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_arrow ]]Block.__(1, {
                    "?" .. _2,
                    mkoption(_4),
                    _6
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 3);
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_arrow ]]Block.__(1, {
                    "?" .. _1,
                    mkoption(_2),
                    _4
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_arrow ]]Block.__(1, {
                    _1,
                    _3,
                    _5
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_arrow ]]Block.__(1, {
                    "",
                    _1,
                    _3
                  }));
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      if (_2) then do
        if (_2[1]) then do
          throw Parsing.Parse_error;
        end
         end 
        return _2[0];
      end else do
        throw Parsing.Parse_error;
      end end 
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      if (_2) then do
        if (_2[1]) then do
          throw Parsing.Parse_error;
        end
         end 
        return _2[0];
      end else do
        throw Parsing.Parse_error;
      end end 
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_var ]]Block.__(0, {_2}));
    end end),
  (function (__caml_parser_env) do
      return mktyp(--[[ Ptyp_any ]]0);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_constr ]]Block.__(3, {
                    do
                      txt: _1,
                      loc: rhs_loc(1)
                    end,
                    --[[ [] ]]0
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_constr ]]Block.__(3, {
                    do
                      txt: _2,
                      loc: rhs_loc(2)
                    end,
                    --[[ :: ]]{
                      _1,
                      --[[ [] ]]0
                    }
                  }));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_constr ]]Block.__(3, {
                    do
                      txt: _4,
                      loc: rhs_loc(4)
                    end,
                    List.rev(_2)
                  }));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(--[[ Ptyp_object ]]Block.__(4, {
                    _2[0],
                    _2[1]
                  }));
    end end),
  (function (__caml_parser_env) do
      return mktyp(--[[ Ptyp_object ]]Block.__(4, {
                    --[[ [] ]]0,
                    --[[ Closed ]]0
                  }));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_class ]]Block.__(5, {
                    do
                      txt: _2,
                      loc: rhs_loc(2)
                    end,
                    --[[ [] ]]0
                  }));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_class ]]Block.__(5, {
                    do
                      txt: _3,
                      loc: rhs_loc(3)
                    end,
                    --[[ :: ]]{
                      _1,
                      --[[ [] ]]0
                    }
                  }));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_class ]]Block.__(5, {
                    do
                      txt: _5,
                      loc: rhs_loc(5)
                    end,
                    List.rev(_2)
                  }));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(--[[ Ptyp_variant ]]Block.__(7, {
                    --[[ :: ]]{
                      _2,
                      --[[ [] ]]0
                    },
                    --[[ Closed ]]0,
                    undefined
                  }));
    end end),
  (function (__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(--[[ Ptyp_variant ]]Block.__(7, {
                    List.rev(_3),
                    --[[ Closed ]]0,
                    undefined
                  }));
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 3);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(--[[ Ptyp_variant ]]Block.__(7, {
                    --[[ :: ]]{
                      _2,
                      List.rev(_4)
                    },
                    --[[ Closed ]]0,
                    undefined
                  }));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(--[[ Ptyp_variant ]]Block.__(7, {
                    List.rev(_3),
                    --[[ Open ]]1,
                    undefined
                  }));
    end end),
  (function (__caml_parser_env) do
      return mktyp(--[[ Ptyp_variant ]]Block.__(7, {
                    --[[ [] ]]0,
                    --[[ Open ]]1,
                    undefined
                  }));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(--[[ Ptyp_variant ]]Block.__(7, {
                    List.rev(_3),
                    --[[ Closed ]]0,
                    --[[ [] ]]0
                  }));
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 3);
      _5 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(--[[ Ptyp_variant ]]Block.__(7, {
                    List.rev(_3),
                    --[[ Closed ]]0,
                    List.rev(_5)
                  }));
    end end),
  (function (__caml_parser_env) do
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(--[[ Ptyp_package ]]Block.__(9, {_3}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_extension ]]Block.__(10, {_1}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              do
                txt: _1,
                loc: rhs_loc(1)
              end,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              do
                txt: _1,
                loc: rhs_loc(1)
              end,
              _3
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              do
                txt: _2,
                loc: rhs_loc(2)
              end,
              _4
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              _3
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Rinherit ]]Block.__(1, {_1});
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 4);
      _3 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 1);
      _5 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Rtag ]]Block.__(0, {
                _1,
                _5,
                _3,
                List.rev(_4)
              });
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Rtag ]]Block.__(0, {
                _1,
                _2,
                true,
                --[[ [] ]]0
              });
    end end),
  (function (__caml_parser_env) do
      return true;
    end end),
  (function (__caml_parser_env) do
      return false;
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _2,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_tuple ]]Block.__(2, {--[[ :: ]]{
                      _1,
                      List.rev(_3)
                    }}));
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(--[[ Ptyp_tuple ]]Block.__(2, {--[[ :: ]]{
                      _1,
                      List.rev(_3)
                    }}));
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _3,
              _1
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              --[[ :: ]]{
                _1,
                _3[0]
              },
              _3[1]
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              --[[ :: ]]{
                _1,
                --[[ [] ]]0
              },
              --[[ Closed ]]0
            };
    end end),
  (function (__caml_parser_env) do
      return --[[ tuple ]]{
              --[[ [] ]]0,
              --[[ Open ]]1
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 3);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _1,
              _4,
              _3
            };
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_int ]]Block.__(0, {_1});
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_char ]]Block.__(1, {_1});
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_string ]]Block.__(2, {
                _1[0],
                _1[1]
              });
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_float ]]Block.__(3, {_1});
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_int32 ]]Block.__(4, {_1});
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_int64 ]]Block.__(5, {_1});
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_nativeint ]]Block.__(6, {_1});
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_int ]]Block.__(0, {-_2 | 0});
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_float ]]Block.__(3, {"-" .. _2});
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_int32 ]]Block.__(4, {-_2 | 0});
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_int64 ]]Block.__(5, {Caml_int64.neg(_2)});
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_nativeint ]]Block.__(6, {-_2});
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_int ]]Block.__(0, {_2});
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_float ]]Block.__(3, {_2});
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_int32 ]]Block.__(4, {_2});
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_int64 ]]Block.__(5, {_2});
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Const_nativeint ]]Block.__(6, {_2});
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 1);
    end end),
  (function (__caml_parser_env) do
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    end end),
  (function (__caml_parser_env) do
      return expecting(2, "operator");
    end end),
  (function (__caml_parser_env) do
      return expecting(3, "module-expr");
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      return "!";
    end end),
  (function (__caml_parser_env) do
      return "+";
    end end),
  (function (__caml_parser_env) do
      return "+.";
    end end),
  (function (__caml_parser_env) do
      return "-";
    end end),
  (function (__caml_parser_env) do
      return "-.";
    end end),
  (function (__caml_parser_env) do
      return "*";
    end end),
  (function (__caml_parser_env) do
      return "=";
    end end),
  (function (__caml_parser_env) do
      return "<";
    end end),
  (function (__caml_parser_env) do
      return ">";
    end end),
  (function (__caml_parser_env) do
      return "or";
    end end),
  (function (__caml_parser_env) do
      return "||";
    end end),
  (function (__caml_parser_env) do
      return "&";
    end end),
  (function (__caml_parser_env) do
      return "&&";
    end end),
  (function (__caml_parser_env) do
      return ":=";
    end end),
  (function (__caml_parser_env) do
      return "+=";
    end end),
  (function (__caml_parser_env) do
      return "%";
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      return "()";
    end end),
  (function (__caml_parser_env) do
      return "::";
    end end),
  (function (__caml_parser_env) do
      return "false";
    end end),
  (function (__caml_parser_env) do
      return "true";
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Lident ]]Block.__(0, {_1});
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Ldot ]]Block.__(1, {
                _1,
                _3
              });
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      return --[[ Lident ]]Block.__(0, {"[]"});
    end end),
  (function (__caml_parser_env) do
      return --[[ Lident ]]Block.__(0, {"()"});
    end end),
  (function (__caml_parser_env) do
      return --[[ Lident ]]Block.__(0, {"false"});
    end end),
  (function (__caml_parser_env) do
      return --[[ Lident ]]Block.__(0, {"true"});
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Lident ]]Block.__(0, {_1});
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Ldot ]]Block.__(1, {
                _1,
                _3
              });
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Lident ]]Block.__(0, {_1});
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Ldot ]]Block.__(1, {
                _1,
                _3
              });
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Lident ]]Block.__(0, {_1});
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Ldot ]]Block.__(1, {
                _1,
                _3
              });
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Lident ]]Block.__(0, {_1});
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Ldot ]]Block.__(1, {
                _1,
                _3
              });
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 3);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      p1 = _1;
      p2 = _3;
      if (applicative_functors.contents) then do
        return --[[ Lapply ]]Block.__(2, {
                  p1,
                  p2
                });
      end else do
        throw {
              __Error$3,
              --[[ Applicative_path ]]Block.__(3, {symbol_rloc(--[[ () ]]0)})
            };
      end end 
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Lident ]]Block.__(0, {_1});
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Ldot ]]Block.__(1, {
                _1,
                _3
              });
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Lident ]]Block.__(0, {_1});
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Ldot ]]Block.__(1, {
                _1,
                _3
              });
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Lident ]]Block.__(0, {_1});
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Ldot ]]Block.__(1, {
                _1,
                _3
              });
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Ptop_dir ]]Block.__(1, {
                _2,
                --[[ Pdir_none ]]0
              });
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Ptop_dir ]]Block.__(1, {
                _2,
                --[[ Pdir_string ]]Block.__(0, {_3[0]})
              });
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Ptop_dir ]]Block.__(1, {
                _2,
                --[[ Pdir_int ]]Block.__(1, {_3})
              });
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Ptop_dir ]]Block.__(1, {
                _2,
                --[[ Pdir_ident ]]Block.__(2, {_3})
              });
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ Ptop_dir ]]Block.__(1, {
                _2,
                --[[ Pdir_ident ]]Block.__(2, {_3})
              });
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ Ptop_dir ]]Block.__(1, {
                _2,
                --[[ Pdir_bool ]]Block.__(3, {false})
              });
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ Ptop_dir ]]Block.__(1, {
                _2,
                --[[ Pdir_bool ]]Block.__(3, {true})
              });
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      return --[[ Nonrecursive ]]0;
    end end),
  (function (__caml_parser_env) do
      return --[[ Recursive ]]1;
    end end),
  (function (__caml_parser_env) do
      return --[[ Recursive ]]1;
    end end),
  (function (__caml_parser_env) do
      return --[[ Nonrecursive ]]0;
    end end),
  (function (__caml_parser_env) do
      return --[[ Upto ]]0;
    end end),
  (function (__caml_parser_env) do
      return --[[ Downto ]]1;
    end end),
  (function (__caml_parser_env) do
      return --[[ Public ]]1;
    end end),
  (function (__caml_parser_env) do
      return --[[ Private ]]0;
    end end),
  (function (__caml_parser_env) do
      return --[[ Immutable ]]0;
    end end),
  (function (__caml_parser_env) do
      return --[[ Mutable ]]1;
    end end),
  (function (__caml_parser_env) do
      return --[[ Concrete ]]1;
    end end),
  (function (__caml_parser_env) do
      return --[[ Virtual ]]0;
    end end),
  (function (__caml_parser_env) do
      return --[[ tuple ]]{
              --[[ Public ]]1,
              --[[ Concrete ]]1
            };
    end end),
  (function (__caml_parser_env) do
      return --[[ tuple ]]{
              --[[ Private ]]0,
              --[[ Concrete ]]1
            };
    end end),
  (function (__caml_parser_env) do
      return --[[ tuple ]]{
              --[[ Public ]]1,
              --[[ Virtual ]]0
            };
    end end),
  (function (__caml_parser_env) do
      return --[[ tuple ]]{
              --[[ Private ]]0,
              --[[ Virtual ]]0
            };
    end end),
  (function (__caml_parser_env) do
      return --[[ tuple ]]{
              --[[ Private ]]0,
              --[[ Virtual ]]0
            };
    end end),
  (function (__caml_parser_env) do
      return --[[ Fresh ]]1;
    end end),
  (function (__caml_parser_env) do
      return --[[ Override ]]0;
    end end),
  (function (__caml_parser_env) do
      return --[[ () ]]0;
    end end),
  (function (__caml_parser_env) do
      return --[[ () ]]0;
    end end),
  (function (__caml_parser_env) do
      return --[[ () ]]0;
    end end),
  (function (__caml_parser_env) do
      return --[[ () ]]0;
    end end),
  (function (__caml_parser_env) do
      return "-";
    end end),
  (function (__caml_parser_env) do
      return "-.";
    end end),
  (function (__caml_parser_env) do
      return "+";
    end end),
  (function (__caml_parser_env) do
      return "+.";
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      return Parsing.peek_val(__caml_parser_env, 0);
    end end),
  (function (__caml_parser_env) do
      return "and";
    end end),
  (function (__caml_parser_env) do
      return "as";
    end end),
  (function (__caml_parser_env) do
      return "assert";
    end end),
  (function (__caml_parser_env) do
      return "begin";
    end end),
  (function (__caml_parser_env) do
      return "class";
    end end),
  (function (__caml_parser_env) do
      return "constraint";
    end end),
  (function (__caml_parser_env) do
      return "do";
    end end),
  (function (__caml_parser_env) do
      return "done";
    end end),
  (function (__caml_parser_env) do
      return "downto";
    end end),
  (function (__caml_parser_env) do
      return "else";
    end end),
  (function (__caml_parser_env) do
      return "end";
    end end),
  (function (__caml_parser_env) do
      return "exception";
    end end),
  (function (__caml_parser_env) do
      return "external";
    end end),
  (function (__caml_parser_env) do
      return "false";
    end end),
  (function (__caml_parser_env) do
      return "for";
    end end),
  (function (__caml_parser_env) do
      return "fun";
    end end),
  (function (__caml_parser_env) do
      return "function";
    end end),
  (function (__caml_parser_env) do
      return "functor";
    end end),
  (function (__caml_parser_env) do
      return "if";
    end end),
  (function (__caml_parser_env) do
      return "in";
    end end),
  (function (__caml_parser_env) do
      return "include";
    end end),
  (function (__caml_parser_env) do
      return "inherit";
    end end),
  (function (__caml_parser_env) do
      return "initializer";
    end end),
  (function (__caml_parser_env) do
      return "lazy";
    end end),
  (function (__caml_parser_env) do
      return "let";
    end end),
  (function (__caml_parser_env) do
      return "match";
    end end),
  (function (__caml_parser_env) do
      return "method";
    end end),
  (function (__caml_parser_env) do
      return "module";
    end end),
  (function (__caml_parser_env) do
      return "mutable";
    end end),
  (function (__caml_parser_env) do
      return "new";
    end end),
  (function (__caml_parser_env) do
      return "object";
    end end),
  (function (__caml_parser_env) do
      return "of";
    end end),
  (function (__caml_parser_env) do
      return "open";
    end end),
  (function (__caml_parser_env) do
      return "or";
    end end),
  (function (__caml_parser_env) do
      return "private";
    end end),
  (function (__caml_parser_env) do
      return "rec";
    end end),
  (function (__caml_parser_env) do
      return "sig";
    end end),
  (function (__caml_parser_env) do
      return "struct";
    end end),
  (function (__caml_parser_env) do
      return "then";
    end end),
  (function (__caml_parser_env) do
      return "to";
    end end),
  (function (__caml_parser_env) do
      return "true";
    end end),
  (function (__caml_parser_env) do
      return "try";
    end end),
  (function (__caml_parser_env) do
      return "type";
    end end),
  (function (__caml_parser_env) do
      return "val";
    end end),
  (function (__caml_parser_env) do
      return "virtual";
    end end),
  (function (__caml_parser_env) do
      return "when";
    end end),
  (function (__caml_parser_env) do
      return "while";
    end end),
  (function (__caml_parser_env) do
      return "with";
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return do
              txt: _1,
              loc: symbol_rloc(--[[ () ]]0)
            end;
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return do
              txt: _1 .. ("." .. _3.txt),
              loc: symbol_rloc(--[[ () ]]0)
            end;
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ tuple ]]{
              _2,
              _3
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ tuple ]]{
              _2,
              _3
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ tuple ]]{
              _2,
              _3
            };
    end end),
  (function (__caml_parser_env) do
      return --[[ [] ]]0;
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              _2
            };
    end end),
  (function (__caml_parser_env) do
      return --[[ [] ]]0;
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ :: ]]{
              _1,
              _2
            };
    end end),
  (function (__caml_parser_env) do
      return --[[ tuple ]]{
              undefined,
              --[[ [] ]]0
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 1);
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              undefined,
              --[[ :: ]]{
                _1,
                _2
              }
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 1);
      _3 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ tuple ]]{
              _2,
              _3
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ tuple ]]{
              _2,
              _3
            };
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _3 = Parsing.peek_val(__caml_parser_env, 1);
      return --[[ tuple ]]{
              _2,
              _3
            };
    end end),
  (function (__caml_parser_env) do
      _1 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ PStr ]]Block.__(0, {_1});
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ PTyp ]]Block.__(1, {_2});
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ PPat ]]Block.__(2, {
                _2,
                undefined
              });
    end end),
  (function (__caml_parser_env) do
      _2 = Parsing.peek_val(__caml_parser_env, 2);
      _4 = Parsing.peek_val(__caml_parser_env, 0);
      return --[[ PPat ]]Block.__(2, {
                _2,
                _4
              });
    end end),
  (function (__caml_parser_env) do
      throw {
            Parsing.YYexit,
            Parsing.peek_val(__caml_parser_env, 0)
          };
    end end),
  (function (__caml_parser_env) do
      throw {
            Parsing.YYexit,
            Parsing.peek_val(__caml_parser_env, 0)
          };
    end end),
  (function (__caml_parser_env) do
      throw {
            Parsing.YYexit,
            Parsing.peek_val(__caml_parser_env, 0)
          };
    end end),
  (function (__caml_parser_env) do
      throw {
            Parsing.YYexit,
            Parsing.peek_val(__caml_parser_env, 0)
          };
    end end),
  (function (__caml_parser_env) do
      throw {
            Parsing.YYexit,
            Parsing.peek_val(__caml_parser_env, 0)
          };
    end end),
  (function (__caml_parser_env) do
      throw {
            Parsing.YYexit,
            Parsing.peek_val(__caml_parser_env, 0)
          };
    end end),
  (function (__caml_parser_env) do
      throw {
            Parsing.YYexit,
            Parsing.peek_val(__caml_parser_env, 0)
          };
    end end)
};

yytables = do
  actions: yyact,
  transl_const: yytransl_const,
  transl_block: yytransl_block,
  lhs: "\xff\xff\x01\0\x02\0\x03\0\x03\0\x03\0\n\0\n\0\x0e\0\x0e\0\x04\0\x10\0\x10\0\x11\0\x11\0\x11\0\x11\0\x11\0\x11\0\x11\0\x05\0\x06\0\x07\0\x14\0\x14\0\x15\0\x15\0\x17\0\x17\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\b\0\b\0\x1e\0\x1e\0\x1e\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0*\0-\0-\0-\0$\0%\0%\0.\0/\0\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\t\0\t\0\t\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\0'\x009\0<\0<\0<\x006\x007\x008\x008\0=\0>\0?\0?\0&\0(\0(\0A\0B\0E\0E\0E\0D\0D\0J\0J\0F\0F\0F\0F\0F\0F\0K\0K\0K\0K\0K\0K\0K\0K\0O\0P\0P\0P\0Q\0Q\0R\0R\0R\0R\0R\0R\0R\0S\0S\0T\0T\0T\0T\0U\0U\0U\0U\0U\0G\0G\0G\0G\0G\0^\0^\0^\0^\0^\0^\0a\0b\0b\0c\0c\0d\0d\0d\0d\0d\0d\0e\0e\0e\0g\0V\0:\0:\0h\0i\0)\0)\0j\0k\0\f\0\f\0\f\0H\0H\0H\0H\0H\0H\0H\0H\0p\0p\0m\0m\0l\0l\0n\0o\0o\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0L\0L\0\x84\0\x84\0\x85\0\x85\0\x85\0\x85\0\x86\0]\0]\0\x87\0\x87\0\x87\0\x87\0\x87\0\x1f\0\x1f\0\x8c\0\x8d\0\x89\0\x89\0\\\0\\\0\\\0u\0u\0\x8f\0\x8f\0v\0v\0v\0w\0w\0\x80\0\x80\0\x90\0\x90\0\x90\0\x91\0\x91\0\x83\0\x83\0\x81\0\x81\0Y\0Y\0Y\0Y\0Y\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0q\0q\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x92\0\x92\0\x92\0\x96\0\x96\0\x95\0\x95\0\x95\0\x95\0\x97\0\x97\x003\0\x98\0\x98\0 \0!\0!\0\x99\0\x9a\0\x9e\0\x9e\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9c\0\x9c\0\x9c\0\xa1\0\xa2\0\xa2\0\xa4\0\xa4\0\xa5\0\xa5\0\xa5\0\xa6\0\xa3\0\xa3\0\xa3\0\xa7\0I\0I\0\x9f\0\x9f\0\x9f\0\xa8\0\xa9\0#\0#\x005\0\xab\0\xab\0\xab\0\xab\0\xa0\0\xa0\0\xa0\0\xaf\0\xb0\0\"\x004\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb3\0\xb3\0\xb3\0\xb4\0\xb5\0\xb6\0\xb7\x001\x001\0\xb8\0\xb8\0\xb8\0\xb8\0\xb9\0\xb9\0\x8a\0\x8a\0Z\0Z\0\xb1\0\xb1\0\x12\0\x12\0\xba\0\xba\0\xbc\0\xbc\0\xbc\0\xbc\0\xbc\0\xbe\0\xbe\0\xae\0\xae\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\x1b\0\x1b\0\xc6\0\xc5\0\xc5\0\xc2\0\xc2\0\xc3\0\xc3\0\xc1\0\xc1\0\xc7\0\xc7\0\xc8\0\xc8\0\xc4\0\xc4\0\xbd\0\xbd\0_\0_\0M\0M\0\xc9\0\xc9\0\xad\0\xad\0\xc0\0\xc0\0\xc0\0\xca\0W\0\x7f\0\x7f\0\x7f\0\x7f\0\x7f\0\x7f\0\x7f\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0@\0@\0\x88\0\x88\0\x88\0\x88\0\x88\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xaa\0\xaa\0\xaa\0\xaa\0\xaa\0~\0~\0x\0x\0x\0x\0x\0}\0}\0\x94\0\x94\0\x19\0\x19\0\xbb\0\xbb\0\xbb\x000\x000\0`\0`\0N\0N\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0y\0\x8e\0\x8e\0\x9b\0\x9b\0z\0z\0[\0[\0X\0X\0C\0C\0f\0f\0f\0f\0f\0;\0;\0t\0t\0\x82\0\x82\0{\0{\0|\0|\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcd\0\xcd\0\x1c\0\xcf\0,\0\r\0\r\0\xac\0\xac\0s\0s\0s\0\x1d\0+\0\xce\0\xce\0\xce\0\xce\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
  len: "\x02\0\x02\0\x02\0\x02\0\x02\0\x01\0\x02\0\x01\0\0\0\x02\0\x01\0\x01\0\x03\0\x01\0\x02\0\x04\0\x03\0\x03\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x05\0\x01\0\x01\0\x02\0\x01\0\x01\0\x03\0\x03\0\x04\0\x04\0\x03\0\x04\0\x05\0\x05\0\x03\0\x03\0\x04\0\x06\0\b\0\x06\0\x05\0\x05\0\x04\0\x02\0\x01\0\x03\0\x01\0\0\0\x02\0\x02\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x02\0\x01\0\x03\0\x02\0\x04\0\x02\0\x04\0\x01\0\x02\0\x05\0\x04\0\x01\0\x03\0\x03\0\x04\0\x03\0\x04\0\x03\0\x03\0\x01\0\x02\0\0\0\x02\0\x02\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x02\0\x01\0\x04\0\x03\0\x02\0\x06\0\x03\0\x04\0\x05\0\x01\0\x02\0\x06\0\x05\0\0\0\x02\0\x05\0\x01\0\x02\0\x06\0\x06\0\x02\0\x04\0\x02\0\0\0\x03\0\x03\0\x02\0\x01\0\x02\0\x02\0\x03\0\x02\0\x01\0\x04\0\x01\0\x03\0\x03\0\x05\0\x05\0\x03\0\x03\0\x02\0\x03\0\x05\0\0\0\0\0\x02\0\x05\0\x03\0\x03\0\x03\0\x03\0\x02\0\x01\0\x02\0\0\0\x06\0\x05\0\x05\0\x06\0\x06\0\x06\0\x04\0\x07\0\n\0\x01\0\x06\0\x04\0\x05\0\x03\0\x04\0\x01\0\x03\0\x03\0\x02\0\x01\0\x02\0\x03\0\0\0\0\0\x02\0\x03\0\x03\0\x06\0\x03\0\x02\0\x01\0\x05\0\x05\0\x03\0\x03\0\x03\0\x01\0\x02\0\x07\0\x07\0\x01\0\x02\0\b\0\x07\0\x01\0\x02\0\x03\0\x05\0\x02\0\x05\0\x02\0\x04\0\x02\0\x02\0\x01\0\x01\0\x01\0\0\0\x02\0\x01\0\x03\0\x01\0\x01\0\x03\0\x01\0\x02\0\x03\0\x07\0\x07\0\x04\0\x04\0\x07\0\x06\0\x06\0\x05\0\x01\0\x02\0\x02\0\x07\0\x05\0\x06\0\n\0\x03\0\b\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x02\0\x02\0\x05\0\x07\0\x07\0\x07\0\x03\0\x03\0\x03\0\x04\0\x04\0\x02\0\x01\0\x01\0\x01\0\x01\0\x03\0\x03\0\x04\0\x03\0\x04\0\x04\0\x03\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x03\0\x03\0\x05\0\x05\0\x04\0\x04\0\x02\0\x06\0\x06\0\x04\0\x04\0\x06\0\x06\0\x02\0\x02\0\x03\0\x04\0\x04\0\x02\0\x06\0\x06\0\x03\0\x03\0\x04\0\x06\0\x05\0\b\0\x07\0\x01\0\x01\0\x02\0\x01\0\x01\0\x02\0\x02\0\x02\0\x02\0\x01\0\x01\0\x02\0\x02\0\x07\0\b\0\x03\0\x05\0\x01\0\x02\0\x05\0\x03\0\x01\0\x03\0\x02\0\x02\0\x05\0\x01\0\x03\0\x03\0\x05\0\x02\0\x02\0\x05\0\x03\0\x03\0\x03\0\x01\0\x01\0\x03\0\x02\0\x03\0\x01\0\x03\0\x05\0\x01\0\x03\0\x02\0\x04\0\x02\0\x02\0\x02\0\x01\0\x03\0\x03\0\x01\0\x02\0\x02\0\x03\0\x03\0\b\0\b\0\x03\0\x03\0\x02\0\x02\0\x02\0\x01\0\x01\0\x01\0\x01\0\x03\0\x01\0\x01\0\x02\0\x03\0\x03\0\x04\0\x04\0\x04\0\x02\0\x04\0\x03\0\x03\0\x05\0\x05\0\x04\0\x04\0\x06\0\x06\0\x01\0\x03\0\x03\0\x03\0\x01\0\x03\0\x01\0\x02\0\x04\0\x03\0\x03\0\x01\0\x05\0\x01\0\x02\0\x07\0\x01\0\x02\0\x07\0\x06\0\x03\0\0\0\0\0\x02\0\x03\0\x02\0\x03\0\x02\0\x05\0\x05\0\x04\0\x07\0\0\0\x01\0\x03\0\x02\0\x01\0\x03\0\x02\0\x01\0\0\0\x01\0\x03\0\x02\0\0\0\x01\0\x01\0\x02\0\x01\0\x03\0\x01\0\x01\0\x02\0\x03\0\x04\0\x01\0\x06\0\x05\0\0\0\x02\0\x04\0\x02\0\x01\0\x01\0\x02\0\x05\0\x07\0\b\0\b\0\x01\0\x01\0\x01\0\x01\0\x02\0\x02\0\x01\0\x01\0\x02\0\x03\0\x04\0\x04\0\x05\0\x01\0\x03\0\x06\0\x05\0\x04\0\x04\0\x01\0\x02\0\x02\0\x03\0\x01\0\x03\0\x01\0\x03\0\x01\0\x02\0\x01\0\x04\0\x01\0\x06\0\x04\0\x05\0\x03\0\x01\0\x03\0\x01\0\x03\0\x02\0\x01\0\x01\0\x02\0\x04\0\x03\0\x02\0\x02\0\x03\0\x05\0\x03\0\x04\0\x05\0\x04\0\x02\0\x04\0\x06\0\x04\0\x01\0\x01\0\x03\0\x04\0\x01\0\x03\0\x01\0\x03\0\x01\0\x01\0\x05\0\x02\0\x01\0\0\0\x01\0\x03\0\x01\0\x02\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x03\0\x02\0\x01\0\x04\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x01\0\x01\0\x01\0\x03\0\x03\0\x02\0\x03\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x02\0\x01\0\x01\0\x01\0\x01\0\x03\0\x01\0\x02\0\x02\0\x01\0\x01\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x04\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x02\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x02\0\0\0\x01\0\0\0\x01\0\x01\0\x01\0\0\0\x01\0\0\0\x01\0\0\0\x01\0\0\0\x01\0\x01\0\x02\0\x02\0\0\0\x01\0\0\0\x01\0\0\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x03\0\x04\0\x04\0\x04\0\0\0\x02\0\0\0\x02\0\0\0\x02\0\x03\0\x04\0\x04\0\x01\0\x02\0\x02\0\x04\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0",
  defred: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0<\x02\0\0\0\0\0\0u\x02>\x02\0\0\0\0\0\0\0\0\0\0;\x02?\x02@\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa5\x02\xa6\x02\0\0A\x02\0\0\0\0\0\0\xa7\x02\xa8\x02\0\0\0\0=\x02v\x02\0\0\0\0{\x02\0\0\xed\x02\0\0\0\0\0\0\0\0\0\0B\x012\0\0\x007\0\0\x009\0:\0;\0\0\0=\0>\0\0\0\0\0A\0\0\0C\0I\0\xd2\x01w\0\0\0\xc7\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\x01\x14\x01p\x02S\x01\xab\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\x02\0\0[\0\0\0b\0c\0\0\0\0\0h\0\0\0Z\0]\0^\0_\0`\0\0\0d\0\0\0p\0\xc3\0\x05\0\0\0\xef\x02\0\0\0\0\0\0\x07\0\0\0\r\0\0\0\xf0\x02\0\0\0\0\0\0\n\0\x0b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0}\x02\t\x02\xf1\x02\0\0\x1a\x02\n\x02\xfb\x01\0\0\0\0\xff\x01\0\0\0\0\xf2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0O\x02\0\0\0\0\0\0\0\0\x86\x01\xf3\x02\0\0\0\0\x9b\x01u\x01\0\0\0\0B\x02\x84\x01\x85\x01\0\0\0\0\0\0\0\0\0\0\0\0N\x02M\x02\x8d\x02\0\x004\x01\x15\x01\x16\x01\0\0\0\0\x99\x02\0\0m\x02n\x02\0\0o\x02k\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x000\0\0\0\0\0\0\0\0\0\0\0\0\0f\x01\0\x008\x01:\x02\0\0\0\0s\x02\0\0\0\0,\x01\0\0\xab\x02\xac\x02\xad\x02\xae\x02\xaf\x02\xb0\x02\xb1\x02\xb2\x02\xb3\x02\xb4\x02\xb5\x02\xb6\x02\xb7\x02\xb8\x02\xb9\x02\xba\x02\xbb\x02\xbc\x02\xbd\x02\xbe\x02\xbf\x02\xc0\x02\xc1\x02\xc2\x02\xc3\x02\xa9\x02\xc4\x02\xc5\x02\xc6\x02\xc7\x02\xc8\x02\xc9\x02\xca\x02\xcb\x02\xcc\x02\xcd\x02\xce\x02\xcf\x02\xd0\x02\xd1\x02\xd2\x02\xd3\x02\xd4\x02\xd5\x02\xaa\x02\xd6\x02\xd7\x02\xd8\x02\xd9\x02\xda\x02\0\0\0\0\0\0\0\0\0\0\0\0R\x02g\x02f\x02\0\0e\x02\0\0h\x02a\x02c\x02U\x02V\x02W\x02X\x02Y\x02b\x02\0\0\0\0\0\0d\x02j\x02\0\0\0\0i\x02\0\0t\x02Z\x02`\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa0\x02\0\x003\x014\0\0\0\x91\x02\0\0\0\0\x01\0\0\0\0\0\0\0\0\x005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x12\x01\0\0\0\0T\x01\0\0\xac\x01\0\0J\0\0\0x\0\0\0\xc8\0B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0C\x01F\x01\0\0\0\0\0\0\x07\x01\b\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0U\0M\0\x80\x02\0\0\0\0\0\0X\0\0\0\0\0\x02\0g\0Y\0\0\0q\0\0\0\xc4\0\0\0\x03\0\x04\0\x06\0\t\0\x0e\0\0\0\0\0\0\0\x13\0\0\0\x12\0\0\0y\x02\0\0#\x02\0\0\0\0\xa2\x02\0\0\x16\x02\0\x008\x02\x0e\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\b\x02\x84\x02\0\0\x0f\x02\x14\0\xfc\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0b\x02\x15\0\x82\x01\0\0\x81\x01\x89\x01\x8a\x01w\x02\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01\0\0[\x02\0\0\0\0_\x02\0\0\0\0]\x02T\x02\0\0D\x02C\x02E\x02F\x02G\x02I\x02H\x02J\x02K\x02L\x02\x8b\x01\0\0\0\0\0\0\0\0\x16\0\x83\x01\0\0y\x01z\x01\0\0\0\0\0\0\0\0\0\0\xe5\x02\0\0\0\0\x1a\x01\0\0\0\0\0\0\0\0l\x02\0\0\0\0\0\0\0\0^\x02\0\0\\\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd5\0\0\0\0\0\0\0\x1c\0\0\0\0\0\0\0\0\0\0\0D\0/\0\0\0\0\0\0\0\0\0'\x01&\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe9\x02\0\0\0\0\0\0\0\0\x8f\x02\0\0\0\0S\x02\0\0\x18\x01\0\0\0\0\x17\x01\0\0Q\x02P\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x005\x01\0\0\0\0\x94\0\0\0\0\0\0\0\xc9\x01\xc8\x01\0\0\xbc\x01\0\0\0\0\0\x001\0\xe1\x02\0\0\0\0\0\0\0\0\0\0|\x02q\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcd\0\0\0\0\0\0\0\0\0\0\0\xe1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0K\x01I\x01;\x01\0\0H\x01D\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0j\0V\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8b\x02\x88\x02\x87\x02\x8c\x02\0\0\x89\x02\x11\0\0\0\x10\0\f\0\"\x02\0\0 \x02\0\0%\x02\x12\x02\0\0\0\0\0\0\0\0\r\x02\0\x007\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0z\x02~\x02\0\0\0\0\0\x002\x02\0\0\x10\x02\0\0\0\0\x8d\x01\x8c\x01\0\0\0\0\0\0\0\0\0\0\0\0\x94\x01\0\0\x93\x01w\x01v\x01\x80\x01\0\0|\x01\0\0\x9e\x01\0\0\0\0\x88\x01\0\0\xe6\x02\xe3\x02\0\0\0\0\0\0\x1d\x01\x1b\x01\x19\x01\0\0\0\0\0\0\xcb\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd6\x014\x02\0\0\0\0\0\0\xd4\0\0\0\xd6\0\0\0\xd7\0\xd1\0\xdc\0\0\0\xcf\0\0\0\xd3\0\0\0\0\0\0\0\xe5\0\0\0\0\0\\\x01\0\0\x17\0\x19\0\x1a\0\0\0\0\0\x1b\0\0\0'\0\0\0&\0\x1f\0\x1e\0\"\0\0\0\0\0e\x01\0\0h\x01\0\0\0\x007\x016\x01\0\x000\x01/\x01+\x01*\x01\xdc\x02\0\0\0\0\xe7\x02\xe8\x02\0\0\0\0\0\0\0\0\0\0=\x01s\x01\0\0t\x01\0\0\x1c\x01\xdf\x02\0\0\0\0\0\0\0\0\0\0\0\0G\0H\0\0\0\x11\x01\x10\x01\0\0i\0\0\0\xbf\x01\0\0\0\0\0\0\0\0\xc2\x01\xbe\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0V\x01\0\0\0\0\0\0\0\0\0\0W\x01N\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\0S\0\0\0O\0N\0\0\0\0\0\0\0\xed\x01\0\0\x81\x02\0\0\0\0\0\0\0\0\0\0n\0\0\0\0\0\0\0\0\0\0\0\x0f\0\0\0\x13\x02&\x02\0\0\0\0\0\0\x17\x02\x15\x02\0\0\0\0\0\0\xf9\x016\x02\0\0\x19\x02\0\0\0\0\0\0\f\x02\0\0\0\0\x85\x02\0\0\x7f\x02\xfe\x01\0\0x\x02\0\0\0\0\xa4\x01\0\0\x8f\x01\x8e\x01\x92\x01\x90\x01\0\0\0\0\x98\x01\x97\x01\0\0\xdd\x02\0\0\0\0\0\0\0\0\0\0\x7f\0\0\0\xc6\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd4\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01a\x01\0\0\0\0\0\0\0\0\0\0\0\0.\0\0\0\0\0(\0\0\0#\0!\0\0\0\0\0\0\0\0\0U\x01\0\0?\x01\0\0\0\0\0\0K\0\0\0v\0\0\0\0\0\x91\0\0\0\0\0\0\0\0\0\0\0\0\0\x9c\0\x95\0\xe9\0\0\0\0\0\xbd\x01\0\0\xb0\x01\0\0\xc1\x01\0\0\xde\x02)\x01(\x01\0\0\0\0\0\0\0\0\x1f\x01\x1e\x01Q\x01\0\0\0\0Y\x01\0\0Z\x01\0\0\0\0\xb0\x01L\0\0\0\0\0\0\0%\x01#\x01\0\0!\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc4\x01\0\0\0\0o\0m\0\0\0\0\0\xa7\x01\0\0\0\0!\x02(\x02\0\0\x14\x02*\x02\0\0\0\0\0\0\0\x009\x02\0\0\0\0\x1c\x02\0\0\x11\x02\0\x003\x02\xa4\x02\xa3\x01\0\0\0\0\x96\x01\x95\x01$\x01\"\x01 \x01\0\0\xcc\x01\xca\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xae\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x87\0\0\0\0\0\0\0\x89\0y\0}\0\0\0\xd7\x015\x02\xd3\x01\0\0\0\0\x93\x02\x92\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd2\0\0\0^\x01\0\0]\x01\0\0\0\0,\0\0\0-\0\0\0%\0$\0\0\0\xec\x02\0\0\0\0\0\0>\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x9b\0\0\0\xc0\x01\0\0\xb6\x01\0\0\0\0\0\0\0\0\0\0\0\0\xcd\x01\xce\x01\0\0\0\0\x95\x02\0\0\xef\0:\x019\x012\x011\x01.\x01-\x01\0\0\0\0\0\0\0\0\0\0X\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\x01r\0\0\0\0\0s\0\0\0\0\0$\x02\x18\x02+\x02\xfa\x01\xf6\x01\0\0\0\0\0\0\0\0\x9a\x01\x99\x01\0\0\x82\x02\xb2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb6\0\0\0\0\0\0\0\xb1\0\0\0\0\0\0\0\0\0\x83\0\0\0\0\0\0\0\0\0\x86\0\0\0\xa9\x01\xaa\x01\0\0\xe6\0\0\0\xd9\0\xd0\0\xce\0\0\0\0\0\0\0\0\0\x18\0\0\0)\0+\0\xe2\0\xe3\0\0\0\x92\0\0\0\x99\0\0\0\x9a\0\0\0\0\0\0\0\x98\0\x97\x02\0\0\0\0\0\0\x97\0\0\0\0\0\0\0\0\0\0\0\xcf\x01\0\0\0\0\xad\x01\0\0\0\0\0\0\xe0\x01\xe1\x01\xe2\x01\xe3\x01A\x01\0\0M\x01\0\0\0\0\0\0R\x01\xae\x01z\0\0\0\0\0\0\0\0\0\xc5\0\0\0\0\0\xc5\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe6\x01\xe7\x01\0\0)\x02\0\0\x1f\x02\0\0\xc9\0\0\0\0\0\0\0\0\0\0\0\xb0\0\xaf\0\0\0\0\0\0\0\0\0\xac\0/\x02\0\0\0\0\x81\0\0\0\x8f\0\0\0\x8e\0\x8b\0\x8a\0\0\0\0\0b\x01_\x01\0\0\xf2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb9\x01\0\0\0\0\0\0\xd9\x01\0\0\xd0\x01\0\0\xaf\x01\0\0\0\0\0\0\xde\x01\xe4\x01\xe5\x01@\x01\0\0\0\0[\x01\xca\0\xf0\x01\xf4\x01\xb0\x01l\0\0\0\xdf\x01\xe8\x01\xc6\0\0\0~\x01}\x01\x83\x02\xad\0\0\0\xb4\0\0\0\0\0\0\0\0\0\0\0\xbd\0\xb7\0\xaa\0\0\0\0\0\x88\0\0\0\0\0*\0\x9d\0\x96\0\0\0\0\0\0\0\xa5\0\0\0\0\0\0\0\0\0\xd1\x01\0\0\0\0\0\0\xb7\x01\xdb\x01\0\0\0\0\0\0\0\0\xe9\x01\0\0O\x01\0\0\xab\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xbc\0\0\0\x8d\0\x8c\0\xf0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\0\0\0\0\0\0\0\0\0\0\0\xea\x01\xeb\x01P\x01\xbb\0\xb8\0\x9d\x02\x9e\x02\0\0\0\0\0\0\0\0\xb9\0\xa9\0\xa3\0\xa4\0\0\0\0\0\0\0\0\0\xa2\0\xba\x01\0\0\xec\x01\0\0\0\0\0\0\0\0\0\0\xa6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xba\0\0\0\0\0\0\0\xdd\x01\xa7\0",
  dgoto: "\b\x008\0e\0{\0\x83\0\x95\0\x9f\0\xad\x007\x02f\0|\0\x84\0:\0Q\x01\x7f\0;\0\x87\0\x88\0\xc1\x01\xe9\x01N\x02\x16\x03\x93\x01 \x02\xd7\0<\0=\0\xbf\x02n\x01>\0?\0\xa1\0A\0B\0C\0D\0E\0F\0G\0H\0I\0J\0K\0L\0M\0O\x02N\0u\x01\x95\x01x\x03n\0o\0p\0O\0r\0s\0t\0u\0v\0H\x01\xa2\x02w\0\xa1\x01B\x03\x96\x01P\0w\x01\xc7\0\n\x02\xbb\x03Y\x04L\x04\r\x03\xef\x02\xdf\x04Z\x04\x83\x01\xc2\x01[\x04R\x02S\x02J\x03\xf1\x03U\x05\x8c\x04\x89\x04\x85\x04Q\0_\x05b\x03\xb9\x05\x96\x04c\x03\xa7\x04M\x04N\x04O\x04\xd5\x04\xd6\x04>\x05\x86\x05\xaf\x05\xab\x05e\x05x\0\xa3\x01R\0y\x01\xc7\x03j\x04\xc8\x03\xc6\x03\x05\x03\xb1\0S\0\"\x01\xb7\x01\x10\x03\x0e\x03T\0U\0V\0f\x04W\0X\0\xde\0Y\0Z\0\xdf\0\xe8\x000\x02\xe5\0\x85\x01\x86\x01\x8f\x02\x7f\x02[\0d\x03\xba\x05\xb6\0\\\0q\x01=\x02\x11\x03\xe0\0\xe1\0\xb7\0\xb8\0\x98\0\xdb\x01\xde\x01\xdc\x01c\x04]\0s\x01M\x01Y\x02\xf7\x03\x9b\x04\x97\x04`\x05Z\x02N\x03[\x02S\x03\x1d\x04\xf1\x02\xb8\x03\x98\x04\x99\x04\x9a\x04\x0f\x02\x03\x02\xf4\x02P\x04a\x05b\x05\x92\x03\x12\x05.\x05\x13\x05\x14\x05\x15\x05\x16\x05y\x03*\x05\x99\0\x9a\0\x9b\0\x9c\0\x9d\0\x9e\0\xbd\x01\xb1\x02\xb2\x02\xb3\x02-\x044\x045\x04\x8b\x03*\x04\xf7\x02\xbe\x01?\x01\x1d\x01\x1e\x018\x02R\x01",
  sindex: "\x14\b\xd9>\x9d\x06p,\x05,k\x0f\x90@\x96D\0\0\x84\x04l\x02WF\x84\x04\0\0\xca\x01e\0\x11\x01\0\0\0\0\x84\x04\x84\x04\x84\x04\x84\x04\x19\x03\0\0\0\0\0\0\x84\x04\x96FR\xff1?\x8b?\xdb:\xdb:\x1d\x05\0\0\xb87\xdb:\x84\x04\0\0\0\0\xe8\x04\0\0\x84\x04\x84\x04\x8e\xff\0\0\0\0WF\xd9>\0\0\0\0\x84\x04\xb9\xff\0\0\x84\x04\0\0(\x01/\0\x9b\x0b\x18\0\xd9G\0\0\0\0\xf6\x02\0\x008\0\0\0\0\0\0\0\xde\x01\0\0\0\0\"\x027\x02\0\0/\0\0\0\0\0\0\0\0\x000\x02\0\0\xd9E\x9b\0WFWF\x90@\x90@\0\0\0\0\0\0\0\0\0\0\xca\x01e\0\x18\x04B\x05\x9d\x06\xb9\xff\x11\x01\0\0\x88\x03\0\x008\0\0\0\0\x007\x02/\0\0\0\x9d\x06\0\0\0\0\0\0\0\0\0\0\x87\x02\0\0\x9e\x02\0\0\0\0\0\0l\x02\0\0<\x02`\x02/\0\0\0\xe3\x02\0\0\xe4,\0\0R\x04/\0R\x04\0\0\0\0\x0b\t\xd5\x02\xac\xff\x87\x04\n\x03\x85Ik\x0f\x8c\x03l\x02\xf3\x02\0\0\0\0\0\0L\0\0\0\0\0\0\0\xd4\x01\x13\0\0\0\x90\x03\xb6\x02\0\0+\x05\xf6\x02\x96D\x96E\x18\x03\x87C\xcdC\0\0\x90;f\x03\xb7\x03\x1c\x03\0\0\0\0J\0$\x04\0\0\0\0\x96D\x96D\0\0\0\0\0\0U\x04\x98\x04\xdb:\xdb:S\x04WF\0\0\0\0\0\0(8\0\0\0\0\0\0\xe2?\xcf\x03\0\0~\x04\0\0\0\0X\x04\0\0\0\0O\x02\x98G\xbd\x04\x96D\xc7B\xd5\x02\x90@\x95\x04o\x02\xd9>[\x05$\x04\0\0WF\0\0\xd9\x04\x0e\x01\xe5\x04\x91\xff\0\0\x93\x04\0\0\0\0\xea\x04\xa1\x04\0\0\x95H\xbe\x04\0\0\xbe\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x10\x05\x80>\x80>\x84\x04\x8e\xff\xd5\x04\0\0\0\0\0\0WF\0\0\xe1\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb3\0\0\0\0\0\0\0\0\0\0\0WF\0\0\0\0\0\0)\0v\xff\x80>\x90@\xcc\x04l\x02\xc1\x02\xf3\x02\b\x05\0\0\xe2\x04\0\0\0\0\x90@\0\0\xb9\x04\x90@\0\0\xdb:\x9b\x0b/\0\x84\x04\0\0W\x05\t\x06\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\0\0\x96D\x90@\0\0\xb9\x04\0\0\xfa\x04\0\0\xcf\x03\0\0\xcf\x03\0\0\0\0\x90@\x1f\x04WFWF6\x05;\x05WF6\x05\x18Fb\x01\0\0\0\0\x90@b\x01b\x01\0\0\0\0~\x04\x98\x01\x95\x04\x18\x04\x02\x05\x9d\x06\0\0;\x02\0\0\0\0\0\0\xad\x02\x1b\x05J\x03\0\0\xb9\x04\x80\x05\0\0\0\0\0\x003\x05\0\0\xcf\x03\0\0B\x06\0\0\0\0\0\0\0\0\0\0R\x04/\0R\x04\0\0R\x04\0\0I\f\0\0\x19\x04\0\0M\x05\xa5\x05\0\0I\f\0\0I\f\0\0\0\0\xab\x05\x97\x05]\x05k\x0f;\x03S\x04\x1d\x01{\x05\xba\x05\0\0\0\0\xb6\x05\0\0\0\0\0\0=\x03`\x05x\x05k\x0f_\x07\xf3\x02\0\0\0\0\0\0T=\0\0\0\0\0\0\0\0\xbf\x05\xbb\x05@\0z\x05\xf9\x03}\x05\0\0}\x05\0\0\x86\x05f\x03\0\0\x87\xff\xb7\x03\0\0\0\0\x81\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0,\x02\x94=\xd4=\x14>\0\0\0\0\x8b\x05\0\0\0\0\x96D\xc0\x02\x80>S\x04S\x04\0\0b\x01\xd0\x04\0\0\xf5\x02~\x04*\x04\xad\x05\0\0\x03't\x01\x03'S\x04\0\0\xec\x05\0\0k\x0f+\x03\x96E\x01<d\x02D\x05d\x05GB\0\0\x96D\x95\x05\x0e\x05\0\0\x0b\x01\x90@\x8b\x01\xa7\x03\xd6\x03\0\0\0\0b\x01|\x06\x18\x03\x90@\0\0\0\0\x18\x03\x90@;\x05\xc7\x03\x90@\xbb\xffz\xff\xdb:k\x0f\x96D\0\0\xa4\x05\xa6\x05\x94\x05\x84\x04\0\0\x96D\xc3\x05\0\0v\x01\0\0\x98\x0b\xd6\f\0\0\xaa\x05\0\0\0\0\xa8\x05\x96\x05\xc1\x02\xf1\x05\x18\x04\x19\x03\xc1\x02/\0\0\0\x96D5\x04\0\0l\x03\x9c\x05*\x04\0\0\0\0b\x03\0\0\xef\0\xfe\x05\x80>\0\0\0\0\x96F;\x05\x90@\x90@\x988\0\0\0\0\x86I\x86IQI\x1a\x07\x95HQI\x8f\f\x8f\f\x8f\f\x8f\f\xa5\x02\xe5\x05\xe5\x05\x8f\f\xa5\x02\xa5\x02QI\xe5\x05\xa5\x02\xa5\x02\xa5\x02\0\0\xe5\x05\x0f\x05/\0>A\x06\x06\0\0\xd5\x05\xc1\x02~\x04~\x04\x95H\x90@\x90@\x90@\xd9\x05b\x01b\x01\0\0\0\0\0\0\x01\x06\0\0\0\0QI\xdd\x05\x13\x05\x8f\xff\xc9\x05H\x04\xfe\x03\0\0\0\0m\x03\x14\x06\x18\x04\xe2\x04\xd8\x02/\0b\x03k\x0f\x18\x06~\x04\0\0\0\0\0\0\0\0\x11\x06\0\0\0\0R\x04\0\0\0\0\0\0\xda\0\0\0)\x06\0\0\0\0I\f\xbf\0\x19\x01\x1d\x10\0\0\xec\x01\0\0\xe2\x05\xda\x05\xc4\x05k\x0f/\x03k\x0fk\x0fu\x03\0\0\0\0\xbb\x01l\x02\xf2\x05\0\0\xd7\x05\0\0\x81\x03\x96D\0\0\0\0 \x03\x96D \0?\x03\x04\x06\"\x01\0\0\x9c\r\0\0\0\0\0\0\0\0\xaa\x02\0\x004\x06\0\0`\xff`\xff\0\0\xe9\x05\0\0\0\0\x90@\x90@\x90@\0\0\0\0\0\0\x07\x06\xbb\0\xf0\x05\0\0\xc4A\x85I\x03\x06\0\0\xb6\x02\xe8\x05\xf4\x05\xef\x05S\x04\0\0\0\0/\0\xc2\x01\x90@\0\0\x0f\x06\0\0\x96D\0\0\0\0\0\0\x17\x06\0\0\x17\x06\0\0r<\x90@GB\0\0\x1d\0Q\x06\0\0\x90@\0\0\0\0\0\0L\x06\x19\x03\0\0iG\0\0\x18\x04\0\0\0\0\0\0\0\0\xfd\0\0\0\0\0\x95H\0\0\x95HA\x06\0\0\0\0\x95H\0\0\0\0\0\0\0\0\0\0S\x04y\xff\0\0\0\0\xc1\x02\xe2\x04/\0\x90@\x94\xff\0\0\0\0\x10\x02\0\0S\x04\0\0\0\0\xd5\x02/\0\x18\x04/\0+\x01p\x05\0\0\0\x005\x02\0\0\0\0+\x02\0\0\x83\x05\0\x008\x01C\x06\x05\x06l\x02\0\0\0\0\x90@\x0b\x06S\0\xa1\x04\xbe\x04\xbe\x04\xb3\0\xa6\xff\x90@\0\0$\x0b\x90@\xe3<\x81AD\x06\0\0\0\0k\x0fC\x06/\0!\x06$\x06\xf9G\x03\x05E\0\xae\xff\x90@Y\x06\x18\x04\0\0\0\0\x19\x03\0\0\0\0\xfc\x05\xc2\x04i\x06\0\0\0\0\0\0\x18\x04$\x02l\x03v\x02c\x06\0\0\x1a\x06s\x05\x18\x048\x06\xe2\xff\0\0I\f\0\0\0\0k\x0f@\x01t\x06\0\0\0\0l\x02+\0S\x04\0\0\0\0k\x0f\0\0\x0e\x06S\x04\xf3\x02\0\0\xf2\x055\x06\0\0\x13\x06\0\0\0\0_\x07\0\0\xf9\x03&\x06\0\0\xf9\x03\0\0\0\0\0\0\0\0\x96D;\x03\0\0\0\0\xcd\xff\0\x007H\xb6\0\xd9\xffj\x06*\x04\0\0l\x02\0\0a\n\x9c\x04/\0\xc4A^\x01\x8d.\x03'/\0\0\0%\x06\x07\0(\x06\xcb\x03r\x06r\x06\x80\x06/\x06O\x06\0\0\0\0\x90@\x90@\x96DWH\x18\x04p\x05\0\0\x9c\xff\x9d\xff\0\0\xa0\xff\0\0\0\0\x90@\x90@l\x06\x18\x05\0\0\xb5H\0\x001\x06k\x0f\x96D\0\0$\x02\0\0\x19\x03k\x0f\0\0k\x0f\x8e\xff\x90@\x8e\xffu\xff/\0\0\0\0\0\0\0\x96D*\x04\0\0\xe3F\0\0<\x06\0\0\x82\x06\0\0\0\0\0\x003\x04\xeb\0>\x05U\x02\0\0\0\0\0\0Z\x06T\x01\0\0d\x06\0\0\x90@\xa3\x02\0\0\0\0\xc4A\x81\x06g\x06\0\0\0\0h\x06\0\0m\x06\x95Ha\n$\x02p\x05\x98\x06\x90\0*\x04\x96\x03\0\0\xfe\x03;\x02\0\0\0\0\x18\x04<\x06\0\0;\x02\x9f\x06\0\0\0\0.\x02\0\0\0\0A\x01\0\0k\x0fl\x02\0\0\xf2\x05\x18\x03\0\0\xac\x06\0\0k\x0f\0\0\0\0\0\0%\x04Z\0\0\0\0\0\0\0\0\0\0\0\f\x03\0\0\0\0r\x0e\xa8\x06\x85Iv\x06\x8d.z\x06\0\0\xa1\x06S\x04x\x06\0\0]\x06*\x03\xb6\x02\x07Ck\x0f\x9c\x04\b\x05\0\0P\x04S\x04\x18F\0\0\0\0\0\0/\x03\0\0\0\0\0\0%\x06/\0\0\0\0\0\x90@GBk\x0f\x90@`\x06e\x06k\x0f\0\0k\x06\0\0}\x06\0\0\x90@%\xff\0\0O\xff\0\0n\x06\0\0\0\0\x95H\0\0\x90@\x90@\x90@\0\0S\x04Q\x06p\x05;\xff\xff\x02/\0\x9c\x04/\0\0\x03/\0\x85\x06\x87\x06/\0\0\0Q\x06\0\0e\0\0\0\xdb0\"G\0\0o\x03\x8e\x06\xc0\x06\0\0\0\0\x98\x01\x01\x02\0\0%\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa9\xffZ\x06\xb3\x06k\x0fw\x06\0\0\x90@\x01\x02/\0\f\x03\x90@\x90@\x90@/\0`\x05`\x05\x95\x01\0\0\xbd\x06\xbb\x06\0\0\0\0\xde\x02y\x01\0\0a\nk\x0f\0\0\0\0\0\0\0\0\0\0\xc1\x06\x0e\x06\xf2\x05\x14>\0\0\0\0k\x0f\0\0\0\0s\x05\x99\x03W\x01\x90\x03\x8d.\x9f\x01k\x0f\x89\x04\0\0\x91\x06\xcf\x06\x9c\x04\0\0a\n\x03'\xb3\x03\x87B\0\0a\x01\xdf\xff\x90\x04\x9c\x04\0\0\x18F\0\0\0\0\xca\x06\0\0S\x04\0\0\0\0\0\0S\x04GB\x90@\x95H\0\0;\x03\0\0\0\0\0\0\0\0\x13I\0\0k\x0f\0\0\xc3\x01\0\0q\x06<\x06;\x05\0\0\0\0;\x05{\x06;\x05\0\0\x98\x01S\x04\xc0\x06\xc0\x01\x85\x06\0\0S\x04k\x0f\0\0e\0^\x02 \x02\0\0\0\0\0\0\0\0\0\0\x84\x06\0\0k\x0f\x92\x03\x81A\0\0\0\0\0\0s\x05\x95H\x95H\x95H\0\0\xf0\x03\xf0\x03\0\0k\x0f\x86\x06k\x0fv\x02e\0\x98\x01G\x02\0\0\0\0/\0\0\0k\x0f\0\0\x1f\x01\0\0\xce\x03\xd0\x03\x9c\x06/\x03W\0\0\0\0\0m\x01a\n\x8d.S\x04\0\0\0\0\0\0\x9c\x04\0\0\xf3\x02\0\0a\n\0\0\0\0\0\0S\x04\x90@\0\0\0\0\x8a\x06\0\0S\x04\xab\x06/\0;\x05;\x05\x07B\xe2\x06;\x05\f\x05S\x04\0\0\xcf\0;\x05\x94\x06\0\0\x85\x06\0\0\xdd\x03\0\0\x7f\x02t\x01S\x04\0\0\0\0\0\0\0\0\xe5\x03\x90@\0\0\0\0\0\0\0\0\0\0\0\0\x98\x01\0\0\0\0\0\0S\x04\0\0\0\0\0\0\0\0a\n\0\0k\x0f\f\x03:\x04\xba\x02/\0\0\0\0\0\0\0\xb2\x06S\x04\0\0l\0\xec\x06\0\0\0\0\0\0\xf4\x06\xf5\x06\xbdF\0\0k\x0f\xf8\x06\x90@\xef\x06\0\0\x85\x06\xc0\x06\xf9\x06\0\0\0\0k\x0ft\x01S\x04S\x04\0\0\x90@\0\0\xfa\x06\0\0/\0s\x05\xaa\x06\xb5\x06;\x05\xcf\x03\x85\x06\x0f\x07/\0\0\0a\n\0\0\0\0\0\0\x1d\x10\x1d\x10Z\x06S\x04\x06\x07\xac\x01S\x04k\x0f\0\0\x90@\xc5\x06\x1d\x10S\x04S\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15\x07;\x05;\x05k\x0f\0\0\0\0\0\0\0\0\x11\x07\x90@k\x0fS\x04\0\0\0\0S\x04\0\0\x1d\x10\x1c\x07\x1e\x07S\x04k\x0f\0\0S\x04\xcd\x06/\0k\x0fk\x0f\x04\x04S\x04\0\0S\x04S\x04\x90@\0\0\0\0",
  rindex: "\0\0/\b0\b\xd0\x06\0\0\0\0\0\0\0\0\0\0\xd5F\0\0\0\x009@\0\0s\x03\0\0\0\0\0\0\0\0\xd6DGC\x10D\xe7@\0\0\0\0\0\0\0\0\xd5F\0\0\0\0\0\0\0\0\0\0\0\0PD\xea\x10\0\0\0\0\xe7@\0\0\0\0\0\0\0\0\xf7\x03\xed\x01\xc2\x06\0\0\0\0\0\0G\0\0\0\0\0\xe7@\xd4\x03\0\0\xe7@\0\0\0\0\xe2\tG\0f\x11\x9a&\0\0\0\0@6\0\0g6\0\0\0\0\0\0\x936\0\0\0\0\xc06\xd66\0\0\xdf6\0\0\0\0\0\0\0\0\0\0\0\0\xfb\x16s\x17\x0e\x16\x84\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\x03\0\0\0\0\0\0n\0\xd4\x03\0\0\0\0\0\0\0\0y\x0e\0\0\0\0?1\xb51\0\0n\0\0\0\0\0\0\0\0\0\0\0\xf02\0\0Y3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd1\x06\0\0\xd0\x06\0\0\0\0\0\0\0\0\x7f\x04\0\0\0\0\0\0\0\0<\r<\r\0\0\n'\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0%\x0f\0\0\xed'R(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0V-\0\0\0\0\xa4\x02 \x06\0\0\0\0\0\0\x95\x06\xc8-\0\0\0\0\x039\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\x03\0\0\xfc\x06\0\0\0\0\0\0\0\0\0\0\xf84\0\0\0\0\0\0\0\0\x16E\0\0\0\0\0\0\xc5\x04\xdf6\xf3\x05\0\0\0\0`\x01\x9b\x04\0\0\xc9\xff\0\0\0\0[\0\0\0\0\0\0\0\x82\x04\0\0^\0\xfe\0\0\0\\\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0C7\xd7\x06\xd7\x06\xc7\x06\"\x04VE\0\0\0\0\0\0\x97\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0u9\xcd9\0\0\0\0\0\0%:}:\0\0\x99\0\0\0\0\0\0\0\0\0\0\0\xd7\x06\0\0\0\0\0\0\0\0\0\0[\x06\0\0\0\0\0\0\0\0\0\0\0\0\xf8\x02\0\0\0\0\0\0G\0\xf7/PD\0\0@6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xca\x1f\0\0\0\0\0\0\0\0\0\x002\x03\0\0\0\0\0\0s\x03\0\0s\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x11\xa9\x14\0\0\0\0\0\0\xe9\x17_\x18\0\0\0\0\xfc\x06\x8a\n\0\0\0\0\0\0\xd6\x04\xca\x07\xb51\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf8\x02\0\0\0\0\0\0\0\0\0\0\0\0s\x03\0\0o\x07\0\0\0\0\0\0\0\0\0\0\0\0\x7f\x04\0\0\0\0\0\0\0\0\0\0\0\0G\x01\0\x000\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1b\x07\0\0\0\0\x90\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xca\xff\0\0\x96\0\xa8\0\xfe\0\0\0\\\x05\0\0\0\0\xc9\0\0\0\0\0\xca\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd7\x06\x039\x95+\0\0\xd7\x18\0\0\0\0\0\0\xfc\x06\xe4\x06\0\0\0\0\0\0\0\0\0\0\xac\x0b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0M\x19\0\0\0\0\0\0\0\0\0\0\x0f\x01\0\0\xa9\x04\0\0\xa1\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc7\x06\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13'\0\0\0\0\0\0\xdf6\0\0\0\0\0\0\0\0z4\0\0/\x04\0\0\0\0\0\0\0\0\0\0\0\0\xd7\x06\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85\"\xf4\"P\t\x7f\x05\xcf\x0f^#@ \xb7 .!\xa4!\x02\x1d\xc3\x19:\x1a\x1b\"x\x1d\xef\x1d\xc8#\xb0\x1af\x1e\xdc\x1eS\x1f\0\0'\x1b\0\0F5\xaf\x04i\x05\0\0\0\0\0\0\xfc\x06\xfc\x06Z\x10\0\0\0\0\0\0W\x12!\x15\x98\x15\0\0\0\0\0\0\xce\x12\0\0\0\x002$\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb51\0\0\0\0\0\0\xfc\x06\0\0\0\0\0\0\0\0\x11\f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x036\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1d\x07\0\0\0\0\0\0\x99\xff\0\0\xb7(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83)\0\0\x1e)\0\0\0\0\0\0\0\0\0\0\x1c\x01\xa1\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\x04\0\0\t\n\0\0\xc6\x03+\b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0.0z0\0\0\0\0\0\0\xcb5\0\0\0\0z4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x9e\x1b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\x01\0\0\xdb\xff\0\0\xa9\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\xe0\x06\xe5\x06\0\0\0\0\0\0\0\0F5\0\0\0\0\0\0\0\x005\x01\0\0\xb9\x01\0\0\0\0\x16E\x0e6\0\0z4\0\0\x904\0\0\0\0\0\0\0\0\0\0\xdb\x04\0\0\x16E\0\0\0\0\xcd1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x04\xfe\0\\\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0v2\x0e6\0\0\0\0\0\0\xf3H\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\x02\x80\x03\0\0\xf3\n\0\0\0\0D\r\xb51\0\0\0\0\0\0\0\0\xb51\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1b\x02\0\0\0\0\0\0\0\0\0\0\x99\x01\0\0\0\0\xe8)\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\0,\x01\0\0\xf6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x06\0\0\0\0\0\0\0\0\0\0\x0e6\0\0\0\0\0\0\0\0\xdf6\0\0\0\0\0\0\0\0\xc7\x01\xea\x06\xea\x06\xd7\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0}'\0\0\xf7\x06\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe03\0\0\0\0\0\0\0\0\0\0\xf5\x04\0\0,\xff\xe7\x04:\b\0\0\0\0\0\0\0\0/\x04\0\0\x18\x07\0\0\b\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0D\x13\0\0\0\0\xbc\x13\0\x003\x14\x97$\0\0\xff1!+r\x04\0\0\xe4\x06\0\0\0\0\0\0\xe9\r\0\0\0\0\0\0\b\x02\0\0\xe9\r\0\0\0\0\0\0G\x01\0\0\0\0\0\0A;\0\0\0\0\0\0O*\0\0\0\0\xac\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0E/\0\0\xd8\x05\0\0\0\0\x80/\0\0\xc0\b\0\0\0\0\x01\x07\0\0\x8b0\0\0\0\0\0\0[\x06\0\0\0\0\\5\x14.\0\0\0\0\0\0\xe70\0\0\0\0\0\0\x124z4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb5\0\0\0\0\0\0\0\0\0\0\0\xdb\x01\x14\x1c\xbd4\0\0\0\0:\b\0\0:\b\x0e\x07:\b\x12\x07\x12\x07:\b\0\0\x8b\x1c\0\0\0\0\0\0\0\0 \x07\x9d.\xb12\0\0\xec2\0\0\0\0\x831M4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0:\x07\0\0\0\0\0\0\0\0\0\0M4\x0e6\0\0\0\0\0\0\0\0\xe9\r\0\0\0\0\0\x004\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb4*\0\0\0\0\0\0\0\0\0\0\0\0M4\0\0\0\0\r\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0O.\0\0\0\0\0\0\0\0\xf2\x01\0\0\0\0\0\0\t\x02\0\0\0\0\xfc$\0\0\0\0\0\0\0\0\0\0\0\0V\x01\0\0\0\0\0\x006\x02\0\0\x13\x07\x0e\x07\0\0\0\0\0\0\0\0%\x07\0\0\0\0\x831'3j3\xf3\x01\x12\x07\0\0:2\0\0\0\0\0\0\xef4\xdf6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0M4f%\xcb%0&\0\0P\f\xdd\f\0\0\0\0&A\0\0\0\0\0\0D\x07\xb51\0\0\0\0\xe9\r\0\0\0\0\0\0\xfa\x03\0\0\0\0\0\0\0\x0051\0\0\0\0\0\0\xe3\x04\0\0\0\0r5\0\0\0\0\xbb/\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd8.\0\0\0\0\0\0\0\0\0\0\t\x05\0\0:\b\0\0\0\0\0\0\0\0\0\0\0\0:2\0\0\0\0\0\0\0\0\0\0E\x02\0\0\0\0\0\0\xef4\0\0\xd73\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0D\x07\0\0\0\0\0\0\xbe\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&\x07\0\0\xe3\t\0\0\0\0\0\0\0\0\x13/\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x12\x07\xa53\0\0\0\0\0\0\0\0\0\0\xd73\xc15\0\0\0\0\0\0,\x0e\0\0\xe3\t\xe3\t-\x072\x07\0\x008\x07\x12\x07\0\0\xe3\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x000\x03\0\0\0\0/\x05\0\0\0\0\0\0\0\0\0\0\xef*\xc15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb4\x05\0\0\0\0\x9b\x02\0\0\0\0\0\0\0\0\xb8\x05\0\0\0\0i\x04\xff\x06\xe3\t\0\0\0\0\0\0\x9f\x04\0\0\xe1\x06\xd3\b\0\0\0\0\0\0",
  gindex: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\\\0\xf3\xff\0\0V\0\xfd\xff\xe8\x06\xff\x07>\0\0\0\xcc\xff\x87\0?\0[\xff\0\0\x94\xfe\0\x07G\xff\xd2\x07\xa3\x0e\xf3\xfc\x11\0\x16\x04\x0e\x001\x004\0B\0\0\0\0\0\0\0\0\0K\0X\0\0\0a\0\0\0\x02\0\x04\0^\xfe\0\0\0\0S\xfe\0\0\0\0\0\0\0\0c\0\0\0\0\0\0\0\0\0\0\0\xee\xfe\xa0\xfc\0\0\0\0\0\0\x06\0\0\0\0\0\xa4\xff\xcf\xfe\x88\xfe\x12\xfcr\xfcH\xffg\x04\xa8\x03\0\x000\x048\xfds\xff7\x04\0\0\0\0\0\0\0\0\0\0\0\0\x10\x03\xf7\xff\xcc\xfb\xc9\xfe$\xfe\x81\xfc9\x03\x8b\xfb\x1d\xfc\n\xfcZ\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8c\x05\xcd\x04\xa8\x04\0\0\0\0g\xff\x1e\0\xe7\0\x8c\xff\x05\x02\t\xfd]\xff\xbe\b1\x0b\0\0\0\0\0\0j\xff\xfb\x06\x8e\f>\x06\x01\0V\xffI\x06\x86\xfe\0\0\"\x07p\x06\xd6\x0b\xbd\xfcX\xfd\xd4\xfe\0\0\0\0\0\0\xdc\x04L\x04\0\0\0\0\xa6\x06w\xff\xdc\x05\n\b\0\0O\x04\0\0\0\0P\bI\x02P\x05-\xfc\xb8\xfb\xf4\xfc\xd2\xfd\0\0\x0f\xfe\0\0\0\0\xea\xff\0\0\0\0\xeb\xfb\xf9\xff\xf0\xfbi\xfe\xfe\xfd\"\xfe\0\0\0\0\xf7\x02\0\0\0\0\xfc\x03\xa0\xfb\0\0\xaa\x03\x9a\x04\0\0s\xfd\x03\f~\xff\0\0\t\0C\xfe\n\x06\x88\xff\xd7\xfe\x82\xff\0\0\xfd\x03\0\0\0\0\0\0\xee\x06\0\0\0\0\0\0\x1a\x005\xff\0\0",
  tablesize: 19189,
  table: "~\0\x85\0\x8c\x01\xa0\0l\0\xc8\x01m\0E\x02\xcd\0\x93\x02\xd5\x01\xb5\x01\xfb\x02\xc3\x01\xda\x01;\x02\xbf\0\xb4\x01\x91\x03\xc0\x02\xe4\0\xd1\x01\xcc\x03\xb9\x01\xf0\x02\x1a\x02\xbb\0\xb5\x02\"\x02\xbb\0\t\x04\"\x04\xea\0>\x01\xf4\x01\x97\x02\xbb\0\xbb\0\xbb\0\xbb\0M\x03\xc1\0\xe1\x03\xbd\x03\xbb\0\x93\x03\xf5\x02\x1f\x02\xfc\x02\x19\x05@\0\xbb\0@\0@\0g\0\xbb\0\x1b\x02\xac\x04\xdd\0\x1f\x01\xbb\0\xbb\x002\x02@\x013\x02\x80\0\x86\0\x81\x02h\0\xbb\0\xae\x003\0\xbb\0T\x01\xf9\x01\t\x05\xc9\x01i\0I\x01\xf6\x02\xad\x01\xf6\x02\xaf\x01\xd7\x049\x02\x9a\x01\x03\x05\x05\x05\x8d\x01}\0j\0\x95\x020\x059\0\x1c\x02\xce\x04\xf3\x04\x9f\x01@\0k\0l\0q\0m\0\xe1\x04\xb9\0\b\x02\xe6\x02\xe7\x02U\x01\x9f\x02W\0\xf7\x01l\0\x84\x01m\0\x88\x01\x89\x01H\x02F\x02\xe2\0\xfd\x02\x9d\x04,\x03@\x02G\x01\xf5\x01\xb9\0\xab\x01\xa4\x01\xf6\x01\f\x05\xbc\x01-\x03\xf2\x04\x9f\x02?\x02\xf7\x01\xb2\x04\r\x05\xf8\x01\x96\0J\x01\xb8\x02q\x03\xb9\x02+\x02\xb3\x01\xe3\0\xe0\x03G\x01g\0\xc5\x01\xfc\x04\x1b\x02\x9a\x02\xf9\x04t\x04v\x04\x9f\x02<\x04x\x04\xa4\x02g\0\xb9\0h\0\xbc\x04\x02\x04\xca\x01@\x03\x17\x05\x1b\x02\xa4\x02E\x03i\0\x14\x04\xf4\x04h\0U\x01j\x05@\0\xb6\x01U\x01\x06\x04U\x01P\x02i\0j\0*\x03\xb9\0>\x01\x80\0\xfa\x01\xac\x01\x07\x02\x86\0k\0\x86\0q\0j\0u\x04w\x04k\x01\xa6\x01 \x05\x02\x02=\x04w\x05k\0\x1d\x02q\0\xb9\0\0\x02\x01\x02\xbd\0G\x02\xee\x02\xaa\x01\x14\x04\x04\x02j\x019\x05\xbd\0\xbd\0H\x05C\x03\xd3\x01g\x03\xb9\0\xdd\x01\xdd\x01\x8b\x02\x8a\x04&\x02\x1f\x02\xbd\0A\x05\xdb\x03I\x05,\x02r\x03\xbc\0\xfc\x01\xfd\x01\xc4\0\f\x05M\x05\xd7\x02\\\x05'\x02\x1b\x02\xd0\0\xd1\0\xd2\0\xd3\0)\x04\xa4\x02y\x04h\x05\xda\0\x92\x01\x9a\x02\xa5\x01\x03\x04@\0L\x01\0\x05\xb8\x01\x92\x01\x92\x01A\x01\x15\x04\x14\x02\xb9\0\x81\x02E\x01F\x01\xbd\x02\x9a\x02\x9a\x05\xcd\x01\x92\x01+\x03\x85\x02K\x01\x86\x02h\x05N\x01d\x04\xa7\x03\xf5\x01\xb9\0\xa7\0\xce\0\xf6\x01k\x01\xa6\x01O\x01A\x02k\x01\xa6\x01\xf7\x01>\x04V\x01\xf8\x011\x05\xbb\0#\x02}\x03\xd4\x02\xe5\x02\xd5\x02B\x02j\x01A\x04C\x02r\x01j\x01\xbe\x02I\x02J\x05\xd0\x02/\x04\xd2\x05\xcd\x02\xc1\0\x12\x04\xa6\x023\0U\x02K\x02\x88\x05\\\x02\xca\x02B\x05\xf5\x01@\0@\0e\x02\xf6\x01\xfc\x03h\x03i\x03\xa0\x05\x89\x05I\x01\xf7\x01\xc9\x04g\x01\xf8\x01\xce\x01n\x01^\x02\xb9\x003\0\xa5\x01\xc0\x03\xbb\0\xa0\x05\xa5\x01\xcd\x03n\x01|\x02]\x02 \x03\xb2\x05\x82\x02W\0\xeb\x02\xe9\x04@\0e\x04P\x01\xc8\0\x85\x03\xad\x02\x90\x02\xaf\x02\xcc\x05\xb0\x02\x18\x03\0\x03\xd0\x04\xa8\x03\xd3\x04W\x05\x1b\x02U\x01\xc9\0\x99\x02\f\x05\xf0\x020\x04W\0D\x02\xc0\x02^\x05\xe0\x04\xb9\0\x8c\x03\xb9\0\xce\x03\xdc\x03U\x03l\0D\x03m\0\xa1\x01[\x02\x18\x05T\x02\xb9\0\x8c\x02\x8d\x02\xd1\x02\xa8\x05\x91\x02\xa5\x05\x84\x01\xc3\x04\x13\x04\x9c\x023\0\xfb\x01\xca\0\x9f\x01l\x01o\x01\xb4\x04\x1e\x02\x87\x01~\x02\xd7\x03\xfd\x03\x87\x05\x9f\x01?\x02o\x01m\x01\x12\x04\x7f\x05g\x01\xb3\x01\xca\x04\x8b\x05n\x01\x1e\x02\x1d\x02n\x01\xb3\x01\x1d\x02\xb3\x01\x02\x02\xf0\x02g\0\x8f\x04\x88\x03a\x03^\x02\\\x02t\x05\xb3\x05\xb5\x03l\x01\x1d\x02P\x03\xcb\0\xca\x01h\0\xcc\0\xe5\x03\xd4\0\x90\x04\xcb\x02o\x05m\x01U\x01i\0U\x01\xc8\0U\x01_\x04`\x04\x88\x03\x8d\x03\xfa\x01k\x03Q\x05\x1b\x02\x86\0j\0\x86\0\xa1\x04\x86\0\xc9\0\xfa\x01 \0\xa6\x05\x18\x03k\0\xa1\x01q\0\xd5\0\xa0\x01[\x02O\x05T\x02\xfa\x011\x04R\x04\xd8\x03\xa3\x02\xc0\x02\xa0\x01R\x04\xf6\x02\xd0\x04\x18\x04\x99\x05\x9f\x01:\x02o\x01\x9f\x01l\x01o\x01\x1e\x02\xfa\x01\xfa\x01i\x01 \x04\xca\0\x02\x02\x02\x02@\x04\xcb\x02m\x01\xcb\x02&\x04\xb6\x03\x82\x03\xd6\0\xa2\x01\x8e\x03\x1d\x02z\x05\x02\x02\x88\x036\0\xcf\x05\x05\x02\xfa\x01&\x03\xc0\x02\xc0\x02^\x02\\\x02\xf0\x02\xa3\x02\x10\x05\xf7\x01\xc1\x02\xac\x03@\x002\x05&\x02\xc8\0\xde\x02\xe0\x02\xe2\x02\x89\x03\x9a\x03\xbc\x03\xcb\0\xda\x01\xe3\x02\xcc\0$\x02\xb9\0\x9b\x03\x9c\x03\xc9\0]\x04k\x03\xe7\x03\n\0\x88\x03\xa2\x04\xf4\x03Q\x03\xbb\0\x1e\x02.\x03\xe2\x02p\x01&\x02\xa7\0\xce\0\xa0\x01\x17\x03\x9d\x05\xa0\x01\xe4\0\x1b\x02R\x04\x0f\x03\xa3\x02\xd9\x03\xd2\x03R\x03w\x02[\x03\xb9\0X\x03Y\x03s\x04d\x01\xca\0d\x01\xc1\x02\xa8\x04\xe2\x02i\x01\xd1\x01\xb9\0x\x02\xc1\x02\x80\x01\x81\x01\xc1\x02\x1b\x020\x03O\x02\x8f\x03\x05\x02\xa2\x01\x87\x03w\x02~\x02\xc2\x02\xdd\0{\x05\x80\x05,\x05\xad\x03)\x027\x03O\x02l\x03m\x03\xc8\0\xa3\x02x\x02\x1a\x03R\x04\xbf\x05@\0\xfa\x01G\x03\xcb\0\x11\0\xc0\x04\xcc\0p\x01\xad\x04\xc9\0\xf5\x03\x1b\x03\xfe\x02q\x05\x81\x05s\x05+\x04\xc1\x04\x9a\x02\x01\x040\x02{\x03\x89\x01\xe2\x02\f\x02\xb5\x03\x9c\x02a\x03!\x001\x02\xf8\x02\xfe\x03\xff\x03\0\x040\x04\xc1\x02%\0\xbc\x01\x82\x058\x05\xf9\x02\xbb\x04$\x02\xb9\0\x19\x04\xca\0/\x03w\x02^\x04G\x05\xb3\x01w\x02\xd4\x05O\x02O\x02\x80\x01\x81\x01T\x05\x1b\x02:\x03<\x03\xe3\x03x\x02$\x02\xb9\0\xa0\x03x\x02\x9e\x03O\x02O\x02r\x01O\x028\x03]\x05\xf3\x03\x86\x04C\x05\x88\x04\x8b\x04\xc2\x03\x83\x05U\x013\0t\x01\xdd\x006\0O\x02\xcb\0\xb2\x03\xb3\x03\xcc\0\x0e\x02\xcb\x01\x1c\x03\x86\0\xe4\x020\x02\xfa\x010\x02\xfa\x01\xda\0\xfa\x01\xfa\x01'\x05q\x011\x02\xc0\x021\x02:\x04\x94\x02\xc3\x03\xcc\x01\xfc\x02:\x05\xe4\x02R\x04\x94\x02\xba\x01\xbc\x03\xb9\0\xb9\0\xe4\x020\x04\xcb\x03(\x04\x02\x026\x04\xde\0\xa3\x03\xca\x01\x94\x02\x94\x02\xa6\x032\x04\x0e\x05R\x04\xcc\x01\x94\x02\x91\x03r\x01\x9c\x04\x9f\x03\xe4\x02\xe4\x02R\x04\xf6\x02\xfa\x01\xe2\x034\x03\x1b\x02\xdb\0v\x01\x94\x02\xdd\0\x10\x05\x94\x02\xe4\x02\x83\x03\xdb\x02\xe3\0\x82\x04\xe4\x02\xbf\x04&\x02\xe4\x02\x93\x03\xe4\x02\x94\x02\x9e\0\xda\0\xc5\0\xf5\x01x\x01q\x01\xc6\0\xf6\x01\xea\x03\xe2\x02\xca\x01\xfa\x01\xc5\x03\xe8\x03\xf7\x01P\x01\xc0\x02\xf8\x01\x98\x03\x9e\0\x94\x02\xca\x01\xef\x03\xca\x01\xf0\x03,\x05\x9e\0\xfa\x03\xde\0\xb9\0\x9c\x02&\x02\xbc\x03\xf9\x03\xfa\x01\x04\x04\xeb\x03\xec\x03\x07\x04\f\x02\xe4\x02\x94\x02\xaf\x03\x1e\x04\x94\x02\xa5\x04P\x01\x9e\0\x9e\0\xb9\0!\0\xdb\0\r\x02\x93\x02\f\x02\xa7\0\xce\0{\x01%\0\xb9\0\xed\x03\x9e\0\x94\x02\x1b\x02c\x05\x94\x02\xb9\0g\x05\x9e\0\x9e\0\xe2\x02\x9e\0\xb9\0P\x01Q\0\xd8\x02R\x04R\x04\x9f\x02\xf5\x01\x96\x02\xb8\x04\x9d\x01\xf6\x01\xa0\x01P\x01R\x04\f\x02\x9c\x02\xd9\x02\xf7\x01\xb3\x01\xd4\0\xf8\x01\xca\x01\xe9\x03.\x04$\x02\xb9\0\x9a\x02\x9f\x05\xde\x04\xee\x03\xc5\x04\xa5\x01C\x04\x0e\x02\xa2\x01\xda\x01\x02\x02\x89\x01\x02\x03\x03\x03\x9e\0\x89\x01\xca\x018\x04 \0\x89\x01\xbd\0\x89\x01\x0e\x02\x9a\x02\xd5\0\x89\x01\x89\x01\xfa\x01\xc7\x04\x89\x01\xfa\x01\xa1\x02\xf7\x01\x1b\x02\x83\x02\xf8\x01D\x04\xab\x04\x89\x01\xca\x01R\x04\xa6\x01\x9d\x02\xb9\0\x98\x05\x9d\x01\xb5\x018\x04\xd1\x01o\x04p\x04\r\0\xb4\x01\x1b\x02L\x02\x0e\x02\xa2\x05b\x01c\x01\x04\x03\x9a\x03\xfa\x01\xd6\0{\x04\xd0\x05\xd1\x05\xbe\0M\x02\xb6\x016\0\x12\0!\x02\xda\x02\xc3\x01&\x02\xa3\x02:\x03\xb9\0\x89\x01\x9c\x02\x87\x04;\x04X\x04\x0b\x04\xb9\0\x89\x01\xcc\x01\x0e\0\x18\0\x19\0\x1a\0R\x04\xec\x02\x9c\x02\xb1\x01\xe2\x02o\x01h\x01\xe3\0\xe2\x02\xc7\x01\xe2\x05\x0f\0\x10\0\x89\x01\x89\x01\x1e\x02\x89\x01\x89\x01\xac\x05\xaa\x04\xa9\0\xc3\x05\xc4\x05m\x01\x17\0*\0\x0f\x03\xed\x02\xc3\x01,\x02&\x02\x7f\x01\xb7\x04#\x02\xaa\0\x89\x01\xbf\x01\xd0\x01\xfa\x04\x97\0\xca\x01\xb0\0p\x01,\x02!\0\xb9\0\x0f\x03S\x01\x97\x05\x93\0\xde\x042\0%\0\x9c\x02&\x02\xd9\x05\xad\x05\xd9\0)\0\xf5\x01\xf7\x01\x9c\x02\x0f\x03\xf6\x01\xc6\x01-\0\xc4\x04\x9c\x02\x7f\x03\xbb\x01\xf7\x01\x02\x02\xd4\0\xf8\x01+\x05\xa9\x03\xdd\x04\xe1\x05\xb9\0\xf7\x01\xcb\x04\x1b\x02\xff\x02\x80\x03 \0\xaa\x03\xf7\x01\xf7\x01\xfa\x01\xcc\x04\xd1\x04\xeb\x05,\x025\0\x81\0\x9a\x02\xc7\x01 \0\x1b\x02,\x02\x9f\x02\xd8\x01\xfe\x04\xd5\0H\x04\xb1\x01\xda\x04\xf7\x01\xf7\x01\xd8\x016\0\xe8\x04a\x03\xa0\x02\xeb\x04\xbb\x01\xc7\x01\x80\x04\xe4\x04,\x02\xcc\x01\xf7\x01\xb9\0\x83\x04\xb1\x01\x84\x04\xff\x04\xbb\x01\xf7\x01\xf7\x01\x94\x01\xf7\x01\x84\x01\xf6\x04\xf7\x04\x93\0\xbd\0\x95\x04\xc6\x02\xe0\x02Q\0\xd6\0\xfb\x01\x1b\x02\x9c\x02\xea\x01X\x046\x006\0\x07\x05\n\x05\x93\0\xa1\x02Q\0\xc7\x016\0\xa4\x03\xca\x01\x99\x03&\x02\xca\x01\xca\x01\x11\x05\xeb\x01\xec\x01\xed\x01Q\0Q\0Q\0Q\0\x93\0\x97\0a\x03\xf7\x01\xc7\x01O\x03\x97\0\x97\0\xca\x01\x1d\x03\x1d\x05Q\0\x92\x01\x98\x02\xc7\x02n\x05\xbd\x007\x05P\x01\x9a\x03\xb9\0\xee\x01\x98\x02-\x05\x9d\x03X\x04\xb0\0\xb0\0\x8a\x05\xb0\0\xb0\0Q\0\xb0\0\x1b\x02Q\0\x1e\x03\xa2\x03Q\0Q\0Q\0\x9d\x01'\x03\xb0\0\xb0\0\x9d\x01Q\0\x9c\x02\xc4\x01\x9d\x01\xf5\x01\x9d\x01\x93\0Q\0\xf6\x01\x9d\x01\xb9\0\xef\x01\xb6\x04\x9d\x01h\x04\xf7\x01\xcc\x01z\x03\xf8\x01Q\0\xda\x04Q\0\x9d\x01Q\0Q\0e\x02\xcb\x02\xb0\0\xb0\0\xf0\x01\xf1\x01\xf2\x01\xd9\0(\x03P\x05Q\0\xea\x04e\x02Q\0\xe4\x04\xee\x04D\x05Q\0\xcf\x01X\x05\x9e\x05\xd4\0Y\x05\xca\x01[\x05\xf5\x01\x9d\x01\xca\x01\xa3\x05\xf6\x01\x9d\x01\x84\x01\xf3\x016\0\x9e\x035\x05\xf7\x01f\x05X\x04\xf8\x01\x9d\x01\xe4\x04\xb9\0|\x05\x9d\x01\xcc\x04 \0\x7f\x01X\x04\x90\x02\x90\x02\x7f\x01\xd5\0\xca\x01\b\x05\x7f\x01\x90\x02\x7f\x01\x02\x02\xea\x05\xb9\0\x7f\x01\xc7\x02\x9d\x01\x9d\x01u\x05\x9d\x01\x9d\x01\xb9\0\xf5\x01\x90\x02\xd2\x01\xca\x01\xf6\x01\x7f\x01\x1b\x05\x90\x02\xda\x04\xcc\x01\x9f\x04\xf7\x01H\x03\x1f\x03\xc8\x04\xe4\x02\x9d\x01\xfb\x01\x8e\x01\xb9\0\xc7\x02\xd6\0\x93\0\x84\x05\xc6\0\x85\x05\x90\x02\x90\x026\0\xfa\x01\xb9\0t\x03v\x03\xd9\0\x8c\x05\xca\x01\x90\x05\x91\x05I\x03\xcb\x05\x95\x05\xe4\x04o\x01 \0\x88\x02\x9b\x05\x89\x02\xa0\x04\xbd\0\x8f\x01;\x05\xb9\0\x7f\x01\xe4\x04\x0e\0\xd8\x01\x8a\x02u\x03\x90\x01\xca\x01\x9f\x02\xe4\x02\xfe\x01\xb9\0\xf8\x01\xb4\x02\xa4\x05w\x03\x02\x02\x0f\0\x10\0\x7f\x01\x7f\x01W\x02\x7f\x01\x7f\x01\xca\x01X\x04\x9f\x02\xe3\x04\x02\x02\xae\x05\x17\0\xf8\x01\x91\x01\xca\x01\xf1\0X\x02S\x05\xa3\x02\xf8\x01\xf8\x01\xb0\0\x7f\x01\x92\x01{\x02<\x05\xca\x01\xc7\x01\xe0\x02{\x026\0!\0K\x05\x9f\x02S\x01\xbd\x05\xa9\x05d\x05\xb9\0%\0\xf8\x01\xf8\x01\xe4\x04\xe0\x02\xe0\x02)\0\xba\x01\xc7\x01\xc5\x05m\x05\xca\x05=\x05-\0\x94\x01\xf8\x01\xa3\x02\xe0\x02\xa4\x02L\x05\xbb\x01\xaa\x05\xf8\x01\xf8\x01\xff\x01\xf8\x01\x02\x02\x02\x02\x84\x01\x82\0z\0\t\x02\x84\x01\x0b\x02\xda\x04y\x05\xd6\x05\xe0\x02S\x04\x84\x01\xe0\x025\0\x84\x01\xdb\x05\xdc\x05\xe0\x023\0\x97\0\xb9\0\xe3\0\xca\x01\xe0\x02\x13\x02\xca\x01\x97\0\xa4\x02\x97\0\xdf\x05\xe0\x02\xca\x01\x02\x02T\x04\x97\0W\0\x1e\x02 \0\xba\0\xf8\x01\x90\0S\x01\xc6\x01U\x043\0\xe2\x02\xe0\x02\xe0\x02\xb3\0\x97\0\x97\0\xca\x01\xec\x05\x81\x04\x02\x02\xb0\0\xe2\x02V\x04\xe0\x02\xca\x01(\x02W\0\xca\x01\x84\x01\x1d\0-\x02\x90\0\xca\x01\x02\x02\x8e\x04\xca\x01\xca\x01V\x02\xe2\x02\xb3\0r\x02r\x02*\x02W\x02/\x02\x11\x04\x1c\x04.\x02\xe8\x02\x84\x04\xe9\x02\xc2\0W\x026\0\xb0\0\xb0\0\xb0\0X\x02r\x02\xd8\x01\xea\x02\xf5\x01\xb0\0\x87\x01\x9f\x02\xf6\x01X\x02\xb8\x05B\x02\xbb\x05\xc2\0C\x02\xf7\x011\x02\x8a\x01\xf8\x01\x97\0\xc2\0\x97\0\xc1\x054\x02\x96\x05\x9f\x02\x97\0\\\x03\xb0\0\xb0\0\x9f\x02\xfb\x01\xa0\0\xb0\0\x9f\x02\xb0\0\x9f\x02<\x02\x9f\x02\x9f\x02\x9f\x02\xc2\0\xc2\0\xd9\0J\x02\xb8\x05\xb8\x05\xa3\x046\0}\x04>\x02\xa0\0\xd5\x05:\x02\x9f\x02\xc2\0B\x01\xa4\x04\xa0\0Q\x02\x97\0\xb0\0\xc2\0\xc2\0w\x02\xc2\x006\0\xb9\0\xb0\0\xdd\x05\x1e\x02C\x01D\x01\x97\0\x97\0o\x01\xe0\x05\xa3\x02p\x03\xa0\0\xa0\0\xb9\0\xb8\x05\x94\x01\xd9\0\x9f\x02\xe5\x05\xa3\x02\xb0\0 \x01\x84\x02\xe8\x05\xe9\x05\xa0\0\x85\x01\x13\x03!\x01\x98\x02\x85\x01\xba\0\xa0\0\xa0\0\"\x03\xa0\0\x8e\x02\x85\x01$\x03\xc2\0\x85\x01\xe3\0\x14\x03\x15\x03\xf1\0\xf1\0\xf1\0\xf1\0\xf2\x03\x85\x01\x06\x03\x07\x03\xf1\0\xf1\0\xf1\0\x9e\x02\xb6\x01\xf1\0\xf1\0\xa4\x02\xf1\0\xf1\0\xf1\0\xf1\0\xf1\0\xf1\0x\x01\xb0\0\xf1\0\xf1\0\xf1\0\xf1\0\xf1\0\xf1\0$\x02\xb9\0P\x01\xa0\0\x98\x01\xa5\x02\xf1\0\xf1\0\x06\x03\t\x03\xf1\0\xf1\0\xf1\0\xf1\0\xb6\x02\x85\x01\xb7\x02\xf1\0\xf1\0C\x01\x99\x01$\x02\xb9\0\x9f\0\x94\x01\xb9\0P\x01\xc0\0\xba\x02\x97\0\xbb\x02\xf1\0\xf1\0\xbc\x02\xf1\0\b\x03\n\x03\xf1\0\xf1\0\xf1\0\xc3\x02\xf1\0\x9f\0\xc4\x02\xf1\0\xf1\0\xc0\0\xc5\x02\x97\0\x9f\0\x93\0\x97\0\xf1\0\xc0\0\xf1\0\xc9\x02\xce\x02\xcf\x02\x97\0\xb5\0\x97\0\x97\0\xd2\x02\xf1\0\xf1\0\xd3\x02\xf1\0\xf1\0\xf1\0\xf1\0\x9f\0\x9f\0\xb0\0\xd6\x02\xc0\0\xf1\0\xb0\0\xf1\0\xb5\0?\x02\xf1\0\xf2\x02\x97\0\xf1\0\x9f\0\xb5\0\x1d\0\xf1\0\xc0\0\x1d\0 \0\x9f\0\x9f\0e\x02\x9f\0\xc0\0\xc0\0\x12\x03\xc0\0\x1d\0\x1d\x001\x033\x032\x036\x03>\x03\xb5\0\xb0\0\x97\0=\x03?\x03A\x03\x1d\0\x1d\0\x1d\0\x1d\0L\x03T\x03c\x01e\x03\xb5\0f\x03\x05\x02n\x03\xb0\0s\x03\x1d\0\x1d\0\xb5\0o\x03\xb5\0\x8a\x01\xb0\0|\x03\xb0\0\x8a\x01\x9f\0\x84\x03\x86\x03\x8a\x01\xc0\0\x8a\x01\x8a\x03\x95\x03\xd9\0\x8a\x01\x8a\x01\x1d\0\x94\x01\x8a\x01\x1d\0z\x01\x1d\0\x1d\0\x1d\0\x1d\0\x97\x03\x96\x03\x8a\x01\xce\x01\xa1\x03\x1d\0`\x02a\x02b\x02c\x02\xf7\x01\xd5\x01\x1d\0\xab\x03\xb0\x03\xb4\x03\xb5\0\xa7\0d\x02\xb7\x03\xbe\x03\xbf\x03;\x01\xc4\x03\x1d\0\xe6\0\x1d\0\x9e\x01\x1d\0\x1d\0\x94\x01\x06\x03\xcf\x03\xd1\x03\x93\0\xda\x03\xf8\x03\xf6\x03\n\x04\xa7\x02\x1d\0\x0e\x04\x8a\x01\x1d\0\x0f\x04\xa7\x01\x17\x04\x1d\0\xfb\x03\x8a\x01\x1a\x04\x1f\x04\xae\x01\x93\0\x86\x02\xd9\0#\x04$\x04\xa8\x02\x97\0\x93\0\xb0\0\xb0\0e\x02'\x04\n\0\x97\x003\x04\x8a\x01\x8a\x017\x04\x8a\x01\x8a\x01\xc7\x02\xa7\0\xce\0B\x04\x94\x019\x04g\x04\xd9\0\x93\0\x93\0b\x04i\x04l\x04m\x04n\x04\x7f\x04\x94\x01\x8a\x01|\x04x\x01\x9c\x04\x9e\x04\x93\0x\x01\x94\x01\xa6\x04\xae\x04x\x01\x97\0x\x01\x93\0\x97\0\x93\0x\x01x\x01\xa9\x04\xaf\x04\xb0\x04\xb3\x04\xa9\x02^\0\x97\0\xb1\x04\xbe\x04\xaa\x02\xc6\x04x\x016\0`\x02a\x02b\x02c\x02\xd2\x04\x97\0\xd4\x04_\0\x10\0\xd8\x04\xd9\x04!\x03d\x02%\x02\xec\x04\xb0\0\xdb\x04\xdc\x04\x0b\x05\xed\x04`\0\xf0\x04\x90\x04\x1a\x05M\x02\xef\x04\x93\0(\x05\xf5\x04K\x04W\x04\x02\x05\xb0\0\x04\x05\x97\0\x97\0)\x05\x1c\x05x\x01\xaf\0!\0?\x053\x05@\x05N\x05x\x01r\x05\xbf\0%\0V\x05l\x05\xb0\0~\x05\x94\x01a\0\xd8\0\x8d\x05e\x02\x8e\x05Z\x05\xdc\0-\0\x94\x05\x9c\x05x\x01x\x01\xbf\0x\x01x\x01 \0\x97\0\xb0\0 \0\xbf\0\xb1\x05\xd9\0\x97\0b\0\x97\0\xb4\x05\xb5\x05\xb6\x05 \0 \0\xbc\x05\xc0\x05x\x01\xb0\0\xbe\x05c\0\x97\0\x0e\x05d\0\xc9\x05\xbf\0 \0 \0 \0 \0\x01\0\x02\0\x03\0\x04\0\x05\0\x06\0\x07\0\xc8\x05\xcd\x05\xbf\0 \0 \0\xd3\x05\xd7\x05\xda\x05\xb0\0\xbf\0\xbf\0\xde\x05\xbf\0Z\x01\xe3\x05\x9c\x01\xe4\x05K\x04\xe6\x053\0W\0\x9f\x02\b\0\xe0\x02 \x003\0\xe4\x02 \0\"\x02\x94\x01_\x02 \0 \0~\0\xea\x02\xa3\x02\xc7\x01\xa4\x02 \0\xeb\x02\xd5\x01\x97\0a\x01b\x01c\x01 \0\xd8\0.\x02\xd5\x01\x97\0\x94\x02\x94\x02L\x01\xd5\x01\xbf\0\x96\x02\x95\x02 \0\x95\x02 \0\xcd\x04 \0 \0\x97\0\xdc\x01\x97\0\xd5\x01\x97\0\xd5\x01\xd5\x01e\x01f\x01\xc7\x01 \0\x97\x02\x9a\x02 \0\xb0\0\x97\0W\x04 \0\xd5\x01\x9b\x02h\x01i\x01j\x01k\x01\x9c\x02\xaf\0\xaf\0\xd9\x01\xaf\0\xaf\0\x98\x02\xaf\0\x9b\x02\x86\x02\xb0\0\x97\0\xa8\x01m\x01\xd5\x01\x97\0\xb5\x04\xaf\0\xaf\0F\x05\xd5\x01\xd5\x01\xd5\x01\xe5\x04\x86\x02\x86\x02\xe2\x04\x96\x02\xd5\x01\xa7\x05\x93\x05}\x05\xae\x02k\x04\xc9\x03\xd5\x01\x89\0\x86\x02\x8a\0\x8b\0 \0W\x04\x8c\0V\x03\xac\x02\xb1\x01\x8e\0\xaf\0\xaf\0\x92\x02\xe4\x02\xd5\x01\xd8\0\x97\0\x97\0W\x03q\x04\x86\x025\x03\xa5\x03\x86\x02\xe0\x01\xe6\x04\xd5\x01\x9b\x01\x86\x02\xd5\x01\f\x04\xd8\x05/\x05\xb9\x04\x86\x02\x91\0k\x05\xcc\x02\x97\0\0\0\xa8\0\x86\x02\x92\x004\x05\xcd\x04\xb2\0\x94\x03\0\0\0\0\xc2\0M\x02\0\0\0\0M\x02\x93\0\x94\0\0\0\x86\x02\x86\x02\0\0K\x04\x97\0\0\0M\x02\0\0\0\0\xc2\0M\x02\0\0\x86\x02\xb0\0\0\0}\x02\x97\0\0\0\0\0M\x02M\x02M\x02M\x02\x97\0\0\0\x97\0\0\0\0\0\0\0\xc2\0W\x04\0\0K\x04\x97\0M\x02\xb0\0\0\0\0\0\0\0\0\0W\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb0\0\xd8\0M\x02\0\0\0\0M\x02\0\0}\x02M\x02M\x02M\x02\x97\0\xc2\0\0\0\xc2\0\xc2\0M\x02\0\0\xc7\x01\0\0\0\0T\x02\0\0M\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x97\0\0\0\0\0\0\0M\x02\0\0M\x02\x9c\x01M\x02M\x02\0\0\x9c\x01\x97\0\0\0\xb0\0\x9c\x01\0\0\x9c\x01\0\0F\x03M\x02\x9c\x01\xe0\x02M\x02K\x03\x9c\x01\x97\0M\x02\x97\0\xaf\0\0\0\0\0\0\0\0\0\x9c\x01\0\0\0\0\x97\0\0\0\0\0\0\0\xe0\x02\xd9\x01\0\0\x03\x01\0\0\0\0\0\0\xe0\x02K\x04\x97\0\0\0\0\0\0\0\0\0W\x04\0\0\0\0\0\0K\x04\xb2\0\xd6\x01\0\0\xb2\0\xb2\0\0\0\xb2\0]\x03\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\xb0\0\0\0\xb2\0\xb2\0\0\0\0\0\0\0\x9c\x01\xab\x02\xe0\x02\0\0\0\0\xc2\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\x9c\x01\x9c\x01\x81\x03\x9c\x01\x9c\x01\0\0\xb2\0\xd6\x01\0\0\0\0\0\0\0\0K\x04\0\0\x97\0\xcd\x04\xc2\0\0\0\0\0\0\0\0\0\0\0\x9c\x01\0\0\0\0\0\0\xc7\x01\0\0\0\0\0\0\xaf\0\0\0\x97\0\0\0\x97\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x97\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa8\0\0\0\0\0\xa8\0\0\0\0\0\0\0K\x04\xaf\0\xaf\0\xaf\0\x97\0\x97\0\xa8\0\0\0\0\0\xaf\0\0\0\x97\0\xbe\0\0\0\0\0\x97\0\xd9\x01\0\0\0\0\xa8\0\xa8\0\xa8\0\xa8\0\0\0\xaf\0\0\0\0\0\xe0\x02\x97\0\xc2\0\xc1\x03\xbe\0\xaf\0\xaf\0\xa8\0\x97\0\0\0\xaf\0\xbe\0\xaf\0\0\0\x97\0\0\0\0\0\0\0\x97\0\0\0\xd8\0\0\0\xc2\0\x97\0\x97\0\xd9\x01\0\0\xa8\0\0\0\xd9\x01\0\0\0\0\xbe\0\0\0\xa8\0\xa8\0\0\0\0\0\xaf\0{\x01\0\0\xa8\0\0\0\0\0\0\0\xaf\0\xbe\0\n\0\xa8\0\xb0\x01\0\0\0\0\0\0\xbe\0\xbe\0\0\0\xbe\0\0\0\0\0\xde\x03\0\0\xd8\0\xa8\0\0\0\xa8\0\xaf\0\0\0\0\0\0\0\0\0\xe4\x03\0\0\xe6\x03\0\0\0\0\xb2\0\xa8\0\0\0\0\0\xa8\0\xdc\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc2\0\xc2\0\0\0\0\0\xc2\0\0\0\xc2\0\0\0\x89\0\xbe\0\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\0\0\xb1\x01\x8e\0\0\0\r\x04\x03\x01\0\0\xaf\0\x03\x01\0\0\0\0\0\0\0\0\x03\x01\0\0\x03\x01\0\0\0\0\x03\x01\x03\x01\0\0\x03\x01\x03\x01\x03\x01\x03\x01\x03\x01\x03\x01!\x04\x91\0\x03\x01\x03\x01\x03\x01%\x04\x03\x01\x03\x01\x92\0\0\0\0\0\0\0~\x03\0\0\0\0\x03\x01\0\0\0\0\x03\x01\x03\x01\x93\0\x94\0\0\0\0\0\0\0\x03\x01\x03\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd5\x01\0\0\0\0\x03\x01\0\0\0\0\x03\x01\0\0\xb2\0\0\0\x03\x01\x03\x01\0\0\x03\x01\0\0\0\0\x03\x01\x03\x01\0\0\0\0\0\0\0\0\0\0\xaf\0\x03\x01\\\x04\xd9\x01\xaf\0\0\0\0\0a\x04\0\0\0\0\0\0\0\0\x03\x01\x03\x01\0\0\x03\x01\x03\x01\x03\x01\x03\x01\xb2\0\xb2\0\xb2\0\0\0\0\0\x03\x01\0\0\x03\x01\xb2\0\0\0\x03\x01\0\0\0\0\x03\x01\0\0\0\0\xaf\0\x03\x01\0\0\0\0\0\0\0\0\0\0\xfa\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd6\x01\xb2\0\xaf\0\0\0\x8d\x04\xd6\x01\0\0\xb2\0\0\0\0\0\xaf\0\0\0\xaf\0\0\0\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\xd8\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0M\x02\xb2\0\0\0\xe0\x02\0\0\0\0\0\0\0\0\xb2\0\xe0\x02\xe0\x02\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\xdd\x03\0\0\xba\x04{\x01\0\0\xe0\x02\0\0{\x01\xbd\x04\xb2\0\0\0{\x01\xe0\x02{\x01\0\0\0\0\0\0{\x01\0\0\0\0\0\0{\x01\0\0\0\0\xc2\0\xe0\x02\xe0\x02\0\0\xe0\x02\0\0{\x01\0\0\0\0\xe0\x02\xe0\x02\0\0\xe0\x02\0\0\xd8\0\xe0\x02\0\0\0\0\0\0\0\0\xaf\0\xaf\0\xe0\x02\0\0\0\0\0\0\xb3\0\0\0\0\0\0\0\xc3\0\0\0\xd6\x01\0\0\xe0\x02\0\0\0\0\0\0\xe0\x02\xd8\0\0\0\0\0\x1b\x04\0\0\0\0\xe7\x04{\x01\xc3\0\0\0\0\0\xe0\x02\0\0\0\0{\x01\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc3\0\0\0\0\0\0\0\0\0{\x01{\x01\0\0{\x01{\x01\xc7\x01\0\0\xfb\x04\0\0\xfd\x04\0\0\x01\x05\0\0\0\0\x06\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0{\x01\xaf\0\0\0\0\0\0\0\0\0\0\0\x0f\x05\xc3\0\0\0\xc3\0\xc3\0\0\0\0\0\xd5\x01\0\0\xc7\x01\xb2\0\xaf\0\0\0\0\0\xb2\0\0\0\0\0\x1e\x05\x1f\x05\0\0\xd5\x01\0\0E\x04$\x05\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\xaf\0F\x04G\x04\xd5\x01\0\0\xd5\x01\xd5\x01\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\xd6\x01H\x04\0\0\xd5\x01I\x04\xaf\x006\x05\0\0\0\0\xd8\0\xb2\x01\0\0J\x04\x91\0\0\0\0\0\0\0\xb2\0\0\0\0\0\x92\0\xaf\0\0\0\xd5\x01\0\0\xb2\0\0\0\xd6\x01\0\0\xd5\x01\xd5\x01\xd5\x01\x93\0\x94\0\0\0\xb3\0\xd7\x01\xd5\x01\xb3\0\xb3\0\0\0\xb3\0\0\0\0\0\xd5\x01\xb5\0\0\0\0\0\xaf\0\0\0\0\0\xb3\0\xb3\0\0\0\xcf\0\0\0\0\0\0\0\0\0\0\0\xd5\x01\xc3\0\0\0\xd9\x01\0\0\0\0\0\0M\x02\0\0\0\0M\x02\0\0\xd5\x01\0\0i\x05\xd5\x01\0\0\0\0\0\0\0\0M\x02\xb3\0\xd7\x01\0\0M\x02\xd9\x01\0\0\0\0p\x05~\x02\0\0\xc3\0\0\0M\x02M\x02M\x02M\x02\x8a\x02\0\0\0\0\0\0\0\0v\x05\0\0\0\0x\x05\0\0\0\0M\x02\0\0\xb2\0\xd6\x01\0\0\0\0\0\0\0\x009\x03\xaf\0\0\0\xc7\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0M\x02\0\0\0\0M\x02\0\0~\x02M\x02M\x02M\x02\xaf\0\x9c\x01\0\0\0\0\x8f\x05M\x02\0\0\0\0\0\0\0\0\0\0\0\0M\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf2\x01M\x02\0\0M\x02\0\0M\x02M\x02\xc3\0\xc7\x01\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0M\x02\x8c\0\x97\x01M\x02\x8d\0\x8e\0\0\0M\x02\xb2\0\0\0\xc3\0\xb0\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8f\0\xb5\0\xb5\0\xd6\x01\xb5\0\xb5\0\0\0\xb5\0\x90\0\x90\x03\0\0\0\0\0\0\0\0\0\0\0\0\x92\0\xb5\0\xb5\0\0\0\0\0\0\0\xb2\0\0\0\xc6\x05\xc7\x05\0\0\x05\x04\x93\0\x94\0\xb4\0\0\0\xce\x059\x03\0\0\xaf\0\0\0\0\0\0\0\0\0\0\0\xb3\0\xb2\0\0\0\0\0\0\0\0\0\xb5\0\xb5\0\x0e\0\0\0\0\0\xc7\x01\xe2\x02\0\0\xc3\0\xc3\0\xaf\0\xb2\0\xc3\0\0\0\xc3\0\xc7\x01\0\0\x0f\0\x10\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xaf\0\0\0\0\0\x17\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe7\x05\0\0\xd6\x01\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\xe2\x02\x8c\0\0\0!\0\x8d\0\x8e\0S\x01\0\0\xf1\x01\0\0\0\0%\0\xb2\x01\0\0\0\0\0\0\0\0)\0\0\0\xb2\x01\xe2\x02\xb2\x01\x8f\0\xe2\x02-\0\xaf\0\0\0\xe2\x02\xe2\x02\0\0\x90\0\x91\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\x92\0\0\x001\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\xb3\0\0\0\x93\0\x94\x005\0\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\xd6\x01\0\0\0\0\0\0\0\0\0\0\xc7\x01\xc2\0\xc7\x01\xe2\x02\0\0\0\0\xe2\x02\x8a\x02\0\0\0\0\0\0\0\0\0\0\0\0\xd6\x01\0\0\xb3\0\xb3\0\xb3\0\xaf\0\0\0f\x02\x8a\x02\x8a\x02\xb3\0\xb4\0\xb4\0\0\0\xb4\0\xb4\0\0\0\xb4\0\0\0\0\0\xaf\0\x8a\x02\0\0\0\0\0\0\0\0\0\0\xb4\0\xb4\0\0\0\0\0k\0\x80\x02\xd7\x01\xb3\0\0\0\0\0\0\0\xd7\x01\0\0\xb3\0\x8a\x02\n\0\xf2\x01\x8a\x02\0\0\xf2\x01\0\0\0\0\x8a\x02\0\0\0\0\0\0\0\0\0\0\x8a\x02\xf2\x01\xb4\0\xb4\0\0\0\0\0\0\0\x8a\x02\0\0\0\0\0\0\xb3\0\0\0\0\0\xf2\x01\xf2\x01\xf2\x01\xf2\x01\xb3\0\0\0\0\0\xaf\0\0\0\x8a\x02\x8a\x02\0\0\0\0\0\0\0\0\xf2\x01\0\0\0\0\0\0\0\0\0\0\x8a\x02\0\0\x89\0\xb3\0\x8a\0\x8b\0 \0\xb2\0\x8c\0\0\0\0\0\xb1\x01\x8e\0\0\0\xf2\x01\0\0\0\0\xf2\x01\xc3\0\x97\x01\xf2\x01\xf2\x01\xf2\x01\0\0\0\0\0\0\0\0\0\0\xf2\x01\xd6\x01\0\0Z\x01\0\0\0\0\0\0\xf2\x01\xc2\0\0\0\x91\0\0\0\0\0\0\0\0\0\xb5\0\0\0\x92\0\xd6\x01\xf2\x01\0\0\xf2\x01\xd7\x01\xf2\x01\xf2\x01\0\0\0\0\0\0\0\0\x93\0\x94\0`\x01a\x01b\x01c\x01\xf2\x01\0\0\0\0\xf2\x01\0\0\x97\x01\0\0\xf2\x01\0\0\0\0\0\0\0\0\0\0\xdc\x02\xb5\0\xb5\0\xb5\0\xc8\x02\0\0\0\0\xb9\0\0\0\xb5\0\0\0;\x03e\x01f\x01\0\0\xd6\x01\0\0\0\0\xf1\x01\0\0\0\0\xf1\x01\0\0\0\0\0\0h\x01i\x01j\x01k\x01\xb2\x01\xe0\x02\xf1\x01\xb5\0\xb5\0\0\0\0\0\0\0\xb5\0\0\0\xb5\0\0\0\0\0m\x01\0\0\xf1\x01\xf1\x01\xf1\x01\xf1\x01\0\0\0\0\xb4\0f\x02\0\0\xb3\0\0\0\0\0\0\0\xb3\0\0\0\xf1\x01\0\0\0\0\0\0\0\0\0\0\xb5\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\x80\x02\x8c\0\0\0\xd6\x01\x8d\0\x8e\0\0\0\xf1\x01\0\0\0\0\xf1\x01\0\0\0\0\xf1\x01\xf1\x01\xf1\x01\xd7\x01\0\0\xa1\x05\0\0\xb5\0\xf1\x01\x8f\0\0\0\0\0\xef\x01\0\0\0\0\xf1\x01\0\0\x90\0\x91\0\0\0\xb3\0\0\0\0\0\0\0\0\0\x92\0\0\0\xf1\x01\xb3\0\xf1\x01\xd7\x01\xf1\x01\xf1\x01\0\0\xa1\x02\0\0k\0\x93\0\x94\0\0\0\0\0\0\0\0\0\xf1\x01\0\0\0\0\xf1\x01\x97\x01\0\0k\0\xf1\x01\0\0\0\0\0\0\xb5\0\0\0\0\0\0\0\0\0\0\0\0\0\xc2\x05k\0\0\0k\0k\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\x02\0\0\xa1\x02\xa1\x02\xa1\x02\\\0\xa1\x02\0\0\0\0\xa1\x02\xa1\x02\0\0\0\0k\0\0\0\0\0\xb4\0\xb4\0\xb4\0\0\0k\0k\0\0\0\0\0\xb4\0\xb4\0\0\0k\0\0\0\xb3\0\xd7\x01\0\0\0\0\0\0k\0\0\0\xa1\x02\0\0\0\0\0\0\xae\x03\0\0\0\0\xa1\x02\0\0\0\0\x97\x01\xb4\0\xb4\0\xb5\0k\0\0\0\xb4\0\xb5\0\xb4\0\xa1\x02\xa1\x02\0\0\0\0\0\0\0\0\0\0k\0\0\0\0\0k\0\0\0\0\0\0\0\xb2\x01\0\0\0\0\0\0\0\0,\x04\0\0\0\0\xe7\0\xe7\0\0\0\xb4\0\0\0\0\0\0\0\xb5\0\0\0\0\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\xb5\0\x8c\0\0\0\xb3\0\x8d\0\x8e\0\xb4\0\0\0\xb5\0\0\0\xb5\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\0\0\xe0\x02\xd7\x01\0\0\x8f\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\x90\0\x91\0\0\0\x8a\x01\x8b\x01\0\0\0\0\0\0\x92\0\xb3\0\0\0\0\0\xe0\x02\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\x93\0\x94\0\0\0\xb4\0\0\0\0\0\0\0\xe0\x02\0\0\xb3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x97\x01\0\0\0\0\0\0\0\0\0\0\xb3\0\xfd\x01\xe0\x02\0\0\0\0\0\0\0\0\0\0\xef\x01\0\0\xe0\x02\xef\x01\0\0\0\0\0\0\0\0\xe0\x02\0\0\xb5\0\xb5\0\0\0\xef\x01\x97\x01\xe0\x02\0\0\0\0\0\0\xd7\x01\0\0\0\0\0\0\0\0\x97\x01\0\0\xef\x01\xef\x01\xef\x01\xef\x01\0\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xef\x01\0\0\xe0\x02\0\0\0\0\xe0\x02\0\0f\x02\xb4\0\xc2\x04\0\0\0\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xef\x01\0\0\0\0\xef\x01\0\0\0\0\xef\x01\xef\x01\xef\x01\0\0\x97\x01\0\0\0\0\xb2\x01\xef\x01\n\0\\\0\xb0\x01\0\0\0\0\0\0\xef\x01\x97\x01\xb4\0\xb5\0\0\0\0\0\xd7\x01\0\0\\\0\x97\x01\0\0\0\0\xef\x01\xc3\0\xef\x01\0\0\xef\x01\xef\x01\0\0\xb4\0\xb5\0\\\0\0\0\\\0\\\0\0\0\xd7\x01\xb4\0\xef\x01\xb4\0\0\0\xef\x01\0\0\0\0\0\0\xef\x01\\\0\0\0\0\0\xb5\0\0\0\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\x97\x01\x8c\0\0\0\0\0\x8d\0\x8e\0\0\0\\\0\0\0\0\0\xb5\0\0\0\0\0Q\x04\0\0\\\0\0\0\0\0\0\0\0\0\0\0\\\0\x8f\0\0\0\0\0\0\0\xb5\0\0\0\\\0\0\0\x90\0\x91\0\x06\x01\0\0\0\0\0\0\0\0\x97\x01\x92\0\0\0\x97\x01\x97\x01\0\0\0\0\\\0\0\0\0\0\0\0\0\0\0\0\x93\0\x94\0\0\0\xb5\0\0\0\0\0\\\0\0\0\0\0\\\0\0\0\0\0\0\0\xb4\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb3\0g\x02h\x02i\x02j\x02k\x02l\x02m\x02n\x02o\x02p\x02q\x02r\x02s\x02t\x02u\x02v\x02w\x02x\x02y\x02z\x02{\x02\xd7\x01}\x02\0\0\0\0\0\0\0\0\0\0\xc3\0\0\0\0\0\0\0Q\x04\0\0\0\0\0\0\x87\x02\0\0\xd7\x01\0\0\0\0\0\0\0\0\xfd\x01\x97\x01\xfd\x01\xfd\x01\xb5\0\x94\x02\0\0\0\0\xfd\x01\0\0\0\0\0\0\0\0\xfd\x01\0\0\0\0\0\0\xfd\x01\xfd\x01\xfd\x01\xb4\0\0\0\0\0\0\0\xb5\0\0\0\xfd\x01\xfd\x01\xfd\x01\xfd\x01\0\0\0\0\xcf\x04\0\0\0\0\0\0\xfd\x01\xb4\0\0\0\0\0\xd7\x01\xfd\x01\0\0\0\0\0\0\0\0\0\0\xfd\x01\xfd\x01\0\0\0\0\0\0\0\0\r\x01\0\0\0\0\xb4\0\0\0\0\0\0\0\0\0\xfd\x01\0\0\0\0\xfd\x01\0\0\0\0\xfd\x01\xfd\x01\xfd\x01\0\0\xfd\x01\0\0\0\0\0\0\xfd\x01\xb4\0\0\0\0\0\0\0\0\0\0\0\xfd\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb4\0\xfd\x01\xfd\x01\0\0\xfd\x01\xfd\x01\xfd\x01\xfd\x01\xd7\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfd\x01\0\0\0\0\xfd\x01\0\0\0\0\0\0\xfd\x01\0\0\xb4\0\0\0\xb5\0\0\0\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\x97\x01\x8c\0\0\0\0\0\x8d\0\x8e\0\0\0\0\0\0\0\xcf\x04\0\0\0\0\xb5\0\0\0%\x05&\x05\0\0\0\0\0\0\0\0\0\0\0\0\x8f\0\0\0\0\0Q\x04\0\0\0\0\x19\x03\xb5\0\x90\0\x91\0\0\0\0\0\0\0\0\0\0\0#\x03\x92\0\x06\x01\0\0%\x03\x06\x01\0\0)\x03\0\0\0\0\x06\x01\0\0\x06\x01\x93\0\x94\0\x06\x01\x06\x01Q\x04\0\0\x06\x01\xb4\0\x06\x01\x06\x01\x06\x01\0\0\0\0\x06\x01\x06\x01\x06\x01O\x02\x06\x01\x06\x01\0\0\0\0\0\0\0\0\0\0\xb5\0\0\0\x06\x01\xb4\0\x97\x01\x06\x01\x06\x01\0\0\0\0\0\0\0\0\0\0\x06\x01\x06\x01\0\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\x06\x01\0\0\0\0\x06\x01\0\0\0\0\0\0\x06\x01\x06\x01\0\0\x06\x01\0\0\0\0\x06\x01\x06\x01\0\0\0\0\0\0\0\0\0\0\0\0\x06\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0j\x03\x06\x01\x06\x01\xb5\0\x06\x01\x06\x01\x06\x01\x06\x01\0\0\0\0\0\0\0\0\0\0\x06\x01\0\0\x06\x01\xcf\x04\0\0\x06\x01\0\0\0\0\x06\x01\0\0Q\x04\0\0\x06\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0Q\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x89\0\xb4\0\x8a\0\x8b\0 \0\r\x01\x8c\0\0\0\r\x01\x8d\0\x8e\0\0\0\0\0\r\x01\0\0\r\x01\0\0r\x02\r\x01\r\x01\0\0\0\0\r\x01\xb4\0\r\x01\r\x01\r\x01\x8f\0\0\0\r\x01\r\x01\r\x01\0\0\r\x01\r\x01\x90\0\x90\x03\0\0\0\0\0\0\xb4\0\0\0\r\x01\x92\0Q\x04\r\x01\r\x01\xcf\x04\0\0\0\0\0\0\0\0\r\x01\r\x01\xb1\x03\x93\0\x94\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\r\x01\0\0\0\0\r\x01\0\0\0\0\0\0\r\x01\r\x01\0\0\r\x01\0\0\0\0\r\x01\r\x01\0\0\0\0\0\0\0\0\xb4\0\0\0\r\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0Q\x04\xd0\x03\0\0\r\x01\r\x01\0\0\r\x01\r\x01\r\x01\r\x01\0\0\0\0\0\0\0\0\0\0\r\x01\0\0\r\x01\0\0\0\0\r\x01\0\0\0\0\r\x01\0\0\0\0\0\0\r\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xdf\x03\0\0\0\0\0\0\0\0\0\0\0\0\xe0\0\0\0\0\0\0\0\0\0\0\0\xb4\0\0\0\0\0\0\0O\x02O\x02O\x02O\x02\0\0\0\0O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02\0\0O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02\0\0\0\0\0\0\0\0O\x02O\x02\0\0\x16\x04O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02\0\0O\x02O\x02O\x02O\x02\0\0\0\0O\x02O\x02O\x02:\x02O\x02O\x02O\x02O\x02O\x02O\x02\0\0O\x02O\x02O\x02O\x02O\x02\0\0O\x02O\x02\0\0\0\0\0\0O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02\0\0O\x02\0\0O\x02O\x02\0\0O\x02O\x02O\x02O\x02O\x02\0\0O\x02O\x02\0\0O\x02O\x02O\x02O\x02\x1d\x01O\x02O\x02\0\0O\x02\0\0\0\0\0\0O\x02\0\0\0\0\0\0\0\0\0\0\0\0r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02\0\0z\x04r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02\0\0\0\0\0\0\0\0r\x02r\x02\0\0\0\0r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02r\x02r\x02\0\0\0\0r\x02r\x02r\x02\0\0r\x02r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02\0\0\0\0\0\0r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02\0\0r\x02\0\0r\x02r\x02\0\0r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02<\x01r\x02r\x02r\x02r\x02\0\0r\x02r\x02\0\0r\x02\0\0\0\0\0\0r\x02\0\0\0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\0\xe0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\xf1\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\0\xe0\0\0\0\xe0\0\xf8\x04\0\0\xe0\0\xe0\0\xe0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\xe0\0\xe0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0$\x01\0\0\xe0\0\0\0\0\0\xe0\0\0\0\xe0\0\0\0\0\0\xe0\0\0\0\0\0\xe0\0!\x05\"\x05#\x05\xe0\0\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\0\0\0\0\0\0\x1d\x01\x1d\x01\0\0\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\0\0\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\0\0\0\0\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\0\0\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\"\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\0\0\x1d\x01\0\0\0\0\0\0\x1d\x01\0\0<\x01<\x01<\x01<\x01<\x01\0\0<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01\0\0\0\0<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01\0\0\0\0\0\0\0\0<\x01<\x01\0\0\0\0<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01\0\0<\x01<\x01<\x01<\x01\0\0\0\0<\x01<\x01<\x01\0\0<\x01<\x01<\x01<\x01<\x01<\x01\0\0<\x01<\x01<\x01<\x01<\x01\0\0<\x01<\x01\0\0\0\0\0\0<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01\0\0<\x01\0\0<\x01<\x01\0\0<\x01<\x01<\x01<\x01<\x01 \x01<\x01<\x01\0\0<\x01<\x01<\x01<\x01\0\0<\x01<\x01\0\0<\x01\0\0\0\0\0\0<\x01$\x01$\x01$\x01$\x01\0\0\0\0$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01\0\0$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01\0\0\0\0\0\0\0\0$\x01$\x01\0\0\0\0$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01\0\0$\x01$\x01$\x01$\x01\0\0\0\0$\x01$\x01$\x01\0\0$\x01$\x01$\x01$\x01$\x01$\x01\0\0$\x01$\x01$\x01$\x01$\x01\0\0$\x01$\x01\0\0\0\0\0\0$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01\0\0$\x01\0\0$\x01$\x01\0\0$\x01$\x01$\x01$\x01$\x01E\x01$\x01$\x01\0\0$\x01$\x01$\x01$\x01\0\0$\x01$\x01\0\0$\x01\0\0\0\0\0\0$\x01\0\0\0\0\"\x01\"\x01\"\x01\"\x01\0\0\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\0\0\0\0\0\0\"\x01\"\x01\0\0\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\0\0\0\0\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\0\0\0\0\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\0\0\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\"\x01G\x01\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\0\0\"\x01\0\0\0\0\0\0\"\x01\0\0 \x01 \x01 \x01 \x01\0\0\0\0 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01\0\0 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01\0\0\0\0\0\0\0\0 \x01 \x01\0\0\0\0 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01\0\0 \x01 \x01 \x01 \x01\0\0\0\0 \x01 \x01 \x01\0\0 \x01 \x01 \x01 \x01 \x01 \x01\0\0 \x01 \x01 \x01 \x01 \x01\0\0 \x01 \x01\0\0\0\0\0\0 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01\0\0 \x01\0\0 \x01 \x01\0\0 \x01 \x01 \x01 \x01 \x01J\x01 \x01 \x01\0\0 \x01 \x01 \x01 \x01\0\0 \x01 \x01\0\0 \x01\0\0\0\0\0\0 \x01E\x01E\x01E\x01E\x01E\x01\0\0E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01\0\0\0\0E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01\0\0\0\0\0\0\0\0E\x01E\x01\0\0\0\0E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01\0\0E\x01E\x01E\x01E\x01\0\0\0\0E\x01E\x01E\x01\0\0E\x01E\x01E\x01E\x01E\x01E\x01\0\0E\x01E\x01E\x01E\x01E\x01\0\0E\x01E\x01\0\0\0\0\0\0E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01\0\0E\x01\0\0E\x01E\x01\0\0E\x01E\x01E\x01\0\0\0\0\x15\x01E\x01E\x01\0\0E\x01E\x01E\x01E\x01\0\0E\x01E\x01\0\0E\x01\0\0\0\0\0\0E\x01\0\0\0\0G\x01G\x01G\x01G\x01G\x01\0\0G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01\0\0\0\0G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01\0\0\0\0\0\0\0\0G\x01G\x01\0\0\0\0G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01\0\0G\x01G\x01G\x01G\x01\0\0\0\0G\x01G\x01G\x01\0\0G\x01G\x01G\x01G\x01G\x01G\x01\0\0G\x01G\x01G\x01G\x01G\x01\0\0G\x01G\x01\0\0\0\0\0\0G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01\0\0G\x01\0\0G\x01G\x01\0\0G\x01G\x01G\x01\x16\x01\0\0\0\0G\x01G\x01\0\0G\x01G\x01G\x01G\x01\0\0G\x01G\x01\0\0G\x01\0\0\0\0\0\0G\x01\0\0J\x01J\x01J\x01J\x01J\x01\0\0J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01\0\0\0\0J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01\0\0\0\0\0\0\0\0J\x01J\x01\0\0\0\0J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01\0\0J\x01J\x01J\x01J\x01\0\0\0\0J\x01J\x01J\x01\0\0J\x01J\x01J\x01J\x01J\x01J\x01\0\0J\x01J\x01J\x01J\x01J\x01\0\0J\x01J\x01\0\0\0\0\0\0J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01\0\0J\x01\0\0J\x01J\x01\0\0J\x01J\x01J\x01\xdf\0\0\0\0\0J\x01J\x01\0\0J\x01J\x01J\x01J\x01\0\0J\x01J\x01\0\0J\x01\0\0\0\0\0\0J\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\0\0\0\0\0\0\x15\x01\x15\x01\x15\x01\0\0\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\0\0\0\0\0\0\0\0\0\0\x15\x01\x15\x01\0\0\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\0\0\0\0\x15\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15\x01\x15\x01\0\0\x15\x01\0\0\0\0\x15\x01\x15\x01\x15\x01\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\0\0\0\0\0\0\0\0\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\0\0\x15\x01\0\0\x15\x01\x15\x01\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\xea\0\x15\x01\0\0\0\0\x15\x01\x15\x01\x15\x01\0\0\0\0\x15\x01\0\0\0\0\x15\x01\0\0\0\0\0\0\x15\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0\0\0\0\0\x16\x01\x16\x01\x16\x01\0\0\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0\0\0\0\0\0\0\0\0\x16\x01\x16\x01\0\0\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0\0\0\x16\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x01\x16\x01\0\0\x16\x01\0\0\0\0\x16\x01\x16\x01\x16\x01\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0\0\0\0\0\0\0\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0\x16\x01\0\0\x16\x01\x16\x01\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\xeb\0\x16\x01\0\0\0\0\x16\x01\x16\x01\x16\x01\0\0\0\0\x16\x01\0\0\0\0\x16\x01\0\0\0\0\0\0\x16\x01\0\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\xdf\0\xdf\0\xdf\0\0\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\0\0\0\0\xdf\0\xdf\0\0\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xdf\0\xdf\0\0\0\xdf\0\0\0\0\0\xdf\0\xdf\0\xdf\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\0\0\0\0\xdf\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\xdf\0\xdf\0\0\0\xdf\0\xdf\0\xdf\0\0\0\xec\0\0\0\xdf\0\0\0\0\0\xdf\0\0\0\xdf\0\0\0\0\0\xdf\0\0\0\0\0\xdf\0\0\0\0\0\0\0\xdf\0\0\0\0\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\xea\0\xea\0\xea\0\0\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\xea\0\xea\0\xea\0\0\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\0\0\0\0\xea\0\xea\0\0\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xea\0\xea\0\0\0\xea\0\0\0\0\0\xea\0\xea\0\xea\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\0\0\0\0\xea\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\xea\0\xea\0\0\0\xea\0\xea\0\xea\0\xea\0\x0e\x01\0\0\xea\0\0\0\0\0\xea\0\0\0\xea\0\0\0\0\0\xea\0\0\0\0\0\xea\0\0\0\0\0\0\0\xea\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\xeb\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\0\0\xeb\0\0\0\0\0\xeb\0\xeb\0\xeb\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\0\0\xeb\0\xeb\0\xeb\0\0\0\x0f\x01\0\0\xeb\0\0\0\0\0\xeb\0\0\0\xeb\0\0\0\0\0\xeb\0\0\0\0\0\xeb\0\0\0\0\0\0\0\xeb\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\0\0\0\0\xec\0\xec\0\xec\0\0\0\0\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\0\0\0\0\0\0\0\0\xec\0\xec\0\0\0\0\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xec\0\xec\0\0\0\xec\0\0\0\0\0\xec\0\xec\0\xec\0\0\0\xec\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\0\0\0\0\0\0\0\0\xec\0\0\0\xec\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\0\0\0\0\xec\0\xec\0\0\0\xec\0\xec\0\xec\0\0\0\xf6\0\0\0\xec\0\0\0\0\0\xec\0\0\0\xec\0\0\0\0\0\xec\0\0\0\0\0\xec\0\0\0\0\0\0\0\xec\0\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0e\x01\x0e\x01\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0e\x01\x0e\x01\0\0\x0e\x01\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0e\x01\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\0\0\0\0\x0e\x01\x0e\x01\0\0\x0e\x01\x0e\x01\x0e\x01\xf7\0\0\0\0\0\x0e\x01\0\0\0\0\x0e\x01\0\0\x0e\x01\0\0\0\0\x0e\x01\0\0\0\0\x0e\x01\0\0\0\0\0\0\x0e\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\0\0\0\0\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0f\x01\x0f\x01\0\0\0\0\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0f\x01\x0f\x01\0\0\x0f\x01\0\0\0\0\x0f\x01\x0f\x01\x0f\x01\0\0\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0f\x01\0\0\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\0\0\0\0\x0f\x01\x0f\x01\0\0\x0f\x01\x0f\x01\x0f\x01\xfe\0\0\0\0\0\x0f\x01\0\0\0\0\x0f\x01\0\0\x0f\x01\0\0\0\0\x0f\x01\0\0\0\0\x0f\x01\0\0\0\0\0\0\x0f\x01\xf6\0\xf6\0\xf6\0\xf6\0\0\0\0\0\0\0\0\0\xf6\0\xf6\0\xf6\0\0\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\0\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\0\0\0\0\0\0\0\0\0\0\0\0\xf6\0\xf6\0\0\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\0\0\xf6\0\xf6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf6\0\xf6\0\0\0\xf6\0\0\0\0\0\xf6\0\xf6\0\xf6\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\0\0\0\0\0\0\0\0\0\0\0\0\xf6\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\0\0\0\0\0\0\0\0\xf6\0\xf6\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xfd\0\0\0\xf6\0\0\0\0\0\xf6\0\0\0\xf6\0\0\0\0\0\xf6\0\0\0\0\0\xf6\0\0\0\0\0\0\0\xf6\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\0\0\0\0\0\0\xf7\0\xf7\0\xf7\0\0\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\0\0\0\0\0\0\0\0\0\0\xf7\0\xf7\0\0\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\xf7\0\xf7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf7\0\xf7\0\0\0\xf7\0\0\0\0\0\xf7\0\xf7\0\xf7\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\0\0\0\0\0\0\0\0\0\0\xf7\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\0\0\0\0\0\0\xf7\0\xf7\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xe4\0\0\0\xf7\0\0\0\0\0\xf7\0\0\0\xf7\0\0\0\0\0\xf7\0\0\0\0\0\xf7\0\0\0\0\0\0\0\xf7\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\0\0\0\0\0\0\xfe\0\xfe\0\xfe\0\0\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\0\0\0\0\0\0\0\0\0\0\xfe\0\xfe\0\0\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\xfe\0\xfe\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfe\0\xfe\0\0\0\xfe\0\0\0\0\0\xfe\0\xfe\0\xfe\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\0\0\0\0\0\0\0\0\0\0\xfe\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\0\0\0\0\0\0\xfe\0\xfe\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xe7\0\0\0\xfe\0\0\0\0\0\xfe\0\0\0\xfe\0\0\0\0\0\xfe\0\0\0\0\0\xfe\0\0\0\0\0\0\0\xfe\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\0\0\0\0\0\0\xfd\0\xfd\0\xfd\0\0\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\0\0\0\0\0\0\0\0\0\0\xfd\0\xfd\0\0\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\xfd\0\xfd\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfd\0\xfd\0\0\0\xfd\0\0\0\0\0\xfd\0\xfd\0\xfd\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\0\0\0\0\0\0\0\0\0\0\xfd\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\0\0\0\0\0\0\xfd\0\xfd\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xe8\0\0\0\xfd\0\0\0\0\0\xfd\0\0\0\xfd\0\0\0\0\0\xfd\0\0\0\0\0\xfd\0\0\0\0\0\0\0\xfd\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\0\0\0\0\0\0\xe4\0\xe4\0\0\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\0\xe4\0\0\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\0\xe4\0\0\0\xe4\0\0\0\0\0\xe4\0\xe4\0\xe4\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\0\0\0\0\xe4\0\xe4\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xf5\0\0\0\xe4\0\0\0\0\0\xe4\0\0\0\xe4\0\0\0\0\0\xe4\0\0\0\0\0\xe4\0\0\0\0\0\0\0\xe4\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\0\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\0\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\0\0\xe7\0\0\0\0\0\xe7\0\xe7\0\xe7\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\0\0\xe7\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xfb\0\0\0\xe7\0\0\0\0\0\xe7\0\0\0\xe7\0\0\0\0\0\xe7\0\0\0\0\0\xe7\0\0\0\0\0\0\0\xe7\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\0\0\0\0\0\0\xe8\0\xe8\0\0\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\0\0\0\0\0\0\0\0\xe8\0\xe8\0\0\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe8\0\xe8\0\0\0\xe8\0\0\0\0\0\xe8\0\xe8\0\xe8\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\0\0\0\0\0\0\0\0\xe8\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\0\0\0\0\xe8\0\xe8\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xfc\0\0\0\xe8\0\0\0\0\0\xe8\0\0\0\xe8\0\0\0\0\0\xe8\0\0\0\0\0\xe8\0\0\0\0\0\0\0\xe8\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\0\0\0\0\0\0\0\0\xf5\0\xf5\0\xf5\0\0\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\0\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\0\0\0\0\0\0\0\0\0\0\0\0\xf5\0\xf5\0\0\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\0\0\0\0\xf5\0\xf5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf5\0\xf5\0\0\0\xf5\0\0\0\0\0\xf5\0\xf5\0\xf5\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\0\0\0\0\0\0\0\0\0\0\0\0\xf5\0\0\0\xf5\0\0\0\xf5\0\xf5\0\xf5\0\0\0\0\0\0\0\0\0\xf5\0\xf5\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\xf8\0\0\0\0\0\0\0\0\0\xf5\0\0\0\xf5\0\0\0\0\0\xf5\0\0\0\0\0\xf5\0\0\0\0\0\0\0\xf5\0\xfb\0\xfb\0\xfb\0\xfb\0\0\0\0\0\0\0\0\0\xfb\0\xfb\0\xfb\0\0\0\0\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\0\0\0\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\0\0\0\0\0\0\0\0\0\0\0\0\xfb\0\xfb\0\0\0\0\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\0\0\0\0\xfb\0\xfb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfb\0\xfb\0\0\0\xfb\0\0\0\0\0\xfb\0\xfb\0\xfb\0\0\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\0\0\0\0\0\0\0\0\0\0\0\0\xfb\0\0\0\xfb\0\0\0\xfb\0\xfb\0\xfb\0\0\0\0\0\0\0\0\0\xfb\0\xfb\0\0\0\xfb\0\xfb\0\xfb\0\xfb\0\xf9\0\0\0\0\0\0\0\0\0\xfb\0\0\0\xfb\0\0\0\0\0\xfb\0\0\0\0\0\xfb\0\0\0\0\0\0\0\xfb\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\0\0\0\0\0\0\0\0\xfc\0\xfc\0\xfc\0\0\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\0\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\0\0\0\0\0\0\0\0\0\0\0\0\xfc\0\xfc\0\0\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\0\0\0\0\xfc\0\xfc\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfc\0\xfc\0\0\0\xfc\0\0\0\0\0\xfc\0\xfc\0\xfc\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\0\0\0\0\0\0\0\0\0\0\0\0\xfc\0\0\0\xfc\0\0\0\xfc\0\xfc\0\xfc\0\0\0\0\0\0\0\0\0\xfc\0\xfc\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\xfa\0\0\0\0\0\0\0\0\0\xfc\0\0\0\xfc\0\0\0\0\0\xfc\0\0\0\0\0\xfc\0\0\0\0\0\0\0\xfc\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\0\0\0\0\0\0\0\0\xf8\0\xf8\0\xf8\0\0\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\0\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\0\0\0\0\0\0\0\0\0\0\0\0\xf8\0\xf8\0\0\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\0\0\0\0\xf8\0\xf8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf8\0\xf8\0\0\0\xf8\0\0\0\0\0\xf8\0\xf8\0\xf8\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\0\0\0\0\0\0\0\0\0\0\0\0\xf8\0\0\0\xf8\0\0\0\xf8\0\xf8\0\xf8\0\0\0\0\0\0\0\0\0\xf8\0\xf8\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\xcc\0\0\0\0\0\0\0\0\0\xf8\0\0\0\xf8\0\0\0\0\0\xf8\0\0\0\0\0\xf8\0\0\0\0\0\0\0\xf8\0\xf9\0\xf9\0\xf9\0\xf9\0\0\0\0\0\0\0\0\0\xf9\0\xf9\0\xf9\0\0\0\0\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\0\0\0\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\0\0\0\0\0\0\0\0\0\0\0\0\xf9\0\xf9\0\0\0\0\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\0\0\0\0\xf9\0\xf9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf9\0\xf9\0\0\0\xf9\0\0\0\0\0\xf9\0\xf9\0\xf9\0\0\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\0\0\0\0\0\0\0\0\0\0\0\0\xf9\0\0\0\xf9\0\0\0\xf9\0\xf9\0\xf9\0\0\0\0\0\0\0\0\0\xf9\0\xf9\0\0\0\xf9\0\xf9\0\xf9\0\xf9\0\xff\0\0\0\0\0\0\0\0\0\xf9\0\0\0\xf9\0\0\0\0\0\xf9\0\0\0\0\0\xf9\0\0\0\0\0\0\0\xf9\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\0\0\0\0\0\0\0\0\xfa\0\xfa\0\xfa\0\0\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\0\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\0\0\0\0\0\0\0\0\0\0\0\0\xfa\0\xfa\0\0\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\0\0\0\0\xfa\0\xfa\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfa\0\xfa\0\0\0\xfa\0\0\0\0\0\xfa\0\xfa\0\xfa\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\0\0\0\0\0\0\0\0\0\0\0\0\xfa\0\0\0\xfa\0\0\0\xfa\0\xfa\0\xfa\0\0\0\0\0\0\0\0\0\xfa\0\xfa\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\x01\x01\0\0\0\0\0\0\0\0\xfa\0\0\0\xfa\0\0\0\0\0\xfa\0\0\0\0\0\xfa\0\0\0\0\0\0\0\xfa\0\0\0\xcc\0\xcc\0\xcc\0\xcc\0\0\0\0\0\0\0\0\0\xcc\0\xcc\0\xcc\0\0\0\0\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\0\0\0\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\0\0\0\0\0\0\0\0\0\0\0\0\xcc\0\xcc\0\0\0\0\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcc\0\xcc\0\0\0\0\0\0\0\0\0\xcc\0\xcc\0\xcc\0\0\0\xcc\0\0\0\0\0\xcc\0\xcc\0\0\0\0\0\0\0\0\0\0\0\0\0\xcc\0\0\0\xcc\0\xcc\0\0\0\0\0\xcc\0\0\0\0\0\0\0\0\0\xcc\0\xcc\0\0\0\xcc\0\xcc\0\xcc\0\xcc\0\xf3\0\0\0\xcc\0\0\0\0\0\xcc\0\0\0\xcc\0\0\0\0\0\xcc\0\0\0\0\0\xcc\0\0\0\0\0\0\0\xcc\0\xff\0\xff\0\xff\0\xff\0\0\0\0\0\0\0\0\0\xff\0\xff\0\xff\0\0\0\0\0\xff\0\xff\0\0\0\xff\0\xff\0\xff\0\xff\0\xff\0\xff\0\0\0\0\0\xff\0\xff\0\xff\0\xff\0\xff\0\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\0\xff\0\0\0\0\0\xff\0\xff\0\xff\0\0\0\0\0\0\0\0\0\xff\0\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\0\xff\0\0\0\xff\0\0\0\0\0\0\0\xff\0\xff\0\0\0\xff\0\0\0\0\0\xff\0\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\0\0\0\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\0\xff\0\0\0\xff\0\xff\0\xff\0\xff\0\xf4\0\0\0\0\0\0\0\0\0\xff\0\0\0\xff\0\0\0\0\0\xff\0\0\0\0\0\xff\0\0\0\0\0\0\0\xff\0\0\0\x01\x01\x01\x01\x01\x01\x01\x01\0\0\0\0\0\0\0\0\x01\x01\x01\x01\x01\x01\0\0\0\0\x01\x01\x01\x01\0\0\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\0\0\0\0\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\x01\x01\x01\x01\0\0\0\0\x01\x01\x01\x01\x01\x01\0\0\0\0\0\0\0\0\x01\x01\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\x01\x01\x01\0\0\x01\x01\0\0\0\0\0\0\x01\x01\x01\x01\0\0\x01\x01\0\0\0\0\x01\x01\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\x01\x01\0\0\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\x01\x01\x01\0\0\x01\x01\x01\x01\x01\x01\x01\x01\0\x01\0\0\0\0\0\0\0\0\x01\x01\0\0\x01\x01\0\0\0\0\x01\x01\0\0\0\0\x01\x01\0\0\0\0\0\0\x01\x01\0\0\xf3\0\xf3\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\xf3\0\xf3\0\xf3\0\0\0\0\0\xf3\0\xf3\0\0\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\0\0\0\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\0\0\0\0\xf3\0\xf3\0\0\0\0\0\xf3\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf3\0\xf3\0\0\0\xf3\0\0\0\0\0\0\0\xf3\0\xf3\0\0\0\xf3\0\0\0\0\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\0\0\0\0\xf3\0\0\0\xf3\0\0\0\0\0\x05\x01\0\0\0\0\0\0\0\0\0\0\xf3\0\xf3\0\0\0\xf3\0\xf3\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\0\0\xf3\0\0\0\xf3\0\0\0\0\0\xf3\0\0\0\0\0\xf3\0\0\0\0\0\0\0\xf3\0\xf4\0\xf4\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\xf4\0\xf4\0\xf4\0\0\0\0\0\xf4\0\xf4\0\0\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\0\0\0\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\0\0\0\0\xf4\0\xf4\0\0\0\0\0\xf4\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf4\0\xf4\0\0\0\xf4\0\0\0\0\0\0\0\xf4\0\xf4\0\0\0\xf4\0\0\0\0\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\x04\x01\0\0\xf4\0\0\0\xf4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf4\0\xf4\0\0\0\xf4\0\xf4\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\0\0\xf4\0\0\0\xf4\0\0\0\0\0\xf4\0\0\0\0\0\xf4\0\0\0\0\0\0\0\xf4\0\0\0\0\x01\0\x01\0\x01\0\x01\0\0\0\0\0\0\0\0\0\x01\0\x01\0\x01\0\0\0\0\0\x01\0\x01\0\0\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\0\0\0\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\x01\0\0\0\0\0\x01\0\x01\0\x01\0\0\0\0\0\0\0\0\0\x01\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\x01\0\0\0\x01\0\0\0\0d\x01\0\x01\0\x01\0\0\0\x01\0\0\0\0\0\x01\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\x01\0\0\0\x01\0\x01\0\x01\0\x01\0\0\0\0\0\0\0\0\0\0\0\x01\x05\x01\0\x01\0\0\x05\x01\0\x01\0\0\0\0\0\x01\x05\x01\x05\x01\x05\x01\0\x01\0\0\x05\x01\x05\x01\0\0\x05\x01\x05\x01\x05\x01\x05\x01\x05\x01\x05\x01\0\0\0\0\x05\x01\x05\x01\x05\x01\0\0\x05\x01\x05\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x01\0\0\0\0\x05\x01\x05\x01\0\0\0\0\0\0\0\0\0\0\x05\x01\x05\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x01\0\0\0\0\x05\x01\0\0\0\0\x02\x01\x05\x01\x05\x01\0\0\x05\x01\0\0\0\0\x05\x01\x05\x01\0\0\0\0\0\0\0\0\0\0\0\0\x05\x01\0\0\x05\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x01\x05\x01\0\0\x05\x01\x05\x01\x05\x01\x05\x01\0\0\0\0\0\0\0\0\0\0\x05\x01\0\0\x05\x01\0\0\0\0\x05\x01\x04\x01\0\0\x05\x01\x04\x01\0\0\0\0\x05\x01\0\0\x04\x01\x04\x01\x04\x01\0\0\0\0\x04\x01\x04\x01\0\0\x04\x01\x04\x01\x04\x01\x04\x01\x04\x01\x04\x01\0\0\0\0\x04\x01\x04\x01\x04\x01\0\0\x04\x01\x04\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\x01\0\0\0\0\x04\x01\x04\x01\0\0\0\0\0\0\0\0\0\0\x04\x01\x04\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\x01c\x01\0\0\x04\x01\0\0\0\0\0\0\x04\x01\x04\x01\0\0\x04\x01\0\0\0\0\x04\x01\x04\x01\0\0\0\0\0\0\0\0\0\0\0\0\x04\x01\0\0\x04\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\x01\x04\x01\0\0\x04\x01\x04\x01\x04\x01\x04\x01\0\0\0\0\0\0\0\0\0\0\x04\x01d\x01\x04\x01\0\0d\x01\x04\x01\0\0\0\0\x04\x01d\x01\0\0d\x01\x04\x01\0\0d\x01d\x01\0\0d\x01d\x01d\x01d\x01d\x01d\x01\0\0\0\0d\x01d\x01d\x01\0\0d\x01d\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\x01\0\0\0\0d\x01d\x01\0\0\0\0\0\0\0\0\0\0d\x01d\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\t\x01\0\0\0\0\0\0d\x01\0\0\0\0d\x01\0\0\0\0\0\0d\x01d\x01\0\0d\x01\0\0\0\0d\x01d\x01\0\0\0\0\0\0\0\0\0\0\0\0d\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\x01d\x01\0\0d\x01d\x01d\x01d\x01\0\0\0\0\0\0\0\0\0\0d\x01\x02\x01d\x01\0\0\x02\x01d\x01\0\0\0\0d\x01\x02\x01\0\0\x02\x01d\x01\0\0\x02\x01\x02\x01\0\0\x02\x01\x02\x01\x02\x01\x02\x01\x02\x01\x02\x01\0\0\0\0\x02\x01\x02\x01\x02\x01\0\0\x02\x01\x02\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x01\0\0\0\0\x02\x01\x02\x01\0\0\0\0\0\0\0\0\0\0\x02\x01\x02\x01\0\0\0\0\0\0\xed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x01\0\0\0\0\x02\x01\0\0\0\0\0\0\x02\x01\x02\x01\0\0\x02\x01\0\0\0\0\x02\x01\x02\x01\0\0\0\0\0\0\0\0\0\0\0\0\x02\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x01\x02\x01\0\0\x02\x01\x02\x01\x02\x01\x02\x01\0\0\0\0\0\0\0\0\0\0\x02\x01c\x01\x02\x01\0\0c\x01\x02\x01\0\0\0\0\x02\x01c\x01\0\0c\x01\x02\x01\0\0c\x01c\x01\0\0c\x01c\x01c\x01c\x01c\x01c\x01\0\0\0\0c\x01c\x01c\x01\0\0c\x01c\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0c\x01\0\0\0\0c\x01c\x01\0\0\0\0\0\0\0\0\0\0c\x01c\x01\0\0\0\0\0\0\f\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0c\x01\0\0\0\0c\x01\0\0\0\0\0\0c\x01c\x01\0\0c\x01\0\0\0\0c\x01c\x01\0\0\0\0\0\0\0\0\0\0\0\0c\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0c\x01c\x01\0\0c\x01c\x01c\x01c\x01\0\0\t\x01\0\0\0\0\t\x01c\x01\0\0c\x01\0\0\t\x01c\x01\t\x01\0\0c\x01\t\x01\t\x01\0\0c\x01\t\x01\0\0\t\x01\t\x01\t\x01\0\0\0\0\t\x01\t\x01\t\x01\0\0\t\x01\t\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\t\x01\0\0\0\0\t\x01\t\x01\0\0\0\0\0\0\0\0\0\0\t\x01\t\x01\0\0\0\0\0\0\x0b\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\t\x01\0\0\0\0\t\x01\0\0\0\0\0\0\t\x01\t\x01\0\0\t\x01\0\0\0\0\t\x01\t\x01\0\0\0\0\0\0\0\0\0\0\0\0\t\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\t\x01\t\x01\0\0\t\x01\t\x01\t\x01\t\x01\0\0\xed\0\0\0\0\0\xed\0\t\x01\0\0\t\x01\0\0\xed\0\t\x01\xed\0\0\0\t\x01\xed\0\xed\0\0\0\t\x01\xed\0\0\0\xed\0\xed\0\xed\0\0\0\0\0\xed\0\xed\0\xed\0\0\0\xed\0\xed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xed\0\0\0\0\0\xed\0\xed\0\0\0\0\0\0\0\0\0\0\0\xed\0\xed\0\0\0\0\0\0\0\n\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xed\0\0\0\0\0\xed\0\0\0\0\0\0\0\xed\0\xed\0\0\0\xed\0\0\0\0\0\xed\0\xed\0\0\0\0\0\0\0\0\0\0\0\0\0\xed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xed\0\xed\0\0\0\xed\0\xed\0\xed\0\xed\0\0\0\0\0\0\0\0\0\0\0\xed\0\f\x01\xed\0\0\0\f\x01\xed\0\0\0\0\0\xed\0\f\x01\0\0\f\x01\xed\0\0\0\f\x01\f\x01\0\0\0\0\f\x01\0\0\f\x01\f\x01\f\x01\0\0\0\0\f\x01\f\x01\f\x01\0\0\f\x01\f\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\x01\0\0\0\0\f\x01\f\x01\0\0\0\0\0\0\0\0\0\0\f\x01\f\x01\0\0\0\0\0\0\xcb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\x01\0\0\0\0\f\x01\0\0\0\0\0\0\f\x01\f\x01\0\0\f\x01\0\0\0\0\f\x01\f\x01\0\0\0\0\0\0\0\0\0\0\0\0\f\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\x01\f\x01\0\0\f\x01\f\x01\f\x01\f\x01\0\0\x0b\x01\0\0\0\0\x0b\x01\f\x01\0\0\f\x01\0\0\x0b\x01\f\x01\x0b\x01\0\0\f\x01\x0b\x01\x0b\x01\0\0\f\x01\x0b\x01\0\0\x0b\x01\x0b\x01\x0b\x01\0\0\0\0\x0b\x01\x0b\x01\x0b\x01\0\0\x0b\x01\x0b\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0b\x01\0\0\0\0\x0b\x01\x0b\x01\0\0\0\0\0\0\0\0\0\0\x0b\x01\x0b\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0b\x01\0\0y\x02\x0b\x01\0\0\0\0\0\0\x0b\x01\x0b\x01\0\0\x0b\x01t\0\0\0\x0b\x01\x0b\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0b\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0b\x01\x0b\x01\0\0\x0b\x01\x0b\x01\x0b\x01\x0b\x01\0\0\n\x01\0\0\0\0\n\x01\x0b\x01\0\0\x0b\x01\0\0\n\x01\x0b\x01\n\x01\0\0\x0b\x01\n\x01\n\x01\0\0\x0b\x01\n\x01\0\0\n\x01\n\x01\n\x01\0\0\0\0\n\x01\n\x01\n\x01\0\0\n\x01\n\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\x01\0\0\0\0\n\x01\n\x01\0\0\0\0\0\0\0\0\0\0\n\x01\n\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\x01\0\0\0\0\n\x01\0\0\0\0\0\0\n\x01\n\x01\0\0\n\x01\0\0\0\0\n\x01\n\x01\0\0\xee\0\0\0\0\0\0\0\0\0\n\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\x01\n\x01\0\0\n\x01\n\x01\n\x01\n\x01\0\0\0\0\0\0\0\0\0\0\n\x01\xcb\0\n\x01\0\0\xcb\0\n\x01\0\0\0\0\n\x01\xcb\0\0\0\xcb\0\n\x01\0\0\xcb\0\xcb\0\0\0\0\0\xcb\0\0\0\xcb\0\xcb\0\xcb\0\0\0\0\0\xcb\0\xcb\0\xcb\0\0\0\xcb\0\xcb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcb\0\0\0\0\0\xcb\0\xcb\0\0\0\0\0\0\0\0\0\0\0\xcb\0\xcb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcb\0\0\0\0\0\xcb\0\0\0\0\0\0\0\xcb\0\xcb\0\0\0\xcb\0\0\0\0\0\xcb\0\xcb\0\0\0\0\0\0\0\0\0\0\0\0\0\xcb\0,\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcb\0\xcb\0\0\0\xcb\0\0\0\xcb\0\xcb\0\0\0\0\0\0\0\0\0\0\0\xcb\0\0\0\xcb\0\0\0\0\0\xcb\0\0\0y\x02\xcb\0y\x02y\x02y\x02\xcb\0\0\0\0\0y\x02t\0\0\0\0\0\0\0y\x02\0\0\0\0\0\0y\x02y\x02y\x02\0\0\0\0t\0\0\0\0\0\0\0y\x02y\x02y\x02y\x02\0\0\0\0\0\0\0\0\0\0t\0y\x02t\0t\0\0\0\0\0y\x02\0\0\0\0\0\0\0\0\0\0y\x02y\x02\x89\0t\0\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\0\0\xb1\x01\xf3\x02\0\0y\x02\0\0\0\0y\x02y\x02\0\0y\x02y\x02y\x02t\0y\x02\x04\x02t\0y\x02y\x02\0\0t\0t\0\0\0\0\0\0\0y\x02\0\0t\0\x91\0\0\0\0\0\0\0\0\0\0\0t\0\x92\0y\x02y\x02\0\0y\x02y\x02y\x02y\x02\0\0\0\0y\x02t\0\x93\0\x94\0\0\0t\0t\0\0\0y\x02y\x02\0\0y\x02\0\0\xee\0\0\0y\x02\xee\0t\0\0\0\0\0t\0\xee\0\0\0\xee\0\0\0\0\0\xee\0\xee\0\0\0\0\0\xee\0\0\0\xee\0\xee\0\xee\0\0\0\0\0\xee\0\0\0\xee\0\0\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\0\0\0\0\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\0\0\0\0\xee\0\0\0\0\0\xee\0\0\0\0\0\0\0\xee\0\xee\0\0\0\xee\0\0\0\0\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\0\xee\0\0\0\xee\0\xee\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\xee\0\0\0\xee\0\0\0\0\0\xee\0\0\0,\x02\xee\0,\x02,\x02,\x02\xee\0\0\0\0\0,\x02\0\0\0\0\0\0\0\0,\x02\0\0\0\0\0\0,\x02,\x02,\x02\0\0\0\0\0\0\0\0\0\0\0\0,\x02,\x02,\x02,\x02\0\0\0\0\0\0\0\0\0\0\0\0,\x02\0\0\0\0\0\0\0\0,\x02\0\0\0\0\0\0\0\0\0\0,\x02,\x02-\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0,\x02\0\0\0\0,\x02\0\0\0\0,\x02,\x02,\x02\0\0,\x02\0\0\0\0,\x02,\x02\0\0\0\0\0\0\0\0\0\0\0\0,\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0,\x02,\x02\0\0,\x02,\x02,\x02,\x02\0\0\x04\x02\0\0\x04\x02\x04\x02\x04\x02\0\0\0\0\0\0\x04\x02,\x02\0\0\0\0,\x02\x04\x02\0\0\0\0,\x02\x04\x02\x04\x02\x04\x02\0\0\0\0\0\0\0\0\0\0\0\0\x04\x02\x04\x02\x04\x02\x04\x02\0\0\0\0\0\0\0\0\0\0\0\0\x04\x02\0\0\0\0\0\0\0\0\x04\x02\0\0\0\0\0\0\0\0\0\0\x04\x02\x04\x02\x03\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\x02\0\0\0\0\x04\x02\0\0\0\0\x04\x02\x04\x02\x04\x02\0\0\x04\x02\0\0\0\0\x04\x02\x04\x02\0\0\0\0\0\0\0\0\0\0\0\0\x04\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\x02\x04\x02\0\0\x04\x02\x04\x02\x04\x02\0\0\0\0\x05\x02\x04\x02\x05\x02\x05\x02\x05\x02\0\0\0\0\0\0\x05\x02\x04\x02\0\0\0\0\x04\x02\x05\x02\0\0\0\0\x04\x02\x05\x02\x05\x02\x05\x02\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\x05\x02\x05\x02\x05\x02\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\0\0\0\0\0\0\0\0\x05\x02\0\0\0\0\0\0\0\0\0\0\x05\x02\x05\x02\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\0\0\0\0\x05\x02\0\0\0\0\x05\x02\x05\x02\x05\x02\0\0\x05\x02\0\0\0\0\x05\x02\x05\x02\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\x05\x02\0\0\x05\x02\x05\x02\x05\x02\0\0\0\0\0\0\x05\x02-\x02\0\0-\x02-\x02-\x02\0\0\0\0\x05\x02-\x02\0\0\x05\x02\0\0\0\0-\x02\x05\x02\0\0\0\0-\x02-\x02-\x02\0\0\0\0\0\0\0\0\0\0\0\0-\x02-\x02-\x02-\x02\0\0\0\0\0\0\0\0\0\0\0\0-\x02\0\0\0\0\0\0\0\0-\x02\0\0\0\0\0\0\0\0\0\0-\x02-\x02\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0-\x02\0\0\0\0-\x02\0\0\0\0-\x02-\x02-\x02\0\0-\x02\0\0\0\0-\x02-\x02\0\0\0\0\0\0\0\0\0\0\0\0-\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0-\x02-\x02\0\0-\x02-\x02-\x02-\x02\0\0\x03\x02\0\0\x03\x02\x03\x02\x03\x02\0\0\0\0\0\0\x03\x02-\x02\0\0\0\0-\x02\x03\x02\0\0\0\0-\x02\x03\x02\x03\x02\x03\x02\0\0\0\0\0\0\0\0\0\0\0\0\x03\x02\x03\x02\x03\x02\x03\x02\0\0\0\0\0\0\0\0\0\0\0\0\x03\x02\0\0\0\0\0\0\0\0\x03\x02\0\0\0\0\0\0\0\0\0\0\x03\x02\x03\x02\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\x02\0\0\0\0\x03\x02\0\0\0\0\x03\x02\x03\x02\x03\x02\0\0\x03\x02\0\0\0\0\0\0\x03\x02\0\0\0\0\0\0\0\0\0\0\0\0\x03\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\x02\x03\x02\0\0\x03\x02\x03\x02\x03\x02\x03\x02\0\0\x01\x02\0\0\x01\x02\x01\x02\x01\x02\0\0\0\0\xc1\0\x01\x02\x03\x02\0\0\0\0\x03\x02\x01\x02\0\0\0\0\x03\x02\x01\x02\x01\x02\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\x01\x02\x01\x02\x01\x02\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\x01\x02\0\0\0\0\0\0\0\0\x01\x02\0\0\0\0\0\0\0\0\0\0\x01\x02\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0R\0\0\0\0\0\0\0\x01\x02\0\0\0\0\x01\x02\0\0\0\0\x01\x02\x01\x02\x01\x02\0\0\x01\x02\0\0\0\0\0\0\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\x02\x01\x02\0\0\x01\x02\x01\x02\x01\x02\x01\x02\0\0\0\0\0\0\x02\x02\0\0\x02\x02\x02\x02\x02\x02\0\0\0\0\x01\x02\x02\x02\0\0\x01\x02\0\0\0\0\x02\x02\x01\x02\0\0\0\0\x02\x02\x02\x02\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\x02\x02\x02\x02\x02\x02\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\x02\x02\0\0\0\0\0\0\0\0\x02\x02\0\0\0\0\0\0\0\0\0\0\x02\x02\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x02\0\0\0\0\x02\x02\0\0\0\0\x02\x02\x02\x02\x02\x02\xe2\x02\x02\x02\0\0\0\0\0\0\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x02\x02\x02\0\0\x02\x02\x02\x02\x02\x02\x02\x02\0\0\0\x02\0\0\0\x02\0\x02\0\x02\0\0\0\0\0\0\0\x02\x02\x02\0\0\0\0\x02\x02\0\x02\0\0\0\0\x02\x02\0\x02\0\x02\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\x02\0\x02\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\0\0\0\0\0\0\0\0\x02\0\0\0\0\0\0\0\0\0\0\0\x02\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc1\0\0\0\0\x02\xc1\0\0\0\0\x02\0\0\0\0\0\x02\0\x02\0\x02\0\0\0\x02\xc1\0\0\0\0\0\0\x02\0\0\0\0\xc1\0\0\0\0\0\x81\0\0\x02\0\0\0\0\xc1\0\xc1\0\xc1\0\xc1\0\0\0\0\0\0\0\0\0\0\x02\0\x02\0\0\0\x02\0\x02\0\x02\0\x02\xc1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0R\0\0\x02\0\0R\0\0\x02\0\0\0\0\0\0\0\x02\0\0\0\0\xc1\0\0\0R\0\xc1\0\0\0\0\0\0\0\xc1\0\xc1\0\0\0\0\0\0\0\0\0\0\0\xc1\0R\0R\0R\0R\0\0\0\0\0\xc1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0R\0\0\0\0\0\xc1\0\0\0\xc1\0\0\0\xc1\0\xc1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc1\0R\0\0\0\xc1\0R\0\0\0\0\0\xc1\0R\0R\0\0\0\0\0\0\0\0\0\0\0R\0\0\0\0\0\0\0y\0\0\0\0\0R\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0R\0\0\0R\0\0\0R\0R\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0R\0\0\0\0\0R\0\0\0\0\0\xe2\x02R\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xa9\x01\xe2\x02\0\0\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\t\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\x0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0f\0\x10\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\x17\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0!\0\0\0\0\0\"\0#\0$\0\0\0\0\0%\0&\0\0\0'\0(\0\0\0)\0\0\0*\0+\0\0\0,\0r\x02-\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\0z\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\x005\x006\0\t\0\n\0\x0b\0\0\x007\0\0\0\f\0\r\0\x0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0f\0\x10\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\x17\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0!\0\0\0\0\0\"\0#\0$\0\0\0\0\0%\0&\0\0\0'\0(\0\0\0)\0\0\0*\0+\0\0\0,\0\0\0-\0\0\0\0\0\0\0.\0/\0\x87\x010\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0z\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\x005\x006\0\0\0\0\0\0\0\0\x007\0\0\0\0\0\0\0\0\0\t\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\x0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0f\0\x10\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\x17\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0!\0\0\0\0\0\"\0#\0$\0\0\0\0\0%\0&\0\0\0'\0(\0\0\0)\0\0\0*\0+\0\0\0,\0\0\0-\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0z\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\x84\x003\x004\x005\x006\0\0\0\0\0r\x02\0\x007\0\0\0r\x02\0\0r\x02\0\0r\x02\0\0r\x02\0\0r\x02r\x02r\x02r\x02\0\0r\x02r\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0r\x02r\x02r\x02r\x02r\x02r\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0r\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0r\x02r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02\0\0\0\0r\x02r\x02\0\0\0\0r\x02r\x02r\x02r\x02r\x02r\x02\0\0k\x02r\x02\0\0r\x02r\x02\0\0r\x02\0\0\0\0\0\0\0\0r\x02r\x02\0\0\0\0r\x02\0\0\0\0\0\0\0\0r\x02\0\0r\x02r\x02\0\0r\x02r\x02r\x02r\x02\0\0\0\0\0\0r\x02\0\0\0\0r\x02\0\0r\x02\0\0r\x02r\x02r\x02\0\0\x87\x01r\x02\0\0\0\0\x87\x01\0\0\x87\x01\0\0\x87\x01\0\0\x87\x01\0\0\x87\x01\0\0\x87\x01\x87\x01\x85\0\x87\x01\x87\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x87\x01\0\0\0\0\x87\x01\x87\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x87\x01\x87\x01\x87\x01\x87\x01\0\0\x87\x01\0\0\x87\x01\x87\x01\0\0\0\0\x87\x01\0\0\0\0\0\0\0\0\x87\x01\x87\x01\x87\x01\0\0\0\0\0\0\0\0\x87\x01\0\0\x87\x01\x80\0\x82\0\x87\x01\0\0\x82\0\x82\0\0\0\0\0\x87\x01\0\0\0\0\x87\x01\0\0\0\0\x82\0\x82\0\x87\x01\0\0\x87\x01\x87\x01\x82\0\x87\x01\x87\x01\0\0\x87\x01\0\0\0\0\x82\0\x87\x01\x82\0\x82\0\x87\x01\0\0\x87\x01\0\0\0\0\x87\x01\x87\x01\0\0\0\0\x87\x01\0\0\x82\0\0\0\0\0\0\0\0\0\0\0\x82\0\x82\0\x82\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84\0\0\0\x82\0\x84\0\x84\0\x82\0\0\0\0\0\x82\0\x82\0\x82\0\0\0\x82\0\x84\0\x84\0\0\0\x82\0\0\0\0\0\x84\0\0\0\0\0\0\0\x82\0\0\0\0\0\x84\0\0\0\x84\0\x84\0\0\0\0\0\0\0\0\0\0\0\x82\0\0\0\x82\0\0\0\x82\0\x82\0\x84\0\0\0\0\0\0\0\0\0\0\0\x84\0\x84\0\xb2\0\0\0\x82\0\0\0\0\0\x82\0\0\0\0\0\0\0\0\0\0\0\0\0\x84\0\0\0\0\0\x84\0\0\0\0\0\x84\0\x84\0\x84\0\0\0\x84\0\0\0\0\0\0\0\x84\0\0\0\0\0k\x02\0\0\0\0k\x02\x84\0\0\0\0\0\0\0k\x02\0\0\0\0\0\0\0\0k\x02k\x02\0\0\x84\0\0\0\x84\0k\x02\x84\0\x84\0}\x02\0\0\0\0\0\0k\x02\0\0k\x02k\x02\x83\x02\0\0\x84\0\0\0\0\0\x84\0\0\0\0\0\0\0\0\0\x89\0k\x02\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\0\0\xb1\x01G\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85\0\0\0k\x02\x85\0\x85\0k\x02\0\0}\x02k\x02k\x02k\x02\0\0\0\0\x85\0\x85\0\0\0k\x02\x91\0\0\0\x85\0\0\0\0\0k\x02k\x02\x92\0\0\0\x85\0\0\0\x85\0\x85\0\0\0\xe0\x02\0\0\0\0\0\0k\x02\x93\0\x94\0\0\0k\x02k\x02\x85\0\0\0\0\0\0\0\0\0\0\0\x85\0\x85\0\0\0\0\0k\x02\0\0\0\0k\x02\0\0\0\0\0\0\0\0\x80\0\0\0\x85\0\x80\0\x80\0\x85\0\0\0\0\0\0\0\x85\0\x85\0\0\0\x85\0\x80\0\x80\0\0\0\x85\0\0\0\0\0\x80\0\0\0\0\0\0\0\x85\0\0\0\0\0\x80\0\xd8\x01\x80\0\x80\0\0\0\0\0\0\0\0\0\0\0\x85\0\0\0\x85\0\0\0\x85\0\x85\0\x80\0\0\0\0\0\0\0\0\0\0\0\x80\0\x80\0\0\0\x82\x02\x85\0\0\0\x82\x02\x85\0\0\0\0\0\0\0\0\0\0\0\0\0\x80\0\0\0\x82\x02\x80\0\0\0\0\0\0\0\x80\0\x80\0\0\0\x80\0\0\0\0\0\0\0\x80\0\x82\x02\x82\x02\x82\x02\x82\x02\0\0\0\0\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x02\0\0\0\0\x80\0\0\0\x80\0\0\0\x80\0\x80\0\0\0\0\0\0\0\x06\x02\0\0\0\0\0\0\0\0\0\0\xb2\0\x80\0\x82\x02\xb2\0\x80\0\0\0y\x02\0\0\x82\x02\x82\x02\x82\x02\x06\x02\0\0\xb2\0\0\0y\x02\x82\x02\0\0\0\0\0\0\0\0\0\0\0\0\x82\x02\0\0\0\0\xb2\0\xb2\0\xb2\0\xb2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x02\0\0\x82\x02y\x02\xb2\0\0\0y\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x02y\x02\0\0\x82\x02\0\0\0\0\0\0\0\0\x83\x02\0\0\xb2\0\x83\x02\0\0\0\0\x1a\x02\0\0\xb2\0\xb2\0\xb2\0\0\0\0\0\x83\x02\0\0\x1a\x02\xb2\0\0\0\0\0\0\0\0\0\0\0\0\0\xb2\0\0\0\0\0\x83\x02\x83\x02\x83\x02\x83\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb2\0\0\0\xb2\0\x1a\x02\x83\x02\0\0\x1a\x02\x07\x02\0\0\0\0\0\0\0\0\0\0\0\0\xb2\0\x1a\x02\0\0\xb2\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\x83\x02\0\0\xe0\x02\0\0z\x02\0\0\x83\x02\x83\x02\x83\x02\0\0\0\0\0\0\xe0\x02z\x02\x83\x02\0\0\0\0\0\0\xe0\x02\0\0\0\0\x83\x02\0\0\0\0\0\0\xe0\x02\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\x83\x02\0\0\x83\x02z\x02\xe0\x02\xe0\x02z\x02\0\0\0\0\0\0\0\0\xe0\x02\xe0\x02\0\0\x83\x02z\x02\0\0\x83\x02\0\0\xd8\x01\0\0\0\0\xd8\x01\0\0\0\0\xe0\x02\x07\x02\xd8\x01\xe0\x02\0\0\0\0\0\0\xd8\x01\xe0\x02\0\0\xe0\x02f\0\0\0\xd8\x01\xe0\x02\0\0\0\0\0\0\0\0\0\0\xd8\x01\xe0\x02\xd8\x01\xd8\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\xd8\x01\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\0\0\xe0\x02\0\0\0\0\xd8\x01\0\0\0\0\xd8\x01\0\0\0\0\xd8\x01\xd8\x01\xd8\x01\0\0\0\0\0\0\0\x004\x02\xd8\x01\x06\x02\0\0\0\0\x06\x02\0\0\0\0\xd8\x01\0\0\x06\x02\xd5\x01\0\0\0\0\0\0\x06\x02\0\0\0\0\0\0\x06\x02\xd8\x01\x06\x02\x06\x02\0\0\xd8\x01\xd8\x01\0\0\x06\x02\x06\x02\0\0\x06\x02\x06\x02\x06\x02\0\0\0\0\0\0\xd8\x01\0\0\x06\x02\xd8\x01\0\0\0\0\0\0\x06\x02\0\0\x06\x02\0\0\x06\x02\x06\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\x02\xe0\x02\0\0\x06\x02\0\0\0\0\x06\x02\0\0\0\0\x06\x02\x06\x02\x06\x02\0\0\0\0\0\0\0\0\x06\x02\x06\x02\0\0\0\0\x06\x02\0\0\0\0\x06\x02\x06\x02\xb1\x01\x06\x02\x06\x02\x06\x02\0\0\0\0\0\0\0\0\x06\x02\x06\x02\0\0\x06\x02\0\0\0\0\0\0\x06\x02\x06\x02\0\0\0\0\x04\x02\0\0\0\0\0\0\0\0\0\0\0\0\x07\x02\x06\x02\x06\x02\x07\x02\x06\x02\0\0\x06\x02\0\0\x07\x02\0\0\x06\x02\0\0\0\0\x07\x02\0\0\0\0\0\0\0\0\x06\x02\x07\x02\0\0\x06\x02\0\0\0\0P\0\0\0\x07\x02\0\0\x07\x02\x07\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\x02\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\0\0\x8d\0\x8e\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\x02\0\0\xc0\x01\x07\x02\0\0\0\0\x07\x02\x07\x02\x07\x02\0\0\x8f\0\0\0\0\0\x07\x02\x07\x02\0\0\0\0\x07\x02\x90\0\x91\0\x07\x02\x07\x02\xe2\x02\x0b\x02\0\0\x07\x02\x92\0f\0\0\0\0\0\x07\x02\0\0\0\0\x07\x02\0\0\0\0\x07\x02\x07\x02\x93\0\x94\0f\0\x05\x02\0\0\x07\x02\0\0\x07\x02\x07\x02\0\0\0\0\x07\x02\0\0\0\0\x07\x02f\0\0\0f\0f\0\0\0\x07\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\x02\0\0\0\0\x07\x02\xb1\x01\0\0\x07\x02\x07\x02\x07\x02\0\0f\0\0\0\0\0\x07\x02\x07\x02\0\0\0\0\xd5\x01f\0\0\0\xd5\x01\x07\x02\0\0\0\0f\0\xd5\x01\0\0\0\0\0\0\0\0\xd5\x01f\0\0\0\x07\x02\0\0\0\0\xd5\x01\x07\x02\0\0\0\0\0\0\x07\x02\0\0\xd5\x01\0\0\xd5\x01\xd5\x01f\0\0\0\x07\x02\0\0\0\0\x07\x02\0\0\0\0\0\0\0\0\0\0\xd5\x01f\0\0\0\0\0f\0\xb2\x01\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd5\x01\0\0\xe0\x02\xd5\x01\0\0\0\0\xd5\x01\xd5\x01\xd5\x01\0\0\0\0\0\0\0\0\xb1\x01\xd5\x01\xe0\x02\xb1\x01\xe0\x02\xe0\x02\0\0\0\0\xd5\x01\0\0\0\0\0\0\0\0\xb1\x01\0\0\0\0\0\0\xe0\x02\0\0\xb1\x01\xd5\x01\0\0\0\0\0\0\xd5\x01\xd5\x01\xb1\x01\0\0\xb1\x01\xb1\x01\0\0\xb4\x01\0\0\0\0\0\0a\0\xd5\x01\xe0\x02\0\0\xd5\x01\0\0\xb1\x01\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\0\0P\0\xe0\x02\0\0P\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\0\0\xb1\x01\0\0P\0\xb1\x01\0\0\0\0\0\0\xb1\x01\xb1\x01\0\0\0\0\0\0\0\0\xe0\x02\xb1\x01P\0P\0P\0P\0\0\0\0\0\xb1\x01\0\0\0\0\0\0\xe0\x02\0\0y\x02\xe0\x02\xb3\x01P\0\0\0\0\0\xb1\x01\0\0\0\0\0\0\xb1\x01\xb1\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\xb1\x01P\0\xe2\x02\xb1\x01P\0\0\0\0\0\xe2\x02P\0P\0\0\0\0\0\xe2\x02\0\0\0\0P\0\0\0\0\0\xe2\x02\0\0\0\0\0\0P\0\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\0\0e\0\0\0\0\0\0\0P\0\0\0P\0\0\0P\0P\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\xb5\x01\0\0\0\0P\0\0\0\0\0P\0\0\0\0\0\0\0\0\0\0\0\xb1\x01\xe2\x02\0\0\xb1\x01\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\0\0\0\0\xb1\x01\0\0\xe2\x02\0\0\0\0\0\0\xb1\x01\0\0\0\0\xe2\x02\0\0\0\0\0\0\xb1\x01\0\0\xb1\x01\xb1\x01\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\xb1\x01\0\0\0\0\0\0\0\0\0\0\xb8\x01\0\0\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\xb2\x01\0\0\xb1\x01\xb2\x01\0\0\xb1\x01\0\0\0\0\0\0\xb1\x01\xb1\x01\0\0\0\0\xb2\x01\0\0\0\0\xb1\x01\0\0\0\0\xb2\x01\0\0\0\0\0\0\xb1\x01\0\0\0\0\xb2\x01\0\0\xb2\x01\xb2\x01\0\0\0\0\0\0\0\0\0\0\xb1\x01\0\0\0\0\xe2\x02\xb1\x01\xb1\x01\xb2\x01\0\0\0\0\0\0\0\0\0\0u\0\0\0\0\0\0\0\xb1\x01\0\0\0\0\xb1\x01\0\0\0\0\0\0\0\0\xb4\x01\0\0\xb2\x01\xb4\x01a\0\xb2\x01\0\0\0\0\0\0\xb2\x01\xb2\x01\0\0\0\0\xb4\x01\0\0\0\0\xb2\x01a\0\0\0\xb4\x01\0\0\0\0\0\0\xb2\x01\0\0\0\0\xb4\x01\0\0\xb4\x01\xb4\x01a\0\0\0a\0a\0\0\0\xb2\x01\0\0\0\0\xa8\x01\xb2\x01\xb2\x01\xb4\x01\0\0\0\0\0\0a\0\0\0\0\0\0\0\0\0\0\0\xb2\x01\0\0\0\0\xb2\x01\0\0\0\0\0\0\0\0\xb3\x01\0\0\xb4\x01\xb3\x01\0\0\xb4\x01a\0\0\0\0\0\xb4\x01\xb4\x01\0\0\0\0\xb3\x01a\0\0\0\xb4\x01\0\0\0\0\xb3\x01a\0\0\0\0\0\xb4\x01\0\0\0\0\xb3\x01a\0\xb3\x01\xb3\x01\0\0\0\0\0\0\0\0\0\0\xb4\x01\0\0\0\0\xe0\x02\xb4\x01\xb4\x01\xb3\x01\0\0a\0\0\0\0\0\0\0\0\0\0\0\0\0e\0\xb4\x01\0\0\0\0\xb4\x01a\0\0\0\0\0a\0\0\0\0\0\xb3\x01\0\0e\0\xb3\x01\0\0\0\0\xb5\x01\xb3\x01\xb3\x01\xb5\x01\0\0\0\0\0\0\0\0\xb3\x01e\0\0\0e\0e\0\xb5\x01\0\0\xb3\x01\xe0\x02\0\0\0\0\xb5\x01\0\0\0\0\0\0\0\0e\0\0\0\xb5\x01\xb3\x01\xb5\x01\xb5\x01\0\0\xb3\x01\xb3\x01\0\0\0\0\0\0\0\0\0\0E\0\0\0\0\0\xb5\x01\0\0\xb3\x01e\0\0\0\xb3\x01\0\0\0\0\0\0\0\0\0\0e\0\0\0\0\0\0\0\0\0\0\0e\0\xb8\x01\0\0\xb5\x01\xb8\x01\0\0\xb5\x01e\0\0\0\0\0\xb5\x01\xb5\x01\0\0\0\0\xb8\x01\0\0\0\0\xb5\x01\0\0\0\0\xb8\x01\0\0\0\0e\0\xb5\x01F\0\0\0\xb8\x01\0\0\xb8\x01\xb8\x01\0\0\0\0\0\0\0\0e\0\xb5\x01\0\0e\0\0\0\xb5\x01\xb5\x01\xb8\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\xb5\x01\0\0\0\0\xb5\x01\0\0\0\0\0\0\xe2\x02u\0\0\0\xb8\x01\0\0\xe2\x02\xb8\x01\0\0\0\0\0\0\xb8\x01\xb8\x01\0\0\0\0u\0\0\0\xd5\x01\xb8\x01\xe2\x02\0\0\xe2\x02\xe2\x02\0\0\0\0\xb8\x01\xd5\x01\0\0u\0\0\0u\0u\0\0\0\0\0\xe2\x02\0\0\0\0\xb8\x01\0\0\0\0\0\0\xb8\x01\xb8\x01u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa8\x01\xb8\x01\xe2\x02\0\0\xb8\x01\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02u\0\0\0\xa8\x01u\0\0\0\xe2\x02\0\0u\0u\0\0\0\0\0\0\0\xe2\x02\0\0u\0\xa8\x01\0\0\xa8\x01\xa8\x01\0\0\0\0u\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\xa8\x01\0\0\0\0u\0\0\0\0\0\0\0u\0u\0\0\0\xe2\x02\xe0\x02\0\0\xe2\x02\0\0\0\0\0\0\0\0\xe0\x02u\0\xa8\x01\xe0\x02u\0\xa8\x01\0\0\0\0\0\0\xa8\x01\xa8\x01\0\0\0\0\xe0\x02\0\0{\0\xa8\x01\0\0\0\0\0\0\0\0\0\0\0\0\xa8\x01\0\0\0\0\xe0\x02\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\xa8\x01\0\0|\0\0\0\xa8\x01\xa8\x01\xe0\x02\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\xa8\x01\0\0\0\0\xa8\x01\0\0\0\0\0\0\xe0\x02\0\0\0\0\xe0\x02\0\0\0\0\xe0\x02\0\0\0\0E\0\0\0\xe0\x02E\0\xe0\x02\0\0\xe0\x02\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0E\0\0\0\xe0\x02\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0E\0\xe0\x02E\0E\0\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x02E\0E\0\xe0\x02\xe0\x02\0\0F\0\xe0\x02\xe0\x02F\0\xe2\x02\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\0\0F\0\xe2\x02\xe0\x02E\0\0\0\0\0E\0\0\0\0\0\0\0E\0E\0\0\0F\0\xe0\x02F\0F\0E\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0E\0\0\0\0\0F\0F\0\0\0\xe0\x02\0\0\0\0\xe0\x02\0\0\0\0E\0\xd5\x01\0\0\0\0E\0E\0\0\0\0\0\0\0\xd5\x01\xd5\x01\0\0F\0\0\0\xd5\x01F\0E\0\0\0\0\0F\0F\0\0\0\0\0\xd5\x01\0\0\0\0F\0\xd5\x01\0\0\xd5\x01\xd5\x01\0\0\xe0\x02F\0\0\0\0\0\xd5\x01\0\0\xd5\x01\xd5\x01\0\0\0\0\xd5\x01\0\0\0\0F\0\0\0\0\0\0\0F\0F\0\xd5\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0F\0\xd5\x01\0\0\0\0\xd5\x01\0\0\0\0\xd5\x01\xd5\x01\xd5\x01\xd5\x01\0\0\0\0\xd5\x01\0\0\xd5\x01\xd5\x01\xd5\x01\xd5\x01\0\0\0\x006\0\xd5\x01\0\0\xd5\x01\0\0\0\0\xe0\x02\0\0\0\0\xe0\x02\xd5\x01\0\0\0\0\xd5\x01\0\0\0\0\0\0\xd5\x01\xd5\x01\xe0\x02\0\0\0\0\xd5\x01\0\0\0\0\0\0\xd5\x01\xd5\x01{\0\xd5\x01\0\0{\0\xe0\x02\0\0\xe0\x02\xe0\x02\0\0\0\0\xd5\x018\0\0\0{\0\0\0\0\0\0\0\0\0\xe0\x02\xe0\x02\0\0\0\0|\0\0\0\0\0|\0{\0\0\0{\0{\0\0\0\0\0\0\0\0\0\0\0|\0\0\0\0\0\0\0\xe0\x02\0\0{\0\xe0\x02\0\0\0\0\0\0\0\0\xe0\x02|\0\0\0|\0|\0\0\0\xe0\x02\0\0<\0\0\0\0\0\0\0\0\0\xe0\x02{\0\0\0|\0{\0\0\0\0\0\0\0{\0{\0\0\0\0\0\xe0\x02\0\0\0\0{\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0{\0|\0\0\0\0\0|\0\0\0\xe0\x02\0\0|\0|\0\0\0\0\0{\0\0\0\0\0|\0{\0{\0?\0\xe2\x02\0\0\0\0|\0\0\0\0\0\0\0\0\0\xe2\x02{\0\xe2\x02\0\0\0\0\xe2\x02\0\0|\0\0\0\0\0\0\0|\0|\0@\0\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe0\x02|\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\0\0\xe0\x02\xe2\x02\xe2\x02\xe0\x02\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\xe0\x02\0\0\xe2\x02\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\0\0\0\0\xe0\x02\xe2\x02\xe0\x02\xe0\x02\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\xe2\x02\0\0'\x02\0\0'\x02'\x02'\x026\0'\x02\0\0\0\0'\x02'\x02\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\x006\0\xe0\x02\0\0\0\0\0\0\0\0\xe0\x02\0\0\0\0'\x02\0\0\0\0\xe0\x026\0\0\x006\x006\0'\x02'\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0'\x028\0\0\x006\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\xe0\x02\xe0\x02'\x02'\x028\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x026\0\0\0\0\x006\x008\0\0\x008\x008\x006\0\0\0\0\0\0\0\0\0\0\x006\0\0\0\0\0\0\0\0\x008\0\0\x006\0<\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x006\0\0\0<\0\0\x006\x006\x008\0\0\0\0\x008\0\0\0\0\0\0\0\0\x008\0<\x006\0<\0<\0\0\x008\0\0\0\0\0\0\0\0\0\0\0\0\x008\0\0\0\0\0<\0\0\0\0\0\0\0?\0\0\0\0\0\0\0\0\x008\0\0\0\0\0\0\x008\x008\0\0\0\0\0?\0\0\0\0\0<\0\0\0\0\0<\0\0\x008\0@\0\0\0<\0\0\0?\0\0\0?\0?\0<\0\xe0\x02\0\0\0\0\0\0@\0\0\0<\0\0\0\0\0\0\0?\0\0\0\0\0\xe0\x02\0\0\0\0\0\0@\0<\0@\0@\0\0\0<\0<\0\0\0\0\0\xe0\x02\0\0\xe0\x02\xe0\x02?\0\0\0@\0?\0<\0\0\0\0\0\0\0?\0\0\0\0\0\xe0\x02\0\0\0\0?\0\0\0\0\0\0\0\0\0\0\0\0\0?\0@\0\0\0\0\0@\0\0\0\0\0\0\0\0\0@\0\xe0\x02\0\0?\0\xe0\x02\0\0@\0?\0?\0\xe0\x02\0\0\0\0\0\0@\0\0\0\xe0\x02\0\0\0\0\0\0?\0\0\0\0\0\xe0\x02\0\0\0\0@\0\0\0\0\0\0\0@\0@\0\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\xe0\x02\xe0\x02\xdb\x02@\0\0\0\0\0\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\xe0\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\0\0\0\0\0\0\xdb\x02\0\0\0\0\0\0\0\0\0\0\0\0\xdb\x02\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\0\0\0\0\0\0\xdb\x02\0\0\xdb\x02\0\0\0\0\0\0\0\0\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\0\0\xdb\x02\xdb\x02\0\0\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\xdb\x02\0\0\xdb\x02\xdb\x02\0\0\xdb\x02\0\0\xdb\x02\xdb\x02\0\0\0\0\xdb\x02\xdb\x02\0\0\xdb\x02\0\0\xdb\x02\0\0\0\0\xdb\x02\xdb\x02\0\0\0\0\xdb\x02\xdb\x02\0\0\0\0\0\0\xdb\x02\0\0\0\0\xdb\x02\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\0\0\xdb\x02#\x01$\x01%\x01\0\0\0\0\t\0\n\0&\x01\0\0'\x01\0\0\f\0\r\0\0\0\0\0(\x01)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\0\0\0\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0+\x01\0\0\0\0\x16\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\x001\x01\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\x002\x013\x01\0\x004\x01\0\0*\0+\0\0\0,\0\0\0\0\0\0\x005\x016\x017\x018\x019\x01:\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\0\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0#\x01$\x01%\x01\0\x007\0\t\0\n\0&\x01\0\0'\x01\0\0\f\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\0\0\0\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0+\x01\0\0\0\0\x16\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\x001\x01\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\x002\x013\x01\0\x004\x01\0\0*\0+\0\0\0,\0\0\0\0\0\0\x005\x016\x017\x018\x019\x01:\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\0\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0#\x01$\x01%\x01\0\x007\0\t\0\n\0&\x01\0\0'\x01\0\0\f\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\0\0\0\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0+\x01\0\0\0\0\x16\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\x001\x01\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\x002\x013\x01\0\0Z\x03\0\0*\0+\0\0\0,\0\0\0\0\0\0\x005\x016\x017\x018\x019\x01:\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0<\x01\0\0=\x012\0\0\0\0\0\0\0\xe2\x023\x004\0\0\x006\0\xe2\x02\xe2\x02\xe2\x02\xe2\x027\0\0\0\xe2\x02\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02^\x02\0\0\xe2\x02\0\0\0\0\xa5\x02\xa5\x02\xa5\x02\0\0\0\0\0\0\xa5\x02\xa5\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa5\x02\xa5\x02\xa5\x02\xa5\x02\xa5\x02\0\0\0\0\0\0\0\0\xa5\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa5\x02\xa5\x02\xa5\x02\0\0\xa5\x02\xa5\x02\xa5\x02\xa5\x02\xa5\x02\0\0\0\0\xa5\x02\0\0\0\0\0\0\xa5\x02\xa5\x02\xa5\x02\0\0\0\0\0\0\xa5\x02\0\0\xa5\x02\xa5\x02\0\0\0\0\0\0\xa5\x02\xa5\x02\0\0\xa5\x02\0\0\0\0\0\0\0\0\0\0\xa5\x02\xa5\x02_\x02\xa5\x02\0\0\0\0\0\0\xa6\x02\xa6\x02\xa6\x02^\x02\0\0\0\0\xa6\x02\xa6\x02\0\0\0\0\xa5\x02\0\0\0\0\0\0\0\0\xa5\x02\xa5\x02\0\0\xa5\x02\0\0\0\0\0\0\0\0\xa5\x02\0\0\xa6\x02\xa6\x02\xa6\x02\xa6\x02\xa6\x02\0\0\0\0\0\0\0\0\xa6\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa6\x02\xa6\x02\xa6\x02\0\0\xa6\x02\xa6\x02\xa6\x02\xa6\x02\xa6\x02\0\0\0\0\xa6\x02\0\0\0\0\0\0\xa6\x02\xa6\x02\xa6\x02\0\0\0\0\0\0\xa6\x02\0\0\xa6\x02\xa6\x02\0\0\0\0\0\0\xa6\x02\xa6\x02\0\0\xa6\x02\0\0\0\0\0\0\0\0\0\0\xa6\x02\xa6\x02\\\x02\xa6\x02\0\0\0\0\0\0\xa7\x02\xa7\x02\xa7\x02_\x02\0\0\0\0\xa7\x02\xa7\x02\0\0\0\0\xa6\x02\0\0\0\0\0\0\0\0\xa6\x02\xa6\x02\0\0\xa6\x02\0\0\0\0\0\0\0\0\xa6\x02\0\0\xa7\x02\xa7\x02\xa7\x02\xa7\x02\xa7\x02\0\0\0\0\0\0\0\0\xa7\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa7\x02\xa7\x02\xa7\x02\0\0\xa7\x02\xa7\x02\xa7\x02\xa7\x02\xa7\x02\0\0\0\0\xa7\x02\0\0\0\0\0\0\xa7\x02\xa7\x02\xa7\x02\0\0\0\0\0\0\xa7\x02\0\0\xa7\x02\xa7\x02\0\0\0\0\0\0\xa7\x02\xa7\x02\0\0\xa7\x02\0\0\0\0\0\0\0\0\0\0\xa7\x02\xa7\x02]\x02\xa7\x02\0\0\0\0\0\0\xa8\x02\xa8\x02\xa8\x02\\\x02\0\0\0\0\xa8\x02\xa8\x02\0\0\0\0\xa7\x02\0\0\0\0\0\0\0\0\xa7\x02\xa7\x02\0\0\xa7\x02\0\0\0\0\0\0\0\0\xa7\x02\0\0\xa8\x02\xa8\x02\xa8\x02\xa8\x02\xa8\x02\0\0\0\0\0\0\0\0\xa8\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa8\x02\xa8\x02\xa8\x02\0\0\xa8\x02\xa8\x02\xa8\x02\xa8\x02\xa8\x02\0\0\0\0\xa8\x02\0\0\0\0\0\0\xa8\x02\xa8\x02\xa8\x02\0\0\0\0\0\0\xa8\x02\0\0\xa8\x02\xa8\x02\0\0\0\0\0\0\xa8\x02\xa8\x02\0\0\xa8\x02\0\0\0\0\0\0\0\0\0\0\xa8\x02\xa8\x02\0\0\xa8\x02\0\0\0\0\0\0\0\0\0\0\0\0]\x02\xeb\0\xec\0\xed\0\0\0\0\0\0\0\xa8\x02\0\0\xee\0\0\0\xef\0\xa8\x02\xa8\x02\0\0\xa8\x02\0\0\xf0\0\xf1\0\xf2\0\xa8\x02\0\0\xf3\0\xf4\0\xf5\0\0\0\xf6\0\xf7\0\xf8\0\0\0\xf9\0\xfa\0\xfb\0\xfc\0\0\0\0\0\0\0\xfd\0\xfe\0\xff\0\0\0\0\0\0\0\0\0\0\0\0\x01\x01\x01\0\0\0\0\0\0\0\0\x02\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\x01\x04\x01\0\0\0\0\0\0\0\0\x05\x01\x06\x01\0\0\0\0\0\0\x07\x01\b\x01\0\0\t\x01\0\0\n\x01\x0b\x01\f\x01\0\0\r\x01\0\0\0\0\0\0\0\0\0\0\x0e\x01\0\0\0\0\0\0\0\0\x0f\x01\0\0\0\0\0\0\0\0\0\0\x10\x01\b\x02\0\0\x11\x01\x12\x01\b\x02\x13\x01\x14\x01\x15\x01\x16\x01\x17\x01\0\0\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\0\0\b\x02\0\0\b\x02\0\0\0\0\xf5\x01\0\0\0\0\0\0\b\x02\b\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\b\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\b\x02\b\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\b\x02\0\0\0\0\0\0\b\x02\0\0\b\x02\b\x02\b\x02\0\0\b\x02\0\0\0\0\b\x02\0\0\0\0\0\0\0\0#\x01$\x01%\x01\0\0\0\0\0\0\n\0\xe1\x01\0\0'\x01\0\0\0\0\r\0\xf5\x01\b\x02\xe2\x01)\x01\0\0\b\x02\0\0\b\x02\0\0\0\0\b\x02\0\0\0\0\0\0*\x01\xa2\0\0\0\x11\0\x12\0\b\x02\0\0\b\x02\0\0+\x01\0\0\0\0\0\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\x001\x01\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xe3\x01\xe4\x01\0\0\xe5\x01\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\x005\x016\x01\xe6\x01\xe7\x019\x01\xe8\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\xab\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0#\x01$\x01%\x01\0\0\0\0\0\0\n\0\xe1\x01\0\0'\x01\0\0\0\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0+\x01\0\0\0\0\0\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\x001\x01\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xe3\x01\xe4\x01\0\0\xe5\x01\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\x005\x016\x01\xe6\x01\xe7\x019\x01\xe8\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\xab\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\0\0\0\x01\x036\0\xac\0#\x01$\x01%\x01\0\0\0\0\0\0\n\0\xe1\x01\0\0'\x01\0\0\0\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0+\x01\0\0\0\0\0\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\x001\x01\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xe3\x01\xe4\x01\0\0\xe5\x01\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\x005\x016\x01\xe6\x01\xe7\x019\x01\xe8\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\xab\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\0\0\0\xca\x036\0\xac\0#\x01$\x01%\x01\0\0\0\0\0\0\n\0\xe1\x01\0\0'\x01\0\0\0\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0+\x01\0\0\0\0\0\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\x001\x01\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xe3\x01\xe4\x01\0\0\xe5\x01\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\x005\x016\x01\xe6\x01\xe7\x019\x01\xe8\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\xab\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\0\0\0\b\x046\0\xac\0#\x01$\x01%\x01\0\0\0\0\0\0\n\0\xe1\x01\0\0'\x01\0\0\0\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0+\x01\0\0\0\0\0\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\x001\x01\0\0\xdd\x02\xa7\0\xa8\0\0\0\0\0\0\0\n\0\0\0\xe3\x01\xe4\x01\0\0\xe5\x01\r\0*\0\0\0\0\0\0\0\0\0\0\0\0\x005\x016\x01\xe6\x01\xe7\x019\x01\xe8\x01\0\0\0\0\xa2\0\0\0\x11\0\x12\0;\x01\0\0\0\0\xab\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\xdf\x02\xa7\0\xa8\0\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0\0\0\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\xe1\x02\xa7\0\xa8\0\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0\0\0\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xa9\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\t\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\x0e\x005\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0f\0\x10\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\x17\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0!\0\0\0\0\0\"\0#\0$\0\0\0\0\0%\0&\0\0\0'\0(\0\0\0)\0\0\0*\0+\0\0\0,\0\0\0-\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\x006\x02\0\0\0\0\t\0\n\0\x0b\0\0\x001\0\0\0\f\0\r\0\x0e\x002\0\0\0\0\0\0\0\0\x003\x004\x005\x006\0\0\0\0\0\0\0\0\x007\0\x0f\0\x10\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\x17\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0!\0\0\0\0\0\"\0#\0$\0\0\0\0\0%\0&\0\0\0'\0(\0\0\0)\0\0\0*\0+\0\0\0,\0\0\0-\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\0\0\t\0\n\0\x0b\0\0\0\0\x001\0\f\0\r\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\x005\x006\0\0\0\0\0\0\0\0\x007\0\0\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\0'\0(\0\0\0\0\0\0\0*\0+\0\0\0,\0\0\0\0\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\0\0\0\0\xe6\0\t\0\n\0\x0b\0\0\0\0\0\xe9\0\f\0\r\x002\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0\0\0\0\0\0\0\0\x007\0\0\0\0\0\0\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\0'\0(\0\0\0\0\0\0\0*\0+\0\0\0,\0\0\0\0\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\t\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0\0\0\x06\x02\0\0\0\x007\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\0'\0(\0\0\0\0\0\0\0*\0+\0\0\0,\0\0\0\0\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0\0\0\xe4\x02\0\0\0\x007\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0\t\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\0'\0(\0\0\0\0\0\0\0*\0+\0\0\0,\0\0\0\0\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0\0\0\0\0\0\0\0\x007\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0\0\0\n\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0^\x03\0\0\xe4\x02C\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0_\x03\0\0\xe4\x02\x11\0\x12\0\xf3\x01\0\0\xf3\x01\xf3\x01\xf3\x01\0\0\xf3\x01\0\0\0\0\xf3\x01\xf3\x01\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\xf3\x01 \0\0\0\0\0\0\0\0\0\xa7\0`\x03\xf3\x01\xf3\x01\0\0\0\0\0\0\xa9\0\n\0\0\0\xf3\x01\0\0*\0\0\0\r\0\0\0B\x02\0\0\x17\x02C\x02\0\0\xaa\0\xf3\x01\xf3\x01\0\0\0\0\x18\x02\0\0\0\0_\x03\0\0\0\0\x11\0\x12\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0`\x03\0\0\0\0\0\0\0\0\0\0\xa9\0\n\0\0\0\0\0\0\0*\0\0\0\r\0\0\0\xb9\x03\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\xba\x03\0\0\0\0\x11\0\x12\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xd4\x01\0\0\0\0\0\0\0\0\0\0\xa9\0\n\0\0\0\0\0\0\0*\0\0\0\r\0\0\0\x92\x05\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0_\x03\0\0\0\0\x11\0\x12\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0`\x03\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0\0\0\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\x0b\x03\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0\f\x03\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xd4\x01\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0E\x05\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\x16\x02\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0\0\0\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xd4\x01\0\0\0\0\0\0\xe4\x02\0\0\xa9\0\0\0\0\0\0\0\xe4\x02*\0\0\0\0\0\0\0\0\0\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\n\0\0\0\xe4\x02\0\0\0\0\0\0\r\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\0\0\xe4\x02\0\0\xe4\x02\0\0\0\0\xe4\x02\xe4\x02\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xa9\0\0\0\0\0\0\0\n\0*\0\0\0\0\0\xdf\x01\0\0\r\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe6\0\0\0\0\0\0\0\xa2\0\xab\0\x11\0\x12\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xa9\0\xe4\x02\0\0\xe4\x02\0\0*\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\n\0\xe4\x02\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\xa2\0\xe4\x02\x11\0\x12\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\xe4\x02\0\0\xa9\0\0\0\0\0\0\0\xe4\x02*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xa1\x02\0\0\xe4\x02\0\0\0\0\0\0\xa1\x02\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\xa1\x02\0\0\xa1\x02\xa1\x02\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\xe4\x02\xe4\x02\xa1\x02\xa1\x02\xa1\x02\0\0\xa1\x02\xa1\x02\0\0\xa1\x02\xa1\x02\0\0\0\0\xa1\x02\0\0\0\0\0\0\0\0\xa1\x02\xa1\x02\0\0\0\0\0\0\x8e\x02\0\0\xa1\x02\0\0\0\0\0\0\x8e\x02\xa1\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\x02\0\0\0\0\0\0\0\0\0\0\x8e\x02\0\0\x8e\x02\x8e\x02\0\0\0\0\0\0\xa1\x02\0\0\0\0\0\0\xa1\x02\0\0\0\0\0\0\0\0\xa1\x02\0\0\0\0\xa1\x02\xa1\x02\x8e\x02\x8e\x02\x8e\x02\0\0\x8e\x02\x8e\x02\0\0\x8e\x02\x8e\x02\0\0\0\0\x8e\x02\0\0\0\0\0\0\0\0\x8e\x02\x8e\x02\0\0\0\0\0\0\n\0\0\0\x8e\x02\0\0\0\0\0\0\r\0\x8e\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8e\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\x8e\x02\0\0\0\0\0\0\x8e\x02\0\0\0\0\0\0\0\0\x8e\x02\0\0\0\0\x8e\x02\x8e\x02\x18\0\x19\0\x1a\0\0\0\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xd4\x01\0\0\0\0\0\0\0\0\0\0\xa9\0\n\0\x0b\0\0\0\0\0*\0\f\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0|\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\0\x12\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0}\x01\0\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xc0\0\0\0\0\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\0\0*\0+\0\0\0\0\0\0\0\0\0~\x01\0\0\0\0\0\0\0\0\0\x000\0\0\0\x7f\x01\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0\x80\x01\x81\x01\0\0\0\x002\0\0\0\0\0\x82\x01\0\x003\0\0\0\0\x006\0\x18\0\x19\0\x1a\0}\x01\0\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xc0\0\0\0\0\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\0\0*\0+\0\0\0\0\0\0\0\0\0~\x01\0\0\0\0\0\0\0\0\0\x000\0\0\0\x7f\x01\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x002\0\0\0\0\0\x82\x01\0\x003\0\0\0\0\x006\0\x18\0\x19\0\x1a\0\0\0\0\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xc0\0\0\0\0\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\0\0*\0+\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x000\0\0\0\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\x18\0\x19\0\x1a\0\0\0\0\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xdb\0\xc0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0*\0+\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x04\0\0\0\0\0\x000\0\0\0\0\0\xc8\0\xe4\x02\xe4\x02\x89\0\0\0\x8a\0\x8b\0 \0\x91\x04\x8c\0\0\x002\0\x8d\0\x8e\0\0\0\xc9\x003\0\0\0\0\x006\0\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\x8f\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\x90\0\x90\x03\0\0\x89\0\0\0\x8a\0\x8b\0 \0\x92\0\x8c\0\xe4\x02\xe4\x02\x8d\0\x92\x04\0\0\0\0\0\0\0\0\x90\x04\xb7\x05\x93\0\x94\0\xe4\x02\0\0\0\0\xc8\0\0\0\0\0\0\0\0\0\x8f\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\x93\x04\x90\0\x91\0\xc9\0\xe4\x02\0\0\0\0\xe4\x02\0\0\x92\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcb\0\0\0\0\0\x94\x04\x94\0\0\0\0\0\0\0\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\0\0\x8d\0\x92\x04\0\0\0\0\0\0\0\0\xd3\x03W\x01X\x01\0\0\0\0\0\0\0\0\0\0\0\0Y\x01\0\0\0\0\x8f\0\0\0\xd4\x03Z\x01[\x01\xd5\x03\\\x01\0\0\x90\0\x91\0\0\0\0\0\0\0\0\0\0\0]\x01\x92\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\x01\xcb\0\0\0\0\0\x94\x04\x94\0_\x01`\x01a\x01b\x01c\x01#\x01$\x01%\x01\0\0\0\0\0\0\0\0\xe1\x01\0\0'\x01\0\0\0\0\0\0\0\0\0\0d\x01)\x01\0\0\0\0\0\0\xb9\0\0\0\0\0\0\0\0\0e\x01f\x01*\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0+\x01g\x01h\x01i\x01j\x01k\x01,\x01-\x01.\x01/\x010\x01\0\0\0\0\xd6\x03\0\0\0\0\0\0\0\0\0\0m\x01\0\0\0\0\0\0\0\0\0\0\0\x001\x01\0\0\0\0\0\0W\x01X\x01\0\0\0\0\0\0\0\0\x10\x02\xe4\x01Y\x01\x11\x02\0\0\0\0\0\0\0\0Z\x01[\x01\0\0\\\x015\x016\x01\x12\x02\xe7\x019\x01\xe8\x01\0\0\0\0]\x01\0\0\0\0\0\0\0\0\0\0W\x01X\x01<\x01^\x01=\x01\0\0\0\0\0\0Y\x01_\x01`\x01a\x01b\x01c\x01Z\x01[\x01\0\0\\\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0]\x01\0\0\0\0d\x01\0\0\0\0\0\0\0\0\xb9\0^\x01\0\0\0\0\0\0e\x01f\x01_\x01`\x01a\x01b\x01c\x01\0\0\0\0\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01\0\0\0\0\0\0\0\0\0\0d\x01W\x01X\x01l\x01\0\0\xb9\0\0\0\0\0m\x01Y\x01e\x01f\x01\0\0\0\0\0\0Z\x01[\x01\0\0\\\x01\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01]\x01\0\0\0\0\0\0\x10\x04\0\0W\x01X\x01\0\0^\x01\0\0\0\0\0\0m\x01Y\x01_\x01`\x01a\x01b\x01c\x01Z\x01[\x01\0\0\\\x01\0\0\0\0\0\0\0\0\0\0\0\0r\x04\0\0]\x01\0\0\0\0d\x01\0\0\0\0\0\0\0\0\xb9\0^\x01\0\0\0\0\0\0e\x01f\x01_\x01`\x01a\x01b\x01c\x01\0\0\0\0\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01\0\0\0\0\0\0\0\0?\x04d\x01W\x01X\x01\0\0\0\0\xb9\0\0\0\0\0m\x01Y\x01e\x01f\x01\0\0\0\0\0\0Z\x01[\x01\0\0\\\x01\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01]\x01\0\0\0\0\0\0\0\0\0\0W\x01X\x01\0\0^\x01\0\0\0\0\0\0m\x01Y\x01_\x01`\x01a\x01b\x01c\x01Z\x01[\x01\0\0~\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0]\x01\0\0\0\0d\x01\0\0\0\0\0\0\0\0\xb9\0^\x01\0\0\0\0\0\0e\x01f\x01_\x01`\x01a\x01b\x01c\x01\0\0\0\0\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01\0\0\0\0\0\0\0\0\0\0d\x01\xea\0\xea\0\0\0\0\0\xb9\0\0\0\0\0m\x01\xea\0e\x01f\x01\0\0\0\0\0\0\xea\0\xea\0\0\0\0\0\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01\xea\0\0\0\0\0\0\0\0\0\0\0W\x01X\x01\0\0\xea\0\0\0\0\0\0\0m\x01Y\x01\xea\0\xea\0\xea\0\xea\0\xea\0Z\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0]\x01\0\0\0\0\xea\0\0\0\0\0\0\0\0\0\xea\0^\x01\0\0\0\0\0\0\xea\0\xea\0_\x01`\x01a\x01b\x01c\x01\0\0\0\0\0\0\0\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\xea\0d\x01W\x01X\x01\0\0\0\0\xb9\0\0\0\0\0\xea\0Y\x01e\x01f\x01\0\0\0\0\0\0Z\x01\0\0\0\0\0\0\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01]\x01\0\0\0\0\0\0\0\0\0\0\0\0R\x05\0\0^\x01\0\0\0\0\0\0m\x01\0\0_\x01`\x01a\x01b\x01c\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0W\x01X\x01\0\0\0\0\0\0\0\0\0\0\0\0d\x01\0\0\0\0\0\0\0\0\xb9\0Z\x01\0\0\0\0\0\0e\x01f\x01\0\0\0\0\0\0\0\0\0\0\0\0]\x01\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01^\x01\0\0\0\0\0\0\0\0\0\0_\x01`\x01a\x01b\x01c\x01\0\0\0\0m\x01\0\0\0\0\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\0\0\x8c\0d\x01\0\0\x8d\0\x8e\0\0\0\xb9\0\0\0\0\0\0\0\0\0e\x01f\x01\xc0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8f\0\0\0\0\0h\x01i\x01j\x01k\x01\0\0\x90\0\x91\0\0\0\0\0\0\0\0\0\0\0\0\0\x92\0\0\0\0\0\0\0m\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x93\0\x94\0",
  check: "\x03\0\x04\0^\0\x06\0\x02\0\x92\0\x02\0>\x01\x0f\0\x83\x01\xa3\0\x89\0\x0e\x02\x8f\0\xa4\0!\x01\n\0\x89\0\xba\x02\xc0\x01\x1d\0\x9e\0\r\x03\x8b\0\t\x02\xd1\0\t\0\xb2\x01\xd5\0\f\0a\x03\x7f\x03\x1f\0$\0\xab\0\x8f\x01\x13\0\x14\0\x15\0\x16\0V\x02\x0b\x007\x03\xf3\x02\x1b\0\xba\x02\f\x02\xd4\0\x0e\x02\xa6\x04\x01\0\"\0\x03\0\x04\0\x02\0&\0\xd1\0\f\x04\x1c\0!\0+\0,\0\xe8\0%\0\xea\0\x03\0\x04\0o\x01\x02\x004\0\x07\0\0\x007\0;\0\0\0\x93\x04\0\0\x02\x000\0\f\x02\x84\0\x0e\x02\x86\0I\x04\x1f\x01b\0\x8a\x04\x8b\x04_\0\x03\0\x02\0\x8c\x01\xbc\x04\x01\0\xd2\0B\x04\x11\x01n\x001\0\x02\0b\0\x02\0b\0U\x04C\x01\xc5\0\x01\x02\x02\x02;\0A\x01\0\0\x0f\x01n\0S\0n\0U\0V\0@\x01\0\x01%\x01\x0f\x02\xf8\x03\0\x014\x01\x07\x01\x04\x01C\x01\x82\0z\0\b\x01\x97\x04\x8c\0\n\x01`\x01Z\x01\0\x01\x0f\x01\x17\x04\x9a\x04\x12\x01\x05\x001\0\xb7\x01\0\x01\xb9\x01\0\x01\x89\0A\x01\0\x01\x07\x01b\0\x91\0\x86\x04\0\x01u\x01`\x01\0\x01\0\x01r\x01\xac\x03\0\x01\0\x01n\0C\x01b\0$\x04\0\x01\x96\0J\x02\0\x01\x11\x01\n\x01N\x02b\0\0\x01`\x01n\0\x80\0\x12\x05\x82\0\b\x01\x84\0^\x03\x86\0E\x01n\0b\0\0\x01C\x01\xc0\0\x80\0\xae\0\x82\0\xc4\0\x84\0b\0\x86\0b\0n\0\xd4\x03\xd5\x03\0\x01\0\x01\xae\x04\xbb\0\0\x01.\x05n\0\xd3\0n\0C\x01\xb9\0\xba\0A\x01`\x01\b\x02\x82\0\0\x01\xbc\0\0\x01\xd2\x04A\x01A\x01\0\x01L\x02\xa2\0\x84\x02C\x01\xa5\0\xa6\0|\x01r\x01\xd7\0\x8e\x01A\x01\xd9\x04s\x01\x0e\x01]\x01`\x01\t\0\xb2\0\xb3\0\f\0\t\x05\xe3\x04o\x01\x07\x05\xda\0`\x01\x13\0\x14\0\x15\0\x16\0\x8b\x03^\x01`\x01\x11\x05\x1b\0o\x01u\x01\0\x01`\x01\xd6\0O\x01\x88\x04^\x01o\x01o\x01&\0`\x01\xd0\0C\x01=\x02+\0,\0\xbe\x01u\x01^\x05\x04\x01o\x01^\x01v\x014\0x\x01-\x057\0\x18\x01\0\x01\x04\x01C\x01A\x01B\x01\b\x01]\x01]\x01\0\0\0\x01a\x01a\x01\x0f\x01`\x01\x16\x01\x12\x01\xbe\x04 \x01\xd6\0\x9f\x02\xde\x01\0\x02\xe0\x01\x0e\x01]\x01`\x01\x11\x01\x03\x01a\x01\xbf\x01A\x01`\x01\0\x01\x16\x01\xb7\x05\xd0\x01&\x01\0\x01\xa2\x01\0\x01K\x01C\x01@\x05N\x01\xce\x01\xdb\x04\x04\x01\x1e\x01\x1f\x01o\x01\b\x01\0\x01\x85\x02\x86\x02f\x05E\x05:\x01\x0f\x01\0\x01\0\x01\x12\x01J\x01\0\x01Q\x01C\x01\x1a\x01]\x01\xfa\x02S\x01u\x05a\x01J\x01\n\x01l\x01P\x01$\x02\0\x01p\x01\0\x01\x05\x02g\x04@\x01k\x01D\x01\x0f\x01\xa6\x02\xaa\x01\x80\x01\xac\x01\xad\x05\xae\x01 \x02\x15\x02E\x04^\x01G\x04\xff\x04\x1a\x02Q\x01\x1e\x01\x91\x01\x9a\x05w\x03\\\x01\x1a\x01`\x017\x03\n\x05T\x04C\x01\xb7\x02C\x01s\x013\x03]\x02\x91\x01M\x02\x91\x01\0\x01\0\x01\xa5\x04\0\x01C\x01}\x01~\x01]\x01\x81\x05\x81\x01s\x05\x83\x01/\x04^\x01\x93\x01^\x01\x16\x01B\x01\0\x01\0\x01\0\x01\x1b\x01\0\x01\x12\x01o\x01\x1b\x03]\x01?\x05\n\x01\0\x01\n\x01\0\x01\0\x01`\x01]\x01\xb0\x01`\x01I\x05^\x01\x11\x01\0\x01a\x01\xb7\x01\x03\x01\xb9\x01\xb2\x01\xb5\x03\x91\x01\xf4\x03\b\x01\x80\x02\0\x01\0\x01+\x05`\x01\x12\x01%\x01\x11\x01Y\x02l\x01\xc1\x01\x91\x01o\x01A\x03#\x01\b\x01\xcf\x01\x1c\x05%\x01\xaa\x01\x91\x01\xac\x01\x0f\x01\xae\x01\xbe\x03\xbf\x03\b\x01$\x01\xd3\x01\x88\x02\xf3\x04\x80\x02\xaa\x01\x91\x01\xac\x01\0\x01\xae\x01\x1e\x01\xdd\x01<\x01~\x05\x96\x02\x91\x01]\x01\x91\x01B\x01\0\x01`\x01\xef\x04`\x01\xe9\x01\x92\x03\xb9\x03\0\x01\0\x01\xac\x03\n\x01\xbe\x03\xbf\x03\xcb\x04p\x036\x01^\x01 \x01^\x01a\x01a\x01a\x01`\x01\xfc\x01\xfd\x01\0\x01|\x03B\x01\x01\x02\x02\x02^\x01\f\x02a\x01\x0e\x02\x84\x03^\x01\xa3\x02h\x01\0\x01^\x01`\x01\0\x01\x0f\x02\b\x01o\x01\xb1\x05\x16\x01\x14\x02/\x02\xd4\x03\xd5\x03`\x01`\x01\x1c\x04\0\x01\b\x01\x0f\x01\x12\x01\x0e\x01\0\x02\xbf\x04\"\x02\x0f\x01\xf6\x01\xf7\x01\xf8\x01^\x01\xc2\x02\xf2\x02l\x01\xd2\x02\xfe\x01o\x01B\x01C\x01\xc3\x02\xc4\x02\x1e\x01\xbc\x03\xe8\x02\x1b\x01\x06\x01\b\x01^\x01\x12\x01\\\x01;\x02B\x014\x02\b\x01\x1b\x01@\x02A\x01B\x01^\x01J\x01b\x05a\x01a\x02\xf2\x02\x17\x04\x1c\x02^\x01`\x01\x17\x03p\x01\0\x01d\x02C\x01b\x02c\x02\xd1\x03\x10\x01B\x01\x12\x01\x12\x01\x16\x01$\x01]\x01\xf6\x02C\x01\0\x01\x12\x01c\x01d\x01\x12\x01\r\x036\x02\x16\x01^\x01\x16\x01]\x01\xae\x02\x1b\x01=\x02`\x01`\x02`\x01\x13\x01\b\x01`\x01u\x01\x0e\x01\x16\x01\x89\x02\x8a\x02\x0f\x01]\x01\x1b\x01\0\x01I\x04\x99\x05]\x02~\x02Q\x02l\x01\x1e\x01*\x04o\x01`\x01\x0e\x04\x1e\x01`\x01\x0e\x01\x13\x02(\x05/\x01*\x05^\x01^\x01u\x01Z\x03\x12\x01\x9d\x02\0\0^\x01\x0e\x01\x12\x01\x97\x02a\x03=\x01\x12\x018\x01W\x03X\x03Y\x03\\\x01\x12\x01E\x01\xbc\x02G\x01^\x01B\x01#\x04B\x01C\x01s\x03B\x015\x02]\x01`\x01^\x01\xb7\x02a\x01\x16\x01c\x01d\x01c\x01d\x01\x04\x01a\x03B\x02C\x02?\x03]\x01B\x01C\x01\xc9\x02a\x01\x16\x01c\x01d\x01\x1b\x01u\x01`\x01\x17\x01L\x03\xeb\x03\xdc\x04\xed\x03\xee\x03\x1b\x01q\x01\xae\x02l\x01\x03\x01\x1b\x01o\x01u\x01l\x01\xe9\x02\xea\x02o\x01Q\x01\x16\x01`\x01\xae\x02\0\x01^\x01\xde\x02`\x01\xe0\x02\x1b\x01\xe2\x02\xe3\x02`\x01\x1b\x01^\x01\xa5\x04`\x01\xa4\x03\b\x01\xff\x02B\x01\xdc\x04`\x01\x13\x01\xbe\x04\x0f\x01\x17\x01\xbc\x03C\x01C\x01\x1a\x01\\\x01\f\x03\x88\x03\xfa\x02\x99\x03\x1b\x01\xcf\x02\xfe\x02\b\x01\x1e\x01\xd3\x02\x95\x03\x13\x01\xd2\x04B\x01\x0f\x01\xc0\x05`\x01Z\x01`\x01/\x010\x01\xdb\x04\xdc\x04\x0f\x03\x11\x01;\x02\xbc\x03\x1b\x01\x03\x01\x1e\x01`\x01\b\x016\x01=\x01\xa4\x02\0\x01A\x01\xe7\x03B\x01\x02\x01 \x03E\x01\xc0\x05G\x01B\x01\0\x01`\x01n\x01\x04\x01\x03\x01`\x01r\x01\b\x01\x13\x01$\x01/\x030\x03\x03\x03\x0e\x01\x0f\x01D\x01\xf3\x04\x12\x01\xc1\x02\x13\x01B\x01:\x03J\x03<\x03J\x03\b\x01\x1a\x01T\x03`\x01C\x01C\x03D\x03\x0e\x04Q\x03G\x03\\\x03/\x010\x01_\x03\x0e\x01q\x01l\x01\xd9\x02w\x03o\x01\x0e\x01D\x01/\x010\x01C\x01=\x01`\x01\x1b\x01\xe5\x04\x0e\x01A\x01B\x01?\x01E\x01C\x01G\x01=\x01l\x01\x0e\x04\r\x05o\x01C\x01\x1b\x01D\x01E\x01a\x01G\x01C\x01D\x01\0\0\0\x01?\x05@\x05\x0e\x01\x04\x01A\x01\x1d\x04\0\0\b\x01\x03\x01D\x01I\x05\x0e\x01}\x03\x0e\x01\x0f\x01\x88\x03#\x01\x12\x01\x83\x03`\x01\x90\x03B\x01C\x01u\x01\x1b\x01S\x04q\x013\x04b\x01\xb5\x03Q\x01\x03\x01]\x01\x92\x03\0\x01A\x01B\x01q\x01\x04\x01\x98\x03\xa1\x03<\x01\b\x01A\x01\n\x01Q\x01u\x01B\x01\x0e\x01\x0f\x01\xa3\x037\x04\x12\x01\xa6\x03B\x01\x0f\x01S\x04r\x01\x12\x01\xb7\x03\x1b\x01\x1b\x01\xaf\x03~\x05b\x01\x16\x01C\x01\\\x05\0\0E\x04\xbf\x03R\x04\xcd\x03\xce\x03\f\x01E\x04g\x04\x0e\x01Q\x01h\x05-\x01.\x01p\x01^\x04\xc5\x03h\x01\xdb\x03\xb5\x05\xb6\x05o\x01\x1b\x01\b\x01o\x01\x1f\x01q\x01`\x01A\x01\xd2\x03\x9b\x01^\x03C\x01C\x01\xd7\x03\xec\x03\xab\x03\xba\x03e\x03C\x01J\x01B\x01\r\x011\x012\x013\x01\xb1\x05\0\x01\xe5\x03A\x01]\x01\x03\x01U\x01A\x01a\x01\\\x01\xda\x05\x1c\x01\x1d\x01]\x01^\x01B\x01`\x01a\x01L\x01\n\x04H\x01\xa0\x05\xa1\x05f\x01)\x01M\x01\xcf\x03\x1a\x01o\x01\x04\x01\x01\x04\0\0\x1d\x04\b\x01V\x01s\x01\x0e\x01c\x01\x1b\x01\x05\0\x0b\x04\x07\0(\x01\x12\x01=\x01C\x01\xe3\x03@\x01[\x05o\x01\xde\x04g\x01E\x01\x18\x04\x19\x04\xc2\x05r\x01\x17\0K\x01\x04\x01\0\x01 \x04\xf3\x03\b\x01A\x01R\x010\x04&\x04`\x01A\x01\x0f\x01*\x04#\x01\x12\x01`\x01\0\x01\x16\x01\xd8\x05C\x01\x13\x018\x01\xde\x04\x1b\x01o\x01<\x01\n\x01\x1a\x01\x1b\x01;\x04A\x01E\x04\xe6\x05C\x01n\x01\0\0u\x01\\\x01<\x01\xef\x04J\x01\x0e\x01A\x01Z\x01B\x01P\x01A\x01M\x04/\x010\x01A\x01o\x01f\x04\x1c\x05\x1b\x01i\x04o\x01p\x01\xe2\x03Y\x04^\x01B\x01=\x01C\x01\xe8\x03A\x01\xea\x03r\x01A\x01D\x01E\x01`\0G\x01Z\x04|\x04}\x04o\x01A\x01\xf6\x03A\x01\0\0\0\x01h\x01\x16\x01\x1c\x05s\x04\x1f\x01U\x04o\x01o\x01\x90\x04\x1b\x01o\x01B\x01\r\x01\\\x01o\x01p\x01\x80\x04c\x01\x82\x04\x83\x04\x84\x04\x9d\x041\x012\x013\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01o\x01\x89\0X\x05q\x01p\x01A\x01\x8e\0\x8f\0\x95\x04\0\x01\xab\x04)\x01o\x018\x01o\x01\x1b\x01A\x01\x16\x01D\x01:\x05C\x01M\x01A\x01\xbc\x04A\x01\x86\x04\xa2\0\xa3\0G\x05\xa5\0\xa6\0=\x01\xa8\0X\x05@\x01\x1a\x01A\x01C\x01D\x01E\x01\0\x01\0\x01\xb2\0\xb3\0\x04\x01K\x01\xbb\x04A\x01\b\x01\x04\x01\n\x01o\x01R\x01\b\x01\x0e\x01C\x01\x1f\x01A\x01\x12\x01\x0e\x01\x0f\x01B\x01o\x01\x12\x01^\x01\xce\x04`\x01\x1b\x01b\x01c\x01o\x01\xdc\x04\xd0\0\xd1\x001\x012\x013\x01\xd5\0%\x01\xf0\x04n\x01h\x04o\x01q\x01\xe1\x04l\x04A\x01u\x01f\x01\0\x05\x1b\x01#\x01\x03\x05\xea\x04\x05\x05\x04\x01\x04\x01\xee\x04\x1b\x01\b\x01\b\x01\xe5\x04M\x01o\x01\x16\x01\xc8\x04\x0f\x01\x10\x05\xd9\x04\x12\x01\x12\x01\xfc\x04C\x01A\x01J\x01A\x01<\x01\0\x01\xe3\x04A\x01B\x01\x04\x01B\x01\b\x05\x93\x04\b\x01H\x01\n\x01\r\x05\x1b\x01C\x01\x0e\x01o\x01]\x01^\x01,\x05`\x01a\x01C\x01\x04\x01V\x01\0\0\x1b\x05\b\x01\x1b\x01\xa8\x04\\\x01 \x05B\x01\0\x01\x0f\x01\0\x01`\x01\x12\x01A\x01s\x01\x16\x01#\x01C\x01o\x01h\x01o\x01>\x05r\x01>\x05o\x01p\x01o\x015\x05C\x01\0\x01K\x014\x01N\x05;\x05V\x05W\x05\x1a\x01\xac\x05Z\x05A\x05\x03\x01<\x016\x01_\x058\x01%\x01A\x01B\x01\xd4\x04C\x01J\x01M\x05\r\x01A\x01B\x01\x1a\x01K\x01S\x05C\x01o\x01\x12\x01C\x01\0\x01Q\x01n\x05n\x01\\\x05\x1c\x01\x1d\x01]\x01^\x01H\x01`\x01a\x01d\x05E\x05U\x01(\x01h\x05\x83\x05)\x01\x13\x01e\x01m\x05\0\0V\x01\xfa\x04\0\x01\x1a\x01\x1b\x01o\x01s\x01o\x01\x16\x01\0\x01y\x05\\\x01\r\x01\x1b\x01o\x01=\x01\0\x01o\x01@\x01\x96\x05Z\x01\x0e\x05C\x01E\x01/\x010\x01\x89\x05\x1c\x01\x1d\x01K\x01\x17\x01p\x01\xa3\x05\x1a\x05\xab\x05\x1a\x01R\x01\x8f\x01=\x01%\x01)\x01\0\x01\x1a\x01$\x01r\x01D\x01E\x01\x17\x01G\x01\xa0\x05\xa1\x05\x04\x01b\x01c\x018\x01\b\x01`\x01\xa8\x053\x05\xbe\x05=\x01!\x01\x0f\x01@\x01n\x01\x12\x01\xcb\x05\xcc\x05E\x01\0\x01\xb0\x01C\x01A\x01\xb8\x05K\x01\x0e\x01\xbb\x05\xb7\x01%\x01\xb9\x01\xd3\x05R\x01\xc1\x05\xc2\x058\x01\xbf\x01\0\x01B\x01<\x01U\x01q\x01\0\x01@\x01A\x01B\x01\x1a\x01A\x01b\x01c\x01\0\x01\xce\x01\xcf\x01\xd5\x05\xea\x05\xe3\x03\xd8\x05\xd4\x01L\x01P\x01n\x01\xdd\x05\x16\x01\x1a\x01\xe0\x05C\x01\0\0a\x01\x1a\x01\xe5\x05\xe6\x05\xf3\x03\xe8\x05\xe9\x05B\x01]\x01\x1a\x01c\x01d\x01\x1b\x01H\x01a\x01\0\x01B\x01\x1b\x016\x01\x80\x058\x01\0\x01H\x01o\x01\xf6\x01\xf7\x01\xf8\x01V\x01u\x01A\x01B\x01\x04\x01\xfe\x01\x12\x01!\x01\b\x01V\x01\x92\x05\x0e\x01\x94\x05\x13\x01\x11\x01\x0f\x01a\x01\0\0\x12\x01\f\x02\x1a\x01\x0e\x02\x9e\x05\x16\x01\x1b\x01A\x01\x13\x02\x1b\x01\x15\x02\x16\x028\x01\x16\x01\0\x01\x1a\x02<\x01\x1c\x02L\x01_\x01@\x01A\x01B\x01/\x010\x01$\x02o\x01\xb5\x05\xb6\x05\0\x01o\x01(\x01`\x01\x13\x01\xbc\x05\x10\x01P\x01=\x01_\x01\n\x01\x1a\x01B\x015\x026\x02D\x01E\x01\x1b\x01G\x01o\x01C\x01=\x02\xcd\x05B\x01n\x01o\x01B\x02C\x02\x03\x01\xd4\x05\0\x01J\x01/\x010\x01C\x01\xda\x05L\x02M\x02o\x01\xde\x05\n\x01Q\x02K\x01o\x01\xe3\x05\xe4\x05=\x01\x04\x01`\x01R\x01n\x01\b\x01U\x01D\x01E\x01)\x02G\x01A\x01\x0f\x01-\x02q\x01\x12\x01A\x01o\x01p\x01\0\x01\x01\x01\x02\x01\x03\x01\0\x01\x1b\x01A\x01B\x01\b\x01\t\x01\n\x01o\x01\b\x01\r\x01\x0e\x01\x0e\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\0\0\x80\x02\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01B\x01C\x01D\x01q\x01_\x01o\x01$\x01%\x01A\x01B\x01(\x01)\x01*\x01+\x01^\x01C\x01\b\x01/\x010\x01n\x01o\x01B\x01C\x01\0\x01\x9f\x02C\x01D\x01\0\x01\x0e\x01\xa4\x02$\x01=\x01>\x01a\x01@\x01\x18\x02\x19\x02C\x01D\x01E\x01J\x01G\x01\x13\x01\x0e\x01J\x01K\x01\x13\x01\x16\x01\xb7\x02\x1a\x01o\x01\xba\x02R\x01\x1a\x01T\x01\\\x01\x16\x01\x1b\x01\xc1\x02\0\x01\xc3\x02\xc4\x02a\x01]\x01^\x01a\x01`\x01a\x01b\x01c\x01/\x010\x01\xcf\x02`\x01/\x01i\x01\xd3\x02k\x01\x13\x01\0\x01n\x01A\x01\xd9\x02q\x01=\x01\x1a\x01\0\x01u\x01=\x01\x03\x01\0\0D\x01E\x01o\x01G\x01D\x01E\x01i\x01G\x01\r\x01\x0e\x01^\x01o\x01^\x01B\x01^\x01/\x01\xf2\x02\xf3\x02`\x01u\x01\x1b\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01u\x01\x14\x01.\x01\x0e\x01=\x01A\x01\x16\x01?\x01\x03\x03Q\x01(\x01)\x01E\x01A\x01G\x01\0\x01\x0b\x03\x0e\x01\r\x03\x04\x01q\x01\x0e\x01\x16\x01\b\x01q\x01\n\x01\x02\x01J\x01\x17\x03\x0e\x01\x0f\x01=\x01\x1b\x03\x12\x01@\x01L\0B\x01C\x01D\x01E\x01u\x01`\x01\x1b\x01J\x01f\x01K\x016\x017\x018\x019\x01\x0f\x01\0\0R\x01B\x01^\x01A\x01q\x01A\x01B\x01\\\x01J\x01f\x01`\x01A\x01^\x01^\x01`\x01l\0b\x01c\x01A\x03A\x01\b\x01\x0e\x01\0\x01\x1b\x01X\x01\x1b\x01\x1b\x01\x1e\x01n\x01A\x01C\x01q\x01A\x01~\0\x0e\x01u\x01^\x01J\x01o\x01\x03\x01\x85\0\x13\x01\0\0Z\x03\x0e\x01X\x011\x01^\x03\x1a\x01`\x03a\x03o\x01A\x01\x06\x01e\x03n\x01]\x01^\x01J\x01`\x01a\x01o\x01A\x01B\x01\x1b\x01p\x03a\x01`\x01s\x03/\x010\x01g\x01\x1b\x01\x0e\x01`\x01A\x01`\x01|\x03s\x01(\x01\0\x01Z\x01\x15\x01=\x01\x04\x01\x84\x03A\x01\x1b\x01\b\x01\x88\x03\n\x01E\x01\x8b\x03G\x01\x0e\x01\x0f\x01A\x01?\x01?\x01\x10\x01g\x01\r\x01\x95\x03?\x01\x0e\x01l\x01\x03\x01\x1b\x01o\x016\x017\x018\x019\x01\x0e\x01\xa1\x03B\x01\x1c\x01\x1d\x01A\x01\x1b\x01A\x01B\x01\xd7\0`\x01\xab\x03J\x01f\x016\x01`\x01)\x01J\x01\b\x01\x16\x01\0\0`\x01q\x01\x10\x01`\x01\xb9\x03\xba\x03L\x01\xbc\x03L\x01\xbe\x03\xbf\x03\x1b\x01`\x01C\x01\x07\0=\x01J\x01\x1b\x01\x0e\x01\x14\x01J\x01Z\x01\0\x01E\x01r\x01`\x01\xcf\x03J\x01\xd1\x03K\x01\x17\0`\x01o\x01A\x01r\x01\x1c\0R\x01\x0e\x01]\x01]\x01^\x01\x13\x01`\x01a\x01\0\x01\xe2\x03\xe3\x03\x03\x01\x1a\x01J\x01\xe7\x03\xe8\x03b\x01\xea\x03\x15\x01\x0e\x01\x0e\x01\r\x01\x0e\x01\x0e\x01\x0e\x01s\x01\xf3\x03\x1b\x01n\x01\xf6\x03\x13\x01q\x01Z\x01/\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x01\0\x02\0\x03\0\x04\0\x05\0\x06\0\x07\0r\x01\x0e\x01=\x01(\x01)\x01\x1b\x01]\x01\x0e\x01\x0e\x04D\x01E\x01\x16\x01G\x01\x0f\x01\x0e\x01\0\0\x0e\x01\x17\x04a\x01\0\0\0\0o\x01b\x01b\x01=\x01^\x01o\x01@\x01\b\x01#\x04R\x01D\x01E\x01A\x01^\x01$\x01\\\x01$\x01K\x01^\x01\0\x01/\x04,\x01-\x01.\x01R\x01`\x01J\x01\b\x017\x046\x01A\x01\x16\x01\r\x01q\x01A\x01A\x01^\x016\x01`\x01B\x04b\x01c\x01E\x04]\x01G\x04\x1a\x01I\x04\x1c\x01\x1d\x01H\x01I\x01\x92\0n\x01A\x01A\x01q\x01S\x04T\x04U\x04u\x01)\x01A\x01U\x01V\x01W\x01X\x01A\x01\xa2\0\xa3\0\xa4\0\xa5\0\xa6\0A\x01\xa8\0\x93\x01\r\x01g\x04h\x04\x80\0f\x01=\x01l\x04\x1c\x04\xb2\0\xb3\0\xde\x04C\x01D\x01E\x01Z\x04\x1c\x01\x1d\x01V\x04\x8e\x01K\x01\x80\x05X\x058\x05\xab\x01\xc7\x03\t\x03R\x018\x01)\x01:\x01;\x01<\x01\x86\x04>\x01`\x02\xa4\x01A\x01B\x01\xd0\0\xd1\0\x82\x01\xff\x01b\x01\xd5\0\x92\x04\x93\x04a\x02\xcf\x03=\x01=\x02\xd2\x02@\x01\xa6\0b\x04n\x01c\0E\x01q\x01f\x03\xc0\x05\xbc\x04\x1f\x04K\x01\\\x01\x12\x05\xcf\x01\xa8\x04\xff\xff\0\0R\x01c\x01\xc6\x04\xae\x04\x07\0\xbc\x02\xff\xff\xff\xff\x0b\0\0\x01\xff\xff\xff\xff\x03\x01o\x01p\x01\xff\xffb\x01c\x01\xff\xff\xbe\x04\xbf\x04\xff\xff\r\x01\xff\xff\xff\xff\x1c\0\x11\x01\xff\xffn\x01\xc8\x04\xff\xff\x16\x01\xcb\x04\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xd2\x04\xff\xff\xd4\x04\xff\xff\xff\xff\xff\xff0\0\xd9\x04\xff\xff\xdb\x04\xdc\x04)\x01\xde\x04\xff\xff\xff\xff\xff\xff\xff\xff\xe3\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xef\x044\x01=\x01\xff\xff\xff\xff@\x01\xff\xffB\x01C\x01D\x01E\x01\xfa\x04S\0\xff\xffU\0V\0K\x01\xff\xffE\x01\xff\xff\xff\xffH\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x0e\x05\xff\xff\xff\xff\xff\xff^\x01\xff\xff`\x01\0\x01b\x01c\x01\xff\xff\x04\x01\x1a\x05\xff\xff\x1c\x05\b\x01\xff\xff\n\x01\xff\xffO\x02n\x01\x0e\x01\0\x01q\x01T\x02\x12\x01(\x05u\x01*\x05o\x01\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff3\x05\xff\xff\xff\xff\xff\xff\x13\x01|\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff\x1a\x01?\x05@\x05\xff\xff\xff\xff\xff\xff\xff\xffE\x05\xff\xff\xff\xff\xff\xffI\x05\xa2\0\xa3\0\xff\xff\xa5\0\xa6\0\xff\xff\xa8\0\x7f\x02\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xffX\x05\xff\xff\xb2\0\xb3\0\xff\xff\xff\xff\xff\xffJ\x01\xa4\x01=\x01\xff\xff\xff\xff\xbc\0\xff\xff\xff\xff\xff\xff\xff\xffE\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xa2\x02`\x01a\x01\xff\xff\xd0\0\xd1\0\xff\xff\xff\xff\xff\xff\xff\xff~\x05\xff\xff\x80\x05\x81\x05\xda\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffs\x01\xff\xff\xff\xff\xff\xff\xd0\x01\xff\xff\xff\xff\xff\xff\xd4\x01\xff\xff\x92\x05\xff\xff\x94\x05q\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9e\x05\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\xff\xff\xff\xff\xff\xff\xb1\x05\xf6\x01\xf7\x01\xf8\x01\xb5\x05\xb6\x05\r\x01\xff\xff\xff\xff\xfe\x01\xff\xff\xbc\x05\0\x01\xff\xff\xff\xff\xc0\x05\x05\x02\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\r\x02\xff\xff\xff\xff\0\0\xcd\x05&\x01\xfd\x02\x13\x01\x15\x02\x16\x02)\x01\xd4\x05\xff\xff\x1a\x02\x1a\x01\x1c\x02\xff\xff\xda\x05\xff\xff\xff\xff\xff\xff\xde\x05\xff\xff$\x02\xff\xff:\x01\xe3\x05\xe4\x05)\x02\xff\xff=\x01\xff\xff-\x02\xff\xff\xff\xff/\x01\xff\xffD\x01E\x01\xff\xff\xff\xff6\x02\0\0\xff\xffK\x01\xff\xff\xff\xff\xff\xff=\x02=\x01\x06\x01R\x01\b\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xff5\x03\xff\xffM\x02`\x01\xff\xffb\x01Q\x02\xff\xff\xff\xff\xff\xff\xff\xff@\x03\xff\xffB\x03\xff\xff\xff\xffo\x01n\x01\xff\xff\xff\xffq\x01`\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff}\x01~\x01\xff\xff\xff\xff\x81\x01\xff\xff\x83\x01\xff\xff8\x01q\x01:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xffg\x03\0\x01\xff\xff\x80\x02\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\xff\xff\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01~\x03\\\x01\x18\x01\x19\x01\x1a\x01\x83\x03\x1c\x01\x1d\x01c\x01\xff\xff\xff\xff\xff\xff\xa0\x02\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01o\x01p\x01\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xd4\x01\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xcf\x02R\x01\xbb\x03\xd2\x02\xd3\x02\xff\xff\xff\xff\xc0\x03\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xf6\x01\xf7\x01\xf8\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xfe\x01\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xf2\x02u\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\r\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x15\x02\x16\x02\x03\x03\xff\xff\xef\x03\x1a\x02\xff\xff\x1c\x02\xff\xff\xff\xff\x0b\x03\xff\xff\r\x03\xff\xff\xff\xff\0\x01\0\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x17\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\0\x006\x02\xff\xff\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff=\x02\x1a\x01\x1a\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff4\x03\xff\xff \x04\0\x01\xff\xff)\x01\xff\xff\x04\x01&\x04Q\x02\xff\xff\b\x01/\x01\n\x01\xff\xff\xff\xff\xff\xff\x0e\x01\xff\xff\xff\xff\xff\xff\x12\x01\xff\xff\xff\xff`\x02=\x01=\x01\xff\xff@\x01\xff\xff\x1b\x01\xff\xff\xff\xffE\x01E\x01\xff\xffG\x01\xff\xffZ\x03K\x01\xff\xff\xff\xff\xff\xff\xff\xff`\x03a\x03R\x01\xff\xff\xff\xff\xff\xff\x07\0\xff\xff\xff\xff\xff\xff\x0b\0\xff\xff\x80\x02\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01s\x03\xff\xff\xff\xffv\x03\xff\xff\xff\xffc\x04C\x01\x1c\0\xff\xff\xff\xffn\x01\xff\xff\xff\xffJ\x01q\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff0\0\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01\x99\x03\xff\xff\x85\x04\xff\xff\x87\x04\xff\xff\x89\x04\xff\xff\xff\xff\x8c\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffs\x01\xab\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9b\x04S\0\xff\xffU\0V\0\xff\xff\xff\xff\0\x01\xff\xff\xba\x03\xcf\x02\xbc\x03\xff\xff\xff\xff\xd3\x02\xff\xff\xff\xff\xac\x04\xad\x04\xff\xff\r\x01\xff\xff8\x01\xb2\x04:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xcf\x03A\x01B\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xf2\x02P\x01\xff\xff)\x01S\x01\xe3\x03\xce\x04\xff\xff\xff\xff\xe7\x03\x89\0\xff\xff[\x01\\\x01\xff\xff\xff\xff\xff\xff\x03\x03\xff\xff\xff\xffc\x01\xf3\x03\xff\xff=\x01\xff\xff\x0b\x03\xff\xff\r\x03\xff\xffC\x01D\x01E\x01o\x01p\x01\xff\xff\xa2\0\xa3\0K\x01\xa5\0\xa6\0\xff\xff\xa8\0\xff\xff\xff\xffR\x01\x07\0\xff\xff\xff\xff\x0e\x04\xff\xff\xff\xff\xb2\0\xb3\0\xff\xff\x10\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffb\x01\xbc\0\xff\xff\x1d\x04\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\xff\xffn\x01\xff\xff\x12\x05q\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xd0\0\xd1\0\xff\xff\x11\x013\x04\xff\xff\xff\xff \x05\x16\x01\xff\xff\xda\0\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff.\x05\xff\xff\xff\xff1\x05\xff\xff\xff\xff)\x01\xff\xff`\x03a\x03\xff\xff\xff\xff\xff\xff\xff\xff\0\x01S\x04\xff\xffU\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xffB\x01C\x01D\x01E\x01g\x04d\0\xff\xff\xff\xffU\x05K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0^\x01\xff\xff`\x01\xff\xffb\x01c\x01&\x01\x86\x04\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01n\x01>\x01`\0q\x01A\x01B\x01\xff\xffu\x01\xab\x03\xff\xff:\x01\x84\x05\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xa2\0\xa3\0\xbc\x03\xa5\0\xa6\0\xff\xff\xa8\0[\x01\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xb2\0\xb3\0\xff\xff\xff\xff\xff\xff\xcf\x03\xff\xff\xa7\x05\xa8\x05\xff\xffn\x01o\x01p\x01\x07\0\xff\xff\xaf\x05\0\x01\xff\xff\xc8\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffo\x01\xe3\x03\xff\xff\xff\xff\xff\xff\xff\xff\xd0\0\xd1\0\r\x01\xff\xff\xff\xff\xd9\x04\0\x01\xff\xff}\x01~\x01\xde\x04\xf3\x03\x81\x01\xff\xff\x83\x01\xe3\x04\xff\xff\x1c\x01\x1d\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xef\x04\xff\xff\xff\xff)\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xe2\x05\xff\xff\x0e\x04\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01)\x01>\x01\xff\xff=\x01A\x01B\x01@\x01\xff\xff\0\0\xff\xff\xff\xffE\x01\xb0\x01\xff\xff\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xb7\x01=\x01\xb9\x01S\x01@\x01R\x01\x1c\x05\xff\xffD\x01E\x01\xff\xff[\x01\\\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xffb\x01R\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xd4\x01\xff\xffo\x01p\x01n\x01^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xffS\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffE\x05Z\x04G\x05n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffg\x04\xff\xff\xf6\x01\xf7\x01\xf8\x01X\x05\xff\xffV\x01\x1c\x01\x1d\x01\xfe\x01\xa2\0\xa3\0\xff\xff\xa5\0\xa6\0\xff\xff\xa8\0\xff\xff\xff\xffg\x05)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xb2\0\xb3\0\xff\xff\xff\xff\0\0o\x01\x15\x02\x16\x02\xff\xff\xff\xff\xff\xff\x1a\x02\xff\xff\x1c\x02=\x01\x06\x01\0\x01@\x01\xff\xff\x03\x01\xff\xff\xff\xffE\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\r\x01\xd0\0\xd1\0\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff6\x02\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01=\x02\xff\xff\xff\xff\x9f\x05\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff8\x01Q\x02:\x01;\x01<\x01\xc8\x04>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff=\x01\xff\xff\xff\xff@\x01`\x02\x8f\x01C\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\xde\x04\xff\xff\x0f\x01\xff\xff\xff\xff\xff\xffR\x01\xe5\x04\xff\xff\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xd4\x01\xff\xffc\x01\xef\x04^\x01\xff\xff`\x01\x80\x02b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xffo\x01p\x01+\x01,\x01-\x01.\x01n\x01\xff\xff\xff\xffq\x01\xff\xff\xc0\x01\xff\xffu\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf5\x01\xf6\x01\xf7\x01\xf8\x01\xcc\x01\xff\xff\xff\xffC\x01\xff\xff\xfe\x01\xff\xff\0\x01H\x01I\x01\xff\xff\x1c\x05\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\xff\xff\xff\xff\xff\xffU\x01V\x01W\x01X\x01\xb7\x02\0\0\r\x01\x15\x02\x16\x02\xff\xff\xff\xff\xff\xff\x1a\x02\xff\xff\x1c\x02\xff\xff\xff\xfff\x01\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xffo\x01(\x02\xff\xff\xcf\x02\xff\xff\xff\xff\xff\xff\xd3\x02\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff6\x02\xff\xff8\x01\xff\xff:\x01;\x01<\x01=\x02>\x01\xff\xffX\x05A\x01B\x01\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xf2\x02\xff\xffg\x05\xff\xffQ\x02K\x01S\x01\xff\xff\xff\xff\0\0\xff\xff\xff\xffR\x01\xff\xff[\x01\\\x01\xff\xff\x03\x03\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xff\xff^\x01\x0b\x03`\x01\r\x03b\x01c\x01\xff\xff\x06\x01\xff\xff\0\x01o\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01L\x02\xff\xff\r\x01u\x01\xff\xff\xff\xff\xff\xff\x80\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9f\x05\x1a\x01\xff\xff\x1c\x01\x1d\x01\xd4\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\0\0>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff=\x01\xff\xff\xff\xff\xf6\x01\xf7\x01\xf8\x01\xff\xffD\x01E\x01\xff\xff\xff\xff\xfe\x01\xff\x01\xff\xffK\x01\xff\xff`\x03a\x03\xff\xff\xff\xff\xff\xffR\x01\xff\xff\\\x01\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xffc\x01\xff\xff\xff\xff\x9f\x02\x15\x02\x16\x02\xcf\x02b\x01\xff\xff\x1a\x02\xd3\x02\x1c\x02o\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\x88\x03\xff\xff\xff\xff\xff\xff\xff\xff\x8d\x03\xff\xff\xff\xff\x1e\0\x1f\0\xff\xff6\x02\xff\xff\xff\xff\xff\xff\xf2\x02\xff\xff\xff\xff=\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\x03\x03>\x01\xff\xff\xab\x03A\x01B\x01Q\x02\xff\xff\x0b\x03\xff\xff\r\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\xbc\x03\xff\xffS\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\r\x01[\x01\\\x01\xff\xffW\0X\0\xff\xff\xff\xff\xff\xffc\x01\xcf\x03\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xffo\x01p\x01\xff\xff\x80\x02\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xe3\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf3\x03\0\0=\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xffE\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xffK\x01\xff\xff`\x03a\x03\xff\xff\r\x017\x03R\x01\xff\xff\xff\xff\xff\xff\x0e\x04\xff\xff\xff\xff\xff\xff\xff\xffA\x03\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xffb\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\x86\x03\xcf\x02-\x04\xff\xff\xff\xff\xd3\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffp\x03\xff\xff\xff\xffE\x04K\x01\x06\x01\0\x01\b\x01\xff\xff\xff\xff\xff\xffR\x01|\x03\xf2\x02\xab\x03\xff\xff\xff\xffS\x04\xff\xff\r\x01\x84\x03\xff\xff\xff\xff^\x01Z\x04`\x01\xff\xffb\x01c\x01\xff\xff\x03\x03\xbc\x03\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xffg\x04\x0b\x03n\x01\r\x03\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01)\x01\xff\xff\xff\xff\xcf\x03\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\xac\x03>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff=\x01\xff\xff\xff\xff\xe3\x03\xff\xff\xff\xff\xb9\x03\xff\xffE\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01S\x01\xff\xff\xff\xff\xff\xff\xf3\x03\xff\xffR\x01\xff\xff[\x01\\\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xd1\x03c\x01\xff\xff\xd4\x03\xd5\x03\xff\xff\xff\xffb\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffo\x01p\x01\xff\xff\x0e\x04\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff`\x03a\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xc8\x04W\x01X\x01Y\x01Z\x01[\x01\\\x01]\x01^\x01_\x01`\x01a\x01b\x01c\x01d\x01e\x01f\x01g\x01h\x01i\x01j\x01k\x01\xde\x04m\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe5\x04\xff\xff\xff\xff\xff\xff\x17\x04\xff\xff\xff\xff\xff\xff{\x01\xff\xff\xef\x04\xff\xff\xff\xff\xff\xff\xff\xff\0\x01#\x04\x02\x01\x03\x01S\x04\x87\x01\xff\xff\xff\xff\b\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\x11\x01\x12\x01\x13\x01\xab\x03\xff\xff\xff\xff\xff\xffg\x04\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xffB\x04\xff\xff\xff\xff\xff\xff$\x01\xbc\x03\xff\xff\xff\xff\x1c\x05)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xcf\x03\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xffK\x01\xe3\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf3\x03]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01X\x05\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\x0e\x04\xff\xff\xc8\x04\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\xa5\x04>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xae\x04\xff\xff\xff\xff\xde\x04\xff\xff\xb3\x04\xb4\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xff\xbe\x04\xff\xff\xff\xff!\x02\xef\x04[\x01\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x02c\x01\0\x01\xff\xff.\x02\x03\x01\xff\xff1\x02\xff\xff\xff\xff\b\x01\xff\xff\n\x01o\x01p\x01\r\x01\x0e\x01\xdb\x04\xff\xff\x11\x01S\x04\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\0\0\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x05\xff\xff%\x01g\x04\xf3\x04(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffb\x02c\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x88\x02]\x01^\x01X\x05`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x018\x05\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff?\x05\xff\xffu\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffI\x05\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xc8\x04:\x01;\x01<\x01\0\x01>\x01\xff\xff\x03\x01A\x01B\x01\xff\xff\xff\xff\b\x01\xff\xff\n\x01\xff\xff\0\0\r\x01\x0e\x01\xff\xff\xff\xff\x11\x01\xde\x04\x13\x01\x14\x01\x15\x01S\x01\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01[\x01\\\x01\xff\xff\xff\xff\xff\xff\xef\x04\xff\xff%\x01c\x01~\x05(\x01)\x01\x81\x05\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xe8\x02o\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x05\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xb1\x05\x12\x03\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff6\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffX\x05\xff\xff\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xffn\x03(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01?\x01@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\xff\xfff\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\0\0n\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\x04\x01\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xda\x03\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\xff\xfff\x01g\x01\0\0i\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xffr\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01~\x04\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xaf\x04\xb0\x04\xb1\x04u\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\x04\x01\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\x04\x01\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\xff\xff\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\x04\x01\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\0\0\xff\xff\xff\xfff\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\x04\x01\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\0\0\xff\xff\xff\xfff\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff4\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01\xff\xff\xff\xffi\x01j\x01k\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff4\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01\xff\xff\xff\xffi\x01j\x01k\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\0\0\xff\xff\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\0\0\xff\xff\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01\xff\xff\xff\xffX\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xff\0\0D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\t\x01\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\0\0D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\0\x01\xff\xffq\x01\x03\x01\xff\xff\xff\xffu\x01\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\0\0\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\xff\xff\x03\x01i\x01\xff\xffk\x01\xff\xff\b\x01n\x01\n\x01\xff\xffq\x01\r\x01\x0e\x01\xff\xffu\x01\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\xff\xff\x03\x01i\x01\xff\xffk\x01\xff\xff\b\x01n\x01\n\x01\xff\xffq\x01\r\x01\x0e\x01\xff\xffu\x01\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\xff\xff\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\xff\xff\x03\x01i\x01\xff\xffk\x01\xff\xff\b\x01n\x01\n\x01\xff\xffq\x01\r\x01\x0e\x01\xff\xffu\x01\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\0\0@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\0\0\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\xff\xff\x03\x01i\x01\xff\xffk\x01\xff\xff\b\x01n\x01\n\x01\xff\xffq\x01\r\x01\x0e\x01\xff\xffu\x01\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\xff\xff\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\0\x01q\x01\x02\x01\x03\x01\x04\x01u\x01\xff\xff\xff\xff\b\x01\0\x01\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01$\x01\x1c\x01\x1d\x01\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x018\x01)\x01:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff=\x01\xff\xff\xff\xff@\x01A\x01\xff\xffC\x01D\x01E\x01=\x01G\x01\0\0@\x01J\x01K\x01\xff\xffD\x01E\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xffK\x01\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01c\x01]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xfff\x01^\x01o\x01p\x01\xff\xffb\x01c\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\0\x01\xff\xffu\x01\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\xff\xff\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\0\x01q\x01\x02\x01\x03\x01\x04\x01u\x01\xff\xff\xff\xff\b\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xff\xff\xff\b\x01n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xffu\x01\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\xff\xff\0\x01f\x01\x02\x01\x03\x01\x04\x01\xff\xff\xff\xff\xff\xff\b\x01n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xffu\x01\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\xff\xff\xff\xfff\x01\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xffn\x01\b\x01\xff\xffq\x01\xff\xff\xff\xff\r\x01u\x01\xff\xff\xff\xff\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xff\xff\xff\b\x01n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xffu\x01\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xff\0\0\b\x01n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xffu\x01\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xffn\x01\b\x01\xff\xffq\x01\xff\xff\xff\xff\r\x01u\x01\xff\xff\xff\xff\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\0\0G\x01\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xff\xff\xff\b\x01n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xffu\x01\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\r\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\0\0R\x01\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01\xff\xff\x03\x01q\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01=\x01\xff\xffq\x01@\x01\xff\xff\xff\xffu\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\0\x01u\x01\xff\xff\x03\x01\xff\xff\x05\x01\x06\x01\x07\x01\b\x01\xff\xff\xff\xff\x0b\x01\f\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff$\x01\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x011\x012\x013\x014\x015\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xffD\x01E\x01F\x01G\x01H\x01I\x01\xff\xffK\x01L\x01M\x01N\x01\0\0P\x01\xff\xffR\x01S\x01\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff[\x01\xff\xff]\x01^\x01_\x01\xff\xffa\x01b\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01m\x01n\x01o\x01p\x01q\x01\xff\xff\xff\xfft\x01\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\0\0R\x01\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01n\x01o\x01\x05\x01\x06\x01\x07\x01\xff\xfft\x01\xff\xff\x0b\x01\f\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xffV\x01W\x01\0\0Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01n\x01o\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x001\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\0\0l\x01m\x01n\x01o\x01\xff\xff\xff\xff\0\x01\xff\xfft\x01\xff\xff\x04\x01\xff\xff\x06\x01\xff\xff\b\x01\xff\xff\n\x01\xff\xff\f\x01\r\x01\x0e\x01\x0f\x01\xff\xff\x11\x01\x12\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x015\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xff\0\0H\x01\xff\xffJ\x01K\x01\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xffR\x01S\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xffn\x01o\x01p\x01\xff\xff\0\x01s\x01\xff\xff\xff\xff\x04\x01\xff\xff\x06\x01\xff\xff\b\x01\xff\xff\n\x01\xff\xff\f\x01\xff\xff\x0e\x01\x0f\x01\0\0\x11\x01\x12\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01C\x01\xff\xff\xff\xff\xff\xff\xff\xffH\x01\xff\xffJ\x01\0\0\0\x01M\x01\xff\xff\x03\x01\x04\x01\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\r\x01\x0e\x01[\x01\xff\xff]\x01^\x01\x13\x01`\x01a\x01\xff\xffc\x01\xff\xff\xff\xff\x1a\x01g\x01\x1c\x01\x1d\x01j\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xffs\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\x04\x01@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\r\x01\x0e\x01\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01R\x01\xff\xff\xff\xff\xff\xff\b\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff^\x01\xff\xff`\x01\x13\x01b\x01c\x01\x16\x01\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\0\0\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff8\x01)\x01:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\x04\x01@\x01\xff\xffB\x01C\x01D\x01E\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xffK\x01\\\x01\xff\xff\x13\x01\xff\xff\xff\xffQ\x01R\x01c\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff^\x01o\x01p\x01\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\x04\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\r\x01\x0e\x01\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\0\0\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\0\x01n\x01\xff\xff\x03\x01q\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xffK\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01=\x01\x03\x01q\x01\xff\xffA\x01\xff\xffC\x01D\x01E\x01\0\0\xff\xff\r\x01\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xffb\x01c\x01)\x01\xff\xfff\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\xff\xff\xff\xffA\x01\xff\xffC\x01D\x01E\x01\xff\xff\xff\xff\r\x01\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xffb\x01c\x01)\x01\xff\xfff\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01=\x01\xff\xff\x03\x01\xff\xffA\x01\xff\xffC\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\r\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\x13\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xffb\x01c\x01(\x01)\x01f\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\xff\xff\xff\xff=\x01\0\0\b\x01@\x01\xff\xff\xff\xff\xff\xff\r\x01E\x01\xff\xffG\x01\0\0\xff\xff\x13\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01R\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff)\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xffJ\x01K\x01\0\x01\xff\xff\xff\xff\x03\x01\xff\xff\xff\xffR\x01\xff\xff\b\x01\0\0\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\0\x01^\x01\x13\x01\x03\x01\xff\xffb\x01c\x01\xff\xff\b\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\r\x01\xff\xff\xff\xff\xff\xffn\x01\xff\xff\x13\x01q\x01\xff\xff\xff\xff\xff\xff)\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\0\0\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01R\x01\0\0C\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xffJ\x01K\x01\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01R\x01\xff\xff\xff\xfff\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01^\x01\x03\x01q\x01\xff\xffb\x01\xff\xff\b\x01\xff\xfff\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\xff\xffn\x01\x13\x01\xff\xffq\x01\xff\xff\xff\xff\0\0\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xffK\x01@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffS\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\0\x01[\x01\\\x01\x03\x01R\x01\0\0`\x01\xff\xff\b\x01c\x01\0\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\x13\x01b\x01o\x01p\x01\r\x01f\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\0\0\xff\xffC\x01D\x01E\x01\xff\xff=\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\0\x01E\x01\xff\xff\x03\x01R\x01\xff\xff\xff\xffK\x01\b\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01R\x01\xff\xff^\x01\xff\xff\xff\xff\x13\x01b\x01\xff\xff\xff\xff\xff\xfff\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01b\x01\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01n\x01\xff\xff\xff\xffq\x01\0\0\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01K\x01\x1a\x01\x03\x01\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff)\x01\xff\xff\x13\x01^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff\0\0n\x01=\x01\xff\xffq\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xffE\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01K\x01\xff\xff\x03\x01\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xffb\x01K\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xffn\x01\xff\xffX\x01q\x01\0\0)\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01=\x01\x03\x01q\x01@\x01\xff\xff\xff\xff\b\x01D\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01=\x01\xff\xff\x03\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\xff\xff\r\x01\xff\xffK\x01\xff\xff\xff\xff\xff\xff\x13\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\0\0b\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\0\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xffK\x01\r\x01\xff\xff\x13\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff^\x01\xff\xff\xff\xff\0\0b\x01c\x01)\x01\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\xff\xff@\x01=\x01\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01E\x01\xff\xffK\x01\xff\xff\xff\xff\x13\x01K\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01R\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\0\0b\x01c\x01)\x01\xff\xffb\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01\xff\xff\xff\xffq\x01n\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\0\x01D\x01E\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xffK\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\r\x01\xff\xffR\x01\0\0\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\x1a\x01^\x01\x1c\x01\x1d\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff)\x01\xff\xffn\x01=\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffE\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\0\x01\xff\xff=\x01\x03\x01\xff\xff@\x01R\x01\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xffb\x01R\x01\0\0\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xffn\x01^\x01\xff\xffq\x01\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\b\x01\0\x01\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\0\0K\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\0\0\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff)\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01=\x01\xff\xffq\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01=\x01\xff\xff\r\x01@\x01\xff\xffK\x01\xff\xffD\x01E\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xffK\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xffn\x01\0\0\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01=\x01\x03\x01q\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\0\0K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\0\0\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\0\x01\xff\xffE\x01\x03\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01^\x01\x1c\x01\x1d\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01(\x01)\x01@\x01n\x01\xff\xff\0\x01q\x01E\x01\x03\x01\0\0\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\0\0R\x01=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\x1a\x01^\x01\x1c\x01\x1d\x01K\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff(\x01)\x01\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff^\x01\0\x01\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\b\x01\0\x01\xff\xff=\x01\xff\xff\r\x01@\x01n\x01\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xffK\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\0\0R\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff)\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01=\x01\xff\xff\xff\xff@\x01\xff\xffK\x01C\x01D\x01E\x01\xff\xff\xff\xff\0\0R\x01\xff\xffK\x01\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01R\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\r\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\0\x01n\x01\xff\xff\x03\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xffn\x01\0\0\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff=\x01\xff\xff)\x01@\x01\xff\xff\xff\xff\xff\xff\xff\xffE\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xffK\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xffR\x01=\x01\xff\xff)\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xffK\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xffR\x01=\x01\xff\xff\xff\xff@\x01\xff\xffn\x01\xff\xffD\x01E\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xffK\x01b\x01c\x01\0\0\0\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01n\x01\0\x01\xff\xff\xff\xff\r\x01\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\0\0\xff\xff\r\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\0\0n\x01\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff=\x01\xff\xff\xff\xff@\x01K\x01\xff\xff\0\x01D\x01E\x01\x03\x01\xff\xffR\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xffR\x01\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\x1a\x01^\x01\x1c\x01\x1d\x01\xff\xffb\x01c\x01n\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xffn\x01\xff\xff8\x01\xff\xff:\x01;\x01<\x01\0\x01>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\xff\xff\xff\xffE\x01\xff\xff\xff\xffS\x01\xff\xff\xff\xffK\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01[\x01\\\x01R\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\0\x01\xff\xff)\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01o\x01p\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01=\x01\xff\xff\xff\xff@\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xffR\x01\0\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\r\x01\xff\xffb\x01c\x01=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xff\xff\xffE\x01\x1a\x01n\x01\x1c\x01\x1d\x01\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xffn\x01\0\x01\xff\xffE\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01K\x01\0\x01\xff\xff\xff\xff\xff\xff\r\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\x1a\x01^\x01\x1c\x01\x1d\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01=\x01\xff\xff)\x01@\x01n\x01\xff\xff\xff\xff\xff\xffE\x01\xff\xff\xff\xff)\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xff\xff\xffE\x01=\x01\xff\xff^\x01@\x01\xff\xffK\x01b\x01c\x01E\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xffK\x01\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\0\x01n\x01\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\b\x01\xff\xffn\x01\x0b\x01\f\x01\r\x01\x0e\x01\xff\xff\xff\xff\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x011\x012\x013\x014\x015\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01C\x01\xff\xffE\x01F\x01G\x01H\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xffR\x01S\x01\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff[\x01\xff\xff\xff\xff^\x01_\x01\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01m\x01n\x01o\x01p\x01q\x01\xff\xff\xff\xfft\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\x0f\x01\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff$\x01\xff\xff\xff\xff'\x01\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xff\xff\xffd\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\0\x01\x01\x01\x02\x01\xff\xfft\x01\x05\x01\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff$\x01\xff\xff\xff\xff'\x01\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xff\xff\xffd\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\0\x01\x01\x01\x02\x01\xff\xfft\x01\x05\x01\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff$\x01\xff\xff\xff\xff'\x01\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffd\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\0\x01l\x01m\x01\xff\xffo\x01\x05\x01\x06\x01\x07\x01\b\x01t\x01\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x011\x012\x013\x014\x015\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01G\x01H\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff[\x01\xff\xff\xff\xff\xff\xff_\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01m\x01\xff\xffo\x01p\x01q\x01\0\x01\xff\xfft\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\0\x01Y\x01\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01`\x01\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\0\x01Y\x01\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01`\x01\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\0\x01Y\x01\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01`\x01\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\x03\x01\x04\x01\x05\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\x0b\x01\xff\xff\r\x01l\x01m\x01\xff\xffo\x01\xff\xff\x13\x01\x14\x01\x15\x01t\x01\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\x1e\x01\xff\xff \x01!\x01\"\x01#\x01\xff\xff\xff\xff\xff\xff'\x01(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff5\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff@\x01A\x01\xff\xff\xff\xff\xff\xff\xff\xffF\x01G\x01\xff\xff\xff\xff\xff\xffK\x01L\x01\xff\xffN\x01\xff\xffP\x01Q\x01R\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffZ\x01\xff\xff\xff\xff\xff\xff\xff\xff_\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffe\x01\0\x01\xff\xffh\x01i\x01\x04\x01k\x01l\x01m\x01n\x01o\x01\xff\xffq\x01r\x01s\x01t\x01u\x01\xff\xff\x11\x01\xff\xff\x13\x01\xff\xff\xff\xff\x16\x01\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff\xff\xffA\x01\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\f\x01\\\x01]\x01\x0f\x01\x10\x01\xff\xffa\x01\xff\xffc\x01\xff\xff\xff\xfff\x01\xff\xff\xff\xff\xff\xff\x1b\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01o\x01\xff\xffq\x01\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xffc\x01d\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xffc\x01d\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xffn\x01o\x01p\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xffc\x01d\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xffn\x01o\x01p\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xffc\x01d\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xffn\x01o\x01p\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff\0\x01A\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01I\x01\xff\xffK\x01\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01`\x01\xff\xff\xff\xffc\x01d\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\0\x01A\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\0\x01A\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\xff\xff\xff\xff\xff\xff\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\r\x01\x0e\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff[\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xffb\x01\xff\xff\x0b\x01\f\x01\r\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01n\x01o\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xffb\x01\x0b\x01\f\x01\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01n\x01o\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\xff\xff^\x01\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\n\x01\x0b\x01\f\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\xff\xff\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\x1a\x01\xff\xff\xff\xfft\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\x1a\x01\xff\xff\xff\xfft\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\f\x01\xff\xff\x0e\x01\xff\xffg\x01\x11\x01\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\x1b\x01\xff\xfft\x01\x1e\x01\x1f\x018\x01\xff\xff:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xffS\x01<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01[\x01\\\x01\xff\xff\xff\xff\xff\xffH\x01\x06\x01\xff\xffc\x01\xff\xffM\x01\xff\xff\f\x01\xff\xff\x0e\x01\xff\xffS\x01\x11\x01\xff\xffV\x01o\x01p\x01\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\x06\x01\xff\xff\xff\xff\xff\xffM\x01\xff\xff\f\x01\xff\xff\x0e\x01\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\x06\x01\xff\xff\xff\xff\xff\xffM\x01\xff\xff\f\x01\xff\xff\x0e\x01\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xffJ\x01\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xffJ\x01\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\xff\xff\xff\xff\xff\xff\x06\x01M\x01\xff\xff\xff\xff\n\x01\xff\xff\f\x01\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xff\x1c\x01c\x01\x1e\x01\x1f\x01\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\x06\x01\xff\xff\b\x01\xff\xffM\x01\xff\xff\f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\xff\xff\xff\xff\xff\xff\x06\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\f\x01\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff_\x01\xff\xff\xff\xff\x1c\x01c\x01\x1e\x01\x1f\x01\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\x06\x01\x07\x01\xff\xff\xff\xffM\x01\x0b\x01\f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\x16\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1e\x01\x1f\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffY\x01\xff\xff[\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xffc\x01d\x01\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffY\x01\xff\xff[\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x011\x012\x013\x01\xff\xff\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffY\x01\xff\xff\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x011\x012\x013\x01\xff\xff\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\xff\xff\xff\xff\xff\xffY\x01\xff\xff\xff\xff\x0f\x01\x1e\x01\x1f\x018\x01\xff\xff:\x01;\x01<\x01\x17\x01>\x01\xff\xffg\x01A\x01B\x01\xff\xff\x1e\x01l\x01\xff\xff\xff\xffo\x011\x012\x013\x01\xff\xff\xff\xff6\x017\x018\x019\x01\xff\xffS\x01<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01[\x01\\\x01\xff\xff8\x01\xff\xff:\x01;\x01<\x01c\x01>\x01M\x01N\x01A\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01n\x01o\x01p\x01Y\x01\xff\xff\xff\xff\x0f\x01\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffg\x01Z\x01[\x01\\\x01\x1e\x01l\x01\xff\xff\xff\xffo\x01\xff\xffc\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\t\x01\xff\xff\xff\xffS\x01\xff\xff\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\xff\xff[\x01\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01l\x01\xff\xff\xff\xffo\x01p\x01*\x01+\x01,\x01-\x01.\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\xff\xff\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\x01\x10\x01\xff\xff\xff\xff\xff\xffC\x01\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01T\x01U\x01V\x01W\x01X\x01*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff`\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfff\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\t\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\x0f\x01\x10\x01\xff\xff\x12\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x01\x02\x01d\x01$\x01f\x01\xff\xff\xff\xff\xff\xff\t\x01*\x01+\x01,\x01-\x01.\x01\x0f\x01\x10\x01\xff\xff\x12\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01$\x01\xff\xff\xff\xff\xff\xffH\x01I\x01*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\x01\x01\x01\x02\x01a\x01\xff\xffC\x01\xff\xff\xff\xfff\x01\t\x01H\x01I\x01\xff\xff\xff\xff\xff\xff\x0f\x01\x10\x01\xff\xff\x12\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\x1b\x01\xff\xff\xff\xff\xff\xff]\x01\xff\xff\x01\x01\x02\x01\xff\xff$\x01\xff\xff\xff\xff\xff\xfff\x01\t\x01*\x01+\x01,\x01-\x01.\x01\x0f\x01\x10\x01\xff\xff\x12\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x19\x01\xff\xff\x1b\x01\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01$\x01\xff\xff\xff\xff\xff\xffH\x01I\x01*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01>\x01\x01\x01\x02\x01\xff\xff\xff\xffC\x01\xff\xff\xff\xfff\x01\t\x01H\x01I\x01\xff\xff\xff\xff\xff\xff\x0f\x01\x10\x01\xff\xff\x12\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x01\x02\x01\xff\xff$\x01\xff\xff\xff\xff\xff\xfff\x01\t\x01*\x01+\x01,\x01-\x01.\x01\x0f\x01\x10\x01\xff\xff\x12\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01$\x01\xff\xff\xff\xff\xff\xffH\x01I\x01*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\x01\x01\x01\x02\x01\xff\xff\xff\xffC\x01\xff\xff\xff\xfff\x01\t\x01H\x01I\x01\xff\xff\xff\xff\xff\xff\x0f\x01\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x01\x02\x01\xff\xff$\x01\xff\xff\xff\xff\xff\xfff\x01\t\x01*\x01+\x01,\x01-\x01.\x01\x0f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01$\x01\xff\xff\xff\xff\xff\xffH\x01I\x01*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01>\x01\x01\x01\x02\x01\xff\xff\xff\xffC\x01\xff\xff\xff\xfff\x01\t\x01H\x01I\x01\xff\xff\xff\xff\xff\xff\x0f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff$\x01\xff\xff\xff\xff\xff\xfff\x01\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01\x0f\x01\xff\xff\xff\xff\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xfff\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\xff\xff>\x01>\x01\xff\xffA\x01B\x01\xff\xffC\x01\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffU\x01V\x01W\x01X\x01\xff\xff[\x01\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xfff\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffo\x01p\x01",
  error_function: Parsing.parse_error,
  names_const: "AMPERAMPER\0AMPERSAND\0AND\0AS\0ASSERT\0BACKQUOTE\0BANG\0BAR\0BARBAR\0BARRBRACKET\0BEGIN\0CLASS\0COLON\0COLONCOLON\0COLONEQUAL\0COLONGREATER\0COMMA\0CONSTRAINT\0DO\0DONE\0DOT\0DOTDOT\0DOWNTO\0ELSE\0END\0EOF\0EQUAL\0EXCEPTION\0EXTERNAL\0FALSE\0FOR\0FUN\0FUNCTION\0FUNCTOR\0GREATER\0GREATERRBRACE\0GREATERRBRACKET\0IF\0IN\0INCLUDE\0INHERIT\0INITIALIZER\0LAZY\0LBRACE\0LBRACELESS\0LBRACKET\0LBRACKETBAR\0LBRACKETLESS\0LBRACKETGREATER\0LBRACKETPERCENT\0LBRACKETPERCENTPERCENT\0LESS\0LESSMINUS\0LET\0LPAREN\0LBRACKETAT\0LBRACKETATAT\0LBRACKETATATAT\0MATCH\0METHOD\0MINUS\0MINUSDOT\0MINUSGREATER\0MODULE\0MUTABLE\0NEW\0NONREC\0OBJECT\0OF\0OPEN\0OR\0PERCENT\0PLUS\0PLUSDOT\0PLUSEQ\0PRIVATE\0QUESTION\0QUOTE\0RBRACE\0RBRACKET\0REC\0RPAREN\0SEMI\0SEMISEMI\0SHARP\0SIG\0STAR\0STRUCT\0THEN\0TILDE\0TO\0TRUE\0TRY\0TYPE\0UNDERSCORE\0VAL\0VIRTUAL\0WHEN\0WHILE\0WITH\0EOL\0",
  names_block: "CHAR\0FLOAT\0INFIXOP0\0INFIXOP1\0INFIXOP2\0INFIXOP3\0INFIXOP4\0INT\0INT32\0INT64\0LABEL\0LIDENT\0NATIVEINT\0OPTLABEL\0PREFIXOP\0SHARPOP\0STRING\0UIDENT\0COMMENT\0DOCSTRING\0"
end;

function implementation(lexfun, lexbuf) do
  return Parsing.yyparse(yytables, 1, lexfun, lexbuf);
end end

function type_of_directive(x) do
  if (typeof x == "number") then do
    return --[[ Dir_type_null ]]4;
  end else do
    local ___conditional___=(x.tag | 0);
    do
       if ___conditional___ = 0--[[ Dir_bool ]] then do
          return --[[ Dir_type_bool ]]0;end end end 
       if ___conditional___ = 1--[[ Dir_float ]] then do
          return --[[ Dir_type_float ]]1;end end end 
       if ___conditional___ = 2--[[ Dir_int ]] then do
          return --[[ Dir_type_int ]]2;end end end 
       if ___conditional___ = 3--[[ Dir_string ]] then do
          return --[[ Dir_type_string ]]3;end end end 
       do
      
    end
  end end 
end end

function string_of_type_directive(x) do
  local ___conditional___=(x);
  do
     if ___conditional___ = 0--[[ Dir_type_bool ]] then do
        return "bool";end end end 
     if ___conditional___ = 1--[[ Dir_type_float ]] then do
        return "float";end end end 
     if ___conditional___ = 2--[[ Dir_type_int ]] then do
        return "int";end end end 
     if ___conditional___ = 3--[[ Dir_type_string ]] then do
        return "string";end end end 
     if ___conditional___ = 4--[[ Dir_type_null ]] then do
        return "nil";end end end 
     do
    
  end
end end

__Error$4 = Caml_exceptions.create("Ocaml_typedtree_test.Lexer.Error");

function assert_same_type(lexbuf, x, y) do
  lhs = type_of_directive(x);
  rhs = type_of_directive(y);
  if (lhs ~= rhs) then do
    throw {
          __Error$4,
          --[[ Conditional_expr_expected_type ]]Block.__(7, {
              lhs,
              rhs
            }),
          curr(lexbuf)
        };
  end
   end 
  return y;
end end

directive_built_in_values = Hashtbl.create(undefined, 51);

Hashtbl.replace(directive_built_in_values, "OCAML_VERSION", --[[ Dir_string ]]Block.__(3, {Sys.ocaml_version}));

tmp;

exit = 0;

i;

try do
  i = __String.rindex(Sys.ocaml_version, --[[ "+" ]]43);
  exit = 1;
end
catch (exn$1)do
  if (exn$1 == Caml_builtin_exceptions.not_found) then do
    tmp = "";
  end else do
    throw exn$1;
  end end 
end

if (exit == 1) then do
  tmp = __String.sub(Sys.ocaml_version, i + 1 | 0, (#Sys.ocaml_version - i | 0) - 1 | 0);
end
 end 

v = --[[ Dir_string ]]Block.__(3, {tmp});

Hashtbl.replace(directive_built_in_values, "OCAML_PATCH", v);

Hashtbl.replace(directive_built_in_values, "OS_TYPE", --[[ Dir_string ]]Block.__(3, {Sys.os_type}));

Hashtbl.replace(directive_built_in_values, "BIG_ENDIAN", --[[ Dir_bool ]]Block.__(0, {Sys.big_endian}));

Hashtbl.replace(directive_built_in_values, "WORD_SIZE", --[[ Dir_int ]]Block.__(2, {Sys.word_size}));

function semantic_version_parse(str, start, last_index) do
  aux = function (_start, _acc, last_index) do
    while(true) do
      acc = _acc;
      start = _start;
      if (start <= last_index) then do
        c = str.charCodeAt(start);
        if (c == --[[ "." ]]46) then do
          return --[[ tuple ]]{
                  acc,
                  start + 1 | 0
                };
        end else do
          v = c - --[[ "0" ]]48 | 0;
          if (v >= 0 and v <= 9) then do
            _acc = Caml_int32.imul(acc, 10) + v | 0;
            _start = start + 1 | 0;
            continue ;
          end else do
            return --[[ tuple ]]{
                    acc,
                    start
                  };
          end end 
        end end 
      end else do
        return --[[ tuple ]]{
                acc,
                start
              };
      end end 
    end;
  end end;
  match = aux(start, 0, last_index);
  match$1 = aux(match[1], 0, last_index);
  match$2 = aux(match$1[1], 0, last_index);
  patch_end = match$2[1];
  additional = __String.sub(str, patch_end, (last_index - patch_end | 0) + 1 | 0);
  return --[[ tuple ]]{
          --[[ tuple ]]{
            match[0],
            match$1[0],
            match$2[0]
          },
          additional
        };
end end

function defined(str) do
  val;
  try do
    val = Hashtbl.find(directive_built_in_values, str);
  end
  catch (exn)do
    try do
      Caml_sys.caml_sys_getenv(str);
      return true;
    end
    catch (exn$1)do
      return false;
    end
  end
  if (typeof val == "number") then do
    return false;
  end else do
    return true;
  end end 
end end

function query(loc, str) do
  v;
  try do
    v = Hashtbl.find(directive_built_in_values, str);
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      exit = 0;
      v$1;
      try do
        v$1 = Caml_sys.caml_sys_getenv(str);
        exit = 2;
      end
      catch (exn$1)do
        if (exn$1 == Caml_builtin_exceptions.not_found) then do
          return --[[ Dir_bool ]]Block.__(0, {false});
        end else do
          throw exn$1;
        end end 
      end
      if (exit == 2) then do
        try do
          return --[[ Dir_bool ]]Block.__(0, {Pervasives.bool_of_string(v$1)});
        end
        catch (exn$2)do
          try do
            return --[[ Dir_int ]]Block.__(2, {Caml_format.caml_int_of_string(v$1)});
          end
          catch (exn$3)do
            try do
              return --[[ Dir_float ]]Block.__(1, {Caml_format.caml_float_of_string(v$1)});
            end
            catch (exn$4)do
              return --[[ Dir_string ]]Block.__(3, {v$1});
            end
          end
        end
      end
       end 
    end else do
      throw exn;
    end end 
  end
  if (typeof v == "number") then do
    return --[[ Dir_bool ]]Block.__(0, {false});
  end else do
    return v;
  end end 
end end

function value_of_token(loc, t) do
  if (typeof t == "number") then do
    local ___conditional___=(t);
    do
       if ___conditional___ = 29--[[ FALSE ]] then do
          return --[[ Dir_bool ]]Block.__(0, {false});end end end 
       if ___conditional___ = 91--[[ TRUE ]] then do
          return --[[ Dir_bool ]]Block.__(0, {true});end end end 
       do
      else do
        throw {
              __Error$4,
              --[[ Unexpected_token_in_conditional ]]4,
              loc
            };
        end end
        
    end
  end else do
    local ___conditional___=(t.tag | 0);
    do
       if ___conditional___ = 1--[[ FLOAT ]] then do
          return --[[ Dir_float ]]Block.__(1, {Caml_format.caml_float_of_string(t[0])});end end end 
       if ___conditional___ = 7--[[ INT ]] then do
          return --[[ Dir_int ]]Block.__(2, {t[0]});end end end 
       if ___conditional___ = 16--[[ STRING ]] then do
          return --[[ Dir_string ]]Block.__(3, {t[0][0]});end end end 
       if ___conditional___ = 17--[[ UIDENT ]] then do
          return query(loc, t[0]);end end end 
       do
      else do
        throw {
              __Error$4,
              --[[ Unexpected_token_in_conditional ]]4,
              loc
            };
        end end
        
    end
  end end 
end end

function directive_parse(token_with_comments, lexbuf) do
  look_ahead = do
    contents: undefined
  end;
  token = function (param) do
    v = look_ahead.contents;
    if (v ~= undefined) then do
      look_ahead.contents = undefined;
      return v;
    end else do
      _param = --[[ () ]]0;
      while(true) do
        t = Curry._1(token_with_comments, lexbuf);
        if (typeof t == "number") then do
          local ___conditional___=(t);
          do
             if ___conditional___ = 25--[[ EOF ]] then do
                throw {
                      __Error$4,
                      --[[ Unterminated_if ]]2,
                      curr(lexbuf)
                    };end end end 
             if ___conditional___ = 100--[[ EOL ]] then do
                _param = --[[ () ]]0;
                continue ;end end end 
             do
            else do
              return t;
              end end
              
          end
        end else do
          local ___conditional___=(t.tag | 0);
          do
             if ___conditional___ = 18--[[ COMMENT ]]
             or ___conditional___ = 19--[[ DOCSTRING ]] then do
                _param = --[[ () ]]0;
                continue ;end end end 
             do
            else do
              return t;
              end end
              
          end
        end end 
      end;
    end end 
  end end;
  push = function (e) do
    if (look_ahead.contents ~= undefined) then do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "lexer.mll",
              312,
              4
            }
          };
    end
     end 
    look_ahead.contents = e;
    return --[[ () ]]0;
  end end;
  token_op = function (calc, no, lhs) do
    op = token(--[[ () ]]0);
    exit = 0;
    if (typeof op == "number") then do
      local ___conditional___=(op);
      do
         if ___conditional___ = 26--[[ EQUAL ]]
         or ___conditional___ = 34--[[ GREATER ]]
         or ___conditional___ = 51--[[ LESS ]] then do
            exit = 1;end else 
         do end end
        else do
          return Curry._1(no, op);
          end end
          
      end
    end else if (op.tag == --[[ INFIXOP0 ]]2) then do
      local ___conditional___=(op[0]);
      do
         if ___conditional___ = "=~" then do
            if (calc) then do
              if (typeof lhs ~= "number" and lhs.tag == --[[ Dir_string ]]3) then do
                curr_loc = curr(lexbuf);
                rhs = value_of_token(curr_loc, token(--[[ () ]]0));
                exit$1 = 0;
                if (typeof rhs == "number" or rhs.tag ~= --[[ Dir_string ]]3) then do
                  exit$1 = 3;
                end else do
                  loc = curr_loc;
                  lhs$1 = lhs[0];
                  str = rhs[0];
                  last_index = #str - 1 | 0;
                  if (last_index < 0) then do
                    throw {
                          __Error$4,
                          --[[ Illegal_semver ]]Block.__(6, {str}),
                          loc
                        };
                  end
                   end 
                  v = str.charCodeAt(0);
                  match;
                  exit$2 = 0;
                  if (v ~= 94) then do
                    if (v >= 63) then do
                      if (v ~= 126) then do
                        exit$2 = 1;
                      end else do
                        match = --[[ tuple ]]{
                          --[[ Approximate ]]-617782220,
                          semantic_version_parse(str, 1, last_index)
                        };
                      end end 
                    end else if (v >= 60) then do
                      local ___conditional___=(v - 60 | 0);
                      do
                         if ___conditional___ = 0 then do
                            if (last_index == 0) then do
                              throw {
                                    __Error$4,
                                    --[[ Illegal_semver ]]Block.__(6, {str}),
                                    loc
                                  };
                            end
                             end 
                            match = str[1] == "=" and --[[ tuple ]]{
                                --[[ Le ]]17049,
                                semantic_version_parse(str, 2, last_index)
                              } or --[[ tuple ]]{
                                --[[ Lt ]]17064,
                                semantic_version_parse(str, 1, last_index)
                              };end else 
                         if ___conditional___ = 1 then do
                            exit$2 = 1;end else 
                         if ___conditional___ = 2 then do
                            if (last_index == 0) then do
                              throw {
                                    __Error$4,
                                    --[[ Illegal_semver ]]Block.__(6, {str}),
                                    loc
                                  };
                            end
                             end 
                            match = str[1] == "=" and --[[ tuple ]]{
                                --[[ Ge ]]15934,
                                semantic_version_parse(str, 2, last_index)
                              } or --[[ tuple ]]{
                                --[[ Gt ]]15949,
                                semantic_version_parse(str, 1, last_index)
                              };end else 
                         do end end end end
                        
                      end
                    end else do
                      exit$2 = 1;
                    end end  end 
                  end else do
                    match = --[[ tuple ]]{
                      --[[ Compatible ]]785637236,
                      semantic_version_parse(str, 1, last_index)
                    };
                  end end 
                  if (exit$2 == 1) then do
                    match = --[[ tuple ]]{
                      --[[ Exact ]]172069535,
                      semantic_version_parse(str, 0, last_index)
                    };
                  end
                   end 
                  version = match[1][0];
                  major = version[0];
                  pred = match[0];
                  match$1 = semantic_version_parse(lhs$1, 0, #lhs$1 - 1 | 0);
                  lversion = match$1[0];
                  l_major = lversion[0];
                  if (pred >= 17049) then do
                    if (pred >= 172069535) then do
                      if (pred >= 785637236) then do
                        return major == l_major;
                      end else do
                        return Caml_obj.caml_equal(lversion, version);
                      end end 
                    end else if (pred >= 17064) then do
                      return Caml_obj.caml_lessthan(lversion, version);
                    end else do
                      return Caml_obj.caml_lessequal(lversion, version);
                    end end  end 
                  end else if (pred ~= 15934) then do
                    if (pred >= 15949) then do
                      return Caml_obj.caml_greaterthan(lversion, version);
                    end else if (major == l_major) then do
                      return version[1] == lversion[1];
                    end else do
                      return false;
                    end end  end 
                  end else do
                    return Caml_obj.caml_greaterequal(lversion, version);
                  end end  end 
                end end 
                if (exit$1 == 3) then do
                  throw {
                        __Error$4,
                        --[[ Conditional_expr_expected_type ]]Block.__(7, {
                            --[[ Dir_type_string ]]3,
                            type_of_directive(lhs)
                          }),
                        curr(lexbuf)
                      };
                end
                 end 
              end
               end 
              throw {
                    __Error$4,
                    --[[ Conditional_expr_expected_type ]]Block.__(7, {
                        --[[ Dir_type_string ]]3,
                        type_of_directive(lhs)
                      }),
                    curr(lexbuf)
                  };
            end else do
              return true;
            end end end else 
         if ___conditional___ = "<="
         or ___conditional___ = "<>"
         or ___conditional___ = ">=" then do
            exit = 1;end else 
         do end end end
        else do
          return Curry._1(no, op);
          end end
          
      end
    end else do
      return Curry._1(no, op);
    end end  end 
    if (exit == 1) then do
      f;
      exit$3 = 0;
      if (typeof op == "number") then do
        local ___conditional___=(op);
        do
           if ___conditional___ = 26--[[ EQUAL ]] then do
              f = Caml_obj.caml_equal;end else 
           if ___conditional___ = 34--[[ GREATER ]] then do
              f = Caml_obj.caml_greaterthan;end else 
           if ___conditional___ = 51--[[ LESS ]] then do
              f = Caml_obj.caml_lessthan;end else 
           do end end end end
          else do
            exit$3 = 2;
            end end
            
        end
      end else if (op.tag == --[[ INFIXOP0 ]]2) then do
        local ___conditional___=(op[0]);
        do
           if ___conditional___ = "<=" then do
              f = Caml_obj.caml_lessequal;end else 
           if ___conditional___ = "<>" then do
              f = Caml_obj.caml_notequal;end else 
           do end end end
          else do
            exit$3 = 2;
            end end
            
        end
      end else do
        exit$3 = 2;
      end end  end 
      if (exit$3 == 2) then do
        throw {
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "lexer.mll",
                331,
                17
              }
            };
      end
       end 
      curr_loc$1 = curr(lexbuf);
      rhs$1 = value_of_token(curr_loc$1, token(--[[ () ]]0));
      if (calc) then do
        return Curry._2(f, lhs, assert_same_type(lexbuf, lhs, rhs$1));
      end else do
        return true;
      end end 
    end
     end 
  end end;
  parse_and_aux = function (calc, v) do
    e = token(--[[ () ]]0);
    if (typeof e == "number" and e == 0) then do
      calc$1 = calc and v;
      b = parse_and_aux(calc$1, parse_relation(calc$1));
      if (v) then do
        return b;
      end else do
        return false;
      end end 
    end else do
      push(e);
      return v;
    end end 
  end end;
  parse_relation = function (calc) do
    curr_token = token(--[[ () ]]0);
    curr_loc = curr(lexbuf);
    if (typeof curr_token == "number") then do
      local ___conditional___=(curr_token);
      do
         if ___conditional___ = 29--[[ FALSE ]] then do
            return false;end end end 
         if ___conditional___ = 54--[[ LPAREN ]] then do
            v = parse_or_aux(calc, parse_and_aux(calc, parse_relation(calc)));
            match = token(--[[ () ]]0);
            if (typeof match == "number") then do
              if (match ~= 81) then do
                throw {
                      __Error$4,
                      --[[ Unterminated_paren_in_conditional ]]1,
                      curr(lexbuf)
                    };
              end
               end 
              return v;
            end else do
              throw {
                    __Error$4,
                    --[[ Unterminated_paren_in_conditional ]]1,
                    curr(lexbuf)
                  };
            end end end end end 
         if ___conditional___ = 91--[[ TRUE ]] then do
            return true;end end end 
         do
        else do
          throw {
                __Error$4,
                --[[ Unexpected_token_in_conditional ]]4,
                curr_loc
              };
          end end
          
      end
    end else do
      local ___conditional___=(curr_token.tag | 0);
      do
         if ___conditional___ = 1--[[ FLOAT ]] then do
            return token_op(calc, (function (e) do
                          throw {
                                __Error$4,
                                --[[ Conditional_expr_expected_type ]]Block.__(7, {
                                    --[[ Dir_type_bool ]]0,
                                    --[[ Dir_type_float ]]1
                                  }),
                                curr_loc
                              };
                        end end), --[[ Dir_float ]]Block.__(1, {Caml_format.caml_float_of_string(curr_token[0])}));end end end 
         if ___conditional___ = 7--[[ INT ]] then do
            return token_op(calc, (function (e) do
                          throw {
                                __Error$4,
                                --[[ Conditional_expr_expected_type ]]Block.__(7, {
                                    --[[ Dir_type_bool ]]0,
                                    --[[ Dir_type_int ]]2
                                  }),
                                curr_loc
                              };
                        end end), --[[ Dir_int ]]Block.__(2, {curr_token[0]}));end end end 
         if ___conditional___ = 11--[[ LIDENT ]] then do
            r = curr_token[0];
            local ___conditional___=(r);
            do
               if ___conditional___ = "defined"
               or ___conditional___ = "undefined"
               do end
              else do
                throw {
                      __Error$4,
                      --[[ Unexpected_token_in_conditional ]]4,
                      curr_loc
                    };
                end end
                
            end
            t = token(--[[ () ]]0);
            loc = curr(lexbuf);
            if (typeof t == "number") then do
              throw {
                    __Error$4,
                    --[[ Unexpected_token_in_conditional ]]4,
                    loc
                  };
            end else if (t.tag == --[[ UIDENT ]]17) then do
              s = t[0];
              if (calc) then do
                if (Caml_string.get(r, 0) == --[[ "u" ]]117) then do
                  return not defined(s);
                end else do
                  return defined(s);
                end end 
              end else do
                return true;
              end end 
            end else do
              throw {
                    __Error$4,
                    --[[ Unexpected_token_in_conditional ]]4,
                    loc
                  };
            end end  end end else 
         if ___conditional___ = 16--[[ STRING ]] then do
            return token_op(calc, (function (e) do
                          throw {
                                __Error$4,
                                --[[ Conditional_expr_expected_type ]]Block.__(7, {
                                    --[[ Dir_type_bool ]]0,
                                    --[[ Dir_type_string ]]3
                                  }),
                                curr_loc
                              };
                        end end), --[[ Dir_string ]]Block.__(3, {curr_token[0][0]}));end end end 
         if ___conditional___ = 17--[[ UIDENT ]] then do
            value_v = query(curr_loc, curr_token[0]);
            return token_op(calc, (function (e) do
                          push(e);
                          if (typeof value_v ~= "number" and not value_v.tag) then do
                            return value_v[0];
                          end
                           end 
                          ty = type_of_directive(value_v);
                          throw {
                                __Error$4,
                                --[[ Conditional_expr_expected_type ]]Block.__(7, {
                                    --[[ Dir_type_bool ]]0,
                                    ty
                                  }),
                                curr_loc
                              };
                        end end), value_v);end end end 
         do
        else do
          throw {
                __Error$4,
                --[[ Unexpected_token_in_conditional ]]4,
                curr_loc
              };
          end end
          
      end
    end end 
  end end;
  parse_or_aux = function (calc, v) do
    e = token(--[[ () ]]0);
    if (typeof e == "number" and e == 8) then do
      calc$1 = calc and not v;
      b = parse_or_aux(calc$1, parse_and_aux(calc$1, parse_relation(calc$1)));
      if (v) then do
        return true;
      end else do
        return b;
      end end 
    end else do
      push(e);
      return v;
    end end 
  end end;
  v = parse_or_aux(true, parse_and_aux(true, parse_relation(true)));
  match = token(--[[ () ]]0);
  if (typeof match == "number") then do
    if (match ~= 88) then do
      throw {
            __Error$4,
            --[[ Expect_hash_then_in_conditional ]]5,
            curr(lexbuf)
          };
    end
     end 
    return v;
  end else do
    throw {
          __Error$4,
          --[[ Expect_hash_then_in_conditional ]]5,
          curr(lexbuf)
        };
  end end 
end end

function is_elif(i) do
  if (typeof i == "number" or not (i.tag == --[[ LIDENT ]]11 and i[0] == "elif")) then do
    return false;
  end else do
    return true;
  end end 
end end

keyword_table = create_hashtable(149, --[[ :: ]]{
      --[[ tuple ]]{
        "and",
        --[[ AND ]]2
      },
      --[[ :: ]]{
        --[[ tuple ]]{
          "as",
          --[[ AS ]]3
        },
        --[[ :: ]]{
          --[[ tuple ]]{
            "assert",
            --[[ ASSERT ]]4
          },
          --[[ :: ]]{
            --[[ tuple ]]{
              "begin",
              --[[ BEGIN ]]10
            },
            --[[ :: ]]{
              --[[ tuple ]]{
                "class",
                --[[ CLASS ]]11
              },
              --[[ :: ]]{
                --[[ tuple ]]{
                  "constraint",
                  --[[ CONSTRAINT ]]17
                },
                --[[ :: ]]{
                  --[[ tuple ]]{
                    "do",
                    --[[ DO ]]18
                  },
                  --[[ :: ]]{
                    --[[ tuple ]]{
                      "done",
                      --[[ DONE ]]19
                    },
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        "downto",
                        --[[ DOWNTO ]]22
                      },
                      --[[ :: ]]{
                        --[[ tuple ]]{
                          "else",
                          --[[ ELSE ]]23
                        },
                        --[[ :: ]]{
                          --[[ tuple ]]{
                            "end",
                            --[[ END ]]24
                          },
                          --[[ :: ]]{
                            --[[ tuple ]]{
                              "exception",
                              --[[ EXCEPTION ]]27
                            },
                            --[[ :: ]]{
                              --[[ tuple ]]{
                                "external",
                                --[[ EXTERNAL ]]28
                              },
                              --[[ :: ]]{
                                --[[ tuple ]]{
                                  "false",
                                  --[[ FALSE ]]29
                                },
                                --[[ :: ]]{
                                  --[[ tuple ]]{
                                    "for",
                                    --[[ FOR ]]30
                                  },
                                  --[[ :: ]]{
                                    --[[ tuple ]]{
                                      "fun",
                                      --[[ FUN ]]31
                                    },
                                    --[[ :: ]]{
                                      --[[ tuple ]]{
                                        "function",
                                        --[[ FUNCTION ]]32
                                      },
                                      --[[ :: ]]{
                                        --[[ tuple ]]{
                                          "functor",
                                          --[[ FUNCTOR ]]33
                                        },
                                        --[[ :: ]]{
                                          --[[ tuple ]]{
                                            "if",
                                            --[[ IF ]]37
                                          },
                                          --[[ :: ]]{
                                            --[[ tuple ]]{
                                              "in",
                                              --[[ IN ]]38
                                            },
                                            --[[ :: ]]{
                                              --[[ tuple ]]{
                                                "include",
                                                --[[ INCLUDE ]]39
                                              },
                                              --[[ :: ]]{
                                                --[[ tuple ]]{
                                                  "inherit",
                                                  --[[ INHERIT ]]40
                                                },
                                                --[[ :: ]]{
                                                  --[[ tuple ]]{
                                                    "initializer",
                                                    --[[ INITIALIZER ]]41
                                                  },
                                                  --[[ :: ]]{
                                                    --[[ tuple ]]{
                                                      "lazy",
                                                      --[[ LAZY ]]42
                                                    },
                                                    --[[ :: ]]{
                                                      --[[ tuple ]]{
                                                        "let",
                                                        --[[ LET ]]53
                                                      },
                                                      --[[ :: ]]{
                                                        --[[ tuple ]]{
                                                          "match",
                                                          --[[ MATCH ]]58
                                                        },
                                                        --[[ :: ]]{
                                                          --[[ tuple ]]{
                                                            "method",
                                                            --[[ METHOD ]]59
                                                          },
                                                          --[[ :: ]]{
                                                            --[[ tuple ]]{
                                                              "module",
                                                              --[[ MODULE ]]63
                                                            },
                                                            --[[ :: ]]{
                                                              --[[ tuple ]]{
                                                                "mutable",
                                                                --[[ MUTABLE ]]64
                                                              },
                                                              --[[ :: ]]{
                                                                --[[ tuple ]]{
                                                                  "new",
                                                                  --[[ NEW ]]65
                                                                },
                                                                --[[ :: ]]{
                                                                  --[[ tuple ]]{
                                                                    "nonrec",
                                                                    --[[ NONREC ]]66
                                                                  },
                                                                  --[[ :: ]]{
                                                                    --[[ tuple ]]{
                                                                      "object",
                                                                      --[[ OBJECT ]]67
                                                                    },
                                                                    --[[ :: ]]{
                                                                      --[[ tuple ]]{
                                                                        "of",
                                                                        --[[ OF ]]68
                                                                      },
                                                                      --[[ :: ]]{
                                                                        --[[ tuple ]]{
                                                                          "open",
                                                                          --[[ OPEN ]]69
                                                                        },
                                                                        --[[ :: ]]{
                                                                          --[[ tuple ]]{
                                                                            "or",
                                                                            --[[ OR ]]70
                                                                          },
                                                                          --[[ :: ]]{
                                                                            --[[ tuple ]]{
                                                                              "private",
                                                                              --[[ PRIVATE ]]75
                                                                            },
                                                                            --[[ :: ]]{
                                                                              --[[ tuple ]]{
                                                                                "rec",
                                                                                --[[ REC ]]80
                                                                              },
                                                                              --[[ :: ]]{
                                                                                --[[ tuple ]]{
                                                                                  "sig",
                                                                                  --[[ SIG ]]85
                                                                                },
                                                                                --[[ :: ]]{
                                                                                  --[[ tuple ]]{
                                                                                    "struct",
                                                                                    --[[ STRUCT ]]87
                                                                                  },
                                                                                  --[[ :: ]]{
                                                                                    --[[ tuple ]]{
                                                                                      "then",
                                                                                      --[[ THEN ]]88
                                                                                    },
                                                                                    --[[ :: ]]{
                                                                                      --[[ tuple ]]{
                                                                                        "to",
                                                                                        --[[ TO ]]90
                                                                                      },
                                                                                      --[[ :: ]]{
                                                                                        --[[ tuple ]]{
                                                                                          "true",
                                                                                          --[[ TRUE ]]91
                                                                                        },
                                                                                        --[[ :: ]]{
                                                                                          --[[ tuple ]]{
                                                                                            "try",
                                                                                            --[[ TRY ]]92
                                                                                          },
                                                                                          --[[ :: ]]{
                                                                                            --[[ tuple ]]{
                                                                                              "type",
                                                                                              --[[ TYPE ]]93
                                                                                            },
                                                                                            --[[ :: ]]{
                                                                                              --[[ tuple ]]{
                                                                                                "val",
                                                                                                --[[ VAL ]]95
                                                                                              },
                                                                                              --[[ :: ]]{
                                                                                                --[[ tuple ]]{
                                                                                                  "virtual",
                                                                                                  --[[ VIRTUAL ]]96
                                                                                                },
                                                                                                --[[ :: ]]{
                                                                                                  --[[ tuple ]]{
                                                                                                    "when",
                                                                                                    --[[ WHEN ]]97
                                                                                                  },
                                                                                                  --[[ :: ]]{
                                                                                                    --[[ tuple ]]{
                                                                                                      "while",
                                                                                                      --[[ WHILE ]]98
                                                                                                    },
                                                                                                    --[[ :: ]]{
                                                                                                      --[[ tuple ]]{
                                                                                                        "with",
                                                                                                        --[[ WITH ]]99
                                                                                                      },
                                                                                                      --[[ :: ]]{
                                                                                                        --[[ tuple ]]{
                                                                                                          "mod",
                                                                                                          --[[ INFIXOP3 ]]Block.__(5, {"mod"})
                                                                                                        },
                                                                                                        --[[ :: ]]{
                                                                                                          --[[ tuple ]]{
                                                                                                            "land",
                                                                                                            --[[ INFIXOP3 ]]Block.__(5, {"land"})
                                                                                                          },
                                                                                                          --[[ :: ]]{
                                                                                                            --[[ tuple ]]{
                                                                                                              "lor",
                                                                                                              --[[ INFIXOP3 ]]Block.__(5, {"lor"})
                                                                                                            },
                                                                                                            --[[ :: ]]{
                                                                                                              --[[ tuple ]]{
                                                                                                                "lxor",
                                                                                                                --[[ INFIXOP3 ]]Block.__(5, {"lxor"})
                                                                                                              },
                                                                                                              --[[ :: ]]{
                                                                                                                --[[ tuple ]]{
                                                                                                                  "lsl",
                                                                                                                  --[[ INFIXOP4 ]]Block.__(6, {"lsl"})
                                                                                                                },
                                                                                                                --[[ :: ]]{
                                                                                                                  --[[ tuple ]]{
                                                                                                                    "lsr",
                                                                                                                    --[[ INFIXOP4 ]]Block.__(6, {"lsr"})
                                                                                                                  },
                                                                                                                  --[[ :: ]]{
                                                                                                                    --[[ tuple ]]{
                                                                                                                      "asr",
                                                                                                                      --[[ INFIXOP4 ]]Block.__(6, {"asr"})
                                                                                                                    },
                                                                                                                    --[[ [] ]]0
                                                                                                                  }
                                                                                                                }
                                                                                                              }
                                                                                                            }
                                                                                                          }
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    });

initial_string_buffer = Caml_bytes.caml_create_bytes(256);

string_buff = do
  contents: initial_string_buffer
end;

string_index = do
  contents: 0
end;

function reset_string_buffer(param) do
  string_buff.contents = initial_string_buffer;
  string_index.contents = 0;
  return --[[ () ]]0;
end end

function store_string_char(c) do
  if (string_index.contents >= #string_buff.contents) then do
    new_buff = Caml_bytes.caml_create_bytes((#string_buff.contents << 1));
    Bytes.blit(string_buff.contents, 0, new_buff, 0, #string_buff.contents);
    string_buff.contents = new_buff;
  end
   end 
  string_buff.contents[string_index.contents] = c;
  string_index.contents = string_index.contents + 1 | 0;
  return --[[ () ]]0;
end end

function store_string(s) do
  for i = 0 , #s - 1 | 0 , 1 do
    store_string_char(Caml_string.get(s, i));
  end
  return --[[ () ]]0;
end end

function get_stored_string(param) do
  s = Bytes.sub_string(string_buff.contents, 0, string_index.contents);
  string_buff.contents = initial_string_buffer;
  return s;
end end

string_start_loc = do
  contents: none
end;

comment_start_loc = do
  contents: --[[ [] ]]0
end;

is_in_string = do
  contents: false
end;

print_warnings = do
  contents: true
end;

if_then_else = do
  contents: --[[ Dir_out ]]2
end;

sharp_look_ahead = do
  contents: undefined
end;

function with_comment_buffer(comment, lexbuf) do
  start_loc = curr(lexbuf);
  comment_start_loc.contents = --[[ :: ]]{
    start_loc,
    --[[ [] ]]0
  };
  reset_string_buffer(--[[ () ]]0);
  end_loc = Curry._1(comment, lexbuf);
  s = get_stored_string(--[[ () ]]0);
  reset_string_buffer(--[[ () ]]0);
  loc_loc_start = start_loc.loc_start;
  loc_loc_end = end_loc.loc_end;
  loc_loc_ghost = start_loc.loc_ghost;
  loc = do
    loc_start: loc_loc_start,
    loc_end: loc_loc_end,
    loc_ghost: loc_loc_ghost
  end;
  return --[[ tuple ]]{
          s,
          loc
        };
end end

function char_for_backslash(c) do
  if (c >= 110) then do
    if (c >= 117) then do
      return c;
    end else do
      local ___conditional___=(c - 110 | 0);
      do
         if ___conditional___ = 0 then do
            return --[[ "\n" ]]10;end end end 
         if ___conditional___ = 4 then do
            return --[[ "\r" ]]13;end end end 
         if ___conditional___ = 1
         or ___conditional___ = 2
         or ___conditional___ = 3
         or ___conditional___ = 5 then do
            return c;end end end 
         if ___conditional___ = 6 then do
            return --[[ "\t" ]]9;end end end 
         do
        
      end
    end end 
  end else if (c ~= 98) then do
    return c;
  end else do
    return --[[ "\b" ]]8;
  end end  end 
end end

function char_for_decimal_code(lexbuf, i) do
  c = (Caml_int32.imul(100, Lexing.lexeme_char(lexbuf, i) - 48 | 0) + Caml_int32.imul(10, Lexing.lexeme_char(lexbuf, i + 1 | 0) - 48 | 0) | 0) + (Lexing.lexeme_char(lexbuf, i + 2 | 0) - 48 | 0) | 0;
  if (c < 0 or c > 255) then do
    if (comment_start_loc.contents ~= --[[ [] ]]0) then do
      return --[[ "x" ]]120;
    end else do
      throw {
            __Error$4,
            --[[ Illegal_escape ]]Block.__(1, {Lexing.lexeme(lexbuf)}),
            curr(lexbuf)
          };
    end end 
  end else do
    return Char.chr(c);
  end end 
end end

function char_for_hexadecimal_code(lexbuf, i) do
  d1 = Lexing.lexeme_char(lexbuf, i);
  val1 = d1 >= 97 and d1 - 87 | 0 or (
      d1 >= 65 and d1 - 55 | 0 or d1 - 48 | 0
    );
  d2 = Lexing.lexeme_char(lexbuf, i + 1 | 0);
  val2 = d2 >= 97 and d2 - 87 | 0 or (
      d2 >= 65 and d2 - 55 | 0 or d2 - 48 | 0
    );
  return Char.chr((val1 << 4) + val2 | 0);
end end

function cvt_int_literal(s) do
  return -Caml_format.caml_int_of_string("-" .. s) | 0;
end end

function cvt_int32_literal(s) do
  return -Caml_format.caml_int32_of_string("-" .. __String.sub(s, 0, #s - 1 | 0)) | 0;
end end

function cvt_int64_literal(s) do
  return Caml_int64.neg(Caml_format.caml_int64_of_string("-" .. __String.sub(s, 0, #s - 1 | 0)));
end end

function cvt_nativeint_literal(s) do
  return -Caml_format.caml_nativeint_of_string("-" .. __String.sub(s, 0, #s - 1 | 0));
end end

function remove_underscores(s) do
  l = #s;
  b = Caml_bytes.caml_create_bytes(l);
  _src = 0;
  _dst = 0;
  while(true) do
    dst = _dst;
    src = _src;
    if (src >= l) then do
      if (dst >= l) then do
        return s;
      end else do
        return Bytes.sub_string(b, 0, dst);
      end end 
    end else do
      c = Caml_string.get(s, src);
      if (c ~= 95) then do
        b[dst] = c;
        _dst = dst + 1 | 0;
        _src = src + 1 | 0;
        continue ;
      end else do
        _src = src + 1 | 0;
        continue ;
      end end 
    end end 
  end;
end end

function get_label_name(lexbuf) do
  s = Lexing.lexeme(lexbuf);
  name = __String.sub(s, 1, #s - 2 | 0);
  if (Hashtbl.mem(keyword_table, name)) then do
    throw {
          __Error$4,
          --[[ Keyword_as_label ]]Block.__(4, {name}),
          curr(lexbuf)
        };
  end
   end 
  return name;
end end

function update_loc(lexbuf, file, line, absolute, chars) do
  pos = lexbuf.lex_curr_p;
  new_file = file ~= undefined and file or pos.pos_fname;
  lexbuf.lex_curr_p = do
    pos_fname: new_file,
    pos_lnum: absolute and line or pos.pos_lnum + line | 0,
    pos_bol: pos.pos_cnum - chars | 0,
    pos_cnum: pos.pos_cnum
  end;
  return --[[ () ]]0;
end end

preprocessor = do
  contents: undefined
end;

escaped_newlines = do
  contents: false
end;

comment_list = do
  contents: --[[ [] ]]0
end;

function add_comment(com) do
  comment_list.contents = --[[ :: ]]{
    com,
    comment_list.contents
  };
  return --[[ () ]]0;
end end

function add_docstring_comment(ds) do
  return add_comment(--[[ tuple ]]{
              ds.ds_body,
              ds.ds_loc
            });
end end

function report_error$2(ppf, param) do
  if (typeof param == "number") then do
    local ___conditional___=(param);
    do
       if ___conditional___ = 0--[[ Unterminated_string ]] then do
          return Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "String literal not terminated",
                          --[[ End_of_format ]]0
                        }),
                      "String literal not terminated"
                    });end end end 
       if ___conditional___ = 1--[[ Unterminated_paren_in_conditional ]] then do
          return Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "Unterminated parens in conditional predicate",
                          --[[ End_of_format ]]0
                        }),
                      "Unterminated parens in conditional predicate"
                    });end end end 
       if ___conditional___ = 2--[[ Unterminated_if ]] then do
          return Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "#if not terminated",
                          --[[ End_of_format ]]0
                        }),
                      "#if not terminated"
                    });end end end 
       if ___conditional___ = 3--[[ Unterminated_else ]] then do
          return Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "#else not terminated",
                          --[[ End_of_format ]]0
                        }),
                      "#else not terminated"
                    });end end end 
       if ___conditional___ = 4--[[ Unexpected_token_in_conditional ]] then do
          return Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "Unexpected token in conditional predicate",
                          --[[ End_of_format ]]0
                        }),
                      "Unexpected token in conditional predicate"
                    });end end end 
       if ___conditional___ = 5--[[ Expect_hash_then_in_conditional ]] then do
          return Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "Expect `then` after conditional predicate",
                          --[[ End_of_format ]]0
                        }),
                      "Expect `then` after conditional predicate"
                    });end end end 
       if ___conditional___ = 6--[[ Unexpected_directive ]] then do
          return Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "Unexpected directive",
                          --[[ End_of_format ]]0
                        }),
                      "Unexpected directive"
                    });end end end 
       do
      
    end
  end else do
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ = 0--[[ Illegal_character ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "Illegal character (",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ Char_literal ]]Block.__(12, {
                                      --[[ ")" ]]41,
                                      --[[ End_of_format ]]0
                                    })
                                })
                            }),
                          "Illegal character (%s)"
                        }), Char.escaped(param[0]));end end end 
       if ___conditional___ = 1--[[ Illegal_escape ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "Illegal backslash escape in string or character (",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ Char_literal ]]Block.__(12, {
                                      --[[ ")" ]]41,
                                      --[[ End_of_format ]]0
                                    })
                                })
                            }),
                          "Illegal backslash escape in string or character (%s)"
                        }), param[0]);end end end 
       if ___conditional___ = 2--[[ Unterminated_comment ]] then do
          return Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "Comment not terminated",
                          --[[ End_of_format ]]0
                        }),
                      "Comment not terminated"
                    });end end end 
       if ___conditional___ = 3--[[ Unterminated_string_in_comment ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "This comment contains an unterminated string literal",
                              --[[ Formatting_lit ]]Block.__(17, {
                                  --[[ Flush_newline ]]4,
                                  --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                          "String literal begins here",
                                          --[[ End_of_format ]]0
                                        })})
                                })
                            }),
                          "This comment contains an unterminated string literal@.%aString literal begins here"
                        }), print_error, param[1]);end end end 
       if ___conditional___ = 4--[[ Keyword_as_label ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Char_literal ]]Block.__(12, {
                              --[[ "`" ]]96,
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ String_literal ]]Block.__(11, {
                                      "' is a keyword, it cannot be used as label name",
                                      --[[ End_of_format ]]0
                                    })
                                })
                            }),
                          "`%s' is a keyword, it cannot be used as label name"
                        }), param[0]);end end end 
       if ___conditional___ = 5--[[ Literal_overflow ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "Integer literal exceeds the range of representable integers of type ",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ End_of_format ]]0
                                })
                            }),
                          "Integer literal exceeds the range of representable integers of type %s"
                        }), param[0]);end end end 
       if ___conditional___ = 6--[[ Illegal_semver ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "Illegal semantic version string ",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ End_of_format ]]0
                                })
                            }),
                          "Illegal semantic version string %s"
                        }), param[0]);end end end 
       if ___conditional___ = 7--[[ Conditional_expr_expected_type ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "Conditional expression type mismatch (",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ Char_literal ]]Block.__(12, {
                                      --[[ "," ]]44,
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ Char_literal ]]Block.__(12, {
                                              --[[ ")" ]]41,
                                              --[[ End_of_format ]]0
                                            })
                                        })
                                    })
                                })
                            }),
                          "Conditional expression type mismatch (%s,%s)"
                        }), string_of_type_directive(param[0]), string_of_type_directive(param[1]));end end end 
       do
      
    end
  end end 
end end

register_error_of_exn((function (param) do
        if (param[0] == __Error$4) then do
          return error_of_printer(param[2], report_error$2, param[1]);
        end
         end 
      end end));

__ocaml_lex_tables = do
  lex_base: "\0\0\xa4\xff\xa5\xff\xe0\0\x03\x01&\x01I\x01l\x01\x8f\x01\xbc\xff\xb2\x01\xd7\x01\xc4\xff[\0\xfc\x01\x1f\x02D\0G\0T\0B\x02\xd5\xff\xd7\xff\xda\xffe\x02\xc4\x02\xe7\x02Y\0\xff\0\x05\x03\xec\xffR\x03s\x03\xbc\x03\x8c\x04\\\x05,\x06\x0b\x07g\x077\b}\0\xfe\xff\x01\0\x05\0\xff\xff\x06\0\x07\0\x16\t4\t\x04\n\xfa\xff\xf9\xff\xd4\n\xa4\x0b\xf7\xff\xf6\xff\xed\xff\xee\xff\xef\xff]\0v\x02[\0n\0\xe7\x02\x07\x04\xd7\x04e\x02\xfe\x02v\0\xc2\xff\xeb\xffx\x05\x84\f`\0q\0\x0b\0\xea\xff\xe9\xff\xe5\xff\xe5\x04\x80\0s\0\xe8\xff\xe0\0u\0\xe7\xffw\x06\x93\0\xe6\xff\x92\0\xe1\xff\x94\0\xe0\xff\xd9\0\x84\f\xdf\xff\xab\f\xaf\b\xae\x06\xde\xff\f\0\x18\x01,\x01P\x01-\x01\xde\xff\r\0\xd9\f\0\r#\rI\r\xd2\xff\xce\xff\xcf\xff\xd0\xff\xcc\xffl\r\x9a\0\xb7\0\xc5\xff\xc6\xff\xc7\xff\xc7\0\xb6\xff\xb8\xff\xbf\xff\x8f\r\xbb\xff\xbd\xff\xb2\r\xd5\r\xf8\r\x1b\x0e\xeb\x05\xf3\xff\xf4\xff\x11\0\xf5\xff>\x02\xac\x07\xfd\xff\xdf\0\xf1\0\xff\xff\xfe\xff\xfc\xff\xc8\x07-\x0e\xfa\0\xfc\0\x12\0\xfb\xff\xfa\xff\xf9\xff\x80\t\x1e\x03\x03\x01\xf8\xff\\\x03\x04\x01\xf7\xffO\n\x05\x01\xf6\xff+\x01\xc7\x01\xf7\xff\xf8\xff\xf9\xff;\x01v\x0e\xff\xff\xfa\xff\x1f\x0b$\x04\xfd\xff&\x01E\x01^\x01\xfc\x04\xfc\xff\xef\x0b\xfb\xff_\x01\xb5\x01\xfc\xff\xee\x06\xfe\xff\xff\xffo\x01p\x01\xfd\xffJ\x07\x10\x01\x13\x012\x01?\x01\x1a\x01k\x01!\x01\x13\0\xff\xff",
  lex_backtrk: "\xff\xff\xff\xff\xff\xffX\0W\0T\0S\0L\0J\0\xff\xffA\0>\0\xff\xff7\x006\x004\x002\0.\0,\0O\0\xff\xff\xff\xff\xff\xff#\0\"\0)\0'\0&\0<\0\xff\xff\x0e\0\x0e\0\r\0\f\0\x0b\0\n\0\x07\0\x04\0\x03\0\x02\0\xff\xff[\0[\0\xff\xff\xff\xff\xff\xffR\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x0f\0\xff\xff\xff\xff\xff\xff\x0e\0\x0e\0\x0e\0\x0f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\0\x1a\0\x1a\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\0\xff\xff\x1c\0\xff\xff\x1d\0V\0\xff\xffY\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\0U\0P\0+\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff5\0F\0E\0\xff\xff\xff\xff\xff\xffH\0\xff\xff\xff\xff\xff\xff?\0\xff\xff\xff\xffQ\0K\0N\0M\0\xff\xff\xff\xff\xff\xff\f\0\xff\xff\f\0\f\0\xff\xff\f\0\f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\b\0\b\0\xff\xff\xff\xff\x05\0\x05\0\xff\xff\x01\0\x05\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x03\0\xff\xff\xff\xff\x03\0\xff\xff\xff\xff\xff\xff\x02\0\xff\xff\xff\xff\x01\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
  lex_default: "\x01\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xffH\0\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xffM\0\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\0\0\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xffd\0\xff\xff\0\0\xff\xffd\0e\0d\0g\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\xff\xff\0\0\0\0\0\0\xff\xff\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\x85\0\0\0\0\0\xff\xff\0\0\x93\0\xff\xff\0\0\xff\xff\xff\xff\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\xa5\0\0\0\0\0\0\0\xff\xff\xab\0\0\0\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\0\0\xff\xff\xb8\0\0\0\xff\xff\0\0\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xc2\0\xc5\0\xff\xff\xc5\0\xff\xff\xff\xff\0\0",
  lex_trans: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\0(\0(\0'\0)\0-\0+\0+\0(\0,\0,\0-\0I\0b\0h\0J\0c\0i\0\x86\0\x94\0\xc8\0\xa3\0\x95\0'\0\b\0\x1d\0\x18\0\x06\0\x04\0\x17\0\x1b\0\x1a\0\x15\0\x19\0\x07\0\x14\0\x13\0\x12\0\x03\0\x1f\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x11\0\x10\0\x0f\0\x0e\0\n\0$\0\x05\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\r\0*\0\f\0\x05\0&\0\x16\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\x1c\0\x0b\0\t\0%\0r\0t\0q\0n\0X\0p\0o\0'\0L\0C\0'\0C\0A\0A\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0w\0K\0v\0Q\0u\0T\0'\0@\0@\0@\0@\0@\0@\0@\0@\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0W\0Y\0Z\0[\0\\\0{\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0x\0 \0 \0 \0 \0 \0 \0 \0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0y\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\x02\0\x03\0[\0\\\0\x03\0\x03\0\x03\0z\0\x8f\0I\0\x03\0\x03\0J\0\x03\0\x03\0\x03\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\x03\0\x8e\0\x03\0\x03\0\x03\0\x03\0\x03\0\x98\0b\0\x97\0\x03\0c\0\xff\xff\x03\0\x03\0\x03\0\x9c\0\x9f\0\xa2\0\x03\0\x03\0\xaf\0\x03\0\x03\0\x03\0\xc1\0\xc2\0\x86\0b\0h\0\xa3\0c\0i\0\xc6\0\xc3\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\xc7\0\xa7\0\xaf\0\x05\0\xb6\0\xc4\0\x05\0\x05\0\x05\0\0\0g\0\xaf\0\x05\0\x05\0\xb1\0\x05\0\x05\0\x05\0\0\0\0\0\0\0f\0b\0G\0\x03\0c\0\x03\0\0\0\x05\0\x03\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\xaf\0\xa7\0\x06\0\xb1\0\xb6\0\x06\0\x06\0\x06\0f\0\0\0e\0\x06\0\x06\0\xc4\0\x06\0\x06\0\x06\0\xbb\0\xbb\0\0\0\xbd\0\xbd\0\0\0\x03\0\0\0\x03\0\0\0\x06\0\x05\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0k\0\0\0k\0\x83\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\0\0\0\x05\0\0\0k\0\x06\0k\0\x82\0k\0k\0k\0\0\0\0\0\0\0\x80\0\0\0\0\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\x80\0\x80\0\0\0\x80\0\x80\0\x80\0\xbb\0\0\0\0\0\xbc\0\0\0\0\0\x06\0\0\0\x06\0\0\0\x80\0k\0\x80\0\x81\0\x80\0\x80\0\x80\0\0\0\xa7\0\0\0\x06\0\xa8\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\xaa\0k\0\0\0\x06\0\x80\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\0\0\x06\0\x06\0\x06\0\0\0\xff\xff\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\0\0\x80\0\0\0\x80\0\0\0\x7f\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\0\0\0\0\0\0\0\0\x06\0\0\0\0\0\x06\0\x06\0\x06\0\xa9\0\0\0\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\x06\0~\0\x06\0\xb9\0\xff\xff\0\0|\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\xff\xff\x06\0\0\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\x94\0\x06\0\x06\0\x95\0s\0\x06\0\x06\0\0\0\xff\xff\0\0\0\0}\0\0\0\x06\0\0\0\0\0\0\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0k\0\0\0\x96\0k\0k\0k\0\0\0\0\0\xff\xffk\0k\0\0\0k\0l\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\x06\0\0\0k\0\x06\0k\0k\0m\0k\0k\0\0\0\0\0\0\0\x06\0\0\0\0\0\x06\0\x06\0j\0\0\0\0\0\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0A\0A\0\0\0\0\0\0\0\x92\0\x06\0\0\0\x06\0\0\0\x06\0k\0\x06\0\x06\0\x06\0\x06\0\x06\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0\0\x008\0\0\0\0\0\0\0\xba\0\0\0\0\0\0\0\0\0\0\0:\0\0\0\0\0k\0\0\0k\0\0\0\0\0\x06\0A\0\0\0\0\0\xa6\0\0\0\0\0\0\0\0\0\0\0a\0\0\0\0\0\0\x009\0\0\x007\0\0\0;\0\0\0\0\0\0\0\0\0\0\0:\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\x06\0a\0_\0\0\0_\0_\0_\0_\0\0\0\0\0\0\0_\0_\0\0\0_\0_\0_\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0_\0\0\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\x03\0\0\0\0\0\x03\0\x03\0\x03\0\0\0\0\0^\0]\0\x03\0\0\0\x03\0\x03\0\x03\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0\x03\0_\0\x03\0\x03\0\x03\0\x03\0\x03\0?\0?\0?\0?\0?\0?\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\0\0_\0D\0_\0\0\0\0\0\x03\0\0\0\0\0?\0?\0?\0?\0?\0?\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\0\0\0\0\0\0\0\0\0\0B\0\0\0\0\0\0\0\0\0\0\0\x03\0F\0\x03\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0;\0E\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\0\0:\0\0\0\0\0\0\0\0\0\0\0\0\x008\0\0\0\0\0;\0\0\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\0\0\0\0\0\0\0\0\x1e\0\0\0\0\0\0\0<\0\0\0:\0:\0\0\0\0\0\0\0\0\0\0\x009\x008\x007\0\0\0=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0>\0\0\0\0\0\0\0\0\0\0\0\0\0\x1e\0\0\0\0\0<\0\0\0\0\0:\0\0\0\0\0\0\0\0\0\0\0\0\x009\0\0\x007\0=\0 \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0>\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\0\0\0\0\0\0\0\0 \0\0\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0?\0?\0?\0?\0?\0?\0\0\0\0\0\0\0\0\0\0\x008\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0?\0\0\0?\0?\0?\0?\0?\0?\0\0\0\0\0\0\0\0\0\0\x009\0\0\x007\0\0\0\0\0\0\0\0\0\0\0\0\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\0\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0!\0 \0 \0 \0 \0 \0 \0 \0 \0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\0\0\0\0\0\0\0\0!\0\0\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0@\0@\0@\0@\0@\0@\0@\0@\0\0\0\0\0\0\0\0\0\0\0\0\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0\0\0\0\0\0\0\0\x008\0\0\0\0\0U\0U\0U\0U\0U\0U\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0@\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x009\0\0\x007\0U\0U\0U\0U\0U\0U\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\0\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\"\0 \0 \0 \0 \0 \0 \0 \0 \0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\0\0\0\0\0\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0F\0\0\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0\0\0E\0\x86\0\0\0\0\0\x87\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8b\0\0\0\0\0\0\0\0\0\x89\0\x8d\0\0\0\x8c\0\0\0\0\0\0\0\0\0\0\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0#\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\x8a\0\0\0\0\0\0\0\0\0\0\0\0\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\0\0\0\0\0\0\0\0#\0\0\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0\0\0\0\0\0\0\0\0\0\0\0\0a\0V\0V\0V\0V\0V\0V\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0V\0V\0V\0V\0V\0V\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0\0\0\0\0\0\0\x88\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0.\0\0\0\0\0.\0.\0.\0\0\0\0\0\0\0.\0.\0\0\0.\0.\0.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0.\0\0\0.\0.\0.\0.\0.\0\0\0\xbf\0\0\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0.\x004\0\xbe\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\0\0.\0.\0.\0\0\0.\0.\0.\0\0\0\0\0\0\0.\0.\0\0\0.\0.\0.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0.\0\0\0.\0.\0.\0.\0.\0\0\0\xbf\0\0\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0.\x000\0\xbe\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\0\0.\0\0\0.\0\0\0\0\0\0\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\0\x003\x003\x003\x003\x003\x003\x003\x003\0\x91\0\0\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x90\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\0\0\x90\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0#\0/\0/\0/\0/\0/\0/\0/\0/\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\0\0\0\0\0\0\0\0#\0\0\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\0\0\0\0\0\0\0\0\0\0\0\0f\0b\0\0\0\0\0c\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0f\0\0\0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0.\0\0\0\0\0.\0.\0.\0\0\0\0\0\0\0.\0.\0\0\0.\0.\0.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0.\0\0\0.\0.\0.\0.\0.\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\x002\0\0\0\0\0\0\0\0\0\0\0.\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\0\0\0\0\0\0.\0/\0.\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\x000\0/\0/\0/\0/\0/\0/\0/\0/\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x001\0\0\0\0\0\0\0\0\0\0\0\0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\0\0\0\0\0\0\0\x000\0\0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\x003\0/\0/\0/\0/\0/\0/\0/\0/\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x006\0\0\0\0\0\0\0\0\0\0\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\0\0\0\0\0\0\0\x003\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x004\x003\x003\x003\x003\x003\x003\x003\x003\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x005\0\0\0\0\0\0\0\0\0\0\0\0\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\0\0\0\0\0\0\0\x004\0\0\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\0\x003\x003\x003\x003\x003\x003\x003\x003\0P\0]\0P\0\0\0]\0]\0]\0P\0\0\0\0\0]\0]\0\0\0]\0]\0]\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0]\0\0\0]\0]\0]\0]\0]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\0\0\0_\0_\0_\0_\0\0\0\0\0\0\0_\0_\0\0\0_\0_\0_\0\0\0\0\0\0\0\0\0\0\0P\0\0\0]\0\0\0\0\0_\0P\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\0\0\0\0\0\0P\0\0\0\0\0\0\0P\0\0\0P\0\0\0\x06\0\0\0N\0\x06\0\x06\0\x06\0]\0\0\0]\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0_\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0_\0\0\0_\0k\0k\0\0\0k\0k\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\0\0k\0\0\0k\0k\0k\0k\0k\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0k\0\0\0k\0k\0k\0\0\0\0\0\x06\0\0\0\x06\0\0\0\0\0\0\0\0\0\0\0k\0k\0k\0k\0k\0k\0k\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0k\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0\0\0k\0\0\0\0\0k\0\0\0k\0\xff\xffk\0k\0k\0k\0k\0\0\0\0\0\0\0\x06\0\0\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0k\0\0\0k\0\0\0\0\0\0\0\0\0\x06\0k\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\x06\0\0\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\0\0k\0\0\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\x80\0\0\0\0\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\x80\0\x80\0\0\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\x06\0\0\0\x80\0\x06\0\x80\0\x80\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\x80\0\0\0\0\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\x80\0\x80\0\0\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\x06\0\0\0\x80\0\x80\0\x80\0\x80\0\x80\0\x80\0\x80\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0k\0\0\0k\0k\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x80\0\0\0\x80\0\0\0k\0\x80\0k\0k\0k\0k\0k\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0k\0\0\0k\0k\0k\0\0\0\0\0\x9b\0\0\0\x9b\0\0\0\x80\0\0\0\x80\0\x9b\0k\0k\0k\0k\0k\0k\0k\0\0\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\0\0k\0\0\0\0\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\xaf\0\0\0\0\0\xb0\0\0\0\0\0\0\0\0\0\0\0\x9b\0\0\0\0\0\0\0\0\0\0\0\x9b\0\0\0\0\0\0\0\0\0\0\0\0\0\xae\0k\0\xae\0k\0\0\0\x9b\0\0\0\xae\0\0\0\x9b\0\0\0\x9b\0\0\0\0\0\0\0\x99\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xae\0\0\0\0\0\0\0\0\0\0\0\xae\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xae\0\0\0\0\0\0\0\xae\0\0\0\xae\0\0\0\0\0\0\0\xac\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff",
  lex_check: "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0)\0\0\0\0\0)\0*\0,\0-\0*\0,\0-\0J\0c\0i\0J\0c\0i\0\x87\0\x95\0\xc7\0\x87\0\x95\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x10\0\r\0\x11\0\x12\0\x1a\0\x11\0\x11\0'\0H\0:\0'\0:\0<\0<\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0\r\0I\0\r\0P\0\r\0S\0'\0=\0=\0=\0=\0=\0=\0=\0=\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0V\0X\0X\0Z\0Z\0t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\0\\\0\\\0\x03\0\x03\0\x03\0y\0\x8c\0\x1b\0\x03\0\x03\0\x1b\0\x03\0\x03\0\x03\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0\x03\0\x8d\0\x03\0\x03\0\x03\0\x03\0\x03\0\x93\0d\0\x94\0\x04\0d\0\x1b\0\x04\0\x04\0\x04\0\x9b\0\x9e\0\xa1\0\x04\0\x04\0\xaf\0\x04\0\x04\0\x04\0\xc0\0\xc1\0\xa3\0e\0g\0\xa3\0e\0g\0\xc4\0\xc2\0\x04\0\x03\0\x04\0\x04\0\x04\0\x04\0\x04\0\xc6\0\xa8\0\xaf\0\x05\0\xa8\0\xc3\0\x05\0\x05\0\x05\0\xff\xffe\0\xb0\0\x05\0\x05\0\xb0\0\x05\0\x05\0\x05\0\xff\xff\xff\xff\xff\xfff\0f\0\x1b\0\x03\0f\0\x03\0\xff\xff\x05\0\x04\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\xb1\0\xb6\0\x06\0\xb1\0\xb6\0\x06\0\x06\0\x06\0f\0\xff\xfff\0\x06\0\x06\0\xc5\0\x06\0\x06\0\x06\0\xbc\0\xbd\0\xff\xff\xbc\0\xbd\0\xff\xff\x04\0\xff\xff\x04\0\xff\xff\x06\0\x05\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\xff\xff\x07\0\xff\xff\xff\xff\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\x07\0\x07\0\xff\xff\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x05\0\xff\xff\x05\0\xff\xff\x07\0\x06\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\b\0\xff\xff\xff\xff\b\0\b\0\b\0\xff\xff\xff\xff\xff\xff\b\0\b\0\xff\xff\b\0\b\0\b\0\xb7\0\xff\xff\xff\xff\xb7\0\xff\xff\xff\xff\x06\0\xff\xff\x06\0\xff\xff\b\0\x07\0\b\0\b\0\b\0\b\0\b\0\xff\xff\xa4\0\xff\xff\n\0\xa4\0\xff\xff\n\0\n\0\n\0\xff\xff\xff\xff\xff\xff\n\0\n\0\xff\xff\n\0\n\0\n\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x07\0\xa4\0\x07\0\xff\xff\n\0\b\0\n\0\n\0\n\0\n\0\n\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x0b\0\xff\xff\xff\xff\x0b\0\x0b\0\x0b\0\xff\xff\x1b\0\xff\xff\x0b\0\x0b\0\xff\xff\x0b\0\x0b\0\x0b\0\xff\xff\xff\xff\xff\xff\xff\xff\b\0\xff\xff\b\0\xff\xff\n\0\n\0\x0b\0\xff\xff\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0d\0\xff\xff\xff\xff\xff\xff\xff\xff\x0e\0\xff\xff\xff\xff\x0e\0\x0e\0\x0e\0\xa4\0\xff\xff\xff\xff\x0e\0\x0e\0\xff\xff\x0e\0\x0e\0\x0e\0e\0g\0\n\0\n\0\n\0\xb7\0\xc2\0\xff\xff\x0b\0\x0b\0\x0e\0\xff\xff\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\xff\xff\xff\xff\xc3\0\x0f\0\xff\xff\xff\xff\x0f\0\x0f\0\x0f\0\xff\xff\xff\xff\x89\0\x0f\0\x0f\0\x89\0\x0f\0\x0f\0\x0f\0\xff\xfff\0\xff\xff\xff\xff\x0b\0\xff\xff\x0b\0\xff\xff\xff\xff\xff\xff\x0f\0\x0e\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\xff\xff\xff\xff\xff\xff\x13\0\xff\xff\x89\0\x13\0\x13\0\x13\0\xff\xff\xff\xff\xc5\0\x13\0\x13\0\xff\xff\x13\0\x13\0\x13\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x0e\0\xff\xff\x0e\0\xff\xff\x13\0\x0f\0\x13\0\x13\0\x13\0\x13\0\x13\0\xff\xff\xff\xff\xff\xff\x17\0\xff\xff\xff\xff\x17\0\x17\0\x17\0\xff\xff\xff\xff\xff\xff\x17\0\x17\0\xff\xff\x17\0\x17\0\x17\0A\0A\0\xff\xff\xff\xff\xff\xff\x89\0\x0f\0\xff\xff\x0f\0\xff\xff\x17\0\x13\0\x17\0\x17\0\x17\0\x17\0\x17\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0\xff\xffA\0\xff\xff\xff\xff\xff\xff\xb7\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff;\0\xff\xff\xff\xff\x13\0\xff\xff\x13\0\xff\xff\xff\xff\x17\0A\0\xff\xff\xff\xff\xa4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x18\0\xff\xff\xff\xff\xff\xffA\0\xff\xffA\0\xff\xff;\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff;\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x17\0\xff\xff\x17\0\x18\0\x18\0\xff\xff\x18\0\x18\0\x18\0\x18\0\xff\xff\xff\xff\xff\xff\x18\0\x18\0\xff\xff\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\xff\xff\x18\0\x18\0\x18\0\x18\0\x18\0\xff\xff\xff\xff\xff\xff\x19\0\xff\xff\xff\xff\x19\0\x19\0\x19\0\xff\xff\xff\xff\x19\0\x19\0\x19\0\xff\xff\x19\0\x19\0\x19\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0\x19\0\x18\0\x19\0\x19\0\x19\0\x19\0\x19\0>\0>\0>\0>\0>\0>\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x89\0\xff\xff\x18\0\x1c\0\x18\0\xff\xff\xff\xff\x19\0\xff\xff\xff\xff>\0>\0>\0>\0>\0>\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffB\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x19\0\x1c\0\x19\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1e\0\x1c\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\xff\xff\x1e\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1e\0\xff\xff\xff\xff\x1f\0\xff\xff\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\xff\xff\xff\xff\xff\xff\xff\xff\x1e\0\xff\xff\xff\xff\xff\xff\x1f\0\xff\xff\x1e\0\x1f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1e\0\x1f\0\x1e\0\xff\xff\x1f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1f\0\xff\xff\xff\xff\x1f\0\xff\xff\xff\xff\x1f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1f\0\xff\xff\x1f\0\x1f\0 \0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1f\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\xff\xff\xff\xff\xff\xff\xff\xff \0\xff\xff \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff?\0?\0?\0?\0?\0?\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff?\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff?\0\xff\xff?\0?\0?\0?\0?\0?\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff?\0\xff\xff?\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\xff\xff \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0!\0 \0 \0 \0 \0 \0 \0 \0 \0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\xff\xff\xff\xff\xff\xff\xff\xff!\0\xff\xff!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0@\0@\0@\0@\0@\0@\0@\0@\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffN\0N\0N\0N\0N\0N\0N\0N\0N\0N\0\xff\xff\xff\xff\xff\xff\xff\xff@\0\xff\xff\xff\xffN\0N\0N\0N\0N\0N\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0@\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff@\0\xff\xff@\0N\0N\0N\0N\0N\0N\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\xff\xff!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\"\0!\0!\0!\0!\0!\0!\0!\0!\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\xff\xff\xff\xff\xff\xff\xff\xff\"\0\xff\xff\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0F\0\xff\xffF\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0\xff\xffF\0\x84\0\xff\xff\xff\xff\x84\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x84\0\xff\xff\xff\xff\xff\xff\xff\xff\x84\0\x84\0\xff\xff\x84\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\xff\xff\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0#\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\x84\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\xff\xff\xff\xff\xff\xff\xff\xff#\0\xff\xff#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffa\0U\0U\0U\0U\0U\0U\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffa\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffU\0U\0U\0U\0U\0U\0a\0a\0a\0a\0a\0a\0a\0a\0a\0a\0\xff\xff\xff\xff\xff\xff\x84\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\xff\xff#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\xff\xff#\0#\0#\0#\0#\0#\0#\0#\0$\0\xff\xff\xff\xff$\0$\0$\0\xff\xff\xff\xff\xff\xff$\0$\0\xff\xff$\0$\0$\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\0\xff\xff$\0$\0$\0$\0$\0\xff\xff\xb9\0\xff\xff\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0$\0$\0\xb9\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0\xff\xff$\0%\0$\0\xff\xff%\0%\0%\0\xff\xff\xff\xff\xff\xff%\0%\0\xff\xff%\0%\0%\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\0\xff\xff%\0%\0%\0%\0%\0\xff\xff\xbf\0\xff\xff\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0%\0%\0\xbf\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0\xff\xff%\0\xff\xff%\0\xff\xff\xff\xff\xff\xff\xff\xff$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0\xff\xff$\0$\0$\0$\0$\0$\0$\0$\0\x8a\0\xff\xff\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x91\0\x8a\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\xff\xff\x91\0\xff\xff%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0&\0%\0%\0%\0%\0%\0%\0%\0%\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0\xff\xff\xff\xff\xff\xff\xff\xff&\0\xff\xff&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\0`\0\xff\xff\xff\xff`\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\0\xff\xff`\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0\xff\xff&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0\xff\xff&\0&\0&\0&\0&\0&\0&\0&\0.\0\xff\xff\xff\xff.\0.\0.\0\xff\xff\xff\xff\xff\xff.\0.\0\xff\xff.\0.\0.\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff.\0\xff\xff.\0.\0.\0.\0.\0\xff\xff\xff\xff\xff\xff\xff\xff/\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff.\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff\xff\xff\xff\xff.\0/\0.\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0`\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\x000\0/\0/\0/\0/\0/\0/\0/\0/\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xff\xff\xff\xff\xff\xff\xff\xff0\0\xff\xff0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xff\xff0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x003\x000\x000\x000\x000\x000\x000\x000\x000\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff3\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xff\xff\xff\xff\xff\xff\xff\xff3\0\xff\xff3\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff3\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xff\xff3\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x004\x003\x003\x003\x003\x003\x003\x003\x003\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xff\xff\xff\xff\xff\xff\xff\xff4\0\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xff\xff4\x004\x004\x004\x004\x004\x004\x004\0G\0]\0G\0\xff\xff]\0]\0]\0G\0\xff\xff\xff\xff]\0]\0\xff\xff]\0]\0]\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0]\0\xff\xff]\0]\0]\0]\0]\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff_\0\xff\xff_\0_\0_\0_\0\xff\xff\xff\xff\xff\xff_\0_\0\xff\xff_\0_\0_\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffG\0\xff\xff]\0\xff\xff\xff\xff_\0G\0_\0_\0_\0_\0_\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffG\0\xff\xff\xff\xff\xff\xffG\0\xff\xffG\0\xff\xffj\0\xff\xffG\0j\0j\0j\0]\0\xff\xff]\0j\0j\0\xff\xffj\0j\0j\0_\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffj\0\xff\xffj\0j\0j\0j\0j\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffk\0\xff\xff\xff\xffk\0k\0k\0_\0\xff\xff_\0k\0k\0\xff\xffk\0k\0k\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffj\0\xff\xff\xff\xffk\0\xff\xffk\0k\0k\0k\0k\0\xff\xff\xff\xff\xff\xffl\0\xff\xff\xff\xffl\0l\0l\0\xff\xff\xff\xff\xff\xffl\0l\0\xff\xffl\0l\0l\0\xff\xff\xff\xffj\0\xff\xffj\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffl\0k\0l\0l\0l\0l\0l\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffm\0\xff\xff\xff\xffm\0m\0m\0\xff\xff\xff\xff\xff\xffm\0m\0\xff\xffm\0m\0m\0\xff\xff\xff\xff\xff\xffk\0\xff\xffk\0\xff\xff\xff\xffl\0\xff\xffm\0G\0m\0m\0m\0m\0m\0\xff\xff\xff\xff\xff\xffs\0\xff\xff\xff\xffs\0s\0s\0\xff\xff\xff\xff\xff\xffs\0s\0\xff\xffs\0s\0s\0\xff\xff\xff\xff\xff\xffl\0\xff\xffl\0\xff\xff\xff\xff\xff\xff\xff\xffs\0m\0s\0s\0s\0s\0s\0\xff\xff\xff\xff\xff\xff}\0\xff\xff\xff\xff}\0}\0}\0\xff\xff\xff\xff\xff\xff}\0}\0\xff\xff}\0}\0}\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffm\0\xff\xffm\0\xff\xff}\0s\0}\0}\0}\0}\0}\0\xff\xff\xff\xff\xff\xff\x80\0\xff\xff\xff\xff\x80\0\x80\0\x80\0\xff\xff\xff\xff\xff\xff\x80\0\x80\0\xff\xff\x80\0\x80\0\x80\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffs\0\xff\xffs\0\xff\xff\x80\0}\0\x80\0\x80\0\x80\0\x80\0\x80\0\xff\xff\xff\xff\xff\xff\x81\0\xff\xff\xff\xff\x81\0\x81\0\x81\0\xff\xff\xff\xff\xff\xff\x81\0\x81\0\xff\xff\x81\0\x81\0\x81\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff}\0\xff\xff}\0\xff\xff\x81\0\x80\0\x81\0\x81\0\x81\0\x81\0\x81\0\xff\xff\xff\xff\xff\xff\x82\0\xff\xff\xff\xff\x82\0\x82\0\x82\0\xff\xff\xff\xff\xff\xff\x82\0\x82\0\xff\xff\x82\0\x82\0\x82\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x80\0\xff\xff\x80\0\xff\xff\x82\0\x81\0\x82\0\x82\0\x82\0\x82\0\x82\0\xff\xff\xff\xff\xff\xff\x83\0\xff\xff\xff\xff\x83\0\x83\0\x83\0\xff\xff\xff\xff\xff\xff\x83\0\x83\0\xff\xff\x83\0\x83\0\x83\0\xff\xff\xff\xff\x92\0\xff\xff\x92\0\xff\xff\x81\0\xff\xff\x81\0\x92\0\x83\0\x82\0\x83\0\x83\0\x83\0\x83\0\x83\0\xff\xff\x92\0\x92\0\x92\0\x92\0\x92\0\x92\0\x92\0\x92\0\x92\0\x92\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x82\0\xff\xff\x82\0\xff\xff\xff\xff\x83\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x92\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x92\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0\x83\0\xa9\0\x83\0\xff\xff\x92\0\xff\xff\xa9\0\xff\xff\x92\0\xff\xff\x92\0\xff\xff\xff\xff\xff\xff\x92\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0",
  lex_base_code: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\0$\0\f\0\0\0\0\0\0\0\x02\0\0\0\x1b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
  lex_backtrk_code: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
  lex_default_code: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
  lex_trans_code: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0$\0$\0\0\0$\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\x01\0\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\x01\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
  lex_check_code: "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x18\0e\0\xa9\0\xb0\0e\0\xb1\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x18\0\xff\xffe\0\0\0f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\0a\0\xff\xff\xff\xff\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0a\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffa\0a\0a\0a\0a\0a\0a\0a\0a\0a\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffe\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
  lex_code: "\xff\x04\xff\xff\x05\xff\xff\x07\xff\x06\xff\xff\x03\xff\0\x04\x01\x05\xff\x07\xff\xff\x06\xff\x07\xff\xff\0\x04\x01\x05\x03\x06\x02\x07\xff\x01\xff\xff\0\x01\xff"
end;

function token(lexbuf) do
  lexbuf.lex_mem = Caml_array.caml_make_vect(8, -1);
  lexbuf$1 = lexbuf;
  ___ocaml_lex_state = 0;
  while(true) do
    __ocaml_lex_state = ___ocaml_lex_state;
    __ocaml_lex_state$1 = Lexing.new_engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf$1);
    local ___conditional___=(__ocaml_lex_state$1);
    do
       if ___conditional___ = 0 then do
          if (not escaped_newlines.contents) then do
            throw {
                  __Error$4,
                  --[[ Illegal_character ]]Block.__(0, {Lexing.lexeme_char(lexbuf$1, 0)}),
                  curr(lexbuf$1)
                };
          end
           end 
          update_loc(lexbuf$1, undefined, 1, false, 0);
          return token(lexbuf$1);end end end 
       if ___conditional___ = 1 then do
          update_loc(lexbuf$1, undefined, 1, false, 0);
          return --[[ EOL ]]100;end end end 
       if ___conditional___ = 2 then do
          return token(lexbuf$1);end end end 
       if ___conditional___ = 3 then do
          return --[[ UNDERSCORE ]]94;end end end 
       if ___conditional___ = 4 then do
          return --[[ TILDE ]]89;end end end 
       if ___conditional___ = 5 then do
          return --[[ LABEL ]]Block.__(10, {get_label_name(lexbuf$1)});end end end 
       if ___conditional___ = 6 then do
          prerr_warning(curr(lexbuf$1), --[[ Deprecated ]]Block.__(0, {"ISO-Latin1 characters in identifiers"}));
          return --[[ LABEL ]]Block.__(10, {get_label_name(lexbuf$1)});end end end 
       if ___conditional___ = 7 then do
          return --[[ QUESTION ]]76;end end end 
       if ___conditional___ = 8 then do
          return --[[ OPTLABEL ]]Block.__(13, {get_label_name(lexbuf$1)});end end end 
       if ___conditional___ = 9 then do
          prerr_warning(curr(lexbuf$1), --[[ Deprecated ]]Block.__(0, {"ISO-Latin1 characters in identifiers"}));
          return --[[ OPTLABEL ]]Block.__(13, {get_label_name(lexbuf$1)});end end end 
       if ___conditional___ = 10 then do
          s = Lexing.lexeme(lexbuf$1);
          try do
            return Hashtbl.find(keyword_table, s);
          end
          catch (exn)do
            if (exn == Caml_builtin_exceptions.not_found) then do
              return --[[ LIDENT ]]Block.__(11, {s});
            end else do
              throw exn;
            end end 
          endend end end 
       if ___conditional___ = 11 then do
          prerr_warning(curr(lexbuf$1), --[[ Deprecated ]]Block.__(0, {"ISO-Latin1 characters in identifiers"}));
          return --[[ LIDENT ]]Block.__(11, {Lexing.lexeme(lexbuf$1)});end end end 
       if ___conditional___ = 12 then do
          return --[[ UIDENT ]]Block.__(17, {Lexing.lexeme(lexbuf$1)});end end end 
       if ___conditional___ = 13 then do
          prerr_warning(curr(lexbuf$1), --[[ Deprecated ]]Block.__(0, {"ISO-Latin1 characters in identifiers"}));
          return --[[ UIDENT ]]Block.__(17, {Lexing.lexeme(lexbuf$1)});end end end 
       if ___conditional___ = 14 then do
          try do
            return --[[ INT ]]Block.__(7, {cvt_int_literal(Lexing.lexeme(lexbuf$1))});
          end
          catch (raw_exn)do
            exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn$1[0] == Caml_builtin_exceptions.failure) then do
              throw {
                    __Error$4,
                    --[[ Literal_overflow ]]Block.__(5, {"int"}),
                    curr(lexbuf$1)
                  };
            end
             end 
            throw exn$1;
          endend end end 
       if ___conditional___ = 15 then do
          return --[[ FLOAT ]]Block.__(1, {remove_underscores(Lexing.lexeme(lexbuf$1))});end end end 
       if ___conditional___ = 16 then do
          try do
            return --[[ INT32 ]]Block.__(8, {cvt_int32_literal(Lexing.lexeme(lexbuf$1))});
          end
          catch (raw_exn$1)do
            exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
            if (exn$2[0] == Caml_builtin_exceptions.failure) then do
              throw {
                    __Error$4,
                    --[[ Literal_overflow ]]Block.__(5, {"int32"}),
                    curr(lexbuf$1)
                  };
            end
             end 
            throw exn$2;
          endend end end 
       if ___conditional___ = 17 then do
          try do
            return --[[ INT64 ]]Block.__(9, {cvt_int64_literal(Lexing.lexeme(lexbuf$1))});
          end
          catch (raw_exn$2)do
            exn$3 = Caml_js_exceptions.internalToOCamlException(raw_exn$2);
            if (exn$3[0] == Caml_builtin_exceptions.failure) then do
              throw {
                    __Error$4,
                    --[[ Literal_overflow ]]Block.__(5, {"int64"}),
                    curr(lexbuf$1)
                  };
            end
             end 
            throw exn$3;
          endend end end 
       if ___conditional___ = 18 then do
          try do
            return --[[ NATIVEINT ]]Block.__(12, {cvt_nativeint_literal(Lexing.lexeme(lexbuf$1))});
          end
          catch (raw_exn$3)do
            exn$4 = Caml_js_exceptions.internalToOCamlException(raw_exn$3);
            if (exn$4[0] == Caml_builtin_exceptions.failure) then do
              throw {
                    __Error$4,
                    --[[ Literal_overflow ]]Block.__(5, {"nativeint"}),
                    curr(lexbuf$1)
                  };
            end
             end 
            throw exn$4;
          endend end end 
       if ___conditional___ = 19 then do
          reset_string_buffer(--[[ () ]]0);
          is_in_string.contents = true;
          string_start = lexbuf$1.lex_start_p;
          string_start_loc.contents = curr(lexbuf$1);
          string(lexbuf$1);
          is_in_string.contents = false;
          lexbuf$1.lex_start_p = string_start;
          return --[[ STRING ]]Block.__(16, {--[[ tuple ]]{
                      get_stored_string(--[[ () ]]0),
                      undefined
                    }});end end end 
       if ___conditional___ = 20 then do
          reset_string_buffer(--[[ () ]]0);
          delim = Lexing.lexeme(lexbuf$1);
          delim$1 = __String.sub(delim, 1, #delim - 2 | 0);
          is_in_string.contents = true;
          string_start$1 = lexbuf$1.lex_start_p;
          string_start_loc.contents = curr(lexbuf$1);
          __ocaml_lex_quoted_string_rec(delim$1, lexbuf$1, 183);
          is_in_string.contents = false;
          lexbuf$1.lex_start_p = string_start$1;
          return --[[ STRING ]]Block.__(16, {--[[ tuple ]]{
                      get_stored_string(--[[ () ]]0),
                      delim$1
                    }});end end end 
       if ___conditional___ = 21 then do
          update_loc(lexbuf$1, undefined, 1, false, 1);
          return --[[ CHAR ]]Block.__(0, {Lexing.lexeme_char(lexbuf$1, 1)});end end end 
       if ___conditional___ = 22 then do
          return --[[ CHAR ]]Block.__(0, {Lexing.lexeme_char(lexbuf$1, 1)});end end end 
       if ___conditional___ = 23 then do
          return --[[ CHAR ]]Block.__(0, {char_for_backslash(Lexing.lexeme_char(lexbuf$1, 2))});end end end 
       if ___conditional___ = 24 then do
          return --[[ CHAR ]]Block.__(0, {char_for_decimal_code(lexbuf$1, 2)});end end end 
       if ___conditional___ = 25 then do
          return --[[ CHAR ]]Block.__(0, {char_for_hexadecimal_code(lexbuf$1, 3)});end end end 
       if ___conditional___ = 26 then do
          l = Lexing.lexeme(lexbuf$1);
          esc = __String.sub(l, 1, #l - 1 | 0);
          throw {
                __Error$4,
                --[[ Illegal_escape ]]Block.__(1, {esc}),
                curr(lexbuf$1)
              };end end end 
       if ___conditional___ = 27 then do
          match = with_comment_buffer(comment, lexbuf$1);
          return --[[ COMMENT ]]Block.__(18, {--[[ tuple ]]{
                      match[0],
                      match[1]
                    }});end end end 
       if ___conditional___ = 28 then do
          match$1 = with_comment_buffer(comment, lexbuf$1);
          return --[[ DOCSTRING ]]Block.__(19, {docstring(match$1[0], match$1[1])});end end end 
       if ___conditional___ = 29 then do
          stars = Lexing.sub_lexeme(lexbuf$1, lexbuf$1.lex_start_pos, lexbuf$1.lex_curr_pos);
          match$2 = with_comment_buffer((function(stars)do
              return function (lexbuf) do
                store_string("*" .. stars);
                return __ocaml_lex_comment_rec(lexbuf, 132);
              end end
              end(stars)), lexbuf$1);
          return --[[ COMMENT ]]Block.__(18, {--[[ tuple ]]{
                      match$2[0],
                      match$2[1]
                    }});end end end 
       if ___conditional___ = 30 then do
          if (print_warnings.contents) then do
            prerr_warning(curr(lexbuf$1), --[[ Comment_start ]]0);
          end
           end 
          match$3 = with_comment_buffer(comment, lexbuf$1);
          return --[[ COMMENT ]]Block.__(18, {--[[ tuple ]]{
                      match$3[0],
                      match$3[1]
                    }});end end end 
       if ___conditional___ = 31 then do
          stars$1 = Lexing.sub_lexeme(lexbuf$1, lexbuf$1.lex_start_pos, lexbuf$1.lex_curr_pos - 2 | 0);
          return --[[ COMMENT ]]Block.__(18, {--[[ tuple ]]{
                      stars$1,
                      curr(lexbuf$1)
                    }});end end end 
       if ___conditional___ = 32 then do
          loc = curr(lexbuf$1);
          prerr_warning(loc, --[[ Comment_not_end ]]1);
          lexbuf$1.lex_curr_pos = lexbuf$1.lex_curr_pos - 1 | 0;
          curpos = lexbuf$1.lex_curr_p;
          lexbuf$1.lex_curr_p = do
            pos_fname: curpos.pos_fname,
            pos_lnum: curpos.pos_lnum,
            pos_bol: curpos.pos_bol,
            pos_cnum: curpos.pos_cnum - 1 | 0
          end;
          return --[[ STAR ]]86;end end end 
       if ___conditional___ = 33 then do
          num = Lexing.sub_lexeme(lexbuf$1, Caml_array.caml_array_get(lexbuf$1.lex_mem, 0), Caml_array.caml_array_get(lexbuf$1.lex_mem, 1));
          name = Lexing.sub_lexeme_opt(lexbuf$1, Caml_array.caml_array_get(lexbuf$1.lex_mem, 3), Caml_array.caml_array_get(lexbuf$1.lex_mem, 2));
          update_loc(lexbuf$1, name, Caml_format.caml_int_of_string(num), true, 0);
          return token(lexbuf$1);end end end 
       if ___conditional___ = 34 then do
          return --[[ SHARP ]]84;end end end 
       if ___conditional___ = 35 then do
          return --[[ AMPERSAND ]]1;end end end 
       if ___conditional___ = 36 then do
          return --[[ AMPERAMPER ]]0;end end end 
       if ___conditional___ = 37 then do
          return --[[ BACKQUOTE ]]5;end end end 
       if ___conditional___ = 38 then do
          return --[[ QUOTE ]]77;end end end 
       if ___conditional___ = 39 then do
          return --[[ LPAREN ]]54;end end end 
       if ___conditional___ = 40 then do
          return --[[ RPAREN ]]81;end end end 
       if ___conditional___ = 41 then do
          return --[[ STAR ]]86;end end end 
       if ___conditional___ = 42 then do
          return --[[ COMMA ]]16;end end end 
       if ___conditional___ = 43 then do
          return --[[ MINUSGREATER ]]62;end end end 
       if ___conditional___ = 44 then do
          return --[[ DOT ]]20;end end end 
       if ___conditional___ = 45 then do
          return --[[ DOTDOT ]]21;end end end 
       if ___conditional___ = 46 then do
          return --[[ COLON ]]12;end end end 
       if ___conditional___ = 47 then do
          return --[[ COLONCOLON ]]13;end end end 
       if ___conditional___ = 48 then do
          return --[[ COLONEQUAL ]]14;end end end 
       if ___conditional___ = 49 then do
          return --[[ COLONGREATER ]]15;end end end 
       if ___conditional___ = 50 then do
          return --[[ SEMI ]]82;end end end 
       if ___conditional___ = 51 then do
          return --[[ SEMISEMI ]]83;end end end 
       if ___conditional___ = 52 then do
          return --[[ LESS ]]51;end end end 
       if ___conditional___ = 53 then do
          return --[[ LESSMINUS ]]52;end end end 
       if ___conditional___ = 54 then do
          return --[[ EQUAL ]]26;end end end 
       if ___conditional___ = 55 then do
          return --[[ LBRACKET ]]45;end end end 
       if ___conditional___ = 56 then do
          return --[[ LBRACKETBAR ]]46;end end end 
       if ___conditional___ = 57 then do
          return --[[ LBRACKETLESS ]]47;end end end 
       if ___conditional___ = 58 then do
          return --[[ LBRACKETGREATER ]]48;end end end 
       if ___conditional___ = 59 then do
          return --[[ RBRACKET ]]79;end end end 
       if ___conditional___ = 60 then do
          return --[[ LBRACE ]]43;end end end 
       if ___conditional___ = 61 then do
          return --[[ LBRACELESS ]]44;end end end 
       if ___conditional___ = 62 then do
          return --[[ BAR ]]7;end end end 
       if ___conditional___ = 63 then do
          return --[[ BARBAR ]]8;end end end 
       if ___conditional___ = 64 then do
          return --[[ BARRBRACKET ]]9;end end end 
       if ___conditional___ = 65 then do
          return --[[ GREATER ]]34;end end end 
       if ___conditional___ = 66 then do
          return --[[ GREATERRBRACKET ]]36;end end end 
       if ___conditional___ = 67 then do
          return --[[ RBRACE ]]78;end end end 
       if ___conditional___ = 68 then do
          return --[[ GREATERRBRACE ]]35;end end end 
       if ___conditional___ = 69 then do
          return --[[ LBRACKETAT ]]55;end end end 
       if ___conditional___ = 70 then do
          return --[[ LBRACKETPERCENT ]]49;end end end 
       if ___conditional___ = 71 then do
          return --[[ LBRACKETPERCENTPERCENT ]]50;end end end 
       if ___conditional___ = 72 then do
          return --[[ LBRACKETATAT ]]56;end end end 
       if ___conditional___ = 73 then do
          return --[[ LBRACKETATATAT ]]57;end end end 
       if ___conditional___ = 74 then do
          return --[[ BANG ]]6;end end end 
       if ___conditional___ = 75 then do
          return --[[ INFIXOP0 ]]Block.__(2, {"!="});end end end 
       if ___conditional___ = 76 then do
          return --[[ PLUS ]]72;end end end 
       if ___conditional___ = 77 then do
          return --[[ PLUSDOT ]]73;end end end 
       if ___conditional___ = 78 then do
          return --[[ PLUSEQ ]]74;end end end 
       if ___conditional___ = 79 then do
          return --[[ MINUS ]]60;end end end 
       if ___conditional___ = 80 then do
          return --[[ MINUSDOT ]]61;end end end 
       if ___conditional___ = 81
       or ___conditional___ = 82 then do
          return --[[ PREFIXOP ]]Block.__(14, {Lexing.lexeme(lexbuf$1)});end end end 
       if ___conditional___ = 83 then do
          return --[[ INFIXOP0 ]]Block.__(2, {Lexing.lexeme(lexbuf$1)});end end end 
       if ___conditional___ = 84 then do
          return --[[ INFIXOP1 ]]Block.__(3, {Lexing.lexeme(lexbuf$1)});end end end 
       if ___conditional___ = 85 then do
          return --[[ INFIXOP2 ]]Block.__(4, {Lexing.lexeme(lexbuf$1)});end end end 
       if ___conditional___ = 86 then do
          return --[[ INFIXOP4 ]]Block.__(6, {Lexing.lexeme(lexbuf$1)});end end end 
       if ___conditional___ = 87 then do
          return --[[ PERCENT ]]71;end end end 
       if ___conditional___ = 88 then do
          return --[[ INFIXOP3 ]]Block.__(5, {Lexing.lexeme(lexbuf$1)});end end end 
       if ___conditional___ = 89 then do
          return --[[ SHARPOP ]]Block.__(15, {Lexing.lexeme(lexbuf$1)});end end end 
       if ___conditional___ = 90 then do
          if (if_then_else.contents ~= --[[ Dir_out ]]2) then do
            if (if_then_else.contents == --[[ Dir_if_true ]]0) then do
              throw {
                    __Error$4,
                    --[[ Unterminated_if ]]2,
                    curr(lexbuf$1)
                  };
            end
             end 
            throw {
                  __Error$4,
                  --[[ Unterminated_else ]]3,
                  curr(lexbuf$1)
                };
          end else do
            return --[[ EOF ]]25;
          end end end end end 
       if ___conditional___ = 91 then do
          throw {
                __Error$4,
                --[[ Illegal_character ]]Block.__(0, {Lexing.lexeme_char(lexbuf$1, 0)}),
                curr(lexbuf$1)
              };end end end 
       do
      else do
        Curry._1(lexbuf$1.refill_buff, lexbuf$1);
        ___ocaml_lex_state = __ocaml_lex_state$1;
        continue ;
        end end
        
    end
  end;
end end

function __ocaml_lex_quoted_string_rec(delim, lexbuf, ___ocaml_lex_state) do
  while(true) do
    __ocaml_lex_state = ___ocaml_lex_state;
    __ocaml_lex_state$1 = Lexing.engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf);
    local ___conditional___=(__ocaml_lex_state$1);
    do
       if ___conditional___ = 0 then do
          update_loc(lexbuf, undefined, 1, false, 0);
          store_string(Lexing.lexeme(lexbuf));
          ___ocaml_lex_state = 183;
          continue ;end end end 
       if ___conditional___ = 1 then do
          is_in_string.contents = false;
          throw {
                __Error$4,
                --[[ Unterminated_string ]]0,
                string_start_loc.contents
              };end end end 
       if ___conditional___ = 2 then do
          edelim = Lexing.lexeme(lexbuf);
          edelim$1 = __String.sub(edelim, 1, #edelim - 2 | 0);
          if (delim == edelim$1) then do
            return --[[ () ]]0;
          end else do
            store_string(Lexing.lexeme(lexbuf));
            ___ocaml_lex_state = 183;
            continue ;
          end end end end end 
       if ___conditional___ = 3 then do
          store_string_char(Lexing.lexeme_char(lexbuf, 0));
          ___ocaml_lex_state = 183;
          continue ;end end end 
       do
      else do
        Curry._1(lexbuf.refill_buff, lexbuf);
        ___ocaml_lex_state = __ocaml_lex_state$1;
        continue ;
        end end
        
    end
  end;
end end

function __ocaml_lex_comment_rec(lexbuf, ___ocaml_lex_state) do
  while(true) do
    __ocaml_lex_state = ___ocaml_lex_state;
    __ocaml_lex_state$1 = Lexing.engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf);
    local ___conditional___=(__ocaml_lex_state$1);
    do
       if ___conditional___ = 0 then do
          comment_start_loc.contents = --[[ :: ]]{
            curr(lexbuf),
            comment_start_loc.contents
          };
          store_string(Lexing.lexeme(lexbuf));
          ___ocaml_lex_state = 132;
          continue ;end end end 
       if ___conditional___ = 1 then do
          match = comment_start_loc.contents;
          if (match) then do
            l = match[1];
            if (l) then do
              comment_start_loc.contents = l;
              store_string(Lexing.lexeme(lexbuf));
              ___ocaml_lex_state = 132;
              continue ;
            end else do
              comment_start_loc.contents = --[[ [] ]]0;
              return curr(lexbuf);
            end end 
          end else do
            throw {
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "lexer.mll",
                    989,
                    16
                  }
                };
          end end end end end 
       if ___conditional___ = 2 then do
          string_start_loc.contents = curr(lexbuf);
          store_string_char(--[[ "\"" ]]34);
          is_in_string.contents = true;
          try do
            string(lexbuf);
          end
          catch (raw_exn)do
            exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn[0] == __Error$4) then do
              match$1 = exn[1];
              if (typeof match$1 == "number") then do
                if (match$1 ~= 0) then do
                  throw exn;
                end
                 end 
                match$2 = comment_start_loc.contents;
                if (match$2) then do
                  start = List.hd(List.rev(comment_start_loc.contents));
                  comment_start_loc.contents = --[[ [] ]]0;
                  throw {
                        __Error$4,
                        --[[ Unterminated_string_in_comment ]]Block.__(3, {
                            start,
                            exn[2]
                          }),
                        match$2[0]
                      };
                end else do
                  throw {
                        Caml_builtin_exceptions.assert_failure,
                        --[[ tuple ]]{
                          "lexer.mll",
                          1003,
                          18
                        }
                      };
                end end 
              end else do
                throw exn;
              end end 
            end else do
              throw exn;
            end end 
          end
          is_in_string.contents = false;
          store_string_char(--[[ "\"" ]]34);
          ___ocaml_lex_state = 132;
          continue ;end end end 
       if ___conditional___ = 3 then do
          delim = Lexing.lexeme(lexbuf);
          delim$1 = __String.sub(delim, 1, #delim - 2 | 0);
          string_start_loc.contents = curr(lexbuf);
          store_string(Lexing.lexeme(lexbuf));
          is_in_string.contents = true;
          try do
            __ocaml_lex_quoted_string_rec(delim$1, lexbuf, 183);
          end
          catch (raw_exn$1)do
            exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
            if (exn$1[0] == __Error$4) then do
              match$3 = exn$1[1];
              if (typeof match$3 == "number") then do
                if (match$3 ~= 0) then do
                  throw exn$1;
                end
                 end 
                match$4 = comment_start_loc.contents;
                if (match$4) then do
                  start$1 = List.hd(List.rev(comment_start_loc.contents));
                  comment_start_loc.contents = --[[ [] ]]0;
                  throw {
                        __Error$4,
                        --[[ Unterminated_string_in_comment ]]Block.__(3, {
                            start$1,
                            exn$1[2]
                          }),
                        match$4[0]
                      };
                end else do
                  throw {
                        Caml_builtin_exceptions.assert_failure,
                        --[[ tuple ]]{
                          "lexer.mll",
                          1023,
                          18
                        }
                      };
                end end 
              end else do
                throw exn$1;
              end end 
            end else do
              throw exn$1;
            end end 
          end
          is_in_string.contents = false;
          store_string_char(--[[ "|" ]]124);
          store_string(delim$1);
          store_string_char(--[[ "}" ]]125);
          ___ocaml_lex_state = 132;
          continue ;end end end 
       if ___conditional___ = 5 then do
          update_loc(lexbuf, undefined, 1, false, 1);
          store_string(Lexing.lexeme(lexbuf));
          ___ocaml_lex_state = 132;
          continue ;end end end 
       if ___conditional___ = 10 then do
          match$5 = comment_start_loc.contents;
          if (match$5) then do
            start$2 = List.hd(List.rev(comment_start_loc.contents));
            comment_start_loc.contents = --[[ [] ]]0;
            throw {
                  __Error$4,
                  --[[ Unterminated_comment ]]Block.__(2, {start$2}),
                  match$5[0]
                };
          end else do
            throw {
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "lexer.mll",
                    1053,
                    16
                  }
                };
          end end end end end 
       if ___conditional___ = 11 then do
          update_loc(lexbuf, undefined, 1, false, 0);
          store_string(Lexing.lexeme(lexbuf));
          ___ocaml_lex_state = 132;
          continue ;end end end 
       if ___conditional___ = 4
       or ___conditional___ = 6
       or ___conditional___ = 7
       or ___conditional___ = 8
       or ___conditional___ = 9
       or ___conditional___ = 12 then do
          store_string(Lexing.lexeme(lexbuf));
          ___ocaml_lex_state = 132;
          continue ;end end end 
       do
      else do
        Curry._1(lexbuf.refill_buff, lexbuf);
        ___ocaml_lex_state = __ocaml_lex_state$1;
        continue ;
        end end
        
    end
  end;
end end

function string(lexbuf) do
  lexbuf.lex_mem = Caml_array.caml_make_vect(2, -1);
  lexbuf$1 = lexbuf;
  ___ocaml_lex_state = 164;
  while(true) do
    __ocaml_lex_state = ___ocaml_lex_state;
    __ocaml_lex_state$1 = Lexing.new_engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf$1);
    local ___conditional___=(__ocaml_lex_state$1);
    do
       if ___conditional___ = 0 then do
          return --[[ () ]]0;end end end 
       if ___conditional___ = 1 then do
          space = Lexing.sub_lexeme(lexbuf$1, Caml_array.caml_array_get(lexbuf$1.lex_mem, 0), lexbuf$1.lex_curr_pos);
          update_loc(lexbuf$1, undefined, 1, false, #space);
          return string(lexbuf$1);end end end 
       if ___conditional___ = 2 then do
          store_string_char(char_for_backslash(Lexing.lexeme_char(lexbuf$1, 1)));
          return string(lexbuf$1);end end end 
       if ___conditional___ = 3 then do
          store_string_char(char_for_decimal_code(lexbuf$1, 1));
          return string(lexbuf$1);end end end 
       if ___conditional___ = 4 then do
          store_string_char(char_for_hexadecimal_code(lexbuf$1, 2));
          return string(lexbuf$1);end end end 
       if ___conditional___ = 5 then do
          if (comment_start_loc.contents ~= --[[ [] ]]0) then do
            return string(lexbuf$1);
          end else do
            loc = curr(lexbuf$1);
            prerr_warning(loc, --[[ Illegal_backslash ]]7);
            store_string_char(Lexing.lexeme_char(lexbuf$1, 0));
            store_string_char(Lexing.lexeme_char(lexbuf$1, 1));
            return string(lexbuf$1);
          end end end end end 
       if ___conditional___ = 6 then do
          if (comment_start_loc.contents == --[[ [] ]]0) then do
            prerr_warning(curr(lexbuf$1), --[[ Eol_in_string ]]14);
          end
           end 
          update_loc(lexbuf$1, undefined, 1, false, 0);
          store_string(Lexing.lexeme(lexbuf$1));
          return string(lexbuf$1);end end end 
       if ___conditional___ = 7 then do
          is_in_string.contents = false;
          throw {
                __Error$4,
                --[[ Unterminated_string ]]0,
                string_start_loc.contents
              };end end end 
       if ___conditional___ = 8 then do
          store_string_char(Lexing.lexeme_char(lexbuf$1, 0));
          return string(lexbuf$1);end end end 
       do
      else do
        Curry._1(lexbuf$1.refill_buff, lexbuf$1);
        ___ocaml_lex_state = __ocaml_lex_state$1;
        continue ;
        end end
        
    end
  end;
end end

function comment(lexbuf) do
  return __ocaml_lex_comment_rec(lexbuf, 132);
end end

function at_bol(lexbuf) do
  pos = lexbuf.lex_start_p;
  return pos.pos_cnum == pos.pos_bol;
end end

function token_with_comments(lexbuf) do
  match = preprocessor.contents;
  if (match ~= undefined) then do
    return Curry._2(match[1], token, lexbuf);
  end else do
    return token(lexbuf);
  end end 
end end

function token$1(lexbuf) do
  post_pos = lexbuf.lex_curr_p;
  attach = function (lines, docs, pre_pos) do
    if (typeof docs == "number") then do
      return --[[ () ]]0;
    end else if (docs.tag) then do
      b = docs[2];
      f = docs[1];
      a = docs[0];
      if (lines >= 2) then do
        set_post_docstrings(post_pos, List.rev(a));
        set_post_extra_docstrings(post_pos, List.rev_append(f, List.rev(b)));
        set_floating_docstrings(pre_pos, List.rev_append(f, List.rev(b)));
        return set_pre_extra_docstrings(pre_pos, List.rev(a));
      end else do
        set_post_docstrings(post_pos, List.rev(a));
        set_post_extra_docstrings(post_pos, List.rev_append(f, List.rev(b)));
        set_floating_docstrings(pre_pos, List.rev(f));
        set_pre_extra_docstrings(pre_pos, List.rev(a));
        return set_pre_docstrings(pre_pos, b);
      end end 
    end else do
      a$1 = docs[0];
      if (lines >= 2) then do
        set_post_docstrings(post_pos, List.rev(a$1));
        return set_pre_extra_docstrings(pre_pos, List.rev(a$1));
      end else do
        set_post_docstrings(post_pos, List.rev(a$1));
        return set_pre_docstrings(pre_pos, a$1);
      end end 
    end end  end 
  end end;
  loop = function (_lines, _docs, lexbuf) do
    while(true) do
      docs = _docs;
      lines = _lines;
      tok = token_with_comments(lexbuf);
      if (typeof tok == "number") then do
        local ___conditional___=(tok);
        do
           if ___conditional___ = 84--[[ SHARP ]] then do
              if (at_bol(lexbuf)) then do
                lexbuf$1 = lexbuf;
                cont = (function(lines,docs)do
                return function cont(lexbuf) do
                  return loop(lines, docs, lexbuf);
                end end
                end(lines,docs));
                look_ahead = function (token) do
                  sharp_look_ahead.contents = token;
                  return --[[ SHARP ]]84;
                end end;
                if_then_else$1 = if_then_else.contents;
                match = token_with_comments(lexbuf$1);
                if (typeof match == "number") then do
                  local ___conditional___=(match);
                  do
                     if ___conditional___ = 23--[[ ELSE ]] then do
                        if (if_then_else$1 ~= 0) then do
                          throw {
                                __Error$4,
                                --[[ Unexpected_directive ]]6,
                                curr(lexbuf$1)
                              };
                        end
                         end end else 
                     if ___conditional___ = 24--[[ END ]] then do
                        if (if_then_else$1 >= 2) then do
                          throw {
                                __Error$4,
                                --[[ Unexpected_directive ]]6,
                                curr(lexbuf$1)
                              };
                        end
                         end 
                        if_then_else.contents = --[[ Dir_out ]]2;
                        return Curry._1(cont, lexbuf$1);end end end 
                     if ___conditional___ = 37--[[ IF ]] then do
                        if (if_then_else$1 >= 2) then do
                          if (directive_parse(token_with_comments, lexbuf$1)) then do
                            if_then_else.contents = --[[ Dir_if_true ]]0;
                            return Curry._1(cont, lexbuf$1);
                          end else do
                            _param = --[[ () ]]0;
                            while(true) do
                              token = token_with_comments(lexbuf$1);
                              if (token == --[[ EOF ]]25) then do
                                throw {
                                      __Error$4,
                                      --[[ Unterminated_if ]]2,
                                      curr(lexbuf$1)
                                    };
                              end
                               end 
                              if (token == --[[ SHARP ]]84 and at_bol(lexbuf$1)) then do
                                token$1 = token_with_comments(lexbuf$1);
                                if (typeof token$1 == "number") then do
                                  switcher = token$1 - 23 | 0;
                                  if (switcher == 0 or switcher == 1) then do
                                    if (switcher ~= 0) then do
                                      if_then_else.contents = --[[ Dir_out ]]2;
                                      return Curry._1(cont, lexbuf$1);
                                    end else do
                                      if_then_else.contents = --[[ Dir_if_false ]]1;
                                      return Curry._1(cont, lexbuf$1);
                                    end end 
                                  end else if (switcher == 14) then do
                                    throw {
                                          __Error$4,
                                          --[[ Unexpected_directive ]]6,
                                          curr(lexbuf$1)
                                        };
                                  end
                                   end  end 
                                end
                                 end 
                                if (is_elif(token$1) and directive_parse(token_with_comments, lexbuf$1)) then do
                                  if_then_else.contents = --[[ Dir_if_true ]]0;
                                  return Curry._1(cont, lexbuf$1);
                                end else do
                                  _param = --[[ () ]]0;
                                  continue ;
                                end end 
                              end else do
                                _param = --[[ () ]]0;
                                continue ;
                              end end 
                            end;
                          end end 
                        end else do
                          throw {
                                __Error$4,
                                --[[ Unexpected_directive ]]6,
                                curr(lexbuf$1)
                              };
                        end end end end end 
                     do
                    else do
                      return Curry._1(look_ahead, match);
                      end end
                      
                  end
                end else if (match.tag == --[[ LIDENT ]]11 and match[0] == "elif") then do
                  if (if_then_else$1 ~= 0) then do
                    throw {
                          __Error$4,
                          --[[ Unexpected_directive ]]6,
                          curr(lexbuf$1)
                        };
                  end
                   end 
                end else do
                  return Curry._1(look_ahead, match);
                end end  end 
                if (if_then_else$1 ~= 0) then do
                  return Curry._1(look_ahead, match);
                end else do
                  _else_seen = match == --[[ ELSE ]]23;
                  while(true) do
                    else_seen = _else_seen;
                    token$2 = token_with_comments(lexbuf$1);
                    if (token$2 == --[[ EOF ]]25) then do
                      throw {
                            __Error$4,
                            --[[ Unterminated_else ]]3,
                            curr(lexbuf$1)
                          };
                    end
                     end 
                    if (token$2 == --[[ SHARP ]]84 and at_bol(lexbuf$1)) then do
                      token$3 = token_with_comments(lexbuf$1);
                      if (typeof token$3 == "number") then do
                        switcher$1 = token$3 - 23 | 0;
                        if (switcher$1 == 0 or switcher$1 == 1) then do
                          if (switcher$1 ~= 0) then do
                            if_then_else.contents = --[[ Dir_out ]]2;
                            return Curry._1(cont, lexbuf$1);
                          end else do
                            if (else_seen) then do
                              throw {
                                    __Error$4,
                                    --[[ Unexpected_directive ]]6,
                                    curr(lexbuf$1)
                                  };
                            end
                             end 
                            _else_seen = true;
                            continue ;
                          end end 
                        end else if (switcher$1 == 14) then do
                          throw {
                                __Error$4,
                                --[[ Unexpected_directive ]]6,
                                curr(lexbuf$1)
                              };
                        end
                         end  end 
                      end
                       end 
                      if (else_seen and is_elif(token$3)) then do
                        throw {
                              __Error$4,
                              --[[ Unexpected_directive ]]6,
                              curr(lexbuf$1)
                            };
                      end
                       end 
                      continue ;
                    end else do
                      continue ;
                    end end 
                  end;
                end end 
              end
               end end else 
           if ___conditional___ = 100--[[ EOL ]] then do
              lines$prime = lines ~= 0 and --[[ BlankLine ]]2 or --[[ NewLine ]]1;
              _lines = lines$prime;
              continue ;end end end 
           do end
          else do
            end end
            
        end
      end else do
        local ___conditional___=(tok.tag | 0);
        do
           if ___conditional___ = 18--[[ COMMENT ]] then do
              match$1 = tok[0];
              add_comment(--[[ tuple ]]{
                    match$1[0],
                    match$1[1]
                  });
              lines$prime$1 = lines >= 2 and --[[ BlankLine ]]2 or --[[ NoLine ]]0;
              _lines = lines$prime$1;
              continue ;end end end 
           if ___conditional___ = 19--[[ DOCSTRING ]] then do
              doc = tok[0];
              add_docstring_comment(doc);
              docs$prime;
              if (typeof docs == "number") then do
                docs$prime = lines >= 2 and --[[ Before ]]Block.__(1, {
                      --[[ [] ]]0,
                      --[[ [] ]]0,
                      --[[ :: ]]{
                        doc,
                        --[[ [] ]]0
                      }
                    }) or --[[ After ]]Block.__(0, {--[[ :: ]]{
                        doc,
                        --[[ [] ]]0
                      }});
              end else if (docs.tag) then do
                b = docs[2];
                f = docs[1];
                a = docs[0];
                docs$prime = lines >= 2 and --[[ Before ]]Block.__(1, {
                      a,
                      Pervasives.$at(b, f),
                      --[[ :: ]]{
                        doc,
                        --[[ [] ]]0
                      }
                    }) or --[[ Before ]]Block.__(1, {
                      a,
                      f,
                      --[[ :: ]]{
                        doc,
                        b
                      }
                    });
              end else do
                a$1 = docs[0];
                docs$prime = lines >= 2 and --[[ Before ]]Block.__(1, {
                      a$1,
                      --[[ [] ]]0,
                      --[[ :: ]]{
                        doc,
                        --[[ [] ]]0
                      }
                    }) or --[[ After ]]Block.__(0, {--[[ :: ]]{
                        doc,
                        a$1
                      }});
              end end  end 
              _docs = docs$prime;
              _lines = --[[ NoLine ]]0;
              continue ;end end end 
           do
          else do
            end end
            
        end
      end end 
      attach(lines, docs, lexbuf.lex_start_p);
      return tok;
    end;
  end end;
  match = sharp_look_ahead.contents;
  if (match ~= undefined) then do
    sharp_look_ahead.contents = undefined;
    return match;
  end else do
    return loop(--[[ NoLine ]]0, --[[ Initial ]]0, lexbuf);
  end end 
end end

function init$1(param) do
  sharp_look_ahead.contents = undefined;
  if_then_else.contents = --[[ Dir_out ]]2;
  is_in_string.contents = false;
  comment_start_loc.contents = --[[ [] ]]0;
  comment_list.contents = --[[ [] ]]0;
  match = preprocessor.contents;
  if (match ~= undefined) then do
    return Curry._1(match[0], --[[ () ]]0);
  end else do
    return --[[ () ]]0;
  end end 
end end

function skip_phrase(lexbuf) do
  while(true) do
    try do
      match = token$1(lexbuf);
      if (typeof match == "number" and not (match ~= 25 and match ~= 83)) then do
        return --[[ () ]]0;
      end else do
        return skip_phrase(lexbuf);
      end end 
    end
    catch (raw_exn)do
      exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] == __Error$4) then do
        tmp = exn[1];
        if (typeof tmp == "number") then do
          if (tmp == --[[ Unterminated_string ]]0) then do
            continue ;
          end else do
            throw exn;
          end end 
        end else do
          local ___conditional___=(tmp.tag | 0);
          do
             if ___conditional___ = 0--[[ Illegal_character ]]
             or ___conditional___ = 2--[[ Unterminated_comment ]]
             or ___conditional___ = 3--[[ Unterminated_string_in_comment ]] then do
                continue ;end end end 
             do
            else do
              throw exn;
              end end
              
          end
        end end 
      end else do
        throw exn;
      end end 
    end
  end;
end end

function maybe_skip_phrase(lexbuf) do
  if (Parsing.is_current_lookahead(--[[ SEMISEMI ]]83) or Parsing.is_current_lookahead(--[[ EOF ]]25)) then do
    return --[[ () ]]0;
  end else do
    return skip_phrase(lexbuf);
  end end 
end end

function wrap$1(parsing_fun, lexbuf) do
  try do
    init(--[[ () ]]0);
    init$1(--[[ () ]]0);
    ast = Curry._2(parsing_fun, token$1, lexbuf);
    Parsing.clear_parser(--[[ () ]]0);
    warn_bad_docstrings(--[[ () ]]0);
    return ast;
  end
  catch (raw_err)do
    err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err[0] == __Error$4) then do
      tmp = err[1];
      if (typeof tmp == "number") then do
        throw err;
      end else if (tmp.tag) then do
        throw err;
      end else if (input_name.contents == "//toplevel//") then do
        skip_phrase(lexbuf);
        throw err;
      end else do
        throw err;
      end end  end  end 
    end else if (err[0] == __Error$3) then do
      if (input_name.contents == "//toplevel//") then do
        maybe_skip_phrase(lexbuf);
        throw err;
      end else do
        throw err;
      end end 
    end else if (err ~= Parsing.Parse_error and err ~= Escape_error) then do
      throw err;
    end
     end  end  end 
    loc = curr(lexbuf);
    if (input_name.contents == "//toplevel//") then do
      maybe_skip_phrase(lexbuf);
    end
     end 
    throw {
          __Error$3,
          --[[ Other ]]Block.__(5, {loc})
        };
  end
end end

function iter_pattern_desc(f, param) do
  if (typeof param == "number") then do
    return --[[ () ]]0;
  end else do
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ = 4--[[ Tpat_construct ]] then do
          return List.iter(f, param[2]);end end end 
       if ___conditional___ = 5--[[ Tpat_variant ]] then do
          return may(f, param[1]);end end end 
       if ___conditional___ = 6--[[ Tpat_record ]] then do
          return List.iter((function (param) do
                        return Curry._1(f, param[2]);
                      end end), param[0]);end end end 
       if ___conditional___ = 3--[[ Tpat_tuple ]]
       or ___conditional___ = 7--[[ Tpat_array ]] then do
          return List.iter(f, param[0]);end end end 
       if ___conditional___ = 8--[[ Tpat_or ]] then do
          Curry._1(f, param[0]);
          return Curry._1(f, param[1]);end end end 
       if ___conditional___ = 1--[[ Tpat_alias ]]
       or ___conditional___ = 9--[[ Tpat_lazy ]] then do
          return Curry._1(f, param[0]);end end end 
       do
      else do
        return --[[ () ]]0;
        end end
        
    end
  end end 
end end

function map_pattern_desc(f, d) do
  if (typeof d == "number") then do
    return d;
  end else do
    local ___conditional___=(d.tag | 0);
    do
       if ___conditional___ = 1--[[ Tpat_alias ]] then do
          return --[[ Tpat_alias ]]Block.__(1, {
                    Curry._1(f, d[0]),
                    d[1],
                    d[2]
                  });end end end 
       if ___conditional___ = 3--[[ Tpat_tuple ]] then do
          return --[[ Tpat_tuple ]]Block.__(3, {List.map(f, d[0])});end end end 
       if ___conditional___ = 4--[[ Tpat_construct ]] then do
          return --[[ Tpat_construct ]]Block.__(4, {
                    d[0],
                    d[1],
                    List.map(f, d[2])
                  });end end end 
       if ___conditional___ = 5--[[ Tpat_variant ]] then do
          match = d[1];
          if (match ~= undefined) then do
            return --[[ Tpat_variant ]]Block.__(5, {
                      d[0],
                      Curry._1(f, match),
                      d[2]
                    });
          end else do
            return d;
          end end end end end 
       if ___conditional___ = 6--[[ Tpat_record ]] then do
          return --[[ Tpat_record ]]Block.__(6, {
                    List.map((function (param) do
                            return --[[ tuple ]]{
                                    param[0],
                                    param[1],
                                    Curry._1(f, param[2])
                                  };
                          end end), d[0]),
                    d[1]
                  });end end end 
       if ___conditional___ = 7--[[ Tpat_array ]] then do
          return --[[ Tpat_array ]]Block.__(7, {List.map(f, d[0])});end end end 
       if ___conditional___ = 8--[[ Tpat_or ]] then do
          return --[[ Tpat_or ]]Block.__(8, {
                    Curry._1(f, d[0]),
                    Curry._1(f, d[1]),
                    d[2]
                  });end end end 
       if ___conditional___ = 9--[[ Tpat_lazy ]] then do
          return --[[ Tpat_lazy ]]Block.__(9, {Curry._1(f, d[0])});end end end 
       do
      else do
        return d;
        end end
        
    end
  end end 
end end

idents = do
  contents: --[[ [] ]]0
end;

function bound_idents(_pat) do
  while(true) do
    pat = _pat;
    d = pat.pat_desc;
    if (typeof d == "number") then do
      return iter_pattern_desc(bound_idents, d);
    end else do
      local ___conditional___=(d.tag | 0);
      do
         if ___conditional___ = 0--[[ Tpat_var ]] then do
            idents.contents = --[[ :: ]]{
              --[[ tuple ]]{
                d[0],
                d[1]
              },
              idents.contents
            };
            return --[[ () ]]0;end end end 
         if ___conditional___ = 1--[[ Tpat_alias ]] then do
            bound_idents(d[0]);
            idents.contents = --[[ :: ]]{
              --[[ tuple ]]{
                d[1],
                d[2]
              },
              idents.contents
            };
            return --[[ () ]]0;end end end 
         if ___conditional___ = 8--[[ Tpat_or ]] then do
            _pat = d[0];
            continue ;end end end 
         do
        else do
          return iter_pattern_desc(bound_idents, d);
          end end
          
      end
    end end 
  end;
end end

function pat_bound_idents(pat) do
  idents.contents = --[[ [] ]]0;
  bound_idents(pat);
  res = idents.contents;
  idents.contents = --[[ [] ]]0;
  return res;
end end

function rev_let_bound_idents_with_loc(bindings) do
  idents.contents = --[[ [] ]]0;
  List.iter((function (vb) do
          return bound_idents(vb.vb_pat);
        end end), bindings);
  res = idents.contents;
  idents.contents = --[[ [] ]]0;
  return res;
end end

function let_bound_idents(pat) do
  return List.map((function (prim) do
                return prim[0];
              end end), List.rev(rev_let_bound_idents_with_loc(pat)));
end end

function alpha_pat(env, p) do
  d = p.pat_desc;
  if (typeof d ~= "number") then do
    local ___conditional___=(d.tag | 0);
    do
       if ___conditional___ = 0--[[ Tpat_var ]] then do
          tmp;
          try do
            tmp = --[[ Tpat_var ]]Block.__(0, {
                List.assoc(d[0], env),
                d[1]
              });
          end
          catch (exn)do
            if (exn == Caml_builtin_exceptions.not_found) then do
              tmp = --[[ Tpat_any ]]0;
            end else do
              throw exn;
            end end 
          end
          return do
                  pat_desc: tmp,
                  pat_loc: p.pat_loc,
                  pat_extra: p.pat_extra,
                  pat_type: p.pat_type,
                  pat_env: p.pat_env,
                  pat_attributes: p.pat_attributes
                end;end end end 
       if ___conditional___ = 1--[[ Tpat_alias ]] then do
          new_p = alpha_pat(env, d[0]);
          try do
            return do
                    pat_desc: --[[ Tpat_alias ]]Block.__(1, {
                        new_p,
                        List.assoc(d[1], env),
                        d[2]
                      }),
                    pat_loc: p.pat_loc,
                    pat_extra: p.pat_extra,
                    pat_type: p.pat_type,
                    pat_env: p.pat_env,
                    pat_attributes: p.pat_attributes
                  end;
          end
          catch (exn$1)do
            if (exn$1 == Caml_builtin_exceptions.not_found) then do
              return new_p;
            end else do
              throw exn$1;
            end end 
          endend end end 
       do
      else do
        end end
        
    end
  end
   end 
  return do
          pat_desc: map_pattern_desc((function (param) do
                  return alpha_pat(env, param);
                end end), d),
          pat_loc: p.pat_loc,
          pat_extra: p.pat_extra,
          pat_type: p.pat_type,
          pat_env: p.pat_env,
          pat_attributes: p.pat_attributes
        end;
end end

function enter_structure(t) do
  return t;
end end

function enter_value_description(t) do
  return t;
end end

function enter_type_declaration(t) do
  return t;
end end

function enter_type_extension(t) do
  return t;
end end

function enter_extension_constructor(t) do
  return t;
end end

function enter_pattern(t) do
  return t;
end end

function enter_expression(t) do
  return t;
end end

function enter_package_type(t) do
  return t;
end end

function enter_signature(t) do
  return t;
end end

function enter_signature_item(t) do
  return t;
end end

function enter_module_type_declaration(t) do
  return t;
end end

function enter_module_type(t) do
  return t;
end end

function enter_module_expr(t) do
  return t;
end end

function enter_with_constraint(t) do
  return t;
end end

function enter_class_expr(t) do
  return t;
end end

function enter_class_signature(t) do
  return t;
end end

function enter_class_declaration(t) do
  return t;
end end

function enter_class_description(t) do
  return t;
end end

function enter_class_type_declaration(t) do
  return t;
end end

function enter_class_type(t) do
  return t;
end end

function enter_class_type_field(t) do
  return t;
end end

function enter_core_type(t) do
  return t;
end end

function enter_class_structure(t) do
  return t;
end end

function enter_class_field(t) do
  return t;
end end

function enter_structure_item(t) do
  return t;
end end

function leave_value_description(t) do
  return t;
end end

function leave_type_declaration(t) do
  return t;
end end

function leave_type_extension(t) do
  return t;
end end

function leave_extension_constructor(t) do
  return t;
end end

function leave_package_type(t) do
  return t;
end end

function leave_module_type_declaration(t) do
  return t;
end end

function leave_with_constraint(t) do
  return t;
end end

function leave_class_signature(t) do
  return t;
end end

function leave_class_declaration(t) do
  return t;
end end

function leave_class_description(t) do
  return t;
end end

function leave_class_type_declaration(t) do
  return t;
end end

function leave_class_type_field(t) do
  return t;
end end

function leave_class_structure(t) do
  return t;
end end

function leave_class_field(t) do
  return t;
end end

function TypedtreeMap_MakeMap(funarg) do
  map_structure = function (str) do
    str$1 = Curry._1(funarg.enter_structure, str);
    str_items = List.map(map_structure_item, str$1.str_items);
    return Curry._1(funarg.leave_structure, do
                str_items: str_items,
                str_type: str$1.str_type,
                str_final_env: str$1.str_final_env
              end);
  end end;
  map_class_type = function (ct) do
    ct$1 = Curry._1(funarg.enter_class_type, ct);
    match = ct$1.cltyp_desc;
    cltyp_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 0--[[ Tcty_constr ]] then do
          cltyp_desc = --[[ Tcty_constr ]]Block.__(0, {
              match[0],
              match[1],
              List.map(map_core_type, match[2])
            });end else 
       if ___conditional___ = 1--[[ Tcty_signature ]] then do
          cltyp_desc = --[[ Tcty_signature ]]Block.__(1, {map_class_signature(match[0])});end else 
       if ___conditional___ = 2--[[ Tcty_arrow ]] then do
          cltyp_desc = --[[ Tcty_arrow ]]Block.__(2, {
              match[0],
              map_core_type(match[1]),
              map_class_type(match[2])
            });end else 
       do end end end end
      
    end
    return Curry._1(funarg.leave_class_type, do
                cltyp_desc: cltyp_desc,
                cltyp_type: ct$1.cltyp_type,
                cltyp_env: ct$1.cltyp_env,
                cltyp_loc: ct$1.cltyp_loc,
                cltyp_attributes: ct$1.cltyp_attributes
              end);
  end end;
  map_core_type = function (ct) do
    ct$1 = Curry._1(funarg.enter_core_type, ct);
    match = ct$1.ctyp_desc;
    ctyp_desc;
    if (typeof match == "number") then do
      ctyp_desc = ct$1.ctyp_desc;
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 0--[[ Ttyp_var ]] then do
            ctyp_desc = ct$1.ctyp_desc;end else 
         if ___conditional___ = 1--[[ Ttyp_arrow ]] then do
            ctyp_desc = --[[ Ttyp_arrow ]]Block.__(1, {
                match[0],
                map_core_type(match[1]),
                map_core_type(match[2])
              });end else 
         if ___conditional___ = 2--[[ Ttyp_tuple ]] then do
            ctyp_desc = --[[ Ttyp_tuple ]]Block.__(2, {List.map(map_core_type, match[0])});end else 
         if ___conditional___ = 3--[[ Ttyp_constr ]] then do
            ctyp_desc = --[[ Ttyp_constr ]]Block.__(3, {
                match[0],
                match[1],
                List.map(map_core_type, match[2])
              });end else 
         if ___conditional___ = 4--[[ Ttyp_object ]] then do
            ctyp_desc = --[[ Ttyp_object ]]Block.__(4, {
                List.map((function (param) do
                        return --[[ tuple ]]{
                                param[0],
                                param[1],
                                map_core_type(param[2])
                              };
                      end end), match[0]),
                match[1]
              });end else 
         if ___conditional___ = 5--[[ Ttyp_class ]] then do
            ctyp_desc = --[[ Ttyp_class ]]Block.__(5, {
                match[0],
                match[1],
                List.map(map_core_type, match[2])
              });end else 
         if ___conditional___ = 6--[[ Ttyp_alias ]] then do
            ctyp_desc = --[[ Ttyp_alias ]]Block.__(6, {
                map_core_type(match[0]),
                match[1]
              });end else 
         if ___conditional___ = 7--[[ Ttyp_variant ]] then do
            ctyp_desc = --[[ Ttyp_variant ]]Block.__(7, {
                List.map(map_row_field, match[0]),
                match[1],
                match[2]
              });end else 
         if ___conditional___ = 8--[[ Ttyp_poly ]] then do
            ctyp_desc = --[[ Ttyp_poly ]]Block.__(8, {
                match[0],
                map_core_type(match[1])
              });end else 
         if ___conditional___ = 9--[[ Ttyp_package ]] then do
            ctyp_desc = --[[ Ttyp_package ]]Block.__(9, {map_package_type(match[0])});end else 
         do end end end end end end end end end end end
        
      end
    end end 
    return Curry._1(funarg.leave_core_type, do
                ctyp_desc: ctyp_desc,
                ctyp_type: ct$1.ctyp_type,
                ctyp_env: ct$1.ctyp_env,
                ctyp_loc: ct$1.ctyp_loc,
                ctyp_attributes: ct$1.ctyp_attributes
              end);
  end end;
  map_type_declaration = function (decl) do
    decl$1 = Curry._1(funarg.enter_type_declaration, decl);
    typ_params = List.map(map_type_parameter, decl$1.typ_params);
    typ_cstrs = List.map((function (param) do
            return --[[ tuple ]]{
                    map_core_type(param[0]),
                    map_core_type(param[1]),
                    param[2]
                  };
          end end), decl$1.typ_cstrs);
    match = decl$1.typ_kind;
    typ_kind;
    if (typeof match == "number") then do
      typ_kind = match == --[[ Ttype_abstract ]]0 and --[[ Ttype_abstract ]]0 or --[[ Ttype_open ]]1;
    end else if (match.tag) then do
      list = List.map((function (ld) do
              return do
                      ld_id: ld.ld_id,
                      ld_name: ld.ld_name,
                      ld_mutable: ld.ld_mutable,
                      ld_type: map_core_type(ld.ld_type),
                      ld_loc: ld.ld_loc,
                      ld_attributes: ld.ld_attributes
                    end;
            end end), match[0]);
      typ_kind = --[[ Ttype_record ]]Block.__(1, {list});
    end else do
      list$1 = List.map(map_constructor_declaration, match[0]);
      typ_kind = --[[ Ttype_variant ]]Block.__(0, {list$1});
    end end  end 
    typ_manifest = may_map(map_core_type, decl$1.typ_manifest);
    return Curry._1(funarg.leave_type_declaration, do
                typ_id: decl$1.typ_id,
                typ_name: decl$1.typ_name,
                typ_params: typ_params,
                typ_type: decl$1.typ_type,
                typ_cstrs: typ_cstrs,
                typ_kind: typ_kind,
                typ_private: decl$1.typ_private,
                typ_manifest: typ_manifest,
                typ_loc: decl$1.typ_loc,
                typ_attributes: decl$1.typ_attributes
              end);
  end end;
  map_module_type = function (mty) do
    mty$1 = Curry._1(funarg.enter_module_type, mty);
    match = mty$1.mty_desc;
    mty_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 1--[[ Tmty_signature ]] then do
          mty_desc = --[[ Tmty_signature ]]Block.__(1, {map_signature(match[0])});end else 
       if ___conditional___ = 2--[[ Tmty_functor ]] then do
          mty_desc = --[[ Tmty_functor ]]Block.__(2, {
              match[0],
              match[1],
              may_map(map_module_type, match[2]),
              map_module_type(match[3])
            });end else 
       if ___conditional___ = 3--[[ Tmty_with ]] then do
          mty_desc = --[[ Tmty_with ]]Block.__(3, {
              map_module_type(match[0]),
              List.map((function (param) do
                      return --[[ tuple ]]{
                              param[0],
                              param[1],
                              map_with_constraint(param[2])
                            };
                    end end), match[1])
            });end else 
       if ___conditional___ = 4--[[ Tmty_typeof ]] then do
          mty_desc = --[[ Tmty_typeof ]]Block.__(4, {map_module_expr(match[0])});end else 
       if ___conditional___ = 0--[[ Tmty_ident ]]
       or ___conditional___ = 5--[[ Tmty_alias ]] then do
          mty_desc = mty$1.mty_desc;end else 
       do end end end end end end
      
    end
    return Curry._1(funarg.leave_module_type, do
                mty_desc: mty_desc,
                mty_type: mty$1.mty_type,
                mty_env: mty$1.mty_env,
                mty_loc: mty$1.mty_loc,
                mty_attributes: mty$1.mty_attributes
              end);
  end end;
  map_module_expr = function (mexpr) do
    mexpr$1 = Curry._1(funarg.enter_module_expr, mexpr);
    match = mexpr$1.mod_desc;
    mod_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 0--[[ Tmod_ident ]] then do
          mod_desc = mexpr$1.mod_desc;end else 
       if ___conditional___ = 1--[[ Tmod_structure ]] then do
          mod_desc = --[[ Tmod_structure ]]Block.__(1, {map_structure(match[0])});end else 
       if ___conditional___ = 2--[[ Tmod_functor ]] then do
          mod_desc = --[[ Tmod_functor ]]Block.__(2, {
              match[0],
              match[1],
              may_map(map_module_type, match[2]),
              map_module_expr(match[3])
            });end else 
       if ___conditional___ = 3--[[ Tmod_apply ]] then do
          mod_desc = --[[ Tmod_apply ]]Block.__(3, {
              map_module_expr(match[0]),
              map_module_expr(match[1]),
              match[2]
            });end else 
       if ___conditional___ = 4--[[ Tmod_constraint ]] then do
          match$1 = match[2];
          mod_type = match[1];
          mexpr$2 = match[0];
          mod_desc = match$1 and --[[ Tmod_constraint ]]Block.__(4, {
                map_module_expr(mexpr$2),
                mod_type,
                --[[ Tmodtype_explicit ]]{map_module_type(match$1[0])},
                match[3]
              }) or --[[ Tmod_constraint ]]Block.__(4, {
                map_module_expr(mexpr$2),
                mod_type,
                --[[ Tmodtype_implicit ]]0,
                match[3]
              });end else 
       if ___conditional___ = 5--[[ Tmod_unpack ]] then do
          mod_desc = --[[ Tmod_unpack ]]Block.__(5, {
              map_expression(match[0]),
              match[1]
            });end else 
       do end end end end end end end
      
    end
    return Curry._1(funarg.leave_module_expr, do
                mod_desc: mod_desc,
                mod_loc: mexpr$1.mod_loc,
                mod_type: mexpr$1.mod_type,
                mod_env: mexpr$1.mod_env,
                mod_attributes: mexpr$1.mod_attributes
              end);
  end end;
  map_with_constraint = function (cstr) do
    cstr$1 = Curry._1(funarg.enter_with_constraint, cstr);
    tmp;
    local ___conditional___=(cstr$1.tag | 0);
    do
       if ___conditional___ = 0--[[ Twith_type ]] then do
          tmp = --[[ Twith_type ]]Block.__(0, {map_type_declaration(cstr$1[0])});end else 
       if ___conditional___ = 2--[[ Twith_typesubst ]] then do
          tmp = --[[ Twith_typesubst ]]Block.__(2, {map_type_declaration(cstr$1[0])});end else 
       if ___conditional___ = 1--[[ Twith_module ]]
       or ___conditional___ = 3--[[ Twith_modsubst ]] then do
          tmp = cstr$1;end else 
       do end end end end
      
    end
    return Curry._1(funarg.leave_with_constraint, tmp);
  end end;
  map_signature = function (sg) do
    sg$1 = Curry._1(funarg.enter_signature, sg);
    sig_items = List.map(map_signature_item, sg$1.sig_items);
    return Curry._1(funarg.leave_signature, do
                sig_items: sig_items,
                sig_type: sg$1.sig_type,
                sig_final_env: sg$1.sig_final_env
              end);
  end end;
  map_value_description = function (v) do
    v$1 = Curry._1(funarg.enter_value_description, v);
    val_desc = map_core_type(v$1.val_desc);
    return Curry._1(funarg.leave_value_description, do
                val_id: v$1.val_id,
                val_name: v$1.val_name,
                val_desc: val_desc,
                val_val: v$1.val_val,
                val_prim: v$1.val_prim,
                val_loc: v$1.val_loc,
                val_attributes: v$1.val_attributes
              end);
  end end;
  map_extension_constructor = function (ext) do
    ext$1 = Curry._1(funarg.enter_extension_constructor, ext);
    match = ext$1.ext_kind;
    ext_kind;
    if (match.tag) then do
      ext_kind = --[[ Text_rebind ]]Block.__(1, {
          match[0],
          match[1]
        });
    end else do
      args = List.map(map_core_type, match[0]);
      ret = may_map(map_core_type, match[1]);
      ext_kind = --[[ Text_decl ]]Block.__(0, {
          args,
          ret
        });
    end end 
    return Curry._1(funarg.leave_extension_constructor, do
                ext_id: ext$1.ext_id,
                ext_name: ext$1.ext_name,
                ext_type: ext$1.ext_type,
                ext_kind: ext_kind,
                ext_loc: ext$1.ext_loc,
                ext_attributes: ext$1.ext_attributes
              end);
  end end;
  map_type_extension = function (tyext) do
    tyext$1 = Curry._1(funarg.enter_type_extension, tyext);
    tyext_params = List.map(map_type_parameter, tyext$1.tyext_params);
    tyext_constructors = List.map(map_extension_constructor, tyext$1.tyext_constructors);
    return Curry._1(funarg.leave_type_extension, do
                tyext_path: tyext$1.tyext_path,
                tyext_txt: tyext$1.tyext_txt,
                tyext_params: tyext_params,
                tyext_constructors: tyext_constructors,
                tyext_private: tyext$1.tyext_private,
                tyext_attributes: tyext$1.tyext_attributes
              end);
  end end;
  map_class_type_declaration = function (cd) do
    cd$1 = Curry._1(funarg.enter_class_type_declaration, cd);
    ci_params = List.map(map_type_parameter, cd$1.ci_params);
    ci_expr = map_class_type(cd$1.ci_expr);
    return Curry._1(funarg.leave_class_type_declaration, do
                ci_virt: cd$1.ci_virt,
                ci_params: ci_params,
                ci_id_name: cd$1.ci_id_name,
                ci_id_class: cd$1.ci_id_class,
                ci_id_class_type: cd$1.ci_id_class_type,
                ci_id_object: cd$1.ci_id_object,
                ci_id_typesharp: cd$1.ci_id_typesharp,
                ci_expr: ci_expr,
                ci_decl: cd$1.ci_decl,
                ci_type_decl: cd$1.ci_type_decl,
                ci_loc: cd$1.ci_loc,
                ci_attributes: cd$1.ci_attributes
              end);
  end end;
  map_module_type_declaration = function (mtd) do
    mtd$1 = Curry._1(funarg.enter_module_type_declaration, mtd);
    return Curry._1(funarg.leave_module_type_declaration, do
                mtd_id: mtd$1.mtd_id,
                mtd_name: mtd$1.mtd_name,
                mtd_type: may_map(map_module_type, mtd$1.mtd_type),
                mtd_attributes: mtd$1.mtd_attributes,
                mtd_loc: mtd$1.mtd_loc
              end);
  end end;
  map_class_description = function (cd) do
    cd$1 = Curry._1(funarg.enter_class_description, cd);
    ci_params = List.map(map_type_parameter, cd$1.ci_params);
    ci_expr = map_class_type(cd$1.ci_expr);
    return Curry._1(funarg.leave_class_description, do
                ci_virt: cd$1.ci_virt,
                ci_params: ci_params,
                ci_id_name: cd$1.ci_id_name,
                ci_id_class: cd$1.ci_id_class,
                ci_id_class_type: cd$1.ci_id_class_type,
                ci_id_object: cd$1.ci_id_object,
                ci_id_typesharp: cd$1.ci_id_typesharp,
                ci_expr: ci_expr,
                ci_decl: cd$1.ci_decl,
                ci_type_decl: cd$1.ci_type_decl,
                ci_loc: cd$1.ci_loc,
                ci_attributes: cd$1.ci_attributes
              end);
  end end;
  map_type_parameter = function (param) do
    return --[[ tuple ]]{
            map_core_type(param[0]),
            param[1]
          };
  end end;
  map_class_expr = function (cexpr) do
    cexpr$1 = Curry._1(funarg.enter_class_expr, cexpr);
    match = cexpr$1.cl_desc;
    cl_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 0--[[ Tcl_ident ]] then do
          cl_desc = --[[ Tcl_ident ]]Block.__(0, {
              match[0],
              match[1],
              List.map(map_core_type, match[2])
            });end else 
       if ___conditional___ = 1--[[ Tcl_structure ]] then do
          cl_desc = --[[ Tcl_structure ]]Block.__(1, {map_class_structure(match[0])});end else 
       if ___conditional___ = 2--[[ Tcl_fun ]] then do
          cl_desc = --[[ Tcl_fun ]]Block.__(2, {
              match[0],
              map_pattern(match[1]),
              List.map((function (param) do
                      return --[[ tuple ]]{
                              param[0],
                              param[1],
                              map_expression(param[2])
                            };
                    end end), match[2]),
              map_class_expr(match[3]),
              match[4]
            });end else 
       if ___conditional___ = 3--[[ Tcl_apply ]] then do
          cl_desc = --[[ Tcl_apply ]]Block.__(3, {
              map_class_expr(match[0]),
              List.map((function (param) do
                      return --[[ tuple ]]{
                              param[0],
                              may_map(map_expression, param[1]),
                              param[2]
                            };
                    end end), match[1])
            });end else 
       if ___conditional___ = 4--[[ Tcl_let ]] then do
          cl_desc = --[[ Tcl_let ]]Block.__(4, {
              match[0],
              List.map(map_binding, match[1]),
              List.map((function (param) do
                      return --[[ tuple ]]{
                              param[0],
                              param[1],
                              map_expression(param[2])
                            };
                    end end), match[2]),
              map_class_expr(match[3])
            });end else 
       if ___conditional___ = 5--[[ Tcl_constraint ]] then do
          match$1 = match[1];
          cl = match[0];
          cl_desc = match$1 ~= undefined and --[[ Tcl_constraint ]]Block.__(5, {
                map_class_expr(cl),
                map_class_type(match$1),
                match[2],
                match[3],
                match[4]
              }) or --[[ Tcl_constraint ]]Block.__(5, {
                map_class_expr(cl),
                undefined,
                match[2],
                match[3],
                match[4]
              });end else 
       do end end end end end end end
      
    end
    return Curry._1(funarg.leave_class_expr, do
                cl_desc: cl_desc,
                cl_loc: cexpr$1.cl_loc,
                cl_type: cexpr$1.cl_type,
                cl_env: cexpr$1.cl_env,
                cl_attributes: cexpr$1.cl_attributes
              end);
  end end;
  map_pattern = function (pat) do
    pat$1 = Curry._1(funarg.enter_pattern, pat);
    match = pat$1.pat_desc;
    pat_desc;
    if (typeof match == "number") then do
      pat_desc = pat$1.pat_desc;
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 1--[[ Tpat_alias ]] then do
            pat1 = map_pattern(match[0]);
            pat_desc = --[[ Tpat_alias ]]Block.__(1, {
                pat1,
                match[1],
                match[2]
              });end else 
         if ___conditional___ = 3--[[ Tpat_tuple ]] then do
            pat_desc = --[[ Tpat_tuple ]]Block.__(3, {List.map(map_pattern, match[0])});end else 
         if ___conditional___ = 4--[[ Tpat_construct ]] then do
            pat_desc = --[[ Tpat_construct ]]Block.__(4, {
                match[0],
                match[1],
                List.map(map_pattern, match[2])
              });end else 
         if ___conditional___ = 5--[[ Tpat_variant ]] then do
            pato = match[1];
            pato$1 = pato ~= undefined and map_pattern(pato) or pato;
            pat_desc = --[[ Tpat_variant ]]Block.__(5, {
                match[0],
                pato$1,
                match[2]
              });end else 
         if ___conditional___ = 6--[[ Tpat_record ]] then do
            pat_desc = --[[ Tpat_record ]]Block.__(6, {
                List.map((function (param) do
                        return --[[ tuple ]]{
                                param[0],
                                param[1],
                                map_pattern(param[2])
                              };
                      end end), match[0]),
                match[1]
              });end else 
         if ___conditional___ = 7--[[ Tpat_array ]] then do
            pat_desc = --[[ Tpat_array ]]Block.__(7, {List.map(map_pattern, match[0])});end else 
         if ___conditional___ = 8--[[ Tpat_or ]] then do
            pat_desc = --[[ Tpat_or ]]Block.__(8, {
                map_pattern(match[0]),
                map_pattern(match[1]),
                match[2]
              });end else 
         if ___conditional___ = 9--[[ Tpat_lazy ]] then do
            pat_desc = --[[ Tpat_lazy ]]Block.__(9, {map_pattern(match[0])});end else 
         do end end end end end end end end end
        else do
          pat_desc = pat$1.pat_desc;
          end end
          
      end
    end end 
    pat_extra = List.map(map_pat_extra, pat$1.pat_extra);
    return Curry._1(funarg.leave_pattern, do
                pat_desc: pat_desc,
                pat_loc: pat$1.pat_loc,
                pat_extra: pat_extra,
                pat_type: pat$1.pat_type,
                pat_env: pat$1.pat_env,
                pat_attributes: pat$1.pat_attributes
              end);
  end end;
  map_pat_extra = function (pat_extra) do
    match = pat_extra[0];
    if (typeof match == "number" or match.tag) then do
      return pat_extra;
    end else do
      return --[[ tuple ]]{
              --[[ Tpat_constraint ]]Block.__(0, {map_core_type(match[0])}),
              pat_extra[1],
              pat_extra[2]
            };
    end end 
  end end;
  map_expression = function (exp) do
    exp$1 = Curry._1(funarg.enter_expression, exp);
    match = exp$1.exp_desc;
    exp_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 2--[[ Texp_let ]] then do
          exp_desc = --[[ Texp_let ]]Block.__(2, {
              match[0],
              List.map(map_binding, match[1]),
              map_expression(match[2])
            });end else 
       if ___conditional___ = 3--[[ Texp_function ]] then do
          exp_desc = --[[ Texp_function ]]Block.__(3, {
              match[0],
              List.map(map_case, match[1]),
              match[2]
            });end else 
       if ___conditional___ = 4--[[ Texp_apply ]] then do
          exp_desc = --[[ Texp_apply ]]Block.__(4, {
              map_expression(match[0]),
              List.map((function (param) do
                      expo = param[1];
                      expo$1 = expo ~= undefined and map_expression(expo) or expo;
                      return --[[ tuple ]]{
                              param[0],
                              expo$1,
                              param[2]
                            };
                    end end), match[1])
            });end else 
       if ___conditional___ = 5--[[ Texp_match ]] then do
          exp_desc = --[[ Texp_match ]]Block.__(5, {
              map_expression(match[0]),
              List.map(map_case, match[1]),
              List.map(map_case, match[2]),
              match[3]
            });end else 
       if ___conditional___ = 6--[[ Texp_try ]] then do
          exp_desc = --[[ Texp_try ]]Block.__(6, {
              map_expression(match[0]),
              List.map(map_case, match[1])
            });end else 
       if ___conditional___ = 7--[[ Texp_tuple ]] then do
          exp_desc = --[[ Texp_tuple ]]Block.__(7, {List.map(map_expression, match[0])});end else 
       if ___conditional___ = 8--[[ Texp_construct ]] then do
          exp_desc = --[[ Texp_construct ]]Block.__(8, {
              match[0],
              match[1],
              List.map(map_expression, match[2])
            });end else 
       if ___conditional___ = 9--[[ Texp_variant ]] then do
          expo = match[1];
          expo$1 = expo ~= undefined and map_expression(expo) or expo;
          exp_desc = --[[ Texp_variant ]]Block.__(9, {
              match[0],
              expo$1
            });end else 
       if ___conditional___ = 10--[[ Texp_record ]] then do
          expo$2 = match[1];
          list = List.map((function (param) do
                  return --[[ tuple ]]{
                          param[0],
                          param[1],
                          map_expression(param[2])
                        };
                end end), match[0]);
          expo$3 = expo$2 ~= undefined and map_expression(expo$2) or expo$2;
          exp_desc = --[[ Texp_record ]]Block.__(10, {
              list,
              expo$3
            });end else 
       if ___conditional___ = 11--[[ Texp_field ]] then do
          exp_desc = --[[ Texp_field ]]Block.__(11, {
              map_expression(match[0]),
              match[1],
              match[2]
            });end else 
       if ___conditional___ = 12--[[ Texp_setfield ]] then do
          exp_desc = --[[ Texp_setfield ]]Block.__(12, {
              map_expression(match[0]),
              match[1],
              match[2],
              map_expression(match[3])
            });end else 
       if ___conditional___ = 13--[[ Texp_array ]] then do
          exp_desc = --[[ Texp_array ]]Block.__(13, {List.map(map_expression, match[0])});end else 
       if ___conditional___ = 14--[[ Texp_ifthenelse ]] then do
          expo$4 = match[2];
          exp_desc = --[[ Texp_ifthenelse ]]Block.__(14, {
              map_expression(match[0]),
              map_expression(match[1]),
              expo$4 ~= undefined and map_expression(expo$4) or expo$4
            });end else 
       if ___conditional___ = 15--[[ Texp_sequence ]] then do
          exp_desc = --[[ Texp_sequence ]]Block.__(15, {
              map_expression(match[0]),
              map_expression(match[1])
            });end else 
       if ___conditional___ = 16--[[ Texp_while ]] then do
          exp_desc = --[[ Texp_while ]]Block.__(16, {
              map_expression(match[0]),
              map_expression(match[1])
            });end else 
       if ___conditional___ = 17--[[ Texp_for ]] then do
          exp_desc = --[[ Texp_for ]]Block.__(17, {
              match[0],
              match[1],
              map_expression(match[2]),
              map_expression(match[3]),
              match[4],
              map_expression(match[5])
            });end else 
       if ___conditional___ = 18--[[ Texp_send ]] then do
          exp_desc = --[[ Texp_send ]]Block.__(18, {
              map_expression(match[0]),
              match[1],
              may_map(map_expression, match[2])
            });end else 
       if ___conditional___ = 0--[[ Texp_ident ]]
       or ___conditional___ = 1--[[ Texp_constant ]]
       or ___conditional___ = 19--[[ Texp_new ]]
       or ___conditional___ = 20--[[ Texp_instvar ]] then do
          exp_desc = exp$1.exp_desc;end else 
       if ___conditional___ = 21--[[ Texp_setinstvar ]] then do
          exp_desc = --[[ Texp_setinstvar ]]Block.__(21, {
              match[0],
              match[1],
              match[2],
              map_expression(match[3])
            });end else 
       if ___conditional___ = 22--[[ Texp_override ]] then do
          exp_desc = --[[ Texp_override ]]Block.__(22, {
              match[0],
              List.map((function (param) do
                      return --[[ tuple ]]{
                              param[0],
                              param[1],
                              map_expression(param[2])
                            };
                    end end), match[1])
            });end else 
       if ___conditional___ = 23--[[ Texp_letmodule ]] then do
          exp_desc = --[[ Texp_letmodule ]]Block.__(23, {
              match[0],
              match[1],
              map_module_expr(match[2]),
              map_expression(match[3])
            });end else 
       if ___conditional___ = 24--[[ Texp_assert ]] then do
          exp_desc = --[[ Texp_assert ]]Block.__(24, {map_expression(match[0])});end else 
       if ___conditional___ = 25--[[ Texp_lazy ]] then do
          exp_desc = --[[ Texp_lazy ]]Block.__(25, {map_expression(match[0])});end else 
       if ___conditional___ = 26--[[ Texp_object ]] then do
          exp_desc = --[[ Texp_object ]]Block.__(26, {
              map_class_structure(match[0]),
              match[1]
            });end else 
       if ___conditional___ = 27--[[ Texp_pack ]] then do
          exp_desc = --[[ Texp_pack ]]Block.__(27, {map_module_expr(match[0])});end else 
       do end end end end end end end end end end end end end end end end end end end end end end end end end end
      
    end
    exp_extra = List.map(map_exp_extra, exp$1.exp_extra);
    return Curry._1(funarg.leave_expression, do
                exp_desc: exp_desc,
                exp_loc: exp$1.exp_loc,
                exp_extra: exp_extra,
                exp_type: exp$1.exp_type,
                exp_env: exp$1.exp_env,
                exp_attributes: exp$1.exp_attributes
              end);
  end end;
  map_structure_item = function (item) do
    item$1 = Curry._1(funarg.enter_structure_item, item);
    match = item$1.str_desc;
    str_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 0--[[ Tstr_eval ]] then do
          str_desc = --[[ Tstr_eval ]]Block.__(0, {
              map_expression(match[0]),
              match[1]
            });end else 
       if ___conditional___ = 1--[[ Tstr_value ]] then do
          str_desc = --[[ Tstr_value ]]Block.__(1, {
              match[0],
              List.map(map_binding, match[1])
            });end else 
       if ___conditional___ = 2--[[ Tstr_primitive ]] then do
          str_desc = --[[ Tstr_primitive ]]Block.__(2, {map_value_description(match[0])});end else 
       if ___conditional___ = 3--[[ Tstr_type ]] then do
          str_desc = --[[ Tstr_type ]]Block.__(3, {List.map(map_type_declaration, match[0])});end else 
       if ___conditional___ = 4--[[ Tstr_typext ]] then do
          str_desc = --[[ Tstr_typext ]]Block.__(4, {map_type_extension(match[0])});end else 
       if ___conditional___ = 5--[[ Tstr_exception ]] then do
          str_desc = --[[ Tstr_exception ]]Block.__(5, {map_extension_constructor(match[0])});end else 
       if ___conditional___ = 6--[[ Tstr_module ]] then do
          str_desc = --[[ Tstr_module ]]Block.__(6, {map_module_binding(match[0])});end else 
       if ___conditional___ = 7--[[ Tstr_recmodule ]] then do
          list = List.map(map_module_binding, match[0]);
          str_desc = --[[ Tstr_recmodule ]]Block.__(7, {list});end else 
       if ___conditional___ = 8--[[ Tstr_modtype ]] then do
          str_desc = --[[ Tstr_modtype ]]Block.__(8, {map_module_type_declaration(match[0])});end else 
       if ___conditional___ = 9--[[ Tstr_open ]] then do
          str_desc = --[[ Tstr_open ]]Block.__(9, {match[0]});end else 
       if ___conditional___ = 10--[[ Tstr_class ]] then do
          list$1 = List.map((function (param) do
                  return --[[ tuple ]]{
                          map_class_declaration(param[0]),
                          param[1],
                          param[2]
                        };
                end end), match[0]);
          str_desc = --[[ Tstr_class ]]Block.__(10, {list$1});end else 
       if ___conditional___ = 11--[[ Tstr_class_type ]] then do
          list$2 = List.map((function (param) do
                  return --[[ tuple ]]{
                          param[0],
                          param[1],
                          map_class_type_declaration(param[2])
                        };
                end end), match[0]);
          str_desc = --[[ Tstr_class_type ]]Block.__(11, {list$2});end else 
       if ___conditional___ = 12--[[ Tstr_include ]] then do
          incl = match[0];
          str_desc = --[[ Tstr_include ]]Block.__(12, {do
                incl_mod: map_module_expr(incl.incl_mod),
                incl_type: incl.incl_type,
                incl_loc: incl.incl_loc,
                incl_attributes: incl.incl_attributes
              end});end else 
       if ___conditional___ = 13--[[ Tstr_attribute ]] then do
          str_desc = --[[ Tstr_attribute ]]Block.__(13, {match[0]});end else 
       do end end end end end end end end end end end end end end end
      
    end
    return Curry._1(funarg.leave_structure_item, do
                str_desc: str_desc,
                str_loc: item$1.str_loc,
                str_env: item$1.str_env
              end);
  end end;
  map_class_structure = function (cs) do
    cs$1 = Curry._1(funarg.enter_class_structure, cs);
    cstr_self = map_pattern(cs$1.cstr_self);
    cstr_fields = List.map(map_class_field, cs$1.cstr_fields);
    return Curry._1(funarg.leave_class_structure, do
                cstr_self: cstr_self,
                cstr_fields: cstr_fields,
                cstr_type: cs$1.cstr_type,
                cstr_meths: cs$1.cstr_meths
              end);
  end end;
  map_binding = function (vb) do
    return do
            vb_pat: map_pattern(vb.vb_pat),
            vb_expr: map_expression(vb.vb_expr),
            vb_attributes: vb.vb_attributes,
            vb_loc: vb.vb_loc
          end;
  end end;
  map_class_field = function (cf) do
    cf$1 = Curry._1(funarg.enter_class_field, cf);
    x = cf$1.cf_desc;
    cf_desc;
    local ___conditional___=(x.tag | 0);
    do
       if ___conditional___ = 0--[[ Tcf_inherit ]] then do
          cf_desc = --[[ Tcf_inherit ]]Block.__(0, {
              x[0],
              map_class_expr(x[1]),
              x[2],
              x[3],
              x[4]
            });end else 
       if ___conditional___ = 1--[[ Tcf_val ]] then do
          match = x[3];
          ident = x[2];
          mut = x[1];
          lab = x[0];
          cf_desc = match.tag and --[[ Tcf_val ]]Block.__(1, {
                lab,
                mut,
                ident,
                --[[ Tcfk_concrete ]]Block.__(1, {
                    match[0],
                    map_expression(match[1])
                  }),
                x[4]
              }) or --[[ Tcf_val ]]Block.__(1, {
                lab,
                mut,
                ident,
                --[[ Tcfk_virtual ]]Block.__(0, {map_core_type(match[0])}),
                x[4]
              });end else 
       if ___conditional___ = 2--[[ Tcf_method ]] then do
          match$1 = x[2];
          priv = x[1];
          lab$1 = x[0];
          cf_desc = match$1.tag and --[[ Tcf_method ]]Block.__(2, {
                lab$1,
                priv,
                --[[ Tcfk_concrete ]]Block.__(1, {
                    match$1[0],
                    map_expression(match$1[1])
                  })
              }) or --[[ Tcf_method ]]Block.__(2, {
                lab$1,
                priv,
                --[[ Tcfk_virtual ]]Block.__(0, {map_core_type(match$1[0])})
              });end else 
       if ___conditional___ = 3--[[ Tcf_constraint ]] then do
          cf_desc = --[[ Tcf_constraint ]]Block.__(3, {
              map_core_type(x[0]),
              map_core_type(x[1])
            });end else 
       if ___conditional___ = 4--[[ Tcf_initializer ]] then do
          cf_desc = --[[ Tcf_initializer ]]Block.__(4, {map_expression(x[0])});end else 
       if ___conditional___ = 5--[[ Tcf_attribute ]] then do
          cf_desc = x;end else 
       do end end end end end end end
      
    end
    return Curry._1(funarg.leave_class_field, do
                cf_desc: cf_desc,
                cf_loc: cf$1.cf_loc,
                cf_attributes: cf$1.cf_attributes
              end);
  end end;
  map_constructor_declaration = function (cd) do
    return do
            cd_id: cd.cd_id,
            cd_name: cd.cd_name,
            cd_args: List.map(map_core_type, cd.cd_args),
            cd_res: may_map(map_core_type, cd.cd_res),
            cd_loc: cd.cd_loc,
            cd_attributes: cd.cd_attributes
          end;
  end end;
  map_class_signature = function (cs) do
    cs$1 = Curry._1(funarg.enter_class_signature, cs);
    csig_self = map_core_type(cs$1.csig_self);
    csig_fields = List.map(map_class_type_field, cs$1.csig_fields);
    return Curry._1(funarg.leave_class_signature, do
                csig_self: csig_self,
                csig_fields: csig_fields,
                csig_type: cs$1.csig_type
              end);
  end end;
  map_case = function (param) do
    return do
            c_lhs: map_pattern(param.c_lhs),
            c_guard: may_map(map_expression, param.c_guard),
            c_rhs: map_expression(param.c_rhs)
          end;
  end end;
  map_exp_extra = function (exp_extra) do
    attrs = exp_extra[2];
    loc = exp_extra[1];
    desc = exp_extra[0];
    local ___conditional___=(desc.tag | 0);
    do
       if ___conditional___ = 0--[[ Texp_constraint ]] then do
          return --[[ tuple ]]{
                  --[[ Texp_constraint ]]Block.__(0, {map_core_type(desc[0])}),
                  loc,
                  attrs
                };end end end 
       if ___conditional___ = 1--[[ Texp_coerce ]] then do
          match = desc[0];
          if (match ~= undefined) then do
            return --[[ tuple ]]{
                    --[[ Texp_coerce ]]Block.__(1, {
                        map_core_type(match),
                        map_core_type(desc[1])
                      }),
                    loc,
                    attrs
                  };
          end else do
            return --[[ tuple ]]{
                    --[[ Texp_coerce ]]Block.__(1, {
                        undefined,
                        map_core_type(desc[1])
                      }),
                    loc,
                    attrs
                  };
          end end end end end 
       if ___conditional___ = 3--[[ Texp_poly ]] then do
          match$1 = desc[0];
          if (match$1 ~= undefined) then do
            return --[[ tuple ]]{
                    --[[ Texp_poly ]]Block.__(3, {map_core_type(match$1)}),
                    loc,
                    attrs
                  };
          end else do
            return exp_extra;
          end end end end end 
       if ___conditional___ = 2--[[ Texp_open ]]
       or ___conditional___ = 4--[[ Texp_newtype ]] then do
          return exp_extra;end end end 
       do
      
    end
  end end;
  map_row_field = function (rf) do
    if (rf.tag) then do
      return --[[ Tinherit ]]Block.__(1, {map_core_type(rf[0])});
    end else do
      return --[[ Ttag ]]Block.__(0, {
                rf[0],
                rf[1],
                rf[2],
                List.map(map_core_type, rf[3])
              });
    end end 
  end end;
  map_package_type = function (pack) do
    pack$1 = Curry._1(funarg.enter_package_type, pack);
    pack_fields = List.map((function (param) do
            return --[[ tuple ]]{
                    param[0],
                    map_core_type(param[1])
                  };
          end end), pack$1.pack_fields);
    return Curry._1(funarg.leave_package_type, do
                pack_path: pack$1.pack_path,
                pack_fields: pack_fields,
                pack_type: pack$1.pack_type,
                pack_txt: pack$1.pack_txt
              end);
  end end;
  map_class_type_field = function (ctf) do
    ctf$1 = Curry._1(funarg.enter_class_type_field, ctf);
    x = ctf$1.ctf_desc;
    ctf_desc;
    local ___conditional___=(x.tag | 0);
    do
       if ___conditional___ = 0--[[ Tctf_inherit ]] then do
          ctf_desc = --[[ Tctf_inherit ]]Block.__(0, {map_class_type(x[0])});end else 
       if ___conditional___ = 1--[[ Tctf_val ]] then do
          match = x[0];
          ctf_desc = --[[ Tctf_val ]]Block.__(1, {--[[ tuple ]]{
                match[0],
                match[1],
                match[2],
                map_core_type(match[3])
              }});end else 
       if ___conditional___ = 2--[[ Tctf_method ]] then do
          match$1 = x[0];
          ctf_desc = --[[ Tctf_method ]]Block.__(2, {--[[ tuple ]]{
                match$1[0],
                match$1[1],
                match$1[2],
                map_core_type(match$1[3])
              }});end else 
       if ___conditional___ = 3--[[ Tctf_constraint ]] then do
          match$2 = x[0];
          ctf_desc = --[[ Tctf_constraint ]]Block.__(3, {--[[ tuple ]]{
                map_core_type(match$2[0]),
                map_core_type(match$2[1])
              }});end else 
       if ___conditional___ = 4--[[ Tctf_attribute ]] then do
          ctf_desc = x;end else 
       do end end end end end end
      
    end
    return Curry._1(funarg.leave_class_type_field, do
                ctf_desc: ctf_desc,
                ctf_loc: ctf$1.ctf_loc,
                ctf_attributes: ctf$1.ctf_attributes
              end);
  end end;
  map_signature_item = function (item) do
    item$1 = Curry._1(funarg.enter_signature_item, item);
    x = item$1.sig_desc;
    sig_desc;
    local ___conditional___=(x.tag | 0);
    do
       if ___conditional___ = 0--[[ Tsig_value ]] then do
          sig_desc = --[[ Tsig_value ]]Block.__(0, {map_value_description(x[0])});end else 
       if ___conditional___ = 1--[[ Tsig_type ]] then do
          sig_desc = --[[ Tsig_type ]]Block.__(1, {List.map(map_type_declaration, x[0])});end else 
       if ___conditional___ = 2--[[ Tsig_typext ]] then do
          sig_desc = --[[ Tsig_typext ]]Block.__(2, {map_type_extension(x[0])});end else 
       if ___conditional___ = 3--[[ Tsig_exception ]] then do
          sig_desc = --[[ Tsig_exception ]]Block.__(3, {map_extension_constructor(x[0])});end else 
       if ___conditional___ = 4--[[ Tsig_module ]] then do
          md = x[0];
          sig_desc = --[[ Tsig_module ]]Block.__(4, {do
                md_id: md.md_id,
                md_name: md.md_name,
                md_type: map_module_type(md.md_type),
                md_attributes: md.md_attributes,
                md_loc: md.md_loc
              end});end else 
       if ___conditional___ = 5--[[ Tsig_recmodule ]] then do
          sig_desc = --[[ Tsig_recmodule ]]Block.__(5, {List.map((function (md) do
                      return do
                              md_id: md.md_id,
                              md_name: md.md_name,
                              md_type: map_module_type(md.md_type),
                              md_attributes: md.md_attributes,
                              md_loc: md.md_loc
                            end;
                    end end), x[0])});end else 
       if ___conditional___ = 6--[[ Tsig_modtype ]] then do
          sig_desc = --[[ Tsig_modtype ]]Block.__(6, {map_module_type_declaration(x[0])});end else 
       if ___conditional___ = 7--[[ Tsig_open ]] then do
          sig_desc = item$1.sig_desc;end else 
       if ___conditional___ = 8--[[ Tsig_include ]] then do
          incl = x[0];
          sig_desc = --[[ Tsig_include ]]Block.__(8, {do
                incl_mod: map_module_type(incl.incl_mod),
                incl_type: incl.incl_type,
                incl_loc: incl.incl_loc,
                incl_attributes: incl.incl_attributes
              end});end else 
       if ___conditional___ = 9--[[ Tsig_class ]] then do
          sig_desc = --[[ Tsig_class ]]Block.__(9, {List.map(map_class_description, x[0])});end else 
       if ___conditional___ = 10--[[ Tsig_class_type ]] then do
          sig_desc = --[[ Tsig_class_type ]]Block.__(10, {List.map(map_class_type_declaration, x[0])});end else 
       if ___conditional___ = 11--[[ Tsig_attribute ]] then do
          sig_desc = x;end else 
       do end end end end end end end end end end end end end
      
    end
    return Curry._1(funarg.leave_signature_item, do
                sig_desc: sig_desc,
                sig_env: item$1.sig_env,
                sig_loc: item$1.sig_loc
              end);
  end end;
  map_class_declaration = function (cd) do
    cd$1 = Curry._1(funarg.enter_class_declaration, cd);
    ci_params = List.map(map_type_parameter, cd$1.ci_params);
    ci_expr = map_class_expr(cd$1.ci_expr);
    return Curry._1(funarg.leave_class_declaration, do
                ci_virt: cd$1.ci_virt,
                ci_params: ci_params,
                ci_id_name: cd$1.ci_id_name,
                ci_id_class: cd$1.ci_id_class,
                ci_id_class_type: cd$1.ci_id_class_type,
                ci_id_object: cd$1.ci_id_object,
                ci_id_typesharp: cd$1.ci_id_typesharp,
                ci_expr: ci_expr,
                ci_decl: cd$1.ci_decl,
                ci_type_decl: cd$1.ci_type_decl,
                ci_loc: cd$1.ci_loc,
                ci_attributes: cd$1.ci_attributes
              end);
  end end;
  map_module_binding = function (x) do
    return do
            mb_id: x.mb_id,
            mb_name: x.mb_name,
            mb_expr: map_module_expr(x.mb_expr),
            mb_attributes: x.mb_attributes,
            mb_loc: x.mb_loc
          end;
  end end;
  return do
          map_structure: map_structure,
          map_pattern: map_pattern,
          map_structure_item: map_structure_item,
          map_expression: map_expression,
          map_class_expr: map_class_expr,
          map_signature: map_signature,
          map_signature_item: map_signature_item,
          map_module_type: map_module_type
        end;
end end

need_to_clear_env;

try do
  Caml_sys.caml_sys_getenv("OCAML_BINANNOT_WITHENV");
  need_to_clear_env = false;
end
catch (exn$2)do
  if (exn$2 == Caml_builtin_exceptions.not_found) then do
    need_to_clear_env = true;
  end else do
    throw exn$2;
  end end 
end

function leave_pattern(p) do
  return do
          pat_desc: p.pat_desc,
          pat_loc: p.pat_loc,
          pat_extra: p.pat_extra,
          pat_type: p.pat_type,
          pat_env: keep_only_summary(p.pat_env),
          pat_attributes: p.pat_attributes
        end;
end end

function leave_expression(e) do
  exp_extra = List.map((function (exp_extra) do
          match = exp_extra[0];
          if (match.tag == --[[ Texp_open ]]2) then do
            return --[[ tuple ]]{
                    --[[ Texp_open ]]Block.__(2, {
                        match[0],
                        match[1],
                        match[2],
                        keep_only_summary(match[3])
                      }),
                    exp_extra[1],
                    exp_extra[2]
                  };
          end else do
            return exp_extra;
          end end 
        end end), e.exp_extra);
  return do
          exp_desc: e.exp_desc,
          exp_loc: e.exp_loc,
          exp_extra: exp_extra,
          exp_type: e.exp_type,
          exp_env: keep_only_summary(e.exp_env),
          exp_attributes: e.exp_attributes
        end;
end end

function leave_class_expr(c) do
  return do
          cl_desc: c.cl_desc,
          cl_loc: c.cl_loc,
          cl_type: c.cl_type,
          cl_env: keep_only_summary(c.cl_env),
          cl_attributes: c.cl_attributes
        end;
end end

function leave_module_expr(m) do
  return do
          mod_desc: m.mod_desc,
          mod_loc: m.mod_loc,
          mod_type: m.mod_type,
          mod_env: keep_only_summary(m.mod_env),
          mod_attributes: m.mod_attributes
        end;
end end

function leave_structure(s) do
  return do
          str_items: s.str_items,
          str_type: s.str_type,
          str_final_env: keep_only_summary(s.str_final_env)
        end;
end end

function leave_structure_item(str) do
  return do
          str_desc: str.str_desc,
          str_loc: str.str_loc,
          str_env: keep_only_summary(str.str_env)
        end;
end end

function leave_module_type(m) do
  return do
          mty_desc: m.mty_desc,
          mty_type: m.mty_type,
          mty_env: keep_only_summary(m.mty_env),
          mty_loc: m.mty_loc,
          mty_attributes: m.mty_attributes
        end;
end end

function leave_signature(s) do
  return do
          sig_items: s.sig_items,
          sig_type: s.sig_type,
          sig_final_env: keep_only_summary(s.sig_final_env)
        end;
end end

function leave_signature_item(s) do
  return do
          sig_desc: s.sig_desc,
          sig_env: keep_only_summary(s.sig_env),
          sig_loc: s.sig_loc
        end;
end end

function leave_core_type(c) do
  return do
          ctyp_desc: c.ctyp_desc,
          ctyp_type: c.ctyp_type,
          ctyp_env: keep_only_summary(c.ctyp_env),
          ctyp_loc: c.ctyp_loc,
          ctyp_attributes: c.ctyp_attributes
        end;
end end

function leave_class_type(c) do
  return do
          cltyp_desc: c.cltyp_desc,
          cltyp_type: c.cltyp_type,
          cltyp_env: keep_only_summary(c.cltyp_env),
          cltyp_loc: c.cltyp_loc,
          cltyp_attributes: c.cltyp_attributes
        end;
end end

ClearEnv = Curry._1(TypedtreeMap_MakeMap, do
      enter_structure: enter_structure,
      enter_value_description: enter_value_description,
      enter_type_declaration: enter_type_declaration,
      enter_type_extension: enter_type_extension,
      enter_extension_constructor: enter_extension_constructor,
      enter_pattern: enter_pattern,
      enter_expression: enter_expression,
      enter_package_type: enter_package_type,
      enter_signature: enter_signature,
      enter_signature_item: enter_signature_item,
      enter_module_type_declaration: enter_module_type_declaration,
      enter_module_type: enter_module_type,
      enter_module_expr: enter_module_expr,
      enter_with_constraint: enter_with_constraint,
      enter_class_expr: enter_class_expr,
      enter_class_signature: enter_class_signature,
      enter_class_declaration: enter_class_declaration,
      enter_class_description: enter_class_description,
      enter_class_type_declaration: enter_class_type_declaration,
      enter_class_type: enter_class_type,
      enter_class_type_field: enter_class_type_field,
      enter_core_type: enter_core_type,
      enter_class_structure: enter_class_structure,
      enter_class_field: enter_class_field,
      enter_structure_item: enter_structure_item,
      leave_structure: leave_structure,
      leave_value_description: leave_value_description,
      leave_type_declaration: leave_type_declaration,
      leave_type_extension: leave_type_extension,
      leave_extension_constructor: leave_extension_constructor,
      leave_pattern: leave_pattern,
      leave_expression: leave_expression,
      leave_package_type: leave_package_type,
      leave_signature: leave_signature,
      leave_signature_item: leave_signature_item,
      leave_module_type_declaration: leave_module_type_declaration,
      leave_module_type: leave_module_type,
      leave_module_expr: leave_module_expr,
      leave_with_constraint: leave_with_constraint,
      leave_class_expr: leave_class_expr,
      leave_class_signature: leave_class_signature,
      leave_class_declaration: leave_class_declaration,
      leave_class_description: leave_class_description,
      leave_class_type_declaration: leave_class_type_declaration,
      leave_class_type: leave_class_type,
      leave_class_type_field: leave_class_type_field,
      leave_core_type: leave_core_type,
      leave_class_structure: leave_class_structure,
      leave_class_field: leave_class_field,
      leave_structure_item: leave_structure_item
    end);

function clear_part(p) do
  local ___conditional___=(p.tag | 0);
  do
     if ___conditional___ = 0--[[ Partial_structure ]] then do
        return --[[ Partial_structure ]]Block.__(0, {Curry._1(ClearEnv.map_structure, p[0])});end end end 
     if ___conditional___ = 1--[[ Partial_structure_item ]] then do
        return --[[ Partial_structure_item ]]Block.__(1, {Curry._1(ClearEnv.map_structure_item, p[0])});end end end 
     if ___conditional___ = 2--[[ Partial_expression ]] then do
        return --[[ Partial_expression ]]Block.__(2, {Curry._1(ClearEnv.map_expression, p[0])});end end end 
     if ___conditional___ = 3--[[ Partial_pattern ]] then do
        return --[[ Partial_pattern ]]Block.__(3, {Curry._1(ClearEnv.map_pattern, p[0])});end end end 
     if ___conditional___ = 4--[[ Partial_class_expr ]] then do
        return --[[ Partial_class_expr ]]Block.__(4, {Curry._1(ClearEnv.map_class_expr, p[0])});end end end 
     if ___conditional___ = 5--[[ Partial_signature ]] then do
        return --[[ Partial_signature ]]Block.__(5, {Curry._1(ClearEnv.map_signature, p[0])});end end end 
     if ___conditional___ = 6--[[ Partial_signature_item ]] then do
        return --[[ Partial_signature_item ]]Block.__(6, {Curry._1(ClearEnv.map_signature_item, p[0])});end end end 
     if ___conditional___ = 7--[[ Partial_module_type ]] then do
        return --[[ Partial_module_type ]]Block.__(7, {Curry._1(ClearEnv.map_module_type, p[0])});end end end 
     do
    
  end
end end

function clear_env(binary_annots) do
  if (need_to_clear_env) then do
    local ___conditional___=(binary_annots.tag | 0);
    do
       if ___conditional___ = 0--[[ Packed ]] then do
          return binary_annots;end end end 
       if ___conditional___ = 1--[[ Implementation ]] then do
          return --[[ Implementation ]]Block.__(1, {Curry._1(ClearEnv.map_structure, binary_annots[0])});end end end 
       if ___conditional___ = 2--[[ Interface ]] then do
          return --[[ Interface ]]Block.__(2, {Curry._1(ClearEnv.map_signature, binary_annots[0])});end end end 
       if ___conditional___ = 3--[[ Partial_implementation ]] then do
          return --[[ Partial_implementation ]]Block.__(3, {__Array.map(clear_part, binary_annots[0])});end end end 
       if ___conditional___ = 4--[[ Partial_interface ]] then do
          return --[[ Partial_interface ]]Block.__(4, {__Array.map(clear_part, binary_annots[0])});end end end 
       do
      
    end
  end else do
    return binary_annots;
  end end 
end end

function output_cmt(oc, cmt) do
  Pervasives.output_string(oc, "Caml2012T004");
  return Caml_external_polyfill.resolve("caml_output_value")(oc, cmt, --[[ [] ]]0);
end end

saved_types = do
  contents: --[[ [] ]]0
end;

value_deps = do
  contents: --[[ [] ]]0
end;

function clear(param) do
  saved_types.contents = --[[ [] ]]0;
  value_deps.contents = --[[ [] ]]0;
  return --[[ () ]]0;
end end

function add_saved_type(b) do
  saved_types.contents = --[[ :: ]]{
    b,
    saved_types.contents
  };
  return --[[ () ]]0;
end end

function record_value_dependency(vd1, vd2) do
  if (Caml_obj.caml_notequal(vd1.val_loc, vd2.val_loc)) then do
    value_deps.contents = --[[ :: ]]{
      --[[ tuple ]]{
        vd1,
        vd2
      },
      value_deps.contents
    };
    return --[[ () ]]0;
  end else do
    return 0;
  end end 
end end

function save_cmt(filename, modname, binary_annots, sourcefile, initial_env, sg) do
  if (binary_annotations.contents and not print_types.contents) then do
    imports$1 = imports(--[[ () ]]0);
    oc = Pervasives.open_out_bin(filename);
    this_crc;
    if (sg ~= undefined) then do
      cmi_cmi_flags = recursive_types.contents and --[[ :: ]]{
          --[[ Rectypes ]]0,
          --[[ [] ]]0
        } or --[[ [] ]]0;
      cmi = do
        cmi_name: modname,
        cmi_sign: sg,
        cmi_crcs: imports$1,
        cmi_flags: cmi_cmi_flags
      end;
      this_crc = output_cmi(filename, oc, cmi);
    end else do
      this_crc = undefined;
    end end 
    source_digest = may_map(Digest.file, sourcefile);
    cmt_cmt_annots = clear_env(binary_annots);
    cmt_cmt_value_dependencies = value_deps.contents;
    cmt_cmt_comments = List.rev(comment_list.contents);
    cmt_cmt_builddir = Caml_sys.caml_sys_getcwd(--[[ () ]]0);
    cmt_cmt_loadpath = load_path.contents;
    cmt_cmt_initial_env = need_to_clear_env and keep_only_summary(initial_env) or initial_env;
    cmt_cmt_imports = List.sort(Caml_obj.caml_compare, imports$1);
    cmt = do
      cmt_modname: modname,
      cmt_annots: cmt_cmt_annots,
      cmt_value_dependencies: cmt_cmt_value_dependencies,
      cmt_comments: cmt_cmt_comments,
      cmt_args: Sys.argv,
      cmt_sourcefile: sourcefile,
      cmt_builddir: cmt_cmt_builddir,
      cmt_loadpath: cmt_cmt_loadpath,
      cmt_source_digest: source_digest,
      cmt_initial_env: cmt_cmt_initial_env,
      cmt_imports: cmt_cmt_imports,
      cmt_interface_digest: this_crc,
      cmt_use_summaries: need_to_clear_env
    end;
    output_cmt(oc, cmt);
    Caml_io.caml_ml_flush(oc);
    Caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
    exit = 0;
    cmd;
    try do
      cmd = Caml_sys.caml_sys_getenv("BS_CMT_POST_PROCESS_CMD");
      exit = 1;
    end
    catch (exn)do
      
    end
    if (exit == 1) then do
      Caml_sys.caml_sys_system_command(cmd .. (" -cmt-add " .. (filename .. (
                sourcefile ~= undefined and ":" .. sourcefile or ""
              ))));
    end
     end 
  end
   end 
  return clear(--[[ () ]]0);
end end

Unify = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Unify");

Tags = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Tags");

register_error_of_exn((function (param) do
        if (param[0] == Tags) then do
          return Curry._2(errorf(in_file(input_name.contents), undefined, undefined, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "In this program,",
                              --[[ Formatting_lit ]]Block.__(17, {
                                  --[[ Break ]]Block.__(0, {
                                      "@ ",
                                      1,
                                      0
                                    }),
                                  --[[ String_literal ]]Block.__(11, {
                                      "variant constructors",
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ Char_literal ]]Block.__(12, {
                                              --[[ "`" ]]96,
                                              --[[ String ]]Block.__(2, {
                                                  --[[ No_padding ]]0,
                                                  --[[ String_literal ]]Block.__(11, {
                                                      " and `",
                                                      --[[ String ]]Block.__(2, {
                                                          --[[ No_padding ]]0,
                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Break ]]Block.__(0, {
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                }),
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "have the same hash value.",
                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Break ]]Block.__(0, {
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        }),
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          "Change one of them.",
                                                                          --[[ End_of_format ]]0
                                                                        })
                                                                    })
                                                                })
                                                            })
                                                        })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            }),
                          "In this program,@ variant constructors@ `%s and `%s@ have the same hash value.@ Change one of them."
                        }), param[1], param[2]);
        end
         end 
      end end));

Subtype = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Subtype");

Cannot_expand = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Cannot_expand");

Recursive_abbrev = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Recursive_abbrev");

Unification_recursive_abbrev = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Unification_recursive_abbrev");

current_level = do
  contents: 0
end;

nongen_level = do
  contents: 0
end;

global_level = do
  contents: 1
end;

saved_level = do
  contents: --[[ [] ]]0
end;

function init_def(level) do
  current_level.contents = level;
  nongen_level.contents = level;
  return --[[ () ]]0;
end end

function begin_def(param) do
  saved_level.contents = --[[ :: ]]{
    --[[ tuple ]]{
      current_level.contents,
      nongen_level.contents
    },
    saved_level.contents
  };
  current_level.contents = current_level.contents + 1 | 0;
  nongen_level.contents = current_level.contents;
  return --[[ () ]]0;
end end

function begin_class_def(param) do
  saved_level.contents = --[[ :: ]]{
    --[[ tuple ]]{
      current_level.contents,
      nongen_level.contents
    },
    saved_level.contents
  };
  current_level.contents = current_level.contents + 1 | 0;
  return --[[ () ]]0;
end end

function raise_nongen_level(param) do
  saved_level.contents = --[[ :: ]]{
    --[[ tuple ]]{
      current_level.contents,
      nongen_level.contents
    },
    saved_level.contents
  };
  nongen_level.contents = current_level.contents;
  return --[[ () ]]0;
end end

function end_def(param) do
  match = List.hd(saved_level.contents);
  saved_level.contents = List.tl(saved_level.contents);
  current_level.contents = match[0];
  nongen_level.contents = match[1];
  return --[[ () ]]0;
end end

function reset_global_level(param) do
  global_level.contents = current_level.contents + 1 | 0;
  return --[[ () ]]0;
end end

function increase_global_level(param) do
  gl = global_level.contents;
  global_level.contents = current_level.contents;
  return gl;
end end

function is_object_type(path) do
  name;
  local ___conditional___=(path.tag | 0);
  do
     if ___conditional___ = 0--[[ Pident ]] then do
        name = path[0].name;end else 
     if ___conditional___ = 1--[[ Pdot ]] then do
        name = path[1];end else 
     if ___conditional___ = 2--[[ Papply ]] then do
        throw {
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "ctype.ml",
                149,
                23
              }
            };end end end 
     do end end
    
  end
  return Caml_string.get(name, 0) == --[[ "#" ]]35;
end end

trace_gadt_instances = do
  contents: false
end;

function check_trace_gadt_instances(env) do
  if (not trace_gadt_instances.contents and env.local_constraints) then do
    trace_gadt_instances.contents = true;
    cleanup_abbrev(--[[ () ]]0);
    return true;
  end else do
    return false;
  end end 
end end

function reset_trace_gadt_instances(b) do
  if (b) then do
    trace_gadt_instances.contents = false;
    return --[[ () ]]0;
  end else do
    return 0;
  end end 
end end

function wrap_trace_gadt_instances(env, f, x) do
  b = check_trace_gadt_instances(env);
  y = Curry._1(f, x);
  reset_trace_gadt_instances(b);
  return y;
end end

simple_abbrevs = do
  contents: --[[ Mnil ]]0
end;

function proper_abbrevs(path, tl, abbrev) do
  if (tl ~= --[[ [] ]]0 or trace_gadt_instances.contents or principal.contents or is_object_type(path)) then do
    return abbrev;
  end else do
    return simple_abbrevs;
  end end 
end end

function newvar(name, param) do
  return newty2(current_level.contents, --[[ Tvar ]]Block.__(0, {name}));
end end

function new_global_var(name, param) do
  return newty2(global_level.contents, --[[ Tvar ]]Block.__(0, {name}));
end end

function newobj(fields) do
  return newty2(current_level.contents, --[[ Tobject ]]Block.__(4, {
                fields,
                do
                  contents: undefined
                end
              }));
end end

function newconstr(path, tyl) do
  return newty2(current_level.contents, --[[ Tconstr ]]Block.__(3, {
                path,
                tyl,
                do
                  contents: --[[ Mnil ]]0
                end
              }));
end end

none$2 = newty2(current_level.contents, --[[ Ttuple ]]Block.__(2, {--[[ [] ]]0}));

function equal$3(param, param$1) do
  if (param[0] == param$1[0]) then do
    return param[1] == param$1[1];
  end else do
    return false;
  end end 
end end

function hash$1(param) do
  return param[0].id + Caml_int32.imul(93, param[1].id) | 0;
end end

TypePairs = Hashtbl.Make(do
      equal: equal$3,
      hash: hash$1
    end);

umode = do
  contents: --[[ Expression ]]0
end;

generate_equations = do
  contents: false
end;

assume_injective = do
  contents: false
end;

function set_mode_pattern(generate, injective, f) do
  old_unification_mode = umode.contents;
  old_gen = generate_equations.contents;
  old_inj = assume_injective.contents;
  try do
    umode.contents = --[[ Pattern ]]1;
    generate_equations.contents = generate;
    assume_injective.contents = injective;
    ret = Curry._1(f, --[[ () ]]0);
    umode.contents = old_unification_mode;
    generate_equations.contents = old_gen;
    assume_injective.contents = old_inj;
    return ret;
  end
  catch (e)do
    umode.contents = old_unification_mode;
    generate_equations.contents = old_gen;
    assume_injective.contents = old_inj;
    throw e;
  end
end end

function in_current_module(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Pident ]] then do
        return true;end end end 
     if ___conditional___ = 1--[[ Pdot ]]
     or ___conditional___ = 2--[[ Papply ]] then do
        return false;end end end 
     do
    
  end
end end

function in_pervasives(p) do
  if (in_current_module(p)) then do
    try do
      find_type_full(p, initial_safe_string)[0];
      return true;
    end
    catch (exn)do
      if (exn == Caml_builtin_exceptions.not_found) then do
        return false;
      end else do
        throw exn;
      end end 
    end
  end else do
    return false;
  end end 
end end

function is_datatype(decl) do
  match = decl.type_kind;
  if (typeof match == "number") then do
    return match ~= 0;
  end else do
    return true;
  end end 
end end

function object_fields(ty) do
  match = repr(ty).desc;
  if (typeof match == "number") then do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ctype.ml",
            284,
            27
          }
        };
  end else if (match.tag == --[[ Tobject ]]4) then do
    return match[0];
  end else do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ctype.ml",
            284,
            27
          }
        };
  end end  end 
end end

function flatten_fields(ty) do
  flatten = function (_l, _ty) do
    while(true) do
      ty = _ty;
      l = _l;
      ty$1 = repr(ty);
      match = ty$1.desc;
      if (typeof match == "number" or match.tag ~= --[[ Tfield ]]5) then do
        return --[[ tuple ]]{
                l,
                ty$1
              };
      end else do
        _ty = match[3];
        _l = --[[ :: ]]{
          --[[ tuple ]]{
            match[0],
            match[1],
            match[2]
          },
          l
        };
        continue ;
      end end 
    end;
  end end;
  match = flatten(--[[ [] ]]0, ty);
  return --[[ tuple ]]{
          List.sort((function (param, param$1) do
                  return Caml_primitive.caml_string_compare(param[0], param$1[0]);
                end end), match[0]),
          match[1]
        };
end end

function build_fields(level) do
  return (function (param, param$1) do
      return List.fold_right((function (param, ty2) do
                    return newty2(level, --[[ Tfield ]]Block.__(5, {
                                  param[0],
                                  param[1],
                                  param[2],
                                  ty2
                                }));
                  end end), param, param$1);
    end end);
end end

function associate_fields(fields1, fields2) do
  _p = --[[ [] ]]0;
  _s = --[[ [] ]]0;
  _s$prime = --[[ [] ]]0;
  _param = --[[ tuple ]]{
    fields1,
    fields2
  };
  while(true) do
    param = _param;
    s$prime = _s$prime;
    s = _s;
    p = _p;
    l = param[0];
    if (param[1]) then do
      if (l) then do
        l$prime = param[1];
        r$prime = l$prime[1];
        match = l$prime[0];
        t$prime = match[2];
        k$prime = match[1];
        n$prime = match[0];
        r = l[1];
        match$1 = l[0];
        t = match$1[2];
        k = match$1[1];
        n = match$1[0];
        if (Caml_obj.caml_equal(n, n$prime)) then do
          _param = --[[ tuple ]]{
            r,
            r$prime
          };
          _p = --[[ :: ]]{
            --[[ tuple ]]{
              n,
              k,
              t,
              k$prime,
              t$prime
            },
            p
          };
          continue ;
        end else if (Caml_obj.caml_lessthan(n, n$prime)) then do
          _param = --[[ tuple ]]{
            r,
            l$prime
          };
          _s = --[[ :: ]]{
            --[[ tuple ]]{
              n,
              k,
              t
            },
            s
          };
          continue ;
        end else do
          _param = --[[ tuple ]]{
            l,
            r$prime
          };
          _s$prime = --[[ :: ]]{
            --[[ tuple ]]{
              n$prime,
              k$prime,
              t$prime
            },
            s$prime
          };
          continue ;
        end end  end 
      end else do
        return --[[ tuple ]]{
                List.rev(p),
                List.rev(s),
                Pervasives.$at(List.rev(s$prime), param[1])
              };
      end end 
    end else do
      return --[[ tuple ]]{
              List.rev(p),
              Pervasives.$at(List.rev(s), l),
              List.rev(s$prime)
            };
    end end 
  end;
end end

function object_row(_ty) do
  while(true) do
    ty = _ty;
    ty$1 = repr(ty);
    match = ty$1.desc;
    if (typeof match == "number") then do
      return ty$1;
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 4--[[ Tobject ]] then do
            _ty = match[0];
            continue ;end end end 
         if ___conditional___ = 5--[[ Tfield ]] then do
            _ty = match[3];
            continue ;end end end 
         do
        else do
          return ty$1;
          end end
          
      end
    end end 
  end;
end end

function opened_object(ty) do
  match = object_row(ty).desc;
  if (typeof match == "number") then do
    return false;
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 0--[[ Tvar ]]
       or ___conditional___ = 3--[[ Tconstr ]]
       or ___conditional___ = 9--[[ Tunivar ]] then do
          return true;end end end 
       do
      else do
        return false;
        end end
        
    end
  end end 
end end

function concrete_object(ty) do
  match = object_row(ty).desc;
  if (typeof match == "number" or match.tag) then do
    return true;
  end else do
    return false;
  end end 
end end

function close_object(ty) do
  match = repr(ty).desc;
  if (typeof match == "number") then do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ctype.ml",
            351,
            25
          }
        };
  end else if (match.tag == --[[ Tobject ]]4) then do
    _ty = match[0];
    while(true) do
      ty$1 = _ty;
      ty$2 = repr(ty$1);
      match$1 = ty$2.desc;
      if (typeof match$1 == "number") then do
        throw {
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "ctype.ml",
                347,
                30
              }
            };
      end else do
        local ___conditional___=(match$1.tag | 0);
        do
           if ___conditional___ = 0--[[ Tvar ]] then do
              return link_type(ty$2, newty2(ty$2.level, --[[ Tnil ]]0));end end end 
           if ___conditional___ = 5--[[ Tfield ]] then do
              _ty = match$1[3];
              continue ;end end end 
           do
          else do
            throw {
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "ctype.ml",
                    347,
                    30
                  }
                };
            end end
            
        end
      end end 
    end;
  end else do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ctype.ml",
            351,
            25
          }
        };
  end end  end 
end end

function row_variable(ty) do
  match = repr(ty).desc;
  if (typeof match == "number") then do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ctype.ml",
            365,
            23
          }
        };
  end else if (match.tag == --[[ Tobject ]]4) then do
    _ty = match[0];
    while(true) do
      ty$1 = _ty;
      ty$2 = repr(ty$1);
      match$1 = ty$2.desc;
      if (typeof match$1 == "number") then do
        throw {
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "ctype.ml",
                361,
                30
              }
            };
      end else do
        local ___conditional___=(match$1.tag | 0);
        do
           if ___conditional___ = 0--[[ Tvar ]] then do
              return ty$2;end end end 
           if ___conditional___ = 5--[[ Tfield ]] then do
              _ty = match$1[3];
              continue ;end end end 
           do
          else do
            throw {
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "ctype.ml",
                    361,
                    30
                  }
                };
            end end
            
        end
      end end 
    end;
  end else do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ctype.ml",
            365,
            23
          }
        };
  end end  end 
end end

function set_object_name(id, rv, params, ty) do
  match = repr(ty).desc;
  if (typeof match == "number") then do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ctype.ml",
            375,
            6
          }
        };
  end else if (match.tag == --[[ Tobject ]]4) then do
    return set_name(match[1], --[[ tuple ]]{
                --[[ Pident ]]Block.__(0, {id}),
                --[[ :: ]]{
                  rv,
                  params
                }
              });
  end else do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ctype.ml",
            375,
            6
          }
        };
  end end  end 
end end

function hide_private_methods(ty) do
  match = repr(ty).desc;
  if (typeof match == "number") then do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ctype.ml",
            397,
            6
          }
        };
  end else if (match.tag == --[[ Tobject ]]4) then do
    match[1].contents = undefined;
    match$1 = flatten_fields(match[0]);
    return List.iter((function (param) do
                  match = field_kind_repr(param[1]);
                  if (typeof match == "number") then do
                    return --[[ () ]]0;
                  end else do
                    return set_kind(match[0], --[[ Fabsent ]]1);
                  end end 
                end end), match$1[0]);
  end else do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ctype.ml",
            397,
            6
          }
        };
  end end  end 
end end

function signature_of_class_type(_param) do
  while(true) do
    param = _param;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ = 1--[[ Cty_signature ]] then do
          return param[0];end end end 
       if ___conditional___ = 0--[[ Cty_constr ]]
       or ___conditional___ = 2--[[ Cty_arrow ]] then do
          _param = param[2];
          continue ;end end end 
       do
      
    end
  end;
end end

function class_type_arity(_param) do
  while(true) do
    param = _param;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ = 0--[[ Cty_constr ]] then do
          _param = param[2];
          continue ;end end end 
       if ___conditional___ = 1--[[ Cty_signature ]] then do
          return 0;end end end 
       if ___conditional___ = 2--[[ Cty_arrow ]] then do
          return 1 + class_type_arity(param[2]) | 0;end end end 
       do
      
    end
  end;
end end

function sort_row_fields(param) do
  return List.sort((function (param, param$1) do
                return Caml_primitive.caml_string_compare(param[0], param$1[0]);
              end end), param);
end end

function merge_row_fields(fi1, fi2) do
  exit = 0;
  if (fi1 and fi2 and (fi1[1] or List.mem_assoc(fi1[0][0], fi2))) then do
    exit = 2;
  end else do
    return --[[ tuple ]]{
            fi1,
            fi2,
            --[[ [] ]]0
          };
  end end 
  if (exit == 2 and not fi2[1] and not List.mem_assoc(fi2[0][0], fi1)) then do
    return --[[ tuple ]]{
            fi1,
            fi2,
            --[[ [] ]]0
          };
  end
   end 
  _r1 = --[[ [] ]]0;
  _r2 = --[[ [] ]]0;
  _pairs = --[[ [] ]]0;
  _fi1 = sort_row_fields(fi1);
  _fi2 = sort_row_fields(fi2);
  while(true) do
    fi2$1 = _fi2;
    fi1$1 = _fi1;
    pairs = _pairs;
    r2 = _r2;
    r1 = _r1;
    if (fi1$1) then do
      if (fi2$1) then do
        fi2$prime = fi2$1[1];
        p2 = fi2$1[0];
        l2 = p2[0];
        fi1$prime = fi1$1[1];
        p1 = fi1$1[0];
        l1 = p1[0];
        if (Caml_obj.caml_equal(l1, l2)) then do
          _fi2 = fi2$prime;
          _fi1 = fi1$prime;
          _pairs = --[[ :: ]]{
            --[[ tuple ]]{
              l1,
              p1[1],
              p2[1]
            },
            pairs
          };
          continue ;
        end else if (Caml_obj.caml_lessthan(l1, l2)) then do
          _fi1 = fi1$prime;
          _r1 = --[[ :: ]]{
            p1,
            r1
          };
          continue ;
        end else do
          _fi2 = fi2$prime;
          _r2 = --[[ :: ]]{
            p2,
            r2
          };
          continue ;
        end end  end 
      end else do
        return --[[ tuple ]]{
                List.rev_append(r1, fi1$1),
                List.rev(r2),
                pairs
              };
      end end 
    end else do
      return --[[ tuple ]]{
              List.rev(r1),
              List.rev_append(r2, fi2$1),
              pairs
            };
    end end 
  end;
end end

function filter_row_fields(erase, param) do
  if (param) then do
    p = param[0];
    fi = filter_row_fields(erase, param[1]);
    match = row_field_repr_aux(--[[ [] ]]0, p[1]);
    if (typeof match == "number") then do
      return fi;
    end else if (match.tag and not (match[2] or not erase)) then do
      set_row_field(match[3], --[[ Rabsent ]]0);
      return fi;
    end else do
      return --[[ :: ]]{
              p,
              fi
            };
    end end  end 
  end else do
    return --[[ [] ]]0;
  end end 
end end

Non_closed0 = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Non_closed0");

function closed_schema_rec(_ty) do
  while(true) do
    ty = _ty;
    ty$1 = repr(ty);
    if (ty$1.level >= 0) then do
      level = ty$1.level;
      ty$1.level = pivot_level - level | 0;
      match = ty$1.desc;
      if (typeof match == "number") then do
        return iter_type_expr(closed_schema_rec, ty$1);
      end else do
        local ___conditional___=(match.tag | 0);
        do
           if ___conditional___ = 0--[[ Tvar ]] then do
              if (level ~= 100000000) then do
                throw Non_closed0;
              end
               end 
              return iter_type_expr(closed_schema_rec, ty$1);end end end 
           if ___conditional___ = 5--[[ Tfield ]] then do
              if (field_kind_repr(match[1]) == --[[ Fpresent ]]0) then do
                closed_schema_rec(match[2]);
              end
               end 
              _ty = match[3];
              continue ;end end end 
           if ___conditional___ = 8--[[ Tvariant ]] then do
              row = row_repr_aux(--[[ [] ]]0, match[0]);
              iter_row(closed_schema_rec, row);
              if (static_row(row)) then do
                return 0;
              end else do
                _ty = row.row_more;
                continue ;
              end end end end end 
           do
          else do
            return iter_type_expr(closed_schema_rec, ty$1);
            end end
            
        end
      end end 
    end else do
      return 0;
    end end 
  end;
end end

function closed_schema(ty) do
  try do
    closed_schema_rec(ty);
    unmark_type(ty);
    return true;
  end
  catch (exn)do
    if (exn == Non_closed0) then do
      unmark_type(ty);
      return false;
    end else do
      throw exn;
    end end 
  end
end end

Non_closed = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Non_closed");

free_variables = do
  contents: --[[ [] ]]0
end;

really_closed = do
  contents: undefined
end;

function free_vars_rec(_real, _ty) do
  while(true) do
    ty = _ty;
    real = _real;
    ty$1 = repr(ty);
    if (ty$1.level >= 0) then do
      ty$1.level = pivot_level - ty$1.level | 0;
      match = ty$1.desc;
      match$1 = really_closed.contents;
      if (typeof match == "number") then do
        return iter_type_expr((function (param) do
                      return free_vars_rec(true, param);
                    end end), ty$1);
      end else do
        local ___conditional___=(match.tag | 0);
        do
           if ___conditional___ = 0--[[ Tvar ]] then do
              free_variables.contents = --[[ :: ]]{
                --[[ tuple ]]{
                  ty$1,
                  real
                },
                free_variables.contents
              };
              return --[[ () ]]0;end end end 
           if ___conditional___ = 3--[[ Tconstr ]] then do
              if (match$1 ~= undefined) then do
                try do
                  match$2 = find_type_expansion(match[0], Caml_option.valFromOption(match$1));
                  if (repr(match$2[1]).level ~= 100000000) then do
                    free_variables.contents = --[[ :: ]]{
                      --[[ tuple ]]{
                        ty$1,
                        real
                      },
                      free_variables.contents
                    };
                  end
                   end 
                end
                catch (exn)do
                  if (exn ~= Caml_builtin_exceptions.not_found) then do
                    throw exn;
                  end
                   end 
                end
                return List.iter((function (param) do
                              return free_vars_rec(true, param);
                            end end), match[1]);
              end else do
                return iter_type_expr((function (param) do
                              return free_vars_rec(true, param);
                            end end), ty$1);
              end end end end end 
           if ___conditional___ = 4--[[ Tobject ]] then do
              _ty = match[0];
              _real = false;
              continue ;end end end 
           if ___conditional___ = 5--[[ Tfield ]] then do
              free_vars_rec(true, match[2]);
              _ty = match[3];
              _real = false;
              continue ;end end end 
           if ___conditional___ = 8--[[ Tvariant ]] then do
              row = row_repr_aux(--[[ [] ]]0, match[0]);
              iter_row((function (param) do
                      return free_vars_rec(true, param);
                    end end), row);
              if (static_row(row)) then do
                return 0;
              end else do
                _ty = row.row_more;
                _real = false;
                continue ;
              end end end end end 
           do
          else do
            return iter_type_expr((function (param) do
                          return free_vars_rec(true, param);
                        end end), ty$1);
            end end
            
        end
      end end 
    end else do
      return 0;
    end end 
  end;
end end

function free_vars$1(env, ty) do
  free_variables.contents = --[[ [] ]]0;
  really_closed.contents = env;
  free_vars_rec(true, ty);
  res = free_variables.contents;
  free_variables.contents = --[[ [] ]]0;
  really_closed.contents = undefined;
  return res;
end end

function free_variables$1(env, ty) do
  tl = List.map((function (prim) do
          return prim[0];
        end end), free_vars$1(env, ty));
  unmark_type(ty);
  return tl;
end end

function closed_type(ty) do
  match = free_vars$1(undefined, ty);
  if (match) then do
    match$1 = match[0];
    throw {
          Non_closed,
          match$1[0],
          match$1[1]
        };
  end else do
    return --[[ () ]]0;
  end end 
end end

function closed_parameterized_type(params, ty) do
  List.iter(mark_type, params);
  ok;
  try do
    closed_type(ty);
    ok = true;
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Non_closed) then do
      ok = false;
    end else do
      throw exn;
    end end 
  end
  List.iter(unmark_type, params);
  unmark_type(ty);
  return ok;
end end

function closed_type_decl(decl) do
  try do
    List.iter(mark_type, decl.type_params);
    match = decl.type_kind;
    if (typeof match == "number") then do
      match == --[[ Type_abstract ]]0;
    end else if (match.tag) then do
      List.iter((function (param) do
              if (param.cd_res ~= undefined) then do
                return --[[ () ]]0;
              end else do
                return List.iter(closed_type, param.cd_args);
              end end 
            end end), match[0]);
    end else do
      List.iter((function (l) do
              return closed_type(l.ld_type);
            end end), match[0]);
    end end  end 
    match$1 = decl.type_manifest;
    if (match$1 ~= undefined) then do
      closed_type(match$1);
    end
     end 
    it_type_declaration(unmark_iterators, decl);
    return ;
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Non_closed) then do
      it_type_declaration(unmark_iterators, decl);
      return exn[1];
    end else do
      throw exn;
    end end 
  end
end end

function closed_extension_constructor(ext) do
  try do
    List.iter(mark_type, ext.ext_type_params);
    match = ext.ext_ret_type;
    if (match == undefined) then do
      List.iter(closed_type, ext.ext_args);
    end
     end 
    unmark_extension_constructor(ext);
    return ;
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Non_closed) then do
      unmark_extension_constructor(ext);
      return exn[1];
    end else do
      throw exn;
    end end 
  end
end end

CCFailure = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.CCFailure");

function closed_class(params, sign) do
  ty = object_fields(repr(sign.csig_self));
  match = flatten_fields(ty);
  fields = match[0];
  List.iter(mark_type, params);
  mark_type(match[1]);
  List.iter((function (param) do
          if (param[0] == dummy_method) then do
            return mark_type(param[2]);
          end else do
            return 0;
          end end 
        end end), fields);
  try do
    mark_type_node(repr(sign.csig_self));
    List.iter((function (param) do
            ty = param[2];
            if (field_kind_repr(param[1]) == --[[ Fpresent ]]0) then do
              try do
                return closed_type(ty);
              end
              catch (raw_exn)do
                exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                if (exn[0] == Non_closed) then do
                  throw {
                        CCFailure,
                        --[[ CC_Method ]]Block.__(0, {
                            exn[1],
                            exn[2],
                            param[0],
                            ty
                          })
                      };
                end
                 end 
                throw exn;
              end
            end else do
              return 0;
            end end 
          end end), fields);
    iter_type_expr(mark_type, repr(sign.csig_self));
    List.iter(unmark_type, params);
    unmark_class_signature(sign);
    return ;
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == CCFailure) then do
      iter_type_expr(mark_type, repr(sign.csig_self));
      List.iter(unmark_type, params);
      unmark_class_signature(sign);
      return exn[1];
    end else do
      throw exn;
    end end 
  end
end end

function iter_generalize(tyl, ty) do
  ty$1 = repr(ty);
  if (ty$1.level > current_level.contents and ty$1.level ~= 100000000) then do
    set_level(ty$1, 100000000);
    match = ty$1.desc;
    if (typeof match ~= "number" and match.tag == --[[ Tconstr ]]3) then do
      iter_abbrev((function (param) do
              return iter_generalize(tyl, param);
            end end), match[2].contents);
    end
     end 
    return iter_type_expr((function (param) do
                  return iter_generalize(tyl, param);
                end end), ty$1);
  end else do
    tyl.contents = --[[ :: ]]{
      ty$1,
      tyl.contents
    };
    return --[[ () ]]0;
  end end 
end end

function iter_generalize$1(tyl, ty) do
  simple_abbrevs.contents = --[[ Mnil ]]0;
  return iter_generalize(tyl, ty);
end end

function generalize(ty) do
  return iter_generalize$1(do
              contents: --[[ [] ]]0
            end, ty);
end end

function generalize_structure(var_level, ty) do
  ty$1 = repr(ty);
  if (ty$1.level ~= 100000000) then do
    if (is_Tvar(ty$1) and ty$1.level > var_level) then do
      return set_level(ty$1, var_level);
    end else do
      tmp = false;
      if (ty$1.level > current_level.contents) then do
        match = ty$1.desc;
        tmp$1;
        tmp$1 = typeof match == "number" or match.tag ~= --[[ Tconstr ]]3 and true or not is_object_type(match[0]) and (match[2].contents = --[[ Mnil ]]0, true);
        tmp = tmp$1;
      end
       end 
      if (tmp) then do
        set_level(ty$1, 100000000);
        return iter_type_expr((function (param) do
                      return generalize_structure(var_level, param);
                    end end), ty$1);
      end else do
        return 0;
      end end 
    end end 
  end else do
    return 0;
  end end 
end end

function generalize_structure$1(var_level, ty) do
  simple_abbrevs.contents = --[[ Mnil ]]0;
  return generalize_structure(var_level, ty);
end end

function generalize_spine(_ty) do
  while(true) do
    ty = _ty;
    ty$1 = repr(ty);
    if (ty$1.level < current_level.contents or ty$1.level == 100000000) then do
      return --[[ () ]]0;
    end else do
      match = ty$1.desc;
      if (typeof match == "number") then do
        return --[[ () ]]0;
      end else do
        local ___conditional___=(match.tag | 0);
        do
           if ___conditional___ = 1--[[ Tarrow ]] then do
              set_level(ty$1, 100000000);
              generalize_spine(match[1]);
              _ty = match[2];
              continue ;end end end 
           if ___conditional___ = 2--[[ Ttuple ]] then do
              set_level(ty$1, 100000000);
              return List.iter(generalize_spine, match[0]);end end end 
           if ___conditional___ = 3--[[ Tconstr ]] then do
              if (is_object_type(match[0])) then do
                return --[[ () ]]0;
              end else do
                set_level(ty$1, 100000000);
                match[2].contents = --[[ Mnil ]]0;
                return List.iter(generalize_spine, match[1]);
              end end end end end 
           if ___conditional___ = 10--[[ Tpoly ]] then do
              set_level(ty$1, 100000000);
              _ty = match[0];
              continue ;end end end 
           if ___conditional___ = 11--[[ Tpackage ]] then do
              set_level(ty$1, 100000000);
              return List.iter(generalize_spine, match[2]);end end end 
           do
          else do
            return --[[ () ]]0;
            end end
            
        end
      end end 
    end end 
  end;
end end

forward_try_expand_once = do
  contents: (function (env, ty) do
      throw Cannot_expand;
    end end)
end;

function get_level(env, p) do
  try do
    match = find_type_full(p, env)[0].type_newtype_level;
    if (match ~= undefined) then do
      return match[0];
    end else do
      return binding_time(p);
    end end 
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return binding_time(p);
    end else do
      throw exn;
    end end 
  end
end end

function normalize_package_path(env, _p) do
  while(true) do
    p = _p;
    t;
    try do
      t = find_modtype(p, env).mtd_type;
    end
    catch (exn)do
      if (exn == Caml_builtin_exceptions.not_found) then do
        t = undefined;
      end else do
        throw exn;
      end end 
    end
    if (t ~= undefined) then do
      match = t;
      if (match.tag) then do
        return p;
      end else do
        _p = match[0];
        continue ;
      end end 
    end else do
      return p;
    end end 
  end;
end end

function update_level(env, level, _ty) do
  while(true) do
    ty = _ty;
    ty$1 = repr(ty);
    if (ty$1.level > level) then do
      match = gadt_instance_level(env, ty$1);
      if (match ~= undefined and level < match) then do
        throw {
              Unify,
              --[[ :: ]]{
                --[[ tuple ]]{
                  ty$1,
                  newty2(level, --[[ Tvar ]]Block.__(0, {undefined}))
                },
                --[[ [] ]]0
              }
            };
      end
       end 
      match$1 = ty$1.desc;
      if (typeof match$1 ~= "number") then do
        local ___conditional___=(match$1.tag | 0);
        do
           if ___conditional___ = 3--[[ Tconstr ]] then do
              p = match$1[0];
              if (level < get_level(env, p)) then do
                try do
                  link_type(ty$1, Curry._2(forward_try_expand_once.contents, env, ty$1));
                  return update_level(env, level, ty$1);
                end
                catch (exn)do
                  if (exn == Cannot_expand) then do
                    if (level < get_level(env, p)) then do
                      throw {
                            Unify,
                            --[[ :: ]]{
                              --[[ tuple ]]{
                                ty$1,
                                newty2(level, --[[ Tvar ]]Block.__(0, {undefined}))
                              },
                              --[[ [] ]]0
                            }
                          };
                    end
                     end 
                    return iter_type_expr((function (param) do
                                  return update_level(env, level, param);
                                end end), ty$1);
                  end else do
                    throw exn;
                  end end 
                end
              end
               end end else 
           if ___conditional___ = 4--[[ Tobject ]] then do
              nm = match$1[1];
              match$2 = nm.contents;
              if (match$2 ~= undefined and level < get_level(env, match$2[0])) then do
                set_name(nm, undefined);
                _ty = ty$1;
                continue ;
              end
               end end else 
           if ___conditional___ = 5--[[ Tfield ]] then do
              ty1 = match$1[2];
              if (match$1[0] == dummy_method and repr(ty1).level > level) then do
                throw {
                      Unify,
                      --[[ :: ]]{
                        --[[ tuple ]]{
                          ty1,
                          newty2(level, --[[ Tvar ]]Block.__(0, {undefined}))
                        },
                        --[[ [] ]]0
                      }
                    };
              end
               end end else 
           if ___conditional___ = 8--[[ Tvariant ]] then do
              row = row_repr_aux(--[[ [] ]]0, match$1[0]);
              match$3 = row.row_name;
              if (match$3 ~= undefined) then do
                if (level < get_level(env, match$3[0])) then do
                  log_type(ty$1);
                  ty$1.desc = --[[ Tvariant ]]Block.__(8, {do
                        row_fields: row.row_fields,
                        row_more: row.row_more,
                        row_bound: row.row_bound,
                        row_closed: row.row_closed,
                        row_fixed: row.row_fixed,
                        row_name: undefined
                      end});
                end
                 end 
              end
               end 
              set_level(ty$1, level);
              return iter_type_expr((function (param) do
                            return update_level(env, level, param);
                          end end), ty$1);end end end 
           if ___conditional___ = 11--[[ Tpackage ]] then do
              p$1 = match$1[0];
              if (level < get_level(env, p$1)) then do
                p$prime = normalize_package_path(env, p$1);
                if (same(p$1, p$prime)) then do
                  throw {
                        Unify,
                        --[[ :: ]]{
                          --[[ tuple ]]{
                            ty$1,
                            newty2(level, --[[ Tvar ]]Block.__(0, {undefined}))
                          },
                          --[[ [] ]]0
                        }
                      };
                end
                 end 
                log_type(ty$1);
                ty$1.desc = --[[ Tpackage ]]Block.__(11, {
                    p$prime,
                    match$1[1],
                    match$1[2]
                  });
                _ty = ty$1;
                continue ;
              end
               end end else 
           do end end end end
          else do
            end end
            
        end
      end
       end 
      set_level(ty$1, level);
      return iter_type_expr((function (param) do
                    return update_level(env, level, param);
                  end end), ty$1);
    end else do
      return 0;
    end end 
  end;
end end

function generalize_contravariant(env) do
  if (principal.contents) then do
    return generalize_structure$1;
  end else do
    return (function (param, param$1) do
        return update_level(env, param, param$1);
      end end);
  end end 
end end

function generalize_expansive(env, var_level, _ty) do
  while(true) do
    ty = _ty;
    ty$1 = repr(ty);
    if (ty$1.level ~= 100000000 and ty$1.level > var_level) then do
      set_level(ty$1, 100000000);
      match = ty$1.desc;
      if (typeof match == "number") then do
        return iter_type_expr((function (param) do
                      return generalize_expansive(env, var_level, param);
                    end end), ty$1);
      end else do
        local ___conditional___=(match.tag | 0);
        do
           if ___conditional___ = 1--[[ Tarrow ]] then do
              generalize_contravariant(env)(var_level, match[1]);
              _ty = match[2];
              continue ;end end end 
           if ___conditional___ = 3--[[ Tconstr ]] then do
              tyl = match[1];
              variance;
              try do
                variance = find_type_full(match[0], env)[0].type_variance;
              end
              catch (exn)do
                if (exn == Caml_builtin_exceptions.not_found) then do
                  variance = List.map((function (param) do
                          return Types_Variance.may_inv;
                        end end), tyl);
                end else do
                  throw exn;
                end end 
              end
              match[2].contents = --[[ Mnil ]]0;
              return List.iter2((function (v, t) do
                            if (Curry._2(Types_Variance.mem, --[[ May_weak ]]2, v)) then do
                              return generalize_contravariant(env)(var_level, t);
                            end else do
                              return generalize_expansive(env, var_level, t);
                            end end 
                          end end), variance, tyl);end end end 
           if ___conditional___ = 11--[[ Tpackage ]] then do
              partial_arg = generalize_contravariant(env);
              return List.iter((function(partial_arg)do
                        return function (param) do
                          return partial_arg(var_level, param);
                        end end
                        end(partial_arg)), match[2]);end end end 
           do
          else do
            return iter_type_expr((function (param) do
                          return generalize_expansive(env, var_level, param);
                        end end), ty$1);
            end end
            
        end
      end end 
    end else do
      return 0;
    end end 
  end;
end end

function generalize_expansive$1(env, ty) do
  simple_abbrevs.contents = --[[ Mnil ]]0;
  try do
    return generalize_expansive(env, nongen_level.contents, ty);
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      tr = exn[1];
      if (tr) then do
        if (tr[1]) then do
          throw exn;
        end
         end 
        throw {
              Unify,
              --[[ :: ]]{
                --[[ tuple ]]{
                  ty,
                  tr[0][1]
                },
                tr
              }
            };
      end else do
        throw exn;
      end end 
    end else do
      throw exn;
    end end 
  end
end end

function generalize_structure$2(ty) do
  return generalize_structure$1(current_level.contents, ty);
end end

function limited_generalize(ty0, ty) do
  ty0$1 = repr(ty0);
  graph = Hashtbl.create(undefined, 17);
  idx = do
    contents: 0
  end;
  roots = do
    contents: --[[ [] ]]0
  end;
  inverse = function (pty, ty) do
    ty$1 = repr(ty);
    if (ty$1.level > current_level.contents or ty$1.level == 100000000) then do
      idx.contents = idx.contents - 1 | 0;
      Hashtbl.add(graph, idx.contents, --[[ tuple ]]{
            ty$1,
            do
              contents: pty
            end
          });
      if (ty$1.level == 100000000 or ty$1 == ty0$1) then do
        roots.contents = --[[ :: ]]{
          ty$1,
          roots.contents
        };
      end
       end 
      set_level(ty$1, idx.contents);
      partial_arg = --[[ :: ]]{
        ty$1,
        --[[ [] ]]0
      };
      return iter_type_expr((function (param) do
                    return inverse(partial_arg, param);
                  end end), ty$1);
    end else if (ty$1.level < 0) then do
      match = Hashtbl.find(graph, ty$1.level);
      parents = match[1];
      parents.contents = Pervasives.$at(pty, parents.contents);
      return --[[ () ]]0;
    end else do
      return 0;
    end end  end 
  end end;
  generalize_parents = function (ty) do
    idx = ty.level;
    if (idx ~= 100000000) then do
      set_level(ty, 100000000);
      List.iter(generalize_parents, Hashtbl.find(graph, idx)[1].contents);
      match = ty.desc;
      if (typeof match == "number" or match.tag ~= --[[ Tvariant ]]8) then do
        return --[[ () ]]0;
      end else do
        more = row_more(match[0]);
        lv = more.level;
        if ((lv < 0 or lv > current_level.contents) and lv ~= 100000000) then do
          return set_level(more, 100000000);
        end else do
          return 0;
        end end 
      end end 
    end else do
      return 0;
    end end 
  end end;
  inverse(--[[ [] ]]0, ty);
  if (ty0$1.level < 0) then do
    iter_type_expr((function (param) do
            return inverse(--[[ [] ]]0, param);
          end end), ty0$1);
  end
   end 
  List.iter(generalize_parents, roots.contents);
  return Hashtbl.iter((function (param, param$1) do
                ty = param$1[0];
                if (ty.level ~= 100000000) then do
                  return set_level(ty, current_level.contents);
                end else do
                  return 0;
                end end 
              end end), graph);
end end

function inv_type(hash, pty, ty) do
  ty$1 = repr(ty);
  try do
    inv = Curry._2(TypeHash.find, hash, ty$1);
    inv.inv_parents = Pervasives.$at(pty, inv.inv_parents);
    return --[[ () ]]0;
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      inv$1 = do
        inv_type: ty$1,
        inv_parents: pty
      end;
      Curry._3(TypeHash.add, hash, ty$1, inv$1);
      partial_arg = --[[ :: ]]{
        inv$1,
        --[[ [] ]]0
      };
      return iter_type_expr((function (param) do
                    return inv_type(hash, partial_arg, param);
                  end end), ty$1);
    end else do
      throw exn;
    end end 
  end
end end

function compute_univars(ty) do
  inverted = Curry._1(TypeHash.create, 17);
  inv_type(inverted, --[[ [] ]]0, ty);
  node_univars = Curry._1(TypeHash.create, 17);
  add_univar = function (univ, inv) do
    match = inv.inv_type.desc;
    if (typeof match ~= "number" and match.tag == --[[ Tpoly ]]10 and List.memq(univ, List.map(repr, match[1]))) then do
      return --[[ () ]]0;
    end
     end 
    try do
      univs = Curry._2(TypeHash.find, node_univars, inv.inv_type);
      if (mem$3(univ, univs.contents)) then do
        return 0;
      end else do
        univs.contents = add$3(univ, univs.contents);
        return List.iter((function (param) do
                      return add_univar(univ, param);
                    end end), inv.inv_parents);
      end end 
    end
    catch (exn)do
      if (exn == Caml_builtin_exceptions.not_found) then do
        Curry._3(TypeHash.add, node_univars, inv.inv_type, do
              contents: singleton$1(univ)
            end);
        return List.iter((function (param) do
                      return add_univar(univ, param);
                    end end), inv.inv_parents);
      end else do
        throw exn;
      end end 
    end
  end end;
  Curry._2(TypeHash.iter, (function (ty, inv) do
          if (is_Tunivar(ty)) then do
            return add_univar(ty, inv);
          end else do
            return 0;
          end end 
        end end), inverted);
  return (function (ty) do
      try do
        return Curry._2(TypeHash.find, node_univars, ty).contents;
      end
      catch (exn)do
        if (exn == Caml_builtin_exceptions.not_found) then do
          return --[[ Empty ]]0;
        end else do
          throw exn;
        end end 
      end
    end end);
end end

function find_repr(p1, _param) do
  while(true) do
    param = _param;
    if (typeof param == "number") then do
      return ;
    end else if (param.tag) then do
      rem = param[0].contents;
      _param = rem;
      continue ;
    end else if (param[0]) then do
      if (same(p1, param[1])) then do
        return param[2];
      end else do
        _param = param[4];
        continue ;
      end end 
    end else do
      _param = param[4];
      continue ;
    end end  end  end 
  end;
end end

abbreviations = do
  contents: do
    contents: --[[ Mnil ]]0
  end
end;

function copy(env, partial, keep_names, ty) do
  copy$1 = function (param) do
    return copy(env, partial, keep_names, param);
  end end;
  ty$1 = repr(ty);
  match = ty$1.desc;
  exit = 0;
  if (typeof match == "number" or match.tag ~= --[[ Tsubst ]]7) then do
    exit = 1;
  end else do
    return match[0];
  end end 
  if (exit == 1) then do
    if (ty$1.level ~= 100000000 and partial == undefined) then do
      return ty$1;
    end else do
      forget;
      if (ty$1.level == 100000000) then do
        forget = 100000000;
      end else if (partial ~= undefined) then do
        match$1 = partial;
        param = Curry._1(match$1[0], ty$1);
        forget = (
          param and false or true
        ) and (
            match$1[1] and ty$1.level or current_level.contents
          ) or 100000000;
      end else do
        throw {
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "ctype.ml",
                984,
                16
              }
            };
      end end  end 
      if (forget ~= 100000000) then do
        return newty2(forget, --[[ Tvar ]]Block.__(0, {undefined}));
      end else do
        desc = ty$1.desc;
        save_desc(ty$1, desc);
        t = newvar(undefined, --[[ () ]]0);
        if (env ~= undefined) then do
          env$1 = Caml_option.valFromOption(env);
          if (env$1.local_constraints) then do
            match$2 = gadt_instance_level(env$1, ty$1);
            if (match$2 ~= undefined) then do
              add_gadt_instances(env$1, match$2, --[[ :: ]]{
                    t,
                    --[[ [] ]]0
                  });
            end
             end 
          end
           end 
        end
         end 
        ty$1.desc = --[[ Tsubst ]]Block.__(7, {t});
        tmp;
        if (typeof desc == "number") then do
          tmp = copy_type_desc(keep_names, copy$1, desc);
        end else do
          local ___conditional___=(desc.tag | 0);
          do
             if ___conditional___ = 3--[[ Tconstr ]] then do
                tl = desc[1];
                p = desc[0];
                abbrevs = proper_abbrevs(p, tl, abbreviations.contents);
                match$3 = find_repr(p, abbrevs.contents);
                exit$1 = 0;
                if (match$3 ~= undefined) then do
                  ty$2 = match$3;
                  if (repr(ty$2) ~= t) then do
                    tmp = --[[ Tlink ]]Block.__(6, {ty$2});
                  end else do
                    exit$1 = 2;
                  end end 
                end else do
                  exit$1 = 2;
                end end 
                if (exit$1 == 2) then do
                  abbrev = abbreviations.contents.contents;
                  tmp$1;
                  tmp$1 = typeof abbrev == "number" or abbrev.tag and abbrev or --[[ Mlink ]]Block.__(1, {abbreviations.contents});
                  tmp = --[[ Tconstr ]]Block.__(3, {
                      p,
                      List.map(copy$1, tl),
                      do
                        contents: tmp$1
                      end
                    });
                end
                 end end else 
             if ___conditional___ = 4--[[ Tobject ]] then do
                tmp = partial ~= undefined and --[[ Tobject ]]Block.__(4, {
                      copy$1(desc[0]),
                      do
                        contents: undefined
                      end
                    }) or copy_type_desc(keep_names, copy$1, desc);end else 
             if ___conditional___ = 5--[[ Tfield ]] then do
                match$4 = field_kind_repr(desc[1]);
                if (typeof match$4 == "number") then do
                  tmp = match$4 ~= 0 and --[[ Tlink ]]Block.__(6, {copy$1(desc[3])}) or copy_type_desc(undefined, copy$1, desc);
                end else do
                  dup_kind(match$4[0]);
                  tmp = copy_type_desc(undefined, copy$1, desc);
                end end end else 
             if ___conditional___ = 8--[[ Tvariant ]] then do
                row = row_repr_aux(--[[ [] ]]0, desc[0]);
                more = repr(row.row_more);
                match$5 = more.desc;
                exit$2 = 0;
                if (typeof match$5 == "number" or match$5.tag ~= --[[ Tsubst ]]7) then do
                  exit$2 = 2;
                end else do
                  match$6 = match$5[0].desc;
                  if (typeof match$6 == "number" or match$6.tag ~= --[[ Ttuple ]]2) then do
                    exit$2 = 2;
                  end else do
                    match$7 = match$6[0];
                    if (match$7) then do
                      match$8 = match$7[1];
                      if (match$8 and not match$8[1]) then do
                        ty2 = match$8[0];
                        ty$1.desc = --[[ Tsubst ]]Block.__(7, {ty2});
                        tmp = --[[ Tlink ]]Block.__(6, {ty2});
                      end else do
                        exit$2 = 2;
                      end end 
                    end else do
                      exit$2 = 2;
                    end end 
                  end end 
                end end 
                if (exit$2 == 2) then do
                  keep = more.level ~= 100000000;
                  match$9 = more.desc;
                  more$prime;
                  exit$3 = 0;
                  if (typeof match$9 == "number") then do
                    exit$3 = 3;
                  end else do
                    local ___conditional___=(match$9.tag | 0);
                    do
                       if ___conditional___ = 3--[[ Tconstr ]] then do
                          exit$3 = 3;end else 
                       if ___conditional___ = 7--[[ Tsubst ]] then do
                          more$prime = match$9[0];end else 
                       if ___conditional___ = 0--[[ Tvar ]]
                       or ___conditional___ = 9--[[ Tunivar ]] then do
                          exit$3 = 4;end else 
                       do end end end end
                      else do
                        throw {
                              Caml_builtin_exceptions.assert_failure,
                              --[[ tuple ]]{
                                "ctype.ml",
                                1047,
                                24
                              }
                            };
                        end end
                        
                    end
                  end end 
                  local ___conditional___=(exit$3);
                  do
                     if ___conditional___ = 3 then do
                        if (keep) then do
                          save_desc(more, more.desc);
                        end
                         end 
                        more$prime = copy$1(more);end else 
                     if ___conditional___ = 4 then do
                        save_desc(more, more.desc);
                        more$prime = keep and more or newty2(current_level.contents, more.desc);end else 
                     do end end end
                    
                  end
                  match$10 = repr(more$prime);
                  match$11 = match$10.desc;
                  row$1;
                  row$1 = typeof match$11 == "number" or not (match$11.tag == --[[ Tconstr ]]3 and not row.row_fixed) and row or (do
                        row_fields: row.row_fields,
                        row_more: row.row_more,
                        row_bound: row.row_bound,
                        row_closed: row.row_closed,
                        row_fixed: true,
                        row_name: row.row_name
                      end);
                  match$12;
                  if (partial ~= undefined) then do
                    match$13 = partial;
                    if (match$13[1]) then do
                      match$12 = --[[ tuple ]]{
                        more$prime,
                        row$1
                      };
                    end else do
                      more$prime$1;
                      if (more.id ~= more$prime.id) then do
                        more$prime$1 = more$prime;
                      end else do
                        lv = keep and more.level or current_level.contents;
                        more$prime$1 = newty2(lv, --[[ Tvar ]]Block.__(0, {undefined}));
                      end end 
                      not_reither = function (param) do
                        match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                        if (typeof match == "number" or not match.tag) then do
                          return true;
                        end else do
                          return false;
                        end end 
                      end end;
                      tmp$2 = false;
                      if (row$1.row_closed) then do
                        tmp$3 = false;
                        if (not row$1.row_fixed) then do
                          param$1 = Curry._1(match$13[0], ty$1);
                          tmp$3 = (
                            param$1 and false or true
                          ) and not List.for_all(not_reither, row$1.row_fields);
                        end
                         end 
                        tmp$2 = tmp$3;
                      end
                       end 
                      match$12 = tmp$2 and --[[ tuple ]]{
                          more$prime$1,
                          do
                            row_fields: List.filter(not_reither)(row$1.row_fields),
                            row_more: more$prime$1,
                            row_bound: --[[ () ]]0,
                            row_closed: false,
                            row_fixed: false,
                            row_name: undefined
                          end
                        } or --[[ tuple ]]{
                          more$prime$1,
                          row$1
                        };
                    end end 
                  end else do
                    match$12 = --[[ tuple ]]{
                      more$prime,
                      row$1
                    };
                  end end 
                  more$prime$2 = match$12[0];
                  more.desc = --[[ Tsubst ]]Block.__(7, {newty2(100000000, --[[ Ttuple ]]Block.__(2, {--[[ :: ]]{
                                more$prime$2,
                                --[[ :: ]]{
                                  t,
                                  --[[ [] ]]0
                                }
                              }}))});
                  tmp = --[[ Tvariant ]]Block.__(8, {copy_row(copy$1, true, match$12[1], keep, more$prime$2)});
                end
                 end end else 
             do end end end end end
            else do
              tmp = copy_type_desc(keep_names, copy$1, desc);
              end end
              
          end
        end end 
        t.desc = tmp;
        return t;
      end end 
    end end 
  end
   end 
end end

function simple_copy(t) do
  return copy(undefined, undefined, undefined, t);
end end

function gadt_env(env) do
  if (env.local_constraints) then do
    return Caml_option.some(env);
  end
   end 
end end

function instance(partial, env, sch) do
  env$1 = gadt_env(env);
  partial$1 = partial ~= undefined and --[[ tuple ]]{
      compute_univars(sch),
      partial
    } or undefined;
  ty = copy(env$1, partial$1, undefined, sch);
  cleanup_types(--[[ () ]]0);
  return ty;
end end

function instance_def(sch) do
  ty = copy(undefined, undefined, undefined, sch);
  cleanup_types(--[[ () ]]0);
  return ty;
end end

function instance_list(env, schl) do
  env$1 = gadt_env(env);
  tyl = List.map((function (t) do
          return copy(env$1, undefined, undefined, t);
        end end), schl);
  cleanup_types(--[[ () ]]0);
  return tyl;
end end

reified_var_counter = do
  contents: --[[ Empty ]]0
end;

function get_new_abstract_name(s) do
  index;
  try do
    index = find(s, reified_var_counter.contents) + 1 | 0;
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      index = 0;
    end else do
      throw exn;
    end end 
  end
  reified_var_counter.contents = add$1(s, index, reified_var_counter.contents);
  return Curry._2(Printf.sprintf(--[[ Format ]]{
                  --[[ String ]]Block.__(2, {
                      --[[ No_padding ]]0,
                      --[[ Char_literal ]]Block.__(12, {
                          --[[ "#" ]]35,
                          --[[ Int ]]Block.__(4, {
                              --[[ Int_d ]]0,
                              --[[ No_padding ]]0,
                              --[[ No_precision ]]0,
                              --[[ End_of_format ]]0
                            })
                        })
                    }),
                  "%s#%d"
                }), s, index);
end end

function new_declaration(newtype, manifest) do
  return do
          type_params: --[[ [] ]]0,
          type_arity: 0,
          type_kind: --[[ Type_abstract ]]0,
          type_private: --[[ Public ]]1,
          type_manifest: manifest,
          type_variance: --[[ [] ]]0,
          type_newtype_level: newtype,
          type_loc: none,
          type_attributes: --[[ [] ]]0
        end;
end end

function instance_constructor(in_pattern, cstr) do
  if (in_pattern ~= undefined) then do
    match = in_pattern;
    newtype_lev = match[1];
    env = match[0];
    __process = function (existential) do
      decl = new_declaration(--[[ tuple ]]{
            newtype_lev,
            newtype_lev
          }, undefined);
      match = repr(existential);
      match$1 = match.desc;
      name;
      if (typeof match$1 == "number" or match$1.tag) then do
        name = "ex";
      end else do
        match$2 = match$1[0];
        name = match$2 ~= undefined and match$2 or "ex";
      end end 
      match$3 = enter_type(get_new_abstract_name(name), decl, env.contents);
      env.contents = match$3[1];
      to_unify = newty2(current_level.contents, --[[ Tconstr ]]Block.__(3, {
              --[[ Pident ]]Block.__(0, {match$3[0]}),
              --[[ [] ]]0,
              do
                contents: --[[ Mnil ]]0
              end
            }));
      tv = copy(undefined, undefined, undefined, existential);
      if (not is_Tvar(tv)) then do
        throw {
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "ctype.ml",
                1170,
                8
              }
            };
      end
       end 
      return link_type(tv, to_unify);
    end end;
    List.iter(__process, cstr.cstr_existentials);
  end
   end 
  ty_res = copy(undefined, undefined, undefined, cstr.cstr_res);
  ty_args = List.map(simple_copy, cstr.cstr_args);
  cleanup_types(--[[ () ]]0);
  return --[[ tuple ]]{
          ty_args,
          ty_res
        };
end end

function instance_parameterized_type(keep_names, sch_args, sch) do
  ty_args = List.map((function (t) do
          return copy(undefined, undefined, keep_names, t);
        end end), sch_args);
  ty = copy(undefined, undefined, undefined, sch);
  cleanup_types(--[[ () ]]0);
  return --[[ tuple ]]{
          ty_args,
          ty
        };
end end

function instance_declaration(decl) do
  match = decl.type_kind;
  tmp;
  tmp = typeof match == "number" and (
      match == --[[ Type_abstract ]]0 and --[[ Type_abstract ]]0 or --[[ Type_open ]]1
    ) or (
      match.tag and --[[ Type_variant ]]Block.__(1, {List.map((function (c) do
                    return do
                            cd_id: c.cd_id,
                            cd_args: List.map(simple_copy, c.cd_args),
                            cd_res: may_map(simple_copy, c.cd_res),
                            cd_loc: c.cd_loc,
                            cd_attributes: c.cd_attributes
                          end;
                  end end), match[0])}) or --[[ Type_record ]]Block.__(0, {
            List.map((function (l) do
                    return do
                            ld_id: l.ld_id,
                            ld_mutable: l.ld_mutable,
                            ld_type: copy(undefined, undefined, undefined, l.ld_type),
                            ld_loc: l.ld_loc,
                            ld_attributes: l.ld_attributes
                          end;
                  end end), match[0]),
            match[1]
          })
    );
  decl_type_params = List.map(simple_copy, decl.type_params);
  decl_type_arity = decl.type_arity;
  decl_type_private = decl.type_private;
  decl_type_manifest = may_map(simple_copy, decl.type_manifest);
  decl_type_variance = decl.type_variance;
  decl_type_newtype_level = decl.type_newtype_level;
  decl_type_loc = decl.type_loc;
  decl_type_attributes = decl.type_attributes;
  decl$1 = do
    type_params: decl_type_params,
    type_arity: decl_type_arity,
    type_kind: tmp,
    type_private: decl_type_private,
    type_manifest: decl_type_manifest,
    type_variance: decl_type_variance,
    type_newtype_level: decl_type_newtype_level,
    type_loc: decl_type_loc,
    type_attributes: decl_type_attributes
  end;
  cleanup_types(--[[ () ]]0);
  return decl$1;
end end

function instance_class(params, cty) do
  copy_class_type = function (param) do
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ = 0--[[ Cty_constr ]] then do
          return --[[ Cty_constr ]]Block.__(0, {
                    param[0],
                    List.map(simple_copy, param[1]),
                    copy_class_type(param[2])
                  });end end end 
       if ___conditional___ = 1--[[ Cty_signature ]] then do
          sign = param[0];
          return --[[ Cty_signature ]]Block.__(1, {do
                      csig_self: copy(undefined, undefined, undefined, sign.csig_self),
                      csig_vars: map((function (param) do
                              return --[[ tuple ]]{
                                      param[0],
                                      param[1],
                                      copy(undefined, undefined, undefined, param[2])
                                    };
                            end end), sign.csig_vars),
                      csig_concr: sign.csig_concr,
                      csig_inher: List.map((function (param) do
                              return --[[ tuple ]]{
                                      param[0],
                                      List.map(simple_copy, param[1])
                                    };
                            end end), sign.csig_inher)
                    end});end end end 
       if ___conditional___ = 2--[[ Cty_arrow ]] then do
          return --[[ Cty_arrow ]]Block.__(2, {
                    param[0],
                    copy(undefined, undefined, undefined, param[1]),
                    copy_class_type(param[2])
                  });end end end 
       do
      
    end
  end end;
  params$prime = List.map(simple_copy, params);
  cty$prime = copy_class_type(cty);
  cleanup_types(--[[ () ]]0);
  return --[[ tuple ]]{
          params$prime,
          cty$prime
        };
end end

function diff_list(l1, l2) do
  if (l1 == l2) then do
    return --[[ [] ]]0;
  end else if (l1) then do
    return --[[ :: ]]{
            l1[0],
            diff_list(l1[1], l2)
          };
  end else do
    throw {
          Caml_builtin_exceptions.invalid_argument,
          "Ctype.diff_list"
        };
  end end  end 
end end

function conflicts(free, bound) do
  bound$1 = List.map(repr, bound);
  return exists((function (t) do
                return List.memq(repr(t), bound$1);
              end end), free);
end end

delayed_copy = do
  contents: --[[ [] ]]0
end;

function copy_sep(fixed, free, bound, visited, ty) do
  ty$1 = repr(ty);
  univars = Curry._1(free, ty$1);
  if (univars and false or true) then do
    if (ty$1.level ~= 100000000) then do
      return ty$1;
    end else do
      t = newvar(undefined, --[[ () ]]0);
      delayed_copy.contents = --[[ :: ]]{
        Caml_obj.caml_lazy_make((function (param) do
                t.desc = --[[ Tlink ]]Block.__(6, {copy(undefined, undefined, undefined, ty$1)});
                return --[[ () ]]0;
              end end)),
        delayed_copy.contents
      };
      return t;
    end end 
  end else do
    try do
      match = List.assq(ty$1, visited);
      dl = is_Tunivar(ty$1) and --[[ [] ]]0 or diff_list(bound, match[1]);
      if (dl ~= --[[ [] ]]0 and conflicts(univars, dl)) then do
        throw Caml_builtin_exceptions.not_found;
      end
       end 
      return match[0];
    end
    catch (exn)do
      if (exn == Caml_builtin_exceptions.not_found) then do
        t$1 = newvar(undefined, --[[ () ]]0);
        match$1 = ty$1.desc;
        visited$1;
        exit = 0;
        if (typeof match$1 == "number") then do
          visited$1 = visited;
        end else do
          local ___conditional___=(match$1.tag | 0);
          do
             if ___conditional___ = 1--[[ Tarrow ]]
             or ___conditional___ = 2--[[ Ttuple ]]
             or ___conditional___ = 3--[[ Tconstr ]]
             or ___conditional___ = 4--[[ Tobject ]]
             or ___conditional___ = 8--[[ Tvariant ]]
             or ___conditional___ = 11--[[ Tpackage ]] then do
                exit = 1;end else 
             do end end
            else do
              visited$1 = visited;
              end end
              
          end
        end end 
        if (exit == 1) then do
          visited$1 = --[[ :: ]]{
            --[[ tuple ]]{
              ty$1,
              --[[ tuple ]]{
                t$1,
                bound
              }
            },
            visited
          };
        end
         end 
        copy_rec = function (param) do
          return copy_sep(fixed, free, bound, visited$1, param);
        end end;
        match$2 = ty$1.desc;
        tmp;
        if (typeof match$2 == "number") then do
          tmp = copy_type_desc(undefined, copy_rec, ty$1.desc);
        end else do
          local ___conditional___=(match$2.tag | 0);
          do
             if ___conditional___ = 8--[[ Tvariant ]] then do
                row = row_repr_aux(--[[ [] ]]0, match$2[0]);
                more = repr(row.row_more);
                keep = is_Tvar(more) and more.level ~= 100000000;
                more$prime = copy_rec(more);
                fixed$prime = fixed and is_Tvar(repr(more$prime));
                row$1 = copy_row(copy_rec, fixed$prime, row, keep, more$prime);
                tmp = --[[ Tvariant ]]Block.__(8, {row$1});end else 
             if ___conditional___ = 10--[[ Tpoly ]] then do
                tl = List.map(repr, match$2[1]);
                tl$prime = List.map((function (t) do
                        return newty2(current_level.contents, t.desc);
                      end end), tl);
                bound$1 = Pervasives.$at(tl, bound);
                visited$2 = Pervasives.$at(List.map2((function (ty, t) do
                            return --[[ tuple ]]{
                                    ty,
                                    --[[ tuple ]]{
                                      t,
                                      bound$1
                                    }
                                  };
                          end end), tl, tl$prime), visited$1);
                tmp = --[[ Tpoly ]]Block.__(10, {
                    copy_sep(fixed, free, bound$1, visited$2, match$2[0]),
                    tl$prime
                  });end else 
             do end end end
            else do
              tmp = copy_type_desc(undefined, copy_rec, ty$1.desc);
              end end
              
          end
        end end 
        t$1.desc = tmp;
        return t$1;
      end else do
        throw exn;
      end end 
    end
  end end 
end end

function instance_poly(keep_namesOpt, fixed, univars, sch) do
  keep_names = keep_namesOpt ~= undefined and keep_namesOpt or false;
  univars$1 = List.map(repr, univars);
  copy_var = function (ty) do
    match = ty.desc;
    if (typeof match == "number") then do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "ctype.ml",
              1307,
              11
            }
          };
    end else if (match.tag == --[[ Tunivar ]]9) then do
      if (keep_names) then do
        return newty2(current_level.contents, --[[ Tvar ]]Block.__(0, {match[0]}));
      end else do
        return newvar(undefined, --[[ () ]]0);
      end end 
    end else do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "ctype.ml",
              1307,
              11
            }
          };
    end end  end 
  end end;
  vars = List.map(copy_var, univars$1);
  pairs = List.map2((function (u, v) do
          return --[[ tuple ]]{
                  u,
                  --[[ tuple ]]{
                    v,
                    --[[ [] ]]0
                  }
                };
        end end), univars$1, vars);
  delayed_copy.contents = --[[ [] ]]0;
  ty = copy_sep(fixed, compute_univars(sch), --[[ [] ]]0, pairs, sch);
  List.iter(CamlinternalLazy.force, delayed_copy.contents);
  delayed_copy.contents = --[[ [] ]]0;
  cleanup_types(--[[ () ]]0);
  return --[[ tuple ]]{
          vars,
          ty
        };
end end

function instance_label(fixed, lbl) do
  ty_res = copy(undefined, undefined, undefined, lbl.lbl_res);
  ty = repr(lbl.lbl_arg);
  match = ty.desc;
  match$1;
  exit = 0;
  if (typeof match == "number" or match.tag ~= --[[ Tpoly ]]10) then do
    exit = 1;
  end else do
    match$1 = instance_poly(undefined, fixed, match[1], match[0]);
  end end 
  if (exit == 1) then do
    match$1 = --[[ tuple ]]{
      --[[ [] ]]0,
      copy(undefined, undefined, undefined, lbl.lbl_arg)
    };
  end
   end 
  cleanup_types(--[[ () ]]0);
  return --[[ tuple ]]{
          match$1[0],
          match$1[1],
          ty_res
        };
end end

unify$prime = do
  contents: (function (env, ty1, ty2) do
      throw {
            Unify,
            --[[ [] ]]0
          };
    end end)
end;

function subst(env, level, priv, abbrev, ty, params, args, body) do
  if (List.length(params) ~= List.length(args)) then do
    throw {
          Unify,
          --[[ [] ]]0
        };
  end
   end 
  old_level = current_level.contents;
  current_level.contents = level;
  try do
    body0 = newvar(undefined, --[[ () ]]0);
    if (ty ~= undefined) then do
      ty$1 = ty;
      match = ty$1.desc;
      if (typeof match == "number") then do
        throw {
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "ctype.ml",
                1347,
                8
              }
            };
      end else if (match.tag == --[[ Tconstr ]]3) then do
        path = match[0];
        abbrev$1 = proper_abbrevs(path, match[1], abbrev);
        memorize_abbrev(abbrev$1, priv, path, ty$1, body0);
      end else do
        throw {
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "ctype.ml",
                1347,
                8
              }
            };
      end end  end 
    end
     end 
    abbreviations.contents = abbrev;
    match$1 = instance_parameterized_type(undefined, params, body);
    body$prime = match$1[1];
    abbreviations.contents = do
      contents: --[[ Mnil ]]0
    end;
    Curry._3(unify$prime.contents, env, body0, body$prime);
    List.iter2(Curry._1(unify$prime.contents, env), match$1[0], args);
    current_level.contents = old_level;
    return body$prime;
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      current_level.contents = old_level;
      throw exn;
    end else do
      throw exn;
    end end 
  end
end end

previous_env = do
  contents: empty
end;

function check_abbrev_env(env) do
  if (env ~= previous_env.contents) then do
    cleanup_abbrev(--[[ () ]]0);
    previous_env.contents = env;
    return --[[ () ]]0;
  end else do
    return 0;
  end end 
end end

function expand_abbrev_gen(kind, find_type_expansion, env, ty) do
  check_abbrev_env(env);
  match = ty.desc;
  if (typeof match == "number") then do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ctype.ml",
            1456,
            6
          }
        };
  end else if (match.tag == --[[ Tconstr ]]3) then do
    abbrev = match[2];
    args = match[1];
    path = match[0];
    level = ty.level;
    lookup_abbrev = proper_abbrevs(path, args, abbrev);
    match$1 = find_expans(kind, path, lookup_abbrev.contents);
    if (match$1 ~= undefined) then do
      ty$1 = match$1;
      if (level ~= 100000000) then do
        try do
          update_level(env, level, ty$1);
        end
        catch (raw_exn)do
          exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn[0] ~= Unify) then do
            throw exn;
          end
           end 
        end
      end
       end 
      return ty$1;
    end else do
      match$2;
      try do
        match$2 = Curry._2(find_type_expansion, path, env);
      end
      catch (exn$1)do
        if (exn$1 == Caml_builtin_exceptions.not_found) then do
          throw Cannot_expand;
        end
         end 
        throw exn$1;
      end
      ty$prime = subst(env, level, kind, abbrev, ty, match$2[0], args, match$2[1]);
      ty$2 = repr(ty$prime);
      match$3 = ty$2.desc;
      if (typeof match$3 ~= "number" and match$3.tag == --[[ Tvariant ]]8) then do
        row = match$3[0];
        if (static_row(row)) then do
          ty$2.desc = --[[ Tvariant ]]Block.__(8, {do
                row_fields: row.row_fields,
                row_more: row.row_more,
                row_bound: row.row_bound,
                row_closed: row.row_closed,
                row_fixed: row.row_fixed,
                row_name: --[[ tuple ]]{
                  path,
                  args
                }
              end});
        end
         end 
      end
       end 
      if (trace_gadt_instances.contents) then do
        match$4 = Caml_obj.caml_max(match$2[2], gadt_instance_level(env, ty));
        if (match$4 ~= undefined) then do
          lv = match$4;
          if (level < lv) then do
            throw {
                  Unify,
                  --[[ :: ]]{
                    --[[ tuple ]]{
                      ty,
                      newty2(level, --[[ Tvar ]]Block.__(0, {undefined}))
                    },
                    --[[ [] ]]0
                  }
                };
          end
           end 
          add_gadt_instances(env, lv, --[[ :: ]]{
                ty,
                --[[ :: ]]{
                  ty$prime,
                  --[[ [] ]]0
                }
              });
        end
         end 
      end
       end 
      return ty$prime;
    end end 
  end else do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ctype.ml",
            1456,
            6
          }
        };
  end end  end 
end end

function expand_abbrev(ty) do
  return (function (param) do
      return expand_abbrev_gen(--[[ Public ]]1, find_type_expansion, ty, param);
    end end);
end end

function expand_head_once(env, ty) do
  try do
    return expand_abbrev(env)(repr(ty));
  end
  catch (exn)do
    if (exn == Cannot_expand) then do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "ctype.ml",
              1464,
              56
            }
          };
    end
     end 
    throw exn;
  end
end end

function safe_abbrev(env, ty) do
  snap = snapshot(--[[ () ]]0);
  try do
    expand_abbrev(env)(ty);
    return true;
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn == Cannot_expand or exn[0] == Unify) then do
      backtrack(snap);
      return false;
    end else do
      throw exn;
    end end 
  end
end end

function try_expand_once(env, ty) do
  ty$1 = repr(ty);
  match = ty$1.desc;
  if (typeof match == "number") then do
    throw Cannot_expand;
  end else if (match.tag == --[[ Tconstr ]]3) then do
    return repr(expand_abbrev(env)(ty$1));
  end else do
    throw Cannot_expand;
  end end  end 
end end

function try_expand_safe(env, ty) do
  snap = snapshot(--[[ () ]]0);
  try do
    return try_expand_once(env, ty);
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      backtrack(snap);
      throw Cannot_expand;
    end else do
      throw exn;
    end end 
  end
end end

function try_expand_head(try_once, env, ty) do
  ty$prime = Curry._2(try_once, env, ty);
  try do
    return try_expand_head(try_once, env, ty$prime);
  end
  catch (exn)do
    if (exn == Cannot_expand) then do
      return ty$prime;
    end else do
      throw exn;
    end end 
  end
end end

function try_expand_head$1(try_once, env, ty) do
  ty$prime = try_expand_head(try_once, env, ty);
  match = gadt_instance_level(env, ty$prime);
  if (match ~= undefined) then do
    add_gadt_instance_chain(env, match, ty);
  end
   end 
  return ty$prime;
end end

function expand_head_unif(env, ty) do
  try do
    return try_expand_head$1(try_expand_once, env, ty);
  end
  catch (exn)do
    if (exn == Cannot_expand) then do
      return repr(ty);
    end else do
      throw exn;
    end end 
  end
end end

function expand_head(env, ty) do
  try do
    return try_expand_head$1(try_expand_safe, env, ty);
  end
  catch (exn)do
    if (exn == Cannot_expand) then do
      return repr(ty);
    end else do
      throw exn;
    end end 
  end
end end

forward_try_expand_once.contents = try_expand_safe;

function extract_concrete_typedecl(env, ty) do
  ty$1 = repr(ty);
  match = ty$1.desc;
  if (typeof match == "number") then do
    throw Caml_builtin_exceptions.not_found;
  end else if (match.tag == --[[ Tconstr ]]3) then do
    p = match[0];
    decl = find_type_full(p, env)[0];
    if (decl.type_kind ~= --[[ Type_abstract ]]0) then do
      return --[[ tuple ]]{
              p,
              p,
              decl
            };
    end else do
      ty$2;
      try do
        ty$2 = try_expand_once(env, ty$1);
      end
      catch (exn)do
        if (exn == Cannot_expand) then do
          throw Caml_builtin_exceptions.not_found;
        end
         end 
        throw exn;
      end
      match$1 = extract_concrete_typedecl(env, ty$2);
      return --[[ tuple ]]{
              p,
              match$1[1],
              match$1[2]
            };
    end end 
  end else do
    throw Caml_builtin_exceptions.not_found;
  end end  end 
end end

function expand_abbrev_opt(param, param$1) do
  return expand_abbrev_gen(--[[ Private ]]0, find_type_expansion_opt, param, param$1);
end end

function try_expand_once_opt(env, ty) do
  ty$1 = repr(ty);
  match = ty$1.desc;
  if (typeof match == "number") then do
    throw Cannot_expand;
  end else if (match.tag == --[[ Tconstr ]]3) then do
    return repr(expand_abbrev_opt(env, ty$1));
  end else do
    throw Cannot_expand;
  end end  end 
end end

function try_expand_head_opt(env, ty) do
  ty$prime = try_expand_once_opt(env, ty);
  try do
    return try_expand_head_opt(env, ty$prime);
  end
  catch (exn)do
    if (exn == Cannot_expand) then do
      return ty$prime;
    end else do
      throw exn;
    end end 
  end
end end

function expand_head_opt(env, ty) do
  snap = snapshot(--[[ () ]]0);
  try do
    return try_expand_head_opt(env, ty);
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn == Cannot_expand or exn[0] == Unify) then do
      backtrack(snap);
      return repr(ty);
    end else do
      throw exn;
    end end 
  end
end end

function enforce_constraints(env, ty) do
  match = ty.desc;
  if (typeof match == "number") then do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ctype.ml",
            1574,
            6
          }
        };
  end else if (match.tag == --[[ Tconstr ]]3) then do
    level = ty.level;
    try do
      decl = find_type_full(match[0], env)[0];
      subst(env, level, --[[ Public ]]1, do
            contents: --[[ Mnil ]]0
          end, undefined, decl.type_params, match[1], newty2(level, --[[ Tvar ]]Block.__(0, {undefined})));
      return --[[ () ]]0;
    end
    catch (exn)do
      if (exn == Caml_builtin_exceptions.not_found) then do
        return --[[ () ]]0;
      end else do
        throw exn;
      end end 
    end
  end else do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ctype.ml",
            1574,
            6
          }
        };
  end end  end 
end end

function full_expand(env, ty) do
  ty$1 = repr(expand_head(env, ty));
  match = ty$1.desc;
  if (typeof match == "number" or match.tag ~= --[[ Tobject ]]4) then do
    return ty$1;
  end else do
    match$1 = match[1].contents;
    if (match$1 ~= undefined) then do
      match$2 = match$1[1];
      if (match$2 and is_Tvar(repr(match$2[0]))) then do
        return newty2(ty$1.level, --[[ Tobject ]]Block.__(4, {
                      match[0],
                      do
                        contents: undefined
                      end
                    }));
      end else do
        return ty$1;
      end end 
    end else do
      return ty$1;
    end end 
  end end 
end end

function generic_abbrev(env, path) do
  try do
    match = find_type_expansion(path, env);
    return repr(match[1]).level == 100000000;
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return false;
    end else do
      throw exn;
    end end 
  end
end end

function generic_private_abbrev(env, path) do
  try do
    match = find_type_full(path, env)[0];
    match$1 = match.type_kind;
    if (typeof match$1 == "number" and not (match$1 ~= 0 or match.type_private)) then do
      match$2 = match.type_manifest;
      if (match$2 ~= undefined) then do
        return repr(match$2).level == 100000000;
      end else do
        return false;
      end end 
    end else do
      return false;
    end end 
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return false;
    end else do
      throw exn;
    end end 
  end
end end

function is_contractive(env, ty) do
  match = repr(ty).desc;
  if (typeof match == "number" or match.tag ~= --[[ Tconstr ]]3) then do
    return true;
  end else do
    p = match[0];
    if (in_pervasives(p)) then do
      return true;
    end else do
      try do
        return is_datatype(find_type_full(p, env)[0]);
      end
      catch (exn)do
        if (exn == Caml_builtin_exceptions.not_found) then do
          return false;
        end else do
          throw exn;
        end end 
      end
    end end 
  end end 
end end

Occur = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Occur");

function occur_rec(env, visited, ty0, ty) do
  if (ty == ty0) then do
    throw Occur;
  end
   end 
  occur_ok = recursive_types.contents and is_contractive(env, ty);
  match = ty.desc;
  if (typeof match ~= "number") then do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 3--[[ Tconstr ]] then do
          try do
            if (occur_ok or List.memq(ty, visited)) then do
              throw Occur;
            end
             end 
            partial_arg = --[[ :: ]]{
              ty,
              visited
            };
            return iter_type_expr((function (param) do
                          return occur_rec(env, partial_arg, ty0, param);
                        end end), ty);
          end
          catch (exn)do
            if (exn == Occur) then do
              try do
                ty$prime = try_expand_head$1(try_expand_once, env, ty);
                if (ty$prime == ty0 or List.memq(ty$prime, visited)) then do
                  throw Occur;
                end
                 end 
                match$1 = ty$prime.desc;
                exit = 0;
                if (typeof match$1 == "number") then do
                  exit = 2;
                end else do
                  local ___conditional___=(match$1.tag | 0);
                  do
                     if ___conditional___ = 4--[[ Tobject ]]
                     or ___conditional___ = 8--[[ Tvariant ]] then do
                        return --[[ () ]]0;end end end 
                     do
                    else do
                      exit = 2;
                      end end
                      
                  end
                end end 
                if (exit == 2) then do
                  if (recursive_types.contents and is_contractive(env, ty$prime)) then do
                    return 0;
                  end else do
                    partial_arg$1 = --[[ :: ]]{
                      ty$prime,
                      visited
                    };
                    return iter_type_expr((function (param) do
                                  return occur_rec(env, partial_arg$1, ty0, param);
                                end end), ty$prime);
                  end end 
                end
                 end 
              end
              catch (exn$1)do
                if (exn$1 == Cannot_expand) then do
                  if (occur_ok) then do
                    return 0;
                  end else do
                    throw Occur;
                  end end 
                end else do
                  throw exn$1;
                end end 
              end
            end else do
              throw exn;
            end end 
          endend else 
       if ___conditional___ = 4--[[ Tobject ]]
       or ___conditional___ = 8--[[ Tvariant ]] then do
          return --[[ () ]]0;end end end 
       do end
      else do
        end end
        
    end
  end
   end 
  if (occur_ok) then do
    return 0;
  end else do
    return iter_type_expr((function (param) do
                  return occur_rec(env, visited, ty0, param);
                end end), ty);
  end end 
end end

type_changed = do
  contents: false
end;

function merge(r, b) do
  if (b) then do
    r.contents = true;
    return --[[ () ]]0;
  end else do
    return 0;
  end end 
end end

function occur(env, ty0, ty) do
  old = type_changed.contents;
  try do
    while(type_changed.contents = false, occur_rec(env, --[[ [] ]]0, ty0, ty), type_changed.contents) do
      
    end;
    return merge(type_changed, old);
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    merge(type_changed, old);
    throw exn == Occur and {
            Unify,
            --[[ [] ]]0
          } or exn;
  end
end end

function occur_in(env, ty0, t) do
  try do
    occur(env, ty0, t);
    return false;
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      return true;
    end else do
      throw exn;
    end end 
  end
end end

function unify_univar(t1, t2, _param) do
  while(true) do
    param = _param;
    if (param) then do
      match = param[0];
      find_univ = function (t, cl) do
        try do
          match = List.find((function (param) do
                  return t == repr(param[0]);
                end end), cl);
          return Caml_option.some(match[1]);
        end
        catch (exn)do
          if (exn == Caml_builtin_exceptions.not_found) then do
            return ;
          end else do
            throw exn;
          end end 
        end
      end end;
      match$1 = find_univ(t1, match[0]);
      match$2 = find_univ(t2, match[1]);
      if (match$1 ~= undefined) then do
        r1 = match$1;
        match$3 = r1.contents;
        if (match$3 ~= undefined) then do
          if (match$2 ~= undefined) then do
            if (t2 == repr(match$3)) then do
              return --[[ () ]]0;
            end else do
              throw {
                    Unify,
                    --[[ [] ]]0
                  };
            end end 
          end else do
            throw {
                  Unify,
                  --[[ [] ]]0
                };
          end end 
        end else if (match$2 ~= undefined) then do
          r2 = match$2;
          match$4 = r2.contents;
          if (match$4 ~= undefined) then do
            throw {
                  Unify,
                  --[[ [] ]]0
                };
          end
           end 
          set_univar(r1, t2);
          return set_univar(r2, t1);
        end else do
          throw {
                Unify,
                --[[ [] ]]0
              };
        end end  end 
      end else do
        if (match$2 ~= undefined) then do
          throw {
                Unify,
                --[[ [] ]]0
              };
        end
         end 
        _param = param[1];
        continue ;
      end end 
    end else do
      throw {
            Unify,
            --[[ [] ]]0
          };
    end end 
  end;
end end

function occur_univar(env, ty) do
  visited = do
    contents: --[[ Empty ]]0
  end;
  occur_rec = function (_bound, _ty) do
    while(true) do
      ty = _ty;
      bound = _bound;
      ty$1 = repr(ty);
      tmp = false;
      if (ty$1.level >= 0) then do
        tmp$1;
        if (bound and false or true) then do
          ty$1.level = pivot_level - ty$1.level | 0;
          tmp$1 = true;
        end else do
          try do
            bound$prime = find$1(ty$1, visited.contents);
            if (exists((function(bound)do
                  return function (x) do
                    return not mem$3(x, bound);
                  end end
                  end(bound)), bound$prime)) then do
              visited.contents = add$4(ty$1, inter$2(bound, bound$prime), visited.contents);
              tmp$1 = true;
            end else do
              tmp$1 = false;
            end end 
          end
          catch (exn)do
            if (exn == Caml_builtin_exceptions.not_found) then do
              visited.contents = add$4(ty$1, bound, visited.contents);
              tmp$1 = true;
            end else do
              throw exn;
            end end 
          end
        end end 
        tmp = tmp$1;
      end
       end 
      if (tmp) then do
        match = ty$1.desc;
        if (typeof match == "number") then do
          return iter_type_expr((function(bound)do
                    return function (param) do
                      return occur_rec(bound, param);
                    end end
                    end(bound)), ty$1);
        end else do
          local ___conditional___=(match.tag | 0);
          do
             if ___conditional___ = 3--[[ Tconstr ]] then do
                tl = match[1];
                if (tl) then do
                  try do
                    td = find_type_full(match[0], env)[0];
                    return List.iter2((function(bound)do
                              return function (t, v) do
                                if (Curry._2(Types_Variance.mem, --[[ May_pos ]]0, v) or Curry._2(Types_Variance.mem, --[[ May_neg ]]1, v)) then do
                                  return occur_rec(bound, t);
                                end else do
                                  return 0;
                                end end 
                              end end
                              end(bound)), tl, td.type_variance);
                  end
                  catch (exn$1)do
                    if (exn$1 == Caml_builtin_exceptions.not_found) then do
                      return List.iter((function(bound)do
                                return function (param) do
                                  return occur_rec(bound, param);
                                end end
                                end(bound)), tl);
                    end else do
                      throw exn$1;
                    end end 
                  end
                end else do
                  return --[[ () ]]0;
                end end end end end 
             if ___conditional___ = 9--[[ Tunivar ]] then do
                if (mem$3(ty$1, bound)) then do
                  return 0;
                end else do
                  throw {
                        Unify,
                        --[[ :: ]]{
                          --[[ tuple ]]{
                            ty$1,
                            newty2(100000000, --[[ Tvar ]]Block.__(0, {undefined}))
                          },
                          --[[ [] ]]0
                        }
                      };
                end end end end end 
             if ___conditional___ = 10--[[ Tpoly ]] then do
                bound$1 = List.fold_right(add$3, List.map(repr, match[1]), bound);
                _ty = match[0];
                _bound = bound$1;
                continue ;end end end 
             do
            else do
              return iter_type_expr((function(bound)do
                        return function (param) do
                          return occur_rec(bound, param);
                        end end
                        end(bound)), ty$1);
              end end
              
          end
        end end 
      end else do
        return 0;
      end end 
    end;
  end end;
  try do
    occur_rec(--[[ Empty ]]0, ty);
    return unmark_type(ty);
  end
  catch (exn)do
    unmark_type(ty);
    throw exn;
  end
end end

function add_univars(param, param$1) do
  return List.fold_left((function (s, param) do
                return add$3(repr(param[0]), s);
              end end), param, param$1);
end end

function get_univar_family(univar_pairs, univars) do
  if (univars == --[[ [] ]]0) then do
    return --[[ Empty ]]0;
  end else do
    insert = function (s, param) do
      cl2 = param[1];
      if (cl2 and List.exists((function (param) do
                return mem$3(repr(param[0]), s);
              end end), param[0])) then do
        return add_univars(s, cl2);
      end else do
        return s;
      end end 
    end end;
    s = List.fold_right(add$3, univars, --[[ Empty ]]0);
    return List.fold_left(insert, s, univar_pairs);
  end end 
end end

function univars_escape(env, univar_pairs, vl, ty) do
  family = get_univar_family(univar_pairs, vl);
  visited = do
    contents: --[[ Empty ]]0
  end;
  occur = function (_t) do
    while(true) do
      t = _t;
      t$1 = repr(t);
      if (mem$3(t$1, visited.contents)) then do
        return --[[ () ]]0;
      end else do
        visited.contents = add$3(t$1, visited.contents);
        match = t$1.desc;
        if (typeof match == "number") then do
          return iter_type_expr(occur, t$1);
        end else do
          local ___conditional___=(match.tag | 0);
          do
             if ___conditional___ = 3--[[ Tconstr ]] then do
                tl = match[1];
                if (tl) then do
                  try do
                    td = find_type_full(match[0], env)[0];
                    return List.iter2((function (t, v) do
                                  if (Curry._2(Types_Variance.mem, --[[ May_pos ]]0, v) or Curry._2(Types_Variance.mem, --[[ May_neg ]]1, v)) then do
                                    return occur(t);
                                  end else do
                                    return 0;
                                  end end 
                                end end), tl, td.type_variance);
                  end
                  catch (exn)do
                    if (exn == Caml_builtin_exceptions.not_found) then do
                      return List.iter(occur, tl);
                    end else do
                      throw exn;
                    end end 
                  end
                end else do
                  return --[[ () ]]0;
                end end end end end 
             if ___conditional___ = 9--[[ Tunivar ]] then do
                if (mem$3(t$1, family)) then do
                  throw Occur;
                end else do
                  return 0;
                end end end end end 
             if ___conditional___ = 10--[[ Tpoly ]] then do
                if (List.exists((function (t) do
                          return mem$3(repr(t), family);
                        end end), match[1])) then do
                  return --[[ () ]]0;
                end else do
                  _t = match[0];
                  continue ;
                end end end end end 
             do
            else do
              return iter_type_expr(occur, t$1);
              end end
              
          end
        end end 
      end end 
    end;
  end end;
  try do
    occur(ty);
    return false;
  end
  catch (exn)do
    if (exn == Occur) then do
      return true;
    end else do
      throw exn;
    end end 
  end
end end

function enter_poly(env, univar_pairs, t1, tl1, t2, tl2, f) do
  old_univars = univar_pairs.contents;
  known_univars = List.fold_left((function (s, param) do
          return add_univars(s, param[0]);
        end end), --[[ Empty ]]0, old_univars);
  tl1$1 = List.map(repr, tl1);
  tl2$1 = List.map(repr, tl2);
  if (List.exists((function (t) do
            return mem$3(t, known_univars);
          end end), tl1$1) and univars_escape(env, old_univars, tl1$1, newty2(current_level.contents, --[[ Tpoly ]]Block.__(10, {
                t2,
                tl2$1
              }))) or List.exists((function (t) do
            return mem$3(t, known_univars);
          end end), tl2$1) and univars_escape(env, old_univars, tl2$1, newty2(current_level.contents, --[[ Tpoly ]]Block.__(10, {
                t1,
                tl1$1
              })))) then do
    throw {
          Unify,
          --[[ [] ]]0
        };
  end
   end 
  cl1 = List.map((function (t) do
          return --[[ tuple ]]{
                  t,
                  do
                    contents: undefined
                  end
                };
        end end), tl1$1);
  cl2 = List.map((function (t) do
          return --[[ tuple ]]{
                  t,
                  do
                    contents: undefined
                  end
                };
        end end), tl2$1);
  univar_pairs.contents = --[[ :: ]]{
    --[[ tuple ]]{
      cl1,
      cl2
    },
    --[[ :: ]]{
      --[[ tuple ]]{
        cl2,
        cl1
      },
      old_univars
    }
  };
  try do
    res = Curry._2(f, t1, t2);
    univar_pairs.contents = old_univars;
    return res;
  end
  catch (exn)do
    univar_pairs.contents = old_univars;
    throw exn;
  end
end end

univar_pairs = do
  contents: --[[ [] ]]0
end;

function has_cached_expansion(p, _abbrev) do
  while(true) do
    abbrev = _abbrev;
    if (typeof abbrev == "number") then do
      return false;
    end else if (abbrev.tag) then do
      _abbrev = abbrev[0].contents;
      continue ;
    end else if (same(p, abbrev[1])) then do
      return true;
    end else do
      _abbrev = abbrev[4];
      continue ;
    end end  end  end 
  end;
end end

function expand_trace(env, trace) do
  return List.fold_right((function (param, rem) do
                t2 = param[1];
                t1 = param[0];
                return --[[ :: ]]{
                        --[[ tuple ]]{
                          repr(t1),
                          full_expand(env, t1)
                        },
                        --[[ :: ]]{
                          --[[ tuple ]]{
                            repr(t2),
                            full_expand(env, t2)
                          },
                          rem
                        }
                      };
              end end), trace, --[[ [] ]]0);
end end

function mkvariant(fields, closed) do
  return newty2(100000000, --[[ Tvariant ]]Block.__(8, {do
                  row_fields: fields,
                  row_more: newvar(undefined, --[[ () ]]0),
                  row_bound: --[[ () ]]0,
                  row_closed: closed,
                  row_fixed: false,
                  row_name: undefined
                end}));
end end

rigid_variants = do
  contents: false
end;

function deep_occur(t0, ty) do
  occur_rec = function (ty) do
    ty$1 = repr(ty);
    if (ty$1.level >= 0) then do
      if (ty$1 == t0) then do
        throw Occur;
      end
       end 
      ty$1.level = pivot_level - ty$1.level | 0;
      return iter_type_expr(occur_rec, ty$1);
    end else do
      return 0;
    end end 
  end end;
  try do
    occur_rec(ty);
    unmark_type(ty);
    return false;
  end
  catch (exn)do
    if (exn == Occur) then do
      unmark_type(ty);
      return true;
    end else do
      throw exn;
    end end 
  end
end end

newtype_level = do
  contents: undefined
end;

function get_newtype_level(param) do
  match = newtype_level.contents;
  if (match ~= undefined) then do
    return match;
  end else do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ctype.ml",
            1949,
            12
          }
        };
  end end 
end end

function reify(env, t) do
  newtype_level = get_newtype_level(--[[ () ]]0);
  create_fresh_constr = function (lev, name) do
    decl = new_declaration(--[[ tuple ]]{
          newtype_level,
          newtype_level
        }, undefined);
    name$1 = get_new_abstract_name(name);
    match = enter_type(name$1, decl, env.contents);
    t = newty2(lev, --[[ Tconstr ]]Block.__(3, {
            --[[ Pident ]]Block.__(0, {match[0]}),
            --[[ [] ]]0,
            do
              contents: --[[ Mnil ]]0
            end
          }));
    env.contents = match[1];
    return t;
  end end;
  visited = do
    contents: --[[ Empty ]]0
  end;
  iterator = function (ty) do
    ty$1 = repr(ty);
    if (mem$3(ty$1, visited.contents)) then do
      return --[[ () ]]0;
    end else do
      visited.contents = add$3(ty$1, visited.contents);
      match = ty$1.desc;
      if (typeof match == "number") then do
        return iter_type_expr(iterator, ty$1);
      end else do
        local ___conditional___=(match.tag | 0);
        do
           if ___conditional___ = 0--[[ Tvar ]] then do
              o = match[0];
              name = o ~= undefined and o or "ex";
              t = create_fresh_constr(ty$1.level, name);
              return link_type(ty$1, t);end end end 
           if ___conditional___ = 3--[[ Tconstr ]] then do
              if (is_object_type(match[0])) then do
                return iter_type_expr(iterator, full_expand(env.contents, ty$1));
              end else do
                return iter_type_expr(iterator, ty$1);
              end end end end end 
           if ___conditional___ = 8--[[ Tvariant ]] then do
              r = row_repr_aux(--[[ [] ]]0, match[0]);
              if (not static_row(r)) then do
                if (r.row_fixed) then do
                  iterator(row_more(r));
                end else do
                  m = r.row_more;
                  match$1 = m.desc;
                  if (typeof match$1 == "number") then do
                    throw {
                          Caml_builtin_exceptions.assert_failure,
                          --[[ tuple ]]{
                            "ctype.ml",
                            1987,
                            19
                          }
                        };
                  end else if (match$1.tag) then do
                    throw {
                          Caml_builtin_exceptions.assert_failure,
                          --[[ tuple ]]{
                            "ctype.ml",
                            1987,
                            19
                          }
                        };
                  end else do
                    o$1 = match$1[0];
                    name$1 = o$1 ~= undefined and o$1 or "ex";
                    t$1 = create_fresh_constr(m.level, name$1);
                    row_row_bound = r.row_bound;
                    row_row_closed = r.row_closed;
                    row_row_name = r.row_name;
                    row = do
                      row_fields: --[[ [] ]]0,
                      row_more: t$1,
                      row_bound: row_row_bound,
                      row_closed: row_row_closed,
                      row_fixed: true,
                      row_name: row_row_name
                    end;
                    link_type(m, newty2(m.level, --[[ Tvariant ]]Block.__(8, {row})));
                  end end  end 
                end end 
              end
               end 
              return iter_row(iterator, r);end end end 
           do
          else do
            return iter_type_expr(iterator, ty$1);
            end end
            
        end
      end end 
    end end 
  end end;
  return iterator(t);
end end

function is_newtype(env, p) do
  try do
    decl = find_type_full(p, env)[0];
    if (decl.type_newtype_level ~= undefined and decl.type_kind == --[[ Type_abstract ]]0) then do
      return decl.type_private == --[[ Public ]]1;
    end else do
      return false;
    end end 
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return false;
    end else do
      throw exn;
    end end 
  end
end end

function non_aliasable(p, decl) do
  if (in_current_module(p)) then do
    return decl.type_newtype_level == undefined;
  end else do
    return false;
  end end 
end end

function expands_to_datatype(env, ty) do
  ty$1 = repr(ty);
  match = ty$1.desc;
  if (typeof match == "number" or match.tag ~= --[[ Tconstr ]]3) then do
    return false;
  end else do
    try do
      if (is_datatype(find_type_full(match[0], env)[0])) then do
        return true;
      end else do
        return expands_to_datatype(env, try_expand_once(env, ty$1));
      end end 
    end
    catch (exn)do
      if (exn == Caml_builtin_exceptions.not_found or exn == Cannot_expand) then do
        return false;
      end else do
        throw exn;
      end end 
    end
  end end 
end end

function mcomp(type_pairs, env, _t1, _t2) do
  while(true) do
    t2 = _t2;
    t1 = _t1;
    if (t1 == t2) then do
      return --[[ () ]]0;
    end else do
      t1$1 = repr(t1);
      t2$1 = repr(t2);
      if (t1$1 == t2$1) then do
        return --[[ () ]]0;
      end else do
        match = t1$1.desc;
        match$1 = t2$1.desc;
        exit = 0;
        exit$1 = 0;
        if (typeof match == "number") then do
          exit$1 = 2;
        end else do
          local ___conditional___=(match.tag | 0);
          do
             if ___conditional___ = 0--[[ Tvar ]] then do
                return --[[ () ]]0;end end end 
             if ___conditional___ = 3--[[ Tconstr ]] then do
                if (match[1]) then do
                  exit$1 = 2;
                end else if (typeof match$1 == "number") then do
                  exit = 1;
                end else do
                  local ___conditional___=(match$1.tag | 0);
                  do
                     if ___conditional___ = 0--[[ Tvar ]] then do
                        exit$1 = 2;end else 
                     if ___conditional___ = 3--[[ Tconstr ]] then do
                        if (match$1[1] or not same(match[0], match$1[0])) then do
                          exit = 1;
                        end else do
                          return --[[ () ]]0;
                        end end end else 
                     do end end end
                    else do
                      exit = 1;
                      end end
                      
                  end
                end end  end end else 
             do end
            else do
              exit$1 = 2;
              end end
              
          end
        end end 
        if (exit$1 == 2) then do
          if (typeof match$1 == "number" or match$1.tag) then do
            exit = 1;
          end else do
            return --[[ () ]]0;
          end end 
        end
         end 
        if (exit == 1) then do
          t1$prime = expand_head_opt(env, t1$1);
          t2$prime = expand_head_opt(env, t2$1);
          t1$prime$1 = repr(t1$prime);
          t2$prime$1 = repr(t2$prime);
          if (t1$prime$1 == t2$prime$1) then do
            return --[[ () ]]0;
          end else do
            try do
              return Curry._2(TypePairs.find, type_pairs, --[[ tuple ]]{
                          t1$prime$1,
                          t2$prime$1
                        });
            end
            catch (exn)do
              if (exn == Caml_builtin_exceptions.not_found) then do
                Curry._3(TypePairs.add, type_pairs, --[[ tuple ]]{
                      t1$prime$1,
                      t2$prime$1
                    }, --[[ () ]]0);
                match$2 = t1$prime$1.desc;
                match$3 = t2$prime$1.desc;
                p;
                exit$2 = 0;
                if (typeof match$2 == "number") then do
                  if (typeof match$3 == "number") then do
                    return --[[ () ]]0;
                  end else if (match$3.tag == --[[ Tconstr ]]3) then do
                    exit$2 = 3;
                  end else do
                    throw {
                          Unify,
                          --[[ [] ]]0
                        };
                  end end  end 
                end else do
                  local ___conditional___=(match$2.tag | 0);
                  do
                     if ___conditional___ = 0--[[ Tvar ]] then do
                        if (typeof match$3 == "number") then do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end else do
                          local ___conditional___=(match$3.tag | 0);
                          do
                             if ___conditional___ = 0--[[ Tvar ]] then do
                                throw {
                                      Caml_builtin_exceptions.assert_failure,
                                      --[[ tuple ]]{
                                        "ctype.ml",
                                        2051,
                                        30
                                      }
                                    };end end end 
                             if ___conditional___ = 3--[[ Tconstr ]] then do
                                exit$2 = 3;end else 
                             do end
                            else do
                              throw {
                                    Unify,
                                    --[[ [] ]]0
                                  };
                              end end
                              
                          end
                        end end end else 
                     if ___conditional___ = 1--[[ Tarrow ]] then do
                        l1 = match$2[0];
                        if (typeof match$3 == "number") then do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end else do
                          local ___conditional___=(match$3.tag | 0);
                          do
                             if ___conditional___ = 1--[[ Tarrow ]] then do
                                l2 = match$3[0];
                                if (l1 == l2 or not (is_optional(l1) or is_optional(l2))) then do
                                  mcomp(type_pairs, env, match$2[1], match$3[1]);
                                  _t2 = match$3[2];
                                  _t1 = match$2[2];
                                  continue ;
                                end else do
                                  throw {
                                        Unify,
                                        --[[ [] ]]0
                                      };
                                end end end end end 
                             if ___conditional___ = 3--[[ Tconstr ]] then do
                                exit$2 = 3;end else 
                             do end
                            else do
                              throw {
                                    Unify,
                                    --[[ [] ]]0
                                  };
                              end end
                              
                          end
                        end end end else 
                     if ___conditional___ = 2--[[ Ttuple ]] then do
                        if (typeof match$3 == "number") then do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end else do
                          local ___conditional___=(match$3.tag | 0);
                          do
                             if ___conditional___ = 2--[[ Ttuple ]] then do
                                return mcomp_list(type_pairs, env, match$2[0], match$3[0]);end end end 
                             if ___conditional___ = 3--[[ Tconstr ]] then do
                                exit$2 = 3;end else 
                             do end
                            else do
                              throw {
                                    Unify,
                                    --[[ [] ]]0
                                  };
                              end end
                              
                          end
                        end end end else 
                     if ___conditional___ = 3--[[ Tconstr ]] then do
                        p1 = match$2[0];
                        if (typeof match$3 == "number" or match$3.tag ~= --[[ Tconstr ]]3) then do
                          p = p1;
                        end else do
                          type_pairs$1 = type_pairs;
                          env$1 = env;
                          p1$1 = p1;
                          p2 = match$3[0];
                          tl1 = match$2[1];
                          tl2 = match$3[1];
                          try do
                            decl = find_type_full(p1$1, env$1)[0];
                            decl$prime = find_type_full(p2, env$1)[0];
                            if (same(p1$1, p2)) then do
                              inj;
                              try do
                                inj = List.map(Curry._1(Types_Variance.mem, --[[ Inj ]]3), find_type_full(p1$1, env$1)[0].type_variance);
                              end
                              catch (exn$1)do
                                if (exn$1 == Caml_builtin_exceptions.not_found) then do
                                  inj = List.map((function (param) do
                                          return false;
                                        end end), tl1);
                                end else do
                                  throw exn$1;
                                end end 
                              end
                              return List.iter2((function(type_pairs$1,env$1)do
                                        return function (i, param) do
                                          if (i) then do
                                            return mcomp(type_pairs$1, env$1, param[0], param[1]);
                                          end else do
                                            return 0;
                                          end end 
                                        end end
                                        end(type_pairs$1,env$1)), inj, List.combine(tl1, tl2));
                            end else do
                              if (non_aliasable(p1$1, decl) and non_aliasable(p2, decl$prime)) then do
                                throw {
                                      Unify,
                                      --[[ [] ]]0
                                    };
                              end
                               end 
                              match$4 = decl.type_kind;
                              match$5 = decl$prime.type_kind;
                              exit$3 = 0;
                              if (typeof match$4 == "number") then do
                                if (match$4 == --[[ Type_abstract ]]0) then do
                                  exit$4 = 0;
                                  if (typeof match$5 == "number" and match$5 == 0) then do
                                    return --[[ () ]]0;
                                  end else do
                                    exit$4 = 2;
                                  end end 
                                  if (exit$4 == 2) then do
                                    if (non_aliasable(p1$1, decl)) then do
                                      exit$3 = 1;
                                    end else do
                                      return --[[ () ]]0;
                                    end end 
                                  end
                                   end 
                                end else if (typeof match$5 == "number") then do
                                  if (match$5 ~= 0) then do
                                    return mcomp_list(type_pairs$1, env$1, tl1, tl2);
                                  end else do
                                    exit$3 = 1;
                                  end end 
                                end else do
                                  throw {
                                        Unify,
                                        --[[ [] ]]0
                                      };
                                end end  end 
                              end else if (match$4.tag) then do
                                if (typeof match$5 == "number") then do
                                  if (match$5 == --[[ Type_abstract ]]0) then do
                                    exit$3 = 1;
                                  end else do
                                    throw {
                                          Unify,
                                          --[[ [] ]]0
                                        };
                                  end end 
                                end else if (match$5.tag) then do
                                  mcomp_list(type_pairs$1, env$1, tl1, tl2);
                                  type_pairs$2 = type_pairs$1;
                                  env$2 = env$1;
                                  xs = match$4[0];
                                  ys = match$5[0];
                                  _x = xs;
                                  _y = ys;
                                  while(true) do
                                    y = _y;
                                    x = _x;
                                    if (x) then do
                                      if (y) then do
                                        c2 = y[0];
                                        c1 = x[0];
                                        mcomp_type_option(type_pairs$2, env$2, c1.cd_res, c2.cd_res);
                                        mcomp_list(type_pairs$2, env$2, c1.cd_args, c2.cd_args);
                                        if (c1.cd_id.name == c2.cd_id.name) then do
                                          _y = y[1];
                                          _x = x[1];
                                          continue ;
                                        end else do
                                          throw {
                                                Unify,
                                                --[[ [] ]]0
                                              };
                                        end end 
                                      end else do
                                        throw {
                                              Unify,
                                              --[[ [] ]]0
                                            };
                                      end end 
                                    end else if (y) then do
                                      throw {
                                            Unify,
                                            --[[ [] ]]0
                                          };
                                    end else do
                                      return --[[ () ]]0;
                                    end end  end 
                                  end;
                                end else do
                                  throw {
                                        Unify,
                                        --[[ [] ]]0
                                      };
                                end end  end 
                              end else if (typeof match$5 == "number") then do
                                if (match$5 == --[[ Type_abstract ]]0) then do
                                  exit$3 = 1;
                                end else do
                                  throw {
                                        Unify,
                                        --[[ [] ]]0
                                      };
                                end end 
                              end else if (match$5.tag) then do
                                throw {
                                      Unify,
                                      --[[ [] ]]0
                                    };
                              end else if (match$4[1] == match$5[1]) then do
                                mcomp_list(type_pairs$1, env$1, tl1, tl2);
                                return mcomp_record_description(type_pairs$1, env$1)(match$4[0], match$5[0]);
                              end else do
                                throw {
                                      Unify,
                                      --[[ [] ]]0
                                    };
                              end end  end  end  end  end 
                              if (exit$3 == 1) then do
                                if (typeof match$5 == "number") then do
                                  if (match$5 ~= 0) then do
                                    throw {
                                          Unify,
                                          --[[ [] ]]0
                                        };
                                  end
                                   end 
                                  if (non_aliasable(p2, decl$prime)) then do
                                    throw {
                                          Unify,
                                          --[[ [] ]]0
                                        };
                                  end else do
                                    return --[[ () ]]0;
                                  end end 
                                end else do
                                  throw {
                                        Unify,
                                        --[[ [] ]]0
                                      };
                                end end 
                              end
                               end 
                            end end 
                          end
                          catch (exn$2)do
                            if (exn$2 == Caml_builtin_exceptions.not_found) then do
                              return --[[ () ]]0;
                            end else do
                              throw exn$2;
                            end end 
                          end
                        end end end else 
                     if ___conditional___ = 4--[[ Tobject ]] then do
                        if (typeof match$3 == "number") then do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end else do
                          local ___conditional___=(match$3.tag | 0);
                          do
                             if ___conditional___ = 3--[[ Tconstr ]] then do
                                exit$2 = 3;end else 
                             if ___conditional___ = 4--[[ Tobject ]] then do
                                return mcomp_fields(type_pairs, env, match$2[0], match$3[0]);end end end 
                             do end
                            else do
                              throw {
                                    Unify,
                                    --[[ [] ]]0
                                  };
                              end end
                              
                          end
                        end end end else 
                     if ___conditional___ = 5--[[ Tfield ]] then do
                        if (typeof match$3 == "number") then do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end else do
                          local ___conditional___=(match$3.tag | 0);
                          do
                             if ___conditional___ = 3--[[ Tconstr ]] then do
                                exit$2 = 3;end else 
                             if ___conditional___ = 5--[[ Tfield ]] then do
                                return mcomp_fields(type_pairs, env, t1$prime$1, t2$prime$1);end end end 
                             do end
                            else do
                              throw {
                                    Unify,
                                    --[[ [] ]]0
                                  };
                              end end
                              
                          end
                        end end end else 
                     if ___conditional___ = 6--[[ Tlink ]]
                     or ___conditional___ = 7--[[ Tsubst ]] then do
                        exit$2 = 3;end else 
                     if ___conditional___ = 8--[[ Tvariant ]] then do
                        if (typeof match$3 == "number") then do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end else do
                          local ___conditional___=(match$3.tag | 0);
                          do
                             if ___conditional___ = 3--[[ Tconstr ]] then do
                                exit$2 = 3;end else 
                             if ___conditional___ = 8--[[ Tvariant ]] then do
                                type_pairs$3 = type_pairs;
                                env$3 = env;
                                row1 = match$2[0];
                                row2 = match$3[0];
                                row1$1 = row_repr_aux(--[[ [] ]]0, row1);
                                row2$1 = row_repr_aux(--[[ [] ]]0, row2);
                                match$6 = merge_row_fields(row1$1.row_fields, row2$1.row_fields);
                                cannot_erase = function (param) do
                                  match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                                  if (typeof match == "number" or match.tag) then do
                                    return false;
                                  end else do
                                    return true;
                                  end end 
                                end end;
                                if (row1$1.row_closed and List.exists(cannot_erase, match$6[1]) or row2$1.row_closed and List.exists(cannot_erase, match$6[0])) then do
                                  throw {
                                        Unify,
                                        --[[ [] ]]0
                                      };
                                end
                                 end 
                                return List.iter((function(type_pairs$3,env$3)do
                                          return function (param) do
                                            match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                                            match$1 = row_field_repr_aux(--[[ [] ]]0, param[2]);
                                            exit = 0;
                                            exit$1 = 0;
                                            if (typeof match == "number") then do
                                              exit$1 = 2;
                                            end else if (match.tag) then do
                                              exit$2 = 0;
                                              if (match[0] or typeof match$1 == "number" or match$1.tag) then do
                                                exit$2 = 3;
                                              end else do
                                                match$2 = match$1[0];
                                                if (match$2 ~= undefined) then do
                                                  t2 = match$2;
                                                  return List.iter((function (param) do
                                                                return mcomp(type_pairs$3, env$3, t2, param);
                                                              end end), match[1]);
                                                end else do
                                                  exit$2 = 3;
                                                end end 
                                              end end 
                                              if (exit$2 == 3) then do
                                                if (match[1]) then do
                                                  exit$1 = 2;
                                                end else do
                                                  exit = 1;
                                                end end 
                                              end
                                               end 
                                            end else do
                                              match$3 = match[0];
                                              if (match$3 ~= undefined) then do
                                                t1 = match$3;
                                                if (typeof match$1 == "number") then do
                                                  throw {
                                                        Unify,
                                                        --[[ [] ]]0
                                                      };
                                                end else if (match$1.tag) then do
                                                  if (match$1[0]) then do
                                                    throw {
                                                          Unify,
                                                          --[[ [] ]]0
                                                        };
                                                  end
                                                   end 
                                                  return List.iter((function (param) do
                                                                return mcomp(type_pairs$3, env$3, t1, param);
                                                              end end), match$1[1]);
                                                end else do
                                                  match$4 = match$1[0];
                                                  if (match$4 ~= undefined) then do
                                                    return mcomp(type_pairs$3, env$3, t1, match$4);
                                                  end else do
                                                    throw {
                                                          Unify,
                                                          --[[ [] ]]0
                                                        };
                                                  end end 
                                                end end  end 
                                              end else if (typeof match$1 == "number") then do
                                                throw {
                                                      Unify,
                                                      --[[ [] ]]0
                                                    };
                                              end else if (match$1.tag) then do
                                                if (match$1[1]) then do
                                                  throw {
                                                        Unify,
                                                        --[[ [] ]]0
                                                      };
                                                end else do
                                                  return --[[ () ]]0;
                                                end end 
                                              end else if (match$1[0] ~= undefined) then do
                                                throw {
                                                      Unify,
                                                      --[[ [] ]]0
                                                    };
                                              end else do
                                                return --[[ () ]]0;
                                              end end  end  end  end 
                                            end end  end 
                                            if (exit$1 == 2) then do
                                              if (typeof match$1 == "number" or match$1.tag) then do
                                                return --[[ () ]]0;
                                              end else if (match$1[0] ~= undefined) then do
                                                exit = 1;
                                              end else do
                                                throw {
                                                      Unify,
                                                      --[[ [] ]]0
                                                    };
                                              end end  end 
                                            end
                                             end 
                                            if (exit == 1) then do
                                              if (typeof match ~= "number" and not match[0]) then do
                                                return --[[ () ]]0;
                                              end
                                               end 
                                              if (typeof match$1 == "number" or match$1.tag or match$1[0] == undefined) then do
                                                return --[[ () ]]0;
                                              end else do
                                                throw {
                                                      Unify,
                                                      --[[ [] ]]0
                                                    };
                                              end end 
                                            end
                                             end 
                                          end end
                                          end(type_pairs$3,env$3)), match$6[2]);end end end 
                             do end
                            else do
                              throw {
                                    Unify,
                                    --[[ [] ]]0
                                  };
                              end end
                              
                          end
                        end end end else 
                     if ___conditional___ = 9--[[ Tunivar ]] then do
                        if (typeof match$3 == "number") then do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end else do
                          local ___conditional___=(match$3.tag | 0);
                          do
                             if ___conditional___ = 3--[[ Tconstr ]] then do
                                exit$2 = 3;end else 
                             if ___conditional___ = 9--[[ Tunivar ]] then do
                                return unify_univar(t1$prime$1, t2$prime$1, univar_pairs.contents);end end end 
                             do end
                            else do
                              throw {
                                    Unify,
                                    --[[ [] ]]0
                                  };
                              end end
                              
                          end
                        end end end else 
                     if ___conditional___ = 10--[[ Tpoly ]] then do
                        tl1$1 = match$2[1];
                        t1$2 = match$2[0];
                        exit$5 = 0;
                        if (tl1$1) then do
                          exit$5 = 4;
                        end else if (typeof match$3 == "number") then do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end else do
                          local ___conditional___=(match$3.tag | 0);
                          do
                             if ___conditional___ = 3--[[ Tconstr ]] then do
                                exit$2 = 3;end else 
                             if ___conditional___ = 10--[[ Tpoly ]] then do
                                if (match$3[1]) then do
                                  exit$5 = 4;
                                end else do
                                  _t2 = match$3[0];
                                  _t1 = t1$2;
                                  continue ;
                                end end end else 
                             do end end end
                            else do
                              throw {
                                    Unify,
                                    --[[ [] ]]0
                                  };
                              end end
                              
                          end
                        end end  end 
                        if (exit$5 == 4) then do
                          if (typeof match$3 == "number") then do
                            throw {
                                  Unify,
                                  --[[ [] ]]0
                                };
                          end else do
                            local ___conditional___=(match$3.tag | 0);
                            do
                               if ___conditional___ = 3--[[ Tconstr ]] then do
                                  exit$2 = 3;end else 
                               if ___conditional___ = 10--[[ Tpoly ]] then do
                                  return enter_poly(env, univar_pairs, t1$2, tl1$1, match$3[0], match$3[1], (function (param, param$1) do
                                                return mcomp(type_pairs, env, param, param$1);
                                              end end));end end end 
                               do end
                              else do
                                throw {
                                      Unify,
                                      --[[ [] ]]0
                                    };
                                end end
                                
                            end
                          end end 
                        end
                         end end else 
                     if ___conditional___ = 11--[[ Tpackage ]] then do
                        if (typeof match$3 == "number") then do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end else do
                          local ___conditional___=(match$3.tag | 0);
                          do
                             if ___conditional___ = 3--[[ Tconstr ]] then do
                                exit$2 = 3;end else 
                             if ___conditional___ = 11--[[ Tpackage ]] then do
                                return --[[ () ]]0;end end end 
                             do end
                            else do
                              throw {
                                    Unify,
                                    --[[ [] ]]0
                                  };
                              end end
                              
                          end
                        end end end else 
                     do end end end end end end end end end end end end
                    
                  end
                end end 
                if (exit$2 == 3) then do
                  if (typeof match$3 == "number") then do
                    throw {
                          Unify,
                          --[[ [] ]]0
                        };
                  end else if (match$3.tag == --[[ Tconstr ]]3) then do
                    p = match$3[0];
                  end else do
                    throw {
                          Unify,
                          --[[ [] ]]0
                        };
                  end end  end 
                end
                 end 
                try do
                  decl$1 = find_type_full(p, env)[0];
                  if (non_aliasable(p, decl$1) or is_datatype(decl$1)) then do
                    throw {
                          Unify,
                          --[[ [] ]]0
                        };
                  end else do
                    return 0;
                  end end 
                end
                catch (exn$3)do
                  if (exn$3 == Caml_builtin_exceptions.not_found) then do
                    return --[[ () ]]0;
                  end else do
                    throw exn$3;
                  end end 
                end
              end else do
                throw exn;
              end end 
            end
          end end 
        end
         end 
      end end 
    end end 
  end;
end end

function mcomp_list(type_pairs, env, tl1, tl2) do
  if (List.length(tl1) ~= List.length(tl2)) then do
    throw {
          Unify,
          --[[ [] ]]0
        };
  end
   end 
  return List.iter2((function (param, param$1) do
                return mcomp(type_pairs, env, param, param$1);
              end end), tl1, tl2);
end end

function mcomp_fields(type_pairs, env, ty1, ty2) do
  if (not (concrete_object(ty1) and concrete_object(ty2))) then do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ctype.ml",
            2096,
            59
          }
        };
  end
   end 
  match = flatten_fields(ty2);
  match$1 = flatten_fields(ty1);
  match$2 = associate_fields(match$1[0], match[0]);
  mcomp(type_pairs, env, match$1[1], match[1]);
  if (match$2[1] ~= --[[ [] ]]0 and object_row(ty1).desc == --[[ Tnil ]]0 or match$2[2] ~= --[[ [] ]]0 and object_row(ty2).desc == --[[ Tnil ]]0) then do
    throw {
          Unify,
          --[[ [] ]]0
        };
  end
   end 
  return List.iter((function (param) do
                mcomp_kind(param[1], param[3]);
                return mcomp(type_pairs, env, param[2], param[4]);
              end end), match$2[0]);
end end

function mcomp_kind(k1, k2) do
  k1$1 = field_kind_repr(k1);
  k2$1 = field_kind_repr(k2);
  if (typeof k1$1 == "number") then do
    if (k1$1 ~= 0) then do
      throw {
            Unify,
            --[[ [] ]]0
          };
    end
     end 
    if (typeof k2$1 == "number") then do
      if (k2$1 ~= 0) then do
        throw {
              Unify,
              --[[ [] ]]0
            };
      end else do
        return --[[ () ]]0;
      end end 
    end else do
      throw {
            Unify,
            --[[ [] ]]0
          };
    end end 
  end else do
    if (typeof k2$1 == "number") then do
      throw {
            Unify,
            --[[ [] ]]0
          };
    end
     end 
    return --[[ () ]]0;
  end end 
end end

function mcomp_type_option(type_pairs, env, t, t$prime) do
  if (t ~= undefined) then do
    if (t$prime ~= undefined) then do
      return mcomp(type_pairs, env, t, t$prime);
    end else do
      throw {
            Unify,
            --[[ [] ]]0
          };
    end end 
  end else if (t$prime ~= undefined) then do
    throw {
          Unify,
          --[[ [] ]]0
        };
  end else do
    return --[[ () ]]0;
  end end  end 
end end

function mcomp_record_description(type_pairs, env) do
  iter = function (_x, _y) do
    while(true) do
      y = _y;
      x = _x;
      if (x) then do
        if (y) then do
          l2 = y[0];
          l1 = x[0];
          mcomp(type_pairs, env, l1.ld_type, l2.ld_type);
          if (l1.ld_id.name == l2.ld_id.name and l1.ld_mutable == l2.ld_mutable) then do
            _y = y[1];
            _x = x[1];
            continue ;
          end else do
            throw {
                  Unify,
                  --[[ [] ]]0
                };
          end end 
        end else do
          throw {
                Unify,
                --[[ [] ]]0
              };
        end end 
      end else if (y) then do
        throw {
              Unify,
              --[[ [] ]]0
            };
      end else do
        return --[[ () ]]0;
      end end  end 
    end;
  end end;
  return iter;
end end

function mcomp$1(env, t1, t2) do
  return mcomp(Curry._1(TypePairs.create, 4), env, t1, t2);
end end

function find_lowest_level(ty) do
  lowest = do
    contents: 100000000
  end;
  find = function (ty) do
    ty$1 = repr(ty);
    if (ty$1.level >= 0) then do
      if (ty$1.level < lowest.contents) then do
        lowest.contents = ty$1.level;
      end
       end 
      ty$1.level = pivot_level - ty$1.level | 0;
      return iter_type_expr(find, ty$1);
    end else do
      return 0;
    end end 
  end end;
  find(ty);
  unmark_type(ty);
  return lowest.contents;
end end

function find_newtype_level(env, path) do
  try do
    match = find_type_full(path, env)[0].type_newtype_level;
    if (match ~= undefined) then do
      return match;
    end else do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "ctype.ml",
              2227,
              12
            }
          };
    end end 
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "ctype.ml",
              2228,
              20
            }
          };
    end
     end 
    throw exn;
  end
end end

function add_gadt_equation(env, source, destination) do
  destination$1 = type_expr(identity, destination);
  source_lev = find_newtype_level(env.contents, --[[ Pident ]]Block.__(0, {source}));
  decl = new_declaration(source_lev, destination$1);
  newtype_level = get_newtype_level(--[[ () ]]0);
  env.contents = add_local_constraint(source, decl, newtype_level, env.contents);
  return cleanup_abbrev(--[[ () ]]0);
end end

unify_eq_set = Curry._1(TypePairs.create, 11);

function order_type_pair(t1, t2) do
  if (t1.id <= t2.id) then do
    return --[[ tuple ]]{
            t1,
            t2
          };
  end else do
    return --[[ tuple ]]{
            t2,
            t1
          };
  end end 
end end

function add_type_equality(t1, t2) do
  return Curry._3(TypePairs.add, unify_eq_set, order_type_pair(t1, t2), --[[ () ]]0);
end end

function eq_package_path(env, p1, p2) do
  if (same(p1, p2)) then do
    return true;
  end else do
    return same(normalize_package_path(env, p1), normalize_package_path(env, p2));
  end end 
end end

nondep_type$prime = do
  contents: (function (param, param$1, param$2) do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "ctype.ml",
              2250,
              37
            }
          };
    end end)
end;

package_subtype = do
  contents: (function (param, param$1, param$2, param$3, param$4, param$5, param$6) do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "ctype.ml",
              2251,
              48
            }
          };
    end end)
end;

function concat_longident(lid1, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Lident ]] then do
        return --[[ Ldot ]]Block.__(1, {
                  lid1,
                  param[0]
                });end end end 
     if ___conditional___ = 1--[[ Ldot ]] then do
        return --[[ Ldot ]]Block.__(1, {
                  concat_longident(lid1, param[0]),
                  param[1]
                });end end end 
     if ___conditional___ = 2--[[ Lapply ]] then do
        return --[[ Lapply ]]Block.__(2, {
                  concat_longident(lid1, param[0]),
                  param[1]
                });end end end 
     do
    
  end
end end

function nondep_instance(env, level, id, ty) do
  ty$1 = Curry._3(nondep_type$prime.contents, env, id, ty);
  if (level == 100000000) then do
    return type_expr(identity, ty$1);
  end else do
    old = current_level.contents;
    current_level.contents = level;
    ty$2 = instance(undefined, env, ty$1);
    current_level.contents = old;
    return ty$2;
  end end 
end end

function complete_type_list(allow_absentOpt, env, nl1, lv2, mty2, nl2, tl2) do
  allow_absent = allow_absentOpt ~= undefined and allow_absentOpt or false;
  id2 = create("Pkg");
  env$prime = add_module$1(undefined, id2, mty2, env);
  complete = function (_nl1, ntl2) do
    while(true) do
      nl1 = _nl1;
      if (nl1) then do
        nl = nl1[1];
        n = nl1[0];
        exit = 0;
        if (ntl2) then do
          nt2 = ntl2[0];
          n2 = nt2[0];
          if (Caml_obj.caml_greaterequal(n, n2)) then do
            return --[[ :: ]]{
                    nt2,
                    complete(Caml_obj.caml_equal(n, n2) and nl or nl1, ntl2[1])
                  };
          end else do
            exit = 1;
          end end 
        end else do
          exit = 1;
        end end 
        if (exit == 1) then do
          try do
            match = lookup_type$1(concat_longident(--[[ Lident ]]Block.__(0, {"Pkg"}), n), env$prime);
            decl = match[1];
            if (decl.type_arity ~= 0) then do
              throw Pervasives.Exit;
            end
             end 
            match$1 = decl.type_kind;
            if (typeof match$1 == "number") then do
              if (match$1 ~= 0) then do
                throw Pervasives.Exit;
              end
               end 
              if (decl.type_private) then do
                match$2 = decl.type_manifest;
                if (match$2 ~= undefined) then do
                  return --[[ :: ]]{
                          --[[ tuple ]]{
                            n,
                            nondep_instance(env$prime, lv2, id2, match$2)
                          },
                          complete(nl, ntl2)
                        };
                end else if (allow_absent) then do
                  return complete(nl, ntl2);
                end else do
                  throw Pervasives.Exit;
                end end  end 
              end else do
                throw Pervasives.Exit;
              end end 
            end else do
              throw Pervasives.Exit;
            end end 
          end
          catch (exn)do
            if (exn == Caml_builtin_exceptions.not_found and allow_absent) then do
              _nl1 = nl;
              continue ;
            end
             end 
            if (exn == Pervasives.Exit) then do
              throw Caml_builtin_exceptions.not_found;
            end
             end 
            throw exn;
          end
        end
         end 
      end else do
        return ntl2;
      end end 
    end;
  end end;
  return complete(nl1, List.combine(nl2, tl2));
end end

function unify_package(env, unify_list, lv1, p1, n1, tl1, lv2, p2, n2, tl2) do
  ntl2 = complete_type_list(undefined, env, n1, lv2, --[[ Mty_ident ]]Block.__(0, {p2}), n2, tl2);
  ntl1 = complete_type_list(undefined, env, n2, lv2, --[[ Mty_ident ]]Block.__(0, {p1}), n1, tl1);
  Curry._2(unify_list, List.map((function (prim) do
              return prim[1];
            end end), ntl1), List.map((function (prim) do
              return prim[1];
            end end), ntl2));
  if (eq_package_path(env, p1, p2) or Curry._7(package_subtype.contents, env, p1, n1, tl1, p2, n2, tl2) and Curry._7(package_subtype.contents, env, p2, n2, tl2, p1, n1, tl1)) then do
    return --[[ () ]]0;
  end else do
    throw Caml_builtin_exceptions.not_found;
  end end 
end end

function unify_eq(env, t1, t2) do
  if (t1 == t2) then do
    return true;
  end else do
    match = umode.contents;
    if (match) then do
      try do
        Curry._2(TypePairs.find, unify_eq_set, order_type_pair(t1, t2));
        return true;
      end
      catch (exn)do
        if (exn == Caml_builtin_exceptions.not_found) then do
          return false;
        end else do
          throw exn;
        end end 
      end
    end else do
      return false;
    end end 
  end end 
end end

function unify(env, t1, t2) do
  if (t1 == t2) then do
    return --[[ () ]]0;
  end else do
    t1$1 = repr(t1);
    t2$1 = repr(t2);
    if (unify_eq(env.contents, t1$1, t2$1)) then do
      return --[[ () ]]0;
    end else do
      reset_tracing = check_trace_gadt_instances(env.contents);
      try do
        type_changed.contents = true;
        match = t1$1.desc;
        match$1 = t2$1.desc;
        exit = 0;
        if (typeof match == "number") then do
          exit = 1;
        end else do
          local ___conditional___=(match.tag | 0);
          do
             if ___conditional___ = 0--[[ Tvar ]] then do
                exit$1 = 0;
                if (typeof match$1 == "number" or not (match$1.tag == --[[ Tconstr ]]3 and deep_occur(t1$1, t2$1))) then do
                  exit$1 = 2;
                end else do
                  unify2(env, t1$1, t2$1);
                end end 
                if (exit$1 == 2) then do
                  occur(env.contents, t1$1, t2$1);
                  occur_univar(env.contents, t2$1);
                  link_type(t1$1, t2$1);
                  update_level(env.contents, t1$1.level, t2$1);
                end
                 end end else 
             if ___conditional___ = 3--[[ Tconstr ]] then do
                p1 = match[0];
                if (typeof match$1 == "number") then do
                  unify2(env, t1$1, t2$1);
                end else do
                  local ___conditional___=(match$1.tag | 0);
                  do
                     if ___conditional___ = 0--[[ Tvar ]] then do
                        if (deep_occur(t2$1, t1$1)) then do
                          unify2(env, t1$1, t2$1);
                        end else do
                          exit = 1;
                        end end end else 
                     if ___conditional___ = 3--[[ Tconstr ]] then do
                        if (match[1] or match$1[1]) then do
                          unify2(env, t1$1, t2$1);
                        end else do
                          p2 = match$1[0];
                          if (same(p1, p2) and not (has_cached_expansion(p1, match[2].contents) or has_cached_expansion(p2, match$1[2].contents))) then do
                            update_level(env.contents, t1$1.level, t2$1);
                            link_type(t1$1, t2$1);
                          end else if (env.contents.local_constraints and is_newtype(env.contents, p1) and is_newtype(env.contents, p2)) then do
                            try do
                              if (Caml_obj.caml_lessthan(find_newtype_level(env.contents, p1), find_newtype_level(env.contents, p2))) then do
                                unify(env, t1$1, try_expand_once(env.contents, t2$1));
                              end else do
                                unify(env, try_expand_once(env.contents, t1$1), t2$1);
                              end end 
                            end
                            catch (exn)do
                              if (exn == Cannot_expand) then do
                                unify2(env, t1$1, t2$1);
                              end else do
                                throw exn;
                              end end 
                            end
                          end else do
                            unify2(env, t1$1, t2$1);
                          end end  end 
                        end end end else 
                     do end end end
                    else do
                      unify2(env, t1$1, t2$1);
                      end end
                      
                  end
                end end end else 
             if ___conditional___ = 9--[[ Tunivar ]] then do
                if (typeof match$1 == "number") then do
                  unify2(env, t1$1, t2$1);
                end else do
                  local ___conditional___=(match$1.tag | 0);
                  do
                     if ___conditional___ = 0--[[ Tvar ]] then do
                        exit = 1;end else 
                     if ___conditional___ = 9--[[ Tunivar ]] then do
                        unify_univar(t1$1, t2$1, univar_pairs.contents);
                        update_level(env.contents, t1$1.level, t2$1);
                        link_type(t1$1, t2$1);end else 
                     do end end end
                    else do
                      unify2(env, t1$1, t2$1);
                      end end
                      
                  end
                end end end else 
             do end end end end
            else do
              exit = 1;
              end end
              
          end
        end end 
        if (exit == 1) then do
          if (typeof match$1 == "number" or match$1.tag) then do
            unify2(env, t1$1, t2$1);
          end else do
            occur(env.contents, t2$1, t1$1);
            occur_univar(env.contents, t1$1);
            link_type(t2$1, t1$1);
            update_level(env.contents, t2$1.level, t1$1);
          end end 
        end
         end 
        return reset_trace_gadt_instances(reset_tracing);
      end
      catch (raw_exn)do
        exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn$1[0] == Unify) then do
          reset_trace_gadt_instances(reset_tracing);
          throw {
                Unify,
                --[[ :: ]]{
                  --[[ tuple ]]{
                    t1$1,
                    t2$1
                  },
                  exn$1[1]
                }
              };
        end else do
          throw exn$1;
        end end 
      end
    end end 
  end end 
end end

function unify_kind(k1, k2) do
  k1$1 = field_kind_repr(k1);
  k2$1 = field_kind_repr(k2);
  if (k1$1 == k2$1) then do
    return --[[ () ]]0;
  end else do
    if (typeof k1$1 == "number") then do
      if (k1$1 == 0) then do
        if (typeof k2$1 == "number") then do
          if (k2$1 == 0) then do
            return --[[ () ]]0;
          end
           end 
        end else do
          return set_kind(k2$1[0], k1$1);
        end end 
      end
       end 
    end else do
      r = k1$1[0];
      if (not (typeof k2$1 == "number" and k2$1 ~= 0)) then do
        return set_kind(r, k2$1);
      end
       end 
    end end 
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ctype.ml",
            2624,
            37
          }
        };
  end end 
end end

function make_rowvar(level, use1, rest1, use2, rest2) do
  set_name = function (ty, name) do
    match = ty.desc;
    if (typeof match == "number" or match.tag or match[0] ~= undefined) then do
      return --[[ () ]]0;
    end else do
      log_type(ty);
      ty.desc = --[[ Tvar ]]Block.__(0, {name});
      return --[[ () ]]0;
    end end 
  end end;
  match = rest1.desc;
  match$1 = rest2.desc;
  name;
  exit = 0;
  if (typeof match == "number" or match.tag) then do
    exit = 1;
  end else do
    name1 = match[0];
    if (name1 ~= undefined) then do
      exit$1 = 0;
      if (typeof match$1 == "number" or match$1.tag) then do
        exit$1 = 2;
      end else do
        name2 = match$1[0];
        if (name2 ~= undefined) then do
          name = rest1.level <= rest2.level and name1 or name2;
        end else do
          exit$1 = 2;
        end end 
      end end 
      if (exit$1 == 2) then do
        if (use2) then do
          set_name(rest2, name1);
        end
         end 
        name = name1;
      end
       end 
    end else do
      exit = 1;
    end end 
  end end 
  if (exit == 1) then do
    if (typeof match$1 == "number" or match$1.tag) then do
      name = undefined;
    end else do
      name$1 = match$1[0];
      if (name$1 ~= undefined) then do
        if (use1) then do
          set_name(rest2, name$1);
        end
         end 
        name = name$1;
      end else do
        name = undefined;
      end end 
    end end 
  end
   end 
  if (use1) then do
    return rest1;
  end else if (use2) then do
    return rest2;
  end else do
    return newty2(level, --[[ Tvar ]]Block.__(0, {name}));
  end end  end 
end end

function unify_fields(env, ty1, ty2) do
  match = flatten_fields(ty1);
  rest1 = match[1];
  match$1 = flatten_fields(ty2);
  rest2 = match$1[1];
  match$2 = associate_fields(match[0], match$1[0]);
  miss2 = match$2[2];
  miss1 = match$2[1];
  l1 = repr(ty1).level;
  l2 = repr(ty2).level;
  va = make_rowvar(l1 < l2 and l1 or l2, miss2 == --[[ [] ]]0, rest1, miss1 == --[[ [] ]]0, rest2);
  d1 = rest1.desc;
  d2 = rest2.desc;
  try do
    unify(env, build_fields(l1)(miss1, va), rest2);
    unify(env, rest1, build_fields(l2)(miss2, va));
    return List.iter((function (param) do
                  t2 = param[4];
                  k2 = param[3];
                  t1 = param[2];
                  k1 = param[1];
                  n = param[0];
                  unify_kind(k1, k2);
                  try do
                    if (trace_gadt_instances.contents) then do
                      update_level(env.contents, va.level, t1);
                    end
                     end 
                    return unify(env, t1, t2);
                  end
                  catch (raw_exn)do
                    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn[0] == Unify) then do
                      desc_003 = newty2(current_level.contents, --[[ Tnil ]]0);
                      desc = --[[ Tfield ]]Block.__(5, {
                          n,
                          k1,
                          t1,
                          desc_003
                        });
                      desc_003$1 = newty2(current_level.contents, --[[ Tnil ]]0);
                      desc$1 = --[[ Tfield ]]Block.__(5, {
                          n,
                          k2,
                          t2,
                          desc_003$1
                        });
                      throw {
                            Unify,
                            --[[ :: ]]{
                              --[[ tuple ]]{
                                newty2(current_level.contents, desc),
                                newty2(current_level.contents, desc$1)
                              },
                              exn[1]
                            }
                          };
                    end
                     end 
                    throw exn;
                  end
                end end), match$2[0]);
  end
  catch (exn)do
    log_type(rest1);
    rest1.desc = d1;
    log_type(rest2);
    rest2.desc = d2;
    throw exn;
  end
end end

function unify_list(env, tl1, tl2) do
  if (List.length(tl1) ~= List.length(tl2)) then do
    throw {
          Unify,
          --[[ [] ]]0
        };
  end
   end 
  return List.iter2((function (param, param$1) do
                return unify(env, param, param$1);
              end end), tl1, tl2);
end end

function unify_row(env, row1, row2) do
  row1$1 = row_repr_aux(--[[ [] ]]0, row1);
  row2$1 = row_repr_aux(--[[ [] ]]0, row2);
  rm1 = row_more(row1$1);
  rm2 = row_more(row2$1);
  if (unify_eq(env.contents, rm1, rm2)) then do
    return --[[ () ]]0;
  end else do
    match = merge_row_fields(row1$1.row_fields, row2$1.row_fields);
    pairs = match[2];
    r2 = match[1];
    r1 = match[0];
    if (r1 ~= --[[ [] ]]0 and r2 ~= --[[ [] ]]0) then do
      ht = Hashtbl.create(undefined, List.length(r1));
      List.iter((function (param) do
              l = param[0];
              return Hashtbl.add(ht, hash_variant(l), l);
            end end), r1);
      List.iter((function (param) do
              l = param[0];
              try do
                throw {
                      Tags,
                      l,
                      Hashtbl.find(ht, hash_variant(l))
                    };
              end
              catch (exn)do
                if (exn == Caml_builtin_exceptions.not_found) then do
                  return --[[ () ]]0;
                end else do
                  throw exn;
                end end 
              end
            end end), r2);
    end
     end 
    fixed1 = row_fixed(row1$1);
    fixed2 = row_fixed(row2$1);
    more = fixed1 and rm1 or (
        fixed2 and rm2 or newty2(rm1.level < rm2.level and rm1.level or rm2.level, --[[ Tvar ]]Block.__(0, {undefined}))
      );
    fixed = fixed1 or fixed2;
    closed = row1$1.row_closed or row2$1.row_closed;
    keep = function (__switch) do
      return List.for_all((function (param) do
                    match = Curry._2(__switch, param[1], param[2]);
                    if (row_field_repr_aux(--[[ [] ]]0, match[0]) == --[[ Rabsent ]]0) then do
                      return true;
                    end else do
                      return row_field_repr_aux(--[[ [] ]]0, match[1]) ~= --[[ Rabsent ]]0;
                    end end 
                  end end), pairs);
    end end;
    empty = function (fields) do
      return List.for_all((function (param) do
                    return row_field_repr_aux(--[[ [] ]]0, param[1]) == --[[ Rabsent ]]0;
                  end end), fields);
    end end;
    if (closed and (empty(r1) or row2$1.row_closed) and (empty(r2) or row1$1.row_closed) and List.for_all((function (param) do
              if (row_field_repr_aux(--[[ [] ]]0, param[1]) == --[[ Rabsent ]]0) then do
                return true;
              end else do
                return row_field_repr_aux(--[[ [] ]]0, param[2]) == --[[ Rabsent ]]0;
              end end 
            end end), pairs)) then do
      throw {
            Unify,
            --[[ :: ]]{
              --[[ tuple ]]{
                mkvariant(--[[ [] ]]0, true),
                mkvariant(--[[ [] ]]0, true)
              },
              --[[ [] ]]0
            }
          };
    end
     end 
    name = row1$1.row_name ~= undefined and (row1$1.row_closed or empty(r2)) and (not row2$1.row_closed or keep((function (f1, f2) do
              return --[[ tuple ]]{
                      f1,
                      f2
                    };
            end end)) and empty(r1)) and row1$1.row_name or (
        row2$1.row_name ~= undefined and (row2$1.row_closed or empty(r1)) and (not row1$1.row_closed or keep((function (f1, f2) do
                  return --[[ tuple ]]{
                          f2,
                          f1
                        };
                end end)) and empty(r2)) and row2$1.row_name or undefined
      );
    set_more = function (row, rest) do
      rest$1 = closed and filter_row_fields(row.row_closed, rest) or rest;
      if (rest$1 ~= --[[ [] ]]0 and (row.row_closed or row_fixed(row)) or closed and row_fixed(row) and not row.row_closed) then do
        t1 = mkvariant(--[[ [] ]]0, true);
        t2 = mkvariant(rest$1, false);
        throw {
              Unify,
              --[[ :: ]]{
                row == row1$1 and --[[ tuple ]]{
                    t1,
                    t2
                  } or --[[ tuple ]]{
                    t2,
                    t1
                  },
                --[[ [] ]]0
              }
            };
      end
       end 
      rm = row_more(row);
      if (not (trace_gadt_instances.contents and rm.desc == --[[ Tnil ]]0)) then do
        if (trace_gadt_instances.contents) then do
          update_level(env.contents, rm.level, newty2(100000000, --[[ Tvariant ]]Block.__(8, {row})));
        end
         end 
      end
       end 
      if (row_fixed(row)) then do
        if (more == rm) then do
          return --[[ () ]]0;
        end else if (is_Tvar(rm)) then do
          return link_type(rm, more);
        end else do
          return unify(env, rm, more);
        end end  end 
      end else do
        ty = newty2(100000000, --[[ Tvariant ]]Block.__(8, {do
                  row_fields: rest$1,
                  row_more: more,
                  row_bound: --[[ () ]]0,
                  row_closed: closed,
                  row_fixed: fixed,
                  row_name: name
                end}));
        update_level(env.contents, rm.level, ty);
        return link_type(rm, ty);
      end end 
    end end;
    md1 = rm1.desc;
    md2 = rm2.desc;
    try do
      set_more(row2$1, r1);
      set_more(row1$1, r2);
      return List.iter((function (param) do
                    f2 = param[2];
                    f1 = param[1];
                    l = param[0];
                    try do
                      env$1 = env;
                      fixed1$1 = fixed1;
                      fixed2$1 = fixed2;
                      more$1 = more;
                      _f1 = f1;
                      _f2 = f2;
                      while(true) do
                        f2$1 = _f2;
                        f1$1 = _f1;
                        f1$2 = row_field_repr_aux(--[[ [] ]]0, f1$1);
                        f2$2 = row_field_repr_aux(--[[ [] ]]0, f2$1);
                        if (f1$2 == f2$2) then do
                          return --[[ () ]]0;
                        end else if (typeof f1$2 == "number") then do
                          if (typeof f2$2 == "number") then do
                            return --[[ () ]]0;
                          end else if (f2$2.tag) then do
                            if (f2$2[2]) then do
                              throw {
                                    Unify,
                                    --[[ [] ]]0
                                  };
                            end
                             end 
                            if (fixed2$1) then do
                              throw {
                                    Unify,
                                    --[[ [] ]]0
                                  };
                            end else do
                              return set_row_field(f2$2[3], f1$2);
                            end end 
                          end else do
                            throw {
                                  Unify,
                                  --[[ [] ]]0
                                };
                          end end  end 
                        end else if (f1$2.tag) then do
                          c1 = f1$2[0];
                          m1 = f1$2[2];
                          tl1 = f1$2[1];
                          e1 = f1$2[3];
                          if (typeof f2$2 == "number") then do
                            if (m1) then do
                              throw {
                                    Unify,
                                    --[[ [] ]]0
                                  };
                            end
                             end 
                            if (fixed1$1) then do
                              throw {
                                    Unify,
                                    --[[ [] ]]0
                                  };
                            end else do
                              return set_row_field(f1$2[3], f2$2);
                            end end 
                          end else if (f2$2.tag) then do
                            e2 = f2$2[3];
                            if (e1 == e2) then do
                              return --[[ () ]]0;
                            end else do
                              m2 = f2$2[2];
                              tl2 = f2$2[1];
                              c2 = f2$2[0];
                              redo = false;
                              if (m1 or m2 or fixed1$1 or fixed2$1 or rigid_variants.contents and (List.length(tl1) == 1 or List.length(tl2) == 1)) then do
                                match = Pervasives.$at(tl1, tl2);
                                tmp;
                                if (match) then do
                                  t1 = match[0];
                                  if (c1 or c2) then do
                                    throw {
                                          Unify,
                                          --[[ [] ]]0
                                        };
                                  end
                                   end 
                                  List.iter((function(t1)do
                                      return function (param) do
                                        return unify(env$1, t1, param);
                                      end end
                                      end(t1)), match[1]);
                                  tmp = e1.contents ~= undefined or e2.contents ~= undefined;
                                end else do
                                  tmp = false;
                                end end 
                                redo = tmp;
                              end
                               end 
                              if (redo) then do
                                _f2 = f2$2;
                                _f1 = f1$2;
                                continue ;
                              end else do
                                tl1$1 = List.map(repr, tl1);
                                tl2$1 = List.map(repr, tl2);
                                remq = function (tl, _param) do
                                  while(true) do
                                    param = _param;
                                    if (param) then do
                                      tl$prime = param[1];
                                      ty = param[0];
                                      if (List.memq(ty, tl)) then do
                                        _param = tl$prime;
                                        continue ;
                                      end else do
                                        return --[[ :: ]]{
                                                ty,
                                                remq(tl, tl$prime)
                                              };
                                      end end 
                                    end else do
                                      return --[[ [] ]]0;
                                    end end 
                                  end;
                                end end;
                                tl2$prime = remq(tl2$1, tl1$1);
                                tl1$prime = remq(tl1$1, tl2$1);
                                partial_arg = repr(more$1).level;
                                partial_arg$1 = env$1.contents;
                                List.iter((function(partial_arg,partial_arg$1)do
                                    return function (param) do
                                      return update_level(partial_arg$1, partial_arg, param);
                                    end end
                                    end(partial_arg,partial_arg$1)), Pervasives.$at(tl1$prime, tl2$prime));
                                e = do
                                  contents: undefined
                                end;
                                f1$prime_000 = c1 or c2;
                                f1$prime_002 = m1 or m2;
                                f1$prime = --[[ Reither ]]Block.__(1, {
                                    f1$prime_000,
                                    tl1$prime,
                                    f1$prime_002,
                                    e
                                  });
                                f2$prime_000 = c1 or c2;
                                f2$prime_002 = m1 or m2;
                                f2$prime = --[[ Reither ]]Block.__(1, {
                                    f2$prime_000,
                                    tl2$prime,
                                    f2$prime_002,
                                    e
                                  });
                                set_row_field(e1, f1$prime);
                                return set_row_field(e2, f2$prime);
                              end end 
                            end end 
                          end else if (c1) then do
                            if (f1$2[1]) then do
                              throw {
                                    Unify,
                                    --[[ [] ]]0
                                  };
                            end
                             end 
                            if (f2$2[0] ~= undefined) then do
                              throw {
                                    Unify,
                                    --[[ [] ]]0
                                  };
                            end
                             end 
                            if (fixed1$1) then do
                              throw {
                                    Unify,
                                    --[[ [] ]]0
                                  };
                            end else do
                              return set_row_field(f1$2[3], f2$2);
                            end end 
                          end else do
                            match$1 = f2$2[0];
                            if (match$1 ~= undefined) then do
                              if (fixed1$1) then do
                                throw {
                                      Unify,
                                      --[[ [] ]]0
                                    };
                              end else do
                                t2 = match$1;
                                e1$1 = f1$2[3];
                                set_row_field(e1$1, f2$2);
                                update_level(env$1.contents, repr(more$1).level, t2);
                                try do
                                  return List.iter((function(t2)do
                                            return function (t1) do
                                              return unify(env$1, t1, t2);
                                            end end
                                            end(t2)), f1$2[1]);
                                end
                                catch (exn)do
                                  e1$1.contents = undefined;
                                  throw exn;
                                end
                              end end 
                            end else do
                              throw {
                                    Unify,
                                    --[[ [] ]]0
                                  };
                            end end 
                          end end  end  end 
                        end else do
                          match$2 = f1$2[0];
                          if (match$2 ~= undefined) then do
                            t1$1 = match$2;
                            if (typeof f2$2 == "number") then do
                              throw {
                                    Unify,
                                    --[[ [] ]]0
                                  };
                            end else if (f2$2.tag) then do
                              if (f2$2[0]) then do
                                throw {
                                      Unify,
                                      --[[ [] ]]0
                                    };
                              end
                               end 
                              if (fixed2$1) then do
                                throw {
                                      Unify,
                                      --[[ [] ]]0
                                    };
                              end else do
                                e2$1 = f2$2[3];
                                set_row_field(e2$1, f1$2);
                                update_level(env$1.contents, repr(more$1).level, t1$1);
                                try do
                                  return List.iter((function(t1$1)do
                                            return function (param) do
                                              return unify(env$1, t1$1, param);
                                            end end
                                            end(t1$1)), f2$2[1]);
                                end
                                catch (exn$1)do
                                  e2$1.contents = undefined;
                                  throw exn$1;
                                end
                              end end 
                            end else do
                              match$3 = f2$2[0];
                              if (match$3 ~= undefined) then do
                                return unify(env$1, t1$1, match$3);
                              end else do
                                throw {
                                      Unify,
                                      --[[ [] ]]0
                                    };
                              end end 
                            end end  end 
                          end else if (typeof f2$2 == "number") then do
                            throw {
                                  Unify,
                                  --[[ [] ]]0
                                };
                          end else if (f2$2.tag) then do
                            if (f2$2[0]) then do
                              if (f2$2[1]) then do
                                throw {
                                      Unify,
                                      --[[ [] ]]0
                                    };
                              end
                               end 
                              if (fixed2$1) then do
                                throw {
                                      Unify,
                                      --[[ [] ]]0
                                    };
                              end else do
                                return set_row_field(f2$2[3], f1$2);
                              end end 
                            end else do
                              throw {
                                    Unify,
                                    --[[ [] ]]0
                                  };
                            end end 
                          end else if (f2$2[0] ~= undefined) then do
                            throw {
                                  Unify,
                                  --[[ [] ]]0
                                };
                          end else do
                            return --[[ () ]]0;
                          end end  end  end  end 
                        end end  end  end 
                      end;
                    end
                    catch (raw_exn)do
                      exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn);
                      if (exn$2[0] == Unify) then do
                        throw {
                              Unify,
                              --[[ :: ]]{
                                --[[ tuple ]]{
                                  mkvariant(--[[ :: ]]{
                                        --[[ tuple ]]{
                                          l,
                                          f1
                                        },
                                        --[[ [] ]]0
                                      }, true),
                                  mkvariant(--[[ :: ]]{
                                        --[[ tuple ]]{
                                          l,
                                          f2
                                        },
                                        --[[ [] ]]0
                                      }, true)
                                },
                                exn$2[1]
                              }
                            };
                      end
                       end 
                      throw exn$2;
                    end
                  end end), pairs);
    end
    catch (exn)do
      log_type(rm1);
      rm1.desc = md1;
      log_type(rm2);
      rm2.desc = md2;
      throw exn;
    end
  end end 
end end

function unify3(env, t1, t1$prime, t2, t2$prime) do
  d1 = t1$prime.desc;
  d2 = t2$prime.desc;
  create_recursion = t2 ~= t2$prime and deep_occur(t1$prime, t2);
  exit = 0;
  exit$1 = 0;
  if (typeof d1 == "number") then do
    exit$1 = 2;
  end else do
    local ___conditional___=(d1.tag | 0);
    do
       if ___conditional___ = 0--[[ Tvar ]] then do
          occur(env.contents, t1$prime, t2);
          occur_univar(env.contents, t2);
          return link_type(t1$prime, t2);end end end 
       if ___conditional___ = 5--[[ Tfield ]] then do
          if (typeof d2 == "number") then do
            exit = 1;
          end else do
            local ___conditional___=(d2.tag | 0);
            do
               if ___conditional___ = 0--[[ Tvar ]] then do
                  exit$1 = 2;end else 
               if ___conditional___ = 5--[[ Tfield ]] then do
                  return unify_fields(env, t1$prime, t2$prime);end end end 
               do end
              else do
                exit = 1;
                end end
                
            end
          end end end else 
       if ___conditional___ = 9--[[ Tunivar ]] then do
          if (typeof d2 == "number") then do
            exit = 1;
          end else do
            local ___conditional___=(d2.tag | 0);
            do
               if ___conditional___ = 0--[[ Tvar ]] then do
                  exit$1 = 2;end else 
               if ___conditional___ = 9--[[ Tunivar ]] then do
                  unify_univar(t1$prime, t2$prime, univar_pairs.contents);
                  return link_type(t1$prime, t2$prime);end end end 
               do end
              else do
                exit = 1;
                end end
                
            end
          end end end else 
       do end end
      else do
        exit$1 = 2;
        end end
        
    end
  end end 
  if (exit$1 == 2) then do
    if (typeof d2 == "number" or d2.tag) then do
      exit = 1;
    end else do
      occur(env.contents, t2$prime, t1);
      occur_univar(env.contents, t1);
      return link_type(t2$prime, t1);
    end end 
  end
   end 
  if (exit == 1) then do
    match = umode.contents;
    if (match) then do
      add_type_equality(t1$prime, t2$prime);
    end else do
      occur(env.contents, t1$prime, t2$prime);
      link_type(t1$prime, t2);
    end end 
    try do
      exit$2 = 0;
      f;
      kind;
      rem;
      exit$3 = 0;
      exit$4 = 0;
      if (typeof d1 == "number") then do
        if (typeof d2 ~= "number") then do
          local ___conditional___=(d2.tag | 0);
          do
             if ___conditional___ = 3--[[ Tconstr ]] then do
                exit$4 = 5;end else 
             if ___conditional___ = 5--[[ Tfield ]] then do
                f = d2[0];
                kind = d2[1];
                rem = d2[3];
                exit$2 = 3;end else 
             do end end end
            else do
              throw {
                    Unify,
                    --[[ [] ]]0
                  };
              end end
              
          end
        end
         end 
      end else do
        local ___conditional___=(d1.tag | 0);
        do
           if ___conditional___ = 1--[[ Tarrow ]] then do
              l1 = d1[0];
              if (typeof d2 == "number") then do
                throw {
                      Unify,
                      --[[ [] ]]0
                    };
              end else do
                local ___conditional___=(d2.tag | 0);
                do
                   if ___conditional___ = 1--[[ Tarrow ]] then do
                      l2 = d2[0];
                      if (l1 == l2 or classic.contents and not (is_optional(l1) or is_optional(l2))) then do
                        unify(env, d1[1], d2[1]);
                        unify(env, d1[2], d2[2]);
                        match$1 = commu_repr(d1[3]);
                        match$2 = commu_repr(d2[3]);
                        if (typeof match$1 == "number") then do
                          if (typeof match$2 == "number") then do
                            
                          end else do
                            set_commu(match$2[0], match$1);
                          end end 
                        end else do
                          set_commu(match$1[0], match$2);
                        end end 
                      end else do
                        throw {
                              Unify,
                              --[[ [] ]]0
                            };
                      end end end else 
                   if ___conditional___ = 3--[[ Tconstr ]] then do
                      exit$4 = 5;end else 
                   do end end end
                  else do
                    throw {
                          Unify,
                          --[[ [] ]]0
                        };
                    end end
                    
                end
              end end end else 
           if ___conditional___ = 2--[[ Ttuple ]] then do
              if (typeof d2 == "number") then do
                throw {
                      Unify,
                      --[[ [] ]]0
                    };
              end else do
                local ___conditional___=(d2.tag | 0);
                do
                   if ___conditional___ = 2--[[ Ttuple ]] then do
                      unify_list(env, d1[0], d2[0]);end else 
                   if ___conditional___ = 3--[[ Tconstr ]] then do
                      exit$4 = 5;end else 
                   do end end end
                  else do
                    throw {
                          Unify,
                          --[[ [] ]]0
                        };
                    end end
                    
                end
              end end end else 
           if ___conditional___ = 3--[[ Tconstr ]] then do
              p1 = d1[0];
              exit$5 = 0;
              if (typeof d2 == "number" or d2.tag ~= --[[ Tconstr ]]3) then do
                exit$5 = 6;
              end else do
                tl2 = d2[1];
                tl1 = d1[1];
                if (same(p1, d2[0])) then do
                  if (umode.contents == --[[ Expression ]]0 or not generate_equations.contents) then do
                    unify_list(env, tl1, tl2);
                  end else if (assume_injective.contents) then do
                    set_mode_pattern(true, false, (function (param) do
                            return unify_list(env, tl1, tl2);
                          end end));
                  end else do
                    tmp = true;
                    if (not in_current_module(p1)) then do
                      partial_arg = env.contents;
                      tmp = List.exists((function (param) do
                              return expands_to_datatype(partial_arg, param);
                            end end), --[[ :: ]]{
                            t1$prime,
                            --[[ :: ]]{
                              t1,
                              --[[ :: ]]{
                                t2,
                                --[[ [] ]]0
                              }
                            }
                          });
                    end
                     end 
                    if (tmp) then do
                      unify_list(env, tl1, tl2);
                    end else do
                      inj;
                      try do
                        inj = List.map(Curry._1(Types_Variance.mem, --[[ Inj ]]3), find_type_full(p1, env.contents)[0].type_variance);
                      end
                      catch (exn)do
                        if (exn == Caml_builtin_exceptions.not_found) then do
                          inj = List.map((function (param) do
                                  return false;
                                end end), tl1);
                        end else do
                          throw exn;
                        end end 
                      end
                      List.iter2((function (i, param) do
                              t2 = param[1];
                              t1 = param[0];
                              if (i) then do
                                return unify(env, t1, t2);
                              end else do
                                return set_mode_pattern(false, false, (function (param) do
                                              snap = snapshot(--[[ () ]]0);
                                              try do
                                                return unify(env, t1, t2);
                                              end
                                              catch (raw_exn)do
                                                exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                                                if (exn[0] == Unify) then do
                                                  backtrack(snap);
                                                  reify(env, t1);
                                                  return reify(env, t2);
                                                end else do
                                                  throw exn;
                                                end end 
                                              end
                                            end end));
                              end end 
                            end end), inj, List.combine(tl1, tl2));
                    end end 
                  end end  end 
                end else do
                  exit$5 = 6;
                end end 
              end end 
              if (exit$5 == 6) then do
                local ___conditional___=(p1.tag | 0);
                do
                   if ___conditional___ = 0--[[ Pident ]] then do
                      if (d1[1]) then do
                        exit$4 = 5;
                      end else do
                        p = p1[0];
                        exit$6 = 0;
                        if (typeof d2 == "number" or d2.tag ~= --[[ Tconstr ]]3) then do
                          exit$6 = 7;
                        end else do
                          path$prime = d2[0];
                          local ___conditional___=(path$prime.tag | 0);
                          do
                             if ___conditional___ = 0--[[ Pident ]] then do
                                if (d2[1] or not (is_newtype(env.contents, p1) and is_newtype(env.contents, path$prime) and generate_equations.contents)) then do
                                  exit$6 = 7;
                                end else do
                                  match$3 = Caml_obj.caml_greaterthan(find_newtype_level(env.contents, p1), find_newtype_level(env.contents, path$prime)) and --[[ tuple ]]{
                                      p,
                                      t2$prime
                                    } or --[[ tuple ]]{
                                      path$prime[0],
                                      t1$prime
                                    };
                                  add_gadt_equation(env, match$3[0], match$3[1]);
                                end end end else 
                             if ___conditional___ = 1--[[ Pdot ]]
                             or ___conditional___ = 2--[[ Papply ]] then do
                                exit$6 = 7;end else 
                             do end end end
                            
                          end
                        end end 
                        if (exit$6 == 7) then do
                          if (is_newtype(env.contents, p1) and generate_equations.contents) then do
                            reify(env, t2$prime);
                            add_gadt_equation(env, p, t2$prime);
                          end else do
                            exit$4 = 5;
                          end end 
                        end
                         end 
                      end end end else 
                   if ___conditional___ = 1--[[ Pdot ]]
                   or ___conditional___ = 2--[[ Papply ]] then do
                      exit$4 = 5;end else 
                   do end end end
                  
                end
              end
               end end else 
           if ___conditional___ = 4--[[ Tobject ]] then do
              nm1 = d1[1];
              if (typeof d2 == "number") then do
                throw {
                      Unify,
                      --[[ [] ]]0
                    };
              end else do
                local ___conditional___=(d2.tag | 0);
                do
                   if ___conditional___ = 3--[[ Tconstr ]] then do
                      exit$4 = 5;end else 
                   if ___conditional___ = 4--[[ Tobject ]] then do
                      unify_fields(env, d1[0], d2[0]);
                      match$4 = repr(t2$prime).desc;
                      if (typeof match$4 ~= "number" and match$4.tag == --[[ Tobject ]]4) then do
                        nm2 = match$4[1];
                        match$5 = nm2.contents;
                        if (match$5 ~= undefined) then do
                          match$6 = match$5[1];
                          if (match$6) then do
                            match$7 = repr(match$6[0]).desc;
                            tmp$1;
                            if (typeof match$7 == "number") then do
                              tmp$1 = true;
                            end else do
                              local ___conditional___=(match$7.tag | 0);
                              do
                                 if ___conditional___ = 0--[[ Tvar ]]
                                 or ___conditional___ = 9--[[ Tunivar ]] then do
                                    tmp$1 = true;end else 
                                 do end end
                                else do
                                  tmp$1 = false;
                                  end end
                                  
                              end
                            end end 
                            if (not tmp$1) then do
                              set_name(nm2, nm1.contents);
                            end
                             end 
                          end else do
                            set_name(nm2, nm1.contents);
                          end end 
                        end else do
                          set_name(nm2, nm1.contents);
                        end end 
                      end
                       end end else 
                   do end end end
                  else do
                    throw {
                          Unify,
                          --[[ [] ]]0
                        };
                    end end
                    
                end
              end end end else 
           if ___conditional___ = 5--[[ Tfield ]] then do
              if (typeof d2 == "number") then do
                f = d1[0];
                kind = d1[1];
                rem = d1[3];
                exit$2 = 3;
              end else if (d2.tag == --[[ Tconstr ]]3) then do
                exit$4 = 5;
              end else do
                throw {
                      Unify,
                      --[[ [] ]]0
                    };
              end end  end end else 
           if ___conditional___ = 8--[[ Tvariant ]] then do
              row1 = d1[0];
              if (typeof d2 == "number") then do
                throw {
                      Unify,
                      --[[ [] ]]0
                    };
              end else do
                local ___conditional___=(d2.tag | 0);
                do
                   if ___conditional___ = 3--[[ Tconstr ]] then do
                      exit$4 = 5;end else 
                   if ___conditional___ = 8--[[ Tvariant ]] then do
                      row2 = d2[0];
                      if (umode.contents == --[[ Expression ]]0) then do
                        unify_row(env, row1, row2);
                      end else do
                        snap = snapshot(--[[ () ]]0);
                        try do
                          unify_row(env, row1, row2);
                        end
                        catch (raw_exn)do
                          exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn);
                          if (exn$1[0] == Unify) then do
                            backtrack(snap);
                            reify(env, t1$prime);
                            reify(env, t2$prime);
                            if (generate_equations.contents) then do
                              mcomp$1(env.contents, t1$prime, t2$prime);
                            end
                             end 
                          end else do
                            throw exn$1;
                          end end 
                        end
                      end end end else 
                   do end end end
                  else do
                    throw {
                          Unify,
                          --[[ [] ]]0
                        };
                    end end
                    
                end
              end end end else 
           if ___conditional___ = 10--[[ Tpoly ]] then do
              tl1$1 = d1[1];
              t1$1 = d1[0];
              exit$7 = 0;
              if (tl1$1) then do
                exit$7 = 6;
              end else if (typeof d2 == "number") then do
                throw {
                      Unify,
                      --[[ [] ]]0
                    };
              end else do
                local ___conditional___=(d2.tag | 0);
                do
                   if ___conditional___ = 3--[[ Tconstr ]] then do
                      exit$4 = 5;end else 
                   if ___conditional___ = 10--[[ Tpoly ]] then do
                      if (d2[1]) then do
                        exit$7 = 6;
                      end else do
                        unify(env, t1$1, d2[0]);
                      end end end else 
                   do end end end
                  else do
                    throw {
                          Unify,
                          --[[ [] ]]0
                        };
                    end end
                    
                end
              end end  end 
              if (exit$7 == 6) then do
                if (typeof d2 == "number") then do
                  throw {
                        Unify,
                        --[[ [] ]]0
                      };
                end else do
                  local ___conditional___=(d2.tag | 0);
                  do
                     if ___conditional___ = 3--[[ Tconstr ]] then do
                        exit$4 = 5;end else 
                     if ___conditional___ = 10--[[ Tpoly ]] then do
                        enter_poly(env.contents, univar_pairs, t1$1, tl1$1, d2[0], d2[1], (function (param, param$1) do
                                return unify(env, param, param$1);
                              end end));end else 
                     do end end end
                    else do
                      throw {
                            Unify,
                            --[[ [] ]]0
                          };
                      end end
                      
                  end
                end end 
              end
               end end else 
           if ___conditional___ = 11--[[ Tpackage ]] then do
              tl1$2 = d1[2];
              if (typeof d2 == "number") then do
                throw {
                      Unify,
                      --[[ [] ]]0
                    };
              end else do
                local ___conditional___=(d2.tag | 0);
                do
                   if ___conditional___ = 3--[[ Tconstr ]] then do
                      exit$4 = 5;end else 
                   if ___conditional___ = 11--[[ Tpackage ]] then do
                      tl2$1 = d2[2];
                      try do
                        unify_package(env.contents, (function (param, param$1) do
                                return unify_list(env, param, param$1);
                              end end), t1.level, d1[0], d1[1], tl1$2, t2.level, d2[0], d2[1], tl2$1);
                      end
                      catch (exn$2)do
                        if (exn$2 == Caml_builtin_exceptions.not_found) then do
                          if (umode.contents == --[[ Expression ]]0) then do
                            throw {
                                  Unify,
                                  --[[ [] ]]0
                                };
                          end
                           end 
                          List.iter((function (param) do
                                  return reify(env, param);
                                end end), Pervasives.$at(tl1$2, tl2$1));
                        end else do
                          throw exn$2;
                        end end 
                      endend else 
                   do end end end
                  else do
                    throw {
                          Unify,
                          --[[ [] ]]0
                        };
                    end end
                    
                end
              end end end else 
           do end end end end end end end end end
          else do
            exit$4 = 5;
            end end
            
        end
      end end 
      if (exit$4 == 5) then do
        if (typeof d2 == "number" or d2.tag ~= --[[ Tconstr ]]3) then do
          exit$3 = 4;
        end else do
          path = d2[0];
          local ___conditional___=(path.tag | 0);
          do
             if ___conditional___ = 0--[[ Pident ]] then do
                if (d2[1] or not (is_newtype(env.contents, path) and generate_equations.contents)) then do
                  exit$2 = 2;
                end else do
                  reify(env, t1$prime);
                  add_gadt_equation(env, path[0], t1$prime);
                end end end else 
             if ___conditional___ = 1--[[ Pdot ]]
             or ___conditional___ = 2--[[ Papply ]] then do
                exit$2 = 2;end else 
             do end end end
            
          end
        end end 
      end
       end 
      if (exit$3 == 4) then do
        if (typeof d1 == "number") then do
          throw {
                Unify,
                --[[ [] ]]0
              };
        end else if (d1.tag == --[[ Tconstr ]]3) then do
          exit$2 = 2;
        end else do
          throw {
                Unify,
                --[[ [] ]]0
              };
        end end  end 
      end
       end 
      local ___conditional___=(exit$2);
      do
         if ___conditional___ = 2 then do
            if (umode.contents == --[[ Pattern ]]1) then do
              reify(env, t1$prime);
              reify(env, t2$prime);
              if (generate_equations.contents) then do
                mcomp$1(env.contents, t1$prime, t2$prime);
              end
               end 
            end else do
              throw {
                    Unify,
                    --[[ [] ]]0
                  };
            end end end else 
         if ___conditional___ = 3 then do
            match$8 = field_kind_repr(kind);
            if (typeof match$8 == "number") then do
              throw {
                    Unify,
                    --[[ [] ]]0
                  };
            end
             end 
            if (f ~= dummy_method) then do
              set_kind(match$8[0], --[[ Fabsent ]]1);
              if (d2 == --[[ Tnil ]]0) then do
                unify(env, rem, t2$prime);
              end else do
                unify(env, newty2(rem.level, --[[ Tnil ]]0), rem);
              end end 
            end else do
              throw {
                    Unify,
                    --[[ [] ]]0
                  };
            end end end else 
         do end end end
        
      end
      if (create_recursion) then do
        match$9 = t2.desc;
        if (typeof match$9 == "number" or match$9.tag ~= --[[ Tconstr ]]3) then do
          return --[[ () ]]0;
        end else do
          forget_abbrev(match$9[2], match$9[0]);
          t2$prime$prime = expand_head_unif(env.contents, t2);
          if (closed_parameterized_type(match$9[1], t2$prime$prime)) then do
            return 0;
          end else do
            return link_type(repr(t2), repr(t2$prime));
          end end 
        end end 
      end else do
        return 0;
      end end 
    end
    catch (raw_exn$1)do
      exn$3 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
      if (exn$3[0] == Unify) then do
        t1$prime.desc = d1;
        throw {
              Unify,
              exn$3[1]
            };
      end else do
        throw exn$3;
      end end 
    end
  end
   end 
end end

function unify2(env, t1, t2) do
  expand_both = function (_t1$prime$prime, _t2$prime$prime) do
    while(true) do
      t2$prime$prime = _t2$prime$prime;
      t1$prime$prime = _t1$prime$prime;
      t1$prime = expand_head_unif(env.contents, t1);
      t2$prime = expand_head_unif(env.contents, t2);
      if (unify_eq(env.contents, t1$prime, t1$prime$prime) and unify_eq(env.contents, t2$prime, t2$prime$prime)) then do
        return --[[ tuple ]]{
                t1$prime,
                t2$prime
              };
      end else do
        _t2$prime$prime = t2$prime;
        _t1$prime$prime = t1$prime;
        continue ;
      end end 
    end;
  end end;
  match = expand_both(t1, t2);
  t2$prime = match[1];
  t1$prime = match[0];
  lv = t1$prime.level < t2$prime.level and t1$prime.level or t2$prime.level;
  update_level(env.contents, lv, t2);
  update_level(env.contents, lv, t1);
  if (unify_eq(env.contents, t1$prime, t2$prime)) then do
    return --[[ () ]]0;
  end else do
    t1$1 = repr(t1);
    t2$1 = repr(t2);
    if (trace_gadt_instances.contents) then do
      ilevel = function (t) do
        match = gadt_instance_level(env.contents, t);
        if (match ~= undefined) then do
          return match;
        end else do
          return 0;
        end end 
      end end;
      lv1 = ilevel(t1$1);
      lv2 = ilevel(t2$1);
      if (lv1 > lv2) then do
        add_gadt_instance_chain(env.contents, lv1, t2$1);
      end else if (lv2 > lv1) then do
        add_gadt_instance_chain(env.contents, lv2, t1$1);
      end
       end  end 
    end
     end 
    match$1;
    if (principal.contents and (find_lowest_level(t1$prime) < lv or find_lowest_level(t2$prime) < lv)) then do
      match$2 = t1$1.desc;
      tmp;
      tmp = typeof match$2 == "number" or not (match$2.tag == --[[ Tconstr ]]3 and not match$2[1]) and t1$1 or t1$prime;
      match$3 = t2$1.desc;
      tmp$1;
      tmp$1 = typeof match$3 == "number" or not (match$3.tag == --[[ Tconstr ]]3 and not match$3[1]) and t2$1 or t2$prime;
      match$1 = --[[ tuple ]]{
        tmp,
        tmp$1
      };
    end else do
      match$1 = --[[ tuple ]]{
        t1$1,
        t2$1
      };
    end end 
    t2$2 = match$1[1];
    t1$2 = match$1[0];
    if (unify_eq(env.contents, t1$2, t1$prime) or not unify_eq(env.contents, t2$2, t2$prime)) then do
      return unify3(env, t1$2, t1$prime, t2$2, t2$prime);
    end else do
      try do
        return unify3(env, t2$2, t2$prime, t1$2, t1$prime);
      end
      catch (raw_exn)do
        exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn[0] == Unify) then do
          throw {
                Unify,
                List.map((function (param) do
                        return --[[ tuple ]]{
                                param[1],
                                param[0]
                              };
                      end end), exn[1])
              };
        end
         end 
        throw exn;
      end
    end end 
  end end 
end end

function unify$1(env, ty1, ty2) do
  try do
    return unify(env, ty1, ty2);
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      throw {
            Unify,
            expand_trace(env.contents, exn[1])
          };
    end
     end 
    if (exn == Recursive_abbrev) then do
      throw {
            Unification_recursive_abbrev,
            expand_trace(env.contents, --[[ :: ]]{
                  --[[ tuple ]]{
                    ty1,
                    ty2
                  },
                  --[[ [] ]]0
                })
          };
    end
     end 
    throw exn;
  end
end end

function unify_var(env, t1, t2) do
  t1$1 = repr(t1);
  t2$1 = repr(t2);
  if (t1$1 == t2$1) then do
    return --[[ () ]]0;
  end else do
    match = t1$1.desc;
    if (typeof match == "number" or match.tag) then do
      return unify$1(do
                  contents: env
                end, t1$1, t2$1);
    end else do
      reset_tracing = check_trace_gadt_instances(env);
      try do
        occur(env, t1$1, t2$1);
        update_level(env, t1$1.level, t2$1);
        link_type(t1$1, t2$1);
        return reset_trace_gadt_instances(reset_tracing);
      end
      catch (raw_exn)do
        exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn[0] == Unify) then do
          reset_trace_gadt_instances(reset_tracing);
          expanded_trace = expand_trace(env, --[[ :: ]]{
                --[[ tuple ]]{
                  t1$1,
                  t2$1
                },
                exn[1]
              });
          throw {
                Unify,
                expanded_trace
              };
        end else do
          throw exn;
        end end 
      end
    end end 
  end end 
end end

unify$prime.contents = unify_var;

function unify_pairs(env, ty1, ty2, pairs) do
  univar_pairs.contents = pairs;
  return unify$1(env, ty1, ty2);
end end

function unify$2(env, ty1, ty2) do
  return unify_pairs(do
              contents: env
            end, ty1, ty2, --[[ [] ]]0);
end end

function expand_head_trace(env, t) do
  reset_tracing = check_trace_gadt_instances(env);
  t$1 = expand_head_unif(env, t);
  reset_trace_gadt_instances(reset_tracing);
  return t$1;
end end

function filter_arrow(env, t, l) do
  t$1 = expand_head_trace(env, t);
  match = t$1.desc;
  if (typeof match == "number") then do
    throw {
          Unify,
          --[[ [] ]]0
        };
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 0--[[ Tvar ]] then do
          lv = t$1.level;
          t1 = newty2(lv, --[[ Tvar ]]Block.__(0, {undefined}));
          t2 = newty2(lv, --[[ Tvar ]]Block.__(0, {undefined}));
          t$prime = newty2(lv, --[[ Tarrow ]]Block.__(1, {
                  l,
                  t1,
                  t2,
                  --[[ Cok ]]0
                }));
          link_type(t$1, t$prime);
          return --[[ tuple ]]{
                  t1,
                  t2
                };end end end 
       if ___conditional___ = 1--[[ Tarrow ]] then do
          l$prime = match[0];
          if (l == l$prime or classic.contents and l == "" and not is_optional(l$prime)) then do
            return --[[ tuple ]]{
                    match[1],
                    match[2]
                  };
          end else do
            throw {
                  Unify,
                  --[[ [] ]]0
                };
          end end end end end 
       do
      else do
        throw {
              Unify,
              --[[ [] ]]0
            };
        end end
        
    end
  end end 
end end

function filter_method_field(env, name, priv, _ty) do
  while(true) do
    ty = _ty;
    ty$1 = expand_head_trace(env, ty);
    match = ty$1.desc;
    if (typeof match == "number") then do
      throw {
            Unify,
            --[[ [] ]]0
          };
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 0--[[ Tvar ]] then do
            level = ty$1.level;
            ty1 = newty2(level, --[[ Tvar ]]Block.__(0, {undefined}));
            ty2 = newty2(level, --[[ Tvar ]]Block.__(0, {undefined}));
            ty$prime = newty2(level, --[[ Tfield ]]Block.__(5, {
                    name,
                    priv and --[[ Fpresent ]]0 or --[[ Fvar ]]{do
                          contents: undefined
                        end},
                    ty1,
                    ty2
                  }));
            link_type(ty$1, ty$prime);
            return ty1;end end end 
         if ___conditional___ = 5--[[ Tfield ]] then do
            kind = field_kind_repr(match[1]);
            if (match[0] == name and kind ~= --[[ Fabsent ]]1) then do
              if (priv == --[[ Public ]]1) then do
                unify_kind(kind, --[[ Fpresent ]]0);
              end
               end 
              return match[2];
            end else do
              _ty = match[3];
              continue ;
            end end end end end 
         do
        else do
          throw {
                Unify,
                --[[ [] ]]0
              };
          end end
          
      end
    end end 
  end;
end end

function filter_method(env, name, priv, ty) do
  ty$1 = expand_head_trace(env, ty);
  match = ty$1.desc;
  if (typeof match == "number") then do
    throw {
          Unify,
          --[[ [] ]]0
        };
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 0--[[ Tvar ]] then do
          ty1 = newvar(undefined, --[[ () ]]0);
          ty$prime = newobj(ty1);
          update_level(env, ty$1.level, ty$prime);
          link_type(ty$1, ty$prime);
          return filter_method_field(env, name, priv, ty1);end end end 
       if ___conditional___ = 4--[[ Tobject ]] then do
          return filter_method_field(env, name, priv, match[0]);end end end 
       do
      else do
        throw {
              Unify,
              --[[ [] ]]0
            };
        end end
        
    end
  end end 
end end

function filter_self_method(env, lab, priv, meths, ty) do
  ty$prime = filter_method(env, lab, priv, ty);
  try do
    return find(lab, meths.contents);
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      pair_000 = create(lab);
      pair = --[[ tuple ]]{
        pair_000,
        ty$prime
      };
      meths.contents = add$1(lab, pair, meths.contents);
      return pair;
    end else do
      throw exn;
    end end 
  end
end end

function moregen_occur(env, level, ty) do
  occur = function (ty) do
    ty$1 = repr(ty);
    if (ty$1.level > level) then do
      if (is_Tvar(ty$1) and ty$1.level >= 99999999) then do
        throw Occur;
      end
       end 
      ty$1.level = pivot_level - ty$1.level | 0;
      match = ty$1.desc;
      if (typeof match == "number" or match.tag ~= --[[ Tvariant ]]8) then do
        return iter_type_expr(occur, ty$1);
      end else do
        row = match[0];
        if (static_row(row)) then do
          return iter_row(occur, row);
        end else do
          return iter_type_expr(occur, ty$1);
        end end 
      end end 
    end else do
      return 0;
    end end 
  end end;
  try do
    occur(ty);
    unmark_type(ty);
  end
  catch (exn)do
    if (exn == Occur) then do
      unmark_type(ty);
      throw {
            Unify,
            --[[ [] ]]0
          };
    end else do
      throw exn;
    end end 
  end
  occur_univar(env, ty);
  return update_level(env, level, ty);
end end

function may_instantiate(inst_nongen, t1) do
  if (inst_nongen) then do
    return t1.level ~= 99999999;
  end else do
    return t1.level == 100000000;
  end end 
end end

function moregen(inst_nongen, type_pairs, env, t1, t2) do
  if (t1 == t2) then do
    return --[[ () ]]0;
  end else do
    t1$1 = repr(t1);
    t2$1 = repr(t2);
    if (t1$1 == t2$1) then do
      return --[[ () ]]0;
    end else do
      try do
        match = t1$1.desc;
        match$1 = t2$1.desc;
        exit = 0;
        if (typeof match == "number") then do
          exit = 1;
        end else do
          local ___conditional___=(match.tag | 0);
          do
             if ___conditional___ = 0--[[ Tvar ]] then do
                if (may_instantiate(inst_nongen, t1$1)) then do
                  moregen_occur(env, t1$1.level, t2$1);
                  occur(env, t1$1, t2$1);
                  return link_type(t1$1, t2$1);
                end else do
                  exit = 1;
                end end end else 
             if ___conditional___ = 3--[[ Tconstr ]] then do
                if (match[1] or typeof match$1 == "number" or not (match$1.tag == --[[ Tconstr ]]3 and not (match$1[1] or not same(match[0], match$1[0])))) then do
                  exit = 1;
                end else do
                  return --[[ () ]]0;
                end end end else 
             do end end end
            else do
              exit = 1;
              end end
              
          end
        end end 
        if (exit == 1) then do
          t1$prime = expand_head(env, t1$1);
          t2$prime = expand_head(env, t2$1);
          t1$prime$1 = repr(t1$prime);
          t2$prime$1 = repr(t2$prime);
          if (t1$prime$1 == t2$prime$1) then do
            return --[[ () ]]0;
          end else do
            try do
              return Curry._2(TypePairs.find, type_pairs, --[[ tuple ]]{
                          t1$prime$1,
                          t2$prime$1
                        });
            end
            catch (exn)do
              if (exn == Caml_builtin_exceptions.not_found) then do
                Curry._3(TypePairs.add, type_pairs, --[[ tuple ]]{
                      t1$prime$1,
                      t2$prime$1
                    }, --[[ () ]]0);
                match$2 = t1$prime$1.desc;
                match$3 = t2$prime$1.desc;
                if (typeof match$2 == "number") then do
                  if (typeof match$3 == "number") then do
                    return --[[ () ]]0;
                  end else do
                    throw {
                          Unify,
                          --[[ [] ]]0
                        };
                  end end 
                end else do
                  local ___conditional___=(match$2.tag | 0);
                  do
                     if ___conditional___ = 0--[[ Tvar ]] then do
                        if (may_instantiate(inst_nongen, t1$prime$1)) then do
                          moregen_occur(env, t1$prime$1.level, t2$1);
                          return link_type(t1$prime$1, t2$1);
                        end else do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end end end end end 
                     if ___conditional___ = 1--[[ Tarrow ]] then do
                        if (typeof match$3 == "number") then do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end else if (match$3.tag == --[[ Tarrow ]]1) then do
                          l2 = match$3[0];
                          l1 = match$2[0];
                          if (l1 == l2 or classic.contents and not (is_optional(l1) or is_optional(l2))) then do
                            moregen(inst_nongen, type_pairs, env, match$2[1], match$3[1]);
                            return moregen(inst_nongen, type_pairs, env, match$2[2], match$3[2]);
                          end else do
                            throw {
                                  Unify,
                                  --[[ [] ]]0
                                };
                          end end 
                        end else do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end end  end end end end 
                     if ___conditional___ = 2--[[ Ttuple ]] then do
                        if (typeof match$3 == "number") then do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end else if (match$3.tag == --[[ Ttuple ]]2) then do
                          return moregen_list(inst_nongen, type_pairs, env, match$2[0], match$3[0]);
                        end else do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end end  end end end end 
                     if ___conditional___ = 3--[[ Tconstr ]] then do
                        if (typeof match$3 == "number") then do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end else if (match$3.tag == --[[ Tconstr ]]3) then do
                          if (same(match$2[0], match$3[0])) then do
                            return moregen_list(inst_nongen, type_pairs, env, match$2[1], match$3[1]);
                          end else do
                            throw {
                                  Unify,
                                  --[[ [] ]]0
                                };
                          end end 
                        end else do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end end  end end end end 
                     if ___conditional___ = 4--[[ Tobject ]] then do
                        if (typeof match$3 == "number") then do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end else if (match$3.tag == --[[ Tobject ]]4) then do
                          return moregen_fields(inst_nongen, type_pairs, env, match$2[0], match$3[0]);
                        end else do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end end  end end end end 
                     if ___conditional___ = 5--[[ Tfield ]] then do
                        if (typeof match$3 == "number") then do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end else if (match$3.tag == --[[ Tfield ]]5) then do
                          return moregen_fields(inst_nongen, type_pairs, env, t1$prime$1, t2$prime$1);
                        end else do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end end  end end end end 
                     if ___conditional___ = 6--[[ Tlink ]]
                     or ___conditional___ = 7--[[ Tsubst ]] then do
                        throw {
                              Unify,
                              --[[ [] ]]0
                            };end end end 
                     if ___conditional___ = 8--[[ Tvariant ]] then do
                        if (typeof match$3 == "number") then do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end else if (match$3.tag == --[[ Tvariant ]]8) then do
                          inst_nongen$1 = inst_nongen;
                          type_pairs$1 = type_pairs;
                          env$1 = env;
                          row1 = match$2[0];
                          row2 = match$3[0];
                          row1$1 = row_repr_aux(--[[ [] ]]0, row1);
                          row2$1 = row_repr_aux(--[[ [] ]]0, row2);
                          rm1 = repr(row1$1.row_more);
                          rm2 = repr(row2$1.row_more);
                          if (rm1 == rm2) then do
                            return --[[ () ]]0;
                          end else do
                            may_inst = is_Tvar(rm1) and may_instantiate(inst_nongen$1, rm1) or rm1.desc == --[[ Tnil ]]0;
                            match$4 = merge_row_fields(row1$1.row_fields, row2$1.row_fields);
                            r2 = match$4[1];
                            r1 = match$4[0];
                            match$5 = row2$1.row_closed and --[[ tuple ]]{
                                filter_row_fields(may_inst, r1),
                                filter_row_fields(false, r2)
                              } or --[[ tuple ]]{
                                r1,
                                r2
                              };
                            r2$1 = match$5[1];
                            if (match$5[0] ~= --[[ [] ]]0 or row1$1.row_closed and (not row2$1.row_closed or r2$1 ~= --[[ [] ]]0)) then do
                              throw {
                                    Unify,
                                    --[[ [] ]]0
                                  };
                            end
                             end 
                            match$6 = rm1.desc;
                            match$7 = rm2.desc;
                            exit$1 = 0;
                            exit$2 = 0;
                            if (typeof match$6 == "number" or match$6.tag ~= --[[ Tunivar ]]9) then do
                              exit$2 = 2;
                            end else if (typeof match$7 == "number") then do
                              throw {
                                    Unify,
                                    --[[ [] ]]0
                                  };
                            end else if (match$7.tag == --[[ Tunivar ]]9) then do
                              unify_univar(rm1, rm2, univar_pairs.contents);
                            end else do
                              throw {
                                    Unify,
                                    --[[ [] ]]0
                                  };
                            end end  end  end 
                            if (exit$2 == 2) then do
                              if (typeof match$7 == "number" or match$7.tag ~= --[[ Tunivar ]]9) then do
                                exit$1 = 1;
                              end else do
                                throw {
                                      Unify,
                                      --[[ [] ]]0
                                    };
                              end end 
                            end
                             end 
                            if (exit$1 == 1 and not static_row(row1$1)) then do
                              if (may_inst) then do
                                ext = newty2(100000000, --[[ Tvariant ]]Block.__(8, {do
                                          row_fields: r2$1,
                                          row_more: row2$1.row_more,
                                          row_bound: row2$1.row_bound,
                                          row_closed: row2$1.row_closed,
                                          row_fixed: row2$1.row_fixed,
                                          row_name: row2$1.row_name
                                        end}));
                                moregen_occur(env$1, rm1.level, ext);
                                link_type(rm1, ext);
                              end else if (typeof match$6 == "number") then do
                                throw {
                                      Unify,
                                      --[[ [] ]]0
                                    };
                              end else if (match$6.tag == --[[ Tconstr ]]3) then do
                                if (typeof match$7 == "number") then do
                                  throw {
                                        Unify,
                                        --[[ [] ]]0
                                      };
                                end else if (match$7.tag == --[[ Tconstr ]]3) then do
                                  moregen(inst_nongen$1, type_pairs$1, env$1, rm1, rm2);
                                end else do
                                  throw {
                                        Unify,
                                        --[[ [] ]]0
                                      };
                                end end  end 
                              end else do
                                throw {
                                      Unify,
                                      --[[ [] ]]0
                                    };
                              end end  end  end 
                            end
                             end 
                            return List.iter((function (param) do
                                          f1 = row_field_repr_aux(--[[ [] ]]0, param[1]);
                                          f2 = row_field_repr_aux(--[[ [] ]]0, param[2]);
                                          if (f1 == f2) then do
                                            return --[[ () ]]0;
                                          end else if (typeof f1 == "number") then do
                                            if (typeof f2 == "number") then do
                                              return --[[ () ]]0;
                                            end else do
                                              throw {
                                                    Unify,
                                                    --[[ [] ]]0
                                                  };
                                            end end 
                                          end else if (f1.tag) then do
                                            c1 = f1[0];
                                            if (c1) then do
                                              if (not f1[1] and typeof f2 ~= "number" and not f2.tag) then do
                                                if (f2[0] ~= undefined) then do
                                                  throw {
                                                        Unify,
                                                        --[[ [] ]]0
                                                      };
                                                end
                                                 end 
                                                if (may_inst) then do
                                                  return set_row_field(f1[3], f2);
                                                end else do
                                                  throw {
                                                        Unify,
                                                        --[[ [] ]]0
                                                      };
                                                end end 
                                              end
                                               end 
                                            end else if (typeof f2 ~= "number" and not f2.tag) then do
                                              match = f2[0];
                                              if (match ~= undefined) then do
                                                if (may_inst) then do
                                                  t2 = match;
                                                  set_row_field(f1[3], f2);
                                                  return List.iter((function (t1) do
                                                                return moregen(inst_nongen$1, type_pairs$1, env$1, t1, t2);
                                                              end end), f1[1]);
                                                end else do
                                                  throw {
                                                        Unify,
                                                        --[[ [] ]]0
                                                      };
                                                end end 
                                              end else do
                                                throw {
                                                      Unify,
                                                      --[[ [] ]]0
                                                    };
                                              end end 
                                            end
                                             end  end 
                                            e1 = f1[3];
                                            tl1 = f1[1];
                                            if (typeof f2 == "number") then do
                                              if (may_inst) then do
                                                return set_row_field(e1, f2);
                                              end else do
                                                throw {
                                                      Unify,
                                                      --[[ [] ]]0
                                                    };
                                              end end 
                                            end else if (f2.tag) then do
                                              e2 = f2[3];
                                              if (e1 ~= e2) then do
                                                tl2 = f2[1];
                                                c2 = f2[0];
                                                if (c1 and not c2) then do
                                                  throw {
                                                        Unify,
                                                        --[[ [] ]]0
                                                      };
                                                end
                                                 end 
                                                set_row_field(e1, --[[ Reither ]]Block.__(1, {
                                                        c2,
                                                        --[[ [] ]]0,
                                                        f2[2],
                                                        e2
                                                      }));
                                                if (List.length(tl1) == List.length(tl2)) then do
                                                  return List.iter2((function (param, param$1) do
                                                                return moregen(inst_nongen$1, type_pairs$1, env$1, param, param$1);
                                                              end end), tl1, tl2);
                                                end else if (tl2) then do
                                                  t2$1 = tl2[0];
                                                  return List.iter((function (t1) do
                                                                return moregen(inst_nongen$1, type_pairs$1, env$1, t1, t2$1);
                                                              end end), tl1);
                                                end else if (tl1 ~= --[[ [] ]]0) then do
                                                  throw {
                                                        Unify,
                                                        --[[ [] ]]0
                                                      };
                                                end else do
                                                  return 0;
                                                end end  end  end 
                                              end else do
                                                return 0;
                                              end end 
                                            end else do
                                              throw {
                                                    Unify,
                                                    --[[ [] ]]0
                                                  };
                                            end end  end 
                                          end else do
                                            match$1 = f1[0];
                                            if (match$1 ~= undefined) then do
                                              if (typeof f2 == "number") then do
                                                throw {
                                                      Unify,
                                                      --[[ [] ]]0
                                                    };
                                              end else if (f2.tag) then do
                                                throw {
                                                      Unify,
                                                      --[[ [] ]]0
                                                    };
                                              end else do
                                                match$2 = f2[0];
                                                if (match$2 ~= undefined) then do
                                                  return moregen(inst_nongen$1, type_pairs$1, env$1, match$1, match$2);
                                                end else do
                                                  throw {
                                                        Unify,
                                                        --[[ [] ]]0
                                                      };
                                                end end 
                                              end end  end 
                                            end else if (typeof f2 == "number") then do
                                              throw {
                                                    Unify,
                                                    --[[ [] ]]0
                                                  };
                                            end else if (f2.tag) then do
                                              throw {
                                                    Unify,
                                                    --[[ [] ]]0
                                                  };
                                            end else if (f2[0] ~= undefined) then do
                                              throw {
                                                    Unify,
                                                    --[[ [] ]]0
                                                  };
                                            end else do
                                              return --[[ () ]]0;
                                            end end  end  end  end 
                                          end end  end  end 
                                        end end), match$4[2]);
                          end end 
                        end else do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end end  end end end end 
                     if ___conditional___ = 9--[[ Tunivar ]] then do
                        if (typeof match$3 == "number") then do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end else if (match$3.tag == --[[ Tunivar ]]9) then do
                          return unify_univar(t1$prime$1, t2$prime$1, univar_pairs.contents);
                        end else do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end end  end end end end 
                     if ___conditional___ = 10--[[ Tpoly ]] then do
                        tl1 = match$2[1];
                        t1$2 = match$2[0];
                        exit$3 = 0;
                        if (tl1) then do
                          exit$3 = 2;
                        end else if (typeof match$3 == "number") then do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end else if (match$3.tag == --[[ Tpoly ]]10) then do
                          if (match$3[1]) then do
                            exit$3 = 2;
                          end else do
                            return moregen(inst_nongen, type_pairs, env, t1$2, match$3[0]);
                          end end 
                        end else do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end end  end  end 
                        if (exit$3 == 2) then do
                          if (typeof match$3 == "number") then do
                            throw {
                                  Unify,
                                  --[[ [] ]]0
                                };
                          end else if (match$3.tag == --[[ Tpoly ]]10) then do
                            return enter_poly(env, univar_pairs, t1$2, tl1, match$3[0], match$3[1], (function (param, param$1) do
                                          return moregen(inst_nongen, type_pairs, env, param, param$1);
                                        end end));
                          end else do
                            throw {
                                  Unify,
                                  --[[ [] ]]0
                                };
                          end end  end 
                        end
                         end end else 
                     if ___conditional___ = 11--[[ Tpackage ]] then do
                        if (typeof match$3 == "number") then do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end else if (match$3.tag == --[[ Tpackage ]]11) then do
                          try do
                            return unify_package(env, (function (param, param$1) do
                                          return moregen_list(inst_nongen, type_pairs, env, param, param$1);
                                        end end), t1$prime$1.level, match$2[0], match$2[1], match$2[2], t2$prime$1.level, match$3[0], match$3[1], match$3[2]);
                          end
                          catch (exn$1)do
                            if (exn$1 == Caml_builtin_exceptions.not_found) then do
                              throw {
                                    Unify,
                                    --[[ [] ]]0
                                  };
                            end
                             end 
                            throw exn$1;
                          end
                        end else do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end end  end end end end 
                     do
                    
                  end
                end end 
              end else do
                throw exn;
              end end 
            end
          end end 
        end
         end 
      end
      catch (raw_exn)do
        exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn$2[0] == Unify) then do
          throw {
                Unify,
                --[[ :: ]]{
                  --[[ tuple ]]{
                    t1$1,
                    t2$1
                  },
                  exn$2[1]
                }
              };
        end
         end 
        throw exn$2;
      end
    end end 
  end end 
end end

function moregen_list(inst_nongen, type_pairs, env, tl1, tl2) do
  if (List.length(tl1) ~= List.length(tl2)) then do
    throw {
          Unify,
          --[[ [] ]]0
        };
  end
   end 
  return List.iter2((function (param, param$1) do
                return moregen(inst_nongen, type_pairs, env, param, param$1);
              end end), tl1, tl2);
end end

function moregen_fields(inst_nongen, type_pairs, env, ty1, ty2) do
  match = flatten_fields(ty1);
  match$1 = flatten_fields(ty2);
  rest2 = match$1[1];
  match$2 = associate_fields(match[0], match$1[0]);
  if (match$2[1] ~= --[[ [] ]]0) then do
    throw {
          Unify,
          --[[ [] ]]0
        };
  end
   end 
  moregen(inst_nongen, type_pairs, env, match[1], build_fields(repr(ty2).level)(match$2[2], rest2));
  return List.iter((function (param) do
                t2 = param[4];
                k2 = param[3];
                t1 = param[2];
                k1 = param[1];
                n = param[0];
                moregen_kind(k1, k2);
                try do
                  return moregen(inst_nongen, type_pairs, env, t1, t2);
                end
                catch (raw_exn)do
                  exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                  if (exn[0] == Unify) then do
                    throw {
                          Unify,
                          --[[ :: ]]{
                            --[[ tuple ]]{
                              newty2(current_level.contents, --[[ Tfield ]]Block.__(5, {
                                      n,
                                      k1,
                                      t1,
                                      rest2
                                    })),
                              newty2(current_level.contents, --[[ Tfield ]]Block.__(5, {
                                      n,
                                      k2,
                                      t2,
                                      rest2
                                    }))
                            },
                            exn[1]
                          }
                        };
                  end
                   end 
                  throw exn;
                end
              end end), match$2[0]);
end end

function moregen_kind(k1, k2) do
  k1$1 = field_kind_repr(k1);
  k2$1 = field_kind_repr(k2);
  if (k1$1 == k2$1) then do
    return --[[ () ]]0;
  end else if (typeof k1$1 == "number") then do
    if (k1$1 ~= 0) then do
      throw {
            Unify,
            --[[ [] ]]0
          };
    end
     end 
    if (typeof k2$1 == "number") then do
      if (k2$1 ~= 0) then do
        throw {
              Unify,
              --[[ [] ]]0
            };
      end else do
        return --[[ () ]]0;
      end end 
    end else do
      throw {
            Unify,
            --[[ [] ]]0
          };
    end end 
  end else do
    r = k1$1[0];
    if (typeof k2$1 == "number") then do
      if (k2$1 ~= 0) then do
        throw {
              Unify,
              --[[ [] ]]0
            };
      end
       end 
      return set_kind(r, k2$1);
    end else do
      return set_kind(r, k2$1);
    end end 
  end end  end 
end end

function moregen$1(inst_nongen, type_pairs, env, patt, subj) do
  univar_pairs.contents = --[[ [] ]]0;
  return moregen(inst_nongen, type_pairs, env, patt, subj);
end end

function moregeneral(env, inst_nongen, pat_sch, subj_sch) do
  old_level = current_level.contents;
  current_level.contents = 99999999;
  ty = instance(undefined, env, subj_sch);
  subj = type_expr(identity, ty);
  current_level.contents = 100000000;
  patt = instance(undefined, env, pat_sch);
  res;
  try do
    moregen$1(inst_nongen, Curry._1(TypePairs.create, 13), env, patt, subj);
    res = true;
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      res = false;
    end else do
      throw exn;
    end end 
  end
  current_level.contents = old_level;
  return res;
end end

function rigidify_rec(vars, _ty) do
  while(true) do
    ty = _ty;
    ty$1 = repr(ty);
    if (ty$1.level >= 0) then do
      ty$1.level = pivot_level - ty$1.level | 0;
      match = ty$1.desc;
      if (typeof match == "number") then do
        return iter_type_expr((function (param) do
                      return rigidify_rec(vars, param);
                    end end), ty$1);
      end else do
        local ___conditional___=(match.tag | 0);
        do
           if ___conditional___ = 0--[[ Tvar ]] then do
              if (List.memq(ty$1, vars.contents)) then do
                return 0;
              end else do
                vars.contents = --[[ :: ]]{
                  ty$1,
                  vars.contents
                };
                return --[[ () ]]0;
              end end end end end 
           if ___conditional___ = 8--[[ Tvariant ]] then do
              row = row_repr_aux(--[[ [] ]]0, match[0]);
              more = repr(row.row_more);
              if (is_Tvar(more) and not row_fixed(row)) then do
                more$prime = newty2(more.level, more.desc);
                row$prime_row_bound = row.row_bound;
                row$prime_row_closed = row.row_closed;
                row$prime_row_name = row.row_name;
                row$prime = do
                  row_fields: --[[ [] ]]0,
                  row_more: more$prime,
                  row_bound: row$prime_row_bound,
                  row_closed: row$prime_row_closed,
                  row_fixed: true,
                  row_name: row$prime_row_name
                end;
                link_type(more, newty2(ty$1.level, --[[ Tvariant ]]Block.__(8, {row$prime})));
              end
               end 
              iter_row((function (param) do
                      return rigidify_rec(vars, param);
                    end end), row);
              if (static_row(row)) then do
                return 0;
              end else do
                _ty = row_more(row);
                continue ;
              end end end end end 
           do
          else do
            return iter_type_expr((function (param) do
                          return rigidify_rec(vars, param);
                        end end), ty$1);
            end end
            
        end
      end end 
    end else do
      return 0;
    end end 
  end;
end end

function rigidify(ty) do
  vars = do
    contents: --[[ [] ]]0
  end;
  rigidify_rec(vars, ty);
  unmark_type(ty);
  return vars.contents;
end end

function all_distinct_vars(env, vars) do
  tyl = do
    contents: --[[ [] ]]0
  end;
  return List.for_all((function (ty) do
                ty$1 = expand_head(env, ty);
                if (List.memq(ty$1, tyl.contents)) then do
                  return false;
                end else do
                  tyl.contents = --[[ :: ]]{
                    ty$1,
                    tyl.contents
                  };
                  return is_Tvar(ty$1);
                end end 
              end end), vars);
end end

function matches(env, ty, ty$prime) do
  snap = snapshot(--[[ () ]]0);
  vars = rigidify(ty);
  cleanup_abbrev(--[[ () ]]0);
  ok;
  try do
    unify$2(env, ty, ty$prime);
    ok = all_distinct_vars(env, vars);
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      ok = false;
    end else do
      throw exn;
    end end 
  end
  backtrack(snap);
  return ok;
end end

function expand_head_rigid(env, ty) do
  old = rigid_variants.contents;
  rigid_variants.contents = true;
  ty$prime = expand_head(env, ty);
  rigid_variants.contents = old;
  return ty$prime;
end end

function normalize_subst(subst) do
  if (List.exists((function (param) do
            match = param[0].desc;
            if (typeof match ~= "number" and match.tag == --[[ Tlink ]]6) then do
              return true;
            end
             end 
            match$1 = param[1].desc;
            return typeof match$1 == "number" or match$1.tag ~= --[[ Tlink ]]6 and false or true;
          end end), subst.contents)) then do
    subst.contents = List.map((function (param) do
            return --[[ tuple ]]{
                    repr(param[0]),
                    repr(param[1])
                  };
          end end), subst.contents);
    return --[[ () ]]0;
  end else do
    return 0;
  end end 
end end

function eqtype(rename, type_pairs, subst, env, t1, t2) do
  if (t1 == t2) then do
    return --[[ () ]]0;
  end else do
    t1$1 = repr(t1);
    t2$1 = repr(t2);
    if (t1$1 == t2$1) then do
      return --[[ () ]]0;
    end else do
      try do
        match = t1$1.desc;
        match$1 = t2$1.desc;
        exit = 0;
        if (typeof match == "number") then do
          exit = 1;
        end else do
          local ___conditional___=(match.tag | 0);
          do
             if ___conditional___ = 0--[[ Tvar ]] then do
                if (typeof match$1 == "number" or match$1.tag or not rename) then do
                  exit = 1;
                end else do
                  try do
                    normalize_subst(subst);
                    if (List.assq(t1$1, subst.contents) ~= t2$1) then do
                      throw {
                            Unify,
                            --[[ [] ]]0
                          };
                    end else do
                      return 0;
                    end end 
                  end
                  catch (exn)do
                    if (exn == Caml_builtin_exceptions.not_found) then do
                      if (List.exists((function (param) do
                                return param[1] == t2$1;
                              end end), subst.contents)) then do
                        throw {
                              Unify,
                              --[[ [] ]]0
                            };
                      end
                       end 
                      subst.contents = --[[ :: ]]{
                        --[[ tuple ]]{
                          t1$1,
                          t2$1
                        },
                        subst.contents
                      };
                      return --[[ () ]]0;
                    end else do
                      throw exn;
                    end end 
                  end
                end end end else 
             if ___conditional___ = 3--[[ Tconstr ]] then do
                if (match[1] or typeof match$1 == "number" or not (match$1.tag == --[[ Tconstr ]]3 and not (match$1[1] or not same(match[0], match$1[0])))) then do
                  exit = 1;
                end else do
                  return --[[ () ]]0;
                end end end else 
             do end end end
            else do
              exit = 1;
              end end
              
          end
        end end 
        if (exit == 1) then do
          t1$prime = expand_head_rigid(env, t1$1);
          t2$prime = expand_head_rigid(env, t2$1);
          t1$prime$1 = repr(t1$prime);
          t2$prime$1 = repr(t2$prime);
          if (t1$prime$1 == t2$prime$1) then do
            return --[[ () ]]0;
          end else do
            try do
              return Curry._2(TypePairs.find, type_pairs, --[[ tuple ]]{
                          t1$prime$1,
                          t2$prime$1
                        });
            end
            catch (exn$1)do
              if (exn$1 == Caml_builtin_exceptions.not_found) then do
                Curry._3(TypePairs.add, type_pairs, --[[ tuple ]]{
                      t1$prime$1,
                      t2$prime$1
                    }, --[[ () ]]0);
                match$2 = t1$prime$1.desc;
                match$3 = t2$prime$1.desc;
                if (typeof match$2 == "number") then do
                  if (typeof match$3 == "number") then do
                    return --[[ () ]]0;
                  end else do
                    throw {
                          Unify,
                          --[[ [] ]]0
                        };
                  end end 
                end else do
                  local ___conditional___=(match$2.tag | 0);
                  do
                     if ___conditional___ = 0--[[ Tvar ]] then do
                        if (typeof match$3 == "number") then do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end else if (match$3.tag) then do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end else if (rename) then do
                          try do
                            normalize_subst(subst);
                            if (List.assq(t1$prime$1, subst.contents) ~= t2$prime$1) then do
                              throw {
                                    Unify,
                                    --[[ [] ]]0
                                  };
                            end else do
                              return 0;
                            end end 
                          end
                          catch (exn$2)do
                            if (exn$2 == Caml_builtin_exceptions.not_found) then do
                              if (List.exists((function (param) do
                                        return param[1] == t2$prime$1;
                                      end end), subst.contents)) then do
                                throw {
                                      Unify,
                                      --[[ [] ]]0
                                    };
                              end
                               end 
                              subst.contents = --[[ :: ]]{
                                --[[ tuple ]]{
                                  t1$prime$1,
                                  t2$prime$1
                                },
                                subst.contents
                              };
                              return --[[ () ]]0;
                            end else do
                              throw exn$2;
                            end end 
                          end
                        end else do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end end  end  end end end end 
                     if ___conditional___ = 1--[[ Tarrow ]] then do
                        if (typeof match$3 == "number") then do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end else if (match$3.tag == --[[ Tarrow ]]1) then do
                          l2 = match$3[0];
                          l1 = match$2[0];
                          if (l1 == l2 or classic.contents and not (is_optional(l1) or is_optional(l2))) then do
                            eqtype(rename, type_pairs, subst, env, match$2[1], match$3[1]);
                            return eqtype(rename, type_pairs, subst, env, match$2[2], match$3[2]);
                          end else do
                            throw {
                                  Unify,
                                  --[[ [] ]]0
                                };
                          end end 
                        end else do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end end  end end end end 
                     if ___conditional___ = 2--[[ Ttuple ]] then do
                        if (typeof match$3 == "number") then do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end else if (match$3.tag == --[[ Ttuple ]]2) then do
                          return eqtype_list(rename, type_pairs, subst, env, match$2[0], match$3[0]);
                        end else do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end end  end end end end 
                     if ___conditional___ = 3--[[ Tconstr ]] then do
                        if (typeof match$3 == "number") then do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end else if (match$3.tag == --[[ Tconstr ]]3) then do
                          if (same(match$2[0], match$3[0])) then do
                            return eqtype_list(rename, type_pairs, subst, env, match$2[1], match$3[1]);
                          end else do
                            throw {
                                  Unify,
                                  --[[ [] ]]0
                                };
                          end end 
                        end else do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end end  end end end end 
                     if ___conditional___ = 4--[[ Tobject ]] then do
                        if (typeof match$3 == "number") then do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end else if (match$3.tag == --[[ Tobject ]]4) then do
                          return eqtype_fields(rename, type_pairs, subst, env, match$2[0], match$3[0]);
                        end else do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end end  end end end end 
                     if ___conditional___ = 5--[[ Tfield ]] then do
                        if (typeof match$3 == "number") then do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end else if (match$3.tag == --[[ Tfield ]]5) then do
                          return eqtype_fields(rename, type_pairs, subst, env, t1$prime$1, t2$prime$1);
                        end else do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end end  end end end end 
                     if ___conditional___ = 6--[[ Tlink ]]
                     or ___conditional___ = 7--[[ Tsubst ]] then do
                        throw {
                              Unify,
                              --[[ [] ]]0
                            };end end end 
                     if ___conditional___ = 8--[[ Tvariant ]] then do
                        if (typeof match$3 == "number") then do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end else if (match$3.tag == --[[ Tvariant ]]8) then do
                          rename$1 = rename;
                          type_pairs$1 = type_pairs;
                          subst$1 = subst;
                          env$1 = env;
                          row1 = match$2[0];
                          _row2 = match$3[0];
                          while(true) do
                            row2 = _row2;
                            match$4 = expand_head_rigid(env$1, row_more(row2));
                            match$5 = match$4.desc;
                            if (typeof match$5 ~= "number" and match$5.tag == --[[ Tvariant ]]8) then do
                              _row2 = match$5[0];
                              continue ;
                            end
                             end 
                            row1$1 = row_repr_aux(--[[ [] ]]0, row1);
                            row2$1 = row_repr_aux(--[[ [] ]]0, row2);
                            match$6 = merge_row_fields(row1$1.row_fields, row2$1.row_fields);
                            r2 = match$6[1];
                            r1 = match$6[0];
                            if (row1$1.row_closed ~= row2$1.row_closed or not row1$1.row_closed and (r1 ~= --[[ [] ]]0 or r2 ~= --[[ [] ]]0) or filter_row_fields(false, Pervasives.$at(r1, r2)) ~= --[[ [] ]]0) then do
                              throw {
                                    Unify,
                                    --[[ [] ]]0
                                  };
                            end
                             end 
                            if (not static_row(row1$1)) then do
                              eqtype(rename$1, type_pairs$1, subst$1, env$1, row1$1.row_more, row2$1.row_more);
                            end
                             end 
                            return List.iter((function (param) do
                                          match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                                          match$1 = row_field_repr_aux(--[[ [] ]]0, param[2]);
                                          if (typeof match == "number") then do
                                            if (typeof match$1 == "number") then do
                                              return --[[ () ]]0;
                                            end else do
                                              throw {
                                                    Unify,
                                                    --[[ [] ]]0
                                                  };
                                            end end 
                                          end else if (match.tag) then do
                                            if (match[0]) then do
                                              if (match[1]) then do
                                                throw {
                                                      Unify,
                                                      --[[ [] ]]0
                                                    };
                                              end
                                               end 
                                              if (typeof match$1 == "number") then do
                                                throw {
                                                      Unify,
                                                      --[[ [] ]]0
                                                    };
                                              end else if (match$1.tag) then do
                                                if (match$1[0]) then do
                                                  if (match$1[1]) then do
                                                    throw {
                                                          Unify,
                                                          --[[ [] ]]0
                                                        };
                                                  end
                                                   end 
                                                  return --[[ () ]]0;
                                                end else do
                                                  throw {
                                                        Unify,
                                                        --[[ [] ]]0
                                                      };
                                                end end 
                                              end else do
                                                throw {
                                                      Unify,
                                                      --[[ [] ]]0
                                                    };
                                              end end  end 
                                            end else do
                                              match$2 = match[1];
                                              if (match$2) then do
                                                tl1 = match$2[1];
                                                t1 = match$2[0];
                                                if (typeof match$1 == "number") then do
                                                  throw {
                                                        Unify,
                                                        --[[ [] ]]0
                                                      };
                                                end else if (match$1.tag) then do
                                                  if (match$1[0]) then do
                                                    throw {
                                                          Unify,
                                                          --[[ [] ]]0
                                                        };
                                                  end
                                                   end 
                                                  match$3 = match$1[1];
                                                  if (match$3) then do
                                                    tl2 = match$3[1];
                                                    t2 = match$3[0];
                                                    eqtype(rename$1, type_pairs$1, subst$1, env$1, t1, t2);
                                                    if (List.length(tl1) == List.length(tl2)) then do
                                                      return List.iter2((function (param, param$1) do
                                                                    return eqtype(rename$1, type_pairs$1, subst$1, env$1, param, param$1);
                                                                  end end), tl1, tl2);
                                                    end else do
                                                      List.iter((function (param) do
                                                              return eqtype(rename$1, type_pairs$1, subst$1, env$1, t1, param);
                                                            end end), tl2);
                                                      return List.iter((function (t1) do
                                                                    return eqtype(rename$1, type_pairs$1, subst$1, env$1, t1, t2);
                                                                  end end), tl1);
                                                    end end 
                                                  end else do
                                                    throw {
                                                          Unify,
                                                          --[[ [] ]]0
                                                        };
                                                  end end 
                                                end else do
                                                  throw {
                                                        Unify,
                                                        --[[ [] ]]0
                                                      };
                                                end end  end 
                                              end else do
                                                throw {
                                                      Unify,
                                                      --[[ [] ]]0
                                                    };
                                              end end 
                                            end end 
                                          end else do
                                            match$4 = match[0];
                                            if (match$4 ~= undefined) then do
                                              if (typeof match$1 == "number") then do
                                                throw {
                                                      Unify,
                                                      --[[ [] ]]0
                                                    };
                                              end else if (match$1.tag) then do
                                                throw {
                                                      Unify,
                                                      --[[ [] ]]0
                                                    };
                                              end else do
                                                match$5 = match$1[0];
                                                if (match$5 ~= undefined) then do
                                                  return eqtype(rename$1, type_pairs$1, subst$1, env$1, match$4, match$5);
                                                end else do
                                                  throw {
                                                        Unify,
                                                        --[[ [] ]]0
                                                      };
                                                end end 
                                              end end  end 
                                            end else if (typeof match$1 == "number") then do
                                              throw {
                                                    Unify,
                                                    --[[ [] ]]0
                                                  };
                                            end else if (match$1.tag) then do
                                              throw {
                                                    Unify,
                                                    --[[ [] ]]0
                                                  };
                                            end else if (match$1[0] ~= undefined) then do
                                              throw {
                                                    Unify,
                                                    --[[ [] ]]0
                                                  };
                                            end else do
                                              return --[[ () ]]0;
                                            end end  end  end  end 
                                          end end  end 
                                        end end), match$6[2]);
                          end;
                        end else do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end end  end end end end 
                     if ___conditional___ = 9--[[ Tunivar ]] then do
                        if (typeof match$3 == "number") then do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end else if (match$3.tag == --[[ Tunivar ]]9) then do
                          return unify_univar(t1$prime$1, t2$prime$1, univar_pairs.contents);
                        end else do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end end  end end end end 
                     if ___conditional___ = 10--[[ Tpoly ]] then do
                        tl1 = match$2[1];
                        t1$2 = match$2[0];
                        exit$1 = 0;
                        if (tl1) then do
                          exit$1 = 2;
                        end else if (typeof match$3 == "number") then do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end else if (match$3.tag == --[[ Tpoly ]]10) then do
                          if (match$3[1]) then do
                            exit$1 = 2;
                          end else do
                            return eqtype(rename, type_pairs, subst, env, t1$2, match$3[0]);
                          end end 
                        end else do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end end  end  end 
                        if (exit$1 == 2) then do
                          if (typeof match$3 == "number") then do
                            throw {
                                  Unify,
                                  --[[ [] ]]0
                                };
                          end else if (match$3.tag == --[[ Tpoly ]]10) then do
                            return enter_poly(env, univar_pairs, t1$2, tl1, match$3[0], match$3[1], (function (param, param$1) do
                                          return eqtype(rename, type_pairs, subst, env, param, param$1);
                                        end end));
                          end else do
                            throw {
                                  Unify,
                                  --[[ [] ]]0
                                };
                          end end  end 
                        end
                         end end else 
                     if ___conditional___ = 11--[[ Tpackage ]] then do
                        if (typeof match$3 == "number") then do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end else if (match$3.tag == --[[ Tpackage ]]11) then do
                          try do
                            return unify_package(env, (function (param, param$1) do
                                          return eqtype_list(rename, type_pairs, subst, env, param, param$1);
                                        end end), t1$prime$1.level, match$2[0], match$2[1], match$2[2], t2$prime$1.level, match$3[0], match$3[1], match$3[2]);
                          end
                          catch (exn$3)do
                            if (exn$3 == Caml_builtin_exceptions.not_found) then do
                              throw {
                                    Unify,
                                    --[[ [] ]]0
                                  };
                            end
                             end 
                            throw exn$3;
                          end
                        end else do
                          throw {
                                Unify,
                                --[[ [] ]]0
                              };
                        end end  end end end end 
                     do
                    
                  end
                end end 
              end else do
                throw exn$1;
              end end 
            end
          end end 
        end
         end 
      end
      catch (raw_exn)do
        exn$4 = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn$4[0] == Unify) then do
          throw {
                Unify,
                --[[ :: ]]{
                  --[[ tuple ]]{
                    t1$1,
                    t2$1
                  },
                  exn$4[1]
                }
              };
        end
         end 
        throw exn$4;
      end
    end end 
  end end 
end end

function eqtype_list(rename, type_pairs, subst, env, tl1, tl2) do
  if (List.length(tl1) ~= List.length(tl2)) then do
    throw {
          Unify,
          --[[ [] ]]0
        };
  end
   end 
  return List.iter2((function (param, param$1) do
                return eqtype(rename, type_pairs, subst, env, param, param$1);
              end end), tl1, tl2);
end end

function eqtype_fields(rename, type_pairs, subst, env, ty1, _ty2) do
  while(true) do
    ty2 = _ty2;
    match = flatten_fields(ty1);
    rest1 = match[1];
    match$1 = flatten_fields(ty2);
    rest2 = match$1[1];
    same_row = rest1 == rest2 or Curry._2(TypePairs.mem, type_pairs, --[[ tuple ]]{
          rest1,
          rest2
        }) or rename and List.mem(--[[ tuple ]]{
          rest1,
          rest2
        }, subst.contents);
    if (same_row) then do
      return --[[ () ]]0;
    end else do
      match$2 = expand_head_rigid(env, rest2);
      match$3 = match$2.desc;
      if (typeof match$3 ~= "number" and match$3.tag == --[[ Tobject ]]4) then do
        _ty2 = match$3[0];
        continue ;
      end
       end 
      match$4 = associate_fields(match[0], match$1[0]);
      eqtype(rename, type_pairs, subst, env, rest1, rest2);
      if (match$4[1] ~= --[[ [] ]]0 or match$4[2] ~= --[[ [] ]]0) then do
        throw {
              Unify,
              --[[ [] ]]0
            };
      end
       end 
      return List.iter((function(rest2)do
                return function (param) do
                  t2 = param[4];
                  k2 = param[3];
                  t1 = param[2];
                  k1 = param[1];
                  n = param[0];
                  eqtype_kind(k1, k2);
                  try do
                    return eqtype(rename, type_pairs, subst, env, t1, t2);
                  end
                  catch (raw_exn)do
                    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn[0] == Unify) then do
                      throw {
                            Unify,
                            --[[ :: ]]{
                              --[[ tuple ]]{
                                newty2(current_level.contents, --[[ Tfield ]]Block.__(5, {
                                        n,
                                        k1,
                                        t1,
                                        rest2
                                      })),
                                newty2(current_level.contents, --[[ Tfield ]]Block.__(5, {
                                        n,
                                        k2,
                                        t2,
                                        rest2
                                      }))
                              },
                              exn[1]
                            }
                          };
                    end
                     end 
                    throw exn;
                  end
                end end
                end(rest2)), match$4[0]);
    end end 
  end;
end end

function eqtype_kind(k1, k2) do
  k1$1 = field_kind_repr(k1);
  k2$1 = field_kind_repr(k2);
  if (typeof k1$1 == "number") then do
    if (k1$1 ~= 0) then do
      throw {
            Unify,
            --[[ [] ]]0
          };
    end
     end 
    if (typeof k2$1 == "number") then do
      if (k2$1 ~= 0) then do
        throw {
              Unify,
              --[[ [] ]]0
            };
      end else do
        return --[[ () ]]0;
      end end 
    end else do
      throw {
            Unify,
            --[[ [] ]]0
          };
    end end 
  end else do
    if (typeof k2$1 == "number") then do
      throw {
            Unify,
            --[[ [] ]]0
          };
    end
     end 
    return --[[ () ]]0;
  end end 
end end

function equal$4(env, rename, tyl1, tyl2) do
  try do
    univar_pairs.contents = --[[ [] ]]0;
    eqtype_list(rename, Curry._1(TypePairs.create, 11), do
          contents: --[[ [] ]]0
        end, env, tyl1, tyl2);
    return true;
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      return false;
    end else do
      throw exn;
    end end 
  end
end end

function eqtype$1(rename, type_pairs, subst, env, t1, t2) do
  univar_pairs.contents = --[[ [] ]]0;
  return eqtype(rename, type_pairs, subst, env, t1, t2);
end end

Failure = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Failure");

function moregen_clty(trace, type_pairs, env, cty1, cty2) do
  try do
    exit = 0;
    local ___conditional___=(cty1.tag | 0);
    do
       if ___conditional___ = 0--[[ Cty_constr ]] then do
          return moregen_clty(true, type_pairs, env, cty1[2], cty2);end end end 
       if ___conditional___ = 1--[[ Cty_signature ]] then do
          sign1 = cty1[0];
          local ___conditional___=(cty2.tag | 0);
          do
             if ___conditional___ = 0--[[ Cty_constr ]] then do
                exit = 1;end else 
             if ___conditional___ = 1--[[ Cty_signature ]] then do
                sign2 = cty2[0];
                ty1 = object_fields(repr(sign1.csig_self));
                ty2 = object_fields(repr(sign2.csig_self));
                match = flatten_fields(ty1);
                match$1 = flatten_fields(ty2);
                match$2 = associate_fields(match[0], match$1[0]);
                List.iter((function (param) do
                        try do
                          return moregen$1(true, type_pairs, env, param[2], param[4]);
                        end
                        catch (raw_exn)do
                          exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                          if (exn[0] == Unify) then do
                            throw {
                                  Failure,
                                  --[[ :: ]]{
                                    --[[ CM_Meth_type_mismatch ]]Block.__(5, {
                                        param[0],
                                        env,
                                        expand_trace(env, exn[1])
                                      }),
                                    --[[ [] ]]0
                                  }
                                };
                          end
                           end 
                          throw exn;
                        end
                      end end), match$2[0]);
                return iter$1((function (lab, param) do
                              match = find(lab, sign1.csig_vars);
                              try do
                                return moregen$1(true, type_pairs, env, match[2], param[2]);
                              end
                              catch (raw_exn)do
                                exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                                if (exn[0] == Unify) then do
                                  throw {
                                        Failure,
                                        --[[ :: ]]{
                                          --[[ CM_Val_type_mismatch ]]Block.__(4, {
                                              lab,
                                              env,
                                              expand_trace(env, exn[1])
                                            }),
                                          --[[ [] ]]0
                                        }
                                      };
                                end
                                 end 
                                throw exn;
                              end
                            end end), sign2.csig_vars);end end end 
             if ___conditional___ = 2--[[ Cty_arrow ]] then do
                throw {
                      Failure,
                      --[[ [] ]]0
                    };end end end 
             do
            
          endend else 
       if ___conditional___ = 2--[[ Cty_arrow ]] then do
          local ___conditional___=(cty2.tag | 0);
          do
             if ___conditional___ = 0--[[ Cty_constr ]] then do
                exit = 1;end else 
             if ___conditional___ = 1--[[ Cty_signature ]] then do
                throw {
                      Failure,
                      --[[ [] ]]0
                    };end end end 
             if ___conditional___ = 2--[[ Cty_arrow ]] then do
                if (cty1[0] == cty2[0]) then do
                  try do
                    moregen$1(true, type_pairs, env, cty1[1], cty2[1]);
                  end
                  catch (raw_exn)do
                    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn[0] == Unify) then do
                      throw {
                            Failure,
                            --[[ :: ]]{
                              --[[ CM_Parameter_mismatch ]]Block.__(3, {
                                  env,
                                  expand_trace(env, exn[1])
                                }),
                              --[[ [] ]]0
                            }
                          };
                    end
                     end 
                    throw exn;
                  end
                  return moregen_clty(false, type_pairs, env, cty1[2], cty2[2]);
                end else do
                  throw {
                        Failure,
                        --[[ [] ]]0
                      };
                end end end end end 
             do
            
          endend else 
       do end end
      
    end
    if (exit == 1) then do
      return moregen_clty(true, type_pairs, env, cty1, cty2[2]);
    end
     end 
  end
  catch (raw_exn$1)do
    exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
    if (exn$1[0] == Failure) then do
      error = exn$1[1];
      if (trace or error == --[[ [] ]]0) then do
        throw {
              Failure,
              --[[ :: ]]{
                --[[ CM_Class_type_mismatch ]]Block.__(2, {
                    env,
                    cty1,
                    cty2
                  }),
                error
              }
            };
      end
       end 
      throw exn$1;
    end else do
      throw exn$1;
    end end 
  end
end end

function match_class_types(traceOpt, env, pat_sch, subj_sch) do
  trace = traceOpt ~= undefined and traceOpt or true;
  type_pairs = Curry._1(TypePairs.create, 53);
  old_level = current_level.contents;
  current_level.contents = 99999999;
  match = instance_class(--[[ [] ]]0, subj_sch);
  subj = class_type$1(identity, match[1]);
  current_level.contents = 100000000;
  match$1 = instance_class(--[[ [] ]]0, pat_sch);
  patt = match$1[1];
  sign1 = signature_of_class_type(patt);
  sign2 = signature_of_class_type(subj);
  t1 = repr(sign1.csig_self);
  t2 = repr(sign2.csig_self);
  Curry._3(TypePairs.add, type_pairs, --[[ tuple ]]{
        t1,
        t2
      }, --[[ () ]]0);
  match$2 = flatten_fields(object_fields(t1));
  match$3 = flatten_fields(object_fields(t2));
  match$4 = associate_fields(match$2[0], match$3[0]);
  error = List.fold_right((function (param, err) do
          lab = param[0];
          k = field_kind_repr(param[1]);
          err$1 = typeof k == "number" and --[[ :: ]]{
              --[[ CM_Hide_public ]]Block.__(10, {lab}),
              err
            } or (set_kind(k[0], --[[ Fabsent ]]1), err);
          if (mem$2(lab, sign1.csig_concr)) then do
            return err$1;
          end else do
            return --[[ :: ]]{
                    --[[ CM_Hide_virtual ]]Block.__(11, {
                        "method",
                        lab
                      }),
                    err$1
                  };
          end end 
        end end), match$4[1], --[[ [] ]]0);
  missing_method = List.map((function (param) do
          return param[0];
        end end), match$4[2]);
  error$1 = Pervasives.$at(List.map((function (m) do
              return --[[ CM_Missing_method ]]Block.__(9, {m});
            end end), missing_method), error);
  moregen$1(true, type_pairs, env, match$2[1], match$3[1]);
  error$2 = List.fold_right((function (param, err) do
          try do
            moregen_kind(param[1], param[3]);
            return err;
          end
          catch (raw_exn)do
            exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn[0] == Unify) then do
              return --[[ :: ]]{
                      --[[ CM_Public_method ]]Block.__(12, {param[0]}),
                      err
                    };
            end else do
              throw exn;
            end end 
          end
        end end), match$4[0], error$1);
  error$3 = fold((function (lab, param, err) do
          try do
            match = find(lab, sign1.csig_vars);
            if (param[0] == --[[ Mutable ]]1 and match[0] ~= --[[ Mutable ]]1) then do
              return --[[ :: ]]{
                      --[[ CM_Non_mutable_value ]]Block.__(6, {lab}),
                      err
                    };
            end else if (param[1] == --[[ Concrete ]]1 and match[1] ~= --[[ Concrete ]]1) then do
              return --[[ :: ]]{
                      --[[ CM_Non_concrete_value ]]Block.__(7, {lab}),
                      err
                    };
            end else do
              return err;
            end end  end 
          end
          catch (exn)do
            if (exn == Caml_builtin_exceptions.not_found) then do
              return --[[ :: ]]{
                      --[[ CM_Missing_value ]]Block.__(8, {lab}),
                      err
                    };
            end else do
              throw exn;
            end end 
          end
        end end), sign2.csig_vars, error$2);
  error$4 = fold((function (lab, param, err) do
          if (param[1] == --[[ Virtual ]]0 and not mem(lab, sign2.csig_vars)) then do
            return --[[ :: ]]{
                    --[[ CM_Hide_virtual ]]Block.__(11, {
                        "instance variable",
                        lab
                      }),
                    err
                  };
          end else do
            return err;
          end end 
        end end), sign1.csig_vars, error$3);
  error$5 = List.fold_right((function (e, l) do
          if (List.mem(e, missing_method)) then do
            return l;
          end else do
            return --[[ :: ]]{
                    --[[ CM_Virtual_method ]]Block.__(14, {e}),
                    l
                  };
          end end 
        end end), elements_aux(--[[ [] ]]0, diff(sign2.csig_concr, sign1.csig_concr)), error$4);
  res;
  if (error$5) then do
    res = --[[ :: ]]{
      --[[ CM_Class_type_mismatch ]]Block.__(2, {
          env,
          patt,
          subj
        }),
      error$5
    };
  end else do
    try do
      moregen_clty(trace, type_pairs, env, patt, subj);
      res = --[[ [] ]]0;
    end
    catch (raw_exn)do
      exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] == Failure) then do
        res = exn[1];
      end else do
        throw exn;
      end end 
    end
  end end 
  current_level.contents = old_level;
  return res;
end end

function equal_clty(trace, type_pairs, subst, env, cty1, cty2) do
  try do
    exit = 0;
    local ___conditional___=(cty1.tag | 0);
    do
       if ___conditional___ = 0--[[ Cty_constr ]] then do
          cty1$1 = cty1[2];
          exit$1 = 0;
          local ___conditional___=(cty2.tag | 0);
          do
             if ___conditional___ = 0--[[ Cty_constr ]] then do
                return equal_clty(true, type_pairs, subst, env, cty1$1, cty2[2]);end end end 
             if ___conditional___ = 1--[[ Cty_signature ]]
             or ___conditional___ = 2--[[ Cty_arrow ]] then do
                exit$1 = 3;end else 
             do end
            
          end
          if (exit$1 == 3) then do
            return equal_clty(true, type_pairs, subst, env, cty1$1, cty2);
          end
           end end else 
       if ___conditional___ = 1--[[ Cty_signature ]] then do
          sign1 = cty1[0];
          local ___conditional___=(cty2.tag | 0);
          do
             if ___conditional___ = 0--[[ Cty_constr ]] then do
                exit = 1;end else 
             if ___conditional___ = 1--[[ Cty_signature ]] then do
                sign2 = cty2[0];
                ty1 = object_fields(repr(sign1.csig_self));
                ty2 = object_fields(repr(sign2.csig_self));
                match = flatten_fields(ty1);
                match$1 = flatten_fields(ty2);
                match$2 = associate_fields(match[0], match$1[0]);
                List.iter((function (param) do
                        try do
                          return eqtype$1(true, type_pairs, subst, env, param[2], param[4]);
                        end
                        catch (raw_exn)do
                          exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                          if (exn[0] == Unify) then do
                            throw {
                                  Failure,
                                  --[[ :: ]]{
                                    --[[ CM_Meth_type_mismatch ]]Block.__(5, {
                                        param[0],
                                        env,
                                        expand_trace(env, exn[1])
                                      }),
                                    --[[ [] ]]0
                                  }
                                };
                          end
                           end 
                          throw exn;
                        end
                      end end), match$2[0]);
                return iter$1((function (lab, param) do
                              match = find(lab, sign1.csig_vars);
                              try do
                                return eqtype$1(true, type_pairs, subst, env, match[2], param[2]);
                              end
                              catch (raw_exn)do
                                exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                                if (exn[0] == Unify) then do
                                  throw {
                                        Failure,
                                        --[[ :: ]]{
                                          --[[ CM_Val_type_mismatch ]]Block.__(4, {
                                              lab,
                                              env,
                                              expand_trace(env, exn[1])
                                            }),
                                          --[[ [] ]]0
                                        }
                                      };
                                end
                                 end 
                                throw exn;
                              end
                            end end), sign2.csig_vars);end end end 
             if ___conditional___ = 2--[[ Cty_arrow ]] then do
                exit = 2;end else 
             do end end
            
          endend else 
       if ___conditional___ = 2--[[ Cty_arrow ]] then do
          local ___conditional___=(cty2.tag | 0);
          do
             if ___conditional___ = 0--[[ Cty_constr ]] then do
                exit = 1;end else 
             if ___conditional___ = 1--[[ Cty_signature ]] then do
                exit = 2;end else 
             if ___conditional___ = 2--[[ Cty_arrow ]] then do
                if (cty1[0] == cty2[0]) then do
                  try do
                    eqtype$1(true, type_pairs, subst, env, cty1[1], cty2[1]);
                  end
                  catch (raw_exn)do
                    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn[0] == Unify) then do
                      throw {
                            Failure,
                            --[[ :: ]]{
                              --[[ CM_Parameter_mismatch ]]Block.__(3, {
                                  env,
                                  expand_trace(env, exn[1])
                                }),
                              --[[ [] ]]0
                            }
                          };
                    end
                     end 
                    throw exn;
                  end
                  return equal_clty(false, type_pairs, subst, env, cty1[2], cty2[2]);
                end else do
                  exit = 2;
                end end end else 
             do end end end end
            
          endend else 
       do end end end end
      
    end
    local ___conditional___=(exit);
    do
       if ___conditional___ = 1 then do
          return equal_clty(true, type_pairs, subst, env, cty1, cty2[2]);end end end 
       if ___conditional___ = 2 then do
          throw {
                Failure,
                trace and --[[ [] ]]0 or --[[ :: ]]{
                    --[[ CM_Class_type_mismatch ]]Block.__(2, {
                        env,
                        cty1,
                        cty2
                      }),
                    --[[ [] ]]0
                  }
              };end end end 
       do
      
    end
  end
  catch (raw_exn$1)do
    exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
    if (exn$1[0] == Failure) then do
      if (trace) then do
        throw {
              Failure,
              --[[ :: ]]{
                --[[ CM_Class_type_mismatch ]]Block.__(2, {
                    env,
                    cty1,
                    cty2
                  }),
                exn$1[1]
              }
            };
      end
       end 
      throw exn$1;
    end else do
      throw exn$1;
    end end 
  end
end end

function match_class_declarations(env, patt_params, patt_type, subj_params, subj_type) do
  type_pairs = Curry._1(TypePairs.create, 53);
  subst = do
    contents: --[[ [] ]]0
  end;
  sign1 = signature_of_class_type(patt_type);
  sign2 = signature_of_class_type(subj_type);
  t1 = repr(sign1.csig_self);
  t2 = repr(sign2.csig_self);
  Curry._3(TypePairs.add, type_pairs, --[[ tuple ]]{
        t1,
        t2
      }, --[[ () ]]0);
  match = flatten_fields(object_fields(t1));
  match$1 = flatten_fields(object_fields(t2));
  match$2 = associate_fields(match[0], match$1[0]);
  error = List.fold_right((function (param, err) do
          lab = param[0];
          k = field_kind_repr(param[1]);
          err$1 = typeof k == "number" and --[[ :: ]]{
              --[[ CM_Hide_public ]]Block.__(10, {lab}),
              err
            } or err;
          if (mem$2(lab, sign1.csig_concr)) then do
            return err$1;
          end else do
            return --[[ :: ]]{
                    --[[ CM_Hide_virtual ]]Block.__(11, {
                        "method",
                        lab
                      }),
                    err$1
                  };
          end end 
        end end), match$2[1], --[[ [] ]]0);
  missing_method = List.map((function (param) do
          return param[0];
        end end), match$2[2]);
  error$1 = Pervasives.$at(List.map((function (m) do
              return --[[ CM_Missing_method ]]Block.__(9, {m});
            end end), missing_method), error);
  eqtype$1(true, type_pairs, subst, env, match[1], match$1[1]);
  error$2 = List.fold_right((function (param, err) do
          lab = param[0];
          k1 = field_kind_repr(param[1]);
          k2 = field_kind_repr(param[3]);
          if (typeof k1 == "number") then do
            if (k1 == 0) then do
              if (typeof k2 == "number") then do
                if (k2 == 0) then do
                  return err;
                end
                 end 
              end else do
                return --[[ :: ]]{
                        --[[ CM_Public_method ]]Block.__(12, {lab}),
                        err
                      };
              end end 
            end
             end 
          end else if (typeof k2 == "number") then do
            if (k2 == 0) then do
              return --[[ :: ]]{
                      --[[ CM_Private_method ]]Block.__(13, {lab}),
                      err
                    };
            end
             end 
          end else do
            return err;
          end end  end 
          throw {
                Caml_builtin_exceptions.assert_failure,
                --[[ tuple ]]{
                  "ctype.ml",
                  3600,
                  34
                }
              };
        end end), match$2[0], error$1);
  error$3 = fold((function (lab, param, err) do
          try do
            match = find(lab, sign1.csig_vars);
            if (param[0] == --[[ Mutable ]]1 and match[0] ~= --[[ Mutable ]]1) then do
              return --[[ :: ]]{
                      --[[ CM_Non_mutable_value ]]Block.__(6, {lab}),
                      err
                    };
            end else if (param[1] == --[[ Concrete ]]1 and match[1] ~= --[[ Concrete ]]1) then do
              return --[[ :: ]]{
                      --[[ CM_Non_concrete_value ]]Block.__(7, {lab}),
                      err
                    };
            end else do
              return err;
            end end  end 
          end
          catch (exn)do
            if (exn == Caml_builtin_exceptions.not_found) then do
              return --[[ :: ]]{
                      --[[ CM_Missing_value ]]Block.__(8, {lab}),
                      err
                    };
            end else do
              throw exn;
            end end 
          end
        end end), sign2.csig_vars, error$2);
  error$4 = fold((function (lab, param, err) do
          if (param[1] == --[[ Virtual ]]0 and not mem(lab, sign2.csig_vars)) then do
            return --[[ :: ]]{
                    --[[ CM_Hide_virtual ]]Block.__(11, {
                        "instance variable",
                        lab
                      }),
                    err
                  };
          end else do
            return err;
          end end 
        end end), sign1.csig_vars, error$3);
  error$5 = List.fold_right((function (e, l) do
          if (List.mem(e, missing_method)) then do
            return l;
          end else do
            return --[[ :: ]]{
                    --[[ CM_Virtual_method ]]Block.__(14, {e}),
                    l
                  };
          end end 
        end end), elements_aux(--[[ [] ]]0, diff(sign2.csig_concr, sign1.csig_concr)), error$4);
  if (error$5) then do
    return error$5;
  end else do
    try do
      lp = List.length(patt_params);
      ls = List.length(subj_params);
      if (lp ~= ls) then do
        throw {
              Failure,
              --[[ :: ]]{
                --[[ CM_Parameter_arity_mismatch ]]Block.__(0, {
                    lp,
                    ls
                  }),
                --[[ [] ]]0
              }
            };
      end
       end 
      List.iter2((function (p, s) do
              try do
                return eqtype$1(true, type_pairs, subst, env, p, s);
              end
              catch (raw_exn)do
                exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                if (exn[0] == Unify) then do
                  throw {
                        Failure,
                        --[[ :: ]]{
                          --[[ CM_Type_parameter_mismatch ]]Block.__(1, {
                              env,
                              expand_trace(env, exn[1])
                            }),
                          --[[ [] ]]0
                        }
                      };
                end
                 end 
                throw exn;
              end
            end end), patt_params, subj_params);
      equal_clty(false, type_pairs, subst, env, --[[ Cty_signature ]]Block.__(1, {sign1}), --[[ Cty_signature ]]Block.__(1, {sign2}));
      clty_params = function (param, param$1) do
        return List.fold_right((function (ty, cty) do
                      return --[[ Cty_arrow ]]Block.__(2, {
                                "*",
                                ty,
                                cty
                              });
                    end end), param, param$1);
      end end;
      return match_class_types(false, env, clty_params(patt_params, patt_type), clty_params(subj_params, subj_type));
    end
    catch (raw_exn)do
      exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] == Failure) then do
        return exn[1];
      end else do
        throw exn;
      end end 
    end
  end end 
end end

warn = do
  contents: false
end;

function pred_expand(n) do
  if (n % 2 == 0 and n > 0) then do
    return n - 1 | 0;
  end else do
    return n;
  end end 
end end

function pred_enlarge(n) do
  if (n % 2 == 1) then do
    return n - 1 | 0;
  end else do
    return n;
  end end 
end end

function collect(l) do
  return List.fold_left((function (c1, param) do
                return Caml_primitive.caml_int_max(c1, param[1]);
              end end), --[[ Unchanged ]]0, l);
end end

function filter_visited(_l) do
  while(true) do
    l = _l;
    if (l) then do
      match = l[0].desc;
      if (typeof match == "number") then do
        _l = l[1];
        continue ;
      end else do
        local ___conditional___=(match.tag | 0);
        do
           if ___conditional___ = 4--[[ Tobject ]]
           or ___conditional___ = 8--[[ Tvariant ]] then do
              return l;end end end 
           do
          else do
            _l = l[1];
            continue ;
            end end
            
        end
      end end 
    end else do
      return --[[ [] ]]0;
    end end 
  end;
end end

function memq_warn(t, visited) do
  if (List.memq(t, visited)) then do
    warn.contents = true;
    return true;
  end else do
    return false;
  end end 
end end

function lid_of_path($staropt$star, param) do
  sharp = $staropt$star ~= undefined and $staropt$star or "";
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Pident ]] then do
        return --[[ Lident ]]Block.__(0, {sharp .. param[0].name});end end end 
     if ___conditional___ = 1--[[ Pdot ]] then do
        return --[[ Ldot ]]Block.__(1, {
                  lid_of_path(undefined, param[0]),
                  sharp .. param[1]
                });end end end 
     if ___conditional___ = 2--[[ Papply ]] then do
        return --[[ Lapply ]]Block.__(2, {
                  lid_of_path(sharp, param[0]),
                  lid_of_path(undefined, param[1])
                });end end end 
     do
    
  end
end end

function find_cltype_for_path(env, p) do
  match = lookup_type$1(lid_of_path("#", p), env);
  cl_abbr = match[1];
  match$1 = cl_abbr.type_manifest;
  if (match$1 ~= undefined) then do
    ty = match$1;
    match$2 = repr(ty).desc;
    if (typeof match$2 == "number") then do
      throw Caml_builtin_exceptions.not_found;
    end else if (match$2.tag == --[[ Tobject ]]4) then do
      match$3 = match$2[1].contents;
      if (match$3 ~= undefined) then do
        if (same(p, match$3[0])) then do
          return --[[ tuple ]]{
                  cl_abbr,
                  ty
                };
        end else do
          throw Caml_builtin_exceptions.not_found;
        end end 
      end else do
        throw Caml_builtin_exceptions.not_found;
      end end 
    end else do
      throw Caml_builtin_exceptions.not_found;
    end end  end 
  end else do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ctype.ml",
            3707,
            12
          }
        };
  end end 
end end

function build_subtype(env, visited, loops, posi, level, t) do
  t$1 = repr(t);
  match = t$1.desc;
  if (typeof match == "number") then do
    if (posi) then do
      v = newvar(undefined, --[[ () ]]0);
      return --[[ tuple ]]{
              v,
              --[[ Changed ]]2
            };
    end else do
      warn.contents = true;
      return --[[ tuple ]]{
              t$1,
              --[[ Unchanged ]]0
            };
    end end 
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 0--[[ Tvar ]] then do
          if (posi) then do
            try do
              t$prime = List.assq(t$1, loops);
              warn.contents = true;
              return --[[ tuple ]]{
                      t$prime,
                      --[[ Equiv ]]1
                    };
            end
            catch (exn)do
              if (exn == Caml_builtin_exceptions.not_found) then do
                return --[[ tuple ]]{
                        t$1,
                        --[[ Unchanged ]]0
                      };
              end else do
                throw exn;
              end end 
            end
          end else do
            return --[[ tuple ]]{
                    t$1,
                    --[[ Unchanged ]]0
                  };
          end end end end end 
       if ___conditional___ = 1--[[ Tarrow ]] then do
          if (memq_warn(t$1, visited)) then do
            return --[[ tuple ]]{
                    t$1,
                    --[[ Unchanged ]]0
                  };
          end else do
            visited$1 = --[[ :: ]]{
              t$1,
              visited
            };
            match$1 = build_subtype(env, visited$1, loops, not posi, level, match[1]);
            match$2 = build_subtype(env, visited$1, loops, posi, level, match[2]);
            c = Caml_primitive.caml_int_max(match$1[1], match$2[1]);
            if (c > --[[ Unchanged ]]0) then do
              return --[[ tuple ]]{
                      newty2(current_level.contents, --[[ Tarrow ]]Block.__(1, {
                              match[0],
                              match$1[0],
                              match$2[0],
                              --[[ Cok ]]0
                            })),
                      c
                    };
            end else do
              return --[[ tuple ]]{
                      t$1,
                      --[[ Unchanged ]]0
                    };
            end end 
          end end end end end 
       if ___conditional___ = 2--[[ Ttuple ]] then do
          if (memq_warn(t$1, visited)) then do
            return --[[ tuple ]]{
                    t$1,
                    --[[ Unchanged ]]0
                  };
          end else do
            visited$2 = --[[ :: ]]{
              t$1,
              visited
            };
            tlist$prime = List.map((function (param) do
                    return build_subtype(env, visited$2, loops, posi, level, param);
                  end end), match[0]);
            c$1 = collect(tlist$prime);
            if (c$1 > --[[ Unchanged ]]0) then do
              desc = --[[ Ttuple ]]Block.__(2, {List.map((function (prim) do
                          return prim[0];
                        end end), tlist$prime)});
              return --[[ tuple ]]{
                      newty2(current_level.contents, desc),
                      c$1
                    };
            end else do
              return --[[ tuple ]]{
                      t$1,
                      --[[ Unchanged ]]0
                    };
            end end 
          end end end end end 
       if ___conditional___ = 3--[[ Tconstr ]] then do
          tl = match[1];
          p = match[0];
          if (level > 0 and generic_abbrev(env, p) and safe_abbrev(env, t$1) and not has_constr_row(expand_abbrev(env)(t$1))) then do
            t$prime$1 = repr(expand_abbrev(env)(t$1));
            level$prime = pred_expand(level);
            try do
              match$3 = t$prime$1.desc;
              if (typeof match$3 == "number") then do
                throw Caml_builtin_exceptions.not_found;
              end else if (match$3.tag == --[[ Tobject ]]4) then do
                if (posi and not opened_object(t$prime$1)) then do
                  match$4 = find_cltype_for_path(env, p);
                  ty = subst(env, current_level.contents, --[[ Public ]]1, match[2], undefined, match$4[0].type_params, tl, match$4[1]);
                  ty$1 = repr(ty);
                  match$5 = ty$1.desc;
                  match$6;
                  if (typeof match$5 == "number") then do
                    throw Caml_builtin_exceptions.not_found;
                  end else if (match$5.tag == --[[ Tobject ]]4) then do
                    match$7 = match$5[1].contents;
                    if (match$7 ~= undefined) then do
                      match$8 = match$7;
                      if (same(p, match$8[0])) then do
                        match$6 = --[[ tuple ]]{
                          match$5[0],
                          match$8[1]
                        };
                      end else do
                        throw Caml_builtin_exceptions.not_found;
                      end end 
                    end else do
                      throw Caml_builtin_exceptions.not_found;
                    end end 
                  end else do
                    throw Caml_builtin_exceptions.not_found;
                  end end  end 
                  tl1 = match$6[1];
                  if (List.exists((function (param) do
                            return deep_occur(ty$1, param);
                          end end), tl1)) then do
                    throw Caml_builtin_exceptions.not_found;
                  end
                   end 
                  ty$1.desc = --[[ Tvar ]]Block.__(0, {undefined});
                  t$prime$prime = newvar(undefined, --[[ () ]]0);
                  loops_000 = --[[ tuple ]]{
                    ty$1,
                    t$prime$prime
                  };
                  loops$1 = --[[ :: ]]{
                    loops_000,
                    loops
                  };
                  match$9 = build_subtype(env, --[[ :: ]]{
                        t$prime$1,
                        --[[ [] ]]0
                      }, loops$1, posi, pred_enlarge(level$prime), match$6[0]);
                  ty1$prime = match$9[0];
                  if (not is_Tvar(t$prime$prime)) then do
                    throw {
                          Caml_builtin_exceptions.assert_failure,
                          --[[ tuple ]]{
                            "ctype.ml",
                            3770,
                            10
                          }
                        };
                  end
                   end 
                  nm = match$9[1] > --[[ Equiv ]]1 or deep_occur(ty$1, ty1$prime) and undefined or --[[ tuple ]]{
                      p,
                      tl1
                    };
                  t$prime$prime.desc = --[[ Tobject ]]Block.__(4, {
                      ty1$prime,
                      do
                        contents: nm
                      end
                    });
                  try do
                    unify_var(env, ty$1, t$1);
                  end
                  catch (raw_exn)do
                    exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn$1[0] == Unify) then do
                      throw {
                            Caml_builtin_exceptions.assert_failure,
                            --[[ tuple ]]{
                              "ctype.ml",
                              3774,
                              50
                            }
                          };
                    end
                     end 
                    throw exn$1;
                  end
                  return --[[ tuple ]]{
                          t$prime$prime,
                          --[[ Changed ]]2
                        };
                end else do
                  throw Caml_builtin_exceptions.not_found;
                end end 
              end else do
                throw Caml_builtin_exceptions.not_found;
              end end  end 
            end
            catch (exn$2)do
              if (exn$2 == Caml_builtin_exceptions.not_found) then do
                match$10 = build_subtype(env, visited, loops, posi, level$prime, t$prime$1);
                c$2 = match$10[1];
                if (c$2 > --[[ Unchanged ]]0) then do
                  return --[[ tuple ]]{
                          match$10[0],
                          c$2
                        };
                end else do
                  return --[[ tuple ]]{
                          t$1,
                          --[[ Unchanged ]]0
                        };
                end end 
              end else do
                throw exn$2;
              end end 
            end
          end else if (memq_warn(t$1, visited)) then do
            return --[[ tuple ]]{
                    t$1,
                    --[[ Unchanged ]]0
                  };
          end else do
            visited$3 = --[[ :: ]]{
              t$1,
              visited
            };
            try do
              decl = find_type_full(p, env)[0];
              if (level == 0 and generic_abbrev(env, p) and safe_abbrev(env, t$1) and not has_constr_row(expand_abbrev(env)(t$1))) then do
                warn.contents = true;
              end
               end 
              tl$prime = List.map2((function (v, t) do
                      match = Curry._1(Types_Variance.get_upper, v);
                      co = match[0];
                      if (match[1]) then do
                        if (co) then do
                          return --[[ tuple ]]{
                                  t,
                                  --[[ Unchanged ]]0
                                };
                        end else do
                          return build_subtype(env, visited$3, loops, not posi, level, t);
                        end end 
                      end else if (co) then do
                        return build_subtype(env, visited$3, loops, posi, level, t);
                      end else do
                        return --[[ tuple ]]{
                                newvar(undefined, --[[ () ]]0),
                                --[[ Changed ]]2
                              };
                      end end  end 
                    end end), decl.type_variance, tl);
              c$3 = collect(tl$prime);
              if (c$3 > --[[ Unchanged ]]0) then do
                return --[[ tuple ]]{
                        newconstr(p, List.map((function (prim) do
                                    return prim[0];
                                  end end), tl$prime)),
                        c$3
                      };
              end else do
                return --[[ tuple ]]{
                        t$1,
                        --[[ Unchanged ]]0
                      };
              end end 
            end
            catch (exn$3)do
              if (exn$3 == Caml_builtin_exceptions.not_found) then do
                return --[[ tuple ]]{
                        t$1,
                        --[[ Unchanged ]]0
                      };
              end else do
                throw exn$3;
              end end 
            end
          end end  end end end end 
       if ___conditional___ = 4--[[ Tobject ]] then do
          t1 = match[0];
          if (memq_warn(t$1, visited) or opened_object(t1)) then do
            return --[[ tuple ]]{
                    t$1,
                    --[[ Unchanged ]]0
                  };
          end else do
            level$prime$1 = pred_enlarge(level);
            visited_001 = level$prime$1 < level and --[[ [] ]]0 or filter_visited(visited);
            visited$4 = --[[ :: ]]{
              t$1,
              visited_001
            };
            match$11 = build_subtype(env, visited$4, loops, posi, level$prime$1, t1);
            c$4 = match$11[1];
            if (c$4 > --[[ Unchanged ]]0) then do
              return --[[ tuple ]]{
                      newty2(current_level.contents, --[[ Tobject ]]Block.__(4, {
                              match$11[0],
                              do
                                contents: undefined
                              end
                            })),
                      c$4
                    };
            end else do
              return --[[ tuple ]]{
                      t$1,
                      --[[ Unchanged ]]0
                    };
            end end 
          end end end end end 
       if ___conditional___ = 5--[[ Tfield ]] then do
          match$12 = build_subtype(env, visited, loops, posi, level, match[2]);
          match$13 = build_subtype(env, visited, loops, posi, level, match[3]);
          c$5 = Caml_primitive.caml_int_max(match$12[1], match$13[1]);
          if (c$5 > --[[ Unchanged ]]0) then do
            return --[[ tuple ]]{
                    newty2(current_level.contents, --[[ Tfield ]]Block.__(5, {
                            match[0],
                            --[[ Fpresent ]]0,
                            match$12[0],
                            match$13[0]
                          })),
                    c$5
                  };
          end else do
            return --[[ tuple ]]{
                    t$1,
                    --[[ Unchanged ]]0
                  };
          end end end end end 
       if ___conditional___ = 6--[[ Tlink ]]
       or ___conditional___ = 7--[[ Tsubst ]] then do
          throw {
                Caml_builtin_exceptions.assert_failure,
                --[[ tuple ]]{
                  "ctype.ml",
                  3865,
                  6
                }
              };end end end 
       if ___conditional___ = 8--[[ Tvariant ]] then do
          row = row_repr_aux(--[[ [] ]]0, match[0]);
          if (memq_warn(t$1, visited) or not static_row(row)) then do
            return --[[ tuple ]]{
                    t$1,
                    --[[ Unchanged ]]0
                  };
          end else do
            level$prime$2 = pred_enlarge(level);
            visited_001$1 = level$prime$2 < level and --[[ [] ]]0 or filter_visited(visited);
            visited$5 = --[[ :: ]]{
              t$1,
              visited_001$1
            };
            fields = filter_row_fields(false, row.row_fields);
            fields$1 = List.map((function (orig) do
                    l = orig[0];
                    match = row_field_repr_aux(--[[ [] ]]0, orig[1]);
                    if (typeof match == "number") then do
                      throw {
                            Caml_builtin_exceptions.assert_failure,
                            --[[ tuple ]]{
                              "ctype.ml",
                              3832,
                              17
                            }
                          };
                    end else if (match.tag) then do
                      throw {
                            Caml_builtin_exceptions.assert_failure,
                            --[[ tuple ]]{
                              "ctype.ml",
                              3832,
                              17
                            }
                          };
                    end else do
                      match$1 = match[0];
                      if (match$1 ~= undefined) then do
                        match$2 = build_subtype(env, visited$5, loops, posi, level$prime$2, match$1);
                        t$prime = match$2[0];
                        f = posi and level > 0 and --[[ Reither ]]Block.__(1, {
                              false,
                              --[[ :: ]]{
                                t$prime,
                                --[[ [] ]]0
                              },
                              false,
                              do
                                contents: undefined
                              end
                            }) or --[[ Rpresent ]]Block.__(0, {t$prime});
                        return --[[ tuple ]]{
                                --[[ tuple ]]{
                                  l,
                                  f
                                },
                                match$2[1]
                              };
                      end else if (posi) then do
                        return --[[ tuple ]]{
                                --[[ tuple ]]{
                                  l,
                                  --[[ Reither ]]Block.__(1, {
                                      true,
                                      --[[ [] ]]0,
                                      false,
                                      do
                                        contents: undefined
                                      end
                                    })
                                },
                                --[[ Unchanged ]]0
                              };
                      end else do
                        return --[[ tuple ]]{
                                orig,
                                --[[ Unchanged ]]0
                              };
                      end end  end 
                    end end  end 
                  end end), fields);
            c$6 = collect(fields$1);
            row_row_fields = List.map((function (prim) do
                    return prim[0];
                  end end), fields$1);
            row_row_more = newvar(undefined, --[[ () ]]0);
            row_row_name = c$6 > --[[ Unchanged ]]0 and undefined or row.row_name;
            row$1 = do
              row_fields: row_row_fields,
              row_more: row_row_more,
              row_bound: --[[ () ]]0,
              row_closed: posi,
              row_fixed: false,
              row_name: row_row_name
            end;
            return --[[ tuple ]]{
                    newty2(current_level.contents, --[[ Tvariant ]]Block.__(8, {row$1})),
                    --[[ Changed ]]2
                  };
          end end end end end 
       if ___conditional___ = 10--[[ Tpoly ]] then do
          match$14 = build_subtype(env, visited, loops, posi, level, match[0]);
          c$7 = match$14[1];
          if (c$7 > --[[ Unchanged ]]0) then do
            return --[[ tuple ]]{
                    newty2(current_level.contents, --[[ Tpoly ]]Block.__(10, {
                            match$14[0],
                            match[1]
                          })),
                    c$7
                  };
          end else do
            return --[[ tuple ]]{
                    t$1,
                    --[[ Unchanged ]]0
                  };
          end end end end end 
       if ___conditional___ = 9--[[ Tunivar ]]
       or ___conditional___ = 11--[[ Tpackage ]] then do
          return --[[ tuple ]]{
                  t$1,
                  --[[ Unchanged ]]0
                };end end end 
       do
      
    end
  end end 
end end

function enlarge_type(env, ty) do
  warn.contents = false;
  match = build_subtype(env, --[[ [] ]]0, --[[ [] ]]0, true, 4, ty);
  return --[[ tuple ]]{
          match[0],
          warn.contents
        };
end end

subtypes = Curry._1(TypePairs.create, 17);

function subtype_error(env, trace) do
  throw {
        Subtype,
        expand_trace(env, List.rev(trace)),
        --[[ [] ]]0
      };
end end

function subtype_rec(env, _trace, _t1, _t2, _cstrs) do
  while(true) do
    cstrs = _cstrs;
    t2 = _t2;
    t1 = _t1;
    trace = _trace;
    t1$1 = repr(t1);
    t2$1 = repr(t2);
    if (t1$1 == t2$1) then do
      return cstrs;
    end else do
      try do
        Curry._2(TypePairs.find, subtypes, --[[ tuple ]]{
              t1$1,
              t2$1
            });
        return cstrs;
      end
      catch (exn)do
        if (exn == Caml_builtin_exceptions.not_found) then do
          Curry._3(TypePairs.add, subtypes, --[[ tuple ]]{
                t1$1,
                t2$1
              }, --[[ () ]]0);
          match = t1$1.desc;
          match$1 = t2$1.desc;
          exit = 0;
          exit$1 = 0;
          exit$2 = 0;
          exit$3 = 0;
          exit$4 = 0;
          if (typeof match == "number") then do
            exit$4 = 6;
          end else do
            local ___conditional___=(match.tag | 0);
            do
               if ___conditional___ = 0--[[ Tvar ]] then do
                  exit = 2;end else 
               if ___conditional___ = 1--[[ Tarrow ]] then do
                  u1 = match[2];
                  t1$2 = match[1];
                  l1 = match[0];
                  if (typeof match$1 == "number") then do
                    exit = 1;
                  end else do
                    local ___conditional___=(match$1.tag | 0);
                    do
                       if ___conditional___ = 0--[[ Tvar ]] then do
                          exit$4 = 6;end else 
                       if ___conditional___ = 1--[[ Tarrow ]] then do
                          u2 = match$1[2];
                          t2$2 = match$1[1];
                          l2 = match$1[0];
                          if (l1 == l2 or classic.contents and not (is_optional(l1) or is_optional(l2))) then do
                            cstrs$1 = subtype_rec(env, --[[ :: ]]{
                                  --[[ tuple ]]{
                                    t2$2,
                                    t1$2
                                  },
                                  trace
                                }, t2$2, t1$2, cstrs);
                            _cstrs = cstrs$1;
                            _t2 = u2;
                            _t1 = u1;
                            _trace = --[[ :: ]]{
                              --[[ tuple ]]{
                                u1,
                                u2
                              },
                              trace
                            };
                            continue ;
                          end else do
                            exit = 1;
                          end end end else 
                       if ___conditional___ = 3--[[ Tconstr ]] then do
                          exit$2 = 4;end else 
                       do end end end end
                      else do
                        exit = 1;
                        end end
                        
                    end
                  end end end else 
               if ___conditional___ = 2--[[ Ttuple ]] then do
                  if (typeof match$1 == "number") then do
                    exit = 1;
                  end else do
                    local ___conditional___=(match$1.tag | 0);
                    do
                       if ___conditional___ = 0--[[ Tvar ]] then do
                          exit$4 = 6;end else 
                       if ___conditional___ = 2--[[ Ttuple ]] then do
                          env$1 = env;
                          trace$1 = trace;
                          tl1 = match[0];
                          tl2 = match$1[0];
                          cstrs$2 = cstrs;
                          if (List.length(tl1) ~= List.length(tl2)) then do
                            subtype_error(env$1, trace$1);
                          end
                           end 
                          return List.fold_left2((function(env$1,trace$1)do
                                    return function (cstrs, t1, t2) do
                                      return subtype_rec(env$1, --[[ :: ]]{
                                                  --[[ tuple ]]{
                                                    t1,
                                                    t2
                                                  },
                                                  trace$1
                                                }, t1, t2, cstrs);
                                    end end
                                    end(env$1,trace$1)), cstrs$2, tl1, tl2);end end end 
                       if ___conditional___ = 3--[[ Tconstr ]] then do
                          exit$2 = 4;end else 
                       do end end
                      else do
                        exit = 1;
                        end end
                        
                    end
                  end end end else 
               if ___conditional___ = 3--[[ Tconstr ]] then do
                  if (match[1]) then do
                    exit$4 = 6;
                  end else if (typeof match$1 == "number") then do
                    exit$3 = 5;
                  end else do
                    local ___conditional___=(match$1.tag | 0);
                    do
                       if ___conditional___ = 0--[[ Tvar ]] then do
                          exit$4 = 6;end else 
                       if ___conditional___ = 3--[[ Tconstr ]] then do
                          if (match$1[1] or not same(match[0], match$1[0])) then do
                            exit$3 = 5;
                          end else do
                            return cstrs;
                          end end end else 
                       do end end end
                      else do
                        exit$3 = 5;
                        end end
                        
                    end
                  end end  end end else 
               if ___conditional___ = 4--[[ Tobject ]] then do
                  f1 = match[0];
                  if (typeof match$1 == "number") then do
                    exit = 1;
                  end else do
                    local ___conditional___=(match$1.tag | 0);
                    do
                       if ___conditional___ = 0--[[ Tvar ]] then do
                          exit$4 = 6;end else 
                       if ___conditional___ = 3--[[ Tconstr ]] then do
                          exit$2 = 4;end else 
                       if ___conditional___ = 4--[[ Tobject ]] then do
                          f2 = match$1[0];
                          if (is_Tvar(object_row(f1)) and is_Tvar(object_row(f2))) then do
                            return --[[ :: ]]{
                                    --[[ tuple ]]{
                                      trace,
                                      t1$1,
                                      t2$1,
                                      univar_pairs.contents
                                    },
                                    cstrs
                                  };
                          end else do
                            env$2 = env;
                            trace$2 = trace;
                            ty1 = f1;
                            ty2 = f2;
                            cstrs$3 = cstrs;
                            match$2 = flatten_fields(ty1);
                            rest1 = match$2[1];
                            match$3 = flatten_fields(ty2);
                            rest2 = match$3[1];
                            match$4 = associate_fields(match$2[0], match$3[0]);
                            miss2 = match$4[2];
                            miss1 = match$4[1];
                            cstrs$4 = rest2.desc == --[[ Tnil ]]0 and cstrs$3 or (
                                miss1 == --[[ [] ]]0 and subtype_rec(env$2, --[[ :: ]]{
                                        --[[ tuple ]]{
                                          rest1,
                                          rest2
                                        },
                                        trace$2
                                      }, rest1, rest2, cstrs$3) or --[[ :: ]]{
                                    --[[ tuple ]]{
                                      trace$2,
                                      build_fields(repr(ty1).level)(miss1, rest1),
                                      rest2,
                                      univar_pairs.contents
                                    },
                                    cstrs$3
                                  }
                              );
                            cstrs$5 = miss2 == --[[ [] ]]0 and cstrs$4 or --[[ :: ]]{
                                --[[ tuple ]]{
                                  trace$2,
                                  rest1,
                                  build_fields(repr(ty2).level)(miss2, newvar(undefined, --[[ () ]]0)),
                                  univar_pairs.contents
                                },
                                cstrs$4
                              };
                            return List.fold_left((function(env$2,trace$2)do
                                      return function (cstrs, param) do
                                        t2 = param[4];
                                        t1 = param[2];
                                        return subtype_rec(env$2, --[[ :: ]]{
                                                    --[[ tuple ]]{
                                                      t1,
                                                      t2
                                                    },
                                                    trace$2
                                                  }, t1, t2, cstrs);
                                      end end
                                      end(env$2,trace$2)), cstrs$5, match$4[0]);
                          end end end end end 
                       do end end
                      else do
                        exit = 1;
                        end end
                        
                    end
                  end end end else 
               if ___conditional___ = 8--[[ Tvariant ]] then do
                  if (typeof match$1 == "number") then do
                    exit = 1;
                  end else do
                    local ___conditional___=(match$1.tag | 0);
                    do
                       if ___conditional___ = 0--[[ Tvar ]] then do
                          exit$4 = 6;end else 
                       if ___conditional___ = 3--[[ Tconstr ]] then do
                          exit$2 = 4;end else 
                       if ___conditional___ = 8--[[ Tvariant ]] then do
                          try do
                            env$3 = env;
                            trace$3 = trace;
                            row1 = match[0];
                            row2 = match$1[0];
                            cstrs$6 = cstrs;
                            row1$1 = row_repr_aux(--[[ [] ]]0, row1);
                            row2$1 = row_repr_aux(--[[ [] ]]0, row2);
                            match$5 = merge_row_fields(row1$1.row_fields, row2$1.row_fields);
                            pairs = match$5[2];
                            r1 = match$5[0];
                            more1 = repr(row1$1.row_more);
                            more2 = repr(row2$1.row_more);
                            match$6 = more1.desc;
                            match$7 = more2.desc;
                            exit$5 = 0;
                            if (typeof match$6 == "number") then do
                              exit$5 = 1;
                            end else do
                              local ___conditional___=(match$6.tag | 0);
                              do
                                 if ___conditional___ = 0--[[ Tvar ]] then do
                                    exit$5 = 1;end else 
                                 if ___conditional___ = 3--[[ Tconstr ]] then do
                                    if (typeof match$7 == "number" or not (match$7.tag == --[[ Tconstr ]]3 and same(match$6[0], match$7[0]))) then do
                                      exit$5 = 1;
                                    end else do
                                      return subtype_rec(env$3, --[[ :: ]]{
                                                  --[[ tuple ]]{
                                                    more1,
                                                    more2
                                                  },
                                                  trace$3
                                                }, more1, more2, cstrs$6);
                                    end end end else 
                                 if ___conditional___ = 9--[[ Tunivar ]] then do
                                    if (typeof match$7 == "number") then do
                                      throw Pervasives.Exit;
                                    end else if (match$7.tag == --[[ Tunivar ]]9) then do
                                      if (row1$1.row_closed == row2$1.row_closed and r1 == --[[ [] ]]0 and match$5[1] == --[[ [] ]]0) then do
                                        cstrs$7 = subtype_rec(env$3, --[[ :: ]]{
                                              --[[ tuple ]]{
                                                more1,
                                                more2
                                              },
                                              trace$3
                                            }, more1, more2, cstrs$6);
                                        return List.fold_left((function(env$3,trace$3)do
                                                  return function (cstrs, param) do
                                                    match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                                                    match$1 = row_field_repr_aux(--[[ [] ]]0, param[2]);
                                                    t1;
                                                    t2;
                                                    if (typeof match == "number") then do
                                                      if (typeof match$1 == "number") then do
                                                        return cstrs;
                                                      end else do
                                                        throw Pervasives.Exit;
                                                      end end 
                                                    end else if (match.tag) then do
                                                      if (match[0]) then do
                                                        if (match[1]) then do
                                                          throw Pervasives.Exit;
                                                        end
                                                         end 
                                                        if (typeof match$1 == "number") then do
                                                          throw Pervasives.Exit;
                                                        end else if (match$1.tag) then do
                                                          if (match$1[0]) then do
                                                            if (match$1[1]) then do
                                                              throw Pervasives.Exit;
                                                            end
                                                             end 
                                                            return cstrs;
                                                          end else do
                                                            throw Pervasives.Exit;
                                                          end end 
                                                        end else do
                                                          throw Pervasives.Exit;
                                                        end end  end 
                                                      end else do
                                                        match$2 = match[1];
                                                        if (match$2) then do
                                                          if (match$2[1]) then do
                                                            throw Pervasives.Exit;
                                                          end
                                                           end 
                                                          if (typeof match$1 == "number") then do
                                                            throw Pervasives.Exit;
                                                          end else if (match$1.tag) then do
                                                            if (match$1[0]) then do
                                                              throw Pervasives.Exit;
                                                            end
                                                             end 
                                                            match$3 = match$1[1];
                                                            if (match$3) then do
                                                              if (match$3[1]) then do
                                                                throw Pervasives.Exit;
                                                              end
                                                               end 
                                                              t1 = match$2[0];
                                                              t2 = match$3[0];
                                                            end else do
                                                              throw Pervasives.Exit;
                                                            end end 
                                                          end else do
                                                            throw Pervasives.Exit;
                                                          end end  end 
                                                        end else do
                                                          throw Pervasives.Exit;
                                                        end end 
                                                      end end 
                                                    end else do
                                                      match$4 = match[0];
                                                      if (match$4 ~= undefined) then do
                                                        if (typeof match$1 == "number") then do
                                                          throw Pervasives.Exit;
                                                        end else if (match$1.tag) then do
                                                          throw Pervasives.Exit;
                                                        end else do
                                                          match$5 = match$1[0];
                                                          if (match$5 ~= undefined) then do
                                                            t1 = match$4;
                                                            t2 = match$5;
                                                          end else do
                                                            throw Pervasives.Exit;
                                                          end end 
                                                        end end  end 
                                                      end else if (typeof match$1 == "number") then do
                                                        throw Pervasives.Exit;
                                                      end else if (match$1.tag) then do
                                                        throw Pervasives.Exit;
                                                      end else do
                                                        if (match$1[0] ~= undefined) then do
                                                          throw Pervasives.Exit;
                                                        end
                                                         end 
                                                        return cstrs;
                                                      end end  end  end 
                                                    end end  end 
                                                    return subtype_rec(env$3, --[[ :: ]]{
                                                                --[[ tuple ]]{
                                                                  t1,
                                                                  t2
                                                                },
                                                                trace$3
                                                              }, t1, t2, cstrs);
                                                  end end
                                                  end(env$3,trace$3)), cstrs$7, pairs);
                                      end else do
                                        throw Pervasives.Exit;
                                      end end 
                                    end else do
                                      throw Pervasives.Exit;
                                    end end  end end end end 
                                 do end end
                                else do
                                  throw Pervasives.Exit;
                                  end end
                                  
                              end
                            end end 
                            if (exit$5 == 1) then do
                              if (typeof match$7 ~= "number") then do
                                local ___conditional___=(match$7.tag | 0);
                                do
                                   if ___conditional___ = 0--[[ Tvar ]]
                                   or ___conditional___ = 3--[[ Tconstr ]]
                                   do end
                                  else do
                                    throw Pervasives.Exit;
                                    end end
                                    
                                end
                              end
                               end 
                              if (row1$1.row_closed and r1 == --[[ [] ]]0) then do
                                return List.fold_left((function(env$3,trace$3)do
                                          return function (cstrs, param) do
                                            match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                                            match$1 = row_field_repr_aux(--[[ [] ]]0, param[2]);
                                            if (typeof match == "number") then do
                                              return cstrs;
                                            end else if (match.tag) then do
                                              if (not match[0]) then do
                                                match$2 = match[1];
                                                if (match$2) then do
                                                  t1 = match$2[0];
                                                  if (typeof match$1 == "number") then do
                                                    throw Pervasives.Exit;
                                                  end else if (match$1.tag) then do
                                                    throw Pervasives.Exit;
                                                  end else do
                                                    match$3 = match$1[0];
                                                    if (match$3 ~= undefined) then do
                                                      t2 = match$3;
                                                      return subtype_rec(env$3, --[[ :: ]]{
                                                                  --[[ tuple ]]{
                                                                    t1,
                                                                    t2
                                                                  },
                                                                  trace$3
                                                                }, t1, t2, cstrs);
                                                    end else do
                                                      throw Pervasives.Exit;
                                                    end end 
                                                  end end  end 
                                                end else do
                                                  throw Pervasives.Exit;
                                                end end 
                                              end
                                               end 
                                            end else do
                                              match$4 = match[0];
                                              if (match$4 ~= undefined) then do
                                                t1$1 = match$4;
                                                if (typeof match$1 == "number") then do
                                                  throw Pervasives.Exit;
                                                end else if (match$1.tag) then do
                                                  throw Pervasives.Exit;
                                                end else do
                                                  match$5 = match$1[0];
                                                  if (match$5 ~= undefined) then do
                                                    t2$1 = match$5;
                                                    return subtype_rec(env$3, --[[ :: ]]{
                                                                --[[ tuple ]]{
                                                                  t1$1,
                                                                  t2$1
                                                                },
                                                                trace$3
                                                              }, t1$1, t2$1, cstrs);
                                                  end else do
                                                    throw Pervasives.Exit;
                                                  end end 
                                                end end  end 
                                              end
                                               end 
                                            end end  end 
                                            if (typeof match$1 == "number") then do
                                              throw Pervasives.Exit;
                                            end else if (match$1.tag) then do
                                              throw Pervasives.Exit;
                                            end else do
                                              if (match$1[0] ~= undefined) then do
                                                throw Pervasives.Exit;
                                              end
                                               end 
                                              return cstrs;
                                            end end  end 
                                          end end
                                          end(env$3,trace$3)), cstrs$6, pairs);
                              end else do
                                throw Pervasives.Exit;
                              end end 
                            end
                             end 
                          end
                          catch (exn$1)do
                            if (exn$1 == Pervasives.Exit) then do
                              return --[[ :: ]]{
                                      --[[ tuple ]]{
                                        trace,
                                        t1$1,
                                        t2$1,
                                        univar_pairs.contents
                                      },
                                      cstrs
                                    };
                            end else do
                              throw exn$1;
                            end end 
                          endend end end 
                       do end end
                      else do
                        exit = 1;
                        end end
                        
                    end
                  end end end else 
               if ___conditional___ = 10--[[ Tpoly ]] then do
                  tl1$1 = match[1];
                  u1$1 = match[0];
                  exit$6 = 0;
                  if (tl1$1) then do
                    exit$6 = 7;
                  end else if (typeof match$1 == "number") then do
                    exit = 1;
                  end else do
                    local ___conditional___=(match$1.tag | 0);
                    do
                       if ___conditional___ = 0--[[ Tvar ]] then do
                          exit$4 = 6;end else 
                       if ___conditional___ = 3--[[ Tconstr ]] then do
                          exit$2 = 4;end else 
                       if ___conditional___ = 10--[[ Tpoly ]] then do
                          if (match$1[1]) then do
                            exit$6 = 7;
                          end else do
                            _t2 = match$1[0];
                            _t1 = u1$1;
                            continue ;
                          end end end else 
                       do end end end end
                      else do
                        exit = 1;
                        end end
                        
                    end
                  end end  end 
                  if (exit$6 == 7) then do
                    if (typeof match$1 == "number") then do
                      exit = 1;
                    end else do
                      local ___conditional___=(match$1.tag | 0);
                      do
                         if ___conditional___ = 0--[[ Tvar ]] then do
                            exit$4 = 6;end else 
                         if ___conditional___ = 3--[[ Tconstr ]] then do
                            exit$2 = 4;end else 
                         if ___conditional___ = 10--[[ Tpoly ]] then do
                            tl2$1 = match$1[1];
                            u2$1 = match$1[0];
                            if (tl2$1) then do
                              try do
                                return enter_poly(env, univar_pairs, u1$1, tl1$1, u2$1, tl2$1, (function(trace,cstrs)do
                                          return function (t1, t2) do
                                            return subtype_rec(env, trace, t1, t2, cstrs);
                                          end end
                                          end(trace,cstrs)));
                              end
                              catch (raw_exn)do
                                exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn);
                                if (exn$2[0] == Unify) then do
                                  return --[[ :: ]]{
                                          --[[ tuple ]]{
                                            trace,
                                            t1$1,
                                            t2$1,
                                            univar_pairs.contents
                                          },
                                          cstrs
                                        };
                                end else do
                                  throw exn$2;
                                end end 
                              end
                            end else do
                              match$8 = instance_poly(undefined, false, tl1$1, u1$1);
                              _t2 = u2$1;
                              _t1 = match$8[1];
                              continue ;
                            end end end end end 
                         do end end
                        else do
                          exit = 1;
                          end end
                          
                      end
                    end end 
                  end
                   end end else 
               if ___conditional___ = 11--[[ Tpackage ]] then do
                  tl1$2 = match[2];
                  nl1 = match[1];
                  p1 = match[0];
                  if (typeof match$1 == "number") then do
                    exit = 1;
                  end else do
                    local ___conditional___=(match$1.tag | 0);
                    do
                       if ___conditional___ = 0--[[ Tvar ]] then do
                          exit$4 = 6;end else 
                       if ___conditional___ = 3--[[ Tconstr ]] then do
                          exit$2 = 4;end else 
                       if ___conditional___ = 11--[[ Tpackage ]] then do
                          tl2$2 = match$1[2];
                          nl2 = match$1[1];
                          p2 = match$1[0];
                          try do
                            ntl1 = complete_type_list(undefined, env, nl2, t1$1.level, --[[ Mty_ident ]]Block.__(0, {p1}), nl1, tl1$2);
                            ntl2 = complete_type_list(true, env, nl1, t2$1.level, --[[ Mty_ident ]]Block.__(0, {p2}), nl2, tl2$2);
                            cstrs$prime = List.map((function(trace,ntl1)do
                                return function (param) do
                                  return --[[ tuple ]]{
                                          trace,
                                          List.assoc(param[0], ntl1),
                                          param[1],
                                          univar_pairs.contents
                                        };
                                end end
                                end(trace,ntl1)), ntl2);
                            if (eq_package_path(env, p1, p2)) then do
                              return Pervasives.$at(cstrs$prime, cstrs);
                            end else do
                              snap = snapshot(--[[ () ]]0);
                              try do
                                List.iter((function (param) do
                                        return unify$2(env, param[1], param[2]);
                                      end end), cstrs$prime);
                                if (Curry._7(package_subtype.contents, env, p1, nl1, tl1$2, p2, nl2, tl2$2)) then do
                                  backtrack(snap);
                                  return Pervasives.$at(cstrs$prime, cstrs);
                                end else do
                                  throw {
                                        Unify,
                                        --[[ [] ]]0
                                      };
                                end end 
                              end
                              catch (raw_exn$1)do
                                exn$3 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
                                if (exn$3[0] == Unify) then do
                                  backtrack(snap);
                                  throw Caml_builtin_exceptions.not_found;
                                end else do
                                  throw exn$3;
                                end end 
                              end
                            end end 
                          end
                          catch (exn$4)do
                            if (exn$4 == Caml_builtin_exceptions.not_found) then do
                              return --[[ :: ]]{
                                      --[[ tuple ]]{
                                        trace,
                                        t1$1,
                                        t2$1,
                                        univar_pairs.contents
                                      },
                                      cstrs
                                    };
                            end else do
                              throw exn$4;
                            end end 
                          endend end end 
                       do end end
                      else do
                        exit = 1;
                        end end
                        
                    end
                  end end end else 
               do end end end end end end end end end
              else do
                exit$4 = 6;
                end end
                
            end
          end end 
          if (exit$4 == 6) then do
            if (typeof match$1 == "number" or match$1.tag) then do
              exit$3 = 5;
            end else do
              exit = 2;
            end end 
          end
           end 
          if (exit$3 == 5) then do
            if (typeof match == "number" or not (match.tag == --[[ Tconstr ]]3 and generic_abbrev(env, match[0]) and safe_abbrev(env, t1$1))) then do
              exit$2 = 4;
            end else do
              _t2 = t2$1;
              _t1 = expand_abbrev(env)(t1$1);
              continue ;
            end end 
          end
           end 
          if (exit$2 == 4) then do
            if (typeof match$1 == "number" or not (match$1.tag == --[[ Tconstr ]]3 and generic_abbrev(env, match$1[0]) and safe_abbrev(env, t2$1))) then do
              exit$1 = 3;
            end else do
              _t2 = expand_abbrev(env)(t2$1);
              _t1 = t1$1;
              continue ;
            end end 
          end
           end 
          if (exit$1 == 3) then do
            if (typeof match == "number" or match.tag ~= --[[ Tconstr ]]3) then do
              exit = 1;
            end else do
              p1$1 = match[0];
              exit$7 = 0;
              if (typeof match$1 == "number" or not (match$1.tag == --[[ Tconstr ]]3 and same(p1$1, match$1[0]))) then do
                exit$7 = 4;
              end else do
                try do
                  decl = find_type_full(p1$1, env)[0];
                  return List.fold_left2((function(trace)do
                            return function (cstrs, v, param) do
                              t2 = param[1];
                              t1 = param[0];
                              match = Curry._1(Types_Variance.get_upper, v);
                              cn = match[1];
                              if (match[0]) then do
                                if (cn) then do
                                  return --[[ :: ]]{
                                          --[[ tuple ]]{
                                            trace,
                                            newty2(t1.level, --[[ Ttuple ]]Block.__(2, {--[[ :: ]]{
                                                      t1,
                                                      --[[ [] ]]0
                                                    }})),
                                            newty2(t2.level, --[[ Ttuple ]]Block.__(2, {--[[ :: ]]{
                                                      t2,
                                                      --[[ [] ]]0
                                                    }})),
                                            univar_pairs.contents
                                          },
                                          cstrs
                                        };
                                end else do
                                  return subtype_rec(env, --[[ :: ]]{
                                              --[[ tuple ]]{
                                                t1,
                                                t2
                                              },
                                              trace
                                            }, t1, t2, cstrs);
                                end end 
                              end else if (cn) then do
                                return subtype_rec(env, --[[ :: ]]{
                                            --[[ tuple ]]{
                                              t2,
                                              t1
                                            },
                                            trace
                                          }, t2, t1, cstrs);
                              end else do
                                return cstrs;
                              end end  end 
                            end end
                            end(trace)), cstrs, decl.type_variance, List.combine(match[1], match$1[1]));
                end
                catch (exn$5)do
                  if (exn$5 == Caml_builtin_exceptions.not_found) then do
                    return --[[ :: ]]{
                            --[[ tuple ]]{
                              trace,
                              t1$1,
                              t2$1,
                              univar_pairs.contents
                            },
                            cstrs
                          };
                  end else do
                    throw exn$5;
                  end end 
                end
              end end 
              if (exit$7 == 4) then do
                if (generic_private_abbrev(env, p1$1)) then do
                  _t2 = t2$1;
                  _t1 = expand_abbrev_opt(env, t1$1);
                  continue ;
                end else do
                  exit = 1;
                end end 
              end
               end 
            end end 
          end
           end 
          local ___conditional___=(exit);
          do
             if ___conditional___ = 1
             or ___conditional___ = 2 then do
                return --[[ :: ]]{
                        --[[ tuple ]]{
                          trace,
                          t1$1,
                          t2$1,
                          univar_pairs.contents
                        },
                        cstrs
                      };end end end 
             do
            
          end
        end else do
          throw exn;
        end end 
      end
    end end 
  end;
end end

function subtype(env, ty1, ty2) do
  Curry._1(TypePairs.clear, subtypes);
  univar_pairs.contents = --[[ [] ]]0;
  cstrs = subtype_rec(env, --[[ :: ]]{
        --[[ tuple ]]{
          ty1,
          ty2
        },
        --[[ [] ]]0
      }, ty1, ty2, --[[ [] ]]0);
  Curry._1(TypePairs.clear, subtypes);
  return (function (param) do
      return List.iter((function (param) do
                    try do
                      return unify_pairs(do
                                  contents: env
                                end, param[1], param[2], param[3]);
                    end
                    catch (raw_exn)do
                      exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                      if (exn[0] == Unify) then do
                        throw {
                              Subtype,
                              expand_trace(env, List.rev(param[0])),
                              List.tl(List.tl(exn[1]))
                            };
                      end
                       end 
                      throw exn;
                    end
                  end end), List.rev(cstrs));
    end end);
end end

function unalias_object(ty) do
  ty$1 = repr(ty);
  match = ty$1.desc;
  if (typeof match == "number") then do
    return newty2(ty$1.level, ty$1.desc);
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 0--[[ Tvar ]] then do
          return newty2(ty$1.level, ty$1.desc);end end end 
       if ___conditional___ = 3--[[ Tconstr ]] then do
          return newty2(ty$1.level, --[[ Tvar ]]Block.__(0, {undefined}));end end end 
       if ___conditional___ = 5--[[ Tfield ]] then do
          return newty2(ty$1.level, --[[ Tfield ]]Block.__(5, {
                        match[0],
                        match[1],
                        match[2],
                        unalias_object(match[3])
                      }));end end end 
       if ___conditional___ = 9--[[ Tunivar ]] then do
          return ty$1;end end end 
       do
      else do
        throw {
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "ctype.ml",
                4129,
                6
              }
            };
        end end
        
    end
  end end 
end end

function unalias(ty) do
  ty$1 = repr(ty);
  match = ty$1.desc;
  if (typeof match == "number") then do
    return newty2(ty$1.level, ty$1.desc);
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 4--[[ Tobject ]] then do
          ty$2 = match[0];
          return newty2(ty$2.level, --[[ Tobject ]]Block.__(4, {
                        unalias_object(ty$2),
                        match[1]
                      }));end end end 
       if ___conditional___ = 8--[[ Tvariant ]] then do
          row = row_repr_aux(--[[ [] ]]0, match[0]);
          more = row.row_more;
          return newty2(ty$1.level, --[[ Tvariant ]]Block.__(8, {do
                          row_fields: row.row_fields,
                          row_more: newty2(more.level, more.desc),
                          row_bound: row.row_bound,
                          row_closed: row.row_closed,
                          row_fixed: row.row_fixed,
                          row_name: row.row_name
                        end}));end end end 
       if ___conditional___ = 0--[[ Tvar ]]
       or ___conditional___ = 9--[[ Tunivar ]] then do
          return ty$1;end end end 
       do
      else do
        return newty2(ty$1.level, ty$1.desc);
        end end
        
    end
  end end 
end end

function arity(ty) do
  match = repr(ty).desc;
  if (typeof match == "number" or match.tag ~= --[[ Tarrow ]]1) then do
    return 0;
  end else do
    return 1 + arity(match[2]) | 0;
  end end 
end end

function cyclic_abbrev(env, id, ty) do
  check_cycle = function (seen, ty) do
    ty$1 = repr(ty);
    match = ty$1.desc;
    if (typeof match == "number" or match.tag ~= --[[ Tconstr ]]3) then do
      return false;
    end else if (Caml_obj.caml_equal(match[0], --[[ Pident ]]Block.__(0, {id})) or List.memq(ty$1, seen)) then do
      return true;
    end else do
      try do
        return check_cycle(--[[ :: ]]{
                    ty$1,
                    seen
                  }, expand_abbrev_opt(env, ty$1));
      end
      catch (raw_exn)do
        exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn == Cannot_expand) then do
          return false;
        end else if (exn[0] == Unify) then do
          return true;
        end else do
          throw exn;
        end end  end 
      end
    end end  end 
  end end;
  return check_cycle(--[[ [] ]]0, ty);
end end

function normalize_type_rec(env, visited, ty) do
  ty$1 = repr(ty);
  if (mem$3(ty$1, visited.contents)) then do
    return 0;
  end else do
    visited.contents = add$3(ty$1, visited.contents);
    match = ty$1.desc;
    if (typeof match ~= "number") then do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 4--[[ Tobject ]] then do
            nm = match[1];
            match$1 = nm.contents;
            if (match$1 ~= undefined) then do
              match$2 = match$1;
              match$3 = match$2[1];
              if (match$3) then do
                l = match$3[1];
                v = match$3[0];
                n = match$2[0];
                if (deep_occur(ty$1, newty2(100000000, --[[ Ttuple ]]Block.__(2, {l})))) then do
                  set_name(nm, undefined);
                end else do
                  v$prime = repr(v);
                  match$4 = v$prime.desc;
                  exit = 0;
                  if (typeof match$4 == "number") then do
                    log_type(ty$1);
                    ty$1.desc = --[[ Tconstr ]]Block.__(3, {
                        n,
                        l,
                        do
                          contents: --[[ Mnil ]]0
                        end
                      });
                  end else do
                    local ___conditional___=(match$4.tag | 0);
                    do
                       if ___conditional___ = 0--[[ Tvar ]]
                       or ___conditional___ = 9--[[ Tunivar ]] then do
                          exit = 1;end else 
                       do end end
                      else do
                        set_name(nm, undefined);
                        end end
                        
                    end
                  end end 
                  if (exit == 1 and v$prime ~= v) then do
                    set_name(nm, --[[ tuple ]]{
                          n,
                          --[[ :: ]]{
                            v$prime,
                            l
                          }
                        });
                  end
                   end 
                end end 
              end else do
                fatal_error("Ctype.normalize_type_rec");
              end end 
            end
             end 
            fi = repr(match[0]);
            if (fi.level >= 0) then do
              match$5 = flatten_fields(fi);
              fi$prime = build_fields(fi.level)(match$5[0], match$5[1]);
              log_type(ty$1);
              fi.desc = fi$prime.desc;
            end
             end end else 
         if ___conditional___ = 8--[[ Tvariant ]] then do
            row = row_repr_aux(--[[ [] ]]0, match[0]);
            fields = List.map((function (param) do
                    f0 = param[1];
                    f = row_field_repr_aux(--[[ [] ]]0, f0);
                    tmp;
                    if (typeof f == "number" or not f.tag) then do
                      tmp = f;
                    end else do
                      match = f[1];
                      if (match) then do
                        tyl = match[1];
                        if (tyl) then do
                          tyl$prime = List.fold_left((function (tyl, ty) do
                                  if (List.exists((function (ty$prime) do
                                            return equal$4(env, false, --[[ :: ]]{
                                                        ty,
                                                        --[[ [] ]]0
                                                      }, --[[ :: ]]{
                                                        ty$prime,
                                                        --[[ [] ]]0
                                                      });
                                          end end), tyl)) then do
                                    return tyl;
                                  end else do
                                    return --[[ :: ]]{
                                            ty,
                                            tyl
                                          };
                                  end end 
                                end end), --[[ :: ]]{
                                match[0],
                                --[[ [] ]]0
                              }, tyl);
                          tmp = f ~= f0 or List.length(tyl$prime) < List.length(tyl) and --[[ Reither ]]Block.__(1, {
                                f[0],
                                List.rev(tyl$prime),
                                f[2],
                                f[3]
                              }) or f;
                        end else do
                          tmp = f;
                        end end 
                      end else do
                        tmp = f;
                      end end 
                    end end 
                    return --[[ tuple ]]{
                            param[0],
                            tmp
                          };
                  end end), row.row_fields);
            fields$1 = List.sort((function (param, param$1) do
                    return Caml_primitive.caml_string_compare(param[0], param$1[0]);
                  end end), List.filter((function (param) do
                          return param[1] ~= --[[ Rabsent ]]0;
                        end end))(fields));
            log_type(ty$1);
            ty$1.desc = --[[ Tvariant ]]Block.__(8, {do
                  row_fields: fields$1,
                  row_more: row.row_more,
                  row_bound: row.row_bound,
                  row_closed: row.row_closed,
                  row_fixed: row.row_fixed,
                  row_name: row.row_name
                end});end else 
         do end end end
        else do
          end end
          
      end
    end
     end 
    return iter_type_expr((function (param) do
                  return normalize_type_rec(env, visited, param);
                end end), ty$1);
  end end 
end end

function normalize_type(env, ty) do
  return normalize_type_rec(env, do
              contents: --[[ Empty ]]0
            end, ty);
end end

nondep_hash = Curry._1(TypeHash.create, 47);

nondep_variants = Curry._1(TypeHash.create, 17);

function nondep_type_rec(env, id, _ty) do
  while(true) do
    ty = _ty;
    match = ty.desc;
    exit = 0;
    if (typeof match == "number") then do
      exit = 1;
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 6--[[ Tlink ]] then do
            _ty = match[0];
            continue ;end end end 
         if ___conditional___ = 0--[[ Tvar ]]
         or ___conditional___ = 9--[[ Tunivar ]] then do
            return ty;end end end 
         do
        else do
          exit = 1;
          end end
          
      end
    end end 
    if (exit == 1) then do
      try do
        return Curry._2(TypeHash.find, nondep_hash, ty);
      end
      catch (exn)do
        if (exn == Caml_builtin_exceptions.not_found) then do
          ty$prime = newty2(100000000, --[[ Tvar ]]Block.__(0, {undefined}));
          Curry._3(TypeHash.add, nondep_hash, ty, ty$prime);
          match$1 = ty.desc;
          tmp;
          exit$1 = 0;
          if (typeof match$1 == "number") then do
            exit$1 = 2;
          end else do
            local ___conditional___=(match$1.tag | 0);
            do
               if ___conditional___ = 3--[[ Tconstr ]] then do
                  p = match$1[0];
                  if (isfree(id, p)) then do
                    try do
                      tmp = --[[ Tlink ]]Block.__(6, {nondep_type_rec(env, id, expand_abbrev(env)(newty2(ty.level, ty.desc)))});
                    end
                    catch (raw_exn)do
                      exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn);
                      if (exn$1 == Cannot_expand) then do
                        throw Caml_builtin_exceptions.not_found;
                      end
                       end 
                      if (exn$1[0] == Unify) then do
                        throw Caml_builtin_exceptions.not_found;
                      end
                       end 
                      throw exn$1;
                    end
                  end else do
                    tmp = --[[ Tconstr ]]Block.__(3, {
                        p,
                        List.map((function (param) do
                                return nondep_type_rec(env, id, param);
                              end end), match$1[1]),
                        do
                          contents: --[[ Mnil ]]0
                        end
                      });
                  end end end else 
               if ___conditional___ = 4--[[ Tobject ]] then do
                  match$2 = match$1[1].contents;
                  tmp$1;
                  if (match$2 ~= undefined) then do
                    match$3 = match$2;
                    p$1 = match$3[0];
                    tmp$1 = isfree(id, p$1) and undefined or --[[ tuple ]]{
                        p$1,
                        List.map((function (param) do
                                return nondep_type_rec(env, id, param);
                              end end), match$3[1])
                      };
                  end else do
                    tmp$1 = undefined;
                  end end 
                  tmp = --[[ Tobject ]]Block.__(4, {
                      nondep_type_rec(env, id, match$1[0]),
                      do
                        contents: tmp$1
                      end
                    });end else 
               if ___conditional___ = 8--[[ Tvariant ]] then do
                  row = row_repr_aux(--[[ [] ]]0, match$1[0]);
                  more = repr(row.row_more);
                  try do
                    ty2 = Curry._2(TypeHash.find, nondep_variants, more);
                    Curry._3(TypeHash.add, nondep_hash, ty, ty2);
                    tmp = --[[ Tlink ]]Block.__(6, {ty2});
                  end
                  catch (exn$2)do
                    if (exn$2 == Caml_builtin_exceptions.not_found) then do
                      Curry._3(TypeHash.add, nondep_variants, more, ty$prime);
                      __static = static_row(row);
                      more$prime = __static and newty2(100000000, --[[ Tnil ]]0) or more;
                      row$1 = copy_row((function (param) do
                              return nondep_type_rec(env, id, param);
                            end end), true, row, true, more$prime);
                      match$4 = row$1.row_name;
                      tmp = match$4 ~= undefined and isfree(id, match$4[0]) and --[[ Tvariant ]]Block.__(8, {do
                              row_fields: row$1.row_fields,
                              row_more: row$1.row_more,
                              row_bound: row$1.row_bound,
                              row_closed: row$1.row_closed,
                              row_fixed: row$1.row_fixed,
                              row_name: undefined
                            end}) or --[[ Tvariant ]]Block.__(8, {row$1});
                    end else do
                      throw exn$2;
                    end end 
                  endend else 
               if ___conditional___ = 11--[[ Tpackage ]] then do
                  p$2 = match$1[0];
                  if (isfree(id, p$2)) then do
                    p$prime = normalize_package_path(env, p$2);
                    if (isfree(id, p$prime)) then do
                      throw Caml_builtin_exceptions.not_found;
                    end
                     end 
                    tmp = --[[ Tpackage ]]Block.__(11, {
                        p$prime,
                        match$1[1],
                        List.map((function (param) do
                                return nondep_type_rec(env, id, param);
                              end end), match$1[2])
                      });
                  end else do
                    exit$1 = 2;
                  end end end else 
               do end end end end end
              else do
                exit$1 = 2;
                end end
                
            end
          end end 
          if (exit$1 == 2) then do
            tmp = copy_type_desc(undefined, (function (param) do
                    return nondep_type_rec(env, id, param);
                  end end), ty.desc);
          end
           end 
          ty$prime.desc = tmp;
          return ty$prime;
        end else do
          throw exn;
        end end 
      end
    end
     end 
  end;
end end

function nondep_type(env, id, ty) do
  try do
    ty$prime = nondep_type_rec(env, id, ty);
    Curry._1(TypeHash.clear, nondep_hash);
    Curry._1(TypeHash.clear, nondep_variants);
    return ty$prime;
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      Curry._1(TypeHash.clear, nondep_hash);
      Curry._1(TypeHash.clear, nondep_variants);
      throw Caml_builtin_exceptions.not_found;
    end else do
      throw exn;
    end end 
  end
end end

nondep_type$prime.contents = nondep_type;

function unroll_abbrev(id, tl, ty) do
  ty$1 = repr(ty);
  path = --[[ Pident ]]Block.__(0, {id});
  if (is_Tvar(ty$1) or List.exists((function (param) do
            return deep_occur(ty$1, param);
          end end), tl) or is_object_type(path)) then do
    return ty$1;
  end else do
    ty$prime = newty2(ty$1.level, ty$1.desc);
    link_type(ty$1, newty2(ty$1.level, --[[ Tconstr ]]Block.__(3, {
                path,
                tl,
                do
                  contents: --[[ Mnil ]]0
                end
              })));
    return ty$prime;
  end end 
end end

function nondep_type_decl(env, mid, id, is_covariant, decl) do
  try do
    params = List.map((function (param) do
            return nondep_type_rec(env, mid, param);
          end end), decl.type_params);
    tk;
    try do
      match = decl.type_kind;
      tk = typeof match == "number" and (
          match == --[[ Type_abstract ]]0 and --[[ Type_abstract ]]0 or --[[ Type_open ]]1
        ) or (
          match.tag and --[[ Type_variant ]]Block.__(1, {List.map((function (c) do
                        return do
                                cd_id: c.cd_id,
                                cd_args: List.map((function (param) do
                                        return nondep_type_rec(env, mid, param);
                                      end end), c.cd_args),
                                cd_res: may_map((function (param) do
                                        return nondep_type_rec(env, mid, param);
                                      end end), c.cd_res),
                                cd_loc: c.cd_loc,
                                cd_attributes: c.cd_attributes
                              end;
                      end end), match[0])}) or --[[ Type_record ]]Block.__(0, {
                List.map((function (l) do
                        return do
                                ld_id: l.ld_id,
                                ld_mutable: l.ld_mutable,
                                ld_type: nondep_type_rec(env, mid, l.ld_type),
                                ld_loc: l.ld_loc,
                                ld_attributes: l.ld_attributes
                              end;
                      end end), match[0]),
                match[1]
              })
        );
    end
    catch (exn)do
      if (exn == Caml_builtin_exceptions.not_found) then do
        if (is_covariant) then do
          tk = --[[ Type_abstract ]]0;
        end else do
          throw exn;
        end end 
      end else do
        throw exn;
      end end 
    end
    tm;
    try do
      match$1 = decl.type_manifest;
      tm = match$1 ~= undefined and unroll_abbrev(id, params, nondep_type_rec(env, mid, match$1)) or undefined;
    end
    catch (exn$1)do
      if (exn$1 == Caml_builtin_exceptions.not_found) then do
        if (is_covariant) then do
          tm = undefined;
        end else do
          throw exn$1;
        end end 
      end else do
        throw exn$1;
      end end 
    end
    Curry._1(TypeHash.clear, nondep_hash);
    Curry._1(TypeHash.clear, nondep_variants);
    priv = tm ~= undefined and has_constr_row(tm) and --[[ Private ]]0 or decl.type_private;
    return do
            type_params: params,
            type_arity: decl.type_arity,
            type_kind: tk,
            type_private: priv,
            type_manifest: tm,
            type_variance: decl.type_variance,
            type_newtype_level: undefined,
            type_loc: decl.type_loc,
            type_attributes: decl.type_attributes
          end;
  end
  catch (exn$2)do
    if (exn$2 == Caml_builtin_exceptions.not_found) then do
      Curry._1(TypeHash.clear, nondep_hash);
      Curry._1(TypeHash.clear, nondep_variants);
      throw Caml_builtin_exceptions.not_found;
    end else do
      throw exn$2;
    end end 
  end
end end

function nondep_extension_constructor(env, mid, ext) do
  try do
    match;
    if (isfree(mid, ext.ext_type_path)) then do
      ty = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
              ext.ext_type_path,
              ext.ext_type_params,
              do
                contents: --[[ Mnil ]]0
              end
            }));
      ty$prime = nondep_type_rec(env, mid, ty);
      match$1 = repr(ty$prime).desc;
      if (typeof match$1 == "number") then do
        throw Caml_builtin_exceptions.not_found;
      end else if (match$1.tag == --[[ Tconstr ]]3) then do
        match = --[[ tuple ]]{
          match$1[0],
          match$1[1]
        };
      end else do
        throw Caml_builtin_exceptions.not_found;
      end end  end 
    end else do
      type_params = List.map((function (param) do
              return nondep_type_rec(env, mid, param);
            end end), ext.ext_type_params);
      match = --[[ tuple ]]{
        ext.ext_type_path,
        type_params
      };
    end end 
    args = List.map((function (param) do
            return nondep_type_rec(env, mid, param);
          end end), ext.ext_args);
    ret_type = may_map((function (param) do
            return nondep_type_rec(env, mid, param);
          end end), ext.ext_ret_type);
    Curry._1(TypeHash.clear, nondep_hash);
    Curry._1(TypeHash.clear, nondep_variants);
    return do
            ext_type_path: match[0],
            ext_type_params: match[1],
            ext_args: args,
            ext_ret_type: ret_type,
            ext_private: ext.ext_private,
            ext_loc: ext.ext_loc,
            ext_attributes: ext.ext_attributes
          end;
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      Curry._1(TypeHash.clear, nondep_hash);
      Curry._1(TypeHash.clear, nondep_variants);
      throw Caml_builtin_exceptions.not_found;
    end else do
      throw exn;
    end end 
  end
end end

function nondep_class_signature(env, id, sign) do
  return do
          csig_self: nondep_type_rec(env, id, sign.csig_self),
          csig_vars: map((function (param) do
                  return --[[ tuple ]]{
                          param[0],
                          param[1],
                          nondep_type_rec(env, id, param[2])
                        };
                end end), sign.csig_vars),
          csig_concr: sign.csig_concr,
          csig_inher: List.map((function (param) do
                  return --[[ tuple ]]{
                          param[0],
                          List.map((function (param) do
                                  return nondep_type_rec(env, id, param);
                                end end), param[1])
                        };
                end end), sign.csig_inher)
        end;
end end

function nondep_class_type(env, id, _param) do
  while(true) do
    param = _param;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ = 0--[[ Cty_constr ]] then do
          cty = param[2];
          p = param[0];
          if (isfree(id, p)) then do
            _param = cty;
            continue ;
          end else do
            return --[[ Cty_constr ]]Block.__(0, {
                      p,
                      List.map((function (param) do
                              return nondep_type_rec(env, id, param);
                            end end), param[1]),
                      nondep_class_type(env, id, cty)
                    });
          end end end end end 
       if ___conditional___ = 1--[[ Cty_signature ]] then do
          return --[[ Cty_signature ]]Block.__(1, {nondep_class_signature(env, id, param[0])});end end end 
       if ___conditional___ = 2--[[ Cty_arrow ]] then do
          return --[[ Cty_arrow ]]Block.__(2, {
                    param[0],
                    nondep_type_rec(env, id, param[1]),
                    nondep_class_type(env, id, param[2])
                  });end end end 
       do
      
    end
  end;
end end

function nondep_class_declaration(env, id, decl) do
  if (isfree(id, decl.cty_path)) then do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ctype.ml",
            4449,
            2
          }
        };
  end
   end 
  match = decl.cty_new;
  decl$1 = do
    cty_params: List.map((function (param) do
            return nondep_type_rec(env, id, param);
          end end), decl.cty_params),
    cty_type: nondep_class_type(env, id, decl.cty_type),
    cty_path: decl.cty_path,
    cty_new: match ~= undefined and nondep_type_rec(env, id, match) or undefined,
    cty_variance: decl.cty_variance,
    cty_loc: decl.cty_loc,
    cty_attributes: decl.cty_attributes
  end;
  Curry._1(TypeHash.clear, nondep_hash);
  Curry._1(TypeHash.clear, nondep_variants);
  return decl$1;
end end

function nondep_cltype_declaration(env, id, decl) do
  if (isfree(id, decl.clty_path)) then do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "ctype.ml",
            4468,
            2
          }
        };
  end
   end 
  decl_clty_params = List.map((function (param) do
          return nondep_type_rec(env, id, param);
        end end), decl.clty_params);
  decl_clty_type = nondep_class_type(env, id, decl.clty_type);
  decl_clty_path = decl.clty_path;
  decl_clty_variance = decl.clty_variance;
  decl_clty_loc = decl.clty_loc;
  decl_clty_attributes = decl.clty_attributes;
  decl$1 = do
    clty_params: decl_clty_params,
    clty_type: decl_clty_type,
    clty_path: decl_clty_path,
    clty_variance: decl_clty_variance,
    clty_loc: decl_clty_loc,
    clty_attributes: decl_clty_attributes
  end;
  Curry._1(TypeHash.clear, nondep_hash);
  Curry._1(TypeHash.clear, nondep_variants);
  return decl$1;
end end

function collapse_conj(env, visited, ty) do
  ty$1 = repr(ty);
  if (List.memq(ty$1, visited)) then do
    return --[[ () ]]0;
  end else do
    visited$1 = --[[ :: ]]{
      ty$1,
      visited
    };
    match = ty$1.desc;
    if (typeof match == "number") then do
      return iter_type_expr((function (param) do
                    return collapse_conj(env, visited$1, param);
                  end end), ty$1);
    end else if (match.tag == --[[ Tvariant ]]8) then do
      row = row_repr_aux(--[[ [] ]]0, match[0]);
      List.iter((function (param) do
              match = row_field_repr_aux(--[[ [] ]]0, param[1]);
              if (typeof match == "number" or not match.tag) then do
                return --[[ () ]]0;
              end else do
                match$1 = match[1];
                if (match$1) then do
                  tl = match$1[1];
                  if (tl) then do
                    t1 = match$1[0];
                    List.iter((function (param) do
                            return unify$2(env, t1, param);
                          end end), tl);
                    return set_row_field(match[3], --[[ Reither ]]Block.__(1, {
                                  match[0],
                                  --[[ :: ]]{
                                    t1,
                                    --[[ [] ]]0
                                  },
                                  match[2],
                                  do
                                    contents: undefined
                                  end
                                }));
                  end else do
                    return --[[ () ]]0;
                  end end 
                end else do
                  return --[[ () ]]0;
                end end 
              end end 
            end end), row.row_fields);
      return iter_row((function (param) do
                    return collapse_conj(env, visited$1, param);
                  end end), row);
    end else do
      return iter_type_expr((function (param) do
                    return collapse_conj(env, visited$1, param);
                  end end), ty$1);
    end end  end 
  end end 
end end

function collapse_conj_params(env, params) do
  return List.iter((function (param) do
                return collapse_conj(env, --[[ [] ]]0, param);
              end end), params);
end end

out_ident = do
  contents: Format.pp_print_string
end;

function print_ident(ppf, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Oide_apply ]] then do
        return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                --[[ "(" ]]40,
                                --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                        --[[ ")" ]]41,
                                        --[[ End_of_format ]]0
                                      })})
                              })}),
                        "%a(%a)"
                      }), print_ident, param[0], print_ident, param[1]);end end end 
     if ___conditional___ = 1--[[ Oide_dot ]] then do
        print_ident(ppf, param[0]);
        Format.pp_print_char(ppf, --[[ "." ]]46);
        return Curry._2(out_ident.contents, ppf, param[1]);end end end 
     if ___conditional___ = 2--[[ Oide_ident ]] then do
        return Curry._2(out_ident.contents, ppf, param[0]);end end end 
     do
    
  end
end end

function parenthesized_ident(name) do
  if (List.mem(name, --[[ :: ]]{
          "or",
          --[[ :: ]]{
            "mod",
            --[[ :: ]]{
              "land",
              --[[ :: ]]{
                "lor",
                --[[ :: ]]{
                  "lxor",
                  --[[ :: ]]{
                    "lsl",
                    --[[ :: ]]{
                      "lsr",
                      --[[ :: ]]{
                        "asr",
                        --[[ [] ]]0
                      }
                    }
                  }
                }
              }
            }
          }
        })) then do
    return true;
  end else do
    match = Caml_string.get(name, 0);
    if (match >= 97) then do
      if (match >= 223) then do
        return match == 247;
      end else do
        return match >= 123;
      end end 
    end else if (match >= 91) then do
      return match ~= 95;
    end else do
      return match < 65;
    end end  end 
  end end 
end end

function value_ident(ppf, name) do
  if (parenthesized_ident(name)) then do
    return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ String_literal ]]Block.__(11, {
                        "( ",
                        --[[ String ]]Block.__(2, {
                            --[[ No_padding ]]0,
                            --[[ String_literal ]]Block.__(11, {
                                " )",
                                --[[ End_of_format ]]0
                              })
                          })
                      }),
                    "( %s )"
                  }), name);
  end else do
    return Format.pp_print_string(ppf, name);
  end end 
end end

function print_list(pr, sep, ppf, _param) do
  while(true) do
    param = _param;
    if (param) then do
      l = param[1];
      a = param[0];
      if (l) then do
        Curry._2(pr, ppf, a);
        Curry._1(sep, ppf);
        _param = l;
        continue ;
      end else do
        return Curry._2(pr, ppf, a);
      end end 
    end else do
      return --[[ () ]]0;
    end end 
  end;
end end

function pr_present(param, param$1) do
  return print_list((function (ppf, s) do
                return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                --[[ Char_literal ]]Block.__(12, {
                                    --[[ "`" ]]96,
                                    --[[ String ]]Block.__(2, {
                                        --[[ No_padding ]]0,
                                        --[[ End_of_format ]]0
                                      })
                                  }),
                                "`%s"
                              }), s);
              end end), (function (ppf) do
                return Format.fprintf(ppf, --[[ Format ]]{
                            --[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@ ",
                                    1,
                                    0
                                  }),
                                --[[ End_of_format ]]0
                              }),
                            "@ "
                          });
              end end), param, param$1);
end end

function pr_vars(param, param$1) do
  return print_list((function (ppf, s) do
                return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                --[[ Char_literal ]]Block.__(12, {
                                    --[[ "'" ]]39,
                                    --[[ String ]]Block.__(2, {
                                        --[[ No_padding ]]0,
                                        --[[ End_of_format ]]0
                                      })
                                  }),
                                "'%s"
                              }), s);
              end end), (function (ppf) do
                return Format.fprintf(ppf, --[[ Format ]]{
                            --[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@ ",
                                    1,
                                    0
                                  }),
                                --[[ End_of_format ]]0
                              }),
                            "@ "
                          });
              end end), param, param$1);
end end

function print_out_type(ppf, ty) do
  if (typeof ty == "number") then do
    return print_out_type_1(ppf, ty);
  end else do
    local ___conditional___=(ty.tag | 0);
    do
       if ___conditional___ = 0--[[ Otyp_alias ]] then do
          return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ String_literal ]]Block.__(11, {
                                          "as '",
                                          --[[ String ]]Block.__(2, {
                                              --[[ No_padding ]]0,
                                              --[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Close_box ]]0,
                                                  --[[ End_of_format ]]0
                                                })
                                            })
                                        })
                                    })})
                            }),
                          "@[%a@ as '%s@]"
                        }), print_out_type, ty[0], ty[1]);end end end 
       if ___conditional___ = 12--[[ Otyp_poly ]] then do
          return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hov 2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hov 2>"
                                  }}),
                              --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                      --[[ "." ]]46,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Close_box ]]0,
                                                  --[[ End_of_format ]]0
                                                })})
                                        })
                                    })})
                            }),
                          "@[<hov 2>%a.@ %a@]"
                        }), pr_vars, ty[0], print_out_type, ty[1]);end end end 
       do
      else do
        return print_out_type_1(ppf, ty);
        end end
        
    end
  end end 
end end

function print_out_type_1(ppf, ty) do
  if (typeof ty == "number" or ty.tag ~= --[[ Otyp_arrow ]]1) then do
    return print_out_type_2(ppf, ty);
  end else do
    lab = ty[0];
    Format.pp_open_box(ppf, 0);
    if (lab ~= "") then do
      Format.pp_print_string(ppf, lab);
      Format.pp_print_char(ppf, --[[ ":" ]]58);
    end
     end 
    print_out_type_2(ppf, ty[1]);
    Format.pp_print_string(ppf, " ->");
    Format.pp_print_space(ppf, --[[ () ]]0);
    print_out_type_1(ppf, ty[2]);
    return Format.pp_close_box(ppf, --[[ () ]]0);
  end end 
end end

function print_out_type_2(ppf, ty) do
  if (typeof ty == "number" or ty.tag ~= --[[ Otyp_tuple ]]9) then do
    return print_simple_out_type(ppf, ty);
  end else do
    return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<0>",
                                  --[[ End_of_format ]]0
                                }),
                              "<0>"
                            }}),
                        --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                --[[ Close_box ]]0,
                                --[[ End_of_format ]]0
                              })})
                      }),
                    "@[<0>%a@]"
                  }), (function (param, param$1) do
                  return print_typlist(print_simple_out_type, " *", param, param$1);
                end end), ty[0]);
  end end 
end end

function print_simple_out_type(ppf, ty) do
  if (typeof ty == "number") then do
    return --[[ () ]]0;
  end else do
    local ___conditional___=(ty.tag | 0);
    do
       if ___conditional___ = 2--[[ Otyp_class ]] then do
          return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ Alpha ]]Block.__(15, {--[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Char_literal ]]Block.__(12, {
                                          --[[ "#" ]]35,
                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Close_box ]]0,
                                                  --[[ End_of_format ]]0
                                                })})
                                        })
                                    })})
                            }),
                          "@[%a%s#%a@]"
                        }), print_typargs, ty[2], ty[0] and "_" or "", print_ident, ty[1]);end end end 
       if ___conditional___ = 3--[[ Otyp_constr ]] then do
          id = ty[0];
          exit = 0;
          local ___conditional___=(id.tag | 0);
          do
             if ___conditional___ = 1--[[ Oide_dot ]] then do
                match = id[0];
                exit$1 = 0;
                local ___conditional___=(match.tag | 0);
                do
                   if ___conditional___ = 0--[[ Oide_apply ]] then do
                      exit = 2;end else 
                   if ___conditional___ = 1--[[ Oide_dot ]] then do
                      match$1 = match[0];
                      local ___conditional___=(match$1.tag | 0);
                      do
                         if ___conditional___ = 0--[[ Oide_apply ]]
                         or ___conditional___ = 1--[[ Oide_dot ]] then do
                            exit = 2;end else 
                         if ___conditional___ = 2--[[ Oide_ident ]] then do
                            if (match$1[0] == "Js" and match[1] == "Internal") then do
                              exit$1 = 3;
                            end else do
                              exit = 2;
                            end end end else 
                         do end end end
                        
                      endend else 
                   if ___conditional___ = 2--[[ Oide_ident ]] then do
                      if (match[0] == "Js_internal") then do
                        exit$1 = 3;
                      end else do
                        exit = 2;
                      end end end else 
                   do end end end end
                  
                end
                if (exit$1 == 3) then do
                  name = id[1];
                  exit$2 = 0;
                  local ___conditional___=(name);
                  do
                     if ___conditional___ = "fn"
                     or ___conditional___ = "meth" then do
                        exit$2 = 4;end else 
                     if ___conditional___ = "meth_callback" then do
                        tyl = ty[1];
                        if (tyl) then do
                          match$2 = tyl[0];
                          if (typeof match$2 == "number" or match$2.tag ~= --[[ Otyp_variant ]]11) then do
                            exit = 2;
                          end else do
                            match$3 = match$2[1];
                            if (match$3.tag) then do
                              exit = 2;
                            end else do
                              match$4 = match$3[0];
                              if (match$4 and not match$4[1]) then do
                                match$5 = tyl[1];
                                if (match$5 and not match$5[1]) then do
                                  match$6 = match$4[0];
                                  variant = match$6[0];
                                  make = function (tys, result) do
                                    if (tys) then do
                                      single = tys[0];
                                      if (typeof single ~= "number" and single.tag == --[[ Otyp_tuple ]]9) then do
                                        if (tys[1]) then do
                                          throw Caml_builtin_exceptions.not_found;
                                        end
                                         end 
                                        if (variant == "Arity_1") then do
                                          return --[[ Otyp_arrow ]]Block.__(1, {
                                                    "",
                                                    single,
                                                    result
                                                  });
                                        end else do
                                          return List.fold_right((function (x, acc) do
                                                        return --[[ Otyp_arrow ]]Block.__(1, {
                                                                  "",
                                                                  x,
                                                                  acc
                                                                });
                                                      end end), single[0], result);
                                        end end 
                                      end
                                       end 
                                      if (tys[1]) then do
                                        throw Caml_builtin_exceptions.not_found;
                                      end
                                       end 
                                      return --[[ Otyp_arrow ]]Block.__(1, {
                                                "",
                                                single,
                                                result
                                              });
                                    end else do
                                      throw Caml_builtin_exceptions.not_found;
                                    end end 
                                  end end;
                                  exit$3 = 0;
                                  res;
                                  try do
                                    res = make(match$6[2], match$5[0]);
                                    exit$3 = 5;
                                  end
                                  catch (exn)do
                                    Format.pp_open_box(ppf, 0);
                                    print_typargs(ppf, tyl);
                                    print_ident(ppf, id);
                                    return Format.pp_close_box(ppf, --[[ () ]]0);
                                  end
                                  if (exit$3 == 5) then do
                                    return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                    --[[ Formatting_gen ]]Block.__(18, {
                                                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "<0>",
                                                                  --[[ End_of_format ]]0
                                                                }),
                                                              "<0>"
                                                            }}),
                                                        --[[ Char_literal ]]Block.__(12, {
                                                            --[[ "(" ]]40,
                                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                    --[[ Break ]]Block.__(0, {
                                                                        "@ ",
                                                                        1,
                                                                        0
                                                                      }),
                                                                    --[[ Char_literal ]]Block.__(12, {
                                                                        --[[ "[" ]]91,
                                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                                            --[[ Scan_indic ]]Block.__(2, {--[[ "b" ]]98}),
                                                                            --[[ String_literal ]]Block.__(11, {
                                                                                "s.this])",
                                                                                --[[ Formatting_lit ]]Block.__(17, {
                                                                                    --[[ Close_box ]]0,
                                                                                    --[[ End_of_format ]]0
                                                                                  })
                                                                              })
                                                                          })
                                                                      })
                                                                  })})
                                                          })
                                                      }),
                                                    "@[<0>(%a@ [@bs.this])@]"
                                                  }), print_out_type_1, res);
                                  end
                                   end 
                                end else do
                                  exit = 2;
                                end end 
                              end else do
                                exit = 2;
                              end end 
                            end end 
                          end end 
                        end else do
                          exit = 2;
                        end end end else 
                     do end end end
                    else do
                      exit = 2;
                      end end
                      
                  end
                  if (exit$2 == 4) then do
                    tyl$1 = ty[1];
                    if (tyl$1) then do
                      match$7 = tyl$1[0];
                      if (typeof match$7 == "number" or match$7.tag ~= --[[ Otyp_variant ]]11) then do
                        exit = 2;
                      end else do
                        match$8 = match$7[1];
                        if (match$8.tag) then do
                          exit = 2;
                        end else do
                          match$9 = match$8[0];
                          if (match$9 and not match$9[1]) then do
                            match$10 = tyl$1[1];
                            if (match$10 and not match$10[1]) then do
                              match$11 = match$9[0];
                              variant$1 = match$11[0];
                              make$1 = function (tys, result) do
                                if (tys == --[[ [] ]]0) then do
                                  return --[[ Otyp_arrow ]]Block.__(1, {
                                            "",
                                            --[[ Otyp_constr ]]Block.__(3, {
                                                --[[ Oide_ident ]]Block.__(2, {"unit"}),
                                                --[[ [] ]]0
                                              }),
                                            result
                                          });
                                end else if (tys) then do
                                  single = tys[0];
                                  if (typeof single ~= "number" and single.tag == --[[ Otyp_tuple ]]9) then do
                                    if (tys[1]) then do
                                      throw Caml_builtin_exceptions.not_found;
                                    end
                                     end 
                                    if (variant$1 == "Arity_1") then do
                                      return --[[ Otyp_arrow ]]Block.__(1, {
                                                "",
                                                single,
                                                result
                                              });
                                    end else do
                                      return List.fold_right((function (x, acc) do
                                                    return --[[ Otyp_arrow ]]Block.__(1, {
                                                              "",
                                                              x,
                                                              acc
                                                            });
                                                  end end), single[0], result);
                                    end end 
                                  end
                                   end 
                                  if (tys[1]) then do
                                    throw Caml_builtin_exceptions.not_found;
                                  end
                                   end 
                                  return --[[ Otyp_arrow ]]Block.__(1, {
                                            "",
                                            single,
                                            result
                                          });
                                end else do
                                  throw Caml_builtin_exceptions.not_found;
                                end end  end 
                              end end;
                              exit$4 = 0;
                              res$1;
                              try do
                                res$1 = make$1(match$11[2], match$10[0]);
                                exit$4 = 5;
                              end
                              catch (exn$1)do
                                Format.pp_open_box(ppf, 0);
                                print_typargs(ppf, tyl$1);
                                print_ident(ppf, id);
                                return Format.pp_close_box(ppf, --[[ () ]]0);
                              end
                              if (exit$4 == 5) then do
                                local ___conditional___=(name);
                                do
                                   if ___conditional___ = "fn" then do
                                      return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                      --[[ Formatting_gen ]]Block.__(18, {
                                                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "<0>",
                                                                    --[[ End_of_format ]]0
                                                                  }),
                                                                "<0>"
                                                              }}),
                                                          --[[ Char_literal ]]Block.__(12, {
                                                              --[[ "(" ]]40,
                                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Break ]]Block.__(0, {
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        }),
                                                                      --[[ Char_literal ]]Block.__(12, {
                                                                          --[[ "[" ]]91,
                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Scan_indic ]]Block.__(2, {--[[ "b" ]]98}),
                                                                              --[[ String_literal ]]Block.__(11, {
                                                                                  "s])",
                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Close_box ]]0,
                                                                                      --[[ End_of_format ]]0
                                                                                    })
                                                                                })
                                                                            })
                                                                        })
                                                                    })})
                                                            })
                                                        }),
                                                      "@[<0>(%a@ [@bs])@]"
                                                    }), print_out_type_1, res$1);end end end 
                                   if ___conditional___ = "meth" then do
                                      return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                      --[[ Formatting_gen ]]Block.__(18, {
                                                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "<0>",
                                                                    --[[ End_of_format ]]0
                                                                  }),
                                                                "<0>"
                                                              }}),
                                                          --[[ Char_literal ]]Block.__(12, {
                                                              --[[ "(" ]]40,
                                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Break ]]Block.__(0, {
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        }),
                                                                      --[[ Char_literal ]]Block.__(12, {
                                                                          --[[ "[" ]]91,
                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Scan_indic ]]Block.__(2, {--[[ "b" ]]98}),
                                                                              --[[ String_literal ]]Block.__(11, {
                                                                                  "s.meth])",
                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Close_box ]]0,
                                                                                      --[[ End_of_format ]]0
                                                                                    })
                                                                                })
                                                                            })
                                                                        })
                                                                    })})
                                                            })
                                                        }),
                                                      "@[<0>(%a@ [@bs.meth])@]"
                                                    }), print_out_type_1, res$1);end end end 
                                   do
                                  else do
                                    throw {
                                          Caml_builtin_exceptions.assert_failure,
                                          --[[ tuple ]]{
                                            "oprint.ml",
                                            229,
                                            17
                                          }
                                        };
                                    end end
                                    
                                end
                              end
                               end 
                            end else do
                              exit = 2;
                            end end 
                          end else do
                            exit = 2;
                          end end 
                        end end 
                      end end 
                    end else do
                      exit = 2;
                    end end 
                  end
                   end 
                end
                 end end else 
             if ___conditional___ = 0--[[ Oide_apply ]]
             or ___conditional___ = 2--[[ Oide_ident ]] then do
                exit = 2;end else 
             do end end end
            
          end
          if (exit == 2) then do
            Format.pp_open_box(ppf, 0);
            print_typargs(ppf, ty[1]);
            print_ident(ppf, id);
            return Format.pp_close_box(ppf, --[[ () ]]0);
          end
           end end else 
       if ___conditional___ = 5--[[ Otyp_object ]] then do
          rest = ty[1];
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<2>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "< ",
                                  --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                          " >",
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Close_box ]]0,
                                              --[[ End_of_format ]]0
                                            })
                                        })})
                                })
                            }),
                          "@[<2>< %a >@]"
                        }), (function (param, param$1) do
                        return print_fields(rest, param, param$1);
                      end end), ty[0]);end end end 
       if ___conditional___ = 7--[[ Otyp_stuff ]] then do
          return Format.pp_print_string(ppf, ty[0]);end end end 
       if ___conditional___ = 10--[[ Otyp_var ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Char_literal ]]Block.__(12, {
                              --[[ "'" ]]39,
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ End_of_format ]]0
                                    })
                                })
                            }),
                          "'%s%s"
                        }), ty[0] and "_" or "", ty[1]);end end end 
       if ___conditional___ = 11--[[ Otyp_variant ]] then do
          tags = ty[3];
          print_present = function (ppf, param) do
            if (param ~= undefined) then do
              l = param;
              if (l) then do
                return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                --[[ Formatting_lit ]]Block.__(17, {
                                    --[[ Break ]]Block.__(0, {
                                        "@;<1 -2>",
                                        1,
                                        -2
                                      }),
                                    --[[ String_literal ]]Block.__(11, {
                                        "> ",
                                        --[[ Formatting_gen ]]Block.__(18, {
                                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                  --[[ String_literal ]]Block.__(11, {
                                                      "<hov>",
                                                      --[[ End_of_format ]]0
                                                    }),
                                                  "<hov>"
                                                }}),
                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Close_box ]]0,
                                                    --[[ End_of_format ]]0
                                                  })})
                                          })
                                      })
                                  }),
                                "@;<1 -2>> @[<hov>%a@]"
                              }), pr_present, l);
              end else do
                return --[[ () ]]0;
              end end 
            end else do
              return --[[ () ]]0;
            end end 
          end end;
          print_fields$1 = function (ppf, param) do
            if (param.tag) then do
              return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                              --[[ Formatting_gen ]]Block.__(18, {
                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                        --[[ End_of_format ]]0,
                                        ""
                                      }}),
                                  --[[ Alpha ]]Block.__(15, {--[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Close_box ]]0,
                                              --[[ End_of_format ]]0
                                            })})})
                                }),
                              "@[%a%a@]"
                            }), print_typargs, param[1], print_ident, param[0]);
            end else do
              return print_list(print_row_field, (function (ppf) do
                            return Format.fprintf(ppf, --[[ Format ]]{
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@;<1 -2>",
                                                1,
                                                -2
                                              }),
                                            --[[ String_literal ]]Block.__(11, {
                                                "| ",
                                                --[[ End_of_format ]]0
                                              })
                                          }),
                                        "@;<1 -2>| "
                                      });
                          end end), ppf, param[0]);
            end end 
          end end;
          return Curry._6(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String ]]Block.__(2, {
                              --[[ No_padding ]]0,
                              --[[ Char_literal ]]Block.__(12, {
                                  --[[ "[" ]]91,
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Formatting_gen ]]Block.__(18, {
                                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                --[[ String_literal ]]Block.__(11, {
                                                    "<hv>",
                                                    --[[ End_of_format ]]0
                                                  }),
                                                "<hv>"
                                              }}),
                                          --[[ Formatting_gen ]]Block.__(18, {
                                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "<hv>",
                                                        --[[ End_of_format ]]0
                                                      }),
                                                    "<hv>"
                                                  }}),
                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Close_box ]]0,
                                                      --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                                              " ]",
                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                  --[[ Close_box ]]0,
                                                                  --[[ End_of_format ]]0
                                                                })
                                                            })})
                                                    })})
                                            })
                                        })
                                    })
                                })
                            }),
                          "%s[%s@[<hv>@[<hv>%a@]%a ]@]"
                        }), ty[0] and "_" or "", ty[2] and (
                        tags == undefined and " " or "< "
                      ) or (
                        tags == undefined and "> " or "? "
                      ), print_fields$1, ty[1], print_present, tags);end end end 
       if ___conditional___ = 0--[[ Otyp_alias ]]
       or ___conditional___ = 1--[[ Otyp_arrow ]]
       or ___conditional___ = 9--[[ Otyp_tuple ]]
       or ___conditional___ = 12--[[ Otyp_poly ]]
       or ___conditional___ = 13--[[ Otyp_module ]] then do
          Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<1>",
                                  --[[ End_of_format ]]0
                                }),
                              "<1>"
                            }}),
                        --[[ String_literal ]]Block.__(11, {
                            "(module ",
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ End_of_format ]]0
                              })
                          })
                      }),
                    "@[<1>(module %s"
                  }), ty[0]);
          first = do
            contents: true
          end;
          List.iter2((function (s, t) do
                  sep = first.contents and (first.contents = false, "with") or "and";
                  return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                                  --[[ Char_literal ]]Block.__(12, {
                                      --[[ " " ]]32,
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ String_literal ]]Block.__(11, {
                                              " type ",
                                              --[[ String ]]Block.__(2, {
                                                  --[[ No_padding ]]0,
                                                  --[[ String_literal ]]Block.__(11, {
                                                      " = ",
                                                      --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                    })
                                                })
                                            })
                                        })
                                    }),
                                  " %s type %s = %a"
                                }), sep, s, print_out_type, t);
                end end), ty[1], ty[2]);
          return Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Char_literal ]]Block.__(12, {
                          --[[ ")" ]]41,
                          --[[ Formatting_lit ]]Block.__(17, {
                              --[[ Close_box ]]0,
                              --[[ End_of_format ]]0
                            })
                        }),
                      ")@]"
                    });end end end 
       do
      else do
        return --[[ () ]]0;
        end end
        
    end
  end end 
  Format.pp_open_box(ppf, 1);
  Format.pp_print_char(ppf, --[[ "(" ]]40);
  print_out_type(ppf, ty);
  Format.pp_print_char(ppf, --[[ ")" ]]41);
  return Format.pp_close_box(ppf, --[[ () ]]0);
end end

function print_fields(rest, ppf, _param) do
  while(true) do
    param = _param;
    if (param) then do
      l = param[1];
      match = param[0];
      t = match[1];
      s = match[0];
      if (l) then do
        return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ String ]]Block.__(2, {
                            --[[ No_padding ]]0,
                            --[[ String_literal ]]Block.__(11, {
                                " : ",
                                --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                        --[[ ";" ]]59,
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                          })
                                      })})
                              })
                          }),
                        "%s : %a;@ %a"
                      }), s, print_out_type, t, (function (param, param$1) do
                      return print_fields(rest, param, param$1);
                    end end), l);
      end else do
        Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                  --[[ String ]]Block.__(2, {
                      --[[ No_padding ]]0,
                      --[[ String_literal ]]Block.__(11, {
                          " : ",
                          --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                        })
                    }),
                  "%s : %a"
                }), s, print_out_type, t);
        if (rest ~= undefined) then do
          Format.fprintf(ppf, --[[ Format ]]{
                --[[ Char_literal ]]Block.__(12, {
                    --[[ ";" ]]59,
                    --[[ Formatting_lit ]]Block.__(17, {
                        --[[ Break ]]Block.__(0, {
                            "@ ",
                            1,
                            0
                          }),
                        --[[ End_of_format ]]0
                      })
                  }),
                ";@ "
              });
        end
         end 
        _param = --[[ [] ]]0;
        continue ;
      end end 
    end else if (rest ~= undefined) then do
      return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String ]]Block.__(2, {
                          --[[ No_padding ]]0,
                          --[[ String_literal ]]Block.__(11, {
                              "..",
                              --[[ End_of_format ]]0
                            })
                        }),
                      "%s.."
                    }), rest and "_" or "");
    end else do
      return --[[ () ]]0;
    end end  end 
  end;
end end

function print_row_field(ppf, param) do
  tyl = param[2];
  opt_amp = param[1];
  pr_of = function (ppf) do
    if (opt_amp) then do
      return Format.fprintf(ppf, --[[ Format ]]{
                  --[[ String_literal ]]Block.__(11, {
                      " of",
                      --[[ Formatting_lit ]]Block.__(17, {
                          --[[ Break ]]Block.__(0, {
                              "@ ",
                              1,
                              0
                            }),
                          --[[ Char_literal ]]Block.__(12, {
                              --[[ "&" ]]38,
                              --[[ Formatting_lit ]]Block.__(17, {
                                  --[[ Break ]]Block.__(0, {
                                      "@ ",
                                      1,
                                      0
                                    }),
                                  --[[ End_of_format ]]0
                                })
                            })
                        })
                    }),
                  " of@ &@ "
                });
    end else if (tyl ~= --[[ [] ]]0) then do
      return Format.fprintf(ppf, --[[ Format ]]{
                  --[[ String_literal ]]Block.__(11, {
                      " of",
                      --[[ Formatting_lit ]]Block.__(17, {
                          --[[ Break ]]Block.__(0, {
                              "@ ",
                              1,
                              0
                            }),
                          --[[ End_of_format ]]0
                        })
                    }),
                  " of@ "
                });
    end else do
      return Format.fprintf(ppf, --[[ Format ]]{
                  --[[ End_of_format ]]0,
                  ""
                });
    end end  end 
  end end;
  return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                  --[[ Formatting_gen ]]Block.__(18, {
                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                            --[[ String_literal ]]Block.__(11, {
                                "<hv 2>",
                                --[[ End_of_format ]]0
                              }),
                            "<hv 2>"
                          }}),
                      --[[ Char_literal ]]Block.__(12, {
                          --[[ "`" ]]96,
                          --[[ String ]]Block.__(2, {
                              --[[ No_padding ]]0,
                              --[[ Theta ]]Block.__(16, {--[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Close_box ]]0,
                                          --[[ End_of_format ]]0
                                        })})})
                            })
                        })
                    }),
                  "@[<hv 2>`%s%t%a@]"
                }), param[0], pr_of, (function (param, param$1) do
                return print_typlist(print_out_type, " &", param, param$1);
              end end), tyl);
end end

function print_typlist(print_elem, sep, ppf, _param) do
  while(true) do
    param = _param;
    if (param) then do
      tyl = param[1];
      ty = param[0];
      if (tyl) then do
        Curry._2(print_elem, ppf, ty);
        Format.pp_print_string(ppf, sep);
        Format.pp_print_space(ppf, --[[ () ]]0);
        _param = tyl;
        continue ;
      end else do
        return Curry._2(print_elem, ppf, ty);
      end end 
    end else do
      return --[[ () ]]0;
    end end 
  end;
end end

function print_typargs(ppf, tyl) do
  if (tyl) then do
    if (tyl[1]) then do
      Format.pp_open_box(ppf, 1);
      Format.pp_print_char(ppf, --[[ "(" ]]40);
      print_typlist(print_out_type, ",", ppf, tyl);
      Format.pp_print_char(ppf, --[[ ")" ]]41);
      Format.pp_close_box(ppf, --[[ () ]]0);
      return Format.pp_print_space(ppf, --[[ () ]]0);
    end else do
      print_simple_out_type(ppf, tyl[0]);
      return Format.pp_print_space(ppf, --[[ () ]]0);
    end end 
  end else do
    return --[[ () ]]0;
  end end 
end end

out_type = do
  contents: print_out_type
end;

function type_parameter(ppf, param) do
  match = param[1];
  ty = param[0];
  return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                  --[[ String ]]Block.__(2, {
                      --[[ No_padding ]]0,
                      --[[ String ]]Block.__(2, {
                          --[[ No_padding ]]0,
                          --[[ End_of_format ]]0
                        })
                    }),
                  "%s%s"
                }), match[1] and (
                match[0] and "" or "-"
              ) or "+", ty == "_" and ty or "'" .. ty);
end end

function print_out_class_params(ppf, tyl) do
  if (tyl) then do
    return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<1>",
                                  --[[ End_of_format ]]0
                                }),
                              "<1>"
                            }}),
                        --[[ Char_literal ]]Block.__(12, {
                            --[[ "[" ]]91,
                            --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                    --[[ "]" ]]93,
                                    --[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Close_box ]]0,
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ End_of_format ]]0
                                          })
                                      })
                                  })})
                          })
                      }),
                    "@[<1>[%a]@]@ "
                  }), (function (param, param$1) do
                  return print_list(type_parameter, (function (ppf) do
                                return Format.fprintf(ppf, --[[ Format ]]{
                                            --[[ String_literal ]]Block.__(11, {
                                                ", ",
                                                --[[ End_of_format ]]0
                                              }),
                                            ", "
                                          });
                              end end), param, param$1);
                end end), tyl);
  end else do
    return --[[ () ]]0;
  end end 
end end

function print_out_class_type(ppf, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Octy_constr ]] then do
        pr_tyl = function (ppf, tyl) do
          if (tyl) then do
            partial_arg = out_type.contents;
            return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                            --[[ Formatting_gen ]]Block.__(18, {
                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                      --[[ String_literal ]]Block.__(11, {
                                          "<1>",
                                          --[[ End_of_format ]]0
                                        }),
                                      "<1>"
                                    }}),
                                --[[ Char_literal ]]Block.__(12, {
                                    --[[ "[" ]]91,
                                    --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                            --[[ "]" ]]93,
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Close_box ]]0,
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ End_of_format ]]0
                                                  })
                                              })
                                          })})
                                  })
                              }),
                            "@[<1>[%a]@]@ "
                          }), (function (param, param$1) do
                          return print_typlist(partial_arg, ",", param, param$1);
                        end end), tyl);
          end else do
            return --[[ () ]]0;
          end end 
        end end;
        return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ End_of_format ]]0,
                                  ""
                                }}),
                            --[[ Alpha ]]Block.__(15, {--[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Close_box ]]0,
                                        --[[ End_of_format ]]0
                                      })})})
                          }),
                        "@[%a%a@]"
                      }), pr_tyl, param[1], print_ident, param[0]);end end end 
     if ___conditional___ = 1--[[ Octy_arrow ]] then do
        lab = param[0];
        return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ End_of_format ]]0,
                                  ""
                                }}),
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                        " ->",
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Close_box ]]0,
                                                    --[[ End_of_format ]]0
                                                  })})
                                          })
                                      })})
                              })
                          }),
                        "@[%s%a ->@ %a@]"
                      }), lab ~= "" and lab .. ":" or "", print_out_type_2, param[1], print_out_class_type, param[2]);end end end 
     if ___conditional___ = 2--[[ Octy_signature ]] then do
        pr_param = function (ppf, param) do
          if (param ~= undefined) then do
            return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                            --[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@ ",
                                    1,
                                    0
                                  }),
                                --[[ Formatting_gen ]]Block.__(18, {
                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                          --[[ End_of_format ]]0,
                                          ""
                                        }}),
                                    --[[ Char_literal ]]Block.__(12, {
                                        --[[ "(" ]]40,
                                        --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                --[[ ")" ]]41,
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Close_box ]]0,
                                                    --[[ End_of_format ]]0
                                                  })
                                              })})
                                      })
                                  })
                              }),
                            "@ @[(%a)@]"
                          }), out_type.contents, param);
          end else do
            return --[[ () ]]0;
          end end 
        end end;
        return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      "<hv 2>",
                                      --[[ End_of_format ]]0
                                    }),
                                  "<hv 2>"
                                }}),
                            --[[ Formatting_gen ]]Block.__(18, {
                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                      --[[ String_literal ]]Block.__(11, {
                                          "<2>",
                                          --[[ End_of_format ]]0
                                        }),
                                      "<2>"
                                    }}),
                                --[[ String_literal ]]Block.__(11, {
                                    "object",
                                    --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Close_box ]]0,
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Break ]]Block.__(0, {
                                                    "@ ",
                                                    1,
                                                    0
                                                  }),
                                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                        --[[ Break ]]Block.__(0, {
                                                            "@;<1 -2>",
                                                            1,
                                                            -2
                                                          }),
                                                        --[[ String_literal ]]Block.__(11, {
                                                            "end",
                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                --[[ Close_box ]]0,
                                                                --[[ End_of_format ]]0
                                                              })
                                                          })
                                                      })})
                                              })
                                          })})
                                  })
                              })
                          }),
                        "@[<hv 2>@[<2>object%a@]@ %a@;<1 -2>end@]"
                      }), pr_param, param[0], (function (param, param$1) do
                      return print_list(print_out_class_sig_item, (function (ppf) do
                                    return Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ End_of_format ]]0
                                                  }),
                                                "@ "
                                              });
                                  end end), param, param$1);
                    end end), param[1]);end end end 
     do
    
  end
end end

function print_out_class_sig_item(ppf, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Ocsg_constraint ]] then do
        return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      "<2>",
                                      --[[ End_of_format ]]0
                                    }),
                                  "<2>"
                                }}),
                            --[[ String_literal ]]Block.__(11, {
                                "constraint ",
                                --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                        " =",
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Close_box ]]0,
                                                    --[[ End_of_format ]]0
                                                  })})
                                          })
                                      })})
                              })
                          }),
                        "@[<2>constraint %a =@ %a@]"
                      }), out_type.contents, param[0], out_type.contents, param[1]);end end end 
     if ___conditional___ = 1--[[ Ocsg_method ]] then do
        return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      "<2>",
                                      --[[ End_of_format ]]0
                                    }),
                                  "<2>"
                                }}),
                            --[[ String_literal ]]Block.__(11, {
                                "method ",
                                --[[ String ]]Block.__(2, {
                                    --[[ No_padding ]]0,
                                    --[[ String ]]Block.__(2, {
                                        --[[ No_padding ]]0,
                                        --[[ String ]]Block.__(2, {
                                            --[[ No_padding ]]0,
                                            --[[ String_literal ]]Block.__(11, {
                                                " :",
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Close_box ]]0,
                                                            --[[ End_of_format ]]0
                                                          })})
                                                  })
                                              })
                                          })
                                      })
                                  })
                              })
                          }),
                        "@[<2>method %s%s%s :@ %a@]"
                      }), param[1] and "private " or "", param[2] and "virtual " or "", param[0], out_type.contents, param[3]);end end end 
     if ___conditional___ = 2--[[ Ocsg_value ]] then do
        return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      "<2>",
                                      --[[ End_of_format ]]0
                                    }),
                                  "<2>"
                                }}),
                            --[[ String_literal ]]Block.__(11, {
                                "val ",
                                --[[ String ]]Block.__(2, {
                                    --[[ No_padding ]]0,
                                    --[[ String ]]Block.__(2, {
                                        --[[ No_padding ]]0,
                                        --[[ String ]]Block.__(2, {
                                            --[[ No_padding ]]0,
                                            --[[ String_literal ]]Block.__(11, {
                                                " :",
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Close_box ]]0,
                                                            --[[ End_of_format ]]0
                                                          })})
                                                  })
                                              })
                                          })
                                      })
                                  })
                              })
                          }),
                        "@[<2>val %s%s%s :@ %a@]"
                      }), param[1] and "mutable " or "", param[2] and "virtual " or "", param[0], out_type.contents, param[3]);end end end 
     do
    
  end
end end

out_class_type = do
  contents: print_out_class_type
end;

out_module_type = do
  contents: (function (param) do
      throw {
            Caml_builtin_exceptions.failure,
            "Oprint.out_module_type"
          };
    end end)
end;

out_sig_item = do
  contents: (function (param) do
      throw {
            Caml_builtin_exceptions.failure,
            "Oprint.out_sig_item"
          };
    end end)
end;

out_signature = do
  contents: (function (param) do
      throw {
            Caml_builtin_exceptions.failure,
            "Oprint.out_signature"
          };
    end end)
end;

out_type_extension = do
  contents: (function (param) do
      throw {
            Caml_builtin_exceptions.failure,
            "Oprint.out_type_extension"
          };
    end end)
end;

function print_out_functor(ppf, m) do
  if (typeof m ~= "number" and not m.tag) then do
    match = m[1];
    if (match ~= undefined) then do
      return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Char_literal ]]Block.__(12, {
                          --[[ "(" ]]40,
                          --[[ String ]]Block.__(2, {
                              --[[ No_padding ]]0,
                              --[[ String_literal ]]Block.__(11, {
                                  " : ",
                                  --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                          ") ",
                                          --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                        })})
                                })
                            })
                        }),
                      "(%s : %a) %a"
                    }), m[0], print_out_module_type, match, print_out_functor, m[2]);
    end else do
      return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "() ",
                          --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                        }),
                      "() %a"
                    }), print_out_functor, m[2]);
    end end 
  end
   end 
  return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                  --[[ String_literal ]]Block.__(11, {
                      "->",
                      --[[ Formatting_lit ]]Block.__(17, {
                          --[[ Break ]]Block.__(0, {
                              "@ ",
                              1,
                              0
                            }),
                          --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                        })
                    }),
                  "->@ %a"
                }), print_out_module_type, m);
end end

function print_out_constr(ppf, param) do
  ret_type_opt = param[2];
  tyl = param[1];
  name = param[0];
  if (ret_type_opt ~= undefined) then do
    ret_type = ret_type_opt;
    if (tyl) then do
      return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Formatting_gen ]]Block.__(18, {
                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                --[[ String_literal ]]Block.__(11, {
                                    "<2>",
                                    --[[ End_of_format ]]0
                                  }),
                                "<2>"
                              }}),
                          --[[ String ]]Block.__(2, {
                              --[[ No_padding ]]0,
                              --[[ String_literal ]]Block.__(11, {
                                  " :",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                              " -> ",
                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Close_box ]]0,
                                                      --[[ End_of_format ]]0
                                                    })})
                                            })})
                                    })
                                })
                            })
                        }),
                      "@[<2>%s :@ %a -> %a@]"
                    }), name, (function (param, param$1) do
                    return print_typlist(print_simple_out_type, " *", param, param$1);
                  end end), tyl, print_simple_out_type, ret_type);
    end else do
      return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Formatting_gen ]]Block.__(18, {
                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                --[[ String_literal ]]Block.__(11, {
                                    "<2>",
                                    --[[ End_of_format ]]0
                                  }),
                                "<2>"
                              }}),
                          --[[ String ]]Block.__(2, {
                              --[[ No_padding ]]0,
                              --[[ String_literal ]]Block.__(11, {
                                  " :",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Close_box ]]0,
                                              --[[ End_of_format ]]0
                                            })})
                                    })
                                })
                            })
                        }),
                      "@[<2>%s :@ %a@]"
                    }), name, print_simple_out_type, ret_type);
    end end 
  end else if (tyl) then do
    return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<2>",
                                  --[[ End_of_format ]]0
                                }),
                              "<2>"
                            }}),
                        --[[ String ]]Block.__(2, {
                            --[[ No_padding ]]0,
                            --[[ String_literal ]]Block.__(11, {
                                " of",
                                --[[ Formatting_lit ]]Block.__(17, {
                                    --[[ Break ]]Block.__(0, {
                                        "@ ",
                                        1,
                                        0
                                      }),
                                    --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Close_box ]]0,
                                            --[[ End_of_format ]]0
                                          })})
                                  })
                              })
                          })
                      }),
                    "@[<2>%s of@ %a@]"
                  }), name, (function (param, param$1) do
                  return print_typlist(print_simple_out_type, " *", param, param$1);
                end end), tyl);
  end else do
    return Format.pp_print_string(ppf, name);
  end end  end 
end end

function print_out_label(ppf, param) do
  return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                  --[[ Formatting_gen ]]Block.__(18, {
                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                            --[[ String_literal ]]Block.__(11, {
                                "<2>",
                                --[[ End_of_format ]]0
                              }),
                            "<2>"
                          }}),
                      --[[ String ]]Block.__(2, {
                          --[[ No_padding ]]0,
                          --[[ String ]]Block.__(2, {
                              --[[ No_padding ]]0,
                              --[[ String_literal ]]Block.__(11, {
                                  " :",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Close_box ]]0,
                                              --[[ Char_literal ]]Block.__(12, {
                                                  --[[ ";" ]]59,
                                                  --[[ End_of_format ]]0
                                                })
                                            })})
                                    })
                                })
                            })
                        })
                    }),
                  "@[<2>%s%s :@ %a@];"
                }), param[1] and "mutable " or "", param[0], out_type.contents, param[2]);
end end

function print_out_signature(ppf, param) do
  if (param) then do
    item = param[0];
    if (param[1]) then do
      if (item.tag == --[[ Osig_typext ]]2 and item[1] == 0) then do
        ext = item[0];
        gather_extensions = function (_acc, _items) do
          while(true) do
            items = _items;
            acc = _acc;
            if (items) then do
              match = items[0];
              if (match.tag == --[[ Osig_typext ]]2 and match[1] == 1) then do
                ext = match[0];
                _items = items[1];
                _acc = --[[ :: ]]{
                  --[[ tuple ]]{
                    ext.oext_name,
                    ext.oext_args,
                    ext.oext_ret_type
                  },
                  acc
                };
                continue ;
              end else do
                return --[[ tuple ]]{
                        List.rev(acc),
                        items
                      };
              end end 
            end else do
              return --[[ tuple ]]{
                      List.rev(acc),
                      items
                    };
            end end 
          end;
        end end;
        match = gather_extensions(--[[ :: ]]{
              --[[ tuple ]]{
                ext.oext_name,
                ext.oext_args,
                ext.oext_ret_type
              },
              --[[ [] ]]0
            }, param[1]);
        te_otyext_name = ext.oext_type_name;
        te_otyext_params = ext.oext_type_params;
        te_otyext_constructors = match[0];
        te_otyext_private = ext.oext_private;
        te = do
          otyext_name: te_otyext_name,
          otyext_params: te_otyext_params,
          otyext_constructors: te_otyext_constructors,
          otyext_private: te_otyext_private
        end;
        return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@ ",
                                    1,
                                    0
                                  }),
                                --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                              })}),
                        "%a@ %a"
                      }), out_type_extension.contents, te, print_out_signature, match[1]);
      end
       end 
    end else do
      return Curry._2(out_sig_item.contents, ppf, item);
    end end 
    return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                            --[[ Break ]]Block.__(0, {
                                "@ ",
                                1,
                                0
                              }),
                            --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                          })}),
                    "%a@ %a"
                  }), out_sig_item.contents, item, print_out_signature, param[1]);
  end else do
    return --[[ () ]]0;
  end end 
end end

function print_out_module_type(ppf, t) do
  if (typeof t == "number") then do
    return --[[ () ]]0;
  end else do
    local ___conditional___=(t.tag | 0);
    do
       if ___conditional___ = 0--[[ Omty_functor ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<2>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "functor",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Close_box ]]0,
                                              --[[ End_of_format ]]0
                                            })})
                                    })
                                })
                            }),
                          "@[<2>functor@ %a@]"
                        }), print_out_functor, t);end end end 
       if ___conditional___ = 1--[[ Omty_ident ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0}),
                          "%a"
                        }), print_ident, t[0]);end end end 
       if ___conditional___ = 2--[[ Omty_signature ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hv 2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hv 2>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "sig",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@;<1 -2>",
                                                  1,
                                                  -2
                                                }),
                                              --[[ String_literal ]]Block.__(11, {
                                                  "end",
                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Close_box ]]0,
                                                      --[[ End_of_format ]]0
                                                    })
                                                })
                                            })})
                                    })
                                })
                            }),
                          "@[<hv 2>sig@ %a@;<1 -2>end@]"
                        }), out_signature.contents, t[0]);end end end 
       if ___conditional___ = 3--[[ Omty_alias ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "(module ",
                              --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                      --[[ ")" ]]41,
                                      --[[ End_of_format ]]0
                                    })})
                            }),
                          "(module %a)"
                        }), print_ident, t[0]);end end end 
       do
      
    end
  end end 
end end

function print_out_sig_item(ppf, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Osig_class ]] then do
        return Curry._7(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      "<2>",
                                      --[[ End_of_format ]]0
                                    }),
                                  "<2>"
                                }}),
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ String ]]Block.__(2, {
                                    --[[ No_padding ]]0,
                                    --[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Break ]]Block.__(0, {
                                            "@ ",
                                            1,
                                            0
                                          }),
                                        --[[ Alpha ]]Block.__(15, {--[[ String ]]Block.__(2, {
                                                --[[ No_padding ]]0,
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ Char_literal ]]Block.__(12, {
                                                        --[[ ":" ]]58,
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Break ]]Block.__(0, {
                                                                "@ ",
                                                                1,
                                                                0
                                                              }),
                                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                    --[[ Close_box ]]0,
                                                                    --[[ End_of_format ]]0
                                                                  })})
                                                          })
                                                      })
                                                  })
                                              })})
                                      })
                                  })
                              })
                          }),
                        "@[<2>%s%s@ %a%s@ :@ %a@]"
                      }), param[4] == --[[ Orec_next ]]2 and "and" or "class", param[0] and " virtual" or "", print_out_class_params, param[2], param[1], out_class_type.contents, param[3]);end end end 
     if ___conditional___ = 1--[[ Osig_class_type ]] then do
        return Curry._7(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      "<2>",
                                      --[[ End_of_format ]]0
                                    }),
                                  "<2>"
                                }}),
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ String ]]Block.__(2, {
                                    --[[ No_padding ]]0,
                                    --[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Break ]]Block.__(0, {
                                            "@ ",
                                            1,
                                            0
                                          }),
                                        --[[ Alpha ]]Block.__(15, {--[[ String ]]Block.__(2, {
                                                --[[ No_padding ]]0,
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ Char_literal ]]Block.__(12, {
                                                        --[[ "=" ]]61,
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Break ]]Block.__(0, {
                                                                "@ ",
                                                                1,
                                                                0
                                                              }),
                                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                    --[[ Close_box ]]0,
                                                                    --[[ End_of_format ]]0
                                                                  })})
                                                          })
                                                      })
                                                  })
                                              })})
                                      })
                                  })
                              })
                          }),
                        "@[<2>%s%s@ %a%s@ =@ %a@]"
                      }), param[4] == --[[ Orec_next ]]2 and "and" or "class type", param[0] and " virtual" or "", print_out_class_params, param[2], param[1], out_class_type.contents, param[3]);end end end 
     if ___conditional___ = 2--[[ Osig_typext ]] then do
        ext = param[0];
        if (param[1] >= 2) then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<2>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "exception ",
                                  --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Close_box ]]0,
                                          --[[ End_of_format ]]0
                                        })})
                                })
                            }),
                          "@[<2>exception %a@]"
                        }), print_out_constr, --[[ tuple ]]{
                      ext.oext_name,
                      ext.oext_args,
                      ext.oext_ret_type
                    });
        end else do
          ppf$1 = ppf;
          ext$1 = ext;
          print_extended_type = function (ppf) do
            print_type_parameter = function (ppf, ty) do
              return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ End_of_format ]]0
                                }),
                              "%s"
                            }), ty == "_" and ty or "'" .. ty);
            end end;
            match = ext$1.oext_type_params;
            if (match) then do
              if (match[1]) then do
                return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                                --[[ Formatting_gen ]]Block.__(18, {
                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                          --[[ End_of_format ]]0,
                                          ""
                                        }}),
                                    --[[ Char_literal ]]Block.__(12, {
                                        --[[ "(" ]]40,
                                        --[[ Formatting_gen ]]Block.__(18, {
                                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                  --[[ End_of_format ]]0,
                                                  ""
                                                }}),
                                            --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                    --[[ ")" ]]41,
                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                        --[[ Close_box ]]0,
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Break ]]Block.__(0, {
                                                                "@ ",
                                                                1,
                                                                0
                                                              }),
                                                            --[[ String ]]Block.__(2, {
                                                                --[[ No_padding ]]0,
                                                                --[[ Formatting_lit ]]Block.__(17, {
                                                                    --[[ Close_box ]]0,
                                                                    --[[ End_of_format ]]0
                                                                  })
                                                              })
                                                          })
                                                      })
                                                  })})
                                          })
                                      })
                                  }),
                                "@[(@[%a)@]@ %s@]"
                              }), (function (param, param$1) do
                              return print_list(print_type_parameter, (function (ppf) do
                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                        --[[ Char_literal ]]Block.__(12, {
                                                            --[[ "," ]]44,
                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                --[[ Break ]]Block.__(0, {
                                                                    "@ ",
                                                                    1,
                                                                    0
                                                                  }),
                                                                --[[ End_of_format ]]0
                                                              })
                                                          }),
                                                        ",@ "
                                                      });
                                          end end), param, param$1);
                            end end), ext$1.oext_type_params, ext$1.oext_type_name);
              end else do
                return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                                --[[ Formatting_gen ]]Block.__(18, {
                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                          --[[ End_of_format ]]0,
                                          ""
                                        }}),
                                    --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ String ]]Block.__(2, {
                                                --[[ No_padding ]]0,
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Close_box ]]0,
                                                    --[[ End_of_format ]]0
                                                  })
                                              })
                                          })})
                                  }),
                                "@[%a@ %s@]"
                              }), print_type_parameter, match[0], ext$1.oext_type_name);
              end end 
            end else do
              return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ End_of_format ]]0
                                }),
                              "%s"
                            }), ext$1.oext_type_name);
            end end 
          end end;
          return Curry._4(Format.fprintf(ppf$1, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hv 2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hv 2>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "type ",
                                  --[[ Theta ]]Block.__(16, {--[[ String_literal ]]Block.__(11, {
                                          " +=",
                                          --[[ String ]]Block.__(2, {
                                              --[[ No_padding ]]0,
                                              --[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Break ]]Block.__(0, {
                                                      "@;<1 2>",
                                                      1,
                                                      2
                                                    }),
                                                  --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                          --[[ Close_box ]]0,
                                                          --[[ End_of_format ]]0
                                                        })})
                                                })
                                            })
                                        })})
                                })
                            }),
                          "@[<hv 2>type %t +=%s@;<1 2>%a@]"
                        }), print_extended_type, ext$1.oext_private == --[[ Private ]]0 and " private" or "", print_out_constr, --[[ tuple ]]{
                      ext$1.oext_name,
                      ext$1.oext_args,
                      ext$1.oext_ret_type
                    });
        end end end end end 
     if ___conditional___ = 3--[[ Osig_modtype ]] then do
        mty = param[1];
        name = param[0];
        if (typeof mty == "number") then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<2>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "module type ",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Close_box ]]0,
                                          --[[ End_of_format ]]0
                                        })
                                    })
                                })
                            }),
                          "@[<2>module type %s@]"
                        }), name);
        end else do
          return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<2>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "module type ",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ String_literal ]]Block.__(11, {
                                          " =",
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@ ",
                                                  1,
                                                  0
                                                }),
                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Close_box ]]0,
                                                      --[[ End_of_format ]]0
                                                    })})
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[<2>module type %s =@ %a@]"
                        }), name, out_module_type.contents, mty);
        end end end end end 
     if ___conditional___ = 4--[[ Osig_module ]] then do
        mty$1 = param[1];
        name$1 = param[0];
        if (typeof mty$1 ~= "number" and mty$1.tag == --[[ Omty_alias ]]3) then do
          return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<2>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "module ",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ String_literal ]]Block.__(11, {
                                          " =",
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@ ",
                                                  1,
                                                  0
                                                }),
                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Close_box ]]0,
                                                      --[[ End_of_format ]]0
                                                    })})
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[<2>module %s =@ %a@]"
                        }), name$1, print_ident, mty$1[0]);
        end
         end 
        tmp;
        local ___conditional___=(param[2]);
        do
           if ___conditional___ = 0--[[ Orec_not ]] then do
              tmp = "module";end else 
           if ___conditional___ = 1--[[ Orec_first ]] then do
              tmp = "module rec";end else 
           if ___conditional___ = 2--[[ Orec_next ]] then do
              tmp = "and";end else 
           do end end end end
          
        end
        return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      "<2>",
                                      --[[ End_of_format ]]0
                                    }),
                                  "<2>"
                                }}),
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ Char_literal ]]Block.__(12, {
                                    --[[ " " ]]32,
                                    --[[ String ]]Block.__(2, {
                                        --[[ No_padding ]]0,
                                        --[[ String_literal ]]Block.__(11, {
                                            " :",
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Break ]]Block.__(0, {
                                                    "@ ",
                                                    1,
                                                    0
                                                  }),
                                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                        --[[ Close_box ]]0,
                                                        --[[ End_of_format ]]0
                                                      })})
                                              })
                                          })
                                      })
                                  })
                              })
                          }),
                        "@[<2>%s %s :@ %a@]"
                      }), tmp, name$1, out_module_type.contents, mty$1);end end end 
     if ___conditional___ = 5--[[ Osig_type ]] then do
        tmp$1;
        local ___conditional___=(param[1]);
        do
           if ___conditional___ = 0--[[ Orec_not ]] then do
              tmp$1 = "type nonrec";end else 
           if ___conditional___ = 1--[[ Orec_first ]] then do
              tmp$1 = "type";end else 
           if ___conditional___ = 2--[[ Orec_next ]] then do
              tmp$1 = "and";end else 
           do end end end end
          
        end
        kwd = tmp$1;
        ppf$2 = ppf;
        td = param[0];
        print_constraints = function (ppf) do
          return List.iter((function (param) do
                        return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ Formatting_gen ]]Block.__(18, {
                                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                      --[[ String_literal ]]Block.__(11, {
                                                          "<2>",
                                                          --[[ End_of_format ]]0
                                                        }),
                                                      "<2>"
                                                    }}),
                                                --[[ String_literal ]]Block.__(11, {
                                                    "constraint ",
                                                    --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                                            " =",
                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                --[[ Break ]]Block.__(0, {
                                                                    "@ ",
                                                                    1,
                                                                    0
                                                                  }),
                                                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                        --[[ Close_box ]]0,
                                                                        --[[ End_of_format ]]0
                                                                      })})
                                                              })
                                                          })})
                                                  })
                                              })
                                          }),
                                        "@ @[<2>constraint %a =@ %a@]"
                                      }), out_type.contents, param[0], out_type.contents, param[1]);
                      end end), td.otype_cstrs);
        end end;
        type_defined = function (ppf) do
          match = td.otype_params;
          if (match) then do
            if (match[1]) then do
              return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                              --[[ Formatting_gen ]]Block.__(18, {
                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                        --[[ End_of_format ]]0,
                                        ""
                                      }}),
                                  --[[ Char_literal ]]Block.__(12, {
                                      --[[ "(" ]]40,
                                      --[[ Formatting_gen ]]Block.__(18, {
                                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                --[[ End_of_format ]]0,
                                                ""
                                              }}),
                                          --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                  --[[ ")" ]]41,
                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Close_box ]]0,
                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                          --[[ Break ]]Block.__(0, {
                                                              "@ ",
                                                              1,
                                                              0
                                                            }),
                                                          --[[ String ]]Block.__(2, {
                                                              --[[ No_padding ]]0,
                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                  --[[ Close_box ]]0,
                                                                  --[[ End_of_format ]]0
                                                                })
                                                            })
                                                        })
                                                    })
                                                })})
                                        })
                                    })
                                }),
                              "@[(@[%a)@]@ %s@]"
                            }), (function (param, param$1) do
                            return print_list(type_parameter, (function (ppf) do
                                          return Format.fprintf(ppf, --[[ Format ]]{
                                                      --[[ Char_literal ]]Block.__(12, {
                                                          --[[ "," ]]44,
                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Break ]]Block.__(0, {
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                }),
                                                              --[[ End_of_format ]]0
                                                            })
                                                        }),
                                                      ",@ "
                                                    });
                                        end end), param, param$1);
                          end end), td.otype_params, td.otype_name);
            end else do
              return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                              --[[ Formatting_gen ]]Block.__(18, {
                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                        --[[ End_of_format ]]0,
                                        ""
                                      }}),
                                  --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ String ]]Block.__(2, {
                                              --[[ No_padding ]]0,
                                              --[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Close_box ]]0,
                                                  --[[ End_of_format ]]0
                                                })
                                            })
                                        })})
                                }),
                              "@[%a@ %s@]"
                            }), type_parameter, match[0], td.otype_name);
            end end 
          end else do
            return Format.pp_print_string(ppf, td.otype_name);
          end end 
        end end;
        print_manifest = function (ppf, param) do
          if (typeof param == "number" or param.tag ~= --[[ Otyp_manifest ]]4) then do
            return --[[ () ]]0;
          end else do
            return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                            --[[ String_literal ]]Block.__(11, {
                                " =",
                                --[[ Formatting_lit ]]Block.__(17, {
                                    --[[ Break ]]Block.__(0, {
                                        "@ ",
                                        1,
                                        0
                                      }),
                                    --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                  })
                              }),
                            " =@ %a"
                          }), out_type.contents, param[0]);
          end end 
        end end;
        print_name_params = function (ppf) do
          return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String ]]Block.__(2, {
                              --[[ No_padding ]]0,
                              --[[ Char_literal ]]Block.__(12, {
                                  --[[ " " ]]32,
                                  --[[ Theta ]]Block.__(16, {--[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})})
                                })
                            }),
                          "%s %t%a"
                        }), kwd, type_defined, print_manifest, td.otype_type);
        end end;
        match = td.otype_type;
        ty;
        ty = typeof match == "number" or match.tag ~= --[[ Otyp_manifest ]]4 and td.otype_type or match[1];
        print_private = function (ppf, param) do
          if (param) then do
            return --[[ () ]]0;
          end else do
            return Format.fprintf(ppf, --[[ Format ]]{
                        --[[ String_literal ]]Block.__(11, {
                            " private",
                            --[[ End_of_format ]]0
                          }),
                        " private"
                      });
          end end 
        end end;
        print_out_tkind = function (ppf, ty) do
          if (typeof ty == "number") then do
            if (ty == --[[ Otyp_abstract ]]0) then do
              return --[[ () ]]0;
            end else do
              return Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              " = ..",
                              --[[ End_of_format ]]0
                            }),
                          " = .."
                        });
            end end 
          end else do
            local ___conditional___=(ty.tag | 0);
            do
               if ___conditional___ = 6--[[ Otyp_record ]] then do
                  return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      " =",
                                      --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                              " {",
                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Break ]]Block.__(0, {
                                                          "@;<1 -2>",
                                                          1,
                                                          -2
                                                        }),
                                                      --[[ Char_literal ]]Block.__(12, {
                                                          --[[ "}" ]]125,
                                                          --[[ End_of_format ]]0
                                                        })
                                                    })})
                                            })})
                                    }),
                                  " =%a {%a@;<1 -2>}"
                                }), print_private, td.otype_private, (function (param, param$1) do
                                pr = print_out_label;
                                sep = function (ppf) do
                                  return Format.fprintf(ppf, --[[ Format ]]{
                                              --[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Break ]]Block.__(0, {
                                                      "@ ",
                                                      1,
                                                      0
                                                    }),
                                                  --[[ End_of_format ]]0
                                                }),
                                              "@ "
                                            });
                                end end;
                                ppf = param;
                                _param = param$1;
                                while(true) do
                                  param$2 = _param;
                                  if (param$2) then do
                                    Curry._1(sep, ppf);
                                    Curry._2(pr, ppf, param$2[0]);
                                    _param = param$2[1];
                                    continue ;
                                  end else do
                                    return --[[ () ]]0;
                                  end end 
                                end;
                              end end), ty[0]);end end end 
               if ___conditional___ = 8--[[ Otyp_sum ]] then do
                  return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      " =",
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@;<1 2>",
                                                  1,
                                                  2
                                                }),
                                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                            })})
                                    }),
                                  " =%a@;<1 2>%a"
                                }), print_private, td.otype_private, (function (param, param$1) do
                                return print_list(print_out_constr, (function (ppf) do
                                              return Format.fprintf(ppf, --[[ Format ]]{
                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Break ]]Block.__(0, {
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                }),
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "| ",
                                                                  --[[ End_of_format ]]0
                                                                })
                                                            }),
                                                          "@ | "
                                                        });
                                            end end), param, param$1);
                              end end), ty[0]);end end end 
               do
              else do
                return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                                --[[ String_literal ]]Block.__(11, {
                                    " =",
                                    --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@;<1 2>",
                                                1,
                                                2
                                              }),
                                            --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                          })})
                                  }),
                                " =%a@;<1 2>%a"
                              }), print_private, td.otype_private, out_type.contents, ty);
                end end
                
            end
          end end 
        end end;
        return Curry._4(Format.fprintf(ppf$2, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      "<2>",
                                      --[[ End_of_format ]]0
                                    }),
                                  "<2>"
                                }}),
                            --[[ Formatting_gen ]]Block.__(18, {
                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                      --[[ String_literal ]]Block.__(11, {
                                          "<hv 2>",
                                          --[[ End_of_format ]]0
                                        }),
                                      "<hv 2>"
                                    }}),
                                --[[ Theta ]]Block.__(16, {--[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Close_box ]]0,
                                            --[[ Theta ]]Block.__(16, {--[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Close_box ]]0,
                                                    --[[ End_of_format ]]0
                                                  })})
                                          })})})
                              })
                          }),
                        "@[<2>@[<hv 2>%t%a@]%t@]"
                      }), print_name_params, print_out_tkind, ty, print_constraints);end end end 
     if ___conditional___ = 6--[[ Osig_value ]] then do
        prims = param[2];
        kwd$1 = prims == --[[ [] ]]0 and "val" or "external";
        pr_prims = function (ppf, param) do
          if (param) then do
            Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Formatting_lit ]]Block.__(17, {
                          --[[ Break ]]Block.__(0, {
                              "@ ",
                              1,
                              0
                            }),
                          --[[ String_literal ]]Block.__(11, {
                              "= \"",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ Char_literal ]]Block.__(12, {
                                      --[[ "\"" ]]34,
                                      --[[ End_of_format ]]0
                                    })
                                })
                            })
                        }),
                      "@ = \"%s\""
                    }), param[0]);
            return List.iter((function (s) do
                          len = #s;
                          if (len >= 3 and Caml_string.get(s, 0) == --[[ "B" ]]66 and Caml_string.get(s, 1) == --[[ "S" ]]83 and Caml_string.get(s, 2) == --[[ ":" ]]58) then do
                            return Format.fprintf(ppf, --[[ Format ]]{
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ String_literal ]]Block.__(11, {
                                                "\"BS-EXTERNAL\"",
                                                --[[ End_of_format ]]0
                                              })
                                          }),
                                        "@ \"BS-EXTERNAL\""
                                      });
                          end else do
                            return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Break ]]Block.__(0, {
                                                    "@ ",
                                                    1,
                                                    0
                                                  }),
                                                --[[ Char_literal ]]Block.__(12, {
                                                    --[[ "\"" ]]34,
                                                    --[[ String ]]Block.__(2, {
                                                        --[[ No_padding ]]0,
                                                        --[[ Char_literal ]]Block.__(12, {
                                                            --[[ "\"" ]]34,
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })
                                                  })
                                              }),
                                            "@ \"%s\""
                                          }), s);
                          end end 
                        end end), param[1]);
          end else do
            return --[[ () ]]0;
          end end 
        end end;
        return Curry._7(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      "<2>",
                                      --[[ End_of_format ]]0
                                    }),
                                  "<2>"
                                }}),
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ Char_literal ]]Block.__(12, {
                                    --[[ " " ]]32,
                                    --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                            " :",
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Break ]]Block.__(0, {
                                                    "@ ",
                                                    1,
                                                    0
                                                  }),
                                                --[[ Alpha ]]Block.__(15, {--[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Close_box ]]0,
                                                            --[[ End_of_format ]]0
                                                          })})})
                                              })
                                          })})
                                  })
                              })
                          }),
                        "@[<2>%s %a :@ %a%a@]"
                      }), kwd$1, value_ident, param[0], out_type.contents, param[1], pr_prims, prims);end end end 
     do
    
  end
end end

function print_out_type_extension(ppf, te) do
  print_extended_type = function (ppf) do
    print_type_parameter = function (ppf, ty) do
      return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String ]]Block.__(2, {
                          --[[ No_padding ]]0,
                          --[[ End_of_format ]]0
                        }),
                      "%s"
                    }), ty == "_" and ty or "'" .. ty);
    end end;
    match = te.otyext_params;
    if (match) then do
      if (match[1]) then do
        return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ End_of_format ]]0,
                                  ""
                                }}),
                            --[[ Char_literal ]]Block.__(12, {
                                --[[ "(" ]]40,
                                --[[ Formatting_gen ]]Block.__(18, {
                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                          --[[ End_of_format ]]0,
                                          ""
                                        }}),
                                    --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                            --[[ ")" ]]41,
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Close_box ]]0,
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ String ]]Block.__(2, {
                                                        --[[ No_padding ]]0,
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Close_box ]]0,
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })
                                                  })
                                              })
                                          })})
                                  })
                              })
                          }),
                        "@[(@[%a)@]@ %s@]"
                      }), (function (param, param$1) do
                      return print_list(print_type_parameter, (function (ppf) do
                                    return Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ Char_literal ]]Block.__(12, {
                                                    --[[ "," ]]44,
                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                        --[[ Break ]]Block.__(0, {
                                                            "@ ",
                                                            1,
                                                            0
                                                          }),
                                                        --[[ End_of_format ]]0
                                                      })
                                                  }),
                                                ",@ "
                                              });
                                  end end), param, param$1);
                    end end), te.otyext_params, te.otyext_name);
      end else do
        return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ End_of_format ]]0,
                                  ""
                                }}),
                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                    --[[ Break ]]Block.__(0, {
                                        "@ ",
                                        1,
                                        0
                                      }),
                                    --[[ String ]]Block.__(2, {
                                        --[[ No_padding ]]0,
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Close_box ]]0,
                                            --[[ End_of_format ]]0
                                          })
                                      })
                                  })})
                          }),
                        "@[%a@ %s@]"
                      }), print_type_parameter, match[0], te.otyext_name);
      end end 
    end else do
      return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String ]]Block.__(2, {
                          --[[ No_padding ]]0,
                          --[[ End_of_format ]]0
                        }),
                      "%s"
                    }), te.otyext_name);
    end end 
  end end;
  return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                  --[[ Formatting_gen ]]Block.__(18, {
                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                            --[[ String_literal ]]Block.__(11, {
                                "<hv 2>",
                                --[[ End_of_format ]]0
                              }),
                            "<hv 2>"
                          }}),
                      --[[ String_literal ]]Block.__(11, {
                          "type ",
                          --[[ Theta ]]Block.__(16, {--[[ String_literal ]]Block.__(11, {
                                  " +=",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@;<1 2>",
                                              1,
                                              2
                                            }),
                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Close_box ]]0,
                                                  --[[ End_of_format ]]0
                                                })})
                                        })
                                    })
                                })})
                        })
                    }),
                  "@[<hv 2>type %t +=%s@;<1 2>%a@]"
                }), print_extended_type, te.otyext_private == --[[ Private ]]0 and " private" or "", (function (param, param$1) do
                return print_list(print_out_constr, (function (ppf) do
                              return Format.fprintf(ppf, --[[ Format ]]{
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@ ",
                                                  1,
                                                  0
                                                }),
                                              --[[ String_literal ]]Block.__(11, {
                                                  "| ",
                                                  --[[ End_of_format ]]0
                                                })
                                            }),
                                          "@ | "
                                        });
                            end end), param, param$1);
              end end), te.otyext_constructors);
end end

out_module_type.contents = print_out_module_type;

out_signature.contents = print_out_signature;

out_sig_item.contents = print_out_sig_item;

out_type_extension.contents = print_out_type_extension;

function longident(ppf, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Lident ]] then do
        return Format.pp_print_string(ppf, param[0]);end end end 
     if ___conditional___ = 1--[[ Ldot ]] then do
        return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                --[[ "." ]]46,
                                --[[ String ]]Block.__(2, {
                                    --[[ No_padding ]]0,
                                    --[[ End_of_format ]]0
                                  })
                              })}),
                        "%a.%s"
                      }), longident, param[0], param[1]);end end end 
     if ___conditional___ = 2--[[ Lapply ]] then do
        return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                --[[ "(" ]]40,
                                --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                        --[[ ")" ]]41,
                                        --[[ End_of_format ]]0
                                      })})
                              })}),
                        "%a(%a)"
                      }), longident, param[0], longident, param[1]);end end end 
     do
    
  end
end end

unique_names = do
  contents: --[[ Empty ]]0
end;

function ident_name(id) do
  try do
    return find_same(id, unique_names.contents);
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return id.name;
    end else do
      throw exn;
    end end 
  end
end end

function add_unique(id) do
  try do
    find_same(id, unique_names.contents);
    return --[[ () ]]0;
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      unique_names.contents = add(id, unique_toplevel_name(id), unique_names.contents);
      return --[[ () ]]0;
    end else do
      throw exn;
    end end 
  end
end end

function ident$3(ppf, id) do
  return Format.pp_print_string(ppf, ident_name(id));
end end

ident_pervasive = do
  stamp: 0,
  name: "Pervasives",
  flags: 1
end;

function tree_of_path(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Pident ]] then do
        return --[[ Oide_ident ]]Block.__(2, {ident_name(param[0])});end end end 
     if ___conditional___ = 1--[[ Pdot ]] then do
        p = param[0];
        local ___conditional___=(p.tag | 0);
        do
           if ___conditional___ = 0--[[ Pident ]] then do
              if (Caml_obj.caml_equal(p[0], ident_pervasive)) then do
                return --[[ Oide_ident ]]Block.__(2, {param[1]});
              end
               end end else 
           if ___conditional___ = 1--[[ Pdot ]]
           or ___conditional___ = 2--[[ Papply ]]
           do end end
          
        end
        return --[[ Oide_dot ]]Block.__(1, {
                  tree_of_path(p),
                  param[1]
                });end end end 
     if ___conditional___ = 2--[[ Papply ]] then do
        return --[[ Oide_apply ]]Block.__(0, {
                  tree_of_path(param[0]),
                  tree_of_path(param[1])
                });end end end 
     do
    
  end
end end

function path(ppf, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Pident ]] then do
        return Format.pp_print_string(ppf, ident_name(param[0]));end end end 
     if ___conditional___ = 1--[[ Pdot ]] then do
        p = param[0];
        local ___conditional___=(p.tag | 0);
        do
           if ___conditional___ = 0--[[ Pident ]] then do
              if (Caml_obj.caml_equal(p[0], ident_pervasive)) then do
                return Format.pp_print_string(ppf, param[1]);
              end
               end end else 
           if ___conditional___ = 1--[[ Pdot ]]
           or ___conditional___ = 2--[[ Papply ]]
           do end end
          
        end
        path(ppf, p);
        Format.pp_print_char(ppf, --[[ "." ]]46);
        return Format.pp_print_string(ppf, param[1]);end end end 
     if ___conditional___ = 2--[[ Papply ]] then do
        return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                --[[ "(" ]]40,
                                --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                        --[[ ")" ]]41,
                                        --[[ End_of_format ]]0
                                      })})
                              })}),
                        "%a(%a)"
                      }), path, param[0], path, param[1]);end end end 
     do
    
  end
end end

function string_of_out_ident(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Oide_apply ]] then do
        return __String.concat("", --[[ :: ]]{
                    string_of_out_ident(param[0]),
                    --[[ :: ]]{
                      "(",
                      --[[ :: ]]{
                        string_of_out_ident(param[1]),
                        --[[ :: ]]{
                          ")",
                          --[[ [] ]]0
                        }
                      }
                    }
                  });end end end 
     if ___conditional___ = 1--[[ Oide_dot ]] then do
        return __String.concat(".", --[[ :: ]]{
                    string_of_out_ident(param[0]),
                    --[[ :: ]]{
                      param[1],
                      --[[ [] ]]0
                    }
                  });end end end 
     if ___conditional___ = 2--[[ Oide_ident ]] then do
        return param[0];end end end 
     do
    
  end
end end

function string_of_path(p) do
  return string_of_out_ident(tree_of_path(p));
end end

function raw_list(pr, ppf, param) do
  if (param) then do
    l = param[1];
    return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<1>",
                                  --[[ End_of_format ]]0
                                }),
                              "<1>"
                            }}),
                        --[[ Char_literal ]]Block.__(12, {
                            --[[ "[" ]]91,
                            --[[ Alpha ]]Block.__(15, {--[[ Theta ]]Block.__(16, {--[[ Char_literal ]]Block.__(12, {
                                        --[[ "]" ]]93,
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Close_box ]]0,
                                            --[[ End_of_format ]]0
                                          })
                                      })})})
                          })
                      }),
                    "@[<1>[%a%t]@]"
                  }), pr, param[0], (function (ppf) do
                  return List.iter((function (x) do
                                return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ Char_literal ]]Block.__(12, {
                                                    --[[ ";" ]]59,
                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                        --[[ Break ]]Block.__(0, {
                                                            "@,",
                                                            0,
                                                            0
                                                          }),
                                                        --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                      })
                                                  }),
                                                ";@,%a"
                                              }), pr, x);
                              end end), l);
                end end));
  end else do
    return Format.fprintf(ppf, --[[ Format ]]{
                --[[ String_literal ]]Block.__(11, {
                    "[]",
                    --[[ End_of_format ]]0
                  }),
                "[]"
              });
  end end 
end end

function safe_kind_repr(_v, _param) do
  while(true) do
    param = _param;
    v = _v;
    if (typeof param == "number") then do
      if (param ~= 0) then do
        return "Fabsent";
      end else do
        return "Fpresent";
      end end 
    end else do
      match = param[0].contents;
      if (match ~= undefined) then do
        k = match;
        if (List.memq(k, v)) then do
          return "Fvar loop";
        end else do
          _param = k;
          _v = --[[ :: ]]{
            k,
            v
          };
          continue ;
        end end 
      end else do
        return "Fvar None";
      end end 
    end end 
  end;
end end

function safe_commu_repr(_v, _param) do
  while(true) do
    param = _param;
    v = _v;
    if (typeof param == "number") then do
      if (param ~= 0) then do
        return "Cunknown";
      end else do
        return "Cok";
      end end 
    end else do
      r = param[0];
      if (List.memq(r, v)) then do
        return "Clink loop";
      end else do
        _param = r.contents;
        _v = --[[ :: ]]{
          r,
          v
        };
        continue ;
      end end 
    end end 
  end;
end end

function safe_repr(_v, _t) do
  while(true) do
    t = _t;
    v = _v;
    match = t.desc;
    if (typeof match == "number" or match.tag ~= --[[ Tlink ]]6) then do
      return t;
    end else do
      t$1 = match[0];
      if (List.memq(t$1, v)) then do
        return t;
      end else do
        _t = t$1;
        _v = --[[ :: ]]{
          t$1,
          v
        };
        continue ;
      end end 
    end end 
  end;
end end

function list_of_memo(_param) do
  while(true) do
    param = _param;
    if (typeof param == "number") then do
      return --[[ [] ]]0;
    end else if (param.tag) then do
      _param = param[0].contents;
      continue ;
    end else do
      return --[[ :: ]]{
              param[1],
              list_of_memo(param[4])
            };
    end end  end 
  end;
end end

function print_name(ppf, param) do
  if (param ~= undefined) then do
    return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Char_literal ]]Block.__(12, {
                        --[[ "\"" ]]34,
                        --[[ String ]]Block.__(2, {
                            --[[ No_padding ]]0,
                            --[[ Char_literal ]]Block.__(12, {
                                --[[ "\"" ]]34,
                                --[[ End_of_format ]]0
                              })
                          })
                      }),
                    "\"%s\""
                  }), param);
  end else do
    return Format.fprintf(ppf, --[[ Format ]]{
                --[[ String_literal ]]Block.__(11, {
                    "None",
                    --[[ End_of_format ]]0
                  }),
                "None"
              });
  end end 
end end

visited = do
  contents: --[[ [] ]]0
end;

function raw_type(ppf, ty) do
  ty$1 = safe_repr(--[[ [] ]]0, ty);
  if (List.memq(ty$1, visited.contents)) then do
    return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ String_literal ]]Block.__(11, {
                        "{id=",
                        --[[ Int ]]Block.__(4, {
                            --[[ Int_d ]]0,
                            --[[ No_padding ]]0,
                            --[[ No_precision ]]0,
                            --[[ Char_literal ]]Block.__(12, {
                                --[[ "}" ]]125,
                                --[[ End_of_format ]]0
                              })
                          })
                      }),
                    "{id=%d}"
                  }), ty$1.id);
  end else do
    visited.contents = --[[ :: ]]{
      ty$1,
      visited.contents
    };
    return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<1>",
                                  --[[ End_of_format ]]0
                                }),
                              "<1>"
                            }}),
                        --[[ String_literal ]]Block.__(11, {
                            "{id=",
                            --[[ Int ]]Block.__(4, {
                                --[[ Int_d ]]0,
                                --[[ No_padding ]]0,
                                --[[ No_precision ]]0,
                                --[[ String_literal ]]Block.__(11, {
                                    ";level=",
                                    --[[ Int ]]Block.__(4, {
                                        --[[ Int_d ]]0,
                                        --[[ No_padding ]]0,
                                        --[[ No_precision ]]0,
                                        --[[ String_literal ]]Block.__(11, {
                                            ";desc=",
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Break ]]Block.__(0, {
                                                    "@,",
                                                    0,
                                                    0
                                                  }),
                                                --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                        --[[ "}" ]]125,
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Close_box ]]0,
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })})
                                              })
                                          })
                                      })
                                  })
                              })
                          })
                      }),
                    "@[<1>{id=%d;level=%d;desc=@,%a}@]"
                  }), ty$1.id, ty$1.level, raw_type_desc, ty$1.desc);
  end end 
end end

function raw_type_list(tl) do
  return (function (param) do
      return raw_list(raw_type, tl, param);
    end end);
end end

function raw_type_desc(ppf, param) do
  if (typeof param == "number") then do
    return Format.fprintf(ppf, --[[ Format ]]{
                --[[ String_literal ]]Block.__(11, {
                    "Tnil",
                    --[[ End_of_format ]]0
                  }),
                "Tnil"
              });
  end else do
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ = 0--[[ Tvar ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "Tvar ",
                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                            }),
                          "Tvar %a"
                        }), print_name, param[0]);end end end 
       if ___conditional___ = 1--[[ Tarrow ]] then do
          return Curry._6(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hov1>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hov1>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "Tarrow(",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Char_literal ]]Block.__(12, {
                                          --[[ "," ]]44,
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@,",
                                                  0,
                                                  0
                                                }),
                                              --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                      --[[ "," ]]44,
                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                          --[[ Break ]]Block.__(0, {
                                                              "@,",
                                                              0,
                                                              0
                                                            }),
                                                          --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                                  --[[ "," ]]44,
                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Break ]]Block.__(0, {
                                                                          "@,",
                                                                          0,
                                                                          0
                                                                        }),
                                                                      --[[ String ]]Block.__(2, {
                                                                          --[[ No_padding ]]0,
                                                                          --[[ Char_literal ]]Block.__(12, {
                                                                              --[[ ")" ]]41,
                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Close_box ]]0,
                                                                                  --[[ End_of_format ]]0
                                                                                })
                                                                            })
                                                                        })
                                                                    })
                                                                })})
                                                        })
                                                    })})
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[<hov1>Tarrow(%s,@,%a,@,%a,@,%s)@]"
                        }), param[0], raw_type, param[1], raw_type, param[2], safe_commu_repr(--[[ [] ]]0, param[3]));end end end 
       if ___conditional___ = 2--[[ Ttuple ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<1>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<1>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "Ttuple",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@,",
                                          0,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Close_box ]]0,
                                              --[[ End_of_format ]]0
                                            })})
                                    })
                                })
                            }),
                          "@[<1>Ttuple@,%a@]"
                        }), raw_type_list, param[0]);end end end 
       if ___conditional___ = 3--[[ Tconstr ]] then do
          return Curry._6(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hov1>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hov1>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "Tconstr(",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@,",
                                          0,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                              --[[ "," ]]44,
                                              --[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Break ]]Block.__(0, {
                                                      "@,",
                                                      0,
                                                      0
                                                    }),
                                                  --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                          --[[ "," ]]44,
                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Break ]]Block.__(0, {
                                                                  "@,",
                                                                  0,
                                                                  0
                                                                }),
                                                              --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                                      --[[ ")" ]]41,
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Close_box ]]0,
                                                                          --[[ End_of_format ]]0
                                                                        })
                                                                    })})
                                                            })
                                                        })})
                                                })
                                            })})
                                    })
                                })
                            }),
                          "@[<hov1>Tconstr(@,%a,@,%a,@,%a)@]"
                        }), path, param[0], raw_type_list, param[1], (function (param, param$1) do
                        return raw_list(path, param, param$1);
                      end end), list_of_memo(param[2].contents));end end end 
       if ___conditional___ = 4--[[ Tobject ]] then do
          nm = param[1];
          return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hov1>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hov1>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "Tobject(",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@,",
                                          0,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                              --[[ "," ]]44,
                                              --[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Break ]]Block.__(0, {
                                                      "@,",
                                                      0,
                                                      0
                                                    }),
                                                  --[[ Formatting_gen ]]Block.__(18, {
                                                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                            --[[ String_literal ]]Block.__(11, {
                                                                "<1>",
                                                                --[[ End_of_format ]]0
                                                              }),
                                                            "<1>"
                                                          }}),
                                                      --[[ String_literal ]]Block.__(11, {
                                                          "ref",
                                                          --[[ Theta ]]Block.__(16, {--[[ Formatting_lit ]]Block.__(17, {
                                                                  --[[ Close_box ]]0,
                                                                  --[[ Char_literal ]]Block.__(12, {
                                                                      --[[ ")" ]]41,
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Close_box ]]0,
                                                                          --[[ End_of_format ]]0
                                                                        })
                                                                    })
                                                                })})
                                                        })
                                                    })
                                                })
                                            })})
                                    })
                                })
                            }),
                          "@[<hov1>Tobject(@,%a,@,@[<1>ref%t@])@]"
                        }), raw_type, param[0], (function (ppf) do
                        match = nm.contents;
                        if (match ~= undefined) then do
                          match$1 = match;
                          return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "(Some(",
                                              --[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Break ]]Block.__(0, {
                                                      "@,",
                                                      0,
                                                      0
                                                    }),
                                                  --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                          --[[ "," ]]44,
                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Break ]]Block.__(0, {
                                                                  "@,",
                                                                  0,
                                                                  0
                                                                }),
                                                              --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                                                      "))",
                                                                      --[[ End_of_format ]]0
                                                                    })})
                                                            })
                                                        })})
                                                })
                                            }),
                                          "(Some(@,%a,@,%a))"
                                        }), path, match$1[0], raw_type_list, match$1[1]);
                        end else do
                          return Format.fprintf(ppf, --[[ Format ]]{
                                      --[[ String_literal ]]Block.__(11, {
                                          " None",
                                          --[[ End_of_format ]]0
                                        }),
                                      " None"
                                    });
                        end end 
                      end end));end end end 
       if ___conditional___ = 5--[[ Tfield ]] then do
          return Curry._6(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hov1>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hov1>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "Tfield(",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@,",
                                          0,
                                          0
                                        }),
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ Char_literal ]]Block.__(12, {
                                              --[[ "," ]]44,
                                              --[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Break ]]Block.__(0, {
                                                      "@,",
                                                      0,
                                                      0
                                                    }),
                                                  --[[ String ]]Block.__(2, {
                                                      --[[ No_padding ]]0,
                                                      --[[ Char_literal ]]Block.__(12, {
                                                          --[[ "," ]]44,
                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Break ]]Block.__(0, {
                                                                  "@,",
                                                                  0,
                                                                  0
                                                                }),
                                                              --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                                      --[[ "," ]]44,
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@;<0 -1>",
                                                                              0,
                                                                              -1
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                                                  --[[ ")" ]]41,
                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Close_box ]]0,
                                                                                      --[[ End_of_format ]]0
                                                                                    })
                                                                                })})
                                                                        })
                                                                    })})
                                                            })
                                                        })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[<hov1>Tfield(@,%s,@,%s,@,%a,@;<0 -1>%a)@]"
                        }), param[0], safe_kind_repr(--[[ [] ]]0, param[1]), raw_type, param[2], raw_type, param[3]);end end end 
       if ___conditional___ = 6--[[ Tlink ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<1>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<1>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "Tlink",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@,",
                                          0,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Close_box ]]0,
                                              --[[ End_of_format ]]0
                                            })})
                                    })
                                })
                            }),
                          "@[<1>Tlink@,%a@]"
                        }), raw_type, param[0]);end end end 
       if ___conditional___ = 7--[[ Tsubst ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<1>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<1>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "Tsubst",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@,",
                                          0,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Close_box ]]0,
                                              --[[ End_of_format ]]0
                                            })})
                                    })
                                })
                            }),
                          "@[<1>Tsubst@,%a@]"
                        }), raw_type, param[0]);end end end 
       if ___conditional___ = 8--[[ Tvariant ]] then do
          row = param[0];
          return Curry.app(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hov1>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hov1>"
                                  }}),
                              --[[ Char_literal ]]Block.__(12, {
                                  --[[ "{" ]]123,
                                  --[[ Formatting_gen ]]Block.__(18, {
                                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                            --[[ End_of_format ]]0,
                                            ""
                                          }}),
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@,",
                                                  0,
                                                  0
                                                }),
                                              --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                      --[[ ";" ]]59,
                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                          --[[ Close_box ]]0,
                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Break ]]Block.__(0, {
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                }),
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String ]]Block.__(2, {
                                                                      --[[ No_padding ]]0,
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@,",
                                                                              0,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                                                  --[[ ";" ]]59,
                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Close_box ]]0,
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Break ]]Block.__(0, {
                                                                                              "@ ",
                                                                                              1,
                                                                                              0
                                                                                            }),
                                                                                          --[[ String ]]Block.__(2, {
                                                                                              --[[ No_padding ]]0,
                                                                                              --[[ Bool ]]Block.__(9, {
                                                                                                  --[[ No_padding ]]0,
                                                                                                  --[[ Char_literal ]]Block.__(12, {
                                                                                                      --[[ ";" ]]59,
                                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                                          --[[ Break ]]Block.__(0, {
                                                                                                              "@ ",
                                                                                                              1,
                                                                                                              0
                                                                                                            }),
                                                                                                          --[[ String ]]Block.__(2, {
                                                                                                              --[[ No_padding ]]0,
                                                                                                              --[[ Bool ]]Block.__(9, {
                                                                                                                  --[[ No_padding ]]0,
                                                                                                                  --[[ Char_literal ]]Block.__(12, {
                                                                                                                      --[[ ";" ]]59,
                                                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                                                          --[[ Break ]]Block.__(0, {
                                                                                                                              "@ ",
                                                                                                                              1,
                                                                                                                              0
                                                                                                                            }),
                                                                                                                          --[[ Formatting_gen ]]Block.__(18, {
                                                                                                                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                                                                                    --[[ String_literal ]]Block.__(11, {
                                                                                                                                        "<1>",
                                                                                                                                        --[[ End_of_format ]]0
                                                                                                                                      }),
                                                                                                                                    "<1>"
                                                                                                                                  }}),
                                                                                                                              --[[ String ]]Block.__(2, {
                                                                                                                                  --[[ No_padding ]]0,
                                                                                                                                  --[[ Theta ]]Block.__(16, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                                                          --[[ Close_box ]]0,
                                                                                                                                          --[[ Char_literal ]]Block.__(12, {
                                                                                                                                              --[[ "}" ]]125,
                                                                                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                                                                                  --[[ Close_box ]]0,
                                                                                                                                                  --[[ End_of_format ]]0
                                                                                                                                                })
                                                                                                                                            })
                                                                                                                                        })})
                                                                                                                                })
                                                                                                                            })
                                                                                                                        })
                                                                                                                    })
                                                                                                                })
                                                                                                            })
                                                                                                        })
                                                                                                    })
                                                                                                })
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })})
                                                                        })
                                                                    })
                                                                })
                                                            })
                                                        })
                                                    })})
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[<hov1>{@[%s@,%a;@]@ @[%s@,%a;@]@ %s%b;@ %s%b;@ @[<1>%s%t@]}@]"
                        }), {
                      "row_fields=",
                      (function (param, param$1) do
                          return raw_list((function (ppf, param) do
                                        return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                                                        --[[ Formatting_gen ]]Block.__(18, {
                                                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                  --[[ End_of_format ]]0,
                                                                  ""
                                                                }}),
                                                            --[[ String ]]Block.__(2, {
                                                                --[[ No_padding ]]0,
                                                                --[[ Char_literal ]]Block.__(12, {
                                                                    --[[ "," ]]44,
                                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                                        --[[ Break ]]Block.__(0, {
                                                                            "@ ",
                                                                            1,
                                                                            0
                                                                          }),
                                                                        --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                --[[ Close_box ]]0,
                                                                                --[[ End_of_format ]]0
                                                                              })})
                                                                      })
                                                                  })
                                                              })
                                                          }),
                                                        "@[%s,@ %a@]"
                                                      }), param[0], raw_field, param[1]);
                                      end end), param, param$1);
                        end end),
                      row.row_fields,
                      "row_more=",
                      raw_type,
                      row.row_more,
                      "row_closed=",
                      row.row_closed,
                      "row_fixed=",
                      row.row_fixed,
                      "row_name=",
                      (function (ppf) do
                          match = row.row_name;
                          if (match ~= undefined) then do
                            match$1 = match;
                            return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                                            --[[ String_literal ]]Block.__(11, {
                                                "Some(",
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@,",
                                                        0,
                                                        0
                                                      }),
                                                    --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                            --[[ "," ]]44,
                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                --[[ Break ]]Block.__(0, {
                                                                    "@,",
                                                                    0,
                                                                    0
                                                                  }),
                                                                --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                                        --[[ ")" ]]41,
                                                                        --[[ End_of_format ]]0
                                                                      })})
                                                              })
                                                          })})
                                                  })
                                              }),
                                            "Some(@,%a,@,%a)"
                                          }), path, match$1[0], raw_type_list, match$1[1]);
                          end else do
                            return Format.fprintf(ppf, --[[ Format ]]{
                                        --[[ String_literal ]]Block.__(11, {
                                            "None",
                                            --[[ End_of_format ]]0
                                          }),
                                        "None"
                                      });
                          end end 
                        end end)
                    });end end end 
       if ___conditional___ = 9--[[ Tunivar ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "Tunivar ",
                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                            }),
                          "Tunivar %a"
                        }), print_name, param[0]);end end end 
       if ___conditional___ = 10--[[ Tpoly ]] then do
          return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hov1>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hov1>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "Tpoly(",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@,",
                                          0,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                              --[[ "," ]]44,
                                              --[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Break ]]Block.__(0, {
                                                      "@,",
                                                      0,
                                                      0
                                                    }),
                                                  --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                          --[[ ")" ]]41,
                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Close_box ]]0,
                                                              --[[ End_of_format ]]0
                                                            })
                                                        })})
                                                })
                                            })})
                                    })
                                })
                            }),
                          "@[<hov1>Tpoly(@,%a,@,%a)@]"
                        }), raw_type, param[0], raw_type_list, param[1]);end end end 
       if ___conditional___ = 11--[[ Tpackage ]] then do
          return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hov1>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hov1>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "Tpackage(",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@,",
                                          0,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@,",
                                                  0,
                                                  0
                                                }),
                                              --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                      --[[ ")" ]]41,
                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                          --[[ Close_box ]]0,
                                                          --[[ End_of_format ]]0
                                                        })
                                                    })})
                                            })})
                                    })
                                })
                            }),
                          "@[<hov1>Tpackage(@,%a@,%a)@]"
                        }), path, param[0], raw_type_list, param[2]);end end end 
       do
      
    end
  end end 
end end

function raw_field(ppf, param) do
  if (typeof param == "number") then do
    return Format.fprintf(ppf, --[[ Format ]]{
                --[[ String_literal ]]Block.__(11, {
                    "Rabsent",
                    --[[ End_of_format ]]0
                  }),
                "Rabsent"
              });
  end else if (param.tag) then do
    e = param[3];
    return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<hov1>",
                                  --[[ End_of_format ]]0
                                }),
                              "<hov1>"
                            }}),
                        --[[ String_literal ]]Block.__(11, {
                            "Reither(",
                            --[[ Bool ]]Block.__(9, {
                                --[[ No_padding ]]0,
                                --[[ Char_literal ]]Block.__(12, {
                                    --[[ "," ]]44,
                                    --[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Break ]]Block.__(0, {
                                            "@,",
                                            0,
                                            0
                                          }),
                                        --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                --[[ "," ]]44,
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@,",
                                                        0,
                                                        0
                                                      }),
                                                    --[[ Bool ]]Block.__(9, {
                                                        --[[ No_padding ]]0,
                                                        --[[ Char_literal ]]Block.__(12, {
                                                            --[[ "," ]]44,
                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                --[[ Break ]]Block.__(0, {
                                                                    "@,",
                                                                    0,
                                                                    0
                                                                  }),
                                                                --[[ Formatting_gen ]]Block.__(18, {
                                                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                          --[[ String_literal ]]Block.__(11, {
                                                                              "<1>",
                                                                              --[[ End_of_format ]]0
                                                                            }),
                                                                          "<1>"
                                                                        }}),
                                                                    --[[ String_literal ]]Block.__(11, {
                                                                        "ref",
                                                                        --[[ Theta ]]Block.__(16, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                --[[ Close_box ]]0,
                                                                                --[[ Char_literal ]]Block.__(12, {
                                                                                    --[[ ")" ]]41,
                                                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                                                        --[[ Close_box ]]0,
                                                                                        --[[ End_of_format ]]0
                                                                                      })
                                                                                  })
                                                                              })})
                                                                      })
                                                                  })
                                                              })
                                                          })
                                                      })
                                                  })
                                              })})
                                      })
                                  })
                              })
                          })
                      }),
                    "@[<hov1>Reither(%b,@,%a,@,%b,@,@[<1>ref%t@])@]"
                  }), param[0], raw_type_list, param[1], param[2], (function (ppf) do
                  match = e.contents;
                  if (match ~= undefined) then do
                    return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                    --[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Break ]]Block.__(0, {
                                            "@,",
                                            0,
                                            0
                                          }),
                                        --[[ Formatting_gen ]]Block.__(18, {
                                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                  --[[ String_literal ]]Block.__(11, {
                                                      "<1>",
                                                      --[[ End_of_format ]]0
                                                    }),
                                                  "<1>"
                                                }}),
                                            --[[ Char_literal ]]Block.__(12, {
                                                --[[ "(" ]]40,
                                                --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                        --[[ ")" ]]41,
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Close_box ]]0,
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })})
                                              })
                                          })
                                      }),
                                    "@,@[<1>(%a)@]"
                                  }), raw_field, match);
                  end else do
                    return Format.fprintf(ppf, --[[ Format ]]{
                                --[[ String_literal ]]Block.__(11, {
                                    " None",
                                    --[[ End_of_format ]]0
                                  }),
                                " None"
                              });
                  end end 
                end end));
  end else do
    match = param[0];
    if (match ~= undefined) then do
      return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Formatting_gen ]]Block.__(18, {
                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                --[[ String_literal ]]Block.__(11, {
                                    "<1>",
                                    --[[ End_of_format ]]0
                                  }),
                                "<1>"
                              }}),
                          --[[ String_literal ]]Block.__(11, {
                              "Rpresent(Some",
                              --[[ Formatting_lit ]]Block.__(17, {
                                  --[[ Break ]]Block.__(0, {
                                      "@,",
                                      0,
                                      0
                                    }),
                                  --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                          --[[ ")" ]]41,
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Close_box ]]0,
                                              --[[ End_of_format ]]0
                                            })
                                        })})
                                })
                            })
                        }),
                      "@[<1>Rpresent(Some@,%a)@]"
                    }), raw_type, match);
    end else do
      return Format.fprintf(ppf, --[[ Format ]]{
                  --[[ String_literal ]]Block.__(11, {
                      "Rpresent None",
                      --[[ End_of_format ]]0
                    }),
                  "Rpresent None"
                });
    end end 
  end end  end 
end end

function raw_type_expr(ppf, t) do
  visited.contents = --[[ [] ]]0;
  raw_type(ppf, t);
  visited.contents = --[[ [] ]]0;
  return --[[ () ]]0;
end end

print_raw = raw_type_expr;

function is_nth(param) do
  if (typeof param == "number" or param.tag) then do
    return false;
  end else do
    return true;
  end end 
end end

function compose(l1, param) do
  if (typeof param == "number") then do
    return --[[ Map ]]Block.__(1, {l1});
  end else if (param.tag) then do
    return --[[ Map ]]Block.__(1, {List.map((function (param) do
                      return List.nth(l1, param);
                    end end), param[0])});
  end else do
    return --[[ Nth ]]Block.__(0, {List.nth(l1, param[0])});
  end end  end 
end end

function apply_subst(s1, tyl) do
  if (typeof s1 == "number") then do
    return tyl;
  end else if (s1.tag) then do
    return List.map((function (param) do
                  return List.nth(tyl, param);
                end end), s1[0]);
  end else do
    return --[[ :: ]]{
            List.nth(tyl, s1[0]),
            --[[ [] ]]0
          };
  end end  end 
end end

printing_env = do
  contents: empty
end;

printing_depth = do
  contents: 0
end;

printing_cont = do
  contents: --[[ [] ]]0
end;

printing_old = do
  contents: empty
end;

printing_pers = do
  contents: --[[ Empty ]]0
end;

function compare$2(_p1, _p2) do
  while(true) do
    p2 = _p2;
    p1 = _p1;
    local ___conditional___=(p1.tag | 0);
    do
       if ___conditional___ = 0--[[ Pident ]] then do
          return Caml_obj.caml_compare(p1, p2);end end end 
       if ___conditional___ = 1--[[ Pdot ]] then do
          local ___conditional___=(p2.tag | 0);
          do
             if ___conditional___ = 1--[[ Pdot ]] then do
                c = compare$2(p1[0], p2[0]);
                if (c ~= 0) then do
                  return c;
                end else do
                  return Caml_primitive.caml_string_compare(p1[1], p2[1]);
                end end end end end 
             if ___conditional___ = 0--[[ Pident ]]
             or ___conditional___ = 2--[[ Papply ]] then do
                return Caml_obj.caml_compare(p1, p2);end end end 
             do
            
          endend end end 
       if ___conditional___ = 2--[[ Papply ]] then do
          local ___conditional___=(p2.tag | 0);
          do
             if ___conditional___ = 0--[[ Pident ]]
             or ___conditional___ = 1--[[ Pdot ]] then do
                return Caml_obj.caml_compare(p1, p2);end end end 
             if ___conditional___ = 2--[[ Papply ]] then do
                c$1 = compare$2(p1[0], p2[0]);
                if (c$1 ~= 0) then do
                  return c$1;
                end else do
                  _p2 = p2[1];
                  _p1 = p1[1];
                  continue ;
                end end end end end 
             do
            
          endend end end 
       do
      
    end
  end;
end end

function height$6(param) do
  if (param) then do
    return param[--[[ h ]]4];
  end else do
    return 0;
  end end 
end end

function create$7(l, x, d, r) do
  hl = height$6(l);
  hr = height$6(r);
  return --[[ Node ]]{
          --[[ l ]]l,
          --[[ v ]]x,
          --[[ d ]]d,
          --[[ r ]]r,
          --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
        };
end end

function bal$6(l, x, d, r) do
  hl = l and l[--[[ h ]]4] or 0;
  hr = r and r[--[[ h ]]4] or 0;
  if (hl > (hr + 2 | 0)) then do
    if (l) then do
      lr = l[--[[ r ]]3];
      ld = l[--[[ d ]]2];
      lv = l[--[[ v ]]1];
      ll = l[--[[ l ]]0];
      if (height$6(ll) >= height$6(lr)) then do
        return create$7(ll, lv, ld, create$7(lr, x, d, r));
      end else if (lr) then do
        return create$7(create$7(ll, lv, ld, lr[--[[ l ]]0]), lr[--[[ v ]]1], lr[--[[ d ]]2], create$7(lr[--[[ r ]]3], x, d, r));
      end else do
        throw {
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            };
      end end  end 
    end else do
      throw {
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          };
    end end 
  end else if (hr > (hl + 2 | 0)) then do
    if (r) then do
      rr = r[--[[ r ]]3];
      rd = r[--[[ d ]]2];
      rv = r[--[[ v ]]1];
      rl = r[--[[ l ]]0];
      if (height$6(rr) >= height$6(rl)) then do
        return create$7(create$7(l, x, d, rl), rv, rd, rr);
      end else if (rl) then do
        return create$7(create$7(l, x, d, rl[--[[ l ]]0]), rl[--[[ v ]]1], rl[--[[ d ]]2], create$7(rl[--[[ r ]]3], rv, rd, rr));
      end else do
        throw {
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            };
      end end  end 
    end else do
      throw {
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          };
    end end 
  end else do
    return --[[ Node ]]{
            --[[ l ]]l,
            --[[ v ]]x,
            --[[ d ]]d,
            --[[ r ]]r,
            --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
          };
  end end  end 
end end

function add$8(x, data, m) do
  if (m) then do
    r = m[--[[ r ]]3];
    d = m[--[[ d ]]2];
    v = m[--[[ v ]]1];
    l = m[--[[ l ]]0];
    c = compare$2(x, v);
    if (c == 0) then do
      if (d == data) then do
        return m;
      end else do
        return --[[ Node ]]{
                --[[ l ]]l,
                --[[ v ]]x,
                --[[ d ]]data,
                --[[ r ]]r,
                --[[ h ]]m[--[[ h ]]4]
              };
      end end 
    end else if (c < 0) then do
      ll = add$8(x, data, l);
      if (l == ll) then do
        return m;
      end else do
        return bal$6(ll, v, d, r);
      end end 
    end else do
      rr = add$8(x, data, r);
      if (r == rr) then do
        return m;
      end else do
        return bal$6(l, v, d, rr);
      end end 
    end end  end 
  end else do
    return --[[ Node ]]{
            --[[ l : Empty ]]0,
            --[[ v ]]x,
            --[[ d ]]data,
            --[[ r : Empty ]]0,
            --[[ h ]]1
          };
  end end 
end end

function find$4(x, _param) do
  while(true) do
    param = _param;
    if (param) then do
      c = compare$2(x, param[--[[ v ]]1]);
      if (c == 0) then do
        return param[--[[ d ]]2];
      end else do
        _param = c < 0 and param[--[[ l ]]0] or param[--[[ r ]]3];
        continue ;
      end end 
    end else do
      throw Caml_builtin_exceptions.not_found;
    end end 
  end;
end end

printing_map = do
  contents: --[[ Empty ]]0
end;

function same_type(t, t$prime) do
  return repr(t) == repr(t$prime);
end end

function index(l, x) do
  if (l) then do
    if (x == l[0]) then do
      return 0;
    end else do
      return 1 + index(l[1], x) | 0;
    end end 
  end else do
    throw Caml_builtin_exceptions.not_found;
  end end 
end end

function uniq(_param) do
  while(true) do
    param = _param;
    if (param) then do
      l = param[1];
      if (List.memq(param[0], l)) then do
        return false;
      end else do
        _param = l;
        continue ;
      end end 
    end else do
      return true;
    end end 
  end;
end end

function normalize_type_path(cacheOpt, env, p) do
  cache = cacheOpt ~= undefined and cacheOpt or false;
  try do
    match = find_type_expansion(p, env);
    params = List.map(repr, match[0]);
    ty = repr(match[1]);
    match$1 = ty.desc;
    if (typeof match$1 == "number" or match$1.tag ~= --[[ Tconstr ]]3) then do
      return --[[ tuple ]]{
              p,
              --[[ Nth ]]Block.__(0, {index(params, ty)})
            };
    end else do
      p1 = match$1[0];
      tyl = List.map(repr, match$1[1]);
      if (List.length(params) == List.length(tyl) and List.for_all2((function (prim, prim$1) do
                return prim == prim$1;
              end end), params, tyl)) then do
        return normalize_type_path(cache, env, p1);
      end else if (cache or List.length(params) <= List.length(tyl) or not uniq(tyl)) then do
        return --[[ tuple ]]{
                p,
                --[[ Id ]]0
              };
      end else do
        l1 = List.map((function (param) do
                return index(params, param);
              end end), tyl);
        match$2 = normalize_type_path(cache, env, p1);
        return --[[ tuple ]]{
                match$2[0],
                compose(l1, match$2[1])
              };
      end end  end 
    end end 
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return --[[ tuple ]]{
              p,
              --[[ Id ]]0
            };
    end else do
      throw exn;
    end end 
  end
end end

function path_size(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Pident ]] then do
        id = param[0];
        s = id.name;
        return --[[ tuple ]]{
                s ~= "" and Caml_string.get(s, 0) == --[[ "_" ]]95 and 10 or 1,
                -id.stamp | 0
              };end end end 
     if ___conditional___ = 1--[[ Pdot ]] then do
        match = path_size(param[0]);
        return --[[ tuple ]]{
                1 + match[0] | 0,
                match[1]
              };end end end 
     if ___conditional___ = 2--[[ Papply ]] then do
        match$1 = path_size(param[0]);
        return --[[ tuple ]]{
                match$1[0] + path_size(param[1])[0] | 0,
                match$1[1]
              };end end end 
     do
    
  end
end end

function same_printing_env(env) do
  used_pers = used_persistent(--[[ () ]]0);
  if (same_types(printing_old.contents, env)) then do
    return equal$2(printing_pers.contents, used_pers);
  end else do
    return false;
  end end 
end end

function set_printing_env(env) do
  printing_env.contents = real_paths.contents and empty or env;
  if (printing_env.contents == empty or same_printing_env(env)) then do
    return --[[ () ]]0;
  end else do
    printing_old.contents = env;
    printing_pers.contents = used_persistent(--[[ () ]]0);
    printing_map.contents = --[[ Empty ]]0;
    printing_depth.contents = 0;
    partial_arg = iter_types((function (p, param) do
            match = normalize_type_path(true, env, param[0]);
            if (match[1] == --[[ Id ]]0) then do
              p1 = match[0];
              try do
                r = find$4(p1, printing_map.contents);
                match$1 = r.contents;
                if (match$1.tag) then do
                  r.contents = --[[ Paths ]]Block.__(0, {--[[ :: ]]{
                        p,
                        --[[ :: ]]{
                          match$1[0],
                          --[[ [] ]]0
                        }
                      }});
                  return --[[ () ]]0;
                end else do
                  r.contents = --[[ Paths ]]Block.__(0, {--[[ :: ]]{
                        p,
                        match$1[0]
                      }});
                  return --[[ () ]]0;
                end end 
              end
              catch (exn)do
                if (exn == Caml_builtin_exceptions.not_found) then do
                  printing_map.contents = add$8(p1, do
                        contents: --[[ Paths ]]Block.__(0, {--[[ :: ]]{
                              p,
                              --[[ [] ]]0
                            }})
                      end, printing_map.contents);
                  return --[[ () ]]0;
                end else do
                  throw exn;
                end end 
              end
            end else do
              return 0;
            end end 
          end end));
    cont = function (param) do
      return partial_arg(env, param);
    end end;
    printing_cont.contents = --[[ :: ]]{
      cont,
      --[[ [] ]]0
    };
    return --[[ () ]]0;
  end end 
end end

function wrap_printing_env(env, f) do
  set_printing_env(env);
  return try_finally(f, (function (param) do
                return set_printing_env(empty);
              end end));
end end

function is_unambiguous(path, env) do
  l = find_shadowed_types(path, env);
  if (List.exists((function (param) do
            return same(path, param);
          end end), l) or not l) then do
    return true;
  end else do
    rem = l[1];
    p = l[0];
    normalize = function (p) do
      return normalize_type_path(true, env, p)[0];
    end end;
    p$prime = normalize(p);
    if (List.for_all((function (p) do
              return same(normalize(p), p$prime);
            end end), rem)) then do
      return true;
    end else do
      id = lid_of_path(undefined, p);
      if (List.for_all((function (p) do
                return Caml_obj.caml_equal(lid_of_path(undefined, p), id);
              end end), rem)) then do
        return same(p, lookup_type$1(id, env)[0]);
      end else do
        return false;
      end end 
    end end 
  end end 
end end

function best_type_path(p) do
  if (real_paths.contents or printing_env.contents == empty) then do
    return --[[ tuple ]]{
            p,
            --[[ Id ]]0
          };
  end else do
    match = normalize_type_path(undefined, printing_env.contents, p);
    p$prime = match[0];
    get_path = function (param) do
      r = find$4(p$prime, printing_map.contents);
      while(true) do
        match = r.contents;
        if (match.tag) then do
          return match[0];
        end else do
          l = match[0];
          if (l) then do
            r.contents = --[[ Paths ]]Block.__(0, {--[[ [] ]]0});
            List.iter((function (p) do
                    match = r.contents;
                    if (match.tag and Caml_obj.caml_greaterequal(path_size(p), path_size(match[0]))) then do
                      return --[[ () ]]0;
                    end
                     end 
                    if (is_unambiguous(p, printing_env.contents)) then do
                      r.contents = --[[ Best ]]Block.__(1, {p});
                      return --[[ () ]]0;
                    end else do
                      return 0;
                    end end 
                  end end), l);
            continue ;
          end else do
            throw Caml_builtin_exceptions.not_found;
          end end 
        end end 
      end;
    end end;
    while((function () do
            tmp = false;
            if (printing_cont.contents ~= --[[ [] ]]0) then do
              tmp$1;
              try do
                get_path(--[[ () ]]0);
                tmp$1 = false;
              end
              catch (exn)do
                if (exn == Caml_builtin_exceptions.not_found) then do
                  tmp$1 = true;
                end else do
                  throw exn;
                end end 
              end
              tmp = tmp$1;
            end
             end 
            return tmp;
          end end)()) do
      printing_cont.contents = List.map((function (prim) do
              return prim[1];
            end end), run_iter_cont(printing_cont.contents));
      printing_depth.contents = printing_depth.contents + 1 | 0;
    end;
    p$prime$prime;
    try do
      p$prime$prime = get_path(--[[ () ]]0);
    end
    catch (exn)do
      if (exn == Caml_builtin_exceptions.not_found) then do
        p$prime$prime = p$prime;
      end else do
        throw exn;
      end end 
    end
    return --[[ tuple ]]{
            p$prime$prime,
            match[1]
          };
  end end 
end end

names = do
  contents: --[[ [] ]]0
end;

name_counter = do
  contents: 0
end;

named_vars = do
  contents: --[[ [] ]]0
end;

function reset_names(param) do
  names.contents = --[[ [] ]]0;
  name_counter.contents = 0;
  named_vars.contents = --[[ [] ]]0;
  return --[[ () ]]0;
end end

function add_named_var(ty) do
  match = ty.desc;
  if (typeof match == "number") then do
    return --[[ () ]]0;
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 0--[[ Tvar ]]
       or ___conditional___ = 9--[[ Tunivar ]]
       do end
      else do
        return --[[ () ]]0;
        end end
        
    end
  end end 
  match$1 = match[0];
  if (match$1 ~= undefined) then do
    name = match$1;
    if (List.mem(name, named_vars.contents)) then do
      return --[[ () ]]0;
    end else do
      named_vars.contents = --[[ :: ]]{
        name,
        named_vars.contents
      };
      return --[[ () ]]0;
    end end 
  end else do
    return --[[ () ]]0;
  end end 
end end

function new_name(_param) do
  while(true) do
    name;
    if (name_counter.contents < 26) then do
      c = Char.chr(97 + name_counter.contents | 0);
      name = Caml_bytes.bytes_to_string(Bytes.make(1, c));
    end else do
      c$1 = Char.chr(97 + name_counter.contents % 26 | 0);
      name = Caml_bytes.bytes_to_string(Bytes.make(1, c$1)) .. String(name_counter.contents / 26 | 0);
    end end 
    name_counter.contents = name_counter.contents + 1 | 0;
    if (List.mem(name, named_vars.contents) or List.exists((function(name)do
          return function (param) do
            return name == param[1];
          end end
          end(name)), names.contents)) then do
      _param = --[[ () ]]0;
      continue ;
    end else do
      return name;
    end end 
  end;
end end

function name_of_type(t) do
  try do
    return List.assq(t, names.contents);
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      match = t.desc;
      name;
      exit = 0;
      if (typeof match == "number") then do
        name = new_name(--[[ () ]]0);
      end else do
        local ___conditional___=(match.tag | 0);
        do
           if ___conditional___ = 0--[[ Tvar ]]
           or ___conditional___ = 9--[[ Tunivar ]] then do
              exit = 1;end else 
           do end end
          else do
            name = new_name(--[[ () ]]0);
            end end
            
        end
      end end 
      if (exit == 1) then do
        match$1 = match[0];
        if (match$1 ~= undefined) then do
          name$1 = match$1;
          current_name = do
            contents: name$1
          end;
          i = 0;
          while(List.exists((function (param) do
                    return current_name.contents == param[1];
                  end end), names.contents)) do
            current_name.contents = name$1 .. String(i);
            i = i + 1 | 0;
          end;
          name = current_name.contents;
        end else do
          name = new_name(--[[ () ]]0);
        end end 
      end
       end 
      if (name ~= "_") then do
        names.contents = --[[ :: ]]{
          --[[ tuple ]]{
            t,
            name
          },
          names.contents
        };
      end
       end 
      return name;
    end else do
      throw exn;
    end end 
  end
end end

function check_name_of_type(t) do
  name_of_type(t);
  return --[[ () ]]0;
end end

function remove_names(tyl) do
  tyl$1 = List.map(repr, tyl);
  names.contents = List.filter((function (param) do
            return not List.memq(param[0], tyl$1);
          end end))(names.contents);
  return --[[ () ]]0;
end end

visited_objects = do
  contents: --[[ [] ]]0
end;

aliased = do
  contents: --[[ [] ]]0
end;

delayed = do
  contents: --[[ [] ]]0
end;

function add_delayed(t) do
  if (List.memq(t, delayed.contents)) then do
    return 0;
  end else do
    delayed.contents = --[[ :: ]]{
      t,
      delayed.contents
    };
    return --[[ () ]]0;
  end end 
end end

function is_aliased(ty) do
  return List.memq(proxy(ty), aliased.contents);
end end

function add_alias(ty) do
  px = proxy(ty);
  if (is_aliased(px)) then do
    return 0;
  end else do
    aliased.contents = --[[ :: ]]{
      px,
      aliased.contents
    };
    return add_named_var(px);
  end end 
end end

function aliasable(ty) do
  match = ty.desc;
  if (typeof match == "number") then do
    return true;
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 3--[[ Tconstr ]] then do
          return not is_nth(best_type_path(match[0])[1]);end end end 
       if ___conditional___ = 0--[[ Tvar ]]
       or ___conditional___ = 9--[[ Tunivar ]]
       or ___conditional___ = 10--[[ Tpoly ]] then do
          return false;end end end 
       do
      else do
        return true;
        end end
        
    end
  end end 
end end

function namable_row(row) do
  if (row.row_name ~= undefined) then do
    return List.for_all((function (param) do
                  match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                  if (typeof match == "number" or not match.tag) then do
                    return true;
                  end else do
                    l = match[1];
                    if (row.row_closed) then do
                      if (match[0]) then do
                        return l == --[[ [] ]]0;
                      end else do
                        return List.length(l) == 1;
                      end end 
                    end else do
                      return false;
                    end end 
                  end end 
                end end), row.row_fields);
  end else do
    return false;
  end end 
end end

function mark_loops_rec(_visited, _ty) do
  while(true) do
    ty = _ty;
    visited = _visited;
    ty$1 = repr(ty);
    px = proxy(ty$1);
    if (List.memq(px, visited) and aliasable(ty$1)) then do
      return add_alias(px);
    end else do
      visited$1 = --[[ :: ]]{
        px,
        visited
      };
      match = ty$1.desc;
      if (typeof match == "number") then do
        return --[[ () ]]0;
      end else do
        local ___conditional___=(match.tag | 0);
        do
           if ___conditional___ = 1--[[ Tarrow ]] then do
              mark_loops_rec(visited$1, match[1]);
              _ty = match[2];
              _visited = visited$1;
              continue ;end end end 
           if ___conditional___ = 2--[[ Ttuple ]] then do
              return List.iter((function(visited$1)do
                        return function (param) do
                          return mark_loops_rec(visited$1, param);
                        end end
                        end(visited$1)), match[0]);end end end 
           if ___conditional___ = 3--[[ Tconstr ]] then do
              match$1 = best_type_path(match[0]);
              return List.iter((function(visited$1)do
                        return function (param) do
                          return mark_loops_rec(visited$1, param);
                        end end
                        end(visited$1)), apply_subst(match$1[1], match[1]));end end end 
           if ___conditional___ = 4--[[ Tobject ]] then do
              if (List.memq(px, visited_objects.contents)) then do
                return add_alias(px);
              end else do
                if (opened_object(ty$1)) then do
                  visited_objects.contents = --[[ :: ]]{
                    px,
                    visited_objects.contents
                  };
                end
                 end 
                match$2 = match[1].contents;
                if (match$2 ~= undefined) then do
                  return List.iter((function(visited$1)do
                            return function (param) do
                              return mark_loops_rec(visited$1, param);
                            end end
                            end(visited$1)), List.tl(match$2[1]));
                end else do
                  match$3 = flatten_fields(match[0]);
                  return List.iter((function(visited$1)do
                            return function (param) do
                              if (field_kind_repr(param[1]) == --[[ Fpresent ]]0) then do
                                return mark_loops_rec(visited$1, param[2]);
                              end else do
                                return 0;
                              end end 
                            end end
                            end(visited$1)), match$3[0]);
                end end 
              end end end end end 
           if ___conditional___ = 5--[[ Tfield ]] then do
              ty2 = match[3];
              if (field_kind_repr(match[1]) == --[[ Fpresent ]]0) then do
                mark_loops_rec(visited$1, match[2]);
                _ty = ty2;
                _visited = visited$1;
                continue ;
              end else do
                _ty = ty2;
                _visited = visited$1;
                continue ;
              end end end end end 
           if ___conditional___ = 6--[[ Tlink ]] then do
              return fatal_error("Printtyp.mark_loops_rec (2)");end end end 
           if ___conditional___ = 7--[[ Tsubst ]] then do
              _ty = match[0];
              _visited = visited$1;
              continue ;end end end 
           if ___conditional___ = 8--[[ Tvariant ]] then do
              if (List.memq(px, visited_objects.contents)) then do
                return add_alias(px);
              end else do
                row = row_repr_aux(--[[ [] ]]0, match[0]);
                if (not static_row(row)) then do
                  visited_objects.contents = --[[ :: ]]{
                    px,
                    visited_objects.contents
                  };
                end
                 end 
                match$4 = row.row_name;
                if (match$4 ~= undefined) then do
                  if (namable_row(row)) then do
                    return List.iter((function(visited$1)do
                              return function (param) do
                                return mark_loops_rec(visited$1, param);
                              end end
                              end(visited$1)), match$4[1]);
                  end else do
                    return iter_row((function(visited$1)do
                              return function (param) do
                                return mark_loops_rec(visited$1, param);
                              end end
                              end(visited$1)), row);
                  end end 
                end else do
                  return iter_row((function(visited$1)do
                            return function (param) do
                              return mark_loops_rec(visited$1, param);
                            end end
                            end(visited$1)), row);
                end end 
              end end end end end 
           if ___conditional___ = 0--[[ Tvar ]]
           or ___conditional___ = 9--[[ Tunivar ]] then do
              return add_named_var(ty$1);end end end 
           if ___conditional___ = 10--[[ Tpoly ]] then do
              List.iter(add_alias, match[1]);
              _ty = match[0];
              _visited = visited$1;
              continue ;end end end 
           if ___conditional___ = 11--[[ Tpackage ]] then do
              return List.iter((function(visited$1)do
                        return function (param) do
                          return mark_loops_rec(visited$1, param);
                        end end
                        end(visited$1)), match[2]);end end end 
           do
          
        end
      end end 
    end end 
  end;
end end

function mark_loops(ty) do
  normalize_type(empty, ty);
  return mark_loops_rec(--[[ [] ]]0, ty);
end end

function reset(param) do
  unique_names.contents = --[[ Empty ]]0;
  reset_names(--[[ () ]]0);
  visited_objects.contents = --[[ [] ]]0;
  aliased.contents = --[[ [] ]]0;
  delayed.contents = --[[ [] ]]0;
  return --[[ () ]]0;
end end

function reset_and_mark_loops_list(tyl) do
  reset(--[[ () ]]0);
  return List.iter(mark_loops, tyl);
end end

print_labels = do
  contents: true
end;

function tree_of_typexp(sch, ty) do
  ty$1 = repr(ty);
  px = proxy(ty$1);
  if (List.mem_assq(px, names.contents) and not List.memq(px, delayed.contents)) then do
    mark = is_non_gen(sch, ty$1);
    return --[[ Otyp_var ]]Block.__(10, {
              mark,
              name_of_type(px)
            });
  end else do
    pr_typ = function (param) do
      match = ty$1.desc;
      if (typeof match == "number") then do
        return tree_of_typobject(sch, ty$1, undefined);
      end else do
        local ___conditional___=(match.tag | 0);
        do
           if ___conditional___ = 0--[[ Tvar ]] then do
              return --[[ Otyp_var ]]Block.__(10, {
                        is_non_gen(sch, ty$1),
                        name_of_type(ty$1)
                      });end end end 
           if ___conditional___ = 1--[[ Tarrow ]] then do
              l = match[0];
              ty1 = match[1];
              ty2 = match[2];
              lab = print_labels.contents and l ~= "" or is_optional(l) and l or "";
              t1;
              if (is_optional(l)) then do
                match$1 = repr(ty1).desc;
                if (typeof match$1 == "number" or match$1.tag ~= --[[ Tconstr ]]3) then do
                  t1 = --[[ Otyp_stuff ]]Block.__(7, {"<hidden>"});
                end else do
                  match$2 = match$1[1];
                  t1 = match$2 and not (match$2[1] or not same(match$1[0], path_option)) and tree_of_typexp(sch, match$2[0]) or --[[ Otyp_stuff ]]Block.__(7, {"<hidden>"});
                end end 
              end else do
                t1 = tree_of_typexp(sch, ty1);
              end end 
              return --[[ Otyp_arrow ]]Block.__(1, {
                        lab,
                        t1,
                        tree_of_typexp(sch, ty2)
                      });end end end 
           if ___conditional___ = 2--[[ Ttuple ]] then do
              return --[[ Otyp_tuple ]]Block.__(9, {List.map((function (param) do
                                return tree_of_typexp(sch, param);
                              end end), match[0])});end end end 
           if ___conditional___ = 3--[[ Tconstr ]] then do
              match$3 = best_type_path(match[0]);
              s = match$3[1];
              tyl$prime = apply_subst(s, match[1]);
              if (is_nth(s)) then do
                return tree_of_typexp(sch, List.hd(tyl$prime));
              end else do
                return --[[ Otyp_constr ]]Block.__(3, {
                          tree_of_path(match$3[0]),
                          List.map((function (param) do
                                  return tree_of_typexp(sch, param);
                                end end), tyl$prime)
                        });
              end end end end end 
           if ___conditional___ = 4--[[ Tobject ]] then do
              return tree_of_typobject(sch, match[0], match[1].contents);end end end 
           if ___conditional___ = 5--[[ Tfield ]] then do
              return tree_of_typobject(sch, ty$1, undefined);end end end 
           if ___conditional___ = 6--[[ Tlink ]] then do
              return fatal_error("Printtyp.tree_of_typexp");end end end 
           if ___conditional___ = 7--[[ Tsubst ]] then do
              return tree_of_typexp(sch, match[0]);end end end 
           if ___conditional___ = 8--[[ Tvariant ]] then do
              row = row_repr_aux(--[[ [] ]]0, match[0]);
              fields = row.row_closed and List.filter((function (param) do
                          return row_field_repr_aux(--[[ [] ]]0, param[1]) ~= --[[ Rabsent ]]0;
                        end end))(row.row_fields) or row.row_fields;
              present = List.filter((function (param) do
                        match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                        if (typeof match == "number" or match.tag) then do
                          return false;
                        end else do
                          return true;
                        end end 
                      end end))(fields);
              all_present = List.length(present) == List.length(fields);
              match$4 = row.row_name;
              if (match$4 ~= undefined) then do
                match$5 = match$4;
                tyl = match$5[1];
                p = match$5[0];
                if (namable_row(row)) then do
                  match$6 = best_type_path(p);
                  s$1 = match$6[1];
                  id = tree_of_path(match$6[0]);
                  tyl$1 = apply_subst(s$1, tyl);
                  args = List.map((function (param) do
                          return tree_of_typexp(sch, param);
                        end end), tyl$1);
                  if (row.row_closed and all_present) then do
                    if (is_nth(s$1)) then do
                      return List.hd(args);
                    end else do
                      return --[[ Otyp_constr ]]Block.__(3, {
                                id,
                                args
                              });
                    end end 
                  end else do
                    non_gen = is_non_gen(sch, px);
                    tags = all_present and undefined or List.map((function (prim) do
                              return prim[0];
                            end end), present);
                    inh;
                    exit = 0;
                    if (args) then do
                      match$7 = args[0];
                      if (typeof match$7 == "number" or not (match$7.tag == --[[ Otyp_constr ]]3 and not (args[1] or not is_nth(s$1)))) then do
                        exit = 2;
                      end else do
                        inh = --[[ Ovar_name ]]Block.__(1, {
                            match$7[0],
                            match$7[1]
                          });
                      end end 
                    end else do
                      exit = 2;
                    end end 
                    if (exit == 2) then do
                      inh = --[[ Ovar_name ]]Block.__(1, {
                          tree_of_path(p),
                          List.map((function (param) do
                                  return tree_of_typexp(sch, param);
                                end end), tyl)
                        });
                    end
                     end 
                    return --[[ Otyp_variant ]]Block.__(11, {
                              non_gen,
                              inh,
                              row.row_closed,
                              tags
                            });
                  end end 
                end
                 end 
              end
               end 
              non_gen$1 = not (row.row_closed and all_present) and is_non_gen(sch, px);
              fields$1 = List.map((function (param) do
                      sch$1 = sch;
                      param$1 = param;
                      l = param$1[0];
                      match = row_field_repr_aux(--[[ [] ]]0, param$1[1]);
                      if (typeof match == "number") then do
                        return --[[ tuple ]]{
                                l,
                                false,
                                --[[ [] ]]0
                              };
                      end else if (match.tag) then do
                        c = match[0];
                        if (c and not match[1]) then do
                          return --[[ tuple ]]{
                                  l,
                                  false,
                                  --[[ [] ]]0
                                };
                        end
                         end 
                        tyl = match[1];
                        if (c) then do
                          return --[[ tuple ]]{
                                  l,
                                  true,
                                  List.map((function (param) do
                                          return tree_of_typexp(sch$1, param);
                                        end end), tyl)
                                };
                        end else do
                          return --[[ tuple ]]{
                                  l,
                                  false,
                                  List.map((function (param) do
                                          return tree_of_typexp(sch$1, param);
                                        end end), tyl)
                                };
                        end end 
                      end else do
                        match$1 = match[0];
                        if (match$1 ~= undefined) then do
                          return --[[ tuple ]]{
                                  l,
                                  false,
                                  --[[ :: ]]{
                                    tree_of_typexp(sch$1, match$1),
                                    --[[ [] ]]0
                                  }
                                };
                        end else do
                          return --[[ tuple ]]{
                                  l,
                                  false,
                                  --[[ [] ]]0
                                };
                        end end 
                      end end  end 
                    end end), fields);
              tags$1 = all_present and undefined or List.map((function (prim) do
                        return prim[0];
                      end end), present);
              return --[[ Otyp_variant ]]Block.__(11, {
                        non_gen$1,
                        --[[ Ovar_fields ]]Block.__(0, {fields$1}),
                        row.row_closed,
                        tags$1
                      });end end end 
           if ___conditional___ = 9--[[ Tunivar ]] then do
              return --[[ Otyp_var ]]Block.__(10, {
                        false,
                        name_of_type(ty$1)
                      });end end end 
           if ___conditional___ = 10--[[ Tpoly ]] then do
              tyl$2 = match[1];
              ty$2 = match[0];
              if (tyl$2) then do
                tyl$3 = List.map(repr, tyl$2);
                if (tyl$3 == --[[ [] ]]0) then do
                  return tree_of_typexp(sch, ty$2);
                end else do
                  old_delayed = delayed.contents;
                  List.iter(add_delayed, tyl$3);
                  tl = List.map(name_of_type, tyl$3);
                  tr_001 = tree_of_typexp(sch, ty$2);
                  tr = --[[ Otyp_poly ]]Block.__(12, {
                      tl,
                      tr_001
                    });
                  remove_names(tyl$3);
                  delayed.contents = old_delayed;
                  return tr;
                end end 
              end else do
                return tree_of_typexp(sch, ty$2);
              end end end end end 
           if ___conditional___ = 11--[[ Tpackage ]] then do
              n = List.map((function (li) do
                      return __String.concat(".", flat(--[[ [] ]]0, li));
                    end end), match[1]);
              return --[[ Otyp_module ]]Block.__(13, {
                        name(undefined, match[0]),
                        n,
                        List.map((function (param) do
                                return tree_of_typexp(sch, param);
                              end end), match[2])
                      });end end end 
           do
          
        end
      end end 
    end end;
    if (List.memq(px, delayed.contents)) then do
      delayed.contents = List.filter((function (param) do
                return px ~= param;
              end end))(delayed.contents);
    end
     end 
    if (is_aliased(px) and aliasable(ty$1)) then do
      name_of_type(px);
      return --[[ Otyp_alias ]]Block.__(0, {
                pr_typ(--[[ () ]]0),
                name_of_type(px)
              });
    end else do
      return pr_typ(--[[ () ]]0);
    end end 
  end end 
end end

function tree_of_typobject(sch, fi, nm) do
  if (nm ~= undefined) then do
    match = nm;
    match$1 = match[1];
    if (match$1) then do
      non_gen = is_non_gen(sch, repr(match$1[0]));
      args = List.map((function (param) do
              return tree_of_typexp(sch, param);
            end end), match$1[1]);
      match$2 = best_type_path(match[0]);
      if (match$2[1] ~= --[[ Id ]]0) then do
        throw {
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "printtyp.ml",
                688,
                6
              }
            };
      end
       end 
      return --[[ Otyp_class ]]Block.__(2, {
                non_gen,
                tree_of_path(match$2[0]),
                args
              });
    end else do
      return fatal_error("Printtyp.tree_of_typobject");
    end end 
  end else do
    pr_fields = function (fi) do
      match = flatten_fields(fi);
      present_fields = List.fold_right((function (param, l) do
              match = field_kind_repr(param[1]);
              if (typeof match == "number" and match == 0) then do
                return --[[ :: ]]{
                        --[[ tuple ]]{
                          param[0],
                          param[2]
                        },
                        l
                      };
              end else do
                return l;
              end end 
            end end), match[0], --[[ [] ]]0);
      sorted_fields = List.sort((function (param, param$1) do
              return Caml_primitive.caml_string_compare(param[0], param$1[0]);
            end end), present_fields);
      return tree_of_typfields(sch, match[1], sorted_fields);
    end end;
    match$3 = pr_fields(fi);
    return --[[ Otyp_object ]]Block.__(5, {
              match$3[0],
              match$3[1]
            });
  end end 
end end

function is_non_gen(sch, ty) do
  if (sch and is_Tvar(ty)) then do
    return ty.level ~= 100000000;
  end else do
    return false;
  end end 
end end

function tree_of_typfields(sch, rest, param) do
  if (param) then do
    match = param[0];
    field_000 = match[0];
    field_001 = tree_of_typexp(sch, match[1]);
    field = --[[ tuple ]]{
      field_000,
      field_001
    };
    match$1 = tree_of_typfields(sch, rest, param[1]);
    return --[[ tuple ]]{
            --[[ :: ]]{
              field,
              match$1[0]
            },
            match$1[1]
          };
  end else do
    match$2 = rest.desc;
    rest$1;
    if (typeof match$2 == "number") then do
      rest$1 = undefined;
    end else do
      local ___conditional___=(match$2.tag | 0);
      do
         if ___conditional___ = 3--[[ Tconstr ]] then do
            rest$1 = false;end else 
         if ___conditional___ = 0--[[ Tvar ]]
         or ___conditional___ = 9--[[ Tunivar ]] then do
            rest$1 = is_non_gen(sch, rest);end else 
         do end end end
        else do
          rest$1 = fatal_error("typfields (1)");
          end end
          
      end
    end end 
    return --[[ tuple ]]{
            --[[ [] ]]0,
            rest$1
          };
  end end 
end end

function typexp$1(sch, prio, ppf, ty) do
  return Curry._2(out_type.contents, ppf, tree_of_typexp(sch, ty));
end end

function type_expr$1(ppf, ty) do
  return typexp$1(false, 0, ppf, ty);
end end

function type_scheme(ppf, ty) do
  reset(--[[ () ]]0);
  mark_loops(ty);
  return typexp$1(true, 0, ppf, ty);
end end

function tree_of_type_scheme(ty) do
  reset(--[[ () ]]0);
  mark_loops(ty);
  return tree_of_typexp(true, ty);
end end

function tree_of_constraints(params) do
  return List.fold_right((function (ty, list) do
                ty$prime = unalias(ty);
                if (proxy(ty) ~= proxy(ty$prime)) then do
                  tr = tree_of_typexp(true, ty);
                  return --[[ :: ]]{
                          --[[ tuple ]]{
                            tr,
                            tree_of_typexp(true, ty$prime)
                          },
                          list
                        };
                end else do
                  return list;
                end end 
              end end), params, --[[ [] ]]0);
end end

function filter_params(tyl) do
  return List.rev(List.fold_left((function (tyl, ty) do
                    ty$1 = repr(ty);
                    if (List.memq(ty$1, tyl)) then do
                      return --[[ :: ]]{
                              newty2(100000000, --[[ Tsubst ]]Block.__(7, {ty$1})),
                              tyl
                            };
                    end else do
                      return --[[ :: ]]{
                              ty$1,
                              tyl
                            };
                    end end 
                  end end), --[[ [] ]]0, tyl));
end end

function tree_of_label(l) do
  return --[[ tuple ]]{
          l.ld_id.name,
          l.ld_mutable == --[[ Mutable ]]1,
          tree_of_typexp(false, l.ld_type)
        };
end end

function tree_of_constructor(cd) do
  name = cd.cd_id.name;
  match = cd.cd_res;
  if (match ~= undefined) then do
    nm = names.contents;
    names.contents = --[[ [] ]]0;
    ret = tree_of_typexp(false, match);
    args = List.map((function (param) do
            return tree_of_typexp(false, param);
          end end), cd.cd_args);
    names.contents = nm;
    return --[[ tuple ]]{
            name,
            args,
            ret
          };
  end else do
    return --[[ tuple ]]{
            name,
            List.map((function (param) do
                    return tree_of_typexp(false, param);
                  end end), cd.cd_args),
            undefined
          };
  end end 
end end

function tree_of_type_decl(id, decl) do
  reset(--[[ () ]]0);
  params = filter_params(decl.type_params);
  match = decl.type_manifest;
  if (match ~= undefined) then do
    vars = free_variables$1(undefined, match);
    List.iter((function (ty) do
            match = ty.desc;
            if (typeof match == "number" or match.tag) then do
              return --[[ () ]]0;
            end else do
              match$1 = match[0];
              if (match$1 ~= undefined and match$1 == "_" and List.memq(ty, vars)) then do
                ty.desc = --[[ Tvar ]]Block.__(0, {undefined});
                return --[[ () ]]0;
              end else do
                return --[[ () ]]0;
              end end 
            end end 
          end end), params);
  end
   end 
  List.iter(add_alias, params);
  List.iter(mark_loops, params);
  List.iter(check_name_of_type, List.map(proxy, params));
  match$1 = decl.type_manifest;
  ty_manifest;
  if (match$1 ~= undefined) then do
    ty = match$1;
    match$2 = repr(ty);
    match$3 = match$2.desc;
    ty$1;
    if (typeof match$3 == "number" or match$3.tag ~= --[[ Tvariant ]]8) then do
      ty$1 = ty;
    end else do
      row = row_repr_aux(--[[ [] ]]0, match$3[0]);
      match$4 = row.row_name;
      if (match$4 ~= undefined) then do
        match$5 = match$4[0];
        local ___conditional___=(match$5.tag | 0);
        do
           if ___conditional___ = 0--[[ Pident ]] then do
              ty$1 = Caml_obj.caml_equal(id, match$5[0]) and newty2(100000000, --[[ Tvariant ]]Block.__(8, {do
                          row_fields: row.row_fields,
                          row_more: row.row_more,
                          row_bound: row.row_bound,
                          row_closed: row.row_closed,
                          row_fixed: row.row_fixed,
                          row_name: undefined
                        end})) or ty;end else 
           if ___conditional___ = 1--[[ Pdot ]]
           or ___conditional___ = 2--[[ Papply ]] then do
              ty$1 = ty;end else 
           do end end end
          
        end
      end else do
        ty$1 = ty;
      end end 
    end end 
    mark_loops(ty$1);
    ty_manifest = ty$1;
  end else do
    ty_manifest = undefined;
  end end 
  match$6 = decl.type_kind;
  if (typeof match$6 == "number") then do
    match$6 == --[[ Type_abstract ]]0;
  end else if (match$6.tag) then do
    List.iter((function (c) do
            List.iter(mark_loops, c.cd_args);
            return may(mark_loops, c.cd_res);
          end end), match$6[0]);
  end else do
    List.iter((function (l) do
            return mark_loops(l.ld_type);
          end end), match$6[0]);
  end end  end 
  type_param = function (param) do
    if (typeof param == "number" or param.tag ~= --[[ Otyp_var ]]10) then do
      return "?";
    end else do
      return param[1];
    end end 
  end end;
  type_defined = function (decl) do
    match = decl.type_kind;
    abstr;
    abstr = typeof match == "number" and (
        match == --[[ Type_abstract ]]0 and decl.type_manifest == undefined or decl.type_private == --[[ Private ]]0 or decl.type_manifest == undefined
      ) or (
        match.tag and decl.type_private == --[[ Private ]]0 or List.exists((function (cd) do
                  return cd.cd_res ~= undefined;
                end end), match[0]) or decl.type_private == --[[ Private ]]0
      );
    vari = List.map2((function (ty, v) do
            if (abstr or not is_Tvar(repr(ty))) then do
              return Curry._1(Types_Variance.get_upper, v);
            end else do
              return --[[ tuple ]]{
                      true,
                      true
                    };
            end end 
          end end), decl.type_params, decl.type_variance);
    return --[[ tuple ]]{
            id.name,
            List.map2((function (ty, cocn) do
                    return --[[ tuple ]]{
                            type_param(tree_of_typexp(false, ty)),
                            cocn
                          };
                  end end), params, vari)
          };
  end end;
  tree_of_manifest = function (ty1) do
    if (ty_manifest ~= undefined) then do
      return --[[ Otyp_manifest ]]Block.__(4, {
                tree_of_typexp(false, ty_manifest),
                ty1
              });
    end else do
      return ty1;
    end end 
  end end;
  match$7 = type_defined(decl);
  constraints = tree_of_constraints(params);
  match$8 = decl.type_kind;
  match$9;
  match$9 = typeof match$8 == "number" and (
      match$8 == --[[ Type_abstract ]]0 and (
          ty_manifest ~= undefined and --[[ tuple ]]{
              tree_of_typexp(false, ty_manifest),
              decl.type_private
            } or --[[ tuple ]]{
              --[[ Otyp_abstract ]]0,
              --[[ Public ]]1
            }
        ) or --[[ tuple ]]{
          tree_of_manifest(--[[ Otyp_open ]]1),
          --[[ Public ]]1
        }
    ) or (
      match$8.tag and --[[ tuple ]]{
          tree_of_manifest(--[[ Otyp_sum ]]Block.__(8, {List.map(tree_of_constructor, match$8[0])})),
          decl.type_private
        } or --[[ tuple ]]{
          tree_of_manifest(--[[ Otyp_record ]]Block.__(6, {List.map(tree_of_label, match$8[0])})),
          decl.type_private
        }
    );
  return do
          otype_name: match$7[0],
          otype_params: match$7[1],
          otype_type: match$9[0],
          otype_private: match$9[1],
          otype_cstrs: constraints
        end;
end end

function tree_of_type_declaration(id, decl, rs) do
  return --[[ Osig_type ]]Block.__(5, {
            tree_of_type_decl(id, decl),
            rs
          });
end end

function type_declaration$1(id, ppf, decl) do
  return Curry._2(out_sig_item.contents, ppf, tree_of_type_declaration(id, decl, --[[ Trec_first ]]1));
end end

function tree_of_extension_constructor(id, ext, es) do
  reset(--[[ () ]]0);
  ty_name = name(undefined, ext.ext_type_path);
  ty_params = filter_params(ext.ext_type_params);
  List.iter(add_alias, ty_params);
  List.iter(mark_loops, ty_params);
  List.iter(check_name_of_type, List.map(proxy, ty_params));
  List.iter(mark_loops, ext.ext_args);
  may(mark_loops, ext.ext_ret_type);
  ty_params$1 = List.map((function (ty) do
          param = tree_of_typexp(false, ty);
          if (typeof param == "number" or param.tag ~= --[[ Otyp_var ]]10) then do
            return "?";
          end else do
            return param[1];
          end end 
        end end), ty_params);
  name$1 = id.name;
  match = ext.ext_ret_type;
  match$1;
  if (match ~= undefined) then do
    nm = names.contents;
    names.contents = --[[ [] ]]0;
    ret = tree_of_typexp(false, match);
    args = List.map((function (param) do
            return tree_of_typexp(false, param);
          end end), ext.ext_args);
    names.contents = nm;
    match$1 = --[[ tuple ]]{
      args,
      ret
    };
  end else do
    match$1 = --[[ tuple ]]{
      List.map((function (param) do
              return tree_of_typexp(false, param);
            end end), ext.ext_args),
      undefined
    };
  end end 
  ext_oext_args = match$1[0];
  ext_oext_ret_type = match$1[1];
  ext_oext_private = ext.ext_private;
  ext$1 = do
    oext_name: name$1,
    oext_type_name: ty_name,
    oext_type_params: ty_params$1,
    oext_args: ext_oext_args,
    oext_ret_type: ext_oext_ret_type,
    oext_private: ext_oext_private
  end;
  return --[[ Osig_typext ]]Block.__(2, {
            ext$1,
            es
          });
end end

function extension_constructor$1(id, ppf, ext) do
  return Curry._2(out_sig_item.contents, ppf, tree_of_extension_constructor(id, ext, --[[ Text_first ]]0));
end end

function tree_of_value_description(id, decl) do
  id$1 = id.name;
  ty = tree_of_type_scheme(decl.val_type);
  match = decl.val_kind;
  prims;
  prims = typeof match == "number" or match.tag and --[[ [] ]]0 or description_list(match[0]);
  return --[[ Osig_value ]]Block.__(6, {
            id$1,
            ty,
            prims
          });
end end

function value_description$1(id, ppf, decl) do
  return Curry._2(out_sig_item.contents, ppf, tree_of_value_description(id, decl));
end end

function method_type(param) do
  match = field_kind_repr(param[1]);
  match$1 = repr(param[2]);
  if (typeof match == "number" and match == 0) then do
    match$2 = match$1.desc;
    if (typeof match$2 == "number" or match$2.tag ~= --[[ Tpoly ]]10) then do
      return --[[ tuple ]]{
              match$1,
              --[[ [] ]]0
            };
    end else do
      return --[[ tuple ]]{
              match$2[0],
              match$2[1]
            };
    end end 
  end else do
    return --[[ tuple ]]{
            match$1,
            --[[ [] ]]0
          };
  end end 
end end

function prepare_class_type(params, _param) do
  while(true) do
    param = _param;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ = 0--[[ Cty_constr ]] then do
          cty = param[2];
          tyl = param[1];
          sty = repr(signature_of_class_type(cty).csig_self);
          if (List.memq(proxy(sty), visited_objects.contents) or not List.for_all(is_Tvar, params) or List.exists((function(sty)do
                return function (param) do
                  return deep_occur(sty, param);
                end end
                end(sty)), tyl)) then do
            _param = cty;
            continue ;
          end else do
            return List.iter(mark_loops, tyl);
          end end end end end 
       if ___conditional___ = 1--[[ Cty_signature ]] then do
          sign = param[0];
          sty$1 = repr(sign.csig_self);
          px = proxy(sty$1);
          if (List.memq(px, visited_objects.contents)) then do
            add_alias(sty$1);
          end else do
            visited_objects.contents = --[[ :: ]]{
              px,
              visited_objects.contents
            };
          end end 
          match = flatten_fields(object_fields(sign.csig_self));
          List.iter((function (met) do
                  return mark_loops(method_type(met)[0]);
                end end), match[0]);
          return iter$1((function (param, param$1) do
                        return mark_loops(param$1[2]);
                      end end), sign.csig_vars);end end end 
       if ___conditional___ = 2--[[ Cty_arrow ]] then do
          mark_loops(param[1]);
          _param = param[2];
          continue ;end end end 
       do
      
    end
  end;
end end

function tree_of_class_type(sch, params, _param) do
  while(true) do
    param = _param;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ = 0--[[ Cty_constr ]] then do
          cty = param[2];
          sty = repr(signature_of_class_type(cty).csig_self);
          if (List.memq(proxy(sty), visited_objects.contents) or not List.for_all(is_Tvar, params)) then do
            _param = cty;
            continue ;
          end else do
            return --[[ Octy_constr ]]Block.__(0, {
                      tree_of_path(param[0]),
                      List.map((function (param) do
                              return tree_of_typexp(true, param);
                            end end), param[1])
                    });
          end end end end end 
       if ___conditional___ = 1--[[ Cty_signature ]] then do
          sign = param[0];
          sty$1 = repr(sign.csig_self);
          self_ty = is_aliased(sty$1) and --[[ Otyp_var ]]Block.__(10, {
                false,
                name_of_type(proxy(sty$1))
              }) or undefined;
          match = flatten_fields(object_fields(sign.csig_self));
          csil = List.fold_left((function (csil, param) do
                  return --[[ :: ]]{
                          --[[ Ocsg_constraint ]]Block.__(0, {
                              param[0],
                              param[1]
                            }),
                          csil
                        };
                end end), --[[ [] ]]0, tree_of_constraints(params));
          all_vars = fold((function (l, param, all) do
                  return --[[ :: ]]{
                          --[[ tuple ]]{
                            l,
                            param[0],
                            param[1],
                            param[2]
                          },
                          all
                        };
                end end), sign.csig_vars, --[[ [] ]]0);
          all_vars$1 = List.rev(all_vars);
          csil$1 = List.fold_left((function (csil, param) do
                  return --[[ :: ]]{
                          --[[ Ocsg_value ]]Block.__(2, {
                              param[0],
                              param[1] == --[[ Mutable ]]1,
                              param[2] == --[[ Virtual ]]0,
                              tree_of_typexp(sch, param[3])
                            }),
                          csil
                        };
                end end), csil, all_vars$1);
          partial_arg = sign.csig_concr;
          csil$2 = List.fold_left((function(partial_arg)do
              return function (param, param$1) do
                sch$1 = sch;
                concrete = partial_arg;
                csil = param;
                param$2 = param$1;
                lab = param$2[0];
                if (lab ~= dummy_method) then do
                  kind = field_kind_repr(param$2[1]);
                  priv = kind ~= --[[ Fpresent ]]0;
                  virt = not mem$2(lab, concrete);
                  match = method_type(--[[ tuple ]]{
                        lab,
                        kind,
                        param$2[2]
                      });
                  tty = tree_of_typexp(sch$1, match[0]);
                  remove_names(match[1]);
                  return --[[ :: ]]{
                          --[[ Ocsg_method ]]Block.__(1, {
                              lab,
                              priv,
                              virt,
                              tty
                            }),
                          csil
                        };
                end else do
                  return csil;
                end end 
              end end
              end(partial_arg)), csil$1, match[0]);
          return --[[ Octy_signature ]]Block.__(2, {
                    self_ty,
                    List.rev(csil$2)
                  });end end end 
       if ___conditional___ = 2--[[ Cty_arrow ]] then do
          ty = param[1];
          l = param[0];
          lab = print_labels.contents and l ~= "" or is_optional(l) and l or "";
          ty$1;
          if (is_optional(l)) then do
            match$1 = repr(ty).desc;
            exit = 0;
            if (typeof match$1 == "number" or match$1.tag ~= --[[ Tconstr ]]3) then do
              exit = 1;
            end else do
              match$2 = match$1[1];
              if (match$2 and not (match$2[1] or not same(match$1[0], path_option))) then do
                ty$1 = match$2[0];
              end else do
                exit = 1;
              end end 
            end end 
            if (exit == 1) then do
              ty$1 = newconstr(--[[ Pident ]]Block.__(0, {create("<hidden>")}), --[[ [] ]]0);
            end
             end 
          end else do
            ty$1 = ty;
          end end 
          tr = tree_of_typexp(sch, ty$1);
          return --[[ Octy_arrow ]]Block.__(1, {
                    lab,
                    tr,
                    tree_of_class_type(sch, params, param[2])
                  });end end end 
       do
      
    end
  end;
end end

function class_type$2(ppf, cty) do
  reset(--[[ () ]]0);
  prepare_class_type(--[[ [] ]]0, cty);
  return Curry._2(out_class_type.contents, ppf, tree_of_class_type(false, --[[ [] ]]0, cty));
end end

function tree_of_class_param(param, variance) do
  match = tree_of_typexp(true, param);
  tmp;
  tmp = typeof match == "number" or match.tag ~= --[[ Otyp_var ]]10 and "?" or match[1];
  return --[[ tuple ]]{
          tmp,
          is_Tvar(repr(param)) and --[[ tuple ]]{
              true,
              true
            } or variance
        };
end end

function class_variance(param) do
  return List.map((function (v) do
                return --[[ tuple ]]{
                        Curry._2(Types_Variance.mem, --[[ May_pos ]]0, v),
                        Curry._2(Types_Variance.mem, --[[ May_neg ]]1, v)
                      };
              end end), param);
end end

function tree_of_class_declaration(id, cl, rs) do
  params = filter_params(cl.cty_params);
  reset(--[[ () ]]0);
  List.iter(add_alias, params);
  prepare_class_type(params, cl.cty_type);
  sty = repr(signature_of_class_type(cl.cty_type).csig_self);
  List.iter(mark_loops, params);
  List.iter(check_name_of_type, List.map(proxy, params));
  if (is_aliased(sty)) then do
    t = proxy(sty);
    name_of_type(t);
  end
   end 
  vir_flag = cl.cty_new == undefined;
  return --[[ Osig_class ]]Block.__(0, {
            vir_flag,
            id.name,
            List.map2(tree_of_class_param, params, class_variance(cl.cty_variance)),
            tree_of_class_type(true, params, cl.cty_type),
            rs
          });
end end

function class_declaration$1(id, ppf, cl) do
  return Curry._2(out_sig_item.contents, ppf, tree_of_class_declaration(id, cl, --[[ Trec_first ]]1));
end end

function tree_of_cltype_declaration(id, cl, rs) do
  params = List.map(repr, cl.clty_params);
  reset(--[[ () ]]0);
  List.iter(add_alias, params);
  prepare_class_type(params, cl.clty_type);
  sty = repr(signature_of_class_type(cl.clty_type).csig_self);
  List.iter(mark_loops, params);
  List.iter(check_name_of_type, List.map(proxy, params));
  if (is_aliased(sty)) then do
    t = proxy(sty);
    name_of_type(t);
  end
   end 
  sign = signature_of_class_type(cl.clty_type);
  match = flatten_fields(object_fields(sign.csig_self));
  virt = List.exists((function (param) do
          lab = param[0];
          return not (lab == dummy_method or mem$2(lab, sign.csig_concr));
        end end), match[0]) or fold((function (param, param$1, b) do
          if (param$1[1] == --[[ Virtual ]]0) then do
            return true;
          end else do
            return b;
          end end 
        end end), sign.csig_vars, false);
  return --[[ Osig_class_type ]]Block.__(1, {
            virt,
            id.name,
            List.map2(tree_of_class_param, params, class_variance(cl.clty_variance)),
            tree_of_class_type(true, params, cl.clty_type),
            rs
          });
end end

function cltype_declaration$1(id, ppf, cl) do
  return Curry._2(out_sig_item.contents, ppf, tree_of_cltype_declaration(id, cl, --[[ Trec_first ]]1));
end end

function wrap_env(fenv, ftree, arg) do
  env = printing_env.contents;
  set_printing_env(Curry._1(fenv, env));
  tree = Curry._1(ftree, arg);
  set_printing_env(env);
  return tree;
end end

function filter_rem_sig(item, rem) do
  local ___conditional___=(item.tag | 0);
  do
     if ___conditional___ = 5--[[ Sig_class ]] then do
        if (rem) then do
          match = rem[1];
          if (match) then do
            match$1 = match[1];
            if (match$1) then do
              return --[[ tuple ]]{
                      --[[ :: ]]{
                        rem[0],
                        --[[ :: ]]{
                          match[0],
                          --[[ :: ]]{
                            match$1[0],
                            --[[ [] ]]0
                          }
                        }
                      },
                      match$1[1]
                    };
            end else do
              return --[[ tuple ]]{
                      --[[ [] ]]0,
                      rem
                    };
            end end 
          end else do
            return --[[ tuple ]]{
                    --[[ [] ]]0,
                    rem
                  };
          end end 
        end else do
          return --[[ tuple ]]{
                  --[[ [] ]]0,
                  rem
                };
        end end end end end 
     if ___conditional___ = 6--[[ Sig_class_type ]] then do
        if (rem) then do
          match$2 = rem[1];
          if (match$2) then do
            return --[[ tuple ]]{
                    --[[ :: ]]{
                      rem[0],
                      --[[ :: ]]{
                        match$2[0],
                        --[[ [] ]]0
                      }
                    },
                    match$2[1]
                  };
          end else do
            return --[[ tuple ]]{
                    --[[ [] ]]0,
                    rem
                  };
          end end 
        end else do
          return --[[ tuple ]]{
                  --[[ [] ]]0,
                  rem
                };
        end end end end end 
     do
    else do
      return --[[ tuple ]]{
              --[[ [] ]]0,
              rem
            };
      end end
      
  end
end end

dummy = do
  type_params: --[[ [] ]]0,
  type_arity: 0,
  type_kind: --[[ Type_abstract ]]0,
  type_private: --[[ Public ]]1,
  type_manifest: undefined,
  type_variance: --[[ [] ]]0,
  type_newtype_level: undefined,
  type_loc: none,
  type_attributes: --[[ [] ]]0
end;

function hide_rec_items(param) do
  if (param) then do
    match = param[0];
    if (match.tag == --[[ Sig_type ]]1 and match[2] == --[[ Trec_first ]]1 and not real_paths.contents) then do
      get_ids = function (param) do
        if (param) then do
          match = param[0];
          if (match.tag == --[[ Sig_type ]]1 and match[2] >= 2) then do
            return --[[ :: ]]{
                    match[0],
                    get_ids(param[1])
                  };
          end else do
            return --[[ [] ]]0;
          end end 
        end else do
          return --[[ [] ]]0;
        end end 
      end end;
      ids_000 = match[0];
      ids_001 = get_ids(param[1]);
      ids = --[[ :: ]]{
        ids_000,
        ids_001
      };
      return set_printing_env(List.fold_right((function (id) do
                        partial_arg = rename(id);
                        return (function (param) do
                            return add_type$1(false, partial_arg, dummy, param);
                          end end);
                      end end), ids, printing_env.contents));
    end else do
      return --[[ () ]]0;
    end end 
  end else do
    return --[[ () ]]0;
  end end 
end end

function tree_of_modtype(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Mty_ident ]] then do
        return --[[ Omty_ident ]]Block.__(1, {tree_of_path(param[0])});end end end 
     if ___conditional___ = 1--[[ Mty_signature ]] then do
        return --[[ Omty_signature ]]Block.__(2, {tree_of_signature(param[0])});end end end 
     if ___conditional___ = 2--[[ Mty_functor ]] then do
        ty_res = param[2];
        ty_arg = param[1];
        param$1 = param[0];
        res;
        if (ty_arg ~= undefined) then do
          mty = ty_arg;
          partial_arg = true;
          res = wrap_env((function (param$2) do
                  return add_module$1(partial_arg, param$1, mty, param$2);
                end end), tree_of_modtype, ty_res);
        end else do
          res = tree_of_modtype(ty_res);
        end end 
        return --[[ Omty_functor ]]Block.__(0, {
                  param$1.name,
                  may_map(tree_of_modtype, ty_arg),
                  res
                });end end end 
     if ___conditional___ = 3--[[ Mty_alias ]] then do
        return --[[ Omty_alias ]]Block.__(3, {tree_of_path(param[0])});end end end 
     do
    
  end
end end

function tree_of_signature(sg) do
  partial_arg = printing_env.contents;
  return wrap_env((function (env) do
                return env;
              end end), (function (param) do
                return tree_of_signature_rec(partial_arg, false, param);
              end end), sg);
end end

function tree_of_signature_rec(env$prime, in_type_group, param) do
  if (param) then do
    item = param[0];
    in_type_group$1;
    exit = 0;
    if (in_type_group) then do
      if (item.tag == --[[ Sig_type ]]1) then do
        if (item[2] >= 2) then do
          in_type_group$1 = true;
        end else do
          exit = 1;
        end end 
      end else do
        set_printing_env(env$prime);
        in_type_group$1 = false;
      end end 
    end else do
      exit = 1;
    end end 
    if (exit == 1) then do
      set_printing_env(env$prime);
      in_type_group$1 = item.tag == --[[ Sig_type ]]1 and item[2] < 2 and true or false;
    end
     end 
    match = filter_rem_sig(item, param[1]);
    rem = match[1];
    trees;
    local ___conditional___=(item.tag | 0);
    do
       if ___conditional___ = 0--[[ Sig_value ]] then do
          trees = --[[ :: ]]{
            tree_of_value_description(item[0], item[1]),
            --[[ [] ]]0
          };end else 
       if ___conditional___ = 1--[[ Sig_type ]] then do
          id = item[0];
          if (is_row_name(id.name)) then do
            trees = --[[ [] ]]0;
          end else do
            hide_rec_items(--[[ :: ]]{
                  item,
                  rem
                });
            trees = --[[ :: ]]{
              --[[ Osig_type ]]Block.__(5, {
                  tree_of_type_decl(id, item[1]),
                  item[2]
                }),
              --[[ [] ]]0
            };
          end end end else 
       if ___conditional___ = 2--[[ Sig_typext ]] then do
          trees = --[[ :: ]]{
            tree_of_extension_constructor(item[0], item[1], item[2]),
            --[[ [] ]]0
          };end else 
       if ___conditional___ = 3--[[ Sig_module ]] then do
          trees = --[[ :: ]]{
            --[[ Osig_module ]]Block.__(4, {
                item[0].name,
                tree_of_modtype(item[1].md_type),
                item[2]
              }),
            --[[ [] ]]0
          };end else 
       if ___conditional___ = 4--[[ Sig_modtype ]] then do
          trees = --[[ :: ]]{
            tree_of_modtype_declaration(item[0], item[1]),
            --[[ [] ]]0
          };end else 
       if ___conditional___ = 5--[[ Sig_class ]] then do
          trees = --[[ :: ]]{
            tree_of_class_declaration(item[0], item[1], item[2]),
            --[[ [] ]]0
          };end else 
       if ___conditional___ = 6--[[ Sig_class_type ]] then do
          trees = --[[ :: ]]{
            tree_of_cltype_declaration(item[0], item[1], item[2]),
            --[[ [] ]]0
          };end else 
       do end end end end end end end end
      
    end
    env$prime$1 = add_signature(--[[ :: ]]{
          item,
          match[0]
        }, env$prime);
    return Pervasives.$at(trees, tree_of_signature_rec(env$prime$1, in_type_group$1, rem));
  end else do
    return --[[ [] ]]0;
  end end 
end end

function tree_of_modtype_declaration(id, decl) do
  match = decl.mtd_type;
  mty = match ~= undefined and tree_of_modtype(match) or --[[ Omty_abstract ]]0;
  return --[[ Osig_modtype ]]Block.__(3, {
            id.name,
            mty
          });
end end

function modtype$1(ppf, mty) do
  return Curry._2(out_module_type.contents, ppf, tree_of_modtype(mty));
end end

function modtype_declaration$1(id, ppf, decl) do
  return Curry._2(out_sig_item.contents, ppf, tree_of_modtype_declaration(id, decl));
end end

function print_signature(ppf, tree) do
  return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                  --[[ Formatting_gen ]]Block.__(18, {
                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                            --[[ String_literal ]]Block.__(11, {
                                "<v>",
                                --[[ End_of_format ]]0
                              }),
                            "<v>"
                          }}),
                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                              --[[ Close_box ]]0,
                              --[[ End_of_format ]]0
                            })})
                    }),
                  "@[<v>%a@]"
                }), out_signature.contents, tree);
end end

function signature$3(ppf, sg) do
  return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                  --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0}),
                  "%a"
                }), print_signature, tree_of_signature(sg));
end end

function same_path(t, t$prime) do
  t$1 = repr(t);
  t$prime$1 = repr(t$prime);
  if (t$1 == t$prime$1) then do
    return true;
  end else do
    match = t$1.desc;
    match$1 = t$prime$1.desc;
    if (typeof match == "number" or not (match.tag == --[[ Tconstr ]]3 and not (typeof match$1 == "number" or match$1.tag ~= --[[ Tconstr ]]3))) then do
      return false;
    end else do
      match$2 = best_type_path(match[0]);
      s1 = match$2[1];
      match$3 = best_type_path(match$1[0]);
      s2 = match$3[1];
      exit = 0;
      if (typeof s1 == "number" or s1.tag) then do
        exit = 1;
      end else if (typeof s2 == "number" or s2.tag) then do
        return false;
      end else do
        return s1[0] == s2[0];
      end end  end 
      if (exit == 1) then do
        if (typeof s2 ~= "number" and not s2.tag) then do
          return false;
        end
         end 
        if (same(match$2[0], match$3[0])) then do
          tl = apply_subst(s1, match[1]);
          tl$prime = apply_subst(s2, match$1[1]);
          if (List.length(tl) == List.length(tl$prime)) then do
            return List.for_all2(same_type, tl, tl$prime);
          end else do
            return false;
          end end 
        end else do
          return false;
        end end 
      end
       end 
    end end 
  end end 
end end

function type_expansion(t, ppf, t$prime) do
  if (same_path(t, t$prime)) then do
    return type_expr$1(ppf, t);
  end else do
    t$prime$1 = proxy(t) == proxy(t$prime) and unalias(t$prime) or t$prime;
    return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<2>",
                                  --[[ End_of_format ]]0
                                }),
                              "<2>"
                            }}),
                        --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@ ",
                                    1,
                                    0
                                  }),
                                --[[ Char_literal ]]Block.__(12, {
                                    --[[ "=" ]]61,
                                    --[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Break ]]Block.__(0, {
                                            "@ ",
                                            1,
                                            0
                                          }),
                                        --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Close_box ]]0,
                                                --[[ End_of_format ]]0
                                              })})
                                      })
                                  })
                              })})
                      }),
                    "@[<2>%a@ =@ %a@]"
                  }), type_expr$1, t, type_expr$1, t$prime$1);
  end end 
end end

function type_path_expansion(tp, ppf, tp$prime) do
  if (same(tp, tp$prime)) then do
    return path(ppf, tp);
  end else do
    return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<2>",
                                  --[[ End_of_format ]]0
                                }),
                              "<2>"
                            }}),
                        --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@ ",
                                    1,
                                    0
                                  }),
                                --[[ Char_literal ]]Block.__(12, {
                                    --[[ "=" ]]61,
                                    --[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Break ]]Block.__(0, {
                                            "@ ",
                                            1,
                                            0
                                          }),
                                        --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Close_box ]]0,
                                                --[[ End_of_format ]]0
                                              })})
                                      })
                                  })
                              })})
                      }),
                    "@[<2>%a@ =@ %a@]"
                  }), path, tp, path, tp$prime);
  end end 
end end

function trace(fst, txt, ppf, param) do
  if (param) then do
    match = param[1];
    if (match) then do
      match$1 = match[0];
      t2 = match$1[0];
      match$2 = param[0];
      t1 = match$2[0];
      if (not fst) then do
        Format.fprintf(ppf, --[[ Format ]]{
              --[[ Formatting_lit ]]Block.__(17, {
                  --[[ Break ]]Block.__(0, {
                      "@,",
                      0,
                      0
                    }),
                  --[[ End_of_format ]]0
                }),
              "@,"
            });
      end
       end 
      return Curry._7(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Formatting_gen ]]Block.__(18, {
                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                --[[ End_of_format ]]0,
                                ""
                              }}),
                          --[[ String_literal ]]Block.__(11, {
                              "Type",
                              --[[ Formatting_lit ]]Block.__(17, {
                                  --[[ Break ]]Block.__(0, {
                                      "@;<1 2>",
                                      1,
                                      2
                                    }),
                                  --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ String ]]Block.__(2, {
                                              --[[ No_padding ]]0,
                                              --[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Break ]]Block.__(0, {
                                                      "@;<1 2>",
                                                      1,
                                                      2
                                                    }),
                                                  --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                          --[[ Close_box ]]0,
                                                          --[[ Char_literal ]]Block.__(12, {
                                                              --[[ " " ]]32,
                                                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                            })
                                                        })})
                                                })
                                            })
                                        })})
                                })
                            })
                        }),
                      "@[Type@;<1 2>%a@ %s@;<1 2>%a@] %a"
                    }), (function (param, param$1) do
                    return type_expansion(t1, param, param$1);
                  end end), match$2[1], txt, (function (param, param$1) do
                    return type_expansion(t2, param, param$1);
                  end end), match$1[1], (function (param, param$1) do
                    return trace(false, txt, param, param$1);
                  end end), match[1]);
    end else do
      return --[[ () ]]0;
    end end 
  end else do
    return --[[ () ]]0;
  end end 
end end

function filter_trace(keep_last, param) do
  if (param) then do
    match = param[1];
    if (match) then do
      rem = match[1];
      match$1 = match[0];
      t2$prime = match$1[1];
      t2 = match$1[0];
      match$2 = param[0];
      t1$prime = match$2[1];
      t1 = match$2[0];
      if (not rem and (is_Tvar(t1$prime) or is_Tvar(t2$prime))) then do
        return --[[ [] ]]0;
      end
       end 
      rem$prime = filter_trace(keep_last, rem);
      if (is_constr_row(t1$prime) or is_constr_row(t2$prime) or same_path(t1, t1$prime) and same_path(t2, t2$prime) and not (keep_last and rem$prime == --[[ [] ]]0)) then do
        return rem$prime;
      end else do
        return --[[ :: ]]{
                --[[ tuple ]]{
                  t1,
                  t1$prime
                },
                --[[ :: ]]{
                  --[[ tuple ]]{
                    t2,
                    t2$prime
                  },
                  rem$prime
                }
              };
      end end 
    end else do
      return --[[ [] ]]0;
    end end 
  end else do
    return --[[ [] ]]0;
  end end 
end end

function type_path_list(ppf, param) do
  if (param) then do
    rem = param[1];
    match = param[0];
    tp$prime = match[1];
    tp = match[0];
    if (rem) then do
      return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                              --[[ Break ]]Block.__(0, {
                                  "@;<2 0>",
                                  2,
                                  0
                                }),
                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                            })}),
                      "%a@;<2 0>%a"
                    }), (function (param, param$1) do
                    return type_path_expansion(tp, param, param$1);
                  end end), tp$prime, type_path_list, rem);
    end else do
      return type_path_expansion(tp, ppf, tp$prime);
    end end 
  end else do
    return --[[ () ]]0;
  end end 
end end

function hide_variant_name(t) do
  t$1 = repr(t);
  match = t$1.desc;
  if (typeof match == "number" or match.tag ~= --[[ Tvariant ]]8) then do
    return t;
  end else do
    row = match[0];
    if (row_repr_aux(--[[ [] ]]0, row).row_name ~= undefined) then do
      init = row_repr_aux(--[[ [] ]]0, row);
      level = row_more(row).level;
      return newty2(t$1.level, --[[ Tvariant ]]Block.__(8, {do
                      row_fields: init.row_fields,
                      row_more: newty2(level, --[[ Tvar ]]Block.__(0, {undefined})),
                      row_bound: init.row_bound,
                      row_closed: init.row_closed,
                      row_fixed: init.row_fixed,
                      row_name: undefined
                    end}));
    end else do
      return t;
    end end 
  end end 
end end

function prepare_expansion(param) do
  t = param[0];
  t$prime = hide_variant_name(param[1]);
  mark_loops(t);
  if (not same_path(t, t$prime)) then do
    mark_loops(t$prime);
  end
   end 
  return --[[ tuple ]]{
          t,
          t$prime
        };
end end

function may_prepare_expansion(compact, param) do
  t$prime = param[1];
  t = param[0];
  match = repr(t$prime).desc;
  if (typeof match == "number") then do
    return prepare_expansion(--[[ tuple ]]{
                t,
                t$prime
              });
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 4--[[ Tobject ]]
       or ___conditional___ = 8--[[ Tvariant ]]
       do end
      else do
        return prepare_expansion(--[[ tuple ]]{
                    t,
                    t$prime
                  });
        end end
        
    end
  end end 
  if (compact) then do
    mark_loops(t);
    return --[[ tuple ]]{
            t,
            t
          };
  end else do
    return prepare_expansion(--[[ tuple ]]{
                t,
                t$prime
              });
  end end 
end end

function print_tags(ppf, fields) do
  if (fields) then do
    Curry._1(Format.fprintf(ppf, --[[ Format ]]{
              --[[ Char_literal ]]Block.__(12, {
                  --[[ "`" ]]96,
                  --[[ String ]]Block.__(2, {
                      --[[ No_padding ]]0,
                      --[[ End_of_format ]]0
                    })
                }),
              "`%s"
            }), fields[0][0]);
    return List.iter((function (param) do
                  return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                  --[[ Char_literal ]]Block.__(12, {
                                      --[[ "," ]]44,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ Char_literal ]]Block.__(12, {
                                              --[[ "`" ]]96,
                                              --[[ String ]]Block.__(2, {
                                                  --[[ No_padding ]]0,
                                                  --[[ End_of_format ]]0
                                                })
                                            })
                                        })
                                    }),
                                  ",@ `%s"
                                }), param[0]);
                end end), fields[1]);
  end else do
    return --[[ () ]]0;
  end end 
end end

function has_explanation(unif, t3, t4) do
  match = t3.desc;
  match$1 = t4.desc;
  exit = 0;
  exit$1 = 0;
  if (typeof match == "number") then do
    if (typeof match$1 == "number") then do
      exit = 2;
    end else do
      local ___conditional___=(match$1.tag | 0);
      do
         if ___conditional___ = 0--[[ Tvar ]] then do
            exit$1 = 3;end else 
         if ___conditional___ = 3--[[ Tconstr ]] then do
            return true;end end end 
         do end
        else do
          exit = 2;
          end end
          
      end
    end end 
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 0--[[ Tvar ]] then do
          return true;end end end 
       if ___conditional___ = 3--[[ Tconstr ]] then do
          if (typeof match$1 == "number") then do
            return true;
          end else if (match$1.tag) then do
            exit = 2;
          end else do
            exit$1 = 3;
          end end  end end else 
       if ___conditional___ = 5--[[ Tfield ]] then do
          match$2 = match[3].desc;
          exit$2 = 0;
          if (typeof match$2 == "number" and typeof match$1 ~= "number") then do
            local ___conditional___=(match$1.tag | 0);
            do
               if ___conditional___ = 0--[[ Tvar ]] then do
                  exit$1 = 3;end else 
               if ___conditional___ = 3--[[ Tconstr ]] then do
                  exit$2 = 4;end else 
               if ___conditional___ = 5--[[ Tfield ]] then do
                  match$3 = match$1[3].desc;
                  if (typeof match$3 == "number") then do
                    return match[0] == match$1[0];
                  end else do
                    return false;
                  end end end end end 
               do end end
              else do
                return false;
                end end
                
            end
          end else do
            exit$2 = 4;
          end end 
          if (exit$2 == 4) then do
            if (typeof match$1 == "number") then do
              return true;
            end else do
              local ___conditional___=(match$1.tag | 0);
              do
                 if ___conditional___ = 0--[[ Tvar ]] then do
                    exit$1 = 3;end else 
                 if ___conditional___ = 3--[[ Tconstr ]] then do
                    return true;end end end 
                 do end
                else do
                  return false;
                  end end
                  
              end
            end end 
          end
           end end else 
       if ___conditional___ = 8--[[ Tvariant ]] then do
          if (typeof match$1 == "number") then do
            return false;
          end else do
            local ___conditional___=(match$1.tag | 0);
            do
               if ___conditional___ = 0--[[ Tvar ]] then do
                  exit$1 = 3;end else 
               if ___conditional___ = 8--[[ Tvariant ]] then do
                  return true;end end end 
               do end
              else do
                return false;
                end end
                
            end
          end end end else 
       do end end end
      else do
        exit$1 = 3;
        end end
        
    end
  end end 
  if (exit$1 == 3) then do
    if (typeof match$1 == "number" or match$1.tag) then do
      exit = 2;
    end else do
      return true;
    end end 
  end
   end 
  if (exit == 2 and typeof match ~= "number" and match.tag ~= --[[ Tconstr ]]3) then do
    return false;
  end
   end 
  if (typeof match$1 == "number" or match$1.tag ~= --[[ Tfield ]]5) then do
    return false;
  end else do
    return true;
  end end 
end end

function mismatch(unif, param) do
  if (param) then do
    match = param[1];
    if (match) then do
      t$prime = match[0][1];
      t = param[0][1];
      m = mismatch(unif, match[1]);
      if (m ~= undefined) then do
        return m;
      end else if (has_explanation(unif, t, t$prime)) then do
        return --[[ tuple ]]{
                t,
                t$prime
              };
      end else do
        return ;
      end end  end 
    end else do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "printtyp.ml",
              1339,
              9
            }
          };
    end end 
  end
   end 
end end

function explanation(unif, mis, ppf) do
  if (mis ~= undefined) then do
    match = mis;
    unif$1 = unif;
    t3 = match[0];
    t4 = match[1];
    ppf$1 = ppf;
    match$1 = t3.desc;
    match$2 = t4.desc;
    exit = 0;
    exit$1 = 0;
    lab;
    exit$2 = 0;
    exit$3 = 0;
    exit$4 = 0;
    if (typeof match$1 == "number") then do
      if (typeof match$2 == "number") then do
        exit = 2;
      end else do
        local ___conditional___=(match$2.tag | 0);
        do
           if ___conditional___ = 0--[[ Tvar ]] then do
              exit$4 = 9;end else 
           if ___conditional___ = 3--[[ Tconstr ]] then do
              exit = 1;end else 
           if ___conditional___ = 5--[[ Tfield ]] then do
              exit$2 = 7;end else 
           do end end end end
          else do
            exit = 2;
            end end
            
        end
      end end 
    end else do
      local ___conditional___=(match$1.tag | 0);
      do
         if ___conditional___ = 0--[[ Tvar ]] then do
            if (typeof match$2 == "number") then do
              exit$1 = 5;
            end else do
              local ___conditional___=(match$2.tag | 0);
              do
                 if ___conditional___ = 2--[[ Ttuple ]] then do
                    exit$1 = match$2[0] and 5 or 3;end else 
                 if ___conditional___ = 3--[[ Tconstr ]] then do
                    p = match$2[0];
                    if (unif$1 and t3.level < binding_time(p)) then do
                      return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@,",
                                              0,
                                              0
                                            }),
                                          --[[ Formatting_gen ]]Block.__(18, {
                                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                    --[[ End_of_format ]]0,
                                                    ""
                                                  }}),
                                              --[[ String_literal ]]Block.__(11, {
                                                  "The type constructor",
                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Break ]]Block.__(0, {
                                                          "@;<1 2>",
                                                          1,
                                                          2
                                                        }),
                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Break ]]Block.__(0, {
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                }),
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "would escape its scope",
                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Close_box ]]0,
                                                                      --[[ End_of_format ]]0
                                                                    })
                                                                })
                                                            })})
                                                    })
                                                })
                                            })
                                        }),
                                      "@,@[The type constructor@;<1 2>%a@ would escape its scope@]"
                                    }), path, p);
                    end else do
                      exit$1 = 5;
                    end end end else 
                 if ___conditional___ = 9--[[ Tunivar ]] then do
                    exit$1 = 4;end else 
                 do end end end end
                else do
                  exit$1 = 5;
                  end end
                  
              end
            end end end else 
         if ___conditional___ = 2--[[ Ttuple ]] then do
            if (match$1[0]) then do
              exit$4 = 9;
            end else if (typeof match$2 == "number") then do
              exit = 2;
            end else do
              local ___conditional___=(match$2.tag | 0);
              do
                 if ___conditional___ = 0--[[ Tvar ]] then do
                    exit$1 = 3;end else 
                 if ___conditional___ = 5--[[ Tfield ]] then do
                    exit$2 = 7;end else 
                 do end end end
                else do
                  exit = 2;
                  end end
                  
              end
            end end  end end else 
         if ___conditional___ = 3--[[ Tconstr ]] then do
            p$1 = match$1[0];
            if (typeof match$2 == "number") then do
              exit = 1;
            end else do
              local ___conditional___=(match$2.tag | 0);
              do
                 if ___conditional___ = 0--[[ Tvar ]] then do
                    if (unif$1 and t4.level < binding_time(p$1)) then do
                      return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@,",
                                              0,
                                              0
                                            }),
                                          --[[ Formatting_gen ]]Block.__(18, {
                                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                    --[[ End_of_format ]]0,
                                                    ""
                                                  }}),
                                              --[[ String_literal ]]Block.__(11, {
                                                  "The type constructor",
                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Break ]]Block.__(0, {
                                                          "@;<1 2>",
                                                          1,
                                                          2
                                                        }),
                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Break ]]Block.__(0, {
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                }),
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "would escape its scope",
                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Close_box ]]0,
                                                                      --[[ End_of_format ]]0
                                                                    })
                                                                })
                                                            })})
                                                    })
                                                })
                                            })
                                        }),
                                      "@,@[The type constructor@;<1 2>%a@ would escape its scope@]"
                                    }), path, p$1);
                    end else do
                      exit$4 = 9;
                    end end end else 
                 if ___conditional___ = 5--[[ Tfield ]] then do
                    exit$2 = 7;end else 
                 do end end end
                else do
                  exit = 2;
                  end end
                  
              end
            end end end else 
         if ___conditional___ = 8--[[ Tvariant ]] then do
            if (typeof match$2 == "number") then do
              exit = 2;
            end else do
              local ___conditional___=(match$2.tag | 0);
              do
                 if ___conditional___ = 0--[[ Tvar ]] then do
                    exit$4 = 9;end else 
                 if ___conditional___ = 5--[[ Tfield ]] then do
                    exit$2 = 7;end else 
                 if ___conditional___ = 8--[[ Tvariant ]] then do
                    row1 = row_repr_aux(--[[ [] ]]0, match$1[0]);
                    row2 = row_repr_aux(--[[ [] ]]0, match$2[0]);
                    match$3 = row1.row_fields;
                    match$4 = row1.row_closed;
                    match$5 = row2.row_fields;
                    match$6 = row2.row_closed;
                    if (match$3) then do
                      if (not match$3[1] and match$4 and match$5) then do
                        if (match$5[1] or not match$6) then do
                          return --[[ () ]]0;
                        end else do
                          l1 = match$3[0][0];
                          if (l1 == match$5[0][0]) then do
                            return Curry._1(Format.fprintf(ppf$1, --[[ Format ]]{
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Break ]]Block.__(0, {
                                                    "@,",
                                                    0,
                                                    0
                                                  }),
                                                --[[ String_literal ]]Block.__(11, {
                                                    "Types for tag `",
                                                    --[[ String ]]Block.__(2, {
                                                        --[[ No_padding ]]0,
                                                        --[[ String_literal ]]Block.__(11, {
                                                            " are incompatible",
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })
                                                  })
                                              }),
                                            "@,Types for tag `%s are incompatible"
                                          }), l1);
                          end else do
                            return --[[ () ]]0;
                          end end 
                        end end 
                      end
                       end 
                    end else if (match$4) then do
                      exit$5 = 0;
                      if (match$5 or not match$6) then do
                        exit$5 = 11;
                      end else do
                        return Format.fprintf(ppf$1, --[[ Format ]]{
                                    --[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Break ]]Block.__(0, {
                                            "@,",
                                            0,
                                            0
                                          }),
                                        --[[ String_literal ]]Block.__(11, {
                                            "These two variant types have no intersection",
                                            --[[ End_of_format ]]0
                                          })
                                      }),
                                    "@,These two variant types have no intersection"
                                  });
                      end end 
                      if (exit$5 == 11) then do
                        return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@,",
                                                0,
                                                0
                                              }),
                                            --[[ Formatting_gen ]]Block.__(18, {
                                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                      --[[ End_of_format ]]0,
                                                      ""
                                                    }}),
                                                --[[ String_literal ]]Block.__(11, {
                                                    "The first variant type does not allow tag(s)",
                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                        --[[ Break ]]Block.__(0, {
                                                            "@ ",
                                                            1,
                                                            0
                                                          }),
                                                        --[[ Formatting_gen ]]Block.__(18, {
                                                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "<hov>",
                                                                      --[[ End_of_format ]]0
                                                                    }),
                                                                  "<hov>"
                                                                }}),
                                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                    --[[ Close_box ]]0,
                                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                                        --[[ Close_box ]]0,
                                                                        --[[ End_of_format ]]0
                                                                      })
                                                                  })})
                                                          })
                                                      })
                                                  })
                                              })
                                          }),
                                        "@,@[The first variant type does not allow tag(s)@ @[<hov>%a@]@]"
                                      }), print_tags, match$5);
                      end
                       end 
                    end
                     end  end 
                    if (match$5 or not match$6) then do
                      return --[[ () ]]0;
                    end else do
                      return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@,",
                                              0,
                                              0
                                            }),
                                          --[[ Formatting_gen ]]Block.__(18, {
                                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                    --[[ End_of_format ]]0,
                                                    ""
                                                  }}),
                                              --[[ String_literal ]]Block.__(11, {
                                                  "The second variant type does not allow tag(s)",
                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Break ]]Block.__(0, {
                                                          "@ ",
                                                          1,
                                                          0
                                                        }),
                                                      --[[ Formatting_gen ]]Block.__(18, {
                                                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "<hov>",
                                                                    --[[ End_of_format ]]0
                                                                  }),
                                                                "<hov>"
                                                              }}),
                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                  --[[ Close_box ]]0,
                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Close_box ]]0,
                                                                      --[[ End_of_format ]]0
                                                                    })
                                                                })})
                                                        })
                                                    })
                                                })
                                            })
                                        }),
                                      "@,@[The second variant type does not allow tag(s)@ @[<hov>%a@]@]"
                                    }), print_tags, match$3);
                    end end end end end 
                 do end end
                else do
                  exit = 2;
                  end end
                  
              end
            end end end else 
         if ___conditional___ = 9--[[ Tunivar ]] then do
            if (typeof match$2 == "number") then do
              exit = 2;
            end else do
              local ___conditional___=(match$2.tag | 0);
              do
                 if ___conditional___ = 0--[[ Tvar ]] then do
                    exit$1 = 4;end else 
                 if ___conditional___ = 5--[[ Tfield ]] then do
                    exit$2 = 7;end else 
                 do end end end
                else do
                  exit = 2;
                  end end
                  
              end
            end end end else 
         do end end end end end end
        else do
          exit$4 = 9;
          end end
          
      end
    end end 
    if (exit$4 == 9) then do
      if (typeof match$2 == "number" or match$2.tag) then do
        exit$3 = 8;
      end else do
        exit$1 = 5;
      end end 
    end
     end 
    if (exit$3 == 8) then do
      if (typeof match$1 == "number" or match$1.tag ~= --[[ Tfield ]]5) then do
        exit$2 = 7;
      end else do
        lab = match$1[0];
        exit$1 = 6;
      end end 
    end
     end 
    if (exit$2 == 7) then do
      if (typeof match$2 == "number" or match$2.tag ~= --[[ Tfield ]]5) then do
        exit = 2;
      end else do
        lab = match$2[0];
        exit$1 = 6;
      end end 
    end
     end 
    local ___conditional___=(exit$1);
    do
       if ___conditional___ = 3 then do
          return Format.fprintf(ppf$1, --[[ Format ]]{
                      --[[ Formatting_lit ]]Block.__(17, {
                          --[[ Break ]]Block.__(0, {
                              "@,",
                              0,
                              0
                            }),
                          --[[ String_literal ]]Block.__(11, {
                              "Self type cannot escape its class",
                              --[[ End_of_format ]]0
                            })
                        }),
                      "@,Self type cannot escape its class"
                    });end end end 
       if ___conditional___ = 4 then do
          return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                          --[[ Formatting_lit ]]Block.__(17, {
                              --[[ Break ]]Block.__(0, {
                                  "@,",
                                  0,
                                  0
                                }),
                              --[[ String_literal ]]Block.__(11, {
                                  "The universal variable ",
                                  --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                          " would escape its scope",
                                          --[[ End_of_format ]]0
                                        })})
                                })
                            }),
                          "@,The universal variable %a would escape its scope"
                        }), type_expr$1, is_Tunivar(t3) and t3 or t4);end end end 
       if ___conditional___ = 5 then do
          match$7 = is_Tvar(t3) and --[[ tuple ]]{
              t3,
              t4
            } or --[[ tuple ]]{
              t4,
              t3
            };
          t$prime = match$7[1];
          t = match$7[0];
          if (occur_in(empty, t, t$prime)) then do
            return Curry._4(Format.fprintf(ppf$1, --[[ Format ]]{
                            --[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@,",
                                    0,
                                    0
                                  }),
                                --[[ Formatting_gen ]]Block.__(18, {
                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "<hov>",
                                              --[[ End_of_format ]]0
                                            }),
                                          "<hov>"
                                        }}),
                                    --[[ String_literal ]]Block.__(11, {
                                        "The type variable ",
                                        --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                                " occurs inside",
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Close_box ]]0,
                                                            --[[ End_of_format ]]0
                                                          })})
                                                  })
                                              })})
                                      })
                                  })
                              }),
                            "@,@[<hov>The type variable %a occurs inside@ %a@]"
                          }), type_expr$1, t, type_expr$1, t$prime);
          end else do
            return Curry._3(Format.fprintf(ppf$1, --[[ Format ]]{
                            --[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@,",
                                    0,
                                    0
                                  }),
                                --[[ Formatting_gen ]]Block.__(18, {
                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "<hov>",
                                              --[[ End_of_format ]]0
                                            }),
                                          "<hov>"
                                        }}),
                                    --[[ String_literal ]]Block.__(11, {
                                        "This instance of ",
                                        --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                                " is ambiguous:",
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ String ]]Block.__(2, {
                                                        --[[ No_padding ]]0,
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Close_box ]]0,
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })
                                                  })
                                              })})
                                      })
                                  })
                              }),
                            "@,@[<hov>This instance of %a is ambiguous:@ %s@]"
                          }), type_expr$1, t$prime, "it would escape the scope of its equation");
          end end end end end 
       if ___conditional___ = 6 then do
          if (lab == dummy_method) then do
            return Format.fprintf(ppf$1, --[[ Format ]]{
                        --[[ Formatting_lit ]]Block.__(17, {
                            --[[ Break ]]Block.__(0, {
                                "@,",
                                0,
                                0
                              }),
                            --[[ String_literal ]]Block.__(11, {
                                "Self type cannot be unified with a closed object type",
                                --[[ End_of_format ]]0
                              })
                          }),
                        "@,Self type cannot be unified with a closed object type"
                      });
          end else do
            exit = 2;
          end end end else 
       do
      
    end
    local ___conditional___=(exit);
    do
       if ___conditional___ = 1 then do
          return Curry._1(Format.fprintf(ppf$1, --[[ Format ]]{
                          --[[ Formatting_lit ]]Block.__(17, {
                              --[[ Break ]]Block.__(0, {
                                  "@,",
                                  0,
                                  0
                                }),
                              --[[ Formatting_gen ]]Block.__(18, {
                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                        --[[ End_of_format ]]0,
                                        ""
                                      }}),
                                  --[[ String_literal ]]Block.__(11, {
                                      "The ",
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ String_literal ]]Block.__(11, {
                                              " object type has an abstract row, it cannot be closed",
                                              --[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Close_box ]]0,
                                                  --[[ End_of_format ]]0
                                                })
                                            })
                                        })
                                    })
                                })
                            }),
                          "@,@[The %s object type has an abstract row, it cannot be closed@]"
                        }), t4.desc == --[[ Tnil ]]0 and "first" or "second");end end end 
       if ___conditional___ = 2 then do
          if (typeof match$1 ~= "number") then do
            local ___conditional___=(match$1.tag | 0);
            do
               if ___conditional___ = 3--[[ Tconstr ]]
               or ___conditional___ = 5--[[ Tfield ]] then do
                  l = match$1[0];
                  match$8 = match$1[3].desc;
                  exit$6 = 0;
                  if (typeof match$8 == "number" and typeof match$2 ~= "number") then do
                    local ___conditional___=(match$2.tag | 0);
                    do
                       if ___conditional___ = 3--[[ Tconstr ]] then do
                          exit$6 = 4;end else 
                       if ___conditional___ = 5--[[ Tfield ]] then do
                          match$9 = match$2[3].desc;
                          if (typeof match$9 == "number" and l == match$2[0]) then do
                            return Curry._1(Format.fprintf(ppf$1, --[[ Format ]]{
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Break ]]Block.__(0, {
                                                    "@,",
                                                    0,
                                                    0
                                                  }),
                                                --[[ String_literal ]]Block.__(11, {
                                                    "Types for method ",
                                                    --[[ String ]]Block.__(2, {
                                                        --[[ No_padding ]]0,
                                                        --[[ String_literal ]]Block.__(11, {
                                                            " are incompatible",
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })
                                                  })
                                              }),
                                            "@,Types for method %s are incompatible"
                                          }), l);
                          end else do
                            return --[[ () ]]0;
                          end end end end end 
                       do end
                      else do
                        return --[[ () ]]0;
                        end end
                        
                    end
                  end else do
                    exit$6 = 4;
                  end end 
                  if (exit$6 == 4) then do
                    exit$7 = 0;
                    if (typeof match$2 == "number" or match$2.tag == --[[ Tconstr ]]3) then do
                      exit$7 = 5;
                    end else do
                      return --[[ () ]]0;
                    end end 
                    if (exit$7 == 5) then do
                      return Curry._1(Format.fprintf(ppf$1, --[[ Format ]]{
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@,",
                                              0,
                                              0
                                            }),
                                          --[[ Formatting_gen ]]Block.__(18, {
                                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                    --[[ End_of_format ]]0,
                                                    ""
                                                  }}),
                                              --[[ String_literal ]]Block.__(11, {
                                                  "The second object type has no method ",
                                                  --[[ String ]]Block.__(2, {
                                                      --[[ No_padding ]]0,
                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                          --[[ Close_box ]]0,
                                                          --[[ End_of_format ]]0
                                                        })
                                                    })
                                                })
                                            })
                                        }),
                                      "@,@[The second object type has no method %s@]"
                                    }), l);
                    end
                     end 
                  end
                   end end else 
               do end end
              else do
                return --[[ () ]]0;
                end end
                
            end
          end
           end 
          if (typeof match$2 == "number" or match$2.tag ~= --[[ Tfield ]]5) then do
            return --[[ () ]]0;
          end else do
            return Curry._1(Format.fprintf(ppf$1, --[[ Format ]]{
                            --[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@,",
                                    0,
                                    0
                                  }),
                                --[[ Formatting_gen ]]Block.__(18, {
                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                          --[[ End_of_format ]]0,
                                          ""
                                        }}),
                                    --[[ String_literal ]]Block.__(11, {
                                        "The first object type has no method ",
                                        --[[ String ]]Block.__(2, {
                                            --[[ No_padding ]]0,
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Close_box ]]0,
                                                --[[ End_of_format ]]0
                                              })
                                          })
                                      })
                                  })
                              }),
                            "@,@[The first object type has no method %s@]"
                          }), match$2[0]);
          end end end else 
       do end
      
    end
  end else do
    return --[[ () ]]0;
  end end 
end end

function path_same_name(_p1, _p2) do
  while(true) do
    p2 = _p2;
    p1 = _p1;
    local ___conditional___=(p1.tag | 0);
    do
       if ___conditional___ = 0--[[ Pident ]] then do
          local ___conditional___=(p2.tag | 0);
          do
             if ___conditional___ = 0--[[ Pident ]] then do
                id1 = p1[0];
                id2 = p2[0];
                if (equal(id1, id2) and not Caml_obj.caml_equal(id1, id2)) then do
                  add_unique(id1);
                  return add_unique(id2);
                end else do
                  return 0;
                end end end end end 
             if ___conditional___ = 1--[[ Pdot ]]
             or ___conditional___ = 2--[[ Papply ]] then do
                return --[[ () ]]0;end end end 
             do
            
          endend end end 
       if ___conditional___ = 1--[[ Pdot ]] then do
          local ___conditional___=(p2.tag | 0);
          do
             if ___conditional___ = 1--[[ Pdot ]] then do
                if (p1[1] == p2[1]) then do
                  _p2 = p2[0];
                  _p1 = p1[0];
                  continue ;
                end else do
                  return --[[ () ]]0;
                end end end end end 
             if ___conditional___ = 0--[[ Pident ]]
             or ___conditional___ = 2--[[ Papply ]] then do
                return --[[ () ]]0;end end end 
             do
            
          endend end end 
       if ___conditional___ = 2--[[ Papply ]] then do
          local ___conditional___=(p2.tag | 0);
          do
             if ___conditional___ = 0--[[ Pident ]]
             or ___conditional___ = 1--[[ Pdot ]] then do
                return --[[ () ]]0;end end end 
             if ___conditional___ = 2--[[ Papply ]] then do
                path_same_name(p1[0], p2[0]);
                _p2 = p2[1];
                _p1 = p1[1];
                continue ;end end end 
             do
            
          endend end end 
       do
      
    end
  end;
end end

function type_same_name(t1, t2) do
  match = repr(t1).desc;
  match$1 = repr(t2).desc;
  if (typeof match == "number" or not (match.tag == --[[ Tconstr ]]3 and not (typeof match$1 == "number" or match$1.tag ~= --[[ Tconstr ]]3))) then do
    return --[[ () ]]0;
  end else do
    return path_same_name(best_type_path(match[0])[0], best_type_path(match$1[0])[0]);
  end end 
end end

function trace_same_names(_param) do
  while(true) do
    param = _param;
    if (param) then do
      match = param[1];
      if (match) then do
        match$1 = match[0];
        match$2 = param[0];
        type_same_name(match$2[0], match$1[0]);
        type_same_name(match$2[1], match$1[1]);
        _param = match[1];
        continue ;
      end else do
        return --[[ () ]]0;
      end end 
    end else do
      return --[[ () ]]0;
    end end 
  end;
end end

function report_unification_error(ppf, env, unifOpt, tr, txt1, txt2) do
  unif = unifOpt ~= undefined and unifOpt or true;
  return wrap_printing_env(env, (function (param) do
                unif$1 = unif;
                tr$1 = tr;
                txt1$1 = txt1;
                ppf$1 = ppf;
                txt2$1 = txt2;
                reset(--[[ () ]]0);
                trace_same_names(tr$1);
                tr$2 = List.map((function (param) do
                        return --[[ tuple ]]{
                                param[0],
                                hide_variant_name(param[1])
                              };
                      end end), tr$1);
                mis = mismatch(unif$1, tr$2);
                if (tr$2) then do
                  match = tr$2[1];
                  if (match) then do
                    try do
                      tr$3 = filter_trace(mis == undefined, match[1]);
                      match$1 = may_prepare_expansion(tr$3 == --[[ [] ]]0, tr$2[0]);
                      t1 = match$1[0];
                      match$2 = may_prepare_expansion(tr$3 == --[[ [] ]]0, match[0]);
                      t2 = match$2[0];
                      print_labels.contents = not classic.contents;
                      tr$4 = List.map(prepare_expansion, tr$3);
                      Curry.app(Format.fprintf(ppf$1, --[[ Format ]]{
                                --[[ Formatting_gen ]]Block.__(18, {
                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "<v>",
                                              --[[ End_of_format ]]0
                                            }),
                                          "<v>"
                                        }}),
                                    --[[ Formatting_gen ]]Block.__(18, {
                                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                              --[[ End_of_format ]]0,
                                              ""
                                            }}),
                                        --[[ Theta ]]Block.__(16, {--[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Break ]]Block.__(0, {
                                                    "@;<1 2>",
                                                    1,
                                                    2
                                                  }),
                                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                        --[[ Break ]]Block.__(0, {
                                                            "@ ",
                                                            1,
                                                            0
                                                          }),
                                                        --[[ Theta ]]Block.__(16, {--[[ Formatting_lit ]]Block.__(17, {
                                                                --[[ Break ]]Block.__(0, {
                                                                    "@;<1 2>",
                                                                    1,
                                                                    2
                                                                  }),
                                                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                        --[[ Close_box ]]0,
                                                                        --[[ Alpha ]]Block.__(15, {--[[ Theta ]]Block.__(16, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                    --[[ Close_box ]]0,
                                                                                    --[[ End_of_format ]]0
                                                                                  })})})
                                                                      })})
                                                              })})
                                                      })})
                                              })})
                                      })
                                  }),
                                "@[<v>@[%t@;<1 2>%a@ %t@;<1 2>%a@]%a%t@]"
                              }), {
                            txt1$1,
                            (function (param, param$1) do
                                return type_expansion(t1, param, param$1);
                              end end),
                            match$1[1],
                            txt2$1,
                            (function (param, param$1) do
                                return type_expansion(t2, param, param$1);
                              end end),
                            match$2[1],
                            (function (param, param$1) do
                                return trace(false, "is not compatible with type", param, param$1);
                              end end),
                            tr$4,
                            (function (param) do
                                return explanation(unif$1, mis, param);
                              end end)
                          });
                      print_labels.contents = true;
                      return --[[ () ]]0;
                    end
                    catch (exn)do
                      print_labels.contents = true;
                      throw exn;
                    end
                  end else do
                    throw {
                          Caml_builtin_exceptions.assert_failure,
                          --[[ tuple ]]{
                            "printtyp.ml",
                            1438,
                            20
                          }
                        };
                  end end 
                end else do
                  throw {
                        Caml_builtin_exceptions.assert_failure,
                        --[[ tuple ]]{
                          "printtyp.ml",
                          1438,
                          20
                        }
                      };
                end end 
              end end));
end end

function trace$1(fst, keep_last, txt, ppf, tr) do
  print_labels.contents = not classic.contents;
  trace_same_names(tr);
  try do
    if (tr) then do
      match = tr[1];
      if (match) then do
        if (fst) then do
          trace(fst, txt, ppf, --[[ :: ]]{
                tr[0],
                --[[ :: ]]{
                  match[0],
                  filter_trace(keep_last, match[1])
                }
              });
        end else do
          trace(fst, txt, ppf, filter_trace(keep_last, tr));
        end end 
        print_labels.contents = true;
        return --[[ () ]]0;
      end else do
        return --[[ () ]]0;
      end end 
    end else do
      return --[[ () ]]0;
    end end 
  end
  catch (exn)do
    print_labels.contents = true;
    throw exn;
  end
end end

function class_types(env, cty1, cty2) do
  return match_class_types(undefined, env, cty1, cty2);
end end

function class_type_declarations(env, cty1, cty2) do
  return match_class_declarations(env, cty1.clty_params, cty1.clty_type, cty2.clty_params, cty2.clty_type);
end end

function class_declarations(env, cty1, cty2) do
  match = cty1.cty_new;
  match$1 = cty2.cty_new;
  if (match == undefined and match$1 ~= undefined) then do
    return --[[ :: ]]{
            --[[ CM_Virtual_class ]]0,
            --[[ [] ]]0
          };
  end
   end 
  return match_class_declarations(env, cty1.cty_params, cty1.cty_type, cty2.cty_params, cty2.cty_type);
end end

function include_err(ppf, param) do
  if (typeof param == "number") then do
    return Format.fprintf(ppf, --[[ Format ]]{
                --[[ String_literal ]]Block.__(11, {
                    "A class cannot be changed from virtual to concrete",
                    --[[ End_of_format ]]0
                  }),
                "A class cannot be changed from virtual to concrete"
              });
  end else do
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ = 0--[[ CM_Parameter_arity_mismatch ]] then do
          return Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "The classes do not have the same number of type parameters",
                          --[[ End_of_format ]]0
                        }),
                      "The classes do not have the same number of type parameters"
                    });end end end 
       if ___conditional___ = 1--[[ CM_Type_parameter_mismatch ]] then do
          return report_unification_error(ppf, param[0], false, param[1], (function (ppf) do
                        return Format.fprintf(ppf, --[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "A type parameter has type",
                                        --[[ End_of_format ]]0
                                      }),
                                    "A type parameter has type"
                                  });
                      end end), (function (ppf) do
                        return Format.fprintf(ppf, --[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "but is expected to have type",
                                        --[[ End_of_format ]]0
                                      }),
                                    "but is expected to have type"
                                  });
                      end end));end end end 
       if ___conditional___ = 2--[[ CM_Class_type_mismatch ]] then do
          cty2 = param[2];
          cty1 = param[1];
          return wrap_printing_env(param[0], (function (param) do
                        return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                                        --[[ Formatting_gen ]]Block.__(18, {
                                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                  --[[ End_of_format ]]0,
                                                  ""
                                                }}),
                                            --[[ String_literal ]]Block.__(11, {
                                                "The class type",
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@;<1 2>",
                                                        1,
                                                        2
                                                      }),
                                                    --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Break ]]Block.__(0, {
                                                                "@ ",
                                                                1,
                                                                0
                                                              }),
                                                            --[[ String ]]Block.__(2, {
                                                                --[[ No_padding ]]0,
                                                                --[[ Formatting_lit ]]Block.__(17, {
                                                                    --[[ Break ]]Block.__(0, {
                                                                        "@;<1 2>",
                                                                        1,
                                                                        2
                                                                      }),
                                                                    --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                            --[[ Close_box ]]0,
                                                                            --[[ End_of_format ]]0
                                                                          })})
                                                                  })
                                                              })
                                                          })})
                                                  })
                                              })
                                          }),
                                        "@[The class type@;<1 2>%a@ %s@;<1 2>%a@]"
                                      }), class_type$2, cty1, "is not matched by the class type", class_type$2, cty2);
                      end end));end end end 
       if ___conditional___ = 3--[[ CM_Parameter_mismatch ]] then do
          return report_unification_error(ppf, param[0], false, param[1], (function (ppf) do
                        return Format.fprintf(ppf, --[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "A parameter has type",
                                        --[[ End_of_format ]]0
                                      }),
                                    "A parameter has type"
                                  });
                      end end), (function (ppf) do
                        return Format.fprintf(ppf, --[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "but is expected to have type",
                                        --[[ End_of_format ]]0
                                      }),
                                    "but is expected to have type"
                                  });
                      end end));end end end 
       if ___conditional___ = 4--[[ CM_Val_type_mismatch ]] then do
          lab = param[0];
          return report_unification_error(ppf, param[1], false, param[2], (function (ppf) do
                        return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                        --[[ String_literal ]]Block.__(11, {
                                            "The instance variable ",
                                            --[[ String ]]Block.__(2, {
                                                --[[ No_padding ]]0,
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "has type",
                                                        --[[ End_of_format ]]0
                                                      })
                                                  })
                                              })
                                          }),
                                        "The instance variable %s@ has type"
                                      }), lab);
                      end end), (function (ppf) do
                        return Format.fprintf(ppf, --[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "but is expected to have type",
                                        --[[ End_of_format ]]0
                                      }),
                                    "but is expected to have type"
                                  });
                      end end));end end end 
       if ___conditional___ = 5--[[ CM_Meth_type_mismatch ]] then do
          lab$1 = param[0];
          return report_unification_error(ppf, param[1], false, param[2], (function (ppf) do
                        return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                        --[[ String_literal ]]Block.__(11, {
                                            "The method ",
                                            --[[ String ]]Block.__(2, {
                                                --[[ No_padding ]]0,
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "has type",
                                                        --[[ End_of_format ]]0
                                                      })
                                                  })
                                              })
                                          }),
                                        "The method %s@ has type"
                                      }), lab$1);
                      end end), (function (ppf) do
                        return Format.fprintf(ppf, --[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "but is expected to have type",
                                        --[[ End_of_format ]]0
                                      }),
                                    "but is expected to have type"
                                  });
                      end end));end end end 
       if ___conditional___ = 6--[[ CM_Non_mutable_value ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "The non-mutable instance variable ",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ String_literal ]]Block.__(11, {
                                          " cannot become mutable",
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Close_box ]]0,
                                              --[[ End_of_format ]]0
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[The non-mutable instance variable %s cannot become mutable@]"
                        }), param[0]);end end end 
       if ___conditional___ = 7--[[ CM_Non_concrete_value ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "The virtual instance variable ",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ String_literal ]]Block.__(11, {
                                          " cannot become concrete",
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Close_box ]]0,
                                              --[[ End_of_format ]]0
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[The virtual instance variable %s cannot become concrete@]"
                        }), param[0]);end end end 
       if ___conditional___ = 8--[[ CM_Missing_value ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "The first class type has no instance variable ",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Close_box ]]0,
                                          --[[ End_of_format ]]0
                                        })
                                    })
                                })
                            }),
                          "@[The first class type has no instance variable %s@]"
                        }), param[0]);end end end 
       if ___conditional___ = 9--[[ CM_Missing_method ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "The first class type has no method ",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Close_box ]]0,
                                          --[[ End_of_format ]]0
                                        })
                                    })
                                })
                            }),
                          "@[The first class type has no method %s@]"
                        }), param[0]);end end end 
       if ___conditional___ = 10--[[ CM_Hide_public ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "The public method ",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ String_literal ]]Block.__(11, {
                                          " cannot be hidden",
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Close_box ]]0,
                                              --[[ End_of_format ]]0
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[The public method %s cannot be hidden@]"
                        }), param[0]);end end end 
       if ___conditional___ = 11--[[ CM_Hide_virtual ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "The virtual ",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Char_literal ]]Block.__(12, {
                                          --[[ " " ]]32,
                                          --[[ String ]]Block.__(2, {
                                              --[[ No_padding ]]0,
                                              --[[ String_literal ]]Block.__(11, {
                                                  " cannot be hidden",
                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Close_box ]]0,
                                                      --[[ End_of_format ]]0
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[The virtual %s %s cannot be hidden@]"
                        }), param[0], param[1]);end end end 
       if ___conditional___ = 12--[[ CM_Public_method ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "The public method ",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ String_literal ]]Block.__(11, {
                                          " cannot become private",
                                          --[[ End_of_format ]]0
                                        })
                                    })
                                })
                            }),
                          "@[The public method %s cannot become private"
                        }), param[0]);end end end 
       if ___conditional___ = 13--[[ CM_Private_method ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "The private method ",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ String_literal ]]Block.__(11, {
                                      " cannot become public",
                                      --[[ End_of_format ]]0
                                    })
                                })
                            }),
                          "The private method %s cannot become public"
                        }), param[0]);end end end 
       if ___conditional___ = 14--[[ CM_Virtual_method ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "The virtual method ",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ String_literal ]]Block.__(11, {
                                          " cannot become concrete",
                                          --[[ End_of_format ]]0
                                        })
                                    })
                                })
                            }),
                          "@[The virtual method %s cannot become concrete"
                        }), param[0]);end end end 
       do
      
    end
  end end 
end end

function report_error$3(ppf, param) do
  if (param) then do
    print_errs = function (ppf, errs) do
      return List.iter((function (err) do
                    return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                    --[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Break ]]Block.__(0, {
                                            "@ ",
                                            1,
                                            0
                                          }),
                                        --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                      }),
                                    "@ %a"
                                  }), include_err, err);
                  end end), errs);
    end end;
    return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<v>",
                                  --[[ End_of_format ]]0
                                }),
                              "<v>"
                            }}),
                        --[[ Alpha ]]Block.__(15, {--[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                    --[[ Close_box ]]0,
                                    --[[ End_of_format ]]0
                                  })})})
                      }),
                    "@[<v>%a%a@]"
                  }), include_err, param[0], print_errs, param[1]);
  end else do
    return --[[ () ]]0;
  end end 
end end

Dont_match = Caml_exceptions.create("Ocaml_typedtree_test.Includecore.Dont_match");

function private_flags(decl1, decl2) do
  match = decl1.type_private;
  match$1 = decl2.type_private;
  if (match or not match$1) then do
    return true;
  end else if (decl2.type_kind == --[[ Type_abstract ]]0) then do
    if (decl2.type_manifest == undefined) then do
      return true;
    end else do
      return decl1.type_kind ~= --[[ Type_abstract ]]0;
    end end 
  end else do
    return false;
  end end  end 
end end

function is_absrow(env, ty) do
  match = ty.desc;
  if (typeof match == "number" or match.tag ~= --[[ Tconstr ]]3) then do
    return false;
  end else do
    local ___conditional___=(match[0].tag | 0);
    do
       if ___conditional___ = 0--[[ Pident ]] then do
          match$1 = expand_head(env, ty);
          match$2 = match$1.desc;
          if (typeof match$2 == "number") then do
            return false;
          end else do
            local ___conditional___=(match$2.tag | 0);
            do
               if ___conditional___ = 4--[[ Tobject ]]
               or ___conditional___ = 8--[[ Tvariant ]] then do
                  return true;end end end 
               do
              else do
                return false;
                end end
                
            end
          end end end end end 
       if ___conditional___ = 1--[[ Pdot ]]
       or ___conditional___ = 2--[[ Papply ]] then do
          return false;end end end 
       do
      
    end
  end end 
end end

function type_manifest(env, ty1, params1, ty2, params2, priv2) do
  ty1$prime = expand_head(env, ty1);
  ty2$prime = expand_head(env, ty2);
  match = ty1$prime.desc;
  match$1 = ty2$prime.desc;
  if (typeof match ~= "number") then do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 4--[[ Tobject ]] then do
          if (typeof match$1 ~= "number" and match$1.tag == --[[ Tobject ]]4) then do
            fi2 = match$1[0];
            if (is_absrow(env, flatten_fields(fi2)[1])) then do
              match$2 = flatten_fields(fi2);
              if (equal$4(env, true, --[[ :: ]]{
                      ty1,
                      params1
                    }, --[[ :: ]]{
                      match$2[1],
                      params2
                    })) then do
                match$3 = flatten_fields(match[0]);
                match$4 = match$3[1].desc;
                tmp;
                if (typeof match$4 == "number") then do
                  tmp = true;
                end else do
                  local ___conditional___=(match$4.tag | 0);
                  do
                     if ___conditional___ = 0--[[ Tvar ]]
                     or ___conditional___ = 3--[[ Tconstr ]] then do
                        tmp = true;end else 
                     do end end
                    else do
                      tmp = false;
                      end end
                      
                  end
                end end 
                if (tmp) then do
                  match$5 = associate_fields(match$3[0], match$2[0]);
                  if (match$5[2] == --[[ [] ]]0) then do
                    match$6 = List.split(List.map((function (param) do
                                return --[[ tuple ]]{
                                        param[2],
                                        param[4]
                                      };
                              end end), match$5[0]));
                    return equal$4(env, true, Pervasives.$at(params1, match$6[0]), Pervasives.$at(params2, match$6[1]));
                  end else do
                    return false;
                  end end 
                end else do
                  return false;
                end end 
              end else do
                return false;
              end end 
            end
             end 
          end
           end end else 
       if ___conditional___ = 8--[[ Tvariant ]] then do
          if (typeof match$1 ~= "number" and match$1.tag == --[[ Tvariant ]]8) then do
            row2 = match$1[0];
            if (is_absrow(env, row_more(row2))) then do
              row1 = row_repr_aux(--[[ [] ]]0, match[0]);
              row2$1 = row_repr_aux(--[[ [] ]]0, row2);
              if (equal$4(env, true, --[[ :: ]]{
                      ty1,
                      params1
                    }, --[[ :: ]]{
                      row2$1.row_more,
                      params2
                    })) then do
                match$7 = row1.row_more;
                match$8 = match$7.desc;
                tmp$1;
                if (typeof match$8 == "number") then do
                  tmp$1 = true;
                end else do
                  local ___conditional___=(match$8.tag | 0);
                  do
                     if ___conditional___ = 0--[[ Tvar ]]
                     or ___conditional___ = 3--[[ Tconstr ]] then do
                        tmp$1 = true;end else 
                     do end end
                    else do
                      tmp$1 = false;
                      end end
                      
                  end
                end end 
                if (tmp$1) then do
                  match$9 = merge_row_fields(row1.row_fields, row2$1.row_fields);
                  if ((not row2$1.row_closed or row1.row_closed and filter_row_fields(false, match$9[0]) == --[[ [] ]]0) and List.for_all((function (param) do
                            match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                            if (typeof match == "number" or match.tag) then do
                              return true;
                            end else do
                              return false;
                            end end 
                          end end), match$9[1])) then do
                    to_equal = do
                      contents: List.combine(params1, params2)
                    end;
                    if (List.for_all((function (param) do
                              match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                              match$1 = row_field_repr_aux(--[[ [] ]]0, param[2]);
                              if (typeof match == "number") then do
                                if (typeof match$1 == "number" or match$1.tag) then do
                                  return true;
                                end else do
                                  return false;
                                end end 
                              end else if (match.tag) then do
                                tl1 = match[1];
                                if (typeof match$1 == "number" or not match$1.tag) then do
                                  return false;
                                end else do
                                  tl2 = match$1[1];
                                  if (List.length(tl1) == List.length(tl2) and match[0] == match$1[0]) then do
                                    to_equal.contents = Pervasives.$at(List.combine(tl1, tl2), to_equal.contents);
                                    return true;
                                  end else do
                                    return false;
                                  end end 
                                end end 
                              end else do
                                match$2 = match[0];
                                if (match$2 ~= undefined) then do
                                  t2;
                                  if (typeof match$1 == "number") then do
                                    return false;
                                  end else if (match$1.tag) then do
                                    if (match$1[0]) then do
                                      return false;
                                    end else do
                                      match$3 = match$1[1];
                                      if (match$3 and not match$3[1]) then do
                                        t2 = match$3[0];
                                      end else do
                                        return false;
                                      end end 
                                    end end 
                                  end else do
                                    match$4 = match$1[0];
                                    if (match$4 ~= undefined) then do
                                      t2 = match$4;
                                    end else do
                                      return false;
                                    end end 
                                  end end  end 
                                  to_equal.contents = --[[ :: ]]{
                                    --[[ tuple ]]{
                                      match$2,
                                      t2
                                    },
                                    to_equal.contents
                                  };
                                  return true;
                                end else if (typeof match$1 == "number") then do
                                  return false;
                                end else if (match$1.tag) then do
                                  if (match$1[0] and not match$1[1]) then do
                                    return true;
                                  end else do
                                    return false;
                                  end end 
                                end else do
                                  return match$1[0] == undefined;
                                end end  end  end 
                              end end  end 
                            end end), match$9[2])) then do
                      match$10 = List.split(to_equal.contents);
                      return equal$4(env, true, match$10[0], match$10[1]);
                    end else do
                      return false;
                    end end 
                  end else do
                    return false;
                  end end 
                end else do
                  return false;
                end end 
              end else do
                return false;
              end end 
            end
             end 
          end
           end end else 
       do end end end
      else do
        end end
        
    end
  end
   end 
  check_super = function (ty1) do
    if (equal$4(env, true, --[[ :: ]]{
            ty1,
            params1
          }, --[[ :: ]]{
            ty2,
            params2
          })) then do
      return true;
    end else if (priv2 == --[[ Private ]]0) then do
      try do
        return check_super(try_expand_once_opt(env, expand_head(env, ty1)));
      end
      catch (exn)do
        if (exn == Cannot_expand) then do
          return false;
        end else do
          throw exn;
        end end 
      end
    end else do
      return false;
    end end  end 
  end end;
  return check_super(ty1);
end end

function report_type_mismatch(first, second, decl, ppf) do
  return (function (param) do
      return List.iter((function (err) do
                    if (err == --[[ Manifest ]]4) then do
                      return --[[ () ]]0;
                    end else do
                      return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                  --[[ "." ]]46,
                                                  --[[ End_of_format ]]0
                                                })})
                                        }),
                                      "@ %a."
                                    }), (function (param, param$1) do
                                    first$1 = first;
                                    second$1 = second;
                                    decl$1 = decl;
                                    ppf = param;
                                    err = param$1;
                                    if (typeof err == "number") then do
                                      local ___conditional___=(err);
                                      do
                                         if ___conditional___ = 0--[[ Arity ]] then do
                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                        --[[ String_literal ]]Block.__(11, {
                                                            "They have different arities",
                                                            --[[ End_of_format ]]0
                                                          }),
                                                        "They have different arities"
                                                      });end end end 
                                         if ___conditional___ = 1--[[ Privacy ]] then do
                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                        --[[ String_literal ]]Block.__(11, {
                                                            "A private type would be revealed",
                                                            --[[ End_of_format ]]0
                                                          }),
                                                        "A private type would be revealed"
                                                      });end end end 
                                         if ___conditional___ = 2--[[ Kind ]] then do
                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                        --[[ String_literal ]]Block.__(11, {
                                                            "Their kinds differ",
                                                            --[[ End_of_format ]]0
                                                          }),
                                                        "Their kinds differ"
                                                      });end end end 
                                         if ___conditional___ = 3--[[ Constraint ]] then do
                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                        --[[ String_literal ]]Block.__(11, {
                                                            "Their constraints differ",
                                                            --[[ End_of_format ]]0
                                                          }),
                                                        "Their constraints differ"
                                                      });end end end 
                                         if ___conditional___ = 4--[[ Manifest ]] then do
                                            return --[[ () ]]0;end end end 
                                         if ___conditional___ = 5--[[ Variance ]] then do
                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                        --[[ String_literal ]]Block.__(11, {
                                                            "Their variances do not agree",
                                                            --[[ End_of_format ]]0
                                                          }),
                                                        "Their variances do not agree"
                                                      });end end end 
                                         do
                                        
                                      end
                                    end else do
                                      local ___conditional___=(err.tag | 0);
                                      do
                                         if ___conditional___ = 0--[[ Field_type ]] then do
                                            return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                            --[[ String_literal ]]Block.__(11, {
                                                                "The types for field ",
                                                                --[[ String ]]Block.__(2, {
                                                                    --[[ No_padding ]]0,
                                                                    --[[ String_literal ]]Block.__(11, {
                                                                        " are not equal",
                                                                        --[[ End_of_format ]]0
                                                                      })
                                                                  })
                                                              }),
                                                            "The types for field %s are not equal"
                                                          }), err[0].name);end end end 
                                         if ___conditional___ = 1--[[ Field_mutable ]] then do
                                            return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                            --[[ String_literal ]]Block.__(11, {
                                                                "The mutability of field ",
                                                                --[[ String ]]Block.__(2, {
                                                                    --[[ No_padding ]]0,
                                                                    --[[ String_literal ]]Block.__(11, {
                                                                        " is different",
                                                                        --[[ End_of_format ]]0
                                                                      })
                                                                  })
                                                              }),
                                                            "The mutability of field %s is different"
                                                          }), err[0].name);end end end 
                                         if ___conditional___ = 2--[[ Field_arity ]] then do
                                            return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                            --[[ String_literal ]]Block.__(11, {
                                                                "The arities for field ",
                                                                --[[ String ]]Block.__(2, {
                                                                    --[[ No_padding ]]0,
                                                                    --[[ String_literal ]]Block.__(11, {
                                                                        " differ",
                                                                        --[[ End_of_format ]]0
                                                                      })
                                                                  })
                                                              }),
                                                            "The arities for field %s differ"
                                                          }), err[0].name);end end end 
                                         if ___conditional___ = 3--[[ Field_names ]] then do
                                            return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                                                            --[[ String_literal ]]Block.__(11, {
                                                                "Fields number ",
                                                                --[[ Int ]]Block.__(4, {
                                                                    --[[ Int_i ]]3,
                                                                    --[[ No_padding ]]0,
                                                                    --[[ No_precision ]]0,
                                                                    --[[ String_literal ]]Block.__(11, {
                                                                        " have different names, ",
                                                                        --[[ String ]]Block.__(2, {
                                                                            --[[ No_padding ]]0,
                                                                            --[[ String_literal ]]Block.__(11, {
                                                                                " and ",
                                                                                --[[ String ]]Block.__(2, {
                                                                                    --[[ No_padding ]]0,
                                                                                    --[[ End_of_format ]]0
                                                                                  })
                                                                              })
                                                                          })
                                                                      })
                                                                  })
                                                              }),
                                                            "Fields number %i have different names, %s and %s"
                                                          }), err[0], err[1].name, err[2].name);end end end 
                                         if ___conditional___ = 4--[[ Field_missing ]] then do
                                            return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                                                            --[[ String_literal ]]Block.__(11, {
                                                                "The field ",
                                                                --[[ String ]]Block.__(2, {
                                                                    --[[ No_padding ]]0,
                                                                    --[[ String_literal ]]Block.__(11, {
                                                                        " is only present in ",
                                                                        --[[ String ]]Block.__(2, {
                                                                            --[[ No_padding ]]0,
                                                                            --[[ Char_literal ]]Block.__(12, {
                                                                                --[[ " " ]]32,
                                                                                --[[ String ]]Block.__(2, {
                                                                                    --[[ No_padding ]]0,
                                                                                    --[[ End_of_format ]]0
                                                                                  })
                                                                              })
                                                                          })
                                                                      })
                                                                  })
                                                              }),
                                                            "The field %s is only present in %s %s"
                                                          }), err[1].name, err[0] and second$1 or first$1, decl$1);end end end 
                                         if ___conditional___ = 5--[[ Record_representation ]] then do
                                            return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                                                            --[[ String_literal ]]Block.__(11, {
                                                                "Their internal representations differ:",
                                                                --[[ Formatting_lit ]]Block.__(17, {
                                                                    --[[ Break ]]Block.__(0, {
                                                                        "@ ",
                                                                        1,
                                                                        0
                                                                      }),
                                                                    --[[ String ]]Block.__(2, {
                                                                        --[[ No_padding ]]0,
                                                                        --[[ Char_literal ]]Block.__(12, {
                                                                            --[[ " " ]]32,
                                                                            --[[ String ]]Block.__(2, {
                                                                                --[[ No_padding ]]0,
                                                                                --[[ Char_literal ]]Block.__(12, {
                                                                                    --[[ " " ]]32,
                                                                                    --[[ String ]]Block.__(2, {
                                                                                        --[[ No_padding ]]0,
                                                                                        --[[ End_of_format ]]0
                                                                                      })
                                                                                  })
                                                                              })
                                                                          })
                                                                      })
                                                                  })
                                                              }),
                                                            "Their internal representations differ:@ %s %s %s"
                                                          }), err[0] and second$1 or first$1, decl$1, "uses unboxed float representation");end end end 
                                         do
                                        
                                      end
                                    end end 
                                  end end), err);
                    end end 
                  end end), param);
    end end);
end end

function compare_variants(env, decl1, decl2, _n, _cstrs1, _cstrs2) do
  while(true) do
    cstrs2 = _cstrs2;
    cstrs1 = _cstrs1;
    n = _n;
    if (cstrs1) then do
      c = cstrs1[0];
      if (cstrs2) then do
        match = cstrs2[0];
        ret2 = match.cd_res;
        arg2 = match.cd_args;
        cstr2 = match.cd_id;
        ret1 = c.cd_res;
        arg1 = c.cd_args;
        cstr1 = c.cd_id;
        if (cstr1.name ~= cstr2.name) then do
          return --[[ :: ]]{
                  --[[ Field_names ]]Block.__(3, {
                      n,
                      cstr1,
                      cstr2
                    }),
                  --[[ [] ]]0
                };
        end else if (List.length(arg1) ~= List.length(arg2)) then do
          return --[[ :: ]]{
                  --[[ Field_arity ]]Block.__(2, {cstr1}),
                  --[[ [] ]]0
                };
        end else do
          if (ret1 ~= undefined) then do
            if (not (ret2 ~= undefined and equal$4(env, true, --[[ :: ]]{
                      ret1,
                      --[[ [] ]]0
                    }, --[[ :: ]]{
                      ret2,
                      --[[ [] ]]0
                    }))) then do
              return --[[ :: ]]{
                      --[[ Field_type ]]Block.__(0, {cstr1}),
                      --[[ [] ]]0
                    };
            end
             end 
          end else if (ret2 ~= undefined) then do
            return --[[ :: ]]{
                    --[[ Field_type ]]Block.__(0, {cstr1}),
                    --[[ [] ]]0
                  };
          end
           end  end 
          if (for_all2((function (ty1, ty2) do
                    return equal$4(env, true, --[[ :: ]]{
                                ty1,
                                decl1.type_params
                              }, --[[ :: ]]{
                                ty2,
                                decl2.type_params
                              });
                  end end), arg1, arg2)) then do
            _cstrs2 = cstrs2[1];
            _cstrs1 = cstrs1[1];
            _n = n + 1 | 0;
            continue ;
          end else do
            return --[[ :: ]]{
                    --[[ Field_type ]]Block.__(0, {cstr1}),
                    --[[ [] ]]0
                  };
          end end 
        end end  end 
      end else do
        return --[[ :: ]]{
                --[[ Field_missing ]]Block.__(4, {
                    false,
                    c.cd_id
                  }),
                --[[ [] ]]0
              };
      end end 
    end else if (cstrs2) then do
      return --[[ :: ]]{
              --[[ Field_missing ]]Block.__(4, {
                  true,
                  cstrs2[0].cd_id
                }),
              --[[ [] ]]0
            };
    end else do
      return --[[ [] ]]0;
    end end  end 
  end;
end end

function compare_records(env, decl1, decl2, _n, _labels1, _labels2) do
  while(true) do
    labels2 = _labels2;
    labels1 = _labels1;
    n = _n;
    if (labels1) then do
      l = labels1[0];
      if (labels2) then do
        match = labels2[0];
        lab2 = match.ld_id;
        lab1 = l.ld_id;
        if (lab1.name ~= lab2.name) then do
          return --[[ :: ]]{
                  --[[ Field_names ]]Block.__(3, {
                      n,
                      lab1,
                      lab2
                    }),
                  --[[ [] ]]0
                };
        end else if (l.ld_mutable ~= match.ld_mutable) then do
          return --[[ :: ]]{
                  --[[ Field_mutable ]]Block.__(1, {lab1}),
                  --[[ [] ]]0
                };
        end else if (equal$4(env, true, --[[ :: ]]{
                l.ld_type,
                decl1.type_params
              }, --[[ :: ]]{
                match.ld_type,
                decl2.type_params
              })) then do
          _labels2 = labels2[1];
          _labels1 = labels1[1];
          _n = n + 1 | 0;
          continue ;
        end else do
          return --[[ :: ]]{
                  --[[ Field_type ]]Block.__(0, {lab1}),
                  --[[ [] ]]0
                };
        end end  end  end 
      end else do
        return --[[ :: ]]{
                --[[ Field_missing ]]Block.__(4, {
                    false,
                    l.ld_id
                  }),
                --[[ [] ]]0
              };
      end end 
    end else if (labels2) then do
      return --[[ :: ]]{
              --[[ Field_missing ]]Block.__(4, {
                  true,
                  labels2[0].ld_id
                }),
              --[[ [] ]]0
            };
    end else do
      return --[[ [] ]]0;
    end end  end 
  end;
end end

function type_declarations$1(equalityOpt, env, name, decl1, id, decl2) do
  equality = equalityOpt ~= undefined and equalityOpt or false;
  if (decl1.type_arity ~= decl2.type_arity) then do
    return --[[ :: ]]{
            --[[ Arity ]]0,
            --[[ [] ]]0
          };
  end else if (private_flags(decl1, decl2)) then do
    match = decl1.type_kind;
    match$1 = decl2.type_kind;
    err;
    exit = 0;
    if (typeof match$1 == "number" and match$1 == 0) then do
      err = --[[ [] ]]0;
    end else do
      exit = 1;
    end end 
    if (exit == 1) then do
      if (typeof match == "number") then do
        err = match == --[[ Type_abstract ]]0 or typeof match$1 ~= "number" and --[[ :: ]]{
            --[[ Kind ]]2,
            --[[ [] ]]0
          } or --[[ [] ]]0;
      end else if (match.tag) then do
        cstrs1 = match[0];
        if (typeof match$1 == "number" or not match$1.tag) then do
          err = --[[ :: ]]{
            --[[ Kind ]]2,
            --[[ [] ]]0
          };
        end else do
          cstrs2 = match$1[0];
          mark = function (cstrs, usage, name, decl) do
            return List.iter((function (c) do
                          return mark_constructor_used(usage, env, name, decl, c.cd_id.name);
                        end end), cstrs);
          end end;
          usage = decl1.type_private == --[[ Private ]]0 or decl2.type_private == --[[ Public ]]1 and --[[ Positive ]]0 or --[[ Privatize ]]2;
          mark(cstrs1, usage, name, decl1);
          if (equality) then do
            mark(cstrs2, --[[ Positive ]]0, id.name, decl2);
          end
           end 
          err = compare_variants(env, decl1, decl2, 1, cstrs1, cstrs2);
        end end 
      end else if (typeof match$1 == "number" or match$1.tag) then do
        err = --[[ :: ]]{
          --[[ Kind ]]2,
          --[[ [] ]]0
        };
      end else do
        rep2 = match$1[1];
        err$1 = compare_records(env, decl1, decl2, 1, match[0], match$1[0]);
        err = err$1 ~= --[[ [] ]]0 or match[1] == rep2 and err$1 or --[[ :: ]]{
            --[[ Record_representation ]]Block.__(5, {rep2 == --[[ Record_float ]]1}),
            --[[ [] ]]0
          };
      end end  end  end 
    end
     end 
    if (err ~= --[[ [] ]]0) then do
      return err;
    end else do
      match$2 = decl1.type_manifest;
      match$3 = decl2.type_manifest;
      err$2;
      if (match$3 ~= undefined) then do
        if (match$2 ~= undefined) then do
          err$2 = type_manifest(env, match$2, decl1.type_params, match$3, decl2.type_params, decl2.type_private) and --[[ [] ]]0 or --[[ :: ]]{
              --[[ Manifest ]]4,
              --[[ [] ]]0
            };
        end else do
          ty1 = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
                  --[[ Pident ]]Block.__(0, {id}),
                  decl2.type_params,
                  do
                    contents: --[[ Mnil ]]0
                  end
                }));
          err$2 = equal$4(env, true, decl1.type_params, decl2.type_params) and (
              equal$4(env, false, --[[ :: ]]{
                    ty1,
                    --[[ [] ]]0
                  }, --[[ :: ]]{
                    match$3,
                    --[[ [] ]]0
                  }) and --[[ [] ]]0 or --[[ :: ]]{
                  --[[ Manifest ]]4,
                  --[[ [] ]]0
                }
            ) or --[[ :: ]]{
              --[[ Constraint ]]3,
              --[[ [] ]]0
            };
        end end 
      end else do
        err$2 = equal$4(env, true, decl1.type_params, decl2.type_params) and --[[ [] ]]0 or --[[ :: ]]{
            --[[ Constraint ]]3,
            --[[ [] ]]0
          };
      end end 
      if (err$2 ~= --[[ [] ]]0) then do
        return err$2;
      end else do
        abstr = decl2.type_private == --[[ Private ]]0 or decl2.type_kind == --[[ Type_abstract ]]0 and decl2.type_manifest == undefined;
        opn = decl2.type_kind == --[[ Type_open ]]1 and decl2.type_manifest == undefined;
        if (List.for_all2((function (ty, param) do
                  v2 = param[1];
                  v1 = param[0];
                  match = Curry._1(Types_Variance.get_upper, v1);
                  cn1 = match[1];
                  co1 = match[0];
                  match$1 = Curry._1(Types_Variance.get_upper, v2);
                  cn2 = match$1[1];
                  co2 = match$1[0];
                  if (abstr and (not co1 or co2) and (not cn1 or cn2) or (
                        opn or not is_Tvar(repr(ty)) and co1 == co2 and cn1 == cn2 or true
                      )) then do
                    match$2 = Curry._1(Types_Variance.get_lower, v1);
                    match$3 = Curry._1(Types_Variance.get_lower, v2);
                    b = (not match$3[0] or match$2[0]) and (not match$3[1] or match$2[1]) and (not match$3[2] or match$2[2]) and (not match$3[3] or match$2[3]);
                    return abstr and b or true;
                  end else do
                    return false;
                  end end 
                end end), decl2.type_params, List.combine(decl1.type_variance, decl2.type_variance))) then do
          return --[[ [] ]]0;
        end else do
          return --[[ :: ]]{
                  --[[ Variance ]]5,
                  --[[ [] ]]0
                };
        end end 
      end end 
    end end 
  end else do
    return --[[ :: ]]{
            --[[ Privacy ]]1,
            --[[ [] ]]0
          };
  end end  end 
end end

function extension_constructors(env, id, ext1, ext2) do
  usage = ext1.ext_private == --[[ Private ]]0 or ext2.ext_private == --[[ Public ]]1 and --[[ Positive ]]0 or --[[ Privatize ]]2;
  mark_extension_used(usage, env, ext1, id.name);
  ty1 = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
          ext1.ext_type_path,
          ext1.ext_type_params,
          do
            contents: --[[ Mnil ]]0
          end
        }));
  ty2 = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
          ext2.ext_type_path,
          ext2.ext_type_params,
          do
            contents: --[[ Mnil ]]0
          end
        }));
  if (equal$4(env, true, --[[ :: ]]{
          ty1,
          ext1.ext_type_params
        }, --[[ :: ]]{
          ty2,
          ext2.ext_type_params
        }) and List.length(ext1.ext_args) == List.length(ext2.ext_args)) then do
    match = ext1.ext_ret_type;
    match$1 = ext2.ext_ret_type;
    tmp;
    exit = 0;
    if (match ~= undefined) then do
      if (match$1 ~= undefined and equal$4(env, true, --[[ :: ]]{
              match,
              --[[ [] ]]0
            }, --[[ :: ]]{
              match$1,
              --[[ [] ]]0
            })) then do
        exit = 1;
      end else do
        tmp = false;
      end end 
    end else if (match$1 ~= undefined) then do
      tmp = false;
    end else do
      exit = 1;
    end end  end 
    if (exit == 1) then do
      tmp = for_all2((function (ty1, ty2) do
              return equal$4(env, true, --[[ :: ]]{
                          ty1,
                          ext1.ext_type_params
                        }, --[[ :: ]]{
                          ty2,
                          ext2.ext_type_params
                        });
            end end), ext1.ext_args, ext2.ext_args);
    end
     end 
    if (tmp) then do
      match$2 = ext1.ext_private;
      match$3 = ext2.ext_private;
      if (match$2 or not match$3) then do
        return true;
      end else do
        return false;
      end end 
    end else do
      return false;
    end end 
  end else do
    return false;
  end end 
end end

function scrape(env, mty) do
  if (mty.tag) then do
    return mty;
  end else do
    try do
      return scrape(env, find_modtype_expansion(mty[0], env));
    end
    catch (exn)do
      if (exn == Caml_builtin_exceptions.not_found) then do
        return mty;
      end else do
        throw exn;
      end end 
    end
  end end 
end end

function strengthen$1(env, mty, p) do
  mty$1 = scrape(env, mty);
  local ___conditional___=(mty$1.tag | 0);
  do
     if ___conditional___ = 1--[[ Mty_signature ]] then do
        return --[[ Mty_signature ]]Block.__(1, {strengthen_sig(env, mty$1[0], p)});end end end 
     if ___conditional___ = 2--[[ Mty_functor ]] then do
        param = mty$1[0];
        if (applicative_functors.contents and param.name ~= "*") then do
          return --[[ Mty_functor ]]Block.__(2, {
                    param,
                    mty$1[1],
                    strengthen$1(env, mty$1[2], --[[ Papply ]]Block.__(2, {
                            p,
                            --[[ Pident ]]Block.__(0, {param})
                          }))
                  });
        end else do
          return mty$1;
        end end end end end 
     if ___conditional___ = 0--[[ Mty_ident ]]
     or ___conditional___ = 3--[[ Mty_alias ]] then do
        return mty$1;end end end 
     do
    
  end
end end

function strengthen_sig(env, sg, p) do
  if (sg) then do
    sigelt = sg[0];
    local ___conditional___=(sigelt.tag | 0);
    do
       if ___conditional___ = 1--[[ Sig_type ]] then do
          decl = sigelt[1];
          id = sigelt[0];
          match = decl.type_manifest;
          match$1 = decl.type_private;
          match$2 = decl.type_kind;
          newdecl;
          exit = 0;
          if (match ~= undefined and (match$1 or typeof match$2 ~= "number")) then do
            newdecl = decl;
          end else do
            exit = 1;
          end end 
          if (exit == 1) then do
            manif = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
                    --[[ Pdot ]]Block.__(1, {
                        p,
                        id.name,
                        -1
                      }),
                    decl.type_params,
                    do
                      contents: --[[ Mnil ]]0
                    end
                  }));
            newdecl = decl.type_kind == --[[ Type_abstract ]]0 and (do
                  type_params: decl.type_params,
                  type_arity: decl.type_arity,
                  type_kind: decl.type_kind,
                  type_private: --[[ Public ]]1,
                  type_manifest: manif,
                  type_variance: decl.type_variance,
                  type_newtype_level: decl.type_newtype_level,
                  type_loc: decl.type_loc,
                  type_attributes: decl.type_attributes
                end) or (do
                  type_params: decl.type_params,
                  type_arity: decl.type_arity,
                  type_kind: decl.type_kind,
                  type_private: decl.type_private,
                  type_manifest: manif,
                  type_variance: decl.type_variance,
                  type_newtype_level: decl.type_newtype_level,
                  type_loc: decl.type_loc,
                  type_attributes: decl.type_attributes
                end);
          end
           end 
          return --[[ :: ]]{
                  --[[ Sig_type ]]Block.__(1, {
                      id,
                      newdecl,
                      sigelt[2]
                    }),
                  strengthen_sig(env, sg[1], p)
                };end end end 
       if ___conditional___ = 3--[[ Sig_module ]] then do
          md = sigelt[1];
          id$1 = sigelt[0];
          str = strengthen_decl(env, md, --[[ Pdot ]]Block.__(1, {
                  p,
                  id$1.name,
                  -1
                }));
          return --[[ :: ]]{
                  --[[ Sig_module ]]Block.__(3, {
                      id$1,
                      str,
                      sigelt[2]
                    }),
                  strengthen_sig(add_module_declaration(undefined, id$1, md, env), sg[1], p)
                };end end end 
       if ___conditional___ = 4--[[ Sig_modtype ]] then do
          decl$1 = sigelt[1];
          id$2 = sigelt[0];
          match$3 = decl$1.mtd_type;
          newdecl$1 = match$3 ~= undefined and decl$1 or (do
                mtd_type: --[[ Mty_ident ]]Block.__(0, {--[[ Pdot ]]Block.__(1, {
                        p,
                        id$2.name,
                        -1
                      })}),
                mtd_attributes: decl$1.mtd_attributes,
                mtd_loc: decl$1.mtd_loc
              end);
          return --[[ :: ]]{
                  --[[ Sig_modtype ]]Block.__(4, {
                      id$2,
                      newdecl$1
                    }),
                  strengthen_sig(add_modtype$1(id$2, decl$1, env), sg[1], p)
                };end end end 
       do
      else do
        return --[[ :: ]]{
                sigelt,
                strengthen_sig(env, sg[1], p)
              };
        end end
        
    end
  end else do
    return --[[ [] ]]0;
  end end 
end end

function strengthen_decl(env, md, p) do
  return do
          md_type: strengthen$1(env, md.md_type, p),
          md_attributes: md.md_attributes,
          md_loc: md.md_loc
        end;
end end

strengthen.contents = strengthen$1;

function nondep_supertype(env, mid, mty) do
  nondep_mty = function (env, va, _mty) do
    while(true) do
      mty = _mty;
      local ___conditional___=(mty.tag | 0);
      do
         if ___conditional___ = 0--[[ Mty_ident ]] then do
            p = mty[0];
            if (isfree(mid, p)) then do
              _mty = find_modtype_expansion(p, env);
              continue ;
            end else do
              return mty;
            end end end end end 
         if ___conditional___ = 1--[[ Mty_signature ]] then do
            return --[[ Mty_signature ]]Block.__(1, {nondep_sig(env, va, mty[0])});end end end 
         if ___conditional___ = 2--[[ Mty_functor ]] then do
            arg = mty[1];
            param = mty[0];
            var_inv;
            local ___conditional___=(va);
            do
               if ___conditional___ = 0--[[ Co ]] then do
                  var_inv = --[[ Contra ]]1;end else 
               if ___conditional___ = 1--[[ Contra ]] then do
                  var_inv = --[[ Co ]]0;end else 
               if ___conditional___ = 2--[[ Strict ]] then do
                  var_inv = --[[ Strict ]]2;end else 
               do end end end end
              
            end
            return --[[ Mty_functor ]]Block.__(2, {
                      param,
                      may_map((function(var_inv)do
                          return function (param) do
                            return nondep_mty(env, var_inv, param);
                          end end
                          end(var_inv)), arg),
                      nondep_mty(add_module$1(true, param, default_mty(arg), env), va, mty[2])
                    });end end end 
         if ___conditional___ = 3--[[ Mty_alias ]] then do
            p$1 = mty[0];
            if (isfree(mid, p$1)) then do
              _mty = find_module(false, p$1, env).md_type;
              continue ;
            end else do
              return mty;
            end end end end end 
         do
        
      end
    end;
  end end;
  nondep_sig = function (env, va, param) do
    if (param) then do
      item = param[0];
      rem$prime = nondep_sig(env, va, param[1]);
      local ___conditional___=(item.tag | 0);
      do
         if ___conditional___ = 0--[[ Sig_value ]] then do
            d = item[1];
            return --[[ :: ]]{
                    --[[ Sig_value ]]Block.__(0, {
                        item[0],
                        do
                          val_type: nondep_type(env, mid, d.val_type),
                          val_kind: d.val_kind,
                          val_loc: d.val_loc,
                          val_attributes: d.val_attributes
                        end
                      }),
                    rem$prime
                  };end end end 
         if ___conditional___ = 1--[[ Sig_type ]] then do
            id = item[0];
            return --[[ :: ]]{
                    --[[ Sig_type ]]Block.__(1, {
                        id,
                        nondep_type_decl(env, mid, id, va == --[[ Co ]]0, item[1]),
                        item[2]
                      }),
                    rem$prime
                  };end end end 
         if ___conditional___ = 2--[[ Sig_typext ]] then do
            return --[[ :: ]]{
                    --[[ Sig_typext ]]Block.__(2, {
                        item[0],
                        nondep_extension_constructor(env, mid, item[1]),
                        item[2]
                      }),
                    rem$prime
                  };end end end 
         if ___conditional___ = 3--[[ Sig_module ]] then do
            md = item[1];
            return --[[ :: ]]{
                    --[[ Sig_module ]]Block.__(3, {
                        item[0],
                        do
                          md_type: nondep_mty(env, va, md.md_type),
                          md_attributes: md.md_attributes,
                          md_loc: md.md_loc
                        end,
                        item[2]
                      }),
                    rem$prime
                  };end end end 
         if ___conditional___ = 4--[[ Sig_modtype ]] then do
            id$1 = item[0];
            try do
              return --[[ :: ]]{
                      --[[ Sig_modtype ]]Block.__(4, {
                          id$1,
                          nondep_modtype_decl(env, item[1])
                        }),
                      rem$prime
                    };
            end
            catch (exn)do
              if (exn == Caml_builtin_exceptions.not_found) then do
                if (va ~= 0) then do
                  throw Caml_builtin_exceptions.not_found;
                end
                 end 
                return --[[ :: ]]{
                        --[[ Sig_modtype ]]Block.__(4, {
                            id$1,
                            do
                              mtd_type: undefined,
                              mtd_attributes: --[[ [] ]]0,
                              mtd_loc: none
                            end
                          }),
                        rem$prime
                      };
              end else do
                throw exn;
              end end 
            endend end end 
         if ___conditional___ = 5--[[ Sig_class ]] then do
            return --[[ :: ]]{
                    --[[ Sig_class ]]Block.__(5, {
                        item[0],
                        nondep_class_declaration(env, mid, item[1]),
                        item[2]
                      }),
                    rem$prime
                  };end end end 
         if ___conditional___ = 6--[[ Sig_class_type ]] then do
            return --[[ :: ]]{
                    --[[ Sig_class_type ]]Block.__(6, {
                        item[0],
                        nondep_cltype_declaration(env, mid, item[1]),
                        item[2]
                      }),
                    rem$prime
                  };end end end 
         do
        
      end
    end else do
      return --[[ [] ]]0;
    end end 
  end end;
  nondep_modtype_decl = function (env, mtd) do
    return do
            mtd_type: may_map((function (param) do
                    return nondep_mty(env, --[[ Strict ]]2, param);
                  end end), mtd.mtd_type),
            mtd_attributes: mtd.mtd_attributes,
            mtd_loc: mtd.mtd_loc
          end;
  end end;
  return nondep_mty(env, --[[ Co ]]0, mty);
end end

function enrich_typedecl(env, p, decl) do
  match = decl.type_manifest;
  if (match ~= undefined) then do
    return decl;
  end else do
    try do
      orig_decl = find_type_full(p, env)[0];
      if (orig_decl.type_arity ~= decl.type_arity) then do
        return decl;
      end else do
        return do
                type_params: decl.type_params,
                type_arity: decl.type_arity,
                type_kind: decl.type_kind,
                type_private: decl.type_private,
                type_manifest: newty2(100000000, --[[ Tconstr ]]Block.__(3, {
                        p,
                        decl.type_params,
                        do
                          contents: --[[ Mnil ]]0
                        end
                      })),
                type_variance: decl.type_variance,
                type_newtype_level: decl.type_newtype_level,
                type_loc: decl.type_loc,
                type_attributes: decl.type_attributes
              end;
      end end 
    end
    catch (exn)do
      if (exn == Caml_builtin_exceptions.not_found) then do
        return decl;
      end else do
        throw exn;
      end end 
    end
  end end 
end end

function enrich_modtype(env, p, mty) do
  if (mty.tag == --[[ Mty_signature ]]1) then do
    return --[[ Mty_signature ]]Block.__(1, {List.map((function (param) do
                      env$1 = env;
                      p$1 = p;
                      item = param;
                      local ___conditional___=(item.tag | 0);
                      do
                         if ___conditional___ = 1--[[ Sig_type ]] then do
                            id = item[0];
                            return --[[ Sig_type ]]Block.__(1, {
                                      id,
                                      enrich_typedecl(env$1, --[[ Pdot ]]Block.__(1, {
                                              p$1,
                                              id.name,
                                              -1
                                            }), item[1]),
                                      item[2]
                                    });end end end 
                         if ___conditional___ = 3--[[ Sig_module ]] then do
                            md = item[1];
                            id$1 = item[0];
                            return --[[ Sig_module ]]Block.__(3, {
                                      id$1,
                                      do
                                        md_type: enrich_modtype(env$1, --[[ Pdot ]]Block.__(1, {
                                                p$1,
                                                id$1.name,
                                                -1
                                              }), md.md_type),
                                        md_attributes: md.md_attributes,
                                        md_loc: md.md_loc
                                      end,
                                      item[2]
                                    });end end end 
                         do
                        else do
                          return item;
                          end end
                          
                      end
                    end end), mty[0])});
  end else do
    return mty;
  end end 
end end

function type_paths(env, p, mty) do
  match = scrape(env, mty);
  if (match.tag == --[[ Mty_signature ]]1) then do
    return type_paths_sig(env, p, 0, match[0]);
  end else do
    return --[[ [] ]]0;
  end end 
end end

function type_paths_sig(_env, p, _pos, _sg) do
  while(true) do
    sg = _sg;
    pos = _pos;
    env = _env;
    if (sg) then do
      match = sg[0];
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 0--[[ Sig_value ]] then do
            match$1 = match[1].val_kind;
            pos$prime;
            pos$prime = typeof match$1 == "number" or match$1.tag and pos + 1 | 0 or pos;
            _sg = sg[1];
            _pos = pos$prime;
            continue ;end end end 
         if ___conditional___ = 1--[[ Sig_type ]] then do
            return --[[ :: ]]{
                    --[[ Pdot ]]Block.__(1, {
                        p,
                        match[0].name,
                        -1
                      }),
                    type_paths_sig(env, p, pos, sg[1])
                  };end end end 
         if ___conditional___ = 3--[[ Sig_module ]] then do
            md = match[1];
            id = match[0];
            return Pervasives.$at(type_paths(env, --[[ Pdot ]]Block.__(1, {
                              p,
                              id.name,
                              pos
                            }), md.md_type), type_paths_sig(add_module_declaration(undefined, id, md, env), p, pos + 1 | 0, sg[1]));end end end 
         if ___conditional___ = 4--[[ Sig_modtype ]] then do
            _sg = sg[1];
            _env = add_modtype$1(match[0], match[1], env);
            continue ;end end end 
         if ___conditional___ = 2--[[ Sig_typext ]]
         or ___conditional___ = 5--[[ Sig_class ]]
         or ___conditional___ = 6--[[ Sig_class_type ]] then do
            _sg = sg[1];
            continue ;end end end 
         do
        
      end
      _sg = sg[1];
      _pos = pos + 1 | 0;
      continue ;
    end else do
      return --[[ [] ]]0;
    end end 
  end;
end end

function contains_type(env, _param) do
  while(true) do
    param = _param;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ = 0--[[ Mty_ident ]] then do
          try do
            match = find_modtype(param[0], env).mtd_type;
            if (match ~= undefined) then do
              return contains_type(env, match);
            end else do
              throw Pervasives.Exit;
            end end 
          end
          catch (exn)do
            if (exn == Caml_builtin_exceptions.not_found) then do
              throw Pervasives.Exit;
            end
             end 
            throw exn;
          endend end end 
       if ___conditional___ = 1--[[ Mty_signature ]] then do
          return contains_type_sig(env)(param[0]);end end end 
       if ___conditional___ = 2--[[ Mty_functor ]] then do
          _param = param[2];
          continue ;end end end 
       if ___conditional___ = 3--[[ Mty_alias ]] then do
          return --[[ () ]]0;end end end 
       do
      
    end
  end;
end end

function contains_type_sig(env) do
  return (function (param) do
      return List.iter((function (param) do
                    env$1 = env;
                    param$1 = param;
                    local ___conditional___=(param$1.tag | 0);
                    do
                       if ___conditional___ = 1--[[ Sig_type ]] then do
                          match = param$1[1];
                          match$1 = match.type_kind;
                          if (match.type_manifest ~= undefined) then do
                            if (typeof match$1 == "number" and not (match$1 ~= 0 or match.type_private)) then do
                              throw Pervasives.Exit;
                            end else do
                              return --[[ () ]]0;
                            end end 
                          end else do
                            throw Pervasives.Exit;
                          end end end end end 
                       if ___conditional___ = 3--[[ Sig_module ]] then do
                          return contains_type(env$1, param$1[1].md_type);end end end 
                       if ___conditional___ = 4--[[ Sig_modtype ]] then do
                          throw Pervasives.Exit;end end end 
                       do
                      else do
                        return --[[ () ]]0;
                        end end
                        
                    end
                  end end), param);
    end end);
end end

function contains_type$1(env, mty) do
  try do
    contains_type(env, mty);
    return false;
  end
  catch (exn)do
    if (exn == Pervasives.Exit) then do
      return true;
    end else do
      throw exn;
    end end 
  end
end end

function compare$3(p1, p2) do
  if (same(p1, p2)) then do
    return 0;
  end else do
    return Caml_obj.caml_compare(p1, p2);
  end end 
end end

function height$7(param) do
  if (param) then do
    return param[--[[ h ]]3];
  end else do
    return 0;
  end end 
end end

function create$8(l, v, r) do
  hl = l and l[--[[ h ]]3] or 0;
  hr = r and r[--[[ h ]]3] or 0;
  return --[[ Node ]]{
          --[[ l ]]l,
          --[[ v ]]v,
          --[[ r ]]r,
          --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
        };
end end

function bal$7(l, v, r) do
  hl = l and l[--[[ h ]]3] or 0;
  hr = r and r[--[[ h ]]3] or 0;
  if (hl > (hr + 2 | 0)) then do
    if (l) then do
      lr = l[--[[ r ]]2];
      lv = l[--[[ v ]]1];
      ll = l[--[[ l ]]0];
      if (height$7(ll) >= height$7(lr)) then do
        return create$8(ll, lv, create$8(lr, v, r));
      end else if (lr) then do
        return create$8(create$8(ll, lv, lr[--[[ l ]]0]), lr[--[[ v ]]1], create$8(lr[--[[ r ]]2], v, r));
      end else do
        throw {
              Caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            };
      end end  end 
    end else do
      throw {
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          };
    end end 
  end else if (hr > (hl + 2 | 0)) then do
    if (r) then do
      rr = r[--[[ r ]]2];
      rv = r[--[[ v ]]1];
      rl = r[--[[ l ]]0];
      if (height$7(rr) >= height$7(rl)) then do
        return create$8(create$8(l, v, rl), rv, rr);
      end else if (rl) then do
        return create$8(create$8(l, v, rl[--[[ l ]]0]), rl[--[[ v ]]1], create$8(rl[--[[ r ]]2], rv, rr));
      end else do
        throw {
              Caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            };
      end end  end 
    end else do
      throw {
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          };
    end end 
  end else do
    return --[[ Node ]]{
            --[[ l ]]l,
            --[[ v ]]v,
            --[[ r ]]r,
            --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
          };
  end end  end 
end end

function add$9(x, t) do
  if (t) then do
    r = t[--[[ r ]]2];
    v = t[--[[ v ]]1];
    l = t[--[[ l ]]0];
    c = compare$3(x, v);
    if (c == 0) then do
      return t;
    end else if (c < 0) then do
      ll = add$9(x, l);
      if (l == ll) then do
        return t;
      end else do
        return bal$7(ll, v, r);
      end end 
    end else do
      rr = add$9(x, r);
      if (r == rr) then do
        return t;
      end else do
        return bal$7(l, v, rr);
      end end 
    end end  end 
  end else do
    return --[[ Node ]]{
            --[[ l : Empty ]]0,
            --[[ v ]]x,
            --[[ r : Empty ]]0,
            --[[ h ]]1
          };
  end end 
end end

function singleton$2(x) do
  return --[[ Node ]]{
          --[[ l : Empty ]]0,
          --[[ v ]]x,
          --[[ r : Empty ]]0,
          --[[ h ]]1
        };
end end

function add_min_element$2(x, param) do
  if (param) then do
    return bal$7(add_min_element$2(x, param[--[[ l ]]0]), param[--[[ v ]]1], param[--[[ r ]]2]);
  end else do
    return singleton$2(x);
  end end 
end end

function add_max_element$2(x, param) do
  if (param) then do
    return bal$7(param[--[[ l ]]0], param[--[[ v ]]1], add_max_element$2(x, param[--[[ r ]]2]));
  end else do
    return singleton$2(x);
  end end 
end end

function join$2(l, v, r) do
  if (l) then do
    if (r) then do
      rh = r[--[[ h ]]3];
      lh = l[--[[ h ]]3];
      if (lh > (rh + 2 | 0)) then do
        return bal$7(l[--[[ l ]]0], l[--[[ v ]]1], join$2(l[--[[ r ]]2], v, r));
      end else if (rh > (lh + 2 | 0)) then do
        return bal$7(join$2(l, v, r[--[[ l ]]0]), r[--[[ v ]]1], r[--[[ r ]]2]);
      end else do
        return create$8(l, v, r);
      end end  end 
    end else do
      return add_max_element$2(v, l);
    end end 
  end else do
    return add_min_element$2(v, r);
  end end 
end end

function split$2(x, param) do
  if (param) then do
    r = param[--[[ r ]]2];
    v = param[--[[ v ]]1];
    l = param[--[[ l ]]0];
    c = compare$3(x, v);
    if (c == 0) then do
      return --[[ tuple ]]{
              l,
              true,
              r
            };
    end else if (c < 0) then do
      match = split$2(x, l);
      return --[[ tuple ]]{
              match[0],
              match[1],
              join$2(match[2], v, r)
            };
    end else do
      match$1 = split$2(x, r);
      return --[[ tuple ]]{
              join$2(l, v, match$1[0]),
              match$1[1],
              match$1[2]
            };
    end end  end 
  end else do
    return --[[ tuple ]]{
            --[[ Empty ]]0,
            false,
            --[[ Empty ]]0
          };
  end end 
end end

function union$3(s1, s2) do
  if (s1) then do
    if (s2) then do
      h2 = s2[--[[ h ]]3];
      v2 = s2[--[[ v ]]1];
      h1 = s1[--[[ h ]]3];
      v1 = s1[--[[ v ]]1];
      if (h1 >= h2) then do
        if (h2 == 1) then do
          return add$9(v2, s1);
        end else do
          match = split$2(v1, s2);
          return join$2(union$3(s1[--[[ l ]]0], match[0]), v1, union$3(s1[--[[ r ]]2], match[2]));
        end end 
      end else if (h1 == 1) then do
        return add$9(v1, s2);
      end else do
        match$1 = split$2(v2, s1);
        return join$2(union$3(match$1[0], s2[--[[ l ]]0]), v2, union$3(match$1[2], s2[--[[ r ]]2]));
      end end  end 
    end else do
      return s1;
    end end 
  end else do
    return s2;
  end end 
end end

function fold$6(f, _s, _accu) do
  while(true) do
    accu = _accu;
    s = _s;
    if (s) then do
      _accu = Curry._2(f, s[--[[ v ]]1], fold$6(f, s[--[[ l ]]0], accu));
      _s = s[--[[ r ]]2];
      continue ;
    end else do
      return accu;
    end end 
  end;
end end

function height$8(param) do
  if (param) then do
    return param[--[[ h ]]4];
  end else do
    return 0;
  end end 
end end

function create$9(l, x, d, r) do
  hl = height$8(l);
  hr = height$8(r);
  return --[[ Node ]]{
          --[[ l ]]l,
          --[[ v ]]x,
          --[[ d ]]d,
          --[[ r ]]r,
          --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
        };
end end

function bal$8(l, x, d, r) do
  hl = l and l[--[[ h ]]4] or 0;
  hr = r and r[--[[ h ]]4] or 0;
  if (hl > (hr + 2 | 0)) then do
    if (l) then do
      lr = l[--[[ r ]]3];
      ld = l[--[[ d ]]2];
      lv = l[--[[ v ]]1];
      ll = l[--[[ l ]]0];
      if (height$8(ll) >= height$8(lr)) then do
        return create$9(ll, lv, ld, create$9(lr, x, d, r));
      end else if (lr) then do
        return create$9(create$9(ll, lv, ld, lr[--[[ l ]]0]), lr[--[[ v ]]1], lr[--[[ d ]]2], create$9(lr[--[[ r ]]3], x, d, r));
      end else do
        throw {
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            };
      end end  end 
    end else do
      throw {
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          };
    end end 
  end else if (hr > (hl + 2 | 0)) then do
    if (r) then do
      rr = r[--[[ r ]]3];
      rd = r[--[[ d ]]2];
      rv = r[--[[ v ]]1];
      rl = r[--[[ l ]]0];
      if (height$8(rr) >= height$8(rl)) then do
        return create$9(create$9(l, x, d, rl), rv, rd, rr);
      end else if (rl) then do
        return create$9(create$9(l, x, d, rl[--[[ l ]]0]), rl[--[[ v ]]1], rl[--[[ d ]]2], create$9(rl[--[[ r ]]3], rv, rd, rr));
      end else do
        throw {
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            };
      end end  end 
    end else do
      throw {
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          };
    end end 
  end else do
    return --[[ Node ]]{
            --[[ l ]]l,
            --[[ v ]]x,
            --[[ d ]]d,
            --[[ r ]]r,
            --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
          };
  end end  end 
end end

function add$10(x, data, m) do
  if (m) then do
    r = m[--[[ r ]]3];
    d = m[--[[ d ]]2];
    v = m[--[[ v ]]1];
    l = m[--[[ l ]]0];
    c = compare$3(x, v);
    if (c == 0) then do
      if (d == data) then do
        return m;
      end else do
        return --[[ Node ]]{
                --[[ l ]]l,
                --[[ v ]]x,
                --[[ d ]]data,
                --[[ r ]]r,
                --[[ h ]]m[--[[ h ]]4]
              };
      end end 
    end else if (c < 0) then do
      ll = add$10(x, data, l);
      if (l == ll) then do
        return m;
      end else do
        return bal$8(ll, v, d, r);
      end end 
    end else do
      rr = add$10(x, data, r);
      if (r == rr) then do
        return m;
      end else do
        return bal$8(l, v, d, rr);
      end end 
    end end  end 
  end else do
    return --[[ Node ]]{
            --[[ l : Empty ]]0,
            --[[ v ]]x,
            --[[ d ]]data,
            --[[ r : Empty ]]0,
            --[[ h ]]1
          };
  end end 
end end

function find$5(x, _param) do
  while(true) do
    param = _param;
    if (param) then do
      c = compare$3(x, param[--[[ v ]]1]);
      if (c == 0) then do
        return param[--[[ d ]]2];
      end else do
        _param = c < 0 and param[--[[ l ]]0] or param[--[[ r ]]3];
        continue ;
      end end 
    end else do
      throw Caml_builtin_exceptions.not_found;
    end end 
  end;
end end

function height$9(param) do
  if (param) then do
    return param[--[[ h ]]3];
  end else do
    return 0;
  end end 
end end

function create$10(l, v, r) do
  hl = l and l[--[[ h ]]3] or 0;
  hr = r and r[--[[ h ]]3] or 0;
  return --[[ Node ]]{
          --[[ l ]]l,
          --[[ v ]]v,
          --[[ r ]]r,
          --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
        };
end end

function bal$9(l, v, r) do
  hl = l and l[--[[ h ]]3] or 0;
  hr = r and r[--[[ h ]]3] or 0;
  if (hl > (hr + 2 | 0)) then do
    if (l) then do
      lr = l[--[[ r ]]2];
      lv = l[--[[ v ]]1];
      ll = l[--[[ l ]]0];
      if (height$9(ll) >= height$9(lr)) then do
        return create$10(ll, lv, create$10(lr, v, r));
      end else if (lr) then do
        return create$10(create$10(ll, lv, lr[--[[ l ]]0]), lr[--[[ v ]]1], create$10(lr[--[[ r ]]2], v, r));
      end else do
        throw {
              Caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            };
      end end  end 
    end else do
      throw {
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          };
    end end 
  end else if (hr > (hl + 2 | 0)) then do
    if (r) then do
      rr = r[--[[ r ]]2];
      rv = r[--[[ v ]]1];
      rl = r[--[[ l ]]0];
      if (height$9(rr) >= height$9(rl)) then do
        return create$10(create$10(l, v, rl), rv, rr);
      end else if (rl) then do
        return create$10(create$10(l, v, rl[--[[ l ]]0]), rl[--[[ v ]]1], create$10(rl[--[[ r ]]2], rv, rr));
      end else do
        throw {
              Caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            };
      end end  end 
    end else do
      throw {
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          };
    end end 
  end else do
    return --[[ Node ]]{
            --[[ l ]]l,
            --[[ v ]]v,
            --[[ r ]]r,
            --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
          };
  end end  end 
end end

function add$11(x, t) do
  if (t) then do
    r = t[--[[ r ]]2];
    v = t[--[[ v ]]1];
    l = t[--[[ l ]]0];
    c = Caml_obj.caml_compare(x, v);
    if (c == 0) then do
      return t;
    end else if (c < 0) then do
      ll = add$11(x, l);
      if (l == ll) then do
        return t;
      end else do
        return bal$9(ll, v, r);
      end end 
    end else do
      rr = add$11(x, r);
      if (r == rr) then do
        return t;
      end else do
        return bal$9(l, v, rr);
      end end 
    end end  end 
  end else do
    return --[[ Node ]]{
            --[[ l : Empty ]]0,
            --[[ v ]]x,
            --[[ r : Empty ]]0,
            --[[ h ]]1
          };
  end end 
end end

function singleton$3(x) do
  return --[[ Node ]]{
          --[[ l : Empty ]]0,
          --[[ v ]]x,
          --[[ r : Empty ]]0,
          --[[ h ]]1
        };
end end

function add_min_element$3(x, param) do
  if (param) then do
    return bal$9(add_min_element$3(x, param[--[[ l ]]0]), param[--[[ v ]]1], param[--[[ r ]]2]);
  end else do
    return singleton$3(x);
  end end 
end end

function add_max_element$3(x, param) do
  if (param) then do
    return bal$9(param[--[[ l ]]0], param[--[[ v ]]1], add_max_element$3(x, param[--[[ r ]]2]));
  end else do
    return singleton$3(x);
  end end 
end end

function join$3(l, v, r) do
  if (l) then do
    if (r) then do
      rh = r[--[[ h ]]3];
      lh = l[--[[ h ]]3];
      if (lh > (rh + 2 | 0)) then do
        return bal$9(l[--[[ l ]]0], l[--[[ v ]]1], join$3(l[--[[ r ]]2], v, r));
      end else if (rh > (lh + 2 | 0)) then do
        return bal$9(join$3(l, v, r[--[[ l ]]0]), r[--[[ v ]]1], r[--[[ r ]]2]);
      end else do
        return create$10(l, v, r);
      end end  end 
    end else do
      return add_max_element$3(v, l);
    end end 
  end else do
    return add_min_element$3(v, r);
  end end 
end end

function split$3(x, param) do
  if (param) then do
    r = param[--[[ r ]]2];
    v = param[--[[ v ]]1];
    l = param[--[[ l ]]0];
    c = Caml_obj.caml_compare(x, v);
    if (c == 0) then do
      return --[[ tuple ]]{
              l,
              true,
              r
            };
    end else if (c < 0) then do
      match = split$3(x, l);
      return --[[ tuple ]]{
              match[0],
              match[1],
              join$3(match[2], v, r)
            };
    end else do
      match$1 = split$3(x, r);
      return --[[ tuple ]]{
              join$3(l, v, match$1[0]),
              match$1[1],
              match$1[2]
            };
    end end  end 
  end else do
    return --[[ tuple ]]{
            --[[ Empty ]]0,
            false,
            --[[ Empty ]]0
          };
  end end 
end end

function mem$5(x, _param) do
  while(true) do
    param = _param;
    if (param) then do
      c = Caml_obj.caml_compare(x, param[--[[ v ]]1]);
      if (c == 0) then do
        return true;
      end else do
        _param = c < 0 and param[--[[ l ]]0] or param[--[[ r ]]2];
        continue ;
      end end 
    end else do
      return false;
    end end 
  end;
end end

function union$4(s1, s2) do
  if (s1) then do
    if (s2) then do
      h2 = s2[--[[ h ]]3];
      v2 = s2[--[[ v ]]1];
      h1 = s1[--[[ h ]]3];
      v1 = s1[--[[ v ]]1];
      if (h1 >= h2) then do
        if (h2 == 1) then do
          return add$11(v2, s1);
        end else do
          match = split$3(v1, s2);
          return join$3(union$4(s1[--[[ l ]]0], match[0]), v1, union$4(s1[--[[ r ]]2], match[2]));
        end end 
      end else if (h1 == 1) then do
        return add$11(v1, s2);
      end else do
        match$1 = split$3(v2, s1);
        return join$3(union$4(match$1[0], s2[--[[ l ]]0]), v2, union$4(match$1[2], s2[--[[ r ]]2]));
      end end  end 
    end else do
      return s1;
    end end 
  end else do
    return s2;
  end end 
end end

function get_prefixes(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Pident ]] then do
        return --[[ Empty ]]0;end end end 
     if ___conditional___ = 1--[[ Pdot ]]
     or ___conditional___ = 2--[[ Papply ]]
     do
    
  end
  p = param[0];
  return add$9(p, get_prefixes(p));
end end

function get_arg_paths(_param) do
  while(true) do
    param = _param;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ = 0--[[ Pident ]] then do
          return --[[ Empty ]]0;end end end 
       if ___conditional___ = 1--[[ Pdot ]] then do
          _param = param[0];
          continue ;end end end 
       if ___conditional___ = 2--[[ Papply ]] then do
          p2 = param[1];
          return add$9(p2, union$3(get_prefixes(p2), union$3(get_arg_paths(param[0]), get_arg_paths(p2))));end end end 
       do
      
    end
  end;
end end

function rollback_path(subst, _p) do
  while(true) do
    p = _p;
    try do
      return --[[ Pident ]]Block.__(0, {find$5(p, subst)});
    end
    catch (exn)do
      if (exn == Caml_builtin_exceptions.not_found) then do
        local ___conditional___=(p.tag | 0);
        do
           if ___conditional___ = 1--[[ Pdot ]] then do
              p1 = p[0];
              p1$prime = rollback_path(subst, p1);
              if (same(p1, p1$prime)) then do
                return p;
              end else do
                _p = --[[ Pdot ]]Block.__(1, {
                    p1$prime,
                    p[1],
                    p[2]
                  });
                continue ;
              end end end end end 
           if ___conditional___ = 0--[[ Pident ]]
           or ___conditional___ = 2--[[ Papply ]] then do
              return p;end end end 
           do
          
        end
      end else do
        throw exn;
      end end 
    end
  end;
end end

function collect_ids(subst, bindings, p) do
  match = rollback_path(subst, p);
  local ___conditional___=(match.tag | 0);
  do
     if ___conditional___ = 0--[[ Pident ]] then do
        id = match[0];
        ids;
        try do
          ids = collect_ids(subst, bindings, find_same(id, bindings));
        end
        catch (exn)do
          if (exn == Caml_builtin_exceptions.not_found) then do
            ids = --[[ Empty ]]0;
          end else do
            throw exn;
          end end 
        end
        return add$11(id, ids);end end end 
     if ___conditional___ = 1--[[ Pdot ]]
     or ___conditional___ = 2--[[ Papply ]] then do
        return --[[ Empty ]]0;end end end 
     do
    
  end
end end

function collect_arg_paths(mty) do
  paths = do
    contents: --[[ Empty ]]0
  end;
  subst = do
    contents: --[[ Empty ]]0
  end;
  bindings = do
    contents: --[[ Empty ]]0
  end;
  it_path = function (p) do
    paths.contents = union$3(get_arg_paths(p), paths.contents);
    return --[[ () ]]0;
  end end;
  it_signature_item$1 = function (it, si) do
    it_signature_item(it, si);
    if (si.tag == --[[ Sig_module ]]3) then do
      match = si[1].md_type;
      id = si[0];
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 1--[[ Mty_signature ]] then do
            return List.iter((function (param) do
                          if (param.tag == --[[ Sig_module ]]3) then do
                            id$prime = param[0];
                            subst.contents = add$10(--[[ Pdot ]]Block.__(1, {
                                    --[[ Pident ]]Block.__(0, {id}),
                                    id$prime.name,
                                    -1
                                  }), id$prime, subst.contents);
                            return --[[ () ]]0;
                          end else do
                            return --[[ () ]]0;
                          end end 
                        end end), match[0]);end end end 
         if ___conditional___ = 0--[[ Mty_ident ]]
         or ___conditional___ = 2--[[ Mty_functor ]] then do
            return --[[ () ]]0;end end end 
         if ___conditional___ = 3--[[ Mty_alias ]] then do
            bindings.contents = add(id, match[0], bindings.contents);
            return --[[ () ]]0;end end end 
         do
        
      end
    end else do
      return --[[ () ]]0;
    end end 
  end end;
  it = do
    it_signature: it_signature,
    it_signature_item: it_signature_item$1,
    it_value_description: it_value_description,
    it_type_declaration: it_type_declaration,
    it_extension_constructor: it_extension_constructor,
    it_module_declaration: it_module_declaration,
    it_modtype_declaration: it_modtype_declaration,
    it_class_declaration: it_class_declaration,
    it_class_type_declaration: it_class_type_declaration,
    it_module_type: it_module_type,
    it_class_type: it_class_type,
    it_type_kind: it_type_kind,
    it_do_type_expr: it_do_type_expr,
    it_type_expr: it_type_expr,
    it_path: it_path
  end;
  it_module_type(it, mty);
  it_module_type(unmark_iterators, mty);
  return fold$6((function (p) do
                partial_arg = collect_ids(subst.contents, bindings.contents, p);
                return (function (param) do
                    return union$4(partial_arg, param);
                  end end);
              end end), paths.contents, --[[ Empty ]]0);
end end

function remove_aliases(env, excl, _mty) do
  while(true) do
    mty = _mty;
    local ___conditional___=(mty.tag | 0);
    do
       if ___conditional___ = 1--[[ Mty_signature ]] then do
          return --[[ Mty_signature ]]Block.__(1, {remove_aliases_sig(env, excl, mty[0])});end end end 
       if ___conditional___ = 0--[[ Mty_ident ]]
       or ___conditional___ = 2--[[ Mty_functor ]] then do
          return mty;end end end 
       if ___conditional___ = 3--[[ Mty_alias ]] then do
          mty$prime = scrape_alias(env, undefined, mty);
          if (Caml_obj.caml_equal(mty$prime, mty)) then do
            return mty;
          end else do
            _mty = mty$prime;
            continue ;
          end end end end end 
       do
      
    end
  end;
end end

function remove_aliases_sig(env, excl, sg) do
  if (sg) then do
    it = sg[0];
    local ___conditional___=(it.tag | 0);
    do
       if ___conditional___ = 3--[[ Sig_module ]] then do
          md = it[1];
          id = it[0];
          mty = md.md_type;
          mty$1;
          mty$1 = mty.tag == --[[ Mty_alias ]]3 and mem$5(id, excl) and md.md_type or remove_aliases(env, excl, mty);
          return --[[ :: ]]{
                  --[[ Sig_module ]]Block.__(3, {
                      id,
                      do
                        md_type: mty$1,
                        md_attributes: md.md_attributes,
                        md_loc: md.md_loc
                      end,
                      it[2]
                    }),
                  remove_aliases_sig(add_module$1(undefined, id, mty$1, env), excl, sg[1])
                };end end end 
       if ___conditional___ = 4--[[ Sig_modtype ]] then do
          mtd = it[1];
          id$1 = it[0];
          return --[[ :: ]]{
                  --[[ Sig_modtype ]]Block.__(4, {
                      id$1,
                      mtd
                    }),
                  remove_aliases_sig(add_modtype$1(id$1, mtd, env), excl, sg[1])
                };end end end 
       do
      else do
        return --[[ :: ]]{
                it,
                remove_aliases_sig(env, excl, sg[1])
              };
        end end
        
    end
  end else do
    return --[[ [] ]]0;
  end end 
end end

function remove_aliases$1(env, sg) do
  excl = collect_arg_paths(sg);
  return remove_aliases(env, excl, sg);
end end

__Error$5 = Caml_exceptions.create("Ocaml_typedtree_test.Includemod.Error");

function value_descriptions(env, cxt, subst, id, vd1, vd2) do
  record_value_dependency(vd1, vd2);
  mark_value_used(env, id.name, vd1);
  vd2$1 = value_description(subst, vd2);
  try do
    env$1 = env;
    id$1 = id;
    vd1$1 = vd1;
    vd2$2 = vd2$1;
    if (moregeneral(env$1, true, vd1$1.val_type, vd2$2.val_type)) then do
      match = vd1$1.val_kind;
      match$1 = vd2$2.val_kind;
      if (typeof match ~= "number" and not match.tag) then do
        p1 = match[0];
        if (typeof match$1 == "number" or match$1.tag) then do
          return --[[ Tcoerce_primitive ]]Block.__(2, {
                    id$1,
                    p1
                  });
        end else if (Caml_obj.caml_equal(p1, match$1[0])) then do
          return --[[ Tcoerce_none ]]0;
        end else do
          throw Dont_match;
        end end  end 
      end
       end 
      if (typeof match$1 == "number" or match$1.tag) then do
        return --[[ Tcoerce_none ]]0;
      end else do
        throw Dont_match;
      end end 
    end else do
      throw Dont_match;
    end end 
  end
  catch (exn)do
    if (exn == Dont_match) then do
      throw {
            __Error$5,
            --[[ :: ]]{
              --[[ tuple ]]{
                cxt,
                env,
                --[[ Value_descriptions ]]Block.__(1, {
                    id,
                    vd1,
                    vd2$1
                  })
              },
              --[[ [] ]]0
            }
          };
    end
     end 
    throw exn;
  end
end end

function type_declarations$2(env, old_envOpt, cxt, subst, id, decl1, decl2) do
  old_env = old_envOpt ~= undefined and Caml_option.valFromOption(old_envOpt) or env;
  mark_type_used(env, id.name, decl1);
  decl2$1 = type_declaration(subst, decl2);
  err = type_declarations$1(undefined, env, id.name, decl1, id, decl2$1);
  if (err ~= --[[ [] ]]0) then do
    throw {
          __Error$5,
          --[[ :: ]]{
            --[[ tuple ]]{
              cxt,
              old_env,
              --[[ Type_declarations ]]Block.__(2, {
                  id,
                  decl1,
                  decl2$1,
                  err
                })
            },
            --[[ [] ]]0
          }
        };
  end else do
    return 0;
  end end 
end end

function extension_constructors$1(env, cxt, subst, id, ext1, ext2) do
  ext2$1 = extension_constructor(subst, ext2);
  if (extension_constructors(env, id, ext1, ext2$1)) then do
    return --[[ () ]]0;
  end else do
    throw {
          __Error$5,
          --[[ :: ]]{
            --[[ tuple ]]{
              cxt,
              env,
              --[[ Extension_constructors ]]Block.__(3, {
                  id,
                  ext1,
                  ext2$1
                })
            },
            --[[ [] ]]0
          }
        };
  end end 
end end

function class_type_declarations$1(old_env, env, cxt, subst, id, decl1, decl2) do
  decl2$1 = cltype_declaration(subst, decl2);
  reason = class_type_declarations(env, decl1, decl2$1);
  if (reason) then do
    throw {
          __Error$5,
          --[[ :: ]]{
            --[[ tuple ]]{
              cxt,
              old_env,
              --[[ Class_type_declarations ]]Block.__(7, {
                  id,
                  decl1,
                  decl2$1,
                  reason
                })
            },
            --[[ [] ]]0
          }
        };
  end else do
    return --[[ () ]]0;
  end end 
end end

function class_declarations$1(old_env, env, cxt, subst, id, decl1, decl2) do
  decl2$1 = class_declaration(subst, decl2);
  reason = class_declarations(env, decl1, decl2$1);
  if (reason) then do
    throw {
          __Error$5,
          --[[ :: ]]{
            --[[ tuple ]]{
              cxt,
              old_env,
              --[[ Class_declarations ]]Block.__(8, {
                  id,
                  decl1,
                  decl2$1,
                  reason
                })
            },
            --[[ [] ]]0
          }
        };
  end else do
    return --[[ () ]]0;
  end end 
end end

Dont_match$1 = Caml_exceptions.create("Ocaml_typedtree_test.Includemod.Dont_match");

function may_expand_module_path(env, path) do
  try do
    find_modtype_expansion(path, env);
    return true;
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return false;
    end else do
      throw exn;
    end end 
  end
end end

function expand_module_path(env, cxt, path) do
  try do
    return find_modtype_expansion(path, env);
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      throw {
            __Error$5,
            --[[ :: ]]{
              --[[ tuple ]]{
                cxt,
                env,
                --[[ Unbound_modtype_path ]]Block.__(9, {path})
              },
              --[[ [] ]]0
            }
          };
    end
     end 
    throw exn;
  end
end end

function expand_module_alias(env, cxt, path) do
  try do
    return find_module(false, path, env).md_type;
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      throw {
            __Error$5,
            --[[ :: ]]{
              --[[ tuple ]]{
                cxt,
                env,
                --[[ Unbound_module_path ]]Block.__(10, {path})
              },
              --[[ [] ]]0
            }
          };
    end
     end 
    throw exn;
  end
end end

function kind_of_field_desc(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Field_value ]] then do
        return "value";end end end 
     if ___conditional___ = 1--[[ Field_type ]] then do
        return "type";end end end 
     if ___conditional___ = 2--[[ Field_typext ]] then do
        return "extension constructor";end end end 
     if ___conditional___ = 3--[[ Field_module ]] then do
        return "module";end end end 
     if ___conditional___ = 4--[[ Field_modtype ]] then do
        return "module type";end end end 
     if ___conditional___ = 5--[[ Field_class ]] then do
        return "class";end end end 
     if ___conditional___ = 6--[[ Field_classtype ]] then do
        return "class type";end end end 
     do
    
  end
end end

function item_ident_name(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Sig_value ]] then do
        id = param[0];
        return --[[ tuple ]]{
                id,
                param[1].val_loc,
                --[[ Field_value ]]Block.__(0, {id.name})
              };end end end 
     if ___conditional___ = 1--[[ Sig_type ]] then do
        id$1 = param[0];
        return --[[ tuple ]]{
                id$1,
                param[1].type_loc,
                --[[ Field_type ]]Block.__(1, {id$1.name})
              };end end end 
     if ___conditional___ = 2--[[ Sig_typext ]] then do
        id$2 = param[0];
        return --[[ tuple ]]{
                id$2,
                param[1].ext_loc,
                --[[ Field_typext ]]Block.__(2, {id$2.name})
              };end end end 
     if ___conditional___ = 3--[[ Sig_module ]] then do
        id$3 = param[0];
        return --[[ tuple ]]{
                id$3,
                param[1].md_loc,
                --[[ Field_module ]]Block.__(3, {id$3.name})
              };end end end 
     if ___conditional___ = 4--[[ Sig_modtype ]] then do
        id$4 = param[0];
        return --[[ tuple ]]{
                id$4,
                param[1].mtd_loc,
                --[[ Field_modtype ]]Block.__(4, {id$4.name})
              };end end end 
     if ___conditional___ = 5--[[ Sig_class ]] then do
        id$5 = param[0];
        return --[[ tuple ]]{
                id$5,
                param[1].cty_loc,
                --[[ Field_class ]]Block.__(5, {id$5.name})
              };end end end 
     if ___conditional___ = 6--[[ Sig_class_type ]] then do
        id$6 = param[0];
        return --[[ tuple ]]{
                id$6,
                param[1].clty_loc,
                --[[ Field_classtype ]]Block.__(6, {id$6.name})
              };end end end 
     do
    
  end
end end

function is_runtime_component(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Sig_value ]] then do
        tmp = param[1].val_kind;
        if (typeof tmp == "number" or tmp.tag) then do
          return true;
        end else do
          return false;
        end end end end end 
     if ___conditional___ = 1--[[ Sig_type ]]
     or ___conditional___ = 4--[[ Sig_modtype ]]
     or ___conditional___ = 6--[[ Sig_class_type ]] then do
        return false;end end end 
     do
    else do
      return true;
      end end
      
  end
end end

function modtypes(env, cxt, subst, mty1, mty2) do
  try do
    return try_modtypes(env, cxt, subst, mty1, mty2);
  end
  catch (raw_err)do
    err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err == Dont_match$1) then do
      throw {
            __Error$5,
            --[[ :: ]]{
              --[[ tuple ]]{
                cxt,
                env,
                --[[ Module_types ]]Block.__(4, {
                    mty1,
                    modtype(subst, mty2)
                  })
              },
              --[[ [] ]]0
            }
          };
    end
     end 
    if (err[0] == __Error$5) then do
      if (mty1.tag == --[[ Mty_alias ]]3) then do
        throw err;
      end else if (mty2.tag == --[[ Mty_alias ]]3) then do
        throw err;
      end else do
        throw {
              __Error$5,
              --[[ :: ]]{
                --[[ tuple ]]{
                  cxt,
                  env,
                  --[[ Module_types ]]Block.__(4, {
                      mty1,
                      modtype(subst, mty2)
                    })
                },
                err[1]
              }
            };
      end end  end 
    end else do
      throw err;
    end end 
  end
end end

function try_modtypes(env, cxt, subst, _mty1, mty2) do
  while(true) do
    mty1 = _mty1;
    local ___conditional___=(mty1.tag | 0);
    do
       if ___conditional___ = 0--[[ Mty_ident ]] then do
          p1 = mty1[0];
          if (may_expand_module_path(env, p1)) then do
            _mty1 = expand_module_path(env, cxt, p1);
            continue ;
          end
           end end else 
       if ___conditional___ = 1--[[ Mty_signature ]] then do
          local ___conditional___=(mty2.tag | 0);
          do
             if ___conditional___ = 0--[[ Mty_ident ]]
             or ___conditional___ = 1--[[ Mty_signature ]] then do
                return signatures(env, cxt, subst, mty1[0], mty2[0]);end end end 
             if ___conditional___ = 2--[[ Mty_functor ]]
             or ___conditional___ = 3--[[ Mty_alias ]] then do
                throw Dont_match$1;end end end 
             do
            
          endend else 
       if ___conditional___ = 2--[[ Mty_functor ]] then do
          match = mty1[1];
          param1 = mty1[0];
          if (match ~= undefined) then do
            local ___conditional___=(mty2.tag | 0);
            do
               if ___conditional___ = 0--[[ Mty_ident ]]
               or ___conditional___ = 2--[[ Mty_functor ]] then do
                  match$1 = mty2[1];
                  if (match$1 ~= undefined) then do
                    arg2$prime = modtype(subst, match$1);
                    cc_arg = modtypes(env, --[[ :: ]]{
                          --[[ Arg ]]Block.__(2, {param1}),
                          cxt
                        }, identity, arg2$prime, match);
                    cc_res = modtypes(add_module$1(undefined, param1, arg2$prime, env), --[[ :: ]]{
                          --[[ Body ]]Block.__(3, {param1}),
                          cxt
                        }, add_module(mty2[0], --[[ Pident ]]Block.__(0, {param1}), subst), mty1[2], mty2[2]);
                    if (typeof cc_arg == "number" and typeof cc_res == "number") then do
                      return --[[ Tcoerce_none ]]0;
                    end else do
                      return --[[ Tcoerce_functor ]]Block.__(1, {
                                cc_arg,
                                cc_res
                              });
                    end end 
                  end else do
                    throw Dont_match$1;
                  end end end end end 
               if ___conditional___ = 1--[[ Mty_signature ]]
               or ___conditional___ = 3--[[ Mty_alias ]] then do
                  throw Dont_match$1;end end end 
               do
              
            end
          end else do
            local ___conditional___=(mty2.tag | 0);
            do
               if ___conditional___ = 0--[[ Mty_ident ]]
               or ___conditional___ = 2--[[ Mty_functor ]] then do
                  if (mty2[1] ~= undefined) then do
                    throw Dont_match$1;
                  end
                   end 
                  cc = modtypes(env, --[[ :: ]]{
                        --[[ Body ]]Block.__(3, {param1}),
                        cxt
                      }, subst, mty1[2], mty2[2]);
                  if (typeof cc == "number") then do
                    return --[[ Tcoerce_none ]]0;
                  end else do
                    return --[[ Tcoerce_functor ]]Block.__(1, {
                              --[[ Tcoerce_none ]]0,
                              cc
                            });
                  end end end end end 
               if ___conditional___ = 1--[[ Mty_signature ]]
               or ___conditional___ = 3--[[ Mty_alias ]] then do
                  throw Dont_match$1;end end end 
               do
              
            end
          end end end else 
       if ___conditional___ = 3--[[ Mty_alias ]] then do
          p1$1 = mty1[0];
          if (mty2.tag == --[[ Mty_alias ]]3) then do
            p2 = mty2[0];
            if (is_functor_arg(p2, env)) then do
              throw {
                    __Error$5,
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        cxt,
                        env,
                        --[[ Invalid_module_alias ]]Block.__(11, {p2})
                      },
                      --[[ [] ]]0
                    }
                  };
            end
             end 
            if (same(p1$1, p2)) then do
              return --[[ Tcoerce_none ]]0;
            end else do
              p1$2 = normalize_path$1(undefined, env, p1$1);
              p2$1 = normalize_path$1(undefined, env, module_path(subst, p2));
              if (same(p1$2, p2$1)) then do
                return --[[ Tcoerce_none ]]0;
              end else do
                throw Dont_match$1;
              end end 
            end end 
          end else do
            p1$3;
            try do
              p1$3 = normalize_path$1(none, env, p1$1);
            end
            catch (raw_exn)do
              exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn[0] == __Error$2) then do
                match$2 = exn[1];
                if (match$2.tag == --[[ Missing_module ]]3) then do
                  throw {
                        __Error$5,
                        --[[ :: ]]{
                          --[[ tuple ]]{
                            cxt,
                            env,
                            --[[ Unbound_module_path ]]Block.__(10, {match$2[2]})
                          },
                          --[[ [] ]]0
                        }
                      };
                end else do
                  throw exn;
                end end 
              end else do
                throw exn;
              end end 
            end
            mty1$1 = strengthen$1(env, expand_module_alias(env, cxt, p1$3), p1$3);
            return --[[ Tcoerce_alias ]]Block.__(3, {
                      p1$3,
                      modtypes(env, cxt, subst, mty1$1, mty2)
                    });
          end end end end end 
       do end end end
      
    end
    if (mty2.tag) then do
      throw Dont_match$1;
    end else do
      env$1 = env;
      cxt$1 = cxt;
      mty1$2 = mty1;
      mty2$1 = modtype(subst, mty2);
      if (not mty1$2.tag) then do
        if (mty2$1.tag) then do
          throw {
                Caml_builtin_exceptions.assert_failure,
                --[[ tuple ]]{
                  "includemod.ml",
                  275,
                  6
                }
              };
        end else if (same(mty1$2[0], mty2$1[0])) then do
          return --[[ Tcoerce_none ]]0;
        end
         end  end 
      end
       end 
      if (mty2$1.tag) then do
        throw {
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "includemod.ml",
                275,
                6
              }
            };
      end else do
        return try_modtypes(env$1, cxt$1, identity, mty1$2, expand_module_path(env$1, cxt$1, mty2$1[0]));
      end end 
    end end 
  end;
end end

function signatures(env, cxt, subst, sig1, sig2) do
  new_env = add_signature(sig1, in_signature(env));
  match = List.fold_left((function (param, item) do
          pos = param[1];
          l = param[0];
          if (item.tag == --[[ Sig_module ]]3) then do
            return --[[ tuple ]]{
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        item[0],
                        pos,
                        --[[ Tcoerce_none ]]0
                      },
                      l
                    },
                    pos + 1 | 0
                  };
          end else do
            return --[[ tuple ]]{
                    l,
                    is_runtime_component(item) and pos + 1 | 0 or pos
                  };
          end end 
        end end), --[[ tuple ]]{
        --[[ [] ]]0,
        0
      }, sig1);
  id_pos_list = match[0];
  build_component_table = function (_pos, _tbl, _param) do
    while(true) do
      param = _param;
      tbl = _tbl;
      pos = _pos;
      if (param) then do
        item = param[0];
        match = item_ident_name(item);
        nextpos = is_runtime_component(item) and pos + 1 | 0 or pos;
        _param = param[1];
        _tbl = add$5(match[2], --[[ tuple ]]{
              match[0],
              item,
              pos
            }, tbl);
        _pos = nextpos;
        continue ;
      end else do
        return --[[ tuple ]]{
                pos,
                tbl
              };
      end end 
    end;
  end end;
  match$1 = build_component_table(0, --[[ Empty ]]0, sig1);
  comps1 = match$1[1];
  len1 = match$1[0];
  len2 = List.fold_left((function (n, i) do
          if (is_runtime_component(i)) then do
            return n + 1 | 0;
          end else do
            return n;
          end end 
        end end), 0, sig2);
  pair_components = function (subst, paired, _unpaired, _param) do
    while(true) do
      param = _param;
      unpaired = _unpaired;
      if (param) then do
        rem = param[1];
        item2 = param[0];
        match = item_ident_name(item2);
        name2 = match[2];
        id2 = match[0];
        match$1;
        if (item2.tag == --[[ Sig_type ]]1 and not (item2[1].type_manifest ~= undefined or name2.tag ~= --[[ Field_type ]]1)) then do
          s = name2[0];
          l = #s;
          match$1 = l >= 4 and __String.sub(s, l - 4 | 0, 4) == "#row" and --[[ tuple ]]{
              --[[ Field_type ]]Block.__(1, {__String.sub(s, 0, #s - 4 | 0)}),
              false
            } or --[[ tuple ]]{
              name2,
              true
            };
        end else do
          match$1 = --[[ tuple ]]{
            name2,
            true
          };
        end end 
        name2$1 = match$1[0];
        try do
          match$2 = find$2(name2$1, comps1);
          id1 = match$2[0];
          new_subst;
          local ___conditional___=(item2.tag | 0);
          do
             if ___conditional___ = 1--[[ Sig_type ]] then do
                new_subst = add_type(id2, --[[ Pident ]]Block.__(0, {id1}), subst);end else 
             if ___conditional___ = 3--[[ Sig_module ]] then do
                new_subst = add_module(id2, --[[ Pident ]]Block.__(0, {id1}), subst);end else 
             if ___conditional___ = 4--[[ Sig_modtype ]] then do
                new_subst = add_modtype(id2, --[[ Mty_ident ]]Block.__(0, {--[[ Pident ]]Block.__(0, {id1})}), subst);end else 
             do end end end end
            else do
              new_subst = subst;
              end end
              
          end
          return pair_components(new_subst, --[[ :: ]]{
                      --[[ tuple ]]{
                        match$2[1],
                        item2,
                        match$2[2]
                      },
                      paired
                    }, unpaired, rem);
        end
        catch (exn)do
          if (exn == Caml_builtin_exceptions.not_found) then do
            unpaired$1 = match$1[1] and --[[ :: ]]{
                --[[ tuple ]]{
                  cxt,
                  env,
                  --[[ Missing_field ]]Block.__(0, {
                      id2,
                      match[1],
                      kind_of_field_desc(name2$1)
                    })
                },
                unpaired
              } or unpaired;
            _param = rem;
            _unpaired = unpaired$1;
            continue ;
          end else do
            throw exn;
          end end 
        end
      end else do
        if (unpaired) then do
          throw {
                __Error$5,
                unpaired
              };
        end
         end 
        cc = signature_components(env, new_env, cxt, subst, List.rev(paired));
        if (len1 == len2) then do
          cc$1 = cc;
          id_pos_list$1 = id_pos_list;
          is_identity_coercion = function (_pos, _param) do
            while(true) do
              param = _param;
              pos = _pos;
              if (param) then do
                match = param[0];
                if (match[0] == pos and match[1] == --[[ Tcoerce_none ]]0) then do
                  _param = param[1];
                  _pos = pos + 1 | 0;
                  continue ;
                end else do
                  return false;
                end end 
              end else do
                return true;
              end end 
            end;
          end end;
          if (is_identity_coercion(0, cc$1)) then do
            return --[[ Tcoerce_none ]]0;
          end else do
            return --[[ Tcoerce_structure ]]Block.__(0, {
                      cc$1,
                      id_pos_list$1
                    });
          end end 
        end else do
          return --[[ Tcoerce_structure ]]Block.__(0, {
                    cc,
                    id_pos_list
                  });
        end end 
      end end 
    end;
  end end;
  return pair_components(subst, --[[ [] ]]0, --[[ [] ]]0, sig2);
end end

function signature_components(old_env, env, cxt, subst, paired) do
  comps_rec = function (rem) do
    return signature_components(old_env, env, cxt, subst, rem);
  end end;
  if (paired) then do
    match = paired[0];
    match$1 = match[0];
    local ___conditional___=(match$1.tag | 0);
    do
       if ___conditional___ = 0--[[ Sig_value ]] then do
          match$2 = match[1];
          if (not match$2.tag) then do
            rem = paired[1];
            pos = match[2];
            valdecl2 = match$2[1];
            cc = value_descriptions(env, cxt, subst, match$1[0], match$1[1], valdecl2);
            match$3 = valdecl2.val_kind;
            if (typeof match$3 == "number" or match$3.tag) then do
              return --[[ :: ]]{
                      --[[ tuple ]]{
                        pos,
                        cc
                      },
                      comps_rec(rem)
                    };
            end else do
              return comps_rec(rem);
            end end 
          end
           end end else 
       if ___conditional___ = 1--[[ Sig_type ]] then do
          match$4 = match[1];
          if (match$4.tag == --[[ Sig_type ]]1) then do
            type_declarations$2(env, Caml_option.some(old_env), cxt, subst, match$1[0], match$1[1], match$4[1]);
            return comps_rec(paired[1]);
          end
           end end else 
       if ___conditional___ = 2--[[ Sig_typext ]] then do
          match$5 = match[1];
          if (match$5.tag == --[[ Sig_typext ]]2) then do
            extension_constructors$1(env, cxt, subst, match$1[0], match$1[1], match$5[1]);
            return --[[ :: ]]{
                    --[[ tuple ]]{
                      match[2],
                      --[[ Tcoerce_none ]]0
                    },
                    comps_rec(paired[1])
                  };
          end
           end end else 
       if ___conditional___ = 3--[[ Sig_module ]] then do
          match$6 = match[1];
          if (match$6.tag == --[[ Sig_module ]]3) then do
            id1 = match$1[0];
            cc$1 = modtypes(env, --[[ :: ]]{
                  --[[ Module ]]Block.__(0, {id1}),
                  cxt
                }, subst, strengthen$1(env, match$1[1].md_type, --[[ Pident ]]Block.__(0, {id1})), match$6[1].md_type);
            return --[[ :: ]]{
                    --[[ tuple ]]{
                      match[2],
                      cc$1
                    },
                    comps_rec(paired[1])
                  };
          end
           end end else 
       if ___conditional___ = 4--[[ Sig_modtype ]] then do
          match$7 = match[1];
          if (match$7.tag == --[[ Sig_modtype ]]4) then do
            modtype_infos(env, cxt, subst, match$1[0], match$1[1], match$7[1]);
            return comps_rec(paired[1]);
          end
           end end else 
       if ___conditional___ = 5--[[ Sig_class ]] then do
          match$8 = match[1];
          if (match$8.tag == --[[ Sig_class ]]5) then do
            class_declarations$1(old_env, env, cxt, subst, match$1[0], match$1[1], match$8[1]);
            return --[[ :: ]]{
                    --[[ tuple ]]{
                      match[2],
                      --[[ Tcoerce_none ]]0
                    },
                    comps_rec(paired[1])
                  };
          end
           end end else 
       if ___conditional___ = 6--[[ Sig_class_type ]] then do
          match$9 = match[1];
          if (match$9.tag == --[[ Sig_class_type ]]6) then do
            class_type_declarations$1(old_env, env, cxt, subst, match$1[0], match$1[1], match$9[1]);
            return comps_rec(paired[1]);
          end
           end end else 
       do end end end end end end end end
      
    end
  end else do
    return --[[ [] ]]0;
  end end 
  throw {
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "includemod.ml",
          400,
          6
        }
      };
end end

function modtype_infos(env, cxt, subst, id, info1, info2) do
  info2$1 = modtype_declaration(subst, info2);
  cxt$prime_000 = --[[ Modtype ]]Block.__(1, {id});
  cxt$prime = --[[ :: ]]{
    cxt$prime_000,
    cxt
  };
  try do
    match = info1.mtd_type;
    match$1 = info2$1.mtd_type;
    if (match ~= undefined) then do
      if (match$1 ~= undefined) then do
        return check_modtype_equiv(env, cxt$prime, match, match$1);
      end else do
        return --[[ () ]]0;
      end end 
    end else if (match$1 ~= undefined) then do
      return check_modtype_equiv(env, cxt$prime, --[[ Mty_ident ]]Block.__(0, {--[[ Pident ]]Block.__(0, {id})}), match$1);
    end else do
      return --[[ () ]]0;
    end end  end 
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == __Error$5) then do
      throw {
            __Error$5,
            --[[ :: ]]{
              --[[ tuple ]]{
                cxt,
                env,
                --[[ Modtype_infos ]]Block.__(5, {
                    id,
                    info1,
                    info2$1
                  })
              },
              exn[1]
            }
          };
    end
     end 
    throw exn;
  end
end end

function check_modtype_equiv(env, cxt, mty1, mty2) do
  match = modtypes(env, cxt, identity, mty1, mty2);
  match$1 = modtypes(env, cxt, identity, mty2, mty1);
  if (typeof match == "number" and typeof match$1 == "number") then do
    return --[[ () ]]0;
  end
   end 
  throw {
        __Error$5,
        --[[ :: ]]{
          --[[ tuple ]]{
            cxt,
            env,
            --[[ Modtype_permutation ]]0
          },
          --[[ [] ]]0
        }
      };
end end

function check_modtype_inclusion$1(env, mty1, path1, mty2) do
  try do
    modtypes(env, --[[ [] ]]0, identity, strengthen$1(env, mty1, path1), mty2);
    return --[[ () ]]0;
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == __Error$5) then do
      throw Caml_builtin_exceptions.not_found;
    end
     end 
    throw exn;
  end
end end

check_modtype_inclusion.contents = check_modtype_inclusion$1;

function compunit(env, impl_name, impl_sig, intf_name, intf_sig) do
  try do
    return signatures(env, --[[ [] ]]0, identity, impl_sig, intf_sig);
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == __Error$5) then do
      throw {
            __Error$5,
            --[[ :: ]]{
              --[[ tuple ]]{
                --[[ [] ]]0,
                empty,
                --[[ Interface_mismatch ]]Block.__(6, {
                    impl_name,
                    intf_name
                  })
              },
              exn[1]
            }
          };
    end
     end 
    throw exn;
  end
end end

function modtypes$1(env, mty1, mty2) do
  return modtypes(env, --[[ [] ]]0, identity, mty1, mty2);
end end

function type_declarations$3(env, id, decl1, decl2) do
  return type_declarations$2(env, undefined, --[[ [] ]]0, identity, id, decl1, decl2);
end end

function show_loc(msg, ppf, loc) do
  pos = loc.loc_start;
  if (List.mem(pos.pos_fname, --[[ :: ]]{
          "",
          --[[ :: ]]{
            "_none_",
            --[[ :: ]]{
              "//toplevel//",
              --[[ [] ]]0
            }
          }
        })) then do
    return --[[ () ]]0;
  end else do
    return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_lit ]]Block.__(17, {
                        --[[ Force_newline ]]3,
                        --[[ Formatting_gen ]]Block.__(18, {
                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      "<2>",
                                      --[[ End_of_format ]]0
                                    }),
                                  "<2>"
                                }}),
                            --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                    --[[ ":" ]]58,
                                    --[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Break ]]Block.__(0, {
                                            "@ ",
                                            1,
                                            0
                                          }),
                                        --[[ String ]]Block.__(2, {
                                            --[[ No_padding ]]0,
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Close_box ]]0,
                                                --[[ End_of_format ]]0
                                              })
                                          })
                                      })
                                  })})
                          })
                      }),
                    "@\n@[<2>%a:@ %s@]"
                  }), print_loc, loc, msg);
  end end 
end end

function show_locs(ppf, param) do
  show_loc("Expected declaration", ppf, param[1]);
  return show_loc("Actual declaration", ppf, param[0]);
end end

function include_err$1(ppf, param) do
  if (typeof param == "number") then do
    return Format.fprintf(ppf, --[[ Format ]]{
                --[[ String_literal ]]Block.__(11, {
                    "Illegal permutation of structure fields",
                    --[[ End_of_format ]]0
                  }),
                "Illegal permutation of structure fields"
              });
  end else do
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ = 0--[[ Missing_field ]] then do
          Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ String_literal ]]Block.__(11, {
                        "The ",
                        --[[ String ]]Block.__(2, {
                            --[[ No_padding ]]0,
                            --[[ String_literal ]]Block.__(11, {
                                " `",
                                --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                        "' is required but not provided",
                                        --[[ End_of_format ]]0
                                      })})
                              })
                          })
                      }),
                    "The %s `%a' is required but not provided"
                  }), param[2], ident$3, param[0]);
          return show_loc("Expected declaration", ppf, param[1]);end end end 
       if ___conditional___ = 1--[[ Value_descriptions ]] then do
          d2 = param[2];
          d1 = param[1];
          id = param[0];
          Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<hv 2>",
                                  --[[ End_of_format ]]0
                                }),
                              "<hv 2>"
                            }}),
                        --[[ String_literal ]]Block.__(11, {
                            "Values do not match:",
                            --[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@ ",
                                    1,
                                    0
                                  }),
                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Break ]]Block.__(0, {
                                            "@;<1 -2>",
                                            1,
                                            -2
                                          }),
                                        --[[ String_literal ]]Block.__(11, {
                                            "is not included in",
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Break ]]Block.__(0, {
                                                    "@ ",
                                                    1,
                                                    0
                                                  }),
                                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                        --[[ Close_box ]]0,
                                                        --[[ End_of_format ]]0
                                                      })})
                                              })
                                          })
                                      })})
                              })
                          })
                      }),
                    "@[<hv 2>Values do not match:@ %a@;<1 -2>is not included in@ %a@]"
                  }), (function (param, param$1) do
                  return value_description$1(id, param, param$1);
                end end), d1, (function (param, param$1) do
                  return value_description$1(id, param, param$1);
                end end), d2);
          return show_locs(ppf, --[[ tuple ]]{
                      d1.val_loc,
                      d2.val_loc
                    });end end end 
       if ___conditional___ = 2--[[ Type_declarations ]] then do
          d2$1 = param[2];
          d1$1 = param[1];
          id$1 = param[0];
          return Curry.app(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<v>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<v>"
                                  }}),
                              --[[ Formatting_gen ]]Block.__(18, {
                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                        --[[ String_literal ]]Block.__(11, {
                                            "<hv>",
                                            --[[ End_of_format ]]0
                                          }),
                                        "<hv>"
                                      }}),
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Char_literal ]]Block.__(12, {
                                          --[[ ":" ]]58,
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@;<1 2>",
                                                  1,
                                                  2
                                                }),
                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Break ]]Block.__(0, {
                                                          "@ ",
                                                          1,
                                                          0
                                                        }),
                                                      --[[ String ]]Block.__(2, {
                                                          --[[ No_padding ]]0,
                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Break ]]Block.__(0, {
                                                                  "@;<1 2>",
                                                                  1,
                                                                  2
                                                                }),
                                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Close_box ]]0,
                                                                      --[[ Alpha ]]Block.__(15, {--[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Close_box ]]0,
                                                                                  --[[ End_of_format ]]0
                                                                                })})})
                                                                    })})
                                                            })
                                                        })
                                                    })})
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[<v>@[<hv>%s:@;<1 2>%a@ %s@;<1 2>%a@]%a%a@]"
                        }), {
                      "Type declarations do not match",
                      (function (param, param$1) do
                          return type_declaration$1(id$1, param, param$1);
                        end end),
                      d1$1,
                      "is not included in",
                      (function (param, param$1) do
                          return type_declaration$1(id$1, param, param$1);
                        end end),
                      d2$1,
                      show_locs,
                      --[[ tuple ]]{
                        d1$1.type_loc,
                        d2$1.type_loc
                      },
                      (function (param) do
                          return report_type_mismatch("the first", "the second", "declaration", param);
                        end end),
                      param[3]
                    });end end end 
       if ___conditional___ = 3--[[ Extension_constructors ]] then do
          x2 = param[2];
          x1 = param[1];
          id$2 = param[0];
          Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<hv 2>",
                                  --[[ End_of_format ]]0
                                }),
                              "<hv 2>"
                            }}),
                        --[[ String_literal ]]Block.__(11, {
                            "Extension declarations do not match:",
                            --[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@ ",
                                    1,
                                    0
                                  }),
                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Break ]]Block.__(0, {
                                            "@;<1 -2>",
                                            1,
                                            -2
                                          }),
                                        --[[ String_literal ]]Block.__(11, {
                                            "is not included in",
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Break ]]Block.__(0, {
                                                    "@ ",
                                                    1,
                                                    0
                                                  }),
                                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                        --[[ Close_box ]]0,
                                                        --[[ End_of_format ]]0
                                                      })})
                                              })
                                          })
                                      })})
                              })
                          })
                      }),
                    "@[<hv 2>Extension declarations do not match:@ %a@;<1 -2>is not included in@ %a@]"
                  }), (function (param, param$1) do
                  return extension_constructor$1(id$2, param, param$1);
                end end), x1, (function (param, param$1) do
                  return extension_constructor$1(id$2, param, param$1);
                end end), x2);
          return show_locs(ppf, --[[ tuple ]]{
                      x1.ext_loc,
                      x2.ext_loc
                    });end end end 
       if ___conditional___ = 4--[[ Module_types ]] then do
          return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hv 2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hv 2>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "Modules do not match:",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@;<1 -2>",
                                                  1,
                                                  -2
                                                }),
                                              --[[ String_literal ]]Block.__(11, {
                                                  "is not included in",
                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Break ]]Block.__(0, {
                                                          "@ ",
                                                          1,
                                                          0
                                                        }),
                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Close_box ]]0,
                                                              --[[ End_of_format ]]0
                                                            })})
                                                    })
                                                })
                                            })})
                                    })
                                })
                            }),
                          "@[<hv 2>Modules do not match:@ %a@;<1 -2>is not included in@ %a@]"
                        }), modtype$1, param[0], modtype$1, param[1]);end end end 
       if ___conditional___ = 5--[[ Modtype_infos ]] then do
          id$3 = param[0];
          return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hv 2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hv 2>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "Module type declarations do not match:",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@;<1 -2>",
                                                  1,
                                                  -2
                                                }),
                                              --[[ String_literal ]]Block.__(11, {
                                                  "does not match",
                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Break ]]Block.__(0, {
                                                          "@ ",
                                                          1,
                                                          0
                                                        }),
                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Close_box ]]0,
                                                              --[[ End_of_format ]]0
                                                            })})
                                                    })
                                                })
                                            })})
                                    })
                                })
                            }),
                          "@[<hv 2>Module type declarations do not match:@ %a@;<1 -2>does not match@ %a@]"
                        }), (function (param, param$1) do
                        return modtype_declaration$1(id$3, param, param$1);
                      end end), param[1], (function (param, param$1) do
                        return modtype_declaration$1(id$3, param, param$1);
                      end end), param[2]);end end end 
       if ___conditional___ = 6--[[ Interface_mismatch ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "The implementation ",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ String_literal ]]Block.__(11, {
                                              "does not match the interface ",
                                              --[[ String ]]Block.__(2, {
                                                  --[[ No_padding ]]0,
                                                  --[[ Char_literal ]]Block.__(12, {
                                                      --[[ ":" ]]58,
                                                      --[[ End_of_format ]]0
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[The implementation %s@ does not match the interface %s:"
                        }), param[0], param[1]);end end end 
       if ___conditional___ = 7--[[ Class_type_declarations ]] then do
          id$4 = param[0];
          return Curry._6(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hv 2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hv 2>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "Class type declarations do not match:",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@;<1 -2>",
                                                  1,
                                                  -2
                                                }),
                                              --[[ String_literal ]]Block.__(11, {
                                                  "does not match",
                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Break ]]Block.__(0, {
                                                          "@ ",
                                                          1,
                                                          0
                                                        }),
                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Close_box ]]0,
                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                  --[[ Break ]]Block.__(0, {
                                                                      "@ ",
                                                                      1,
                                                                      0
                                                                    }),
                                                                  --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                                })
                                                            })})
                                                    })
                                                })
                                            })})
                                    })
                                })
                            }),
                          "@[<hv 2>Class type declarations do not match:@ %a@;<1 -2>does not match@ %a@]@ %a"
                        }), (function (param, param$1) do
                        return cltype_declaration$1(id$4, param, param$1);
                      end end), param[1], (function (param, param$1) do
                        return cltype_declaration$1(id$4, param, param$1);
                      end end), param[2], report_error$3, param[3]);end end end 
       if ___conditional___ = 8--[[ Class_declarations ]] then do
          id$5 = param[0];
          return Curry._6(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hv 2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hv 2>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "Class declarations do not match:",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@;<1 -2>",
                                                  1,
                                                  -2
                                                }),
                                              --[[ String_literal ]]Block.__(11, {
                                                  "does not match",
                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Break ]]Block.__(0, {
                                                          "@ ",
                                                          1,
                                                          0
                                                        }),
                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Close_box ]]0,
                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                  --[[ Break ]]Block.__(0, {
                                                                      "@ ",
                                                                      1,
                                                                      0
                                                                    }),
                                                                  --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                                })
                                                            })})
                                                    })
                                                })
                                            })})
                                    })
                                })
                            }),
                          "@[<hv 2>Class declarations do not match:@ %a@;<1 -2>does not match@ %a@]@ %a"
                        }), (function (param, param$1) do
                        return class_declaration$1(id$5, param, param$1);
                      end end), param[1], (function (param, param$1) do
                        return class_declaration$1(id$5, param, param$1);
                      end end), param[2], report_error$3, param[3]);end end end 
       if ___conditional___ = 9--[[ Unbound_modtype_path ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "Unbound module type ",
                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                            }),
                          "Unbound module type %a"
                        }), path, param[0]);end end end 
       if ___conditional___ = 10--[[ Unbound_module_path ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "Unbound module ",
                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                            }),
                          "Unbound module %a"
                        }), path, param[0]);end end end 
       if ___conditional___ = 11--[[ Invalid_module_alias ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "Module ",
                              --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                      " cannot be aliased",
                                      --[[ End_of_format ]]0
                                    })})
                            }),
                          "Module %a cannot be aliased"
                        }), path, param[0]);end end end 
       do
      
    end
  end end 
end end

function context(ppf, param) do
  if (param) then do
    match = param[0];
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 0--[[ Module ]] then do
          return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<2>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "module ",
                                  --[[ Alpha ]]Block.__(15, {--[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Close_box ]]0,
                                              --[[ End_of_format ]]0
                                            })})})
                                })
                            }),
                          "@[<2>module %a%a@]"
                        }), ident$3, match[0], args, param[1]);end end end 
       if ___conditional___ = 1--[[ Modtype ]] then do
          return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<2>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<2>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "module type ",
                                  --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                          " =",
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@ ",
                                                  1,
                                                  0
                                                }),
                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Close_box ]]0,
                                                      --[[ End_of_format ]]0
                                                    })})
                                            })
                                        })})
                                })
                            }),
                          "@[<2>module type %a =@ %a@]"
                        }), ident$3, match[0], context_mty, param[1]);end end end 
       if ___conditional___ = 2--[[ Arg ]] then do
          return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "functor (",
                              --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                      " : ",
                                      --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                              ") -> ...",
                                              --[[ End_of_format ]]0
                                            })})
                                    })})
                            }),
                          "functor (%a : %a) -> ..."
                        }), ident$3, match[0], context_mty, param[1]);end end end 
       if ___conditional___ = 3--[[ Body ]] then do
          return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "functor (",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ String_literal ]]Block.__(11, {
                                      ") ->",
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                        })
                                    })
                                })
                            }),
                          "functor (%s) ->@ %a"
                        }), argname(match[0]), context_mty, param[1]);end end end 
       do
      
    end
  end else do
    return Format.fprintf(ppf, --[[ Format ]]{
                --[[ String_literal ]]Block.__(11, {
                    "<here>",
                    --[[ End_of_format ]]0
                  }),
                "<here>"
              });
  end end 
end end

function context_mty(ppf, rem) do
  if (rem) then do
    local ___conditional___=(rem[0].tag | 0);
    do
       if ___conditional___ = 0--[[ Module ]]
       or ___conditional___ = 1--[[ Modtype ]]
       or ___conditional___ = 2--[[ Arg ]]
       or ___conditional___ = 3--[[ Body ]] then do
          return context(ppf, rem);end end end 
       do
      
    end
    return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<2>",
                                  --[[ End_of_format ]]0
                                }),
                              "<2>"
                            }}),
                        --[[ String_literal ]]Block.__(11, {
                            "sig",
                            --[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@ ",
                                    1,
                                    0
                                  }),
                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Break ]]Block.__(0, {
                                            "@;<1 -2>",
                                            1,
                                            -2
                                          }),
                                        --[[ String_literal ]]Block.__(11, {
                                            "end",
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Close_box ]]0,
                                                --[[ End_of_format ]]0
                                              })
                                          })
                                      })})
                              })
                          })
                      }),
                    "@[<2>sig@ %a@;<1 -2>end@]"
                  }), context, rem);
  end else do
    return context(ppf, rem);
  end end 
end end

function args(ppf, cxt) do
  if (cxt) then do
    match = cxt[0];
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 0--[[ Module ]]
       or ___conditional___ = 1--[[ Modtype ]]
       or ___conditional___ = 2--[[ Arg ]] then do
          return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Char_literal ]]Block.__(12, {
                              --[[ "(" ]]40,
                              --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                      " :",
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                                  ") : ...",
                                                  --[[ End_of_format ]]0
                                                })})
                                        })
                                    })})
                            }),
                          "(%a :@ %a) : ..."
                        }), ident$3, match[0], context_mty, cxt[1]);end end end 
       if ___conditional___ = 3--[[ Body ]] then do
          return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Char_literal ]]Block.__(12, {
                              --[[ "(" ]]40,
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ Char_literal ]]Block.__(12, {
                                      --[[ ")" ]]41,
                                      --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                    })
                                })
                            }),
                          "(%s)%a"
                        }), argname(match[0]), args, cxt[1]);end end end 
       do
      
    end
  end
   end 
  return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                  --[[ String_literal ]]Block.__(11, {
                      " :",
                      --[[ Formatting_lit ]]Block.__(17, {
                          --[[ Break ]]Block.__(0, {
                              "@ ",
                              1,
                              0
                            }),
                          --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                        })
                    }),
                  " :@ %a"
                }), context_mty, cxt);
end end

function argname(x) do
  s = x.name;
  if (s == "*") then do
    return "";
  end else do
    return s;
  end end 
end end

function path_of_context(param) do
  if (param) then do
    match = param[0];
    if (match.tag) then do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "includemod.ml",
              573,
              9
            }
          };
    end else do
      _path = --[[ Pident ]]Block.__(0, {match[0]});
      _param = param[1];
      while(true) do
        param$1 = _param;
        path = _path;
        if (param$1) then do
          match$1 = param$1[0];
          if (match$1.tag) then do
            throw {
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "includemod.ml",
                    571,
                    15
                  }
                };
          end else do
            _param = param$1[1];
            _path = --[[ Pdot ]]Block.__(1, {
                path,
                match$1[0].name,
                -1
              });
            continue ;
          end end 
        end else do
          return path;
        end end 
      end;
    end end 
  end else do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "includemod.ml",
            573,
            9
          }
        };
  end end 
end end

function context$1(ppf, cxt) do
  if (cxt == --[[ [] ]]0) then do
    return --[[ () ]]0;
  end else if (List.for_all((function (param) do
            return param.tag and false or true;
          end end), cxt)) then do
    return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ String_literal ]]Block.__(11, {
                        "In module ",
                        --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                --[[ ":" ]]58,
                                --[[ Formatting_lit ]]Block.__(17, {
                                    --[[ Break ]]Block.__(0, {
                                        "@ ",
                                        1,
                                        0
                                      }),
                                    --[[ End_of_format ]]0
                                  })
                              })})
                      }),
                    "In module %a:@ "
                  }), path, path_of_context(cxt));
  end else do
    return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<hv 2>",
                                  --[[ End_of_format ]]0
                                }),
                              "<hv 2>"
                            }}),
                        --[[ String_literal ]]Block.__(11, {
                            "At position",
                            --[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@ ",
                                    1,
                                    0
                                  }),
                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Close_box ]]0,
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ End_of_format ]]0
                                          })
                                      })})
                              })
                          })
                      }),
                    "@[<hv 2>At position@ %a@]@ "
                  }), context, cxt);
  end end  end 
end end

function include_err$2(ppf, param) do
  err = param[2];
  cxt = param[0];
  return wrap_printing_env(param[1], (function (param) do
                return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                                --[[ Formatting_gen ]]Block.__(18, {
                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "<v>",
                                              --[[ End_of_format ]]0
                                            }),
                                          "<v>"
                                        }}),
                                    --[[ Alpha ]]Block.__(15, {--[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Close_box ]]0,
                                                --[[ End_of_format ]]0
                                              })})})
                                  }),
                                "@[<v>%a%a@]"
                              }), context$1, List.rev(cxt), include_err$1, err);
              end end));
end end

buffer = do
  contents: Bytes.empty
end;

function is_big(obj) do
  size = error_size.contents;
  if (size > 0) then do
    if (#buffer.contents < size) then do
      buffer.contents = Caml_bytes.caml_create_bytes(size);
    end
     end 
    try do
      Marshal.to_buffer(buffer.contents, 0, size, obj, --[[ [] ]]0);
      return false;
    end
    catch (exn)do
      return true;
    end
  end else do
    return false;
  end end 
end end

function report_error$4(ppf, errs) do
  if (errs == --[[ [] ]]0) then do
    return --[[ () ]]0;
  end else do
    match = split_last(errs);
    pe = do
      contents: true
    end;
    print_errs = function (ppf) do
      return (function (param) do
          return List.iter((function (param) do
                        ppf$1 = ppf;
                        err = param;
                        if (is_big(err[2])) then do
                          if (pe.contents) then do
                            Format.fprintf(ppf$1, --[[ Format ]]{
                                  --[[ String_literal ]]Block.__(11, {
                                      "...",
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ End_of_format ]]0
                                        })
                                    }),
                                  "...@ "
                                });
                            pe.contents = false;
                            return --[[ () ]]0;
                          end else do
                            return 0;
                          end end 
                        end else do
                          return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Break ]]Block.__(0, {
                                                      "@ ",
                                                      1,
                                                      0
                                                    }),
                                                  --[[ End_of_format ]]0
                                                })}),
                                          "%a@ "
                                        }), include_err$2, err);
                        end end 
                      end end), param);
        end end);
    end end;
    return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Formatting_gen ]]Block.__(18, {
                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                              --[[ String_literal ]]Block.__(11, {
                                  "<v>",
                                  --[[ End_of_format ]]0
                                }),
                              "<v>"
                            }}),
                        --[[ Alpha ]]Block.__(15, {--[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                    --[[ Close_box ]]0,
                                    --[[ End_of_format ]]0
                                  })})})
                      }),
                    "@[<v>%a%a@]"
                  }), print_errs, match[0], include_err$2, match[1]);
  end end 
end end

register_error_of_exn((function (param) do
        if (param[0] == __Error$5) then do
          return error_of_printer_file(report_error$4, param[1]);
        end
         end 
      end end));

function get_location(ti) do
  local ___conditional___=(ti.tag | 0);
  do
     if ___conditional___ = 0--[[ Ti_pat ]] then do
        return ti[0].pat_loc;end end end 
     if ___conditional___ = 1--[[ Ti_expr ]] then do
        return ti[0].exp_loc;end end end 
     if ___conditional___ = 2--[[ Ti_class ]] then do
        return ti[0].cl_loc;end end end 
     if ___conditional___ = 3--[[ Ti_mod ]] then do
        return ti[0].mod_loc;end end end 
     if ___conditional___ = 4--[[ An_call ]]
     or ___conditional___ = 5--[[ An_ident ]] then do
        return ti[0];end end end 
     do
    
  end
end end

annotations$1 = do
  contents: --[[ [] ]]0
end;

phrases = do
  contents: --[[ [] ]]0
end;

function record$2(ti) do
  if (annotations.contents and not get_location(ti).loc_ghost) then do
    annotations$1.contents = --[[ :: ]]{
      ti,
      annotations$1.contents
    };
    return --[[ () ]]0;
  end else do
    return 0;
  end end 
end end

function make_pat(desc, ty, tenv) do
  return do
          pat_desc: desc,
          pat_loc: none,
          pat_extra: --[[ [] ]]0,
          pat_type: ty,
          pat_env: tenv,
          pat_attributes: --[[ [] ]]0
        end;
end end

omega = make_pat(--[[ Tpat_any ]]0, none$2, empty);

extra_pat = make_pat(--[[ Tpat_var ]]Block.__(0, {
        create("+"),
        do
          txt: "+",
          loc: none
        end
      }), none$2, empty);

function omegas(i) do
  if (i <= 0) then do
    return --[[ [] ]]0;
  end else do
    return --[[ :: ]]{
            omega,
            omegas(i - 1 | 0)
          };
  end end 
end end

zero = make_pat(--[[ Tpat_constant ]]Block.__(2, {--[[ Const_int ]]Block.__(0, {0})}), none$2, empty);

function is_absent(tag, row) do
  return row_field(tag, row.contents) == --[[ Rabsent ]]0;
end end

function is_absent_pat(p) do
  match = p.pat_desc;
  if (typeof match == "number" or match.tag ~= --[[ Tpat_variant ]]5) then do
    return false;
  end else do
    return is_absent(match[0], match[2]);
  end end 
end end

function const_compare(x, y) do
  local ___conditional___=(x.tag | 0);
  do
     if ___conditional___ = 2--[[ Const_string ]] then do
        if (y.tag == --[[ Const_string ]]2) then do
          return Caml_primitive.caml_string_compare(x[0], y[0]);
        end else do
          return Caml_obj.caml_compare(x, y);
        end end end end end 
     if ___conditional___ = 3--[[ Const_float ]] then do
        if (y.tag == --[[ Const_float ]]3) then do
          return Caml_primitive.caml_float_compare(Caml_format.caml_float_of_string(x[0]), Caml_format.caml_float_of_string(y[0]));
        end else do
          return Caml_obj.caml_compare(x, y);
        end end end end end 
     do
    else do
      return Caml_obj.caml_compare(x, y);
      end end
      
  end
end end

function records_args(l1, l2) do
  _r1 = --[[ [] ]]0;
  _r2 = --[[ [] ]]0;
  _l1 = l1;
  _l2 = l2;
  while(true) do
    l2$1 = _l2;
    l1$1 = _l1;
    r2 = _r2;
    r1 = _r1;
    if (l1$1) then do
      rem1 = l1$1[1];
      match = l1$1[0];
      p1 = match[2];
      lbl1 = match[1];
      if (l2$1) then do
        rem2 = l2$1[1];
        match$1 = l2$1[0];
        p2 = match$1[2];
        lbl2 = match$1[1];
        if (lbl1.lbl_pos < lbl2.lbl_pos) then do
          _l1 = rem1;
          _r2 = --[[ :: ]]{
            omega,
            r2
          };
          _r1 = --[[ :: ]]{
            p1,
            r1
          };
          continue ;
        end else if (lbl1.lbl_pos > lbl2.lbl_pos) then do
          _l2 = rem2;
          _r2 = --[[ :: ]]{
            p2,
            r2
          };
          _r1 = --[[ :: ]]{
            omega,
            r1
          };
          continue ;
        end else do
          _l2 = rem2;
          _l1 = rem1;
          _r2 = --[[ :: ]]{
            p2,
            r2
          };
          _r1 = --[[ :: ]]{
            p1,
            r1
          };
          continue ;
        end end  end 
      end else do
        _l2 = --[[ [] ]]0;
        _l1 = rem1;
        _r2 = --[[ :: ]]{
          omega,
          r2
        };
        _r1 = --[[ :: ]]{
          p1,
          r1
        };
        continue ;
      end end 
    end else if (l2$1) then do
      _l2 = l2$1[1];
      _l1 = --[[ [] ]]0;
      _r2 = --[[ :: ]]{
        l2$1[0][2],
        r2
      };
      _r1 = --[[ :: ]]{
        omega,
        r1
      };
      continue ;
    end else do
      return --[[ tuple ]]{
              List.rev(r1),
              List.rev(r2)
            };
    end end  end 
  end;
end end

function compat(_p, _q) do
  while(true) do
    q = _q;
    p = _p;
    match = p.pat_desc;
    match$1 = q.pat_desc;
    exit = 0;
    if (typeof match == "number") then do
      exit = 1;
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 1--[[ Tpat_alias ]] then do
            _p = match[0];
            continue ;end end end 
         if ___conditional___ = 2--[[ Tpat_constant ]] then do
            if (typeof match$1 == "number") then do
              exit = 1;
            end else do
              local ___conditional___=(match$1.tag | 0);
              do
                 if ___conditional___ = 0--[[ Tpat_var ]]
                 or ___conditional___ = 1--[[ Tpat_alias ]] then do
                    exit = 1;end else 
                 if ___conditional___ = 2--[[ Tpat_constant ]] then do
                    return const_compare(match[0], match$1[0]) == 0;end end end 
                 if ___conditional___ = 8--[[ Tpat_or ]] then do
                    exit = 2;end else 
                 do end end
                else do
                  exit = 3;
                  end end
                  
              end
            end end end else 
         if ___conditional___ = 3--[[ Tpat_tuple ]] then do
            if (typeof match$1 == "number") then do
              exit = 1;
            end else do
              local ___conditional___=(match$1.tag | 0);
              do
                 if ___conditional___ = 0--[[ Tpat_var ]]
                 or ___conditional___ = 1--[[ Tpat_alias ]] then do
                    exit = 1;end else 
                 if ___conditional___ = 3--[[ Tpat_tuple ]] then do
                    return compats(match[0], match$1[0]);end end end 
                 if ___conditional___ = 8--[[ Tpat_or ]] then do
                    exit = 2;end else 
                 do end end
                else do
                  exit = 3;
                  end end
                  
              end
            end end end else 
         if ___conditional___ = 4--[[ Tpat_construct ]] then do
            if (typeof match$1 == "number") then do
              exit = 1;
            end else do
              local ___conditional___=(match$1.tag | 0);
              do
                 if ___conditional___ = 0--[[ Tpat_var ]]
                 or ___conditional___ = 1--[[ Tpat_alias ]] then do
                    exit = 1;end else 
                 if ___conditional___ = 4--[[ Tpat_construct ]] then do
                    if (equal_tag(match[1].cstr_tag, match$1[1].cstr_tag)) then do
                      return compats(match[2], match$1[2]);
                    end else do
                      return false;
                    end end end end end 
                 if ___conditional___ = 8--[[ Tpat_or ]] then do
                    exit = 2;end else 
                 do end end
                else do
                  exit = 3;
                  end end
                  
              end
            end end end else 
         if ___conditional___ = 5--[[ Tpat_variant ]] then do
            match$2 = match[1];
            l1 = match[0];
            if (match$2 ~= undefined) then do
              if (typeof match$1 == "number") then do
                exit = 1;
              end else do
                local ___conditional___=(match$1.tag | 0);
                do
                   if ___conditional___ = 0--[[ Tpat_var ]]
                   or ___conditional___ = 1--[[ Tpat_alias ]] then do
                      exit = 1;end else 
                   if ___conditional___ = 5--[[ Tpat_variant ]] then do
                      match$3 = match$1[1];
                      if (match$3 ~= undefined and l1 == match$1[0]) then do
                        _q = match$3;
                        _p = match$2;
                        continue ;
                      end else do
                        return false;
                      end end end end end 
                   if ___conditional___ = 8--[[ Tpat_or ]] then do
                      exit = 2;end else 
                   do end end
                  else do
                    exit = 3;
                    end end
                    
                end
              end end 
            end else if (typeof match$1 == "number") then do
              exit = 1;
            end else do
              local ___conditional___=(match$1.tag | 0);
              do
                 if ___conditional___ = 0--[[ Tpat_var ]]
                 or ___conditional___ = 1--[[ Tpat_alias ]] then do
                    exit = 1;end else 
                 if ___conditional___ = 5--[[ Tpat_variant ]] then do
                    if (match$1[1] ~= undefined) then do
                      return false;
                    end else do
                      return l1 == match$1[0];
                    end end end end end 
                 if ___conditional___ = 8--[[ Tpat_or ]] then do
                    exit = 2;end else 
                 do end end
                else do
                  exit = 3;
                  end end
                  
              end
            end end  end end else 
         if ___conditional___ = 6--[[ Tpat_record ]] then do
            if (typeof match$1 == "number") then do
              exit = 1;
            end else do
              local ___conditional___=(match$1.tag | 0);
              do
                 if ___conditional___ = 0--[[ Tpat_var ]]
                 or ___conditional___ = 1--[[ Tpat_alias ]] then do
                    exit = 1;end else 
                 if ___conditional___ = 6--[[ Tpat_record ]] then do
                    match$4 = records_args(match[0], match$1[0]);
                    return compats(match$4[0], match$4[1]);end end end 
                 if ___conditional___ = 8--[[ Tpat_or ]] then do
                    exit = 2;end else 
                 do end end
                else do
                  exit = 3;
                  end end
                  
              end
            end end end else 
         if ___conditional___ = 7--[[ Tpat_array ]] then do
            ps = match[0];
            if (typeof match$1 == "number") then do
              exit = 1;
            end else do
              local ___conditional___=(match$1.tag | 0);
              do
                 if ___conditional___ = 0--[[ Tpat_var ]]
                 or ___conditional___ = 1--[[ Tpat_alias ]] then do
                    exit = 1;end else 
                 if ___conditional___ = 7--[[ Tpat_array ]] then do
                    qs = match$1[0];
                    if (List.length(ps) == List.length(qs)) then do
                      return compats(ps, qs);
                    end else do
                      return false;
                    end end end end end 
                 if ___conditional___ = 8--[[ Tpat_or ]] then do
                    exit = 2;end else 
                 do end end
                else do
                  exit = 3;
                  end end
                  
              end
            end end end else 
         if ___conditional___ = 9--[[ Tpat_lazy ]] then do
            if (typeof match$1 == "number") then do
              exit = 1;
            end else do
              local ___conditional___=(match$1.tag | 0);
              do
                 if ___conditional___ = 0--[[ Tpat_var ]]
                 or ___conditional___ = 1--[[ Tpat_alias ]] then do
                    exit = 1;end else 
                 if ___conditional___ = 8--[[ Tpat_or ]] then do
                    exit = 2;end else 
                 if ___conditional___ = 9--[[ Tpat_lazy ]] then do
                    _q = match$1[0];
                    _p = match[0];
                    continue ;end end end 
                 do end end
                else do
                  exit = 3;
                  end end
                  
              end
            end end end else 
         do end end end end end end end
        else do
          exit = 1;
          end end
          
      end
    end end 
    local ___conditional___=(exit);
    do
       if ___conditional___ = 1 then do
          if (typeof match$1 == "number") then do
            return true;
          end else do
            local ___conditional___=(match$1.tag | 0);
            do
               if ___conditional___ = 0--[[ Tpat_var ]] then do
                  return true;end end end 
               if ___conditional___ = 1--[[ Tpat_alias ]] then do
                  _q = match$1[0];
                  continue ;end end end 
               do
              else do
                if (typeof match == "number" or not (match.tag and not compat(match[0], q))) then do
                  return true;
                end else do
                  _p = match[1];
                  continue ;
                end end 
                end end
                
            end
          end end end end end 
       if ___conditional___ = 2 then do
          if (compat(p, match$1[0])) then do
            return true;
          end else do
            _q = match$1[1];
            continue ;
          end end end end end 
       if ___conditional___ = 3 then do
          throw {
                Caml_builtin_exceptions.assert_failure,
                --[[ tuple ]]{
                  "parmatch.ml",
                  106,
                  6
                }
              };end end end 
       do
      
    end
  end;
end end

function compats(_ps, _qs) do
  while(true) do
    qs = _qs;
    ps = _ps;
    if (ps) then do
      if (qs) then do
        if (compat(ps[0], qs[0])) then do
          _qs = qs[1];
          _ps = ps[1];
          continue ;
        end else do
          return false;
        end end 
      end else do
        throw {
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "parmatch.ml",
                111,
                12
              }
            };
      end end 
    end else if (qs) then do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "parmatch.ml",
              111,
              12
            }
          };
    end else do
      return true;
    end end  end 
  end;
end end

Empty = Caml_exceptions.create("Ocaml_typedtree_test.Parmatch.Empty");

function clean_copy(ty) do
  if (ty.level == 100000000) then do
    return ty;
  end else do
    return type_expr(identity, ty);
  end end 
end end

function get_type_path(ty, tenv) do
  ty$1 = repr(expand_head(tenv, clean_copy(ty)));
  match = ty$1.desc;
  if (typeof match == "number" or match.tag ~= --[[ Tconstr ]]3) then do
    return fatal_error("Parmatch.get_type_path");
  end else do
    return match[0];
  end end 
end end

function is_cons(param) do
  if (param.cstr_name == "::") then do
    return true;
  end else do
    return false;
  end end 
end end

function pretty_const(c) do
  local ___conditional___=(c.tag | 0);
  do
     if ___conditional___ = 0--[[ Const_int ]] then do
        return Curry._1(Printf.sprintf(--[[ Format ]]{
                        --[[ Int ]]Block.__(4, {
                            --[[ Int_d ]]0,
                            --[[ No_padding ]]0,
                            --[[ No_precision ]]0,
                            --[[ End_of_format ]]0
                          }),
                        "%d"
                      }), c[0]);end end end 
     if ___conditional___ = 1--[[ Const_char ]] then do
        return Curry._1(Printf.sprintf(--[[ Format ]]{
                        --[[ Caml_char ]]Block.__(1, {--[[ End_of_format ]]0}),
                        "%C"
                      }), c[0]);end end end 
     if ___conditional___ = 2--[[ Const_string ]] then do
        return Curry._1(Printf.sprintf(--[[ Format ]]{
                        --[[ Caml_string ]]Block.__(3, {
                            --[[ No_padding ]]0,
                            --[[ End_of_format ]]0
                          }),
                        "%S"
                      }), c[0]);end end end 
     if ___conditional___ = 3--[[ Const_float ]] then do
        return Curry._1(Printf.sprintf(--[[ Format ]]{
                        --[[ String ]]Block.__(2, {
                            --[[ No_padding ]]0,
                            --[[ End_of_format ]]0
                          }),
                        "%s"
                      }), c[0]);end end end 
     if ___conditional___ = 4--[[ Const_int32 ]] then do
        return Curry._1(Printf.sprintf(--[[ Format ]]{
                        --[[ Int32 ]]Block.__(5, {
                            --[[ Int_d ]]0,
                            --[[ No_padding ]]0,
                            --[[ No_precision ]]0,
                            --[[ Char_literal ]]Block.__(12, {
                                --[[ "l" ]]108,
                                --[[ End_of_format ]]0
                              })
                          }),
                        "%ldl"
                      }), c[0]);end end end 
     if ___conditional___ = 5--[[ Const_int64 ]] then do
        return Curry._1(Printf.sprintf(--[[ Format ]]{
                        --[[ Int64 ]]Block.__(7, {
                            --[[ Int_d ]]0,
                            --[[ No_padding ]]0,
                            --[[ No_precision ]]0,
                            --[[ Char_literal ]]Block.__(12, {
                                --[[ "L" ]]76,
                                --[[ End_of_format ]]0
                              })
                          }),
                        "%LdL"
                      }), c[0]);end end end 
     if ___conditional___ = 6--[[ Const_nativeint ]] then do
        return Curry._1(Printf.sprintf(--[[ Format ]]{
                        --[[ Nativeint ]]Block.__(6, {
                            --[[ Int_d ]]0,
                            --[[ No_padding ]]0,
                            --[[ No_precision ]]0,
                            --[[ Char_literal ]]Block.__(12, {
                                --[[ "n" ]]110,
                                --[[ End_of_format ]]0
                              })
                          }),
                        "%ndn"
                      }), c[0]);end end end 
     do
    
  end
end end

function pretty_val(ppf, v) do
  match = v.pat_extra;
  if (match) then do
    rem = match[1];
    tmp = match[0][0];
    if (typeof tmp == "number") then do
      return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Formatting_gen ]]Block.__(18, {
                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                --[[ End_of_format ]]0,
                                ""
                              }}),
                          --[[ String_literal ]]Block.__(11, {
                              "(module ",
                              --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                      --[[ ")" ]]41,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Close_box ]]0,
                                          --[[ End_of_format ]]0
                                        })
                                    })})
                            })
                        }),
                      "@[(module %a)@]"
                    }), pretty_val, do
                  pat_desc: v.pat_desc,
                  pat_loc: v.pat_loc,
                  pat_extra: rem,
                  pat_type: v.pat_type,
                  pat_env: v.pat_env,
                  pat_attributes: v.pat_attributes
                end);
    end else if (tmp.tag) then do
      return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Formatting_gen ]]Block.__(18, {
                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                --[[ End_of_format ]]0,
                                ""
                              }}),
                          --[[ String_literal ]]Block.__(11, {
                              "(# ",
                              --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                      --[[ ")" ]]41,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Close_box ]]0,
                                          --[[ End_of_format ]]0
                                        })
                                    })})
                            })
                        }),
                      "@[(# %a)@]"
                    }), pretty_val, do
                  pat_desc: v.pat_desc,
                  pat_loc: v.pat_loc,
                  pat_extra: rem,
                  pat_type: v.pat_type,
                  pat_env: v.pat_env,
                  pat_attributes: v.pat_attributes
                end);
    end else do
      return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Formatting_gen ]]Block.__(18, {
                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                --[[ End_of_format ]]0,
                                ""
                              }}),
                          --[[ Char_literal ]]Block.__(12, {
                              --[[ "(" ]]40,
                              --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                      " : _)",
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Close_box ]]0,
                                          --[[ End_of_format ]]0
                                        })
                                    })})
                            })
                        }),
                      "@[(%a : _)@]"
                    }), pretty_val, do
                  pat_desc: v.pat_desc,
                  pat_loc: v.pat_loc,
                  pat_extra: rem,
                  pat_type: v.pat_type,
                  pat_env: v.pat_env,
                  pat_attributes: v.pat_attributes
                end);
    end end  end 
  end else do
    match$1 = v.pat_desc;
    if (typeof match$1 == "number") then do
      return Format.fprintf(ppf, --[[ Format ]]{
                  --[[ Char_literal ]]Block.__(12, {
                      --[[ "_" ]]95,
                      --[[ End_of_format ]]0
                    }),
                  "_"
                });
    end else do
      local ___conditional___=(match$1.tag | 0);
      do
         if ___conditional___ = 0--[[ Tpat_var ]] then do
            return print$2(ppf, match$1[0]);end end end 
         if ___conditional___ = 1--[[ Tpat_alias ]] then do
            return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                            --[[ Formatting_gen ]]Block.__(18, {
                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                      --[[ End_of_format ]]0,
                                      ""
                                    }}),
                                --[[ Char_literal ]]Block.__(12, {
                                    --[[ "(" ]]40,
                                    --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ String_literal ]]Block.__(11, {
                                                "as ",
                                                --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                        --[[ ")" ]]41,
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Close_box ]]0,
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })})
                                              })
                                          })})
                                  })
                              }),
                            "@[(%a@ as %a)@]"
                          }), pretty_val, match$1[0], print$2, match$1[1]);end end end 
         if ___conditional___ = 2--[[ Tpat_constant ]] then do
            return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                            --[[ String ]]Block.__(2, {
                                --[[ No_padding ]]0,
                                --[[ End_of_format ]]0
                              }),
                            "%s"
                          }), pretty_const(match$1[0]));end end end 
         if ___conditional___ = 3--[[ Tpat_tuple ]] then do
            return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                            --[[ Formatting_gen ]]Block.__(18, {
                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                      --[[ End_of_format ]]0,
                                      ""
                                    }}),
                                --[[ Char_literal ]]Block.__(12, {
                                    --[[ "(" ]]40,
                                    --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                            --[[ ")" ]]41,
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Close_box ]]0,
                                                --[[ End_of_format ]]0
                                              })
                                          })})
                                  })
                              }),
                            "@[(%a)@]"
                          }), (function (param, param$1) do
                          return pretty_vals(",", param, param$1);
                        end end), match$1[0]);end end end 
         if ___conditional___ = 4--[[ Tpat_construct ]] then do
            vs = match$1[2];
            cstr = match$1[1];
            if (vs) then do
              if (vs[1]) then do
                name = cstr.cstr_name;
                if (name == "::" and vs) then do
                  match$2 = vs[1];
                  if (match$2 and not match$2[1]) then do
                    return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                                    --[[ Formatting_gen ]]Block.__(18, {
                                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                              --[[ End_of_format ]]0,
                                              ""
                                            }}),
                                        --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                                "::",
                                                --[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@,",
                                                        0,
                                                        0
                                                      }),
                                                    --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Close_box ]]0,
                                                            --[[ End_of_format ]]0
                                                          })})
                                                  })
                                              })})
                                      }),
                                    "@[%a::@,%a@]"
                                  }), pretty_car, vs[0], pretty_cdr, match$2[0]);
                  end
                   end 
                end
                 end 
                return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                                --[[ Formatting_gen ]]Block.__(18, {
                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "<2>",
                                              --[[ End_of_format ]]0
                                            }),
                                          "<2>"
                                        }}),
                                    --[[ String ]]Block.__(2, {
                                        --[[ No_padding ]]0,
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ Formatting_gen ]]Block.__(18, {
                                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                      --[[ End_of_format ]]0,
                                                      ""
                                                    }}),
                                                --[[ Char_literal ]]Block.__(12, {
                                                    --[[ "(" ]]40,
                                                    --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                            --[[ ")" ]]41,
                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                --[[ Close_box ]]0,
                                                                --[[ Formatting_lit ]]Block.__(17, {
                                                                    --[[ Close_box ]]0,
                                                                    --[[ End_of_format ]]0
                                                                  })
                                                              })
                                                          })})
                                                  })
                                              })
                                          })
                                      })
                                  }),
                                "@[<2>%s@ @[(%a)@]@]"
                              }), name, (function (param, param$1) do
                              return pretty_vals(",", param, param$1);
                            end end), vs);
              end else do
                return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                                --[[ Formatting_gen ]]Block.__(18, {
                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "<2>",
                                              --[[ End_of_format ]]0
                                            }),
                                          "<2>"
                                        }}),
                                    --[[ String ]]Block.__(2, {
                                        --[[ No_padding ]]0,
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Close_box ]]0,
                                                    --[[ End_of_format ]]0
                                                  })})
                                          })
                                      })
                                  }),
                                "@[<2>%s@ %a@]"
                              }), cstr.cstr_name, pretty_arg, vs[0]);
              end end 
            end else do
              return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ End_of_format ]]0
                                }),
                              "%s"
                            }), cstr.cstr_name);
            end end end else 
         if ___conditional___ = 5--[[ Tpat_variant ]] then do
            match$3 = match$1[1];
            l = match$1[0];
            if (match$3 ~= undefined) then do
              return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                              --[[ Formatting_gen ]]Block.__(18, {
                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                        --[[ String_literal ]]Block.__(11, {
                                            "<2>",
                                            --[[ End_of_format ]]0
                                          }),
                                        "<2>"
                                      }}),
                                  --[[ Char_literal ]]Block.__(12, {
                                      --[[ "`" ]]96,
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@ ",
                                                  1,
                                                  0
                                                }),
                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Close_box ]]0,
                                                      --[[ End_of_format ]]0
                                                    })})
                                            })
                                        })
                                    })
                                }),
                              "@[<2>`%s@ %a@]"
                            }), l, pretty_arg, match$3);
            end else do
              return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                              --[[ Char_literal ]]Block.__(12, {
                                  --[[ "`" ]]96,
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ End_of_format ]]0
                                    })
                                }),
                              "`%s"
                            }), l);
            end end end end end 
         if ___conditional___ = 6--[[ Tpat_record ]] then do
            return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                            --[[ Formatting_gen ]]Block.__(18, {
                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                      --[[ End_of_format ]]0,
                                      ""
                                    }}),
                                --[[ Char_literal ]]Block.__(12, {
                                    --[[ "{" ]]123,
                                    --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                            --[[ "}" ]]125,
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Close_box ]]0,
                                                --[[ End_of_format ]]0
                                              })
                                          })})
                                  })
                              }),
                            "@[{%a}@]"
                          }), pretty_lvals, List.filter((function (param) do
                                if (typeof param[2].pat_desc == "number") then do
                                  return false;
                                end else do
                                  return true;
                                end end 
                              end end))(match$1[0]));end end end 
         if ___conditional___ = 7--[[ Tpat_array ]] then do
            return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                            --[[ Formatting_gen ]]Block.__(18, {
                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                      --[[ End_of_format ]]0,
                                      ""
                                    }}),
                                --[[ String_literal ]]Block.__(11, {
                                    "[| ",
                                    --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                            " |]",
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Close_box ]]0,
                                                --[[ End_of_format ]]0
                                              })
                                          })})
                                  })
                              }),
                            "@[[| %a |]@]"
                          }), (function (param, param$1) do
                          return pretty_vals(" ;", param, param$1);
                        end end), match$1[0]);end end end 
         if ___conditional___ = 8--[[ Tpat_or ]] then do
            return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                            --[[ Formatting_gen ]]Block.__(18, {
                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                      --[[ End_of_format ]]0,
                                      ""
                                    }}),
                                --[[ Char_literal ]]Block.__(12, {
                                    --[[ "(" ]]40,
                                    --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                            --[[ "|" ]]124,
                                            --[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Break ]]Block.__(0, {
                                                    "@,",
                                                    0,
                                                    0
                                                  }),
                                                --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                        --[[ ")" ]]41,
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Close_box ]]0,
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })})
                                              })
                                          })})
                                  })
                              }),
                            "@[(%a|@,%a)@]"
                          }), pretty_or, match$1[0], pretty_or, match$1[1]);end end end 
         if ___conditional___ = 9--[[ Tpat_lazy ]] then do
            return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                            --[[ Formatting_gen ]]Block.__(18, {
                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                      --[[ String_literal ]]Block.__(11, {
                                          "<2>",
                                          --[[ End_of_format ]]0
                                        }),
                                      "<2>"
                                    }}),
                                --[[ String_literal ]]Block.__(11, {
                                    "lazy",
                                    --[[ Formatting_lit ]]Block.__(17, {
                                        --[[ Break ]]Block.__(0, {
                                            "@ ",
                                            1,
                                            0
                                          }),
                                        --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                --[[ Close_box ]]0,
                                                --[[ End_of_format ]]0
                                              })})
                                      })
                                  })
                              }),
                            "@[<2>lazy@ %a@]"
                          }), pretty_arg, match$1[0]);end end end 
         do
        
      end
    end end 
  end end 
end end

function pretty_car(ppf, v) do
  match = v.pat_desc;
  if (typeof match == "number" or match.tag ~= --[[ Tpat_construct ]]4) then do
    return pretty_val(ppf, v);
  end else do
    match$1 = match[2];
    if (match$1) then do
      match$2 = match$1[1];
      if (match$2 and not (match$2[1] or not is_cons(match[1]))) then do
        return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Char_literal ]]Block.__(12, {
                            --[[ "(" ]]40,
                            --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                    --[[ ")" ]]41,
                                    --[[ End_of_format ]]0
                                  })})
                          }),
                        "(%a)"
                      }), pretty_val, v);
      end else do
        return pretty_val(ppf, v);
      end end 
    end else do
      return pretty_val(ppf, v);
    end end 
  end end 
end end

function pretty_cdr(ppf, v) do
  match = v.pat_desc;
  if (typeof match == "number" or match.tag ~= --[[ Tpat_construct ]]4) then do
    return pretty_val(ppf, v);
  end else do
    match$1 = match[2];
    if (match$1) then do
      match$2 = match$1[1];
      if (match$2 and not (match$2[1] or not is_cons(match[1]))) then do
        return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                        --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                "::",
                                --[[ Formatting_lit ]]Block.__(17, {
                                    --[[ Break ]]Block.__(0, {
                                        "@,",
                                        0,
                                        0
                                      }),
                                    --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                  })
                              })}),
                        "%a::@,%a"
                      }), pretty_car, match$1[0], pretty_cdr, match$2[0]);
      end else do
        return pretty_val(ppf, v);
      end end 
    end else do
      return pretty_val(ppf, v);
    end end 
  end end 
end end

function pretty_arg(ppf, v) do
  match = v.pat_desc;
  if (typeof match == "number") then do
    return pretty_val(ppf, v);
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 4--[[ Tpat_construct ]] then do
          if (not match[2]) then do
            return pretty_val(ppf, v);
          end
           end end else 
       if ___conditional___ = 5--[[ Tpat_variant ]] then do
          if (match[1] == undefined) then do
            return pretty_val(ppf, v);
          end
           end end else 
       do end end end
      else do
        return pretty_val(ppf, v);
        end end
        
    end
  end end 
  return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                  --[[ Char_literal ]]Block.__(12, {
                      --[[ "(" ]]40,
                      --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                              --[[ ")" ]]41,
                              --[[ End_of_format ]]0
                            })})
                    }),
                  "(%a)"
                }), pretty_val, v);
end end

function pretty_or(ppf, v) do
  match = v.pat_desc;
  if (typeof match == "number" or match.tag ~= --[[ Tpat_or ]]8) then do
    return pretty_val(ppf, v);
  end else do
    return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                            --[[ "|" ]]124,
                            --[[ Formatting_lit ]]Block.__(17, {
                                --[[ Break ]]Block.__(0, {
                                    "@,",
                                    0,
                                    0
                                  }),
                                --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                              })
                          })}),
                    "%a|@,%a"
                  }), pretty_or, match[0], pretty_or, match[1]);
  end end 
end end

function pretty_vals(sep, ppf, param) do
  if (param) then do
    vs = param[1];
    v = param[0];
    if (vs) then do
      return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Alpha ]]Block.__(15, {--[[ String ]]Block.__(2, {
                              --[[ No_padding ]]0,
                              --[[ Formatting_lit ]]Block.__(17, {
                                  --[[ Break ]]Block.__(0, {
                                      "@ ",
                                      1,
                                      0
                                    }),
                                  --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                })
                            })}),
                      "%a%s@ %a"
                    }), pretty_val, v, sep, (function (param, param$1) do
                    return pretty_vals(sep, param, param$1);
                  end end), vs);
    end else do
      return pretty_val(ppf, v);
    end end 
  end else do
    return --[[ () ]]0;
  end end 
end end

function pretty_lvals(ppf, param) do
  if (param) then do
    rest = param[1];
    match = param[0];
    v = match[2];
    lbl = match[1];
    if (rest) then do
      return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String ]]Block.__(2, {
                          --[[ No_padding ]]0,
                          --[[ Char_literal ]]Block.__(12, {
                              --[[ "=" ]]61,
                              --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                      --[[ ";" ]]59,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                        })
                                    })})
                            })
                        }),
                      "%s=%a;@ %a"
                    }), lbl.lbl_name, pretty_val, v, pretty_lvals, rest);
    end else do
      return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String ]]Block.__(2, {
                          --[[ No_padding ]]0,
                          --[[ Char_literal ]]Block.__(12, {
                              --[[ "=" ]]61,
                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                            })
                        }),
                      "%s=%a"
                    }), lbl.lbl_name, pretty_val, v);
    end end 
  end else do
    return --[[ () ]]0;
  end end 
end end

function top_pretty(ppf, v) do
  return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                  --[[ Formatting_gen ]]Block.__(18, {
                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                            --[[ End_of_format ]]0,
                            ""
                          }}),
                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                              --[[ Close_box ]]0,
                              --[[ Formatting_lit ]]Block.__(17, {
                                  --[[ FFlush ]]2,
                                  --[[ End_of_format ]]0
                                })
                            })})
                    }),
                  "@[%a@]@?"
                }), pretty_val, v);
end end

function simple_match(p1, p2) do
  match = p1.pat_desc;
  match$1 = p2.pat_desc;
  if (typeof match ~= "number") then do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 2--[[ Tpat_constant ]] then do
          if (typeof match$1 ~= "number") then do
            local ___conditional___=(match$1.tag | 0);
            do
               if ___conditional___ = 0--[[ Tpat_var ]]
               or ___conditional___ = 2--[[ Tpat_constant ]] then do
                  return const_compare(match[0], match$1[0]) == 0;end end end 
               do
              else do
                return false;
                end end
                
            end
          end
           end end else 
       if ___conditional___ = 3--[[ Tpat_tuple ]] then do
          if (typeof match$1 ~= "number") then do
            local ___conditional___=(match$1.tag | 0);
            do
               if ___conditional___ = 0--[[ Tpat_var ]]
               or ___conditional___ = 3--[[ Tpat_tuple ]] then do
                  return true;end end end 
               do
              else do
                return false;
                end end
                
            end
          end
           end end else 
       if ___conditional___ = 4--[[ Tpat_construct ]] then do
          if (typeof match$1 ~= "number") then do
            local ___conditional___=(match$1.tag | 0);
            do
               if ___conditional___ = 0--[[ Tpat_var ]]
               or ___conditional___ = 4--[[ Tpat_construct ]] then do
                  return equal_tag(match[1].cstr_tag, match$1[1].cstr_tag);end end end 
               do
              else do
                return false;
                end end
                
            end
          end
           end end else 
       if ___conditional___ = 5--[[ Tpat_variant ]] then do
          if (typeof match$1 ~= "number") then do
            local ___conditional___=(match$1.tag | 0);
            do
               if ___conditional___ = 0--[[ Tpat_var ]]
               or ___conditional___ = 5--[[ Tpat_variant ]] then do
                  return match[0] == match$1[0];end end end 
               do
              else do
                return false;
                end end
                
            end
          end
           end end else 
       if ___conditional___ = 6--[[ Tpat_record ]] then do
          if (typeof match$1 ~= "number") then do
            local ___conditional___=(match$1.tag | 0);
            do
               if ___conditional___ = 0--[[ Tpat_var ]]
               or ___conditional___ = 6--[[ Tpat_record ]] then do
                  return true;end end end 
               do
              else do
                return false;
                end end
                
            end
          end
           end end else 
       if ___conditional___ = 7--[[ Tpat_array ]] then do
          if (typeof match$1 ~= "number") then do
            local ___conditional___=(match$1.tag | 0);
            do
               if ___conditional___ = 0--[[ Tpat_var ]]
               or ___conditional___ = 7--[[ Tpat_array ]] then do
                  return List.length(match[0]) == List.length(match$1[0]);end end end 
               do
              else do
                return false;
                end end
                
            end
          end
           end end else 
       if ___conditional___ = 9--[[ Tpat_lazy ]] then do
          if (typeof match$1 ~= "number") then do
            local ___conditional___=(match$1.tag | 0);
            do
               if ___conditional___ = 0--[[ Tpat_var ]]
               or ___conditional___ = 9--[[ Tpat_lazy ]] then do
                  return true;end end end 
               do
              else do
                return false;
                end end
                
            end
          end
           end end else 
       do end end end end end end end end
      else do
        end end
        
    end
  end
   end 
  if (typeof match$1 == "number" or not match$1.tag) then do
    return true;
  end else do
    return false;
  end end 
end end

function record_arg(p) do
  match = p.pat_desc;
  if (typeof match == "number") then do
    return --[[ [] ]]0;
  end else if (match.tag == --[[ Tpat_record ]]6) then do
    return match[0];
  end else do
    return fatal_error("Parmatch.as_record");
  end end  end 
end end

function get_field(pos, arg) do
  return List.find((function (param) do
                  return pos == param[1].lbl_pos;
                end end), arg)[2];
end end

function simple_match_args(p1, _p2) do
  while(true) do
    p2 = _p2;
    match = p2.pat_desc;
    if (typeof match ~= "number") then do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 0--[[ Tpat_var ]]
         or ___conditional___ = 1--[[ Tpat_alias ]] then do
            _p2 = match[0];
            continue ;end end end 
         if ___conditional___ = 4--[[ Tpat_construct ]] then do
            return match[2];end end end 
         if ___conditional___ = 5--[[ Tpat_variant ]] then do
            match$1 = match[1];
            if (match$1 ~= undefined) then do
              return --[[ :: ]]{
                      match$1,
                      --[[ [] ]]0
                    };
            end else do
              return --[[ [] ]]0;
            end end end end end 
         if ___conditional___ = 6--[[ Tpat_record ]] then do
            omegas = record_arg(p1);
            arg = match[0];
            return List.map((function(arg)do
                      return function (param) do
                        try do
                          return get_field(param[1].lbl_pos, arg);
                        end
                        catch (exn)do
                          if (exn == Caml_builtin_exceptions.not_found) then do
                            return omega;
                          end else do
                            throw exn;
                          end end 
                        end
                      end end
                      end(arg)), omegas);end end end 
         if ___conditional___ = 3--[[ Tpat_tuple ]]
         or ___conditional___ = 7--[[ Tpat_array ]] then do
            return match[0];end end end 
         if ___conditional___ = 2--[[ Tpat_constant ]]
         or ___conditional___ = 8--[[ Tpat_or ]] then do
            return --[[ [] ]]0;end end end 
         if ___conditional___ = 9--[[ Tpat_lazy ]] then do
            return --[[ :: ]]{
                    match[0],
                    --[[ [] ]]0
                  };end end end 
         do
        
      end
    end
     end 
    match$2 = p1.pat_desc;
    if (typeof match$2 == "number") then do
      return --[[ [] ]]0;
    end else do
      local ___conditional___=(match$2.tag | 0);
      do
         if ___conditional___ = 3--[[ Tpat_tuple ]] then do
            return List.map((function (param) do
                          return omega;
                        end end), match$2[0]);end end end 
         if ___conditional___ = 4--[[ Tpat_construct ]] then do
            return List.map((function (param) do
                          return omega;
                        end end), match$2[2]);end end end 
         if ___conditional___ = 5--[[ Tpat_variant ]] then do
            if (match$2[1] ~= undefined) then do
              return --[[ :: ]]{
                      omega,
                      --[[ [] ]]0
                    };
            end else do
              return --[[ [] ]]0;
            end end end end end 
         if ___conditional___ = 6--[[ Tpat_record ]] then do
            return List.map((function (param) do
                          return omega;
                        end end), match$2[0]);end end end 
         if ___conditional___ = 7--[[ Tpat_array ]] then do
            return List.map((function (param) do
                          return omega;
                        end end), match$2[0]);end end end 
         if ___conditional___ = 9--[[ Tpat_lazy ]] then do
            return --[[ :: ]]{
                    omega,
                    --[[ [] ]]0
                  };end end end 
         do
        else do
          return --[[ [] ]]0;
          end end
          
      end
    end end 
  end;
end end

function normalize_pat(_q) do
  while(true) do
    q = _q;
    match = q.pat_desc;
    if (typeof match == "number") then do
      return q;
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 0--[[ Tpat_var ]] then do
            return make_pat(--[[ Tpat_any ]]0, q.pat_type, q.pat_env);end end end 
         if ___conditional___ = 1--[[ Tpat_alias ]] then do
            _q = match[0];
            continue ;end end end 
         if ___conditional___ = 2--[[ Tpat_constant ]] then do
            return q;end end end 
         if ___conditional___ = 3--[[ Tpat_tuple ]] then do
            return make_pat(--[[ Tpat_tuple ]]Block.__(3, {List.map((function (param) do
                                  return omega;
                                end end), match[0])}), q.pat_type, q.pat_env);end end end 
         if ___conditional___ = 4--[[ Tpat_construct ]] then do
            return make_pat(--[[ Tpat_construct ]]Block.__(4, {
                          match[0],
                          match[1],
                          List.map((function (param) do
                                  return omega;
                                end end), match[2])
                        }), q.pat_type, q.pat_env);end end end 
         if ___conditional___ = 5--[[ Tpat_variant ]] then do
            return make_pat(--[[ Tpat_variant ]]Block.__(5, {
                          match[0],
                          may_map((function (param) do
                                  return omega;
                                end end), match[1]),
                          match[2]
                        }), q.pat_type, q.pat_env);end end end 
         if ___conditional___ = 6--[[ Tpat_record ]] then do
            return make_pat(--[[ Tpat_record ]]Block.__(6, {
                          List.map((function (param) do
                                  return --[[ tuple ]]{
                                          param[0],
                                          param[1],
                                          omega
                                        };
                                end end), match[0]),
                          match[1]
                        }), q.pat_type, q.pat_env);end end end 
         if ___conditional___ = 7--[[ Tpat_array ]] then do
            return make_pat(--[[ Tpat_array ]]Block.__(7, {List.map((function (param) do
                                  return omega;
                                end end), match[0])}), q.pat_type, q.pat_env);end end end 
         if ___conditional___ = 8--[[ Tpat_or ]] then do
            return fatal_error("Parmatch.normalize_pat");end end end 
         if ___conditional___ = 9--[[ Tpat_lazy ]] then do
            return make_pat(--[[ Tpat_lazy ]]Block.__(9, {omega}), q.pat_type, q.pat_env);end end end 
         do
        
      end
    end end 
  end;
end end

function discr_pat(q, pss) do
  q$1 = normalize_pat(q);
  tmp = q$1.pat_desc;
  if (typeof tmp == "number" or tmp.tag == --[[ Tpat_record ]]6) then do
    _acc = q$1;
    _pss = pss;
    while(true) do
      pss$1 = _pss;
      acc = _acc;
      if (pss$1) then do
        match = pss$1[0];
        if (match) then do
          p = match[0];
          match$1 = p.pat_desc;
          if (typeof match$1 == "number") then do
            _pss = pss$1[1];
            continue ;
          end else do
            local ___conditional___=(match$1.tag | 0);
            do
               if ___conditional___ = 0--[[ Tpat_var ]] then do
                  _pss = pss$1[1];
                  continue ;end end end 
               if ___conditional___ = 1--[[ Tpat_alias ]] then do
                  _pss = --[[ :: ]]{
                    --[[ :: ]]{
                      match$1[0],
                      match[1]
                    },
                    pss$1[1]
                  };
                  continue ;end end end 
               if ___conditional___ = 6--[[ Tpat_record ]] then do
                  new_omegas = List.fold_right((function (param, r) do
                          lbl = param[1];
                          try do
                            get_field(lbl.lbl_pos, r);
                            return r;
                          end
                          catch (exn)do
                            if (exn == Caml_builtin_exceptions.not_found) then do
                              return --[[ :: ]]{
                                      --[[ tuple ]]{
                                        param[0],
                                        lbl,
                                        omega
                                      },
                                      r
                                    };
                            end else do
                              throw exn;
                            end end 
                          end
                        end end), match$1[0], record_arg(acc));
                  _pss = pss$1[1];
                  _acc = make_pat(--[[ Tpat_record ]]Block.__(6, {
                          new_omegas,
                          match$1[1]
                        }), p.pat_type, p.pat_env);
                  continue ;end end end 
               if ___conditional___ = 8--[[ Tpat_or ]] then do
                  ps = match[1];
                  _pss = --[[ :: ]]{
                    --[[ :: ]]{
                      match$1[0],
                      ps
                    },
                    --[[ :: ]]{
                      --[[ :: ]]{
                        match$1[1],
                        ps
                      },
                      pss$1[1]
                    }
                  };
                  continue ;end end end 
               if ___conditional___ = 3--[[ Tpat_tuple ]]
               or ___conditional___ = 9--[[ Tpat_lazy ]] then do
                  return normalize_pat(p);end end end 
               do
              else do
                return acc;
                end end
                
            end
          end end 
        end else do
          return acc;
        end end 
      end else do
        return acc;
      end end 
    end;
  end else do
    return q$1;
  end end 
end end

function read_args(xs, r) do
  if (xs) then do
    if (r) then do
      match = read_args(xs[1], r[1]);
      return --[[ tuple ]]{
              --[[ :: ]]{
                r[0],
                match[0]
              },
              match[1]
            };
    end else do
      return fatal_error("Parmatch.read_args");
    end end 
  end else do
    return --[[ tuple ]]{
            --[[ [] ]]0,
            r
          };
  end end 
end end

function do_set_args(erase_mutable, q, r) do
  match = q.pat_desc;
  if (typeof match == "number") then do
    return --[[ :: ]]{
            q,
            r
          };
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 2--[[ Tpat_constant ]] then do
          return --[[ :: ]]{
                  q,
                  r
                };end end end 
       if ___conditional___ = 3--[[ Tpat_tuple ]] then do
          match$1 = read_args(match[0], r);
          return --[[ :: ]]{
                  make_pat(--[[ Tpat_tuple ]]Block.__(3, {match$1[0]}), q.pat_type, q.pat_env),
                  match$1[1]
                };end end end 
       if ___conditional___ = 4--[[ Tpat_construct ]] then do
          match$2 = read_args(match[2], r);
          return --[[ :: ]]{
                  make_pat(--[[ Tpat_construct ]]Block.__(4, {
                          match[0],
                          match[1],
                          match$2[0]
                        }), q.pat_type, q.pat_env),
                  match$2[1]
                };end end end 
       if ___conditional___ = 5--[[ Tpat_variant ]] then do
          match$3;
          if (match[1] ~= undefined) then do
            if (r) then do
              match$3 = --[[ tuple ]]{
                r[0],
                r[1]
              };
            end else do
              throw {
                    Caml_builtin_exceptions.assert_failure,
                    --[[ tuple ]]{
                      "parmatch.ml",
                      450,
                      13
                    }
                  };
            end end 
          end else do
            match$3 = --[[ tuple ]]{
              undefined,
              r
            };
          end end 
          return --[[ :: ]]{
                  make_pat(--[[ Tpat_variant ]]Block.__(5, {
                          match[0],
                          match$3[0],
                          match[2]
                        }), q.pat_type, q.pat_env),
                  match$3[1]
                };end end end 
       if ___conditional___ = 6--[[ Tpat_record ]] then do
          omegas = match[0];
          match$4 = read_args(omegas, r);
          return --[[ :: ]]{
                  make_pat(--[[ Tpat_record ]]Block.__(6, {
                          List.map2((function (param, arg) do
                                  lbl = param[1];
                                  lid = param[0];
                                  tmp = false;
                                  if (erase_mutable) then do
                                    match = lbl.lbl_mut;
                                    tmp = match and true or false;
                                  end
                                   end 
                                  if (tmp) then do
                                    return --[[ tuple ]]{
                                            lid,
                                            lbl,
                                            omega
                                          };
                                  end else do
                                    return --[[ tuple ]]{
                                            lid,
                                            lbl,
                                            arg
                                          };
                                  end end 
                                end end), omegas, match$4[0]),
                          match[1]
                        }), q.pat_type, q.pat_env),
                  match$4[1]
                };end end end 
       if ___conditional___ = 7--[[ Tpat_array ]] then do
          match$5 = read_args(match[0], r);
          return --[[ :: ]]{
                  make_pat(--[[ Tpat_array ]]Block.__(7, {match$5[0]}), q.pat_type, q.pat_env),
                  match$5[1]
                };end end end 
       if ___conditional___ = 9--[[ Tpat_lazy ]] then do
          if (r) then do
            return --[[ :: ]]{
                    make_pat(--[[ Tpat_lazy ]]Block.__(9, {r[0]}), q.pat_type, q.pat_env),
                    r[1]
                  };
          end else do
            return fatal_error("Parmatch.do_set_args (lazy)");
          end end end end end 
       do
      else do
        return fatal_error("Parmatch.set_args");
        end end
        
    end
  end end 
end end

function filter_one(q, pss) do
  filter_rec = function (_param) do
    while(true) do
      param = _param;
      if (param) then do
        match = param[0];
        if (match) then do
          p = match[0];
          match$1 = p.pat_desc;
          if (typeof match$1 ~= "number") then do
            local ___conditional___=(match$1.tag | 0);
            do
               if ___conditional___ = 1--[[ Tpat_alias ]] then do
                  _param = --[[ :: ]]{
                    --[[ :: ]]{
                      match$1[0],
                      match[1]
                    },
                    param[1]
                  };
                  continue ;end end end 
               if ___conditional___ = 8--[[ Tpat_or ]] then do
                  ps = match[1];
                  _param = --[[ :: ]]{
                    --[[ :: ]]{
                      match$1[0],
                      ps
                    },
                    --[[ :: ]]{
                      --[[ :: ]]{
                        match$1[1],
                        ps
                      },
                      param[1]
                    }
                  };
                  continue ;end end end 
               do
              else do
                end end
                
            end
          end
           end 
          pss = param[1];
          if (simple_match(q, p)) then do
            return --[[ :: ]]{
                    Pervasives.$at(simple_match_args(q, p), match[1]),
                    filter_rec(pss)
                  };
          end else do
            _param = pss;
            continue ;
          end end 
        end else do
          return --[[ [] ]]0;
        end end 
      end else do
        return --[[ [] ]]0;
      end end 
    end;
  end end;
  return filter_rec(pss);
end end

function filter_extra(pss) do
  filter_rec = function (_param) do
    while(true) do
      param = _param;
      if (param) then do
        match = param[0];
        if (match) then do
          match$1 = match[0].pat_desc;
          if (typeof match$1 == "number") then do
            return --[[ :: ]]{
                    match[1],
                    filter_rec(param[1])
                  };
          end else do
            local ___conditional___=(match$1.tag | 0);
            do
               if ___conditional___ = 0--[[ Tpat_var ]] then do
                  return --[[ :: ]]{
                          match[1],
                          filter_rec(param[1])
                        };end end end 
               if ___conditional___ = 1--[[ Tpat_alias ]] then do
                  _param = --[[ :: ]]{
                    --[[ :: ]]{
                      match$1[0],
                      match[1]
                    },
                    param[1]
                  };
                  continue ;end end end 
               if ___conditional___ = 8--[[ Tpat_or ]] then do
                  ps = match[1];
                  _param = --[[ :: ]]{
                    --[[ :: ]]{
                      match$1[0],
                      ps
                    },
                    --[[ :: ]]{
                      --[[ :: ]]{
                        match$1[1],
                        ps
                      },
                      param[1]
                    }
                  };
                  continue ;end end end 
               do
              else do
                _param = param[1];
                continue ;
                end end
                
            end
          end end 
        end else do
          _param = param[1];
          continue ;
        end end 
      end else do
        return --[[ [] ]]0;
      end end 
    end;
  end end;
  return filter_rec(pss);
end end

function filter_all(pat0, pss) do
  insert = function (q, qs, env) do
    if (env) then do
      env$1 = env[1];
      c = env[0];
      q0 = c[0];
      if (simple_match(q0, q)) then do
        return --[[ :: ]]{
                --[[ tuple ]]{
                  q0,
                  --[[ :: ]]{
                    Pervasives.$at(simple_match_args(q0, q), qs),
                    c[1]
                  }
                },
                env$1
              };
      end else do
        return --[[ :: ]]{
                c,
                insert(q, qs, env$1)
              };
      end end 
    end else do
      q0$1 = normalize_pat(q);
      return --[[ :: ]]{
              --[[ tuple ]]{
                q0$1,
                --[[ :: ]]{
                  Pervasives.$at(simple_match_args(q0$1, q), qs),
                  --[[ [] ]]0
                }
              },
              --[[ [] ]]0
            };
    end end 
  end end;
  filter_rec = function (_env, _param) do
    while(true) do
      param = _param;
      env = _env;
      if (param) then do
        match = param[0];
        if (match) then do
          p = match[0];
          match$1 = p.pat_desc;
          if (typeof match$1 == "number") then do
            _param = param[1];
            continue ;
          end else do
            local ___conditional___=(match$1.tag | 0);
            do
               if ___conditional___ = 0--[[ Tpat_var ]] then do
                  _param = param[1];
                  continue ;end end end 
               if ___conditional___ = 1--[[ Tpat_alias ]] then do
                  _param = --[[ :: ]]{
                    --[[ :: ]]{
                      match$1[0],
                      match[1]
                    },
                    param[1]
                  };
                  continue ;end end end 
               if ___conditional___ = 8--[[ Tpat_or ]] then do
                  ps = match[1];
                  _param = --[[ :: ]]{
                    --[[ :: ]]{
                      match$1[0],
                      ps
                    },
                    --[[ :: ]]{
                      --[[ :: ]]{
                        match$1[1],
                        ps
                      },
                      param[1]
                    }
                  };
                  continue ;end end end 
               do
              else do
                _param = param[1];
                _env = insert(p, match[1], env);
                continue ;
                end end
                
            end
          end end 
        end else do
          return env;
        end end 
      end else do
        return env;
      end end 
    end;
  end end;
  match = pat0.pat_desc;
  tmp;
  exit = 0;
  if (typeof match == "number") then do
    tmp = --[[ [] ]]0;
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 3--[[ Tpat_tuple ]]
       or ___conditional___ = 6--[[ Tpat_record ]]
       or ___conditional___ = 9--[[ Tpat_lazy ]] then do
          exit = 1;end else 
       do end end
      else do
        tmp = --[[ [] ]]0;
        end end
        
    end
  end end 
  if (exit == 1) then do
    tmp = --[[ :: ]]{
      --[[ tuple ]]{
        pat0,
        --[[ [] ]]0
      },
      --[[ [] ]]0
    };
  end
   end 
  _env = filter_rec(tmp, pss);
  _param = pss;
  while(true) do
    param = _param;
    env = _env;
    if (param) then do
      match$1 = param[0];
      if (match$1) then do
        match$2 = match$1[0].pat_desc;
        if (typeof match$2 ~= "number") then do
          local ___conditional___=(match$2.tag | 0);
          do
             if ___conditional___ = 0--[[ Tpat_var ]]
             or ___conditional___ = 1--[[ Tpat_alias ]] then do
                _param = --[[ :: ]]{
                  --[[ :: ]]{
                    match$2[0],
                    match$1[1]
                  },
                  param[1]
                };
                continue ;end end end 
             if ___conditional___ = 8--[[ Tpat_or ]] then do
                ps = match$1[1];
                _param = --[[ :: ]]{
                  --[[ :: ]]{
                    match$2[0],
                    ps
                  },
                  --[[ :: ]]{
                    --[[ :: ]]{
                      match$2[1],
                      ps
                    },
                    param[1]
                  }
                };
                continue ;end end end 
             do
            else do
              _param = param[1];
              continue ;
              end end
              
          end
        end
         end 
        ps$1 = match$1[1];
        _param = param[1];
        _env = List.map((function(ps$1)do
            return function (param) do
              q = param[0];
              return --[[ tuple ]]{
                      q,
                      --[[ :: ]]{
                        Pervasives.$at(simple_match_args(q, omega), ps$1),
                        param[1]
                      }
                    };
            end end
            end(ps$1)), env);
        continue ;
      end else do
        _param = param[1];
        continue ;
      end end 
    end else do
      return env;
    end end 
  end;
end end

function set_last(a, param) do
  if (param) then do
    l = param[1];
    if (l) then do
      return --[[ :: ]]{
              param[0],
              set_last(a, l)
            };
    end else do
      return --[[ :: ]]{
              a,
              --[[ [] ]]0
            };
    end end 
  end else do
    return --[[ [] ]]0;
  end end 
end end

function mark_partial(_param) do
  while(true) do
    param = _param;
    if (param) then do
      ps = param[0];
      if (ps) then do
        match = ps[0].pat_desc;
        if (typeof match == "number") then do
          return --[[ :: ]]{
                  ps,
                  mark_partial(param[1])
                };
        end else do
          local ___conditional___=(match.tag | 0);
          do
             if ___conditional___ = 0--[[ Tpat_var ]] then do
                return --[[ :: ]]{
                        ps,
                        mark_partial(param[1])
                      };end end end 
             if ___conditional___ = 1--[[ Tpat_alias ]] then do
                _param = --[[ :: ]]{
                  --[[ :: ]]{
                    match[0],
                    ps[1]
                  },
                  param[1]
                };
                continue ;end end end 
             if ___conditional___ = 8--[[ Tpat_or ]] then do
                ps$1 = ps[1];
                _param = --[[ :: ]]{
                  --[[ :: ]]{
                    match[0],
                    ps$1
                  },
                  --[[ :: ]]{
                    --[[ :: ]]{
                      match[1],
                      ps$1
                    },
                    param[1]
                  }
                };
                continue ;end end end 
             do
            else do
              end end
              
          end
        end end 
      end
       end 
      return --[[ :: ]]{
              set_last(zero, ps),
              mark_partial(param[1])
            };
    end else do
      return --[[ [] ]]0;
    end end 
  end;
end end

function close_variant(env, row) do
  row$1 = row_repr_aux(--[[ [] ]]0, row);
  nm = List.fold_left((function (nm, param) do
          match = row_field_repr_aux(--[[ [] ]]0, param[1]);
          if (typeof match == "number" or not (match.tag and not match[2])) then do
            return nm;
          end else do
            set_row_field(match[3], --[[ Rabsent ]]0);
            return ;
          end end 
        end end), row$1.row_name, row$1.row_fields);
  if (not row$1.row_closed or nm ~= row$1.row_name) then do
    return unify$2(env, row$1.row_more, newty2(100000000, --[[ Tvariant ]]Block.__(8, {do
                        row_fields: --[[ [] ]]0,
                        row_more: newty2(100000000, --[[ Tvar ]]Block.__(0, {undefined})),
                        row_bound: row$1.row_bound,
                        row_closed: true,
                        row_fixed: row$1.row_fixed,
                        row_name: nm
                      end})));
  end else do
    return 0;
  end end 
end end

function row_of_pat(pat) do
  match = expand_head(pat.pat_env, pat.pat_type);
  match$1 = match.desc;
  if (typeof match$1 == "number") then do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "parmatch.ml",
            602,
            9
          }
        };
  end else if (match$1.tag == --[[ Tvariant ]]8) then do
    return row_repr_aux(--[[ [] ]]0, match$1[0]);
  end else do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "parmatch.ml",
            602,
            9
          }
        };
  end end  end 
end end

function generalized_constructor(x) do
  match = x[0].pat_desc;
  if (typeof match == "number") then do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "parmatch.ml",
            613,
            9
          }
        };
  end else if (match.tag == --[[ Tpat_construct ]]4) then do
    return match[1].cstr_generalized;
  end else do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "parmatch.ml",
            613,
            9
          }
        };
  end end  end 
end end

function clean_env(env) do
  loop = function (_param) do
    while(true) do
      param = _param;
      if (param) then do
        xs = param[1];
        x = param[0];
        if (generalized_constructor(x)) then do
          _param = xs;
          continue ;
        end else do
          return --[[ :: ]]{
                  x,
                  loop(xs)
                };
        end end 
      end else do
        return --[[ [] ]]0;
      end end 
    end;
  end end;
  return loop(env);
end end

function full_match(ignore_generalized, closing, env) do
  if (env) then do
    p = env[0][0];
    match = p.pat_desc;
    if (typeof match == "number") then do
      return fatal_error("Parmatch.full_match");
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 2--[[ Tpat_constant ]] then do
            if (match[0].tag == --[[ Const_char ]]1) then do
              return List.length(env) == 256;
            end else do
              return false;
            end end end end end 
         if ___conditional___ = 4--[[ Tpat_construct ]] then do
            c = match[1];
            if (c.cstr_consts < 0) then do
              return false;
            end else if (ignore_generalized) then do
              env$1 = clean_env(env);
              return List.length(env$1) == c.cstr_normal;
            end else do
              return List.length(env) == (c.cstr_consts + c.cstr_nonconsts | 0);
            end end  end end end end 
         if ___conditional___ = 5--[[ Tpat_variant ]] then do
            fields = List.map((function (param) do
                    match = param[0].pat_desc;
                    if (typeof match == "number") then do
                      throw {
                            Caml_builtin_exceptions.assert_failure,
                            --[[ tuple ]]{
                              "parmatch.ml",
                              640,
                              17
                            }
                          };
                    end else if (match.tag == --[[ Tpat_variant ]]5) then do
                      return match[0];
                    end else do
                      throw {
                            Caml_builtin_exceptions.assert_failure,
                            --[[ tuple ]]{
                              "parmatch.ml",
                              640,
                              17
                            }
                          };
                    end end  end 
                  end end), env);
            row = row_of_pat(p);
            if (closing and not row_fixed(row)) then do
              return List.for_all((function (param) do
                            tag = param[0];
                            match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                            if (typeof match == "number" or match.tag and not match[2]) then do
                              return true;
                            end else do
                              return List.mem(tag, fields);
                            end end 
                          end end), row.row_fields);
            end else if (row.row_closed) then do
              return List.for_all((function (param) do
                            if (row_field_repr_aux(--[[ [] ]]0, param[1]) == --[[ Rabsent ]]0) then do
                              return true;
                            end else do
                              return List.mem(param[0], fields);
                            end end 
                          end end), row.row_fields);
            end else do
              return false;
            end end  end end end end 
         if ___conditional___ = 7--[[ Tpat_array ]] then do
            return false;end end end 
         if ___conditional___ = 3--[[ Tpat_tuple ]]
         or ___conditional___ = 6--[[ Tpat_record ]]
         or ___conditional___ = 9--[[ Tpat_lazy ]] then do
            return true;end end end 
         do
        else do
          return fatal_error("Parmatch.full_match");
          end end
          
      end
    end end 
  end else do
    return fatal_error("Parmatch.full_match");
  end end 
end end

function full_match_gadt(env) do
  if (env) then do
    match = env[0][0].pat_desc;
    if (typeof match == "number" or match.tag ~= --[[ Tpat_construct ]]4) then do
      return true;
    end else do
      c = match[1];
      return List.length(env) == (c.cstr_consts + c.cstr_nonconsts | 0);
    end end 
  end else do
    return true;
  end end 
end end

function should_extend(ext, env) do
  if (ext ~= undefined and env) then do
    p = env[0][0];
    match = p.pat_desc;
    if (typeof match == "number" or match.tag ~= --[[ Tpat_construct ]]4) then do
      return false;
    end else do
      local ___conditional___=(match[1].cstr_tag.tag | 0);
      do
         if ___conditional___ = 0--[[ Cstr_constant ]]
         or ___conditional___ = 1--[[ Cstr_block ]]
         or ___conditional___ = 2--[[ Cstr_extension ]] then do
            return false;end end end 
         do
        
      end
      path = get_type_path(p.pat_type, p.pat_env);
      return same(path, ext);
    end end 
  end else do
    return false;
  end end 
end end

function complete_tags(nconsts, nconstrs, tags) do
  seen_const = Caml_array.caml_make_vect(nconsts, false);
  seen_constr = Caml_array.caml_make_vect(nconstrs, false);
  List.iter((function (param) do
          local ___conditional___=(param.tag | 0);
          do
             if ___conditional___ = 0--[[ Cstr_constant ]] then do
                return Caml_array.caml_array_set(seen_const, param[0], true);end end end 
             if ___conditional___ = 1--[[ Cstr_block ]] then do
                return Caml_array.caml_array_set(seen_constr, param[0], true);end end end 
             if ___conditional___ = 2--[[ Cstr_extension ]] then do
                throw {
                      Caml_builtin_exceptions.assert_failure,
                      --[[ tuple ]]{
                        "parmatch.ml",
                        703,
                        14
                      }
                    };end end end 
             do
            
          end
        end end), tags);
  r = --[[ [] ]]0;
  for i = 0 , nconsts - 1 | 0 , 1 do
    if (not Caml_array.caml_array_get(seen_const, i)) then do
      r = --[[ :: ]]{
        --[[ Cstr_constant ]]Block.__(0, {i}),
        r
      };
    end
     end 
  end
  for i$1 = 0 , nconstrs - 1 | 0 , 1 do
    if (not Caml_array.caml_array_get(seen_constr, i$1)) then do
      r = --[[ :: ]]{
        --[[ Cstr_block ]]Block.__(1, {i$1}),
        r
      };
    end
     end 
  end
  return r;
end end

function pat_of_constr(ex_pat, cstr) do
  return do
          pat_desc: --[[ Tpat_construct ]]Block.__(4, {
              do
                txt: --[[ Lident ]]Block.__(0, {"?pat_of_constr?"}),
                loc: none
              end,
              cstr,
              omegas(cstr.cstr_arity)
            }),
          pat_loc: ex_pat.pat_loc,
          pat_extra: ex_pat.pat_extra,
          pat_type: ex_pat.pat_type,
          pat_env: ex_pat.pat_env,
          pat_attributes: ex_pat.pat_attributes
        end;
end end

function pat_of_constrs(ex_pat, param) do
  if (param) then do
    rem = param[1];
    cstr = param[0];
    if (rem) then do
      return do
              pat_desc: --[[ Tpat_or ]]Block.__(8, {
                  pat_of_constr(ex_pat, cstr),
                  pat_of_constrs(ex_pat, rem),
                  undefined
                }),
              pat_loc: ex_pat.pat_loc,
              pat_extra: ex_pat.pat_extra,
              pat_type: ex_pat.pat_type,
              pat_env: ex_pat.pat_env,
              pat_attributes: ex_pat.pat_attributes
            end;
    end else do
      return pat_of_constr(ex_pat, cstr);
    end end 
  end else do
    throw Empty;
  end end 
end end

function get_variant_constructors(env, _ty) do
  while(true) do
    ty = _ty;
    match = repr(ty).desc;
    if (typeof match == "number" or match.tag ~= --[[ Tconstr ]]3) then do
      return fatal_error("Parmatch.get_variant_constructors");
    end else do
      path = match[0];
      match$1 = find_type_full(path, env)[0];
      tmp = match$1.type_kind;
      if (typeof tmp ~= "number" and tmp.tag == --[[ Type_variant ]]1) then do
        return find_type_full(path, env)[1][0];
      end
       end 
      if (match$1.type_manifest ~= undefined) then do
        _ty = expand_head_once(env, clean_copy(ty));
        continue ;
      end else do
        return fatal_error("Parmatch.get_variant_constructors");
      end end 
    end end 
  end;
end end

function map_filter(f, _param) do
  while(true) do
    param = _param;
    if (param) then do
      xs = param[1];
      match = Curry._1(f, param[0]);
      if (match ~= undefined) then do
        return --[[ :: ]]{
                Caml_option.valFromOption(match),
                map_filter(f, xs)
              };
      end else do
        _param = xs;
        continue ;
      end end 
    end else do
      return --[[ [] ]]0;
    end end 
  end;
end end

function complete_constrs(p, all_tags) do
  match = p.pat_desc;
  if (typeof match == "number" or match.tag ~= --[[ Tpat_construct ]]4) then do
    return fatal_error("Parmatch.complete_constr");
  end else do
    c = match[1];
    not_tags = complete_tags(c.cstr_consts, c.cstr_nonconsts, all_tags);
    constrs = get_variant_constructors(p.pat_env, c.cstr_res);
    return map_filter((function (cnstr) do
                  if (List.exists((function (tag) do
                            return equal_tag(tag, cnstr.cstr_tag);
                          end end), not_tags)) then do
                    return cnstr;
                  end
                   end 
                end end), constrs);
  end end 
end end

function build_other_constant(proj, make, first, next, p, env) do
  all = List.map((function (param) do
          return Curry._1(proj, param[0].pat_desc);
        end end), env);
  _i = first;
  while(true) do
    i = _i;
    if (List.mem(i, all)) then do
      _i = Curry._1(next, i);
      continue ;
    end else do
      return make_pat(Curry._1(make, i), p.pat_type, p.pat_env);
    end end 
  end;
end end

function build_other(ext, env) do
  if (env) then do
    p = env[0][0];
    match = p.pat_desc;
    if (typeof match == "number") then do
      return omega;
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 2--[[ Tpat_constant ]] then do
            local ___conditional___=(match[0].tag | 0);
            do
               if ___conditional___ = 0--[[ Const_int ]] then do
                  return build_other_constant((function (param) do
                                if (typeof param ~= "number" and param.tag == --[[ Tpat_constant ]]2) then do
                                  match = param[0];
                                  if (not match.tag) then do
                                    return match[0];
                                  end
                                   end 
                                end
                                 end 
                                throw {
                                      Caml_builtin_exceptions.assert_failure,
                                      --[[ tuple ]]{
                                        "parmatch.ml",
                                        857,
                                        55
                                      }
                                    };
                              end end), (function (i) do
                                return --[[ Tpat_constant ]]Block.__(2, {--[[ Const_int ]]Block.__(0, {i})});
                              end end), 0, (function (prim) do
                                return prim + 1 | 0;
                              end end), p, env);end end end 
               if ___conditional___ = 1--[[ Const_char ]] then do
                  all_chars = List.map((function (param) do
                          match = param[0].pat_desc;
                          if (typeof match ~= "number" and match.tag == --[[ Tpat_constant ]]2) then do
                            match$1 = match[0];
                            if (match$1.tag == --[[ Const_char ]]1) then do
                              return match$1[0];
                            end
                             end 
                          end
                           end 
                          throw {
                                Caml_builtin_exceptions.assert_failure,
                                --[[ tuple ]]{
                                  "parmatch.ml",
                                  832,
                                  15
                                }
                              };
                        end end), env);
                  _param = --[[ :: ]]{
                    --[[ tuple ]]{
                      --[[ "a" ]]97,
                      --[[ "z" ]]122
                    },
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        --[[ "A" ]]65,
                        --[[ "Z" ]]90
                      },
                      --[[ :: ]]{
                        --[[ tuple ]]{
                          --[[ "0" ]]48,
                          --[[ "9" ]]57
                        },
                        --[[ :: ]]{
                          --[[ tuple ]]{
                            --[[ " " ]]32,
                            --[[ "~" ]]126
                          },
                          --[[ :: ]]{
                            --[[ tuple ]]{
                              Char.chr(0),
                              Char.chr(255)
                            },
                            --[[ [] ]]0
                          }
                        }
                      }
                    }
                  };
                  while(true) do
                    param = _param;
                    if (param) then do
                      match$1 = param[0];
                      try do
                        _i = match$1[0];
                        imax = match$1[1];
                        while(true) do
                          i = _i;
                          if (i > imax) then do
                            throw Caml_builtin_exceptions.not_found;
                          end
                           end 
                          ci = Char.chr(i);
                          if (List.mem(ci, all_chars)) then do
                            _i = i + 1 | 0;
                            continue ;
                          end else do
                            return make_pat(--[[ Tpat_constant ]]Block.__(2, {--[[ Const_char ]]Block.__(1, {ci})}), p.pat_type, p.pat_env);
                          end end 
                        end;
                      end
                      catch (exn)do
                        if (exn == Caml_builtin_exceptions.not_found) then do
                          _param = param[1];
                          continue ;
                        end else do
                          throw exn;
                        end end 
                      end
                    end else do
                      return omega;
                    end end 
                  end;end end end 
               if ___conditional___ = 2--[[ Const_string ]] then do
                  return build_other_constant((function (param) do
                                if (typeof param ~= "number" and param.tag == --[[ Tpat_constant ]]2) then do
                                  match = param[0];
                                  if (match.tag == --[[ Const_string ]]2) then do
                                    return #match[0];
                                  end
                                   end 
                                end
                                 end 
                                throw {
                                      Caml_builtin_exceptions.assert_failure,
                                      --[[ tuple ]]{
                                        "parmatch.ml",
                                        878,
                                        21
                                      }
                                    };
                              end end), (function (i) do
                                return --[[ Tpat_constant ]]Block.__(2, {--[[ Const_string ]]Block.__(2, {
                                              Caml_bytes.bytes_to_string(Bytes.make(i, --[[ "*" ]]42)),
                                              undefined
                                            })});
                              end end), 0, (function (prim) do
                                return prim + 1 | 0;
                              end end), p, env);end end end 
               if ___conditional___ = 3--[[ Const_float ]] then do
                  return build_other_constant((function (param) do
                                if (typeof param ~= "number" and param.tag == --[[ Tpat_constant ]]2) then do
                                  match = param[0];
                                  if (match.tag == --[[ Const_float ]]3) then do
                                    return Caml_format.caml_float_of_string(match[0]);
                                  end
                                   end 
                                end
                                 end 
                                throw {
                                      Caml_builtin_exceptions.assert_failure,
                                      --[[ tuple ]]{
                                        "parmatch.ml",
                                        884,
                                        21
                                      }
                                    };
                              end end), (function (f) do
                                return --[[ Tpat_constant ]]Block.__(2, {--[[ Const_float ]]Block.__(3, {Pervasives.string_of_float(f)})});
                              end end), 0.0, (function (f) do
                                return f + 1.0;
                              end end), p, env);end end end 
               if ___conditional___ = 4--[[ Const_int32 ]] then do
                  return build_other_constant((function (param) do
                                if (typeof param ~= "number" and param.tag == --[[ Tpat_constant ]]2) then do
                                  match = param[0];
                                  if (match.tag == --[[ Const_int32 ]]4) then do
                                    return match[0];
                                  end
                                   end 
                                end
                                 end 
                                throw {
                                      Caml_builtin_exceptions.assert_failure,
                                      --[[ tuple ]]{
                                        "parmatch.ml",
                                        862,
                                        57
                                      }
                                    };
                              end end), (function (i) do
                                return --[[ Tpat_constant ]]Block.__(2, {--[[ Const_int32 ]]Block.__(4, {i})});
                              end end), 0, Int32.succ, p, env);end end end 
               if ___conditional___ = 5--[[ Const_int64 ]] then do
                  return build_other_constant((function (param) do
                                if (typeof param ~= "number" and param.tag == --[[ Tpat_constant ]]2) then do
                                  match = param[0];
                                  if (match.tag == --[[ Const_int64 ]]5) then do
                                    return match[0];
                                  end
                                   end 
                                end
                                 end 
                                throw {
                                      Caml_builtin_exceptions.assert_failure,
                                      --[[ tuple ]]{
                                        "parmatch.ml",
                                        867,
                                        57
                                      }
                                    };
                              end end), (function (i) do
                                return --[[ Tpat_constant ]]Block.__(2, {--[[ Const_int64 ]]Block.__(5, {i})});
                              end end), --[[ int64 ]]{
                              --[[ hi ]]0,
                              --[[ lo ]]0
                            }, Int64.succ, p, env);end end end 
               if ___conditional___ = 6--[[ Const_nativeint ]] then do
                  return build_other_constant((function (param) do
                                if (typeof param ~= "number" and param.tag == --[[ Tpat_constant ]]2) then do
                                  match = param[0];
                                  if (match.tag == --[[ Const_nativeint ]]6) then do
                                    return match[0];
                                  end
                                   end 
                                end
                                 end 
                                throw {
                                      Caml_builtin_exceptions.assert_failure,
                                      --[[ tuple ]]{
                                        "parmatch.ml",
                                        872,
                                        61
                                      }
                                    };
                              end end), (function (i) do
                                return --[[ Tpat_constant ]]Block.__(2, {--[[ Const_nativeint ]]Block.__(6, {i})});
                              end end), 0, Nativeint.succ, p, env);end end end 
               do
              
            endend end end 
         if ___conditional___ = 4--[[ Tpat_construct ]] then do
            c = match[1];
            exit = 0;
            local ___conditional___=(c.cstr_tag.tag | 0);
            do
               if ___conditional___ = 0--[[ Cstr_constant ]]
               or ___conditional___ = 1--[[ Cstr_block ]] then do
                  exit = 1;end else 
               if ___conditional___ = 2--[[ Cstr_extension ]] then do
                  c_cstr_res = c.cstr_res;
                  c_cstr_existentials = c.cstr_existentials;
                  c_cstr_args = c.cstr_args;
                  c_cstr_arity = c.cstr_arity;
                  c_cstr_tag = c.cstr_tag;
                  c_cstr_consts = c.cstr_consts;
                  c_cstr_nonconsts = c.cstr_nonconsts;
                  c_cstr_normal = c.cstr_normal;
                  c_cstr_generalized = c.cstr_generalized;
                  c_cstr_private = c.cstr_private;
                  c_cstr_loc = c.cstr_loc;
                  c_cstr_attributes = c.cstr_attributes;
                  c$1 = do
                    cstr_name: "*extension*",
                    cstr_res: c_cstr_res,
                    cstr_existentials: c_cstr_existentials,
                    cstr_args: c_cstr_args,
                    cstr_arity: c_cstr_arity,
                    cstr_tag: c_cstr_tag,
                    cstr_consts: c_cstr_consts,
                    cstr_nonconsts: c_cstr_nonconsts,
                    cstr_normal: c_cstr_normal,
                    cstr_generalized: c_cstr_generalized,
                    cstr_private: c_cstr_private,
                    cstr_loc: c_cstr_loc,
                    cstr_attributes: c_cstr_attributes
                  end;
                  return make_pat(--[[ Tpat_construct ]]Block.__(4, {
                                match[0],
                                c$1,
                                --[[ [] ]]0
                              }), none$2, empty);end end end 
               do end
              
            end
            if (exit == 1) then do
              if (ext ~= undefined and same(ext, get_type_path(p.pat_type, p.pat_env))) then do
                return extra_pat;
              end
               end 
              all_tags = List.map((function (param) do
                      param$1 = param[0];
                      match = param$1.pat_desc;
                      if (typeof match == "number" or match.tag ~= --[[ Tpat_construct ]]4) then do
                        return fatal_error("Parmatch.get_tag");
                      end else do
                        return match[1].cstr_tag;
                      end end 
                    end end), env);
              return pat_of_constrs(p, complete_constrs(p, all_tags));
            end
             end end else 
         if ___conditional___ = 5--[[ Tpat_variant ]] then do
            r = match[2];
            tags = List.map((function (param) do
                    match = param[0].pat_desc;
                    if (typeof match == "number") then do
                      throw {
                            Caml_builtin_exceptions.assert_failure,
                            --[[ tuple ]]{
                              "parmatch.ml",
                              801,
                              23
                            }
                          };
                    end else if (match.tag == --[[ Tpat_variant ]]5) then do
                      return match[0];
                    end else do
                      throw {
                            Caml_builtin_exceptions.assert_failure,
                            --[[ tuple ]]{
                              "parmatch.ml",
                              801,
                              23
                            }
                          };
                    end end  end 
                  end end), env);
            row = row_of_pat(p);
            make_other_pat = function (tag, __const) do
              arg = __const and undefined or omega;
              return make_pat(--[[ Tpat_variant ]]Block.__(5, {
                            tag,
                            arg,
                            r
                          }), p.pat_type, p.pat_env);
            end end;
            match$2 = List.fold_left((function (others, param) do
                    tag = param[0];
                    if (List.mem(tag, tags)) then do
                      return others;
                    end else do
                      match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                      if (typeof match == "number") then do
                        return others;
                      end else if (match.tag) then do
                        return --[[ :: ]]{
                                make_other_pat(tag, match[0]),
                                others
                              };
                      end else do
                        return --[[ :: ]]{
                                make_other_pat(tag, match[0] == undefined),
                                others
                              };
                      end end  end 
                    end end 
                  end end), --[[ [] ]]0, row.row_fields);
            if (match$2) then do
              return List.fold_left((function (p_res, pat) do
                            return make_pat(--[[ Tpat_or ]]Block.__(8, {
                                          pat,
                                          p_res,
                                          undefined
                                        }), p.pat_type, p.pat_env);
                          end end), match$2[0], match$2[1]);
            end else do
              return make_other_pat("AnyExtraTag", true);
            end end end end end 
         if ___conditional___ = 7--[[ Tpat_array ]] then do
            all_lengths = List.map((function (param) do
                    match = param[0].pat_desc;
                    if (typeof match == "number") then do
                      throw {
                            Caml_builtin_exceptions.assert_failure,
                            --[[ tuple ]]{
                              "parmatch.ml",
                              893,
                              15
                            }
                          };
                    end else if (match.tag == --[[ Tpat_array ]]7) then do
                      return List.length(match[0]);
                    end else do
                      throw {
                            Caml_builtin_exceptions.assert_failure,
                            --[[ tuple ]]{
                              "parmatch.ml",
                              893,
                              15
                            }
                          };
                    end end  end 
                  end end), env);
            _l = 0;
            while(true) do
              l = _l;
              if (List.mem(l, all_lengths)) then do
                _l = l + 1 | 0;
                continue ;
              end else do
                return make_pat(--[[ Tpat_array ]]Block.__(7, {omegas(l)}), p.pat_type, p.pat_env);
              end end 
            end;end end end 
         do
        else do
          return omega;
          end end
          
      end
    end end 
  end else do
    return omega;
  end end 
end end

function build_other_gadt(ext, env) do
  if (env) then do
    p = env[0][0];
    tmp = p.pat_desc;
    if (typeof tmp ~= "number" and tmp.tag == --[[ Tpat_construct ]]4) then do
      all_tags = List.map((function (param) do
              param$1 = param[0];
              match = param$1.pat_desc;
              if (typeof match == "number" or match.tag ~= --[[ Tpat_construct ]]4) then do
                return fatal_error("Parmatch.get_tag");
              end else do
                return match[1].cstr_tag;
              end end 
            end end), env);
      cnstrs = complete_constrs(p, all_tags);
      return List.map((function (param) do
                    return pat_of_constr(p, param);
                  end end), cnstrs);
    end
     end 
  end
   end 
  throw {
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "parmatch.ml",
          917,
          11
        }
      };
end end

function has_instance(_p) do
  while(true) do
    p = _p;
    match = p.pat_desc;
    if (typeof match == "number") then do
      return true;
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 4--[[ Tpat_construct ]] then do
            return has_instances(match[2]);end end end 
         if ___conditional___ = 5--[[ Tpat_variant ]] then do
            match$1 = match[1];
            if (is_absent(match[0], match[2])) then do
              return false;
            end else if (match$1 ~= undefined) then do
              _p = match$1;
              continue ;
            end else do
              return true;
            end end  end end end end 
         if ___conditional___ = 6--[[ Tpat_record ]] then do
            return has_instances(List.map((function (param) do
                              return param[2];
                            end end), match[0]));end end end 
         if ___conditional___ = 3--[[ Tpat_tuple ]]
         or ___conditional___ = 7--[[ Tpat_array ]] then do
            return has_instances(match[0]);end end end 
         if ___conditional___ = 8--[[ Tpat_or ]] then do
            if (has_instance(match[0])) then do
              return true;
            end else do
              _p = match[1];
              continue ;
            end end end end end 
         if ___conditional___ = 1--[[ Tpat_alias ]]
         or ___conditional___ = 9--[[ Tpat_lazy ]] then do
            _p = match[0];
            continue ;end end end 
         do
        else do
          return true;
          end end
          
      end
    end end 
  end;
end end

function has_instances(_param) do
  while(true) do
    param = _param;
    if (param) then do
      if (has_instance(param[0])) then do
        _param = param[1];
        continue ;
      end else do
        return false;
      end end 
    end else do
      return true;
    end end 
  end;
end end

function satisfiable(_pss, _qs) do
  while(true) do
    qs = _qs;
    pss = _pss;
    if (pss) then do
      if (qs) then do
        q = qs[0];
        match = q.pat_desc;
        exit = 0;
        if (typeof match == "number") then do
          exit = 1;
        end else do
          local ___conditional___=(match.tag | 0);
          do
             if ___conditional___ = 0--[[ Tpat_var ]] then do
                exit = 1;end else 
             if ___conditional___ = 1--[[ Tpat_alias ]] then do
                _qs = --[[ :: ]]{
                  match[0],
                  qs[1]
                };
                continue ;end end end 
             if ___conditional___ = 5--[[ Tpat_variant ]] then do
                if (is_absent(match[0], match[2])) then do
                  return false;
                end else do
                  exit = 2;
                end end end else 
             if ___conditional___ = 8--[[ Tpat_or ]] then do
                qs$1 = qs[1];
                if (satisfiable(pss, --[[ :: ]]{
                        match[0],
                        qs$1
                      })) then do
                  return true;
                end else do
                  _qs = --[[ :: ]]{
                    match[1],
                    qs$1
                  };
                  continue ;
                end end end end end 
             do end
            else do
              exit = 2;
              end end
              
          end
        end end 
        local ___conditional___=(exit);
        do
           if ___conditional___ = 1 then do
              qs$2 = qs[1];
              q0 = discr_pat(omega, pss);
              constrs = filter_all(q0, pss);
              if (constrs) then do
                if (full_match(false, false, constrs)) then do
                  return List.exists((function(qs$2)do
                            return function (param) do
                              p = param[0];
                              if (is_absent_pat(p)) then do
                                return false;
                              end else do
                                return satisfiable(param[1], Pervasives.$at(simple_match_args(p, omega), qs$2));
                              end end 
                            end end
                            end(qs$2)), constrs);
                end else do
                  _qs = qs$2;
                  _pss = filter_extra(pss);
                  continue ;
                end end 
              end else do
                _qs = qs$2;
                _pss = filter_extra(pss);
                continue ;
              end end end end end 
           if ___conditional___ = 2 then do
              q0$1 = discr_pat(q, pss);
              _qs = Pervasives.$at(simple_match_args(q0$1, q), qs[1]);
              _pss = filter_one(q0$1, pss);
              continue ;end end end 
           do
          
        end
      end else do
        return false;
      end end 
    end else do
      return has_instances(qs);
    end end 
  end;
end end

function orify_many(param) do
  if (param) then do
    xs = param[1];
    x = param[0];
    if (xs) then do
      x$1 = x;
      y = Curry._1(orify_many, xs);
      return make_pat(--[[ Tpat_or ]]Block.__(8, {
                    x$1,
                    y,
                    undefined
                  }), x$1.pat_type, x$1.pat_env);
    end else do
      return x;
    end end 
  end else do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "parmatch.ml",
            989,
            12
          }
        };
  end end 
end end

function try_many_gadt(f, param) do
  if (param) then do
    match = param[0];
    r1 = Curry._1(f, --[[ tuple ]]{
          match[0],
          match[1]
        });
    r2 = try_many_gadt(f, param[1]);
    if (r1) then do
      if (r2) then do
        return --[[ Rsome ]]{Pervasives.$at(r1[0], r2[0])};
      end else do
        return r1;
      end end 
    end else do
      return r2;
    end end 
  end else do
    return --[[ Rnone ]]0;
  end end 
end end

function exhaust(ext, pss, n) do
  if (pss) then do
    if (pss[0]) then do
      q0 = discr_pat(omega, pss);
      constrs = filter_all(q0, pss);
      if (constrs) then do
        try_non_omega = function (param) do
          p = param[0];
          if (is_absent_pat(p)) then do
            return --[[ Rnone ]]0;
          end else do
            r = exhaust(ext, param[1], (List.length(simple_match_args(p, omega)) + n | 0) - 1 | 0);
            if (r) then do
              return --[[ Rsome ]]{do_set_args(false, p, r[0])};
            end else do
              return r;
            end end 
          end end 
        end end;
        if (full_match(true, false, constrs) and not should_extend(ext, constrs)) then do
          f = try_non_omega;
          _param = constrs;
          while(true) do
            param = _param;
            if (param) then do
              match = param[0];
              r = Curry._1(f, --[[ tuple ]]{
                    match[0],
                    match[1]
                  });
              if (r) then do
                return r;
              end else do
                _param = param[1];
                continue ;
              end end 
            end else do
              return --[[ Rnone ]]0;
            end end 
          end;
        end else do
          r$1 = exhaust(ext, filter_extra(pss), n - 1 | 0);
          if (r$1) then do
            try do
              return --[[ Rsome ]]{--[[ :: ]]{
                        build_other(ext, constrs),
                        r$1[0]
                      }};
            end
            catch (exn)do
              if (exn == Empty) then do
                return fatal_error("Parmatch.exhaust");
              end else do
                throw exn;
              end end 
            end
          end else do
            return --[[ Rnone ]]0;
          end end 
        end end 
      end else do
        r$2 = exhaust(ext, filter_extra(pss), n - 1 | 0);
        if (r$2) then do
          return --[[ Rsome ]]{--[[ :: ]]{
                    q0,
                    r$2[0]
                  }};
        end else do
          return r$2;
        end end 
      end end 
    end else do
      return --[[ Rnone ]]0;
    end end 
  end else do
    return --[[ Rsome ]]{omegas(n)};
  end end 
end end

function combinations(f, lst, lst$prime) do
  iter2 = function (x, param) do
    if (param) then do
      return --[[ :: ]]{
              Curry._2(f, x, param[0]),
              iter2(x, param[1])
            };
    end else do
      return --[[ [] ]]0;
    end end 
  end end;
  iter = function (param) do
    if (param) then do
      return Pervasives.$at(iter2(param[0], lst$prime), iter(param[1]));
    end else do
      return --[[ [] ]]0;
    end end 
  end end;
  return iter(lst);
end end

function exhaust_gadt(ext, pss, n) do
  if (pss) then do
    if (pss[0]) then do
      q0 = discr_pat(omega, pss);
      constrs = filter_all(q0, pss);
      if (constrs) then do
        try_non_omega = function (param) do
          p = param[0];
          if (is_absent_pat(p)) then do
            return --[[ Rnone ]]0;
          end else do
            r = exhaust_gadt(ext, param[1], (List.length(simple_match_args(p, omega)) + n | 0) - 1 | 0);
            if (r) then do
              return --[[ Rsome ]]{List.map((function (row) do
                              return do_set_args(false, p, row);
                            end end), r[0])};
            end else do
              return r;
            end end 
          end end 
        end end;
        before = try_many_gadt(try_non_omega, constrs);
        if (full_match_gadt(constrs) and not should_extend(ext, constrs)) then do
          return before;
        end else do
          r = exhaust_gadt(ext, filter_extra(pss), n - 1 | 0);
          if (r) then do
            try do
              missing_trailing = build_other_gadt(ext, constrs);
              dug = combinations((function (head, tail) do
                      return --[[ :: ]]{
                              head,
                              tail
                            };
                    end end), missing_trailing, r[0]);
              if (before) then do
                return --[[ Rsome ]]{Pervasives.$at(before[0], dug)};
              end else do
                return --[[ Rsome ]]{dug};
              end end 
            end
            catch (exn)do
              if (exn == Empty) then do
                return fatal_error("Parmatch.exhaust");
              end else do
                throw exn;
              end end 
            end
          end else do
            return before;
          end end 
        end end 
      end else do
        r$1 = exhaust_gadt(ext, filter_extra(pss), n - 1 | 0);
        if (r$1) then do
          return --[[ Rsome ]]{List.map((function (row) do
                          return --[[ :: ]]{
                                  q0,
                                  row
                                };
                        end end), r$1[0])};
        end else do
          return r$1;
        end end 
      end end 
    end else do
      return --[[ Rnone ]]0;
    end end 
  end else do
    return --[[ Rsome ]]{--[[ :: ]]{
              omegas(n),
              --[[ [] ]]0
            }};
  end end 
end end

function exhaust_gadt$1(ext, pss, n) do
  ret = exhaust_gadt(ext, pss, n);
  if (ret) then do
    lst = ret[0];
    if (lst == --[[ [] ]]0) then do
      return --[[ Rsome ]]{omegas(n)};
    end else do
      singletons = List.map((function (param) do
              if (param) then do
                if (param[1]) then do
                  throw {
                        Caml_builtin_exceptions.assert_failure,
                        --[[ tuple ]]{
                          "parmatch.ml",
                          1165,
                          19
                        }
                      };
                end
                 end 
                return param[0];
              end else do
                throw {
                      Caml_builtin_exceptions.assert_failure,
                      --[[ tuple ]]{
                        "parmatch.ml",
                        1165,
                        19
                      }
                    };
              end end 
            end end), lst);
      return --[[ Rsome ]]{--[[ :: ]]{
                Curry._1(orify_many, singletons),
                --[[ [] ]]0
              }};
    end end 
  end else do
    return --[[ Rnone ]]0;
  end end 
end end

function pressure_variants(_tdefs, _pss) do
  while(true) do
    pss = _pss;
    tdefs = _tdefs;
    if (pss) then do
      if (pss[0]) then do
        q0 = discr_pat(omega, pss);
        constrs = filter_all(q0, pss);
        if (constrs) then do
          try_non_omega = (function(tdefs)do
          return function try_non_omega(param) do
            if (param) then do
              ok = pressure_variants(tdefs, param[0][1]);
              if (try_non_omega(param[1])) then do
                return ok;
              end else do
                return false;
              end end 
            end else do
              return true;
            end end 
          end end
          end(tdefs));
          if (full_match(true, tdefs == undefined, constrs)) then do
            return try_non_omega(constrs);
          end else if (tdefs == undefined) then do
            _pss = filter_extra(pss);
            _tdefs = undefined;
            continue ;
          end else do
            full = full_match(true, true, constrs);
            ok = full and try_non_omega(constrs) or try_non_omega(filter_all(q0, mark_partial(pss)));
            if (constrs) then do
              p = constrs[0][0];
              tmp = p.pat_desc;
              if (typeof tmp ~= "number" and tmp.tag == --[[ Tpat_variant ]]5 and tdefs ~= undefined) then do
                row = row_of_pat(p);
                if (not (row_fixed(row) or pressure_variants(undefined, filter_extra(pss)))) then do
                  close_variant(Caml_option.valFromOption(tdefs), row);
                end
                 end 
              end
               end 
            end
             end 
            return ok;
          end end  end 
        end else do
          _pss = filter_extra(pss);
          continue ;
        end end 
      end else do
        return true;
      end end 
    end else do
      return false;
    end end 
  end;
end end

function make_row(ps) do
  return do
          no_ors: --[[ [] ]]0,
          ors: --[[ [] ]]0,
          active: ps
        end;
end end

function unalias$1(_p) do
  while(true) do
    p = _p;
    match = p.pat_desc;
    if (typeof match == "number" or match.tag ~= --[[ Tpat_alias ]]1) then do
      return p;
    end else do
      _p = match[0];
      continue ;
    end end 
  end;
end end

function is_var_column(rs) do
  return List.for_all((function (r) do
                match = r.active;
                if (match) then do
                  p = match[0];
                  match$1 = unalias$1(p).pat_desc;
                  if (typeof match$1 == "number" or not match$1.tag) then do
                    return true;
                  end else do
                    return false;
                  end end 
                end else do
                  throw {
                        Caml_builtin_exceptions.assert_failure,
                        --[[ tuple ]]{
                          "parmatch.ml",
                          1274,
                          14
                        }
                      };
                end end 
              end end), rs);
end end

function or_args(_p) do
  while(true) do
    p = _p;
    match = p.pat_desc;
    if (typeof match == "number") then do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "parmatch.ml",
              1281,
              23
            }
          };
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 1--[[ Tpat_alias ]] then do
            _p = match[0];
            continue ;end end end 
         if ___conditional___ = 8--[[ Tpat_or ]] then do
            return --[[ tuple ]]{
                    match[0],
                    match[1]
                  };end end end 
         do
        else do
          throw {
                Caml_builtin_exceptions.assert_failure,
                --[[ tuple ]]{
                  "parmatch.ml",
                  1281,
                  23
                }
              };
          end end
          
      end
    end end 
  end;
end end

function remove(r) do
  match = r.active;
  if (match) then do
    return do
            no_ors: r.no_ors,
            ors: r.ors,
            active: match[1]
          end;
  end else do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "parmatch.ml",
            1286,
            12
          }
        };
  end end 
end end

function push_no_or(r) do
  match = r.active;
  if (match) then do
    return do
            no_ors: --[[ :: ]]{
              match[0],
              r.no_ors
            },
            ors: r.ors,
            active: match[1]
          end;
  end else do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "parmatch.ml",
            1293,
            8
          }
        };
  end end 
end end

function push_or(r) do
  match = r.active;
  if (match) then do
    return do
            no_ors: r.no_ors,
            ors: --[[ :: ]]{
              match[0],
              r.ors
            },
            active: match[1]
          end;
  end else do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "parmatch.ml",
            1297,
            8
          }
        };
  end end 
end end

function discr_pat$1(q, rs) do
  return discr_pat(q, List.map((function (r) do
                    return r.active;
                  end end), rs));
end end

function filter_one$1(q, rs) do
  filter_rec = function (_rs) do
    while(true) do
      rs = _rs;
      if (rs) then do
        rem = rs[1];
        r = rs[0];
        match = r.active;
        if (match) then do
          p = match[0];
          match$1 = p.pat_desc;
          if (typeof match$1 ~= "number") then do
            local ___conditional___=(match$1.tag | 0);
            do
               if ___conditional___ = 1--[[ Tpat_alias ]] then do
                  _rs = --[[ :: ]]{
                    do
                      no_ors: r.no_ors,
                      ors: r.ors,
                      active: --[[ :: ]]{
                        match$1[0],
                        match[1]
                      }
                    end,
                    rem
                  };
                  continue ;end end end 
               if ___conditional___ = 8--[[ Tpat_or ]] then do
                  ps = match[1];
                  _rs = --[[ :: ]]{
                    do
                      no_ors: r.no_ors,
                      ors: r.ors,
                      active: --[[ :: ]]{
                        match$1[0],
                        ps
                      }
                    end,
                    --[[ :: ]]{
                      do
                        no_ors: r.no_ors,
                        ors: r.ors,
                        active: --[[ :: ]]{
                          match$1[1],
                          ps
                        }
                      end,
                      rem
                    }
                  };
                  continue ;end end end 
               do
              else do
                end end
                
            end
          end
           end 
          if (simple_match(q, p)) then do
            return --[[ :: ]]{
                    do
                      no_ors: r.no_ors,
                      ors: r.ors,
                      active: Pervasives.$at(simple_match_args(q, p), match[1])
                    end,
                    filter_rec(rem)
                  };
          end else do
            _rs = rem;
            continue ;
          end end 
        end else do
          throw {
                Caml_builtin_exceptions.assert_failure,
                --[[ tuple ]]{
                  "parmatch.ml",
                  1314,
                  14
                }
              };
        end end 
      end else do
        return --[[ [] ]]0;
      end end 
    end;
  end end;
  return filter_rec(rs);
end end

function make_vector(r) do
  return r.no_ors;
end end

function extract_elements(qs) do
  do_rec = function (seen, param) do
    if (param) then do
      rem = param[1];
      q = param[0];
      return --[[ :: ]]{
              do
                no_ors: Pervasives.$at(List.rev_append(seen, rem), qs.no_ors),
                ors: --[[ [] ]]0,
                active: --[[ :: ]]{
                  q,
                  --[[ [] ]]0
                }
              end,
              do_rec(--[[ :: ]]{
                    q,
                    seen
                  }, rem)
            };
    end else do
      return --[[ [] ]]0;
    end end 
  end end;
  return do_rec(--[[ [] ]]0, qs.ors);
end end

function extract_columns(pss, qs) do
  if (pss) then do
    rs = List.map(extract_elements, pss);
    if (rs) then do
      i = List.map((function (x) do
              return --[[ :: ]]{
                      x,
                      --[[ [] ]]0
                    };
            end end), rs[0]);
      return List.fold_left((function (param, param$1) do
                    return List.map2((function (r, x) do
                                  return --[[ :: ]]{
                                          x,
                                          r
                                        };
                                end end), param, param$1);
                  end end), i, rs[1]);
    end else do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "parmatch.ml",
              1357,
              8
            }
          };
    end end 
  end else do
    return List.map((function (param) do
                  return --[[ [] ]]0;
                end end), qs.ors);
  end end 
end end

function every_satisfiables(_pss, _qs) do
  while(true) do
    qs = _qs;
    pss = _pss;
    match = qs.active;
    if (match) then do
      q = match[0];
      uq = unalias$1(q);
      match$1 = uq.pat_desc;
      exit = 0;
      if (typeof match$1 == "number") then do
        exit = 2;
      end else do
        local ___conditional___=(match$1.tag | 0);
        do
           if ___conditional___ = 0--[[ Tpat_var ]] then do
              exit = 2;end else 
           if ___conditional___ = 5--[[ Tpat_variant ]] then do
              if (is_absent(match$1[0], match$1[2])) then do
                return --[[ Unused ]]1;
              end else do
                exit = 1;
              end end end else 
           if ___conditional___ = 8--[[ Tpat_or ]] then do
              if (match$1[0].pat_loc.loc_ghost and match$1[1].pat_loc.loc_ghost) then do
                _qs = push_no_or(qs);
                _pss = List.map(push_no_or, pss);
                continue ;
              end else do
                _qs = push_or(qs);
                _pss = List.map(push_or, pss);
                continue ;
              end end end end end 
           do end end
          else do
            exit = 1;
            end end
            
        end
      end end 
      local ___conditional___=(exit);
      do
         if ___conditional___ = 1 then do
            q0 = discr_pat$1(q, pss);
            _qs = do
              no_ors: qs.no_ors,
              ors: qs.ors,
              active: Pervasives.$at(simple_match_args(q0, q), match[1])
            end;
            _pss = filter_one$1(q0, pss);
            continue ;end end end 
         if ___conditional___ = 2 then do
            if (is_var_column(pss)) then do
              _qs = remove(qs);
              _pss = List.map(remove, pss);
              continue ;
            end else do
              _qs = push_no_or(qs);
              _pss = List.map(push_no_or, pss);
              continue ;
            end end end end end 
         do
        
      end
    end else do
      match$2 = qs.ors;
      if (match$2) then do
        return List.fold_right2((function (pss, qs, r) do
                      if (typeof r == "number" and r ~= 0) then do
                        return --[[ Unused ]]1;
                      end
                       end 
                      match = qs.active;
                      if (match) then do
                        if (match[1]) then do
                          throw {
                                Caml_builtin_exceptions.assert_failure,
                                --[[ tuple ]]{
                                  "parmatch.ml",
                                  1394,
                                  23
                                }
                              };
                        end
                         end 
                        match$1 = or_args(match[0]);
                        r_loc = every_both(pss, qs, match$1[0], match$1[1]);
                        r1 = r;
                        r2 = r_loc;
                        if (typeof r1 == "number") then do
                          if (r1 ~= 0) then do
                            return --[[ Unused ]]1;
                          end
                           end 
                        end else if (typeof r2 == "number") then do
                          if (r2 == 0) then do
                            return r1;
                          end
                           end 
                        end else do
                          return --[[ Upartial ]]{Pervasives.$at(r1[0], r2[0])};
                        end end  end 
                        if (typeof r2 == "number" and r2 ~= 0) then do
                          return --[[ Unused ]]1;
                        end else do
                          return r2;
                        end end 
                      end else do
                        throw {
                              Caml_builtin_exceptions.assert_failure,
                              --[[ tuple ]]{
                                "parmatch.ml",
                                1394,
                                23
                              }
                            };
                      end end 
                    end end), extract_columns(pss, qs), extract_elements(qs), --[[ Used ]]0);
      end else if (satisfiable(List.map(make_vector, pss), qs.no_ors)) then do
        return --[[ Used ]]0;
      end else do
        return --[[ Unused ]]1;
      end end  end 
    end end 
  end;
end end

function every_both(pss, qs, q1, q2) do
  qs1_no_ors = qs.no_ors;
  qs1_ors = qs.ors;
  qs1_active = --[[ :: ]]{
    q1,
    --[[ [] ]]0
  };
  qs1 = do
    no_ors: qs1_no_ors,
    ors: qs1_ors,
    active: qs1_active
  end;
  qs2_no_ors = qs.no_ors;
  qs2_ors = qs.ors;
  qs2_active = --[[ :: ]]{
    q2,
    --[[ [] ]]0
  };
  qs2 = do
    no_ors: qs2_no_ors,
    ors: qs2_ors,
    active: qs2_active
  end;
  r1 = every_satisfiables(pss, qs1);
  r2 = every_satisfiables(compat(q1, q2) and --[[ :: ]]{
          qs1,
          pss
        } or pss, qs2);
  if (typeof r1 == "number") then do
    if (r1 ~= 0) then do
      if (typeof r2 == "number") then do
        if (r2 ~= 0) then do
          return --[[ Unused ]]1;
        end else do
          return --[[ Upartial ]]{--[[ :: ]]{
                    q1,
                    --[[ [] ]]0
                  }};
        end end 
      end else do
        return --[[ Upartial ]]{--[[ :: ]]{
                  q1,
                  r2[0]
                }};
      end end 
    end else if (typeof r2 == "number" and r2 ~= 0) then do
      return --[[ Upartial ]]{--[[ :: ]]{
                q2,
                --[[ [] ]]0
              }};
    end else do
      return r2;
    end end  end 
  end else do
    u1 = r1[0];
    if (typeof r2 == "number") then do
      if (r2 ~= 0) then do
        return --[[ Upartial ]]{Pervasives.$at(u1, --[[ :: ]]{
                      q2,
                      --[[ [] ]]0
                    })};
      end else do
        return r1;
      end end 
    end else do
      return --[[ Upartial ]]{Pervasives.$at(u1, r2[0])};
    end end 
  end end 
end end

function le_pat(_p, _q) do
  while(true) do
    q = _q;
    p = _p;
    match = p.pat_desc;
    match$1 = q.pat_desc;
    exit = 0;
    if (typeof match == "number") then do
      return true;
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 0--[[ Tpat_var ]] then do
            return true;end end end 
         if ___conditional___ = 1--[[ Tpat_alias ]] then do
            _p = match[0];
            continue ;end end end 
         if ___conditional___ = 2--[[ Tpat_constant ]] then do
            if (typeof match$1 ~= "number") then do
              local ___conditional___=(match$1.tag | 0);
              do
                 if ___conditional___ = 1--[[ Tpat_alias ]] then do
                    exit = 2;end else 
                 if ___conditional___ = 2--[[ Tpat_constant ]] then do
                    return const_compare(match[0], match$1[0]) == 0;end end end 
                 do end
                else do
                  end end
                  
              end
            end
             end end else 
         if ___conditional___ = 3--[[ Tpat_tuple ]] then do
            if (typeof match$1 ~= "number") then do
              local ___conditional___=(match$1.tag | 0);
              do
                 if ___conditional___ = 1--[[ Tpat_alias ]] then do
                    exit = 2;end else 
                 if ___conditional___ = 3--[[ Tpat_tuple ]] then do
                    return le_pats(match[0], match$1[0]);end end end 
                 do end
                else do
                  end end
                  
              end
            end
             end end else 
         if ___conditional___ = 4--[[ Tpat_construct ]] then do
            if (typeof match$1 ~= "number") then do
              local ___conditional___=(match$1.tag | 0);
              do
                 if ___conditional___ = 1--[[ Tpat_alias ]] then do
                    exit = 2;end else 
                 if ___conditional___ = 4--[[ Tpat_construct ]] then do
                    if (equal_tag(match[1].cstr_tag, match$1[1].cstr_tag)) then do
                      return le_pats(match[2], match$1[2]);
                    end else do
                      return false;
                    end end end end end 
                 do end
                else do
                  end end
                  
              end
            end
             end end else 
         if ___conditional___ = 5--[[ Tpat_variant ]] then do
            match$2 = match[1];
            l1 = match[0];
            if (match$2 ~= undefined) then do
              if (typeof match$1 ~= "number") then do
                local ___conditional___=(match$1.tag | 0);
                do
                   if ___conditional___ = 1--[[ Tpat_alias ]] then do
                      exit = 2;end else 
                   if ___conditional___ = 5--[[ Tpat_variant ]] then do
                      match$3 = match$1[1];
                      if (match$3 ~= undefined and l1 == match$1[0]) then do
                        _q = match$3;
                        _p = match$2;
                        continue ;
                      end else do
                        return false;
                      end end end end end 
                   do end
                  else do
                    end end
                    
                end
              end
               end 
            end else if (typeof match$1 ~= "number") then do
              local ___conditional___=(match$1.tag | 0);
              do
                 if ___conditional___ = 1--[[ Tpat_alias ]] then do
                    exit = 2;end else 
                 if ___conditional___ = 5--[[ Tpat_variant ]] then do
                    if (match$1[1] ~= undefined) then do
                      return false;
                    end else do
                      return l1 == match$1[0];
                    end end end end end 
                 do end
                else do
                  end end
                  
              end
            end
             end  end end else 
         if ___conditional___ = 6--[[ Tpat_record ]] then do
            if (typeof match$1 ~= "number") then do
              local ___conditional___=(match$1.tag | 0);
              do
                 if ___conditional___ = 1--[[ Tpat_alias ]] then do
                    exit = 2;end else 
                 if ___conditional___ = 6--[[ Tpat_record ]] then do
                    match$4 = records_args(match[0], match$1[0]);
                    return le_pats(match$4[0], match$4[1]);end end end 
                 do end
                else do
                  end end
                  
              end
            end
             end end else 
         if ___conditional___ = 7--[[ Tpat_array ]] then do
            ps = match[0];
            if (typeof match$1 ~= "number") then do
              local ___conditional___=(match$1.tag | 0);
              do
                 if ___conditional___ = 1--[[ Tpat_alias ]] then do
                    exit = 2;end else 
                 if ___conditional___ = 7--[[ Tpat_array ]] then do
                    qs = match$1[0];
                    if (List.length(ps) == List.length(qs)) then do
                      return le_pats(ps, qs);
                    end else do
                      return false;
                    end end end end end 
                 do end
                else do
                  end end
                  
              end
            end
             end end else 
         if ___conditional___ = 8--[[ Tpat_or ]] then do
            exit = 2;end else 
         if ___conditional___ = 9--[[ Tpat_lazy ]] then do
            if (typeof match$1 ~= "number") then do
              local ___conditional___=(match$1.tag | 0);
              do
                 if ___conditional___ = 1--[[ Tpat_alias ]] then do
                    exit = 2;end else 
                 if ___conditional___ = 9--[[ Tpat_lazy ]] then do
                    _q = match$1[0];
                    _p = match[0];
                    continue ;end end end 
                 do end
                else do
                  end end
                  
              end
            end
             end end else 
         do end end end end end end end
        
      end
    end end 
    if (exit == 2 and typeof match$1 ~= "number" and match$1.tag == --[[ Tpat_alias ]]1) then do
      _q = match$1[0];
      continue ;
    end
     end 
    return not satisfiable(--[[ :: ]]{
                --[[ :: ]]{
                  p,
                  --[[ [] ]]0
                },
                --[[ [] ]]0
              }, --[[ :: ]]{
                q,
                --[[ [] ]]0
              });
  end;
end end

function le_pats(_ps, _qs) do
  while(true) do
    qs = _qs;
    ps = _ps;
    if (ps and qs) then do
      if (le_pat(ps[0], qs[0])) then do
        _qs = qs[1];
        _ps = ps[1];
        continue ;
      end else do
        return false;
      end end 
    end else do
      return true;
    end end 
  end;
end end

function get_mins(le, ps) do
  select_rec = function (_r, _param) do
    while(true) do
      param = _param;
      r = _r;
      if (param) then do
        ps = param[1];
        p = param[0];
        if (List.exists((function(p)do
              return function (p0) do
                return Curry._2(le, p0, p);
              end end
              end(p)), ps)) then do
          _param = ps;
          continue ;
        end else do
          _param = ps;
          _r = --[[ :: ]]{
            p,
            r
          };
          continue ;
        end end 
      end else do
        return r;
      end end 
    end;
  end end;
  return select_rec(--[[ [] ]]0, select_rec(--[[ [] ]]0, ps));
end end

function pressure_variants$1(tdefs, patl) do
  pss = List.map((function (p) do
          return --[[ :: ]]{
                  p,
                  --[[ :: ]]{
                    omega,
                    --[[ [] ]]0
                  }
                };
        end end), patl);
  pressure_variants(Caml_option.some(tdefs), pss);
  return --[[ () ]]0;
end end

function initial_matrix(_param) do
  while(true) do
    param = _param;
    if (param) then do
      match = param[0];
      if (match.c_guard ~= undefined) then do
        _param = param[1];
        continue ;
      end else do
        return --[[ :: ]]{
                --[[ :: ]]{
                  match.c_lhs,
                  --[[ [] ]]0
                },
                initial_matrix(param[1])
              };
      end end 
    end else do
      return --[[ [] ]]0;
    end end 
  end;
end end

NoGuard = Caml_exceptions.create("Ocaml_typedtree_test.Parmatch.NoGuard");

function initial_all(no_guard, param) do
  if (param) then do
    match = param[0];
    pat = match.c_lhs;
    return --[[ :: ]]{
            --[[ tuple ]]{
              --[[ :: ]]{
                pat,
                --[[ [] ]]0
              },
              pat.pat_loc
            },
            initial_all(no_guard and match.c_guard == undefined, param[1])
          };
  end else if (no_guard) then do
    throw NoGuard;
  end else do
    return --[[ [] ]]0;
  end end  end 
end end

function do_filter_var(param) do
  if (param) then do
    match = param[0];
    match$1 = match[0];
    if (match$1) then do
      return --[[ :: ]]{
              --[[ tuple ]]{
                match$1[1],
                match[1]
              },
              do_filter_var(param[1])
            };
    end else do
      return --[[ [] ]]0;
    end end 
  end else do
    return --[[ [] ]]0;
  end end 
end end

function do_filter_one(q, pss) do
  filter_rec = function (_param) do
    while(true) do
      param = _param;
      if (param) then do
        match = param[0];
        match$1 = match[0];
        if (match$1) then do
          p = match$1[0];
          match$2 = p.pat_desc;
          if (typeof match$2 ~= "number") then do
            local ___conditional___=(match$2.tag | 0);
            do
               if ___conditional___ = 1--[[ Tpat_alias ]] then do
                  _param = --[[ :: ]]{
                    --[[ tuple ]]{
                      --[[ :: ]]{
                        match$2[0],
                        match$1[1]
                      },
                      match[1]
                    },
                    param[1]
                  };
                  continue ;end end end 
               if ___conditional___ = 8--[[ Tpat_or ]] then do
                  loc = match[1];
                  ps = match$1[1];
                  _param = --[[ :: ]]{
                    --[[ tuple ]]{
                      --[[ :: ]]{
                        match$2[0],
                        ps
                      },
                      loc
                    },
                    --[[ :: ]]{
                      --[[ tuple ]]{
                        --[[ :: ]]{
                          match$2[1],
                          ps
                        },
                        loc
                      },
                      param[1]
                    }
                  };
                  continue ;end end end 
               do
              else do
                end end
                
            end
          end
           end 
          pss = param[1];
          if (simple_match(q, p)) then do
            return --[[ :: ]]{
                    --[[ tuple ]]{
                      Pervasives.$at(simple_match_args(q, p), match$1[1]),
                      match[1]
                    },
                    filter_rec(pss)
                  };
          end else do
            _param = pss;
            continue ;
          end end 
        end else do
          return --[[ [] ]]0;
        end end 
      end else do
        return --[[ [] ]]0;
      end end 
    end;
  end end;
  return filter_rec(pss);
end end

function do_match(_pss, _qs) do
  while(true) do
    qs = _qs;
    pss = _pss;
    if (qs) then do
      q = qs[0];
      match = q.pat_desc;
      qs$1 = qs[1];
      if (typeof match == "number") then do
        _qs = qs$1;
        _pss = do_filter_var(pss);
        continue ;
      end else if (match.tag == --[[ Tpat_or ]]8) then do
        r = do_match(pss, --[[ :: ]]{
              match[0],
              qs$1
            });
        if (r ~= undefined) then do
          return r;
        end else do
          _qs = --[[ :: ]]{
            match[1],
            qs$1
          };
          continue ;
        end end 
      end else do
        q0 = normalize_pat(q);
        _qs = Pervasives.$at(simple_match_args(q0, q), qs$1);
        _pss = do_filter_one(q0, pss);
        continue ;
      end end  end 
    end else if (pss) then do
      match$1 = pss[0];
      if (match$1[0]) then do
        return ;
      end else do
        return Caml_option.some(match$1[1]);
      end end 
    end else do
      return ;
    end end  end 
  end;
end end

function check_partial_all(v, casel) do
  try do
    pss = initial_all(true, casel);
    return do_match(pss, --[[ :: ]]{
                v,
                --[[ [] ]]0
              });
  end
  catch (exn)do
    if (exn == NoGuard) then do
      return ;
    end else do
      throw exn;
    end end 
  end
end end

function get_first(f, _param) do
  while(true) do
    param = _param;
    if (param) then do
      x = Curry._1(f, param[0]);
      if (x ~= undefined) then do
        return x;
      end else do
        _param = param[1];
        continue ;
      end end 
    end else do
      return ;
    end end 
  end;
end end

function select(param) do
  if (param) then do
    xs = param[0];
    if (param[1]) then do
      if (xs) then do
        ys = param[1];
        x = xs[0];
        return Pervasives.$at(List.map((function (lst) do
                          return --[[ :: ]]{
                                  x,
                                  lst
                                };
                        end end), select(ys)), select(--[[ :: ]]{
                        xs[1],
                        ys
                      }));
      end else do
        return --[[ [] ]]0;
      end end 
    end else do
      return List.map((function (y) do
                    return --[[ :: ]]{
                            y,
                            --[[ [] ]]0
                          };
                  end end), xs);
    end end 
  end else do
    return --[[ [] ]]0;
  end end 
end end

name_counter$1 = do
  contents: 0
end;

function fresh(name) do
  current = name_counter$1.contents;
  name_counter$1.contents = name_counter$1.contents + 1 | 0;
  return "#$" .. (name .. String(current));
end end

function conv(typed) do
  constrs = Hashtbl.create(undefined, 0);
  labels = Hashtbl.create(undefined, 0);
  loop = function (_pat) do
    while(true) do
      pat = _pat;
      match = pat.pat_desc;
      if (typeof match == "number") then do
        return --[[ :: ]]{
                mk$1(undefined, undefined, --[[ Ppat_any ]]0),
                --[[ [] ]]0
              };
      end else do
        local ___conditional___=(match.tag | 0);
        do
           if ___conditional___ = 1--[[ Tpat_alias ]] then do
              _pat = match[0];
              continue ;end end end 
           if ___conditional___ = 3--[[ Tpat_tuple ]] then do
              results = select(List.map(loop, match[0]));
              return List.map((function (lst) do
                            return mk$1(undefined, undefined, --[[ Ppat_tuple ]]Block.__(4, {lst}));
                          end end), results);end end end 
           if ___conditional___ = 4--[[ Tpat_construct ]] then do
              lst = match[2];
              cstr = match[1];
              id = fresh(cstr.cstr_name);
              lid_txt = --[[ Lident ]]Block.__(0, {id});
              lid_loc = match[0].loc;
              lid = do
                txt: lid_txt,
                loc: lid_loc
              end;
              Hashtbl.add(constrs, id, cstr);
              results$1 = select(List.map(loop, lst));
              if (lst) then do
                return List.map((function(lid)do
                          return function (lst) do
                            arg;
                            if (lst) then do
                              arg = lst[1] and mk$1(undefined, undefined, --[[ Ppat_tuple ]]Block.__(4, {lst})) or lst[0];
                            end else do
                              throw {
                                    Caml_builtin_exceptions.assert_failure,
                                    --[[ tuple ]]{
                                      "parmatch.ml",
                                      1729,
                                      28
                                    }
                                  };
                            end end 
                            return mk$1(undefined, undefined, --[[ Ppat_construct ]]Block.__(5, {
                                          lid,
                                          arg
                                        }));
                          end end
                          end(lid)), results$1);
              end else do
                return --[[ :: ]]{
                        mk$1(undefined, undefined, --[[ Ppat_construct ]]Block.__(5, {
                                lid,
                                undefined
                              })),
                        --[[ [] ]]0
                      };
              end end end end end 
           if ___conditional___ = 5--[[ Tpat_variant ]] then do
              p_opt = match[1];
              label = match[0];
              if (p_opt ~= undefined) then do
                results$2 = loop(p_opt);
                return List.map((function(label)do
                          return function (p) do
                            return mk$1(undefined, undefined, --[[ Ppat_variant ]]Block.__(6, {
                                          label,
                                          p
                                        }));
                          end end
                          end(label)), results$2);
              end else do
                return --[[ :: ]]{
                        mk$1(undefined, undefined, --[[ Ppat_variant ]]Block.__(6, {
                                label,
                                undefined
                              })),
                        --[[ [] ]]0
                      };
              end end end end end 
           if ___conditional___ = 6--[[ Tpat_record ]] then do
              subpatterns = match[0];
              pats = select(List.map((function (param) do
                          return loop(param[2]);
                        end end), subpatterns));
              label_idents = List.map((function (param) do
                      lbl = param[1];
                      id = fresh(lbl.lbl_name);
                      Hashtbl.add(labels, id, lbl);
                      return --[[ Lident ]]Block.__(0, {id});
                    end end), subpatterns);
              return List.map((function(label_idents)do
                        return function (lst) do
                          lst$1 = List.map2((function (lid, pat) do
                                  return --[[ tuple ]]{
                                          do
                                            txt: lid,
                                            loc: none
                                          end,
                                          pat
                                        };
                                end end), label_idents, lst);
                          return mk$1(undefined, undefined, --[[ Ppat_record ]]Block.__(7, {
                                        lst$1,
                                        --[[ Open ]]1
                                      }));
                        end end
                        end(label_idents)), pats);end end end 
           if ___conditional___ = 7--[[ Tpat_array ]] then do
              results$3 = select(List.map(loop, match[0]));
              return List.map((function (lst) do
                            return mk$1(undefined, undefined, --[[ Ppat_array ]]Block.__(8, {lst}));
                          end end), results$3);end end end 
           if ___conditional___ = 8--[[ Tpat_or ]] then do
              return Pervasives.$at(loop(match[0]), loop(match[1]));end end end 
           if ___conditional___ = 9--[[ Tpat_lazy ]] then do
              results$4 = loop(match[0]);
              return List.map((function (p) do
                            return mk$1(undefined, undefined, --[[ Ppat_lazy ]]Block.__(12, {p}));
                          end end), results$4);end end end 
           do
          else do
            return --[[ :: ]]{
                    mk$1(undefined, undefined, --[[ Ppat_any ]]0),
                    --[[ [] ]]0
                  };
            end end
            
        end
      end end 
    end;
  end end;
  ps = loop(typed);
  return --[[ tuple ]]{
          ps,
          constrs,
          labels
        };
end end

function do_check_partial(pred, exhaust, loc, casel, pss) do
  if (pss) then do
    match = Curry._3(exhaust, undefined, pss, List.length(pss[0]));
    if (match) then do
      match$1 = match[0];
      if (match$1 and not match$1[1]) then do
        u = match$1[0];
        v;
        if (pred ~= undefined) then do
          match$2 = conv(u);
          v = get_first(Curry._2(pred, match$2[1], match$2[2]), match$2[0]);
        end else do
          v = u;
        end end 
        if (v ~= undefined) then do
          v$1 = v;
          match$3 = v$1.pat_desc;
          errmsg;
          exit = 0;
          if (typeof match$3 == "number" or not (match$3.tag == --[[ Tpat_construct ]]4 and match$3[1].cstr_name == "*extension*")) then do
            exit = 1;
          end else do
            errmsg = "_\nMatching over values of extensible variant types must include\na wild card pattern in order to be exhaustive.";
          end end 
          if (exit == 1) then do
            try do
              buf = __Buffer.create(16);
              fmt = Format.formatter_of_buffer(buf);
              top_pretty(fmt, v$1);
              match$4 = check_partial_all(v$1, casel);
              if (match$4 ~= undefined) then do
                __Buffer.add_string(buf, "\n(However, some guarded clause may match this value.)");
              end
               end 
              errmsg = __Buffer.contents(buf);
            end
            catch (exn)do
              errmsg = "";
            end
          end
           end 
          prerr_warning(loc, --[[ Partial_match ]]Block.__(3, {errmsg}));
          return --[[ Partial ]]0;
        end else do
          return --[[ Total ]]1;
        end end 
      end else do
        return fatal_error("Parmatch.check_partial");
      end end 
    end else do
      return --[[ Total ]]1;
    end end 
  end else do
    if (casel) then do
      prerr_warning(loc, --[[ All_clauses_guarded ]]12);
    end
     end 
    return --[[ Partial ]]0;
  end end 
end end

function do_check_partial_normal(loc, casel, pss) do
  return do_check_partial(undefined, exhaust, loc, casel, pss);
end end

function add_path(path, paths) do
  if (paths) then do
    x = paths[0];
    if (same(path, x)) then do
      return paths;
    end else do
      return --[[ :: ]]{
              x,
              add_path(path, paths[1])
            };
    end end 
  end else do
    return --[[ :: ]]{
            path,
            --[[ [] ]]0
          };
  end end 
end end

function extendable_path(path) do
  return not (same(path, path_bool) or same(path, path_list) or same(path, path_unit) or same(path, path_option));
end end

function collect_paths_from_pat(_r, _p) do
  while(true) do
    p = _p;
    r = _r;
    match = p.pat_desc;
    if (typeof match == "number") then do
      return r;
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 4--[[ Tpat_construct ]] then do
            local ___conditional___=(match[1].cstr_tag.tag | 0);
            do
               if ___conditional___ = 0--[[ Cstr_constant ]]
               or ___conditional___ = 1--[[ Cstr_block ]]
               or ___conditional___ = 2--[[ Cstr_extension ]] then do
                  return List.fold_left(collect_paths_from_pat, r, match[2]);end end end 
               do
              
            end
            path = get_type_path(p.pat_type, p.pat_env);
            return List.fold_left(collect_paths_from_pat, extendable_path(path) and add_path(path, r) or r, match[2]);end end end 
         if ___conditional___ = 5--[[ Tpat_variant ]] then do
            match$1 = match[1];
            if (match$1 ~= undefined) then do
              _p = match$1;
              continue ;
            end else do
              return r;
            end end end end end 
         if ___conditional___ = 6--[[ Tpat_record ]] then do
            return List.fold_left((function (r, param) do
                          return collect_paths_from_pat(r, param[2]);
                        end end), r, match[0]);end end end 
         if ___conditional___ = 3--[[ Tpat_tuple ]]
         or ___conditional___ = 7--[[ Tpat_array ]] then do
            return List.fold_left(collect_paths_from_pat, r, match[0]);end end end 
         if ___conditional___ = 8--[[ Tpat_or ]] then do
            _p = match[1];
            _r = collect_paths_from_pat(r, match[0]);
            continue ;end end end 
         if ___conditional___ = 1--[[ Tpat_alias ]]
         or ___conditional___ = 9--[[ Tpat_lazy ]] then do
            _p = match[0];
            continue ;end end end 
         do
        else do
          return r;
          end end
          
      end
    end end 
  end;
end end

function do_check_fragile_param(exhaust, loc, casel, pss) do
  exts = List.fold_left((function (r, c) do
          return collect_paths_from_pat(r, c.c_lhs);
        end end), --[[ [] ]]0, casel);
  if (exts and pss) then do
    ps = pss[0];
    return List.iter((function (ext) do
                  match = Curry._3(exhaust, ext, pss, List.length(ps));
                  if (match) then do
                    return --[[ () ]]0;
                  end else do
                    return prerr_warning(loc, --[[ Fragile_match ]]Block.__(1, {name(undefined, ext)}));
                  end end 
                end end), exts);
  end else do
    return --[[ () ]]0;
  end end 
end end

function do_check_fragile_normal(param, param$1, param$2) do
  return do_check_fragile_param(exhaust, param, param$1, param$2);
end end

function do_check_fragile_gadt(param, param$1, param$2) do
  return do_check_fragile_param(exhaust_gadt$1, param, param$1, param$2);
end end

function check_partial_param(do_check_partial, do_check_fragile, loc, casel) do
  if (is_active(--[[ Partial_match ]]Block.__(3, {""}))) then do
    pss = initial_matrix(casel);
    pss$1 = get_mins(le_pats, pss);
    total = Curry._3(do_check_partial, loc, casel, pss$1);
    if (total == --[[ Total ]]1 and is_active(--[[ Fragile_match ]]Block.__(1, {""}))) then do
      Curry._3(do_check_fragile, loc, casel, pss$1);
    end
     end 
    return total;
  end else do
    return --[[ Partial ]]0;
  end end 
end end

function check_partial(param, param$1) do
  return check_partial_param(do_check_partial_normal, do_check_fragile_normal, param, param$1);
end end

Already_bound = Caml_exceptions.create("Ocaml_typedtree_test.Typetexp.Already_bound");

__Error$6 = Caml_exceptions.create("Ocaml_typedtree_test.Typetexp.Error");

Error_forward = Caml_exceptions.create("Ocaml_typedtree_test.Typetexp.Error_forward");

function string_of_payload(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ PStr ]] then do
        match = param[0];
        if (match) then do
          match$1 = match[0].pstr_desc;
          if (match$1.tag) then do
            return ;
          end else do
            match$2 = match$1[0].pexp_desc;
            if (match$2.tag == --[[ Pexp_constant ]]1 and not match[1]) then do
              param$1 = match$2[0];
              if (param$1.tag == --[[ Const_string ]]2) then do
                return param$1[0];
              end else do
                return ;
              end end 
            end else do
              return ;
            end end 
          end end 
        end else do
          return ;
        end end end end end 
     if ___conditional___ = 1--[[ PTyp ]]
     or ___conditional___ = 2--[[ PPat ]] then do
        return ;end end end 
     do
    
  end
end end

function error_of_extension(ext) do
  match = ext[0];
  txt = match.txt;
  exit = 0;
  local ___conditional___=(txt);
  do
     if ___conditional___ = "error"
     or ___conditional___ = "ocaml.error" then do
        exit = 1;end else 
     do end end
    else do
      return Curry._1(errorf(match.loc, undefined, undefined, --[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "Uninterpreted extension '",
                          --[[ String ]]Block.__(2, {
                              --[[ No_padding ]]0,
                              --[[ String_literal ]]Block.__(11, {
                                  "'.",
                                  --[[ End_of_format ]]0
                                })
                            })
                        }),
                      "Uninterpreted extension '%s'."
                    }), txt);
      end end
      
  end
  if (exit == 1) then do
    p = ext[1];
    loc = match.loc;
    sub_from = function (inner) do
      if (inner) then do
        match = inner[0].pstr_desc;
        if (match.tag == --[[ Pstr_extension ]]14) then do
          return --[[ :: ]]{
                  error_of_extension(match[0]),
                  sub_from(inner[1])
                };
        end else do
          return --[[ :: ]]{
                  Curry._1(errorf(loc, undefined, undefined, --[[ Format ]]{
                            --[[ String_literal ]]Block.__(11, {
                                "Invalid syntax for sub-error of extension '",
                                --[[ String ]]Block.__(2, {
                                    --[[ No_padding ]]0,
                                    --[[ String_literal ]]Block.__(11, {
                                        "'.",
                                        --[[ End_of_format ]]0
                                      })
                                  })
                              }),
                            "Invalid syntax for sub-error of extension '%s'."
                          }), txt),
                  sub_from(inner[1])
                };
        end end 
      end else do
        return --[[ [] ]]0;
      end end 
    end end;
    local ___conditional___=(p.tag | 0);
    do
       if ___conditional___ = 0--[[ PStr ]] then do
          match$1 = p[0];
          if (match$1) then do
            match$2 = match$1[0].pstr_desc;
            if (not match$2.tag) then do
              match$3 = match$2[0].pexp_desc;
              if (match$3.tag == --[[ Pexp_constant ]]1) then do
                match$4 = match$3[0];
                if (match$4.tag == --[[ Const_string ]]2) then do
                  inner = match$1[1];
                  msg = match$4[0];
                  exit$1 = 0;
                  if (inner) then do
                    match$5 = inner[0].pstr_desc;
                    if (match$5.tag) then do
                      exit$1 = 3;
                    end else do
                      match$6 = match$5[0].pexp_desc;
                      if (match$6.tag == --[[ Pexp_constant ]]1) then do
                        match$7 = match$6[0];
                        if (match$7.tag == --[[ Const_string ]]2) then do
                          return error(loc, sub_from(inner[1]), match$7[0], msg);
                        end else do
                          exit$1 = 3;
                        end end 
                      end else do
                        exit$1 = 3;
                      end end 
                    end end 
                  end else do
                    exit$1 = 3;
                  end end 
                  if (exit$1 == 3) then do
                    return error(loc, sub_from(inner), undefined, msg);
                  end
                   end 
                end
                 end 
              end
               end 
            end
             end 
          end
           end end else 
       if ___conditional___ = 1--[[ PTyp ]]
       or ___conditional___ = 2--[[ PPat ]]
       do end end
      
    end
    return Curry._1(errorf(loc, undefined, undefined, --[[ Format ]]{
                    --[[ String_literal ]]Block.__(11, {
                        "Invalid syntax for extension '",
                        --[[ String ]]Block.__(2, {
                            --[[ No_padding ]]0,
                            --[[ String_literal ]]Block.__(11, {
                                "'.",
                                --[[ End_of_format ]]0
                              })
                          })
                      }),
                    "Invalid syntax for extension '%s'."
                  }), txt);
  end
   end 
end end

function check_deprecated(loc, attrs, s) do
  return List.iter((function (param) do
                local ___conditional___=(param[0].txt);
                do
                   if ___conditional___ = "deprecated"
                   or ___conditional___ = "ocaml.deprecated"
                   do end
                  else do
                    return --[[ () ]]0;
                    end end
                    
                end
                match = string_of_payload(param[1]);
                if (match ~= undefined) then do
                  txt = match;
                  if (bs_vscode) then do
                    return prerr_warning(loc, --[[ Deprecated ]]Block.__(0, {s .. (" " .. txt)}));
                  end else do
                    return prerr_warning(loc, --[[ Deprecated ]]Block.__(0, {s .. ("\n" .. txt)}));
                  end end 
                end else do
                  return prerr_warning(loc, --[[ Deprecated ]]Block.__(0, {s}));
                end end 
              end end), attrs);
end end

newrecord$1 = Caml_obj.caml_obj_dup(default_mapper);

newrecord$1.attribute = (function (param, a) do
    exit = 0;
    local ___conditional___=(a[0].txt);
    do
       if ___conditional___ = "ocaml.ppwarning"
       or ___conditional___ = "ppwarning" then do
          exit = 1;end else 
       do end end
      else do
        end end
        
    end
    if (exit == 1) then do
      match = a[1];
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 0--[[ PStr ]] then do
            match$1 = match[0];
            if (match$1) then do
              match$2 = match$1[0];
              match$3 = match$2.pstr_desc;
              if (not match$3.tag) then do
                match$4 = match$3[0].pexp_desc;
                if (match$4.tag == --[[ Pexp_constant ]]1) then do
                  match$5 = match$4[0];
                  if (match$5.tag == --[[ Const_string ]]2 and not match$1[1]) then do
                    prerr_warning(match$2.pstr_loc, --[[ Preprocessor ]]Block.__(10, {match$5[0]}));
                  end
                   end 
                end
                 end 
              end
               end 
            end
             end end else 
         if ___conditional___ = 1--[[ PTyp ]]
         or ___conditional___ = 2--[[ PPat ]]
         do end end
        
      end
    end
     end 
    return a;
  end end);

warning_scope = do
  contents: --[[ [] ]]0
end;

function warning_enter_scope(param) do
  warning_scope.contents = --[[ :: ]]{
    current.contents,
    warning_scope.contents
  };
  return --[[ () ]]0;
end end

function warning_leave_scope(param) do
  match = warning_scope.contents;
  if (match) then do
    current.contents = match[0];
    warning_scope.contents = match[1];
    return --[[ () ]]0;
  end else do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "typetexp.ml",
            146,
            10
          }
        };
  end end 
end end

function warning_attribute(attrs) do
  __process = function (loc, txt, errflag, payload) do
    match = string_of_payload(payload);
    if (match ~= undefined) then do
      try do
        return parse_options(errflag, match);
      end
      catch (raw_exn)do
        exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn[0] == Arg.Bad) then do
          return prerr_warning(loc, --[[ Attribute_payload ]]Block.__(30, {
                        txt,
                        "Ill-formed list of warnings"
                      }));
        end else do
          throw exn;
        end end 
      end
    end else do
      return prerr_warning(loc, --[[ Attribute_payload ]]Block.__(30, {
                    txt,
                    "A single string literal is expected"
                  }));
    end end 
  end end;
  return List.iter((function (param) do
                match = param[0];
                txt = match.txt;
                exit = 0;
                local ___conditional___=(txt);
                do
                   if ___conditional___ = "ocaml.warnerror"
                   or ___conditional___ = "warnerror" then do
                      exit = 2;end else 
                   if ___conditional___ = "ocaml.warning"
                   or ___conditional___ = "warning" then do
                      exit = 1;end else 
                   do end end end
                  else do
                    return --[[ () ]]0;
                    end end
                    
                end
                local ___conditional___=(exit);
                do
                   if ___conditional___ = 1 then do
                      return __process(match.loc, txt, false, param[1]);end end end 
                   if ___conditional___ = 2 then do
                      return __process(match.loc, txt, true, param[1]);end end end 
                   do
                  
                end
              end end), attrs);
end end

function narrow_unbound_lid_error(env, loc, lid, make_error) do
  check_module = function (mlid) do
    try do
      lookup_module(true, mlid, env);
      return --[[ () ]]0;
    end
    catch (exn)do
      if (exn == Caml_builtin_exceptions.not_found) then do
        return narrow_unbound_lid_error(env, loc, mlid, (function (lid) do
                      return --[[ Unbound_module ]]Block.__(20, {lid});
                    end end));
      end else do
        if (exn == Recmodule) then do
          throw {
                __Error$6,
                loc,
                env,
                --[[ Illegal_reference_to_recursive_module ]]1
              };
        end
         end 
        throw exn;
      end end 
    end
  end end;
  local ___conditional___=(lid.tag | 0);
  do
     if ___conditional___ = 0--[[ Lident ]]
     or ___conditional___ = 1--[[ Ldot ]] then do
        mlid = lid[0];
        check_module(mlid);
        md = find_module(false, lookup_module(true, mlid, env), env);
        match = scrape_alias(env, undefined, md.md_type);
        if (match.tag == --[[ Mty_functor ]]2) then do
          throw {
                __Error$6,
                loc,
                env,
                --[[ Access_functor_as_structure ]]Block.__(25, {mlid})
              };
        end
         end end else 
     if ___conditional___ = 2--[[ Lapply ]] then do
        check_module(lid[0]);
        check_module(lid[1]);
        throw {
              __Error$6,
              loc,
              env,
              --[[ Ill_typed_functor_application ]]Block.__(24, {lid})
            };end end end 
     do end
    
  end
  throw {
        __Error$6,
        loc,
        env,
        Curry._1(make_error, lid)
      };
end end

function find_component(lookup, make_error, env, loc, lid) do
  try do
    local ___conditional___=(lid.tag | 0);
    do
       if ___conditional___ = 1--[[ Ldot ]] then do
          match = lid[0];
          local ___conditional___=(match.tag | 0);
          do
             if ___conditional___ = 0--[[ Lident ]] then do
                if (match[0] == "*predef*") then do
                  return Curry._2(lookup, --[[ Lident ]]Block.__(0, {lid[1]}), initial_safe_string);
                end else do
                  return Curry._2(lookup, lid, env);
                end end end end end 
             if ___conditional___ = 1--[[ Ldot ]]
             or ___conditional___ = 2--[[ Lapply ]] then do
                return Curry._2(lookup, lid, env);end end end 
             do
            
          endend end end 
       if ___conditional___ = 0--[[ Lident ]]
       or ___conditional___ = 2--[[ Lapply ]] then do
          return Curry._2(lookup, lid, env);end end end 
       do
      
    end
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return narrow_unbound_lid_error(env, loc, lid, make_error);
    end else do
      if (exn == Recmodule) then do
        throw {
              __Error$6,
              loc,
              env,
              --[[ Illegal_reference_to_recursive_module ]]1
            };
      end
       end 
      throw exn;
    end end 
  end
end end

function find_type(env, loc, lid) do
  r = find_component(lookup_type$1, (function (lid) do
          return --[[ Unbound_type_constructor ]]Block.__(1, {lid});
        end end), env, loc, lid);
  check_deprecated(loc, r[1].type_attributes, name(undefined, r[0]));
  return r;
end end

function find_constructor(param, param$1, param$2) do
  return find_component(lookup_constructor, (function (lid) do
                return --[[ Unbound_constructor ]]Block.__(18, {lid});
              end end), param, param$1, param$2);
end end

function find_all_constructors(param, param$1, param$2) do
  return find_component(lookup_all_constructors$1, (function (lid) do
                return --[[ Unbound_constructor ]]Block.__(18, {lid});
              end end), param, param$1, param$2);
end end

function find_all_labels(param, param$1, param$2) do
  return find_component(lookup_all_labels$1, (function (lid) do
                return --[[ Unbound_label ]]Block.__(19, {lid});
              end end), param, param$1, param$2);
end end

function find_class$1(env, loc, lid) do
  r = find_component(lookup_class$1, (function (lid) do
          return --[[ Unbound_class ]]Block.__(21, {lid});
        end end), env, loc, lid);
  check_deprecated(loc, r[1].cty_attributes, name(undefined, r[0]));
  return r;
end end

function find_value$1(env, loc, lid) do
  check_value_name(last$1(lid), loc);
  r = find_component(lookup_value$1, (function (lid) do
          return --[[ Unbound_value ]]Block.__(17, {lid});
        end end), env, loc, lid);
  check_deprecated(loc, r[1].val_attributes, name(undefined, r[0]));
  return r;
end end

function lookup_module$1(loadOpt, env, loc, lid) do
  load = loadOpt ~= undefined and loadOpt or false;
  return find_component((function (lid, env) do
                  return --[[ tuple ]]{
                          lookup_module(load, lid, env),
                          --[[ () ]]0
                        };
                end end), (function (lid) do
                  return --[[ Unbound_module ]]Block.__(20, {lid});
                end end), env, loc, lid)[0];
end end

function find_module$1(env, loc, lid) do
  path = lookup_module$1(true, env, loc, lid);
  decl = find_module(false, path, env);
  check_deprecated(loc, decl.md_attributes, name(undefined, path));
  return --[[ tuple ]]{
          path,
          decl
        };
end end

function find_modtype$1(env, loc, lid) do
  r = find_component(lookup_modtype, (function (lid) do
          return --[[ Unbound_modtype ]]Block.__(22, {lid});
        end end), env, loc, lid);
  check_deprecated(loc, r[1].mtd_attributes, name(undefined, r[0]));
  return r;
end end

function find_class_type(env, loc, lid) do
  r = find_component(lookup_cltype$1, (function (lid) do
          return --[[ Unbound_cltype ]]Block.__(23, {lid});
        end end), env, loc, lid);
  check_deprecated(loc, r[1].clty_attributes, name(undefined, r[0]));
  return r;
end end

function unbound_constructor_error(env, lid) do
  return narrow_unbound_lid_error(env, lid.loc, lid.txt, (function (lid) do
                return --[[ Unbound_constructor ]]Block.__(18, {lid});
              end end));
end end

function unbound_label_error(env, lid) do
  return narrow_unbound_lid_error(env, lid.loc, lid.txt, (function (lid) do
                return --[[ Unbound_label ]]Block.__(19, {lid});
              end end));
end end

transl_modtype_longident = do
  contents: (function (param) do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "typetexp.ml",
              293,
              45
            }
          };
    end end)
end;

transl_modtype = do
  contents: (function (param) do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "typetexp.ml",
              294,
              35
            }
          };
    end end)
end;

function create_package_mty(fake, loc, env, param) do
  l = List.sort((function (param, param$1) do
          s2 = param$1[0];
          s1 = param[0];
          if (Caml_obj.caml_equal(s1.txt, s2.txt)) then do
            throw {
                  __Error$6,
                  loc,
                  env,
                  --[[ Multiple_constraints_on_type ]]Block.__(15, {s1.txt})
                };
          end
           end 
          return Caml_obj.caml_compare(s1.txt, s2.txt);
        end end), param[1]);
  return --[[ tuple ]]{
          l,
          List.fold_left((function (mty, param) do
                  s = param[0];
                  d_ptype_name = do
                    txt: last$1(s.txt),
                    loc: s.loc
                  end;
                  d_ptype_manifest = fake and undefined or param[1];
                  d = do
                    ptype_name: d_ptype_name,
                    ptype_params: --[[ [] ]]0,
                    ptype_cstrs: --[[ [] ]]0,
                    ptype_kind: --[[ Ptype_abstract ]]0,
                    ptype_private: --[[ Public ]]1,
                    ptype_manifest: d_ptype_manifest,
                    ptype_attributes: --[[ [] ]]0,
                    ptype_loc: loc
                  end;
                  return mk$3(loc, undefined, --[[ Pmty_with ]]Block.__(3, {
                                mty,
                                --[[ :: ]]{
                                  --[[ Pwith_type ]]Block.__(0, {
                                      do
                                        txt: s.txt,
                                        loc: loc
                                      end,
                                      d
                                    }),
                                  --[[ [] ]]0
                                }
                              }));
                end end), mk$3(loc, undefined, --[[ Pmty_ident ]]Block.__(0, {param[0]})), l)
        };
end end

type_variables = do
  contents: --[[ Empty ]]0
end;

univars = do
  contents: --[[ [] ]]0
end;

pre_univars = do
  contents: --[[ [] ]]0
end;

used_variables = do
  contents: --[[ Empty ]]0
end;

function reset_type_variables(param) do
  reset_global_level(--[[ () ]]0);
  type_variables.contents = --[[ Empty ]]0;
  return --[[ () ]]0;
end end

function narrow(param) do
  return --[[ tuple ]]{
          increase_global_level(--[[ () ]]0),
          type_variables.contents
        };
end end

function widen(param) do
  global_level.contents = param[0];
  type_variables.contents = param[1];
  return --[[ () ]]0;
end end

function strict_lowercase(c) do
  if (c == --[[ "_" ]]95) then do
    return true;
  end else if (c >= --[[ "a" ]]97) then do
    return c <= --[[ "z" ]]122;
  end else do
    return false;
  end end  end 
end end

function validate_name(s) do
  if (s ~= undefined) then do
    name = s;
    if (name ~= "" and strict_lowercase(Caml_string.get(name, 0))) then do
      return s;
    end else do
      return ;
    end end 
  end
   end 
end end

function transl_type_param(env, styp) do
  loc = styp.ptyp_loc;
  match = styp.ptyp_desc;
  if (typeof match == "number") then do
    ty = new_global_var(validate_name("_"), --[[ () ]]0);
    return do
            ctyp_desc: --[[ Ttyp_any ]]0,
            ctyp_type: ty,
            ctyp_env: env,
            ctyp_loc: loc,
            ctyp_attributes: styp.ptyp_attributes
          end;
  end else if (match.tag) then do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "typetexp.ml",
            379,
            9
          }
        };
  end else do
    name = match[0];
    ty$1;
    try do
      if (name ~= "" and Caml_string.get(name, 0) == --[[ "_" ]]95) then do
        throw {
              __Error$6,
              loc,
              empty,
              --[[ Invalid_variable_name ]]Block.__(13, {"'" .. name})
            };
      end
       end 
      find$2(name, type_variables.contents);
      throw Already_bound;
    end
    catch (exn)do
      if (exn == Caml_builtin_exceptions.not_found) then do
        v = new_global_var(validate_name(name), --[[ () ]]0);
        type_variables.contents = add$5(name, v, type_variables.contents);
        ty$1 = v;
      end else do
        throw exn;
      end end 
    end
    return do
            ctyp_desc: --[[ Ttyp_var ]]Block.__(0, {name}),
            ctyp_type: ty$1,
            ctyp_env: env,
            ctyp_loc: loc,
            ctyp_attributes: styp.ptyp_attributes
          end;
  end end  end 
end end

function new_pre_univar(name, param) do
  v = newvar(validate_name(name), --[[ () ]]0);
  pre_univars.contents = --[[ :: ]]{
    v,
    pre_univars.contents
  };
  return v;
end end

function swap_list(l) do
  if (l) then do
    match = l[1];
    if (match) then do
      return --[[ :: ]]{
              match[0],
              --[[ :: ]]{
                l[0],
                swap_list(match[1])
              }
            };
    end else do
      return l;
    end end 
  end else do
    return l;
  end end 
end end

function transl_type(env, policy, styp) do
  loc = styp.ptyp_loc;
  ctyp = function (ctyp_desc, ctyp_type) do
    return do
            ctyp_desc: ctyp_desc,
            ctyp_type: ctyp_type,
            ctyp_env: env,
            ctyp_loc: loc,
            ctyp_attributes: styp.ptyp_attributes
          end;
  end end;
  match = styp.ptyp_desc;
  if (typeof match == "number") then do
    ty;
    if (policy == --[[ Univars ]]2) then do
      ty = new_pre_univar(undefined, --[[ () ]]0);
    end else do
      if (policy == --[[ Fixed ]]0) then do
        throw {
              __Error$6,
              styp.ptyp_loc,
              env,
              --[[ Unbound_type_variable ]]Block.__(0, {"_"})
            };
      end
       end 
      ty = newvar(validate_name(undefined), --[[ () ]]0);
    end end 
    return ctyp(--[[ Ttyp_any ]]0, ty);
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 0--[[ Ptyp_var ]] then do
          name = match[0];
          if (name ~= "" and Caml_string.get(name, 0) == --[[ "_" ]]95) then do
            throw {
                  __Error$6,
                  styp.ptyp_loc,
                  env,
                  --[[ Invalid_variable_name ]]Block.__(13, {"'" .. name})
                };
          end
           end 
          ty$1;
          try do
            ty$1 = instance(undefined, env, List.assoc(name, univars.contents));
          end
          catch (exn)do
            if (exn == Caml_builtin_exceptions.not_found) then do
              try do
                ty$1 = instance(undefined, env, find$2(name, used_variables.contents)[0]);
              end
              catch (exn$1)do
                if (exn$1 == Caml_builtin_exceptions.not_found) then do
                  v = policy == --[[ Univars ]]2 and new_pre_univar(name, --[[ () ]]0) or newvar(validate_name(name), --[[ () ]]0);
                  used_variables.contents = add$5(name, --[[ tuple ]]{
                        v,
                        styp.ptyp_loc
                      }, used_variables.contents);
                  ty$1 = v;
                end else do
                  throw exn$1;
                end end 
              end
            end else do
              throw exn;
            end end 
          end
          return ctyp(--[[ Ttyp_var ]]Block.__(0, {name}), ty$1);end end end 
       if ___conditional___ = 1--[[ Ptyp_arrow ]] then do
          l = match[0];
          cty1 = transl_type(env, policy, match[1]);
          cty2 = transl_type(env, policy, match[2]);
          ty$2 = newty2(current_level.contents, --[[ Tarrow ]]Block.__(1, {
                  l,
                  cty1.ctyp_type,
                  cty2.ctyp_type,
                  --[[ Cok ]]0
                }));
          return ctyp(--[[ Ttyp_arrow ]]Block.__(1, {
                        l,
                        cty1,
                        cty2
                      }), ty$2);end end end 
       if ___conditional___ = 2--[[ Ptyp_tuple ]] then do
          stl = match[0];
          if (List.length(stl) < 2) then do
            ill_formed_ast(loc, "Tuples must have at least 2 components.");
          end
           end 
          ctys = List.map((function (param) do
                  return transl_type(env, policy, param);
                end end), stl);
          desc = --[[ Ttuple ]]Block.__(2, {List.map((function (ctyp) do
                      return ctyp.ctyp_type;
                    end end), ctys)});
          ty$3 = newty2(current_level.contents, desc);
          return ctyp(--[[ Ttyp_tuple ]]Block.__(2, {ctys}), ty$3);end end end 
       if ___conditional___ = 3--[[ Ptyp_constr ]] then do
          stl$1 = match[1];
          lid = match[0];
          match$1 = find_type(env, styp.ptyp_loc, lid.txt);
          decl = match$1[1];
          path = match$1[0];
          stl$2;
          if (stl$1) then do
            t = stl$1[0];
            stl$2 = typeof t.ptyp_desc == "number" and not (stl$1[1] or decl.type_arity <= 1) and List.map((function (param) do
                      return t;
                    end end), decl.type_params) or stl$1;
          end else do
            stl$2 = stl$1;
          end end 
          if (List.length(stl$2) ~= decl.type_arity) then do
            throw {
                  __Error$6,
                  styp.ptyp_loc,
                  env,
                  --[[ Type_arity_mismatch ]]Block.__(3, {
                      lid.txt,
                      decl.type_arity,
                      List.length(stl$2)
                    })
                };
          end
           end 
          args = List.map((function (param) do
                  return transl_type(env, policy, param);
                end end), stl$2);
          params = instance_list(empty, decl.type_params);
          match$2 = decl.type_manifest;
          unify_param = match$2 ~= undefined and repr(match$2).level ~= 100000000 and unify$2 or unify_var;
          List.iter2((function (param, ty$prime) do
                  try do
                    return Curry._3(unify_param, env, ty$prime, param[1].ctyp_type);
                  end
                  catch (raw_exn)do
                    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn[0] == Unify) then do
                      throw {
                            __Error$6,
                            param[0].ptyp_loc,
                            env,
                            --[[ Type_mismatch ]]Block.__(6, {swap_list(exn[1])})
                          };
                    end
                     end 
                    throw exn;
                  end
                end end), List.combine(stl$2, args), params);
          constr = newconstr(path, List.map((function (ctyp) do
                      return ctyp.ctyp_type;
                    end end), args));
          try do
            enforce_constraints(env, constr);
          end
          catch (raw_exn)do
            exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn$2[0] == Unify) then do
              throw {
                    __Error$6,
                    styp.ptyp_loc,
                    env,
                    --[[ Type_mismatch ]]Block.__(6, {exn$2[1]})
                  };
            end
             end 
            throw exn$2;
          end
          return ctyp(--[[ Ttyp_constr ]]Block.__(3, {
                        path,
                        lid,
                        args
                      }), constr);end end end 
       if ___conditional___ = 4--[[ Ptyp_object ]] then do
          o = match[1];
          fields = List.map((function (param) do
                  return --[[ tuple ]]{
                          param[0],
                          param[1],
                          transl_poly_type(env, policy, param[2])
                        };
                end end), match[0]);
          ty$4 = newobj(transl_fields(loc, env, policy, --[[ [] ]]0, o, fields));
          return ctyp(--[[ Ttyp_object ]]Block.__(4, {
                        fields,
                        o
                      }), ty$4);end end end 
       if ___conditional___ = 5--[[ Ptyp_class ]] then do
          stl$3 = match[1];
          lid$1 = match[0];
          match$3;
          try do
            match$4 = lookup_type$1(lid$1.txt, env);
            decl$1 = match$4[1];
            check = function (_decl) do
              while(true) do
                decl = _decl;
                match = decl.type_manifest;
                if (match ~= undefined) then do
                  match$1 = repr(match).desc;
                  if (typeof match$1 == "number") then do
                    throw Caml_builtin_exceptions.not_found;
                  end else do
                    local ___conditional___=(match$1.tag | 0);
                    do
                       if ___conditional___ = 3--[[ Tconstr ]] then do
                          _decl = find_type_full(match$1[0], env)[0];
                          continue ;end end end 
                       if ___conditional___ = 8--[[ Tvariant ]] then do
                          if (static_row(match$1[0])) then do
                            return --[[ () ]]0;
                          end else do
                            throw Caml_builtin_exceptions.not_found;
                          end end end end end 
                       do
                      else do
                        throw Caml_builtin_exceptions.not_found;
                        end end
                        
                    end
                  end end 
                end else do
                  throw Caml_builtin_exceptions.not_found;
                end end 
              end;
            end end;
            check(decl$1);
            prerr_warning(styp.ptyp_loc, --[[ Deprecated ]]Block.__(0, {"old syntax for polymorphic variant type"}));
            match$3 = --[[ tuple ]]{
              match$4[0],
              decl$1,
              true
            };
          end
          catch (exn$3)do
            if (exn$3 == Caml_builtin_exceptions.not_found) then do
              try do
                match$5 = lid$1.txt;
                lid2;
                local ___conditional___=(match$5.tag | 0);
                do
                   if ___conditional___ = 0--[[ Lident ]] then do
                      lid2 = --[[ Lident ]]Block.__(0, {"#" .. match$5[0]});end else 
                   if ___conditional___ = 1--[[ Ldot ]] then do
                      lid2 = --[[ Ldot ]]Block.__(1, {
                          match$5[0],
                          "#" .. match$5[1]
                        });end else 
                   if ___conditional___ = 2--[[ Lapply ]] then do
                      lid2 = fatal_error("Typetexp.transl_type");end else 
                   do end end end end
                  
                end
                match$6 = lookup_type$1(lid2, env);
                match$3 = --[[ tuple ]]{
                  match$6[0],
                  match$6[1],
                  false
                };
              end
              catch (exn$4)do
                if (exn$4 == Caml_builtin_exceptions.not_found) then do
                  find_class$1(env, styp.ptyp_loc, lid$1.txt);
                  throw {
                        Caml_builtin_exceptions.assert_failure,
                        --[[ tuple ]]{
                          "typetexp.ml",
                          505,
                          57
                        }
                      };
                end else do
                  throw exn$4;
                end end 
              end
            end else do
              throw exn$3;
            end end 
          end
          decl$2 = match$3[1];
          path$1 = match$3[0];
          if (List.length(stl$3) ~= decl$2.type_arity) then do
            throw {
                  __Error$6,
                  styp.ptyp_loc,
                  env,
                  --[[ Type_arity_mismatch ]]Block.__(3, {
                      lid$1.txt,
                      decl$2.type_arity,
                      List.length(stl$3)
                    })
                };
          end
           end 
          args$1 = List.map((function (param) do
                  return transl_type(env, policy, param);
                end end), stl$3);
          params$1 = instance_list(empty, decl$2.type_params);
          List.iter2((function (param, ty$prime) do
                  try do
                    return unify_var(env, ty$prime, param[1].ctyp_type);
                  end
                  catch (raw_exn)do
                    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn[0] == Unify) then do
                      throw {
                            __Error$6,
                            param[0].ptyp_loc,
                            env,
                            --[[ Type_mismatch ]]Block.__(6, {swap_list(exn[1])})
                          };
                    end
                     end 
                    throw exn;
                  end
                end end), List.combine(stl$3, args$1), params$1);
          ty_args = List.map((function (ctyp) do
                  return ctyp.ctyp_type;
                end end), args$1);
          ty$5;
          try do
            ty$5 = expand_head(env, newconstr(path$1, ty_args));
          end
          catch (raw_exn$1)do
            exn$5 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
            if (exn$5[0] == Unify) then do
              throw {
                    __Error$6,
                    styp.ptyp_loc,
                    env,
                    --[[ Type_mismatch ]]Block.__(6, {exn$5[1]})
                  };
            end
             end 
            throw exn$5;
          end
          match$7 = ty$5.desc;
          ty$6;
          if (typeof match$7 == "number") then do
            throw {
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "typetexp.ml",
                    553,
                    10
                  }
                };
          end else do
            local ___conditional___=(match$7.tag | 0);
            do
               if ___conditional___ = 4--[[ Tobject ]] then do
                  match$8 = flatten_fields(match$7[0]);
                  if (policy == --[[ Univars ]]2) then do
                    pre_univars.contents = --[[ :: ]]{
                      match$8[1],
                      pre_univars.contents
                    };
                  end
                   end 
                  ty$6 = ty$5;end else 
               if ___conditional___ = 8--[[ Tvariant ]] then do
                  row = row_repr_aux(--[[ [] ]]0, match$7[0]);
                  fields$1 = List.map((function (param) do
                          f = param[1];
                          match = row_field_repr_aux(--[[ [] ]]0, f);
                          tmp;
                          if (typeof match == "number" or match.tag) then do
                            tmp = f;
                          end else do
                            match$1 = match[0];
                            tmp = match$1 ~= undefined and --[[ Reither ]]Block.__(1, {
                                  false,
                                  --[[ :: ]]{
                                    match$1,
                                    --[[ [] ]]0
                                  },
                                  false,
                                  do
                                    contents: undefined
                                  end
                                }) or --[[ Reither ]]Block.__(1, {
                                  true,
                                  --[[ [] ]]0,
                                  false,
                                  do
                                    contents: undefined
                                  end
                                });
                          end end 
                          return --[[ tuple ]]{
                                  param[0],
                                  tmp
                                };
                        end end), row.row_fields);
                  row_row_more = newvar(validate_name(undefined), --[[ () ]]0);
                  row_row_name = --[[ tuple ]]{
                    path$1,
                    ty_args
                  };
                  row$1 = do
                    row_fields: fields$1,
                    row_more: row_row_more,
                    row_bound: --[[ () ]]0,
                    row_closed: true,
                    row_fixed: false,
                    row_name: row_row_name
                  end;
                  __static = static_row(row$1);
                  row$2 = __static and (do
                        row_fields: fields$1,
                        row_more: newty2(current_level.contents, --[[ Tnil ]]0),
                        row_bound: --[[ () ]]0,
                        row_closed: true,
                        row_fixed: false,
                        row_name: row_row_name
                      end) or (
                      policy ~= --[[ Univars ]]2 and row$1 or (do
                            row_fields: fields$1,
                            row_more: new_pre_univar(undefined, --[[ () ]]0),
                            row_bound: --[[ () ]]0,
                            row_closed: true,
                            row_fixed: false,
                            row_name: row_row_name
                          end)
                    );
                  ty$6 = newty2(current_level.contents, --[[ Tvariant ]]Block.__(8, {row$2}));end else 
               do end end end
              else do
                throw {
                      Caml_builtin_exceptions.assert_failure,
                      --[[ tuple ]]{
                        "typetexp.ml",
                        553,
                        10
                      }
                    };
                end end
                
            end
          end end 
          return ctyp(--[[ Ttyp_class ]]Block.__(5, {
                        path$1,
                        lid$1,
                        args$1
                      }), ty$6);end end end 
       if ___conditional___ = 6--[[ Ptyp_alias ]] then do
          alias = match[1];
          st = match[0];
          cty;
          try do
            t$1;
            try do
              t$1 = List.assoc(alias, univars.contents);
            end
            catch (exn$6)do
              if (exn$6 == Caml_builtin_exceptions.not_found) then do
                t$1 = instance(undefined, env, find$2(alias, used_variables.contents)[0]);
              end else do
                throw exn$6;
              end end 
            end
            ty$7 = transl_type(env, policy, st);
            try do
              unify_var(env, t$1, ty$7.ctyp_type);
            end
            catch (raw_exn$2)do
              exn$7 = Caml_js_exceptions.internalToOCamlException(raw_exn$2);
              if (exn$7[0] == Unify) then do
                trace = swap_list(exn$7[1]);
                throw {
                      __Error$6,
                      styp.ptyp_loc,
                      env,
                      --[[ Alias_type_mismatch ]]Block.__(7, {trace})
                    };
              end else do
                throw exn$7;
              end end 
            end
            cty = ty$7;
          end
          catch (exn$8)do
            if (exn$8 == Caml_builtin_exceptions.not_found) then do
              if (principal.contents) then do
                begin_def(--[[ () ]]0);
              end
               end 
              t$2 = newvar(validate_name(undefined), --[[ () ]]0);
              used_variables.contents = add$5(alias, --[[ tuple ]]{
                    t$2,
                    styp.ptyp_loc
                  }, used_variables.contents);
              ty$8 = transl_type(env, policy, st);
              try do
                unify_var(env, t$2, ty$8.ctyp_type);
              end
              catch (raw_exn$3)do
                exn$9 = Caml_js_exceptions.internalToOCamlException(raw_exn$3);
                if (exn$9[0] == Unify) then do
                  trace$1 = swap_list(exn$9[1]);
                  throw {
                        __Error$6,
                        styp.ptyp_loc,
                        env,
                        --[[ Alias_type_mismatch ]]Block.__(7, {trace$1})
                      };
                end else do
                  throw exn$9;
                end end 
              end
              if (principal.contents) then do
                end_def(--[[ () ]]0);
                generalize_structure$1(current_level.contents, t$2);
              end
               end 
              t$3 = instance(undefined, env, t$2);
              px = proxy(t$3);
              match$9 = px.desc;
              if (typeof match$9 ~= "number") then do
                local ___conditional___=(match$9.tag | 0);
                do
                   if ___conditional___ = 0--[[ Tvar ]] then do
                      if (match$9[0] == undefined) then do
                        log_type(px);
                        px.desc = --[[ Tvar ]]Block.__(0, {alias});
                      end
                       end end else 
                   if ___conditional___ = 9--[[ Tunivar ]] then do
                      if (match$9[0] == undefined) then do
                        log_type(px);
                        px.desc = --[[ Tunivar ]]Block.__(9, {alias});
                      end
                       end end else 
                   do end end end
                  else do
                    end end
                    
                end
              end
               end 
              cty = do
                ctyp_desc: ty$8.ctyp_desc,
                ctyp_type: t$3,
                ctyp_env: ty$8.ctyp_env,
                ctyp_loc: ty$8.ctyp_loc,
                ctyp_attributes: ty$8.ctyp_attributes
              end;
            end else do
              throw exn$8;
            end end 
          end
          return ctyp(--[[ Ttyp_alias ]]Block.__(6, {
                        cty,
                        alias
                      }), cty.ctyp_type);end end end 
       if ___conditional___ = 7--[[ Ptyp_variant ]] then do
          present = match[2];
          closed = match[1];
          name$1 = do
            contents: undefined
          end;
          mkfield = function (l, f) do
            desc = --[[ Tvariant ]]Block.__(8, {do
                  row_fields: --[[ :: ]]{
                    --[[ tuple ]]{
                      l,
                      f
                    },
                    --[[ [] ]]0
                  },
                  row_more: newvar(validate_name(undefined), --[[ () ]]0),
                  row_bound: --[[ () ]]0,
                  row_closed: true,
                  row_fixed: false,
                  row_name: undefined
                end});
            return newty2(current_level.contents, desc);
          end end;
          hfields = Hashtbl.create(undefined, 17);
          add_typed_field = function (loc, l, f) do
            h = hash_variant(l);
            try do
              match = Hashtbl.find(hfields, h);
              l$prime = match[0];
              if (l ~= l$prime) then do
                throw {
                      __Error$6,
                      styp.ptyp_loc,
                      env,
                      --[[ Variant_tags ]]Block.__(12, {
                          l,
                          l$prime
                        })
                    };
              end
               end 
              ty = mkfield(l, f);
              ty$prime = mkfield(l, match[1]);
              if (equal$4(env, false, --[[ :: ]]{
                      ty,
                      --[[ [] ]]0
                    }, --[[ :: ]]{
                      ty$prime,
                      --[[ [] ]]0
                    })) then do
                return --[[ () ]]0;
              end else do
                try do
                  return unify$2(env, ty, ty$prime);
                end
                catch (raw_exn)do
                  exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                  if (exn[0] == Unify) then do
                    throw {
                          __Error$6,
                          loc,
                          env,
                          --[[ Constructor_mismatch ]]Block.__(10, {
                              ty,
                              ty$prime
                            })
                        };
                  end
                   end 
                  throw exn;
                end
              end end 
            end
            catch (exn$1)do
              if (exn$1 == Caml_builtin_exceptions.not_found) then do
                return Hashtbl.add(hfields, h, --[[ tuple ]]{
                            l,
                            f
                          });
              end else do
                throw exn$1;
              end end 
            end
          end end;
          add_field = function (param) do
            if (param.tag) then do
              sty = param[0];
              cty = transl_type(env, policy, sty);
              ty = cty.ctyp_type;
              match = repr(cty.ctyp_type);
              match$1 = match.desc;
              nm;
              nm = typeof match$1 == "number" or match$1.tag ~= --[[ Tconstr ]]3 and undefined or --[[ tuple ]]{
                  match$1[0],
                  match$1[1]
                };
              try do
                Hashtbl.iter((function (param, param$1) do
                        throw Pervasives.Exit;
                      end end), hfields);
                name$1.contents = nm;
              end
              catch (exn)do
                if (exn == Pervasives.Exit) then do
                  name$1.contents = undefined;
                end else do
                  throw exn;
                end end 
              end
              match$2 = expand_head(env, cty.ctyp_type);
              match$3 = match$2.desc;
              fl;
              exit = 0;
              if (typeof match$3 == "number") then do
                exit = 1;
              end else do
                local ___conditional___=(match$3.tag | 0);
                do
                   if ___conditional___ = 0--[[ Tvar ]] then do
                      if (nm ~= undefined) then do
                        throw {
                              __Error$6,
                              sty.ptyp_loc,
                              env,
                              --[[ Unbound_type_constructor_2 ]]Block.__(2, {nm[0]})
                            };
                      end
                       end 
                      exit = 1;end else 
                   if ___conditional___ = 8--[[ Tvariant ]] then do
                      row = match$3[0];
                      if (static_row(row)) then do
                        fl = row_repr_aux(--[[ [] ]]0, row).row_fields;
                      end else do
                        exit = 1;
                      end end end else 
                   do end end end
                  else do
                    exit = 1;
                    end end
                    
                end
              end end 
              if (exit == 1) then do
                throw {
                      __Error$6,
                      sty.ptyp_loc,
                      env,
                      --[[ Not_a_variant ]]Block.__(11, {ty})
                    };
              end
               end 
              List.iter((function (param) do
                      f = param[1];
                      l = param[0];
                      f$1;
                      if (present ~= undefined and not List.mem(l, present)) then do
                        if (typeof f == "number") then do
                          throw {
                                Caml_builtin_exceptions.assert_failure,
                                --[[ tuple ]]{
                                  "typetexp.ml",
                                  666,
                                  24
                                }
                              };
                        end else if (f.tag) then do
                          throw {
                                Caml_builtin_exceptions.assert_failure,
                                --[[ tuple ]]{
                                  "typetexp.ml",
                                  666,
                                  24
                                }
                              };
                        end else do
                          match = f[0];
                          f$1 = match ~= undefined and --[[ Reither ]]Block.__(1, {
                                false,
                                --[[ :: ]]{
                                  match,
                                  --[[ [] ]]0
                                },
                                false,
                                do
                                  contents: undefined
                                end
                              }) or --[[ Reither ]]Block.__(1, {
                                true,
                                --[[ [] ]]0,
                                false,
                                do
                                  contents: undefined
                                end
                              });
                        end end  end 
                      end else do
                        f$1 = f;
                      end end 
                      return add_typed_field(sty.ptyp_loc, l, f$1);
                    end end), fl);
              return --[[ Tinherit ]]Block.__(1, {cty});
            end else do
              stl = param[3];
              c = param[2];
              l = param[0];
              name$1.contents = undefined;
              tl = List.map((function (param) do
                      return transl_type(env, policy, param);
                    end end), stl);
              f;
              exit$1 = 0;
              if (present ~= undefined and not List.mem(l, present)) then do
                ty_tl = List.map((function (cty) do
                        return cty.ctyp_type;
                      end end), tl);
                f = --[[ Reither ]]Block.__(1, {
                    c,
                    ty_tl,
                    false,
                    do
                      contents: undefined
                    end
                  });
              end else do
                exit$1 = 1;
              end end 
              if (exit$1 == 1) then do
                if (List.length(stl) > 1 or c and stl ~= --[[ [] ]]0) then do
                  throw {
                        __Error$6,
                        styp.ptyp_loc,
                        env,
                        --[[ Present_has_conjunction ]]Block.__(8, {l})
                      };
                end
                 end 
                f = tl and --[[ Rpresent ]]Block.__(0, {tl[0].ctyp_type}) or --[[ Rpresent ]]Block.__(0, {undefined});
              end
               end 
              add_typed_field(styp.ptyp_loc, l, f);
              return --[[ Ttag ]]Block.__(0, {
                        l,
                        param[1],
                        c,
                        tl
                      });
            end end 
          end end;
          tfields = List.map(add_field, match[0]);
          fields$2 = Hashtbl.fold((function (param, p, l) do
                  return --[[ :: ]]{
                          p,
                          l
                        };
                end end), hfields, --[[ [] ]]0);
          if (present ~= undefined) then do
            List.iter((function (l) do
                    if (List.mem_assoc(l, fields$2)) then do
                      return 0;
                    end else do
                      throw {
                            __Error$6,
                            styp.ptyp_loc,
                            env,
                            --[[ Present_has_no_type ]]Block.__(9, {l})
                          };
                    end end 
                  end end), present);
          end
           end 
          row_row_fields = List.rev(fields$2);
          row_row_more$1 = newvar(validate_name(undefined), --[[ () ]]0);
          row_row_closed = closed == --[[ Closed ]]0;
          row_row_name$1 = name$1.contents;
          row$3 = do
            row_fields: row_row_fields,
            row_more: row_row_more$1,
            row_bound: --[[ () ]]0,
            row_closed: row_row_closed,
            row_fixed: false,
            row_name: row_row_name$1
          end;
          __static$1 = static_row(row$3);
          row$4 = __static$1 and (do
                row_fields: row_row_fields,
                row_more: newty2(current_level.contents, --[[ Tnil ]]0),
                row_bound: --[[ () ]]0,
                row_closed: row_row_closed,
                row_fixed: false,
                row_name: row_row_name$1
              end) or (
              policy ~= --[[ Univars ]]2 and row$3 or (do
                    row_fields: row_row_fields,
                    row_more: new_pre_univar(undefined, --[[ () ]]0),
                    row_bound: --[[ () ]]0,
                    row_closed: row_row_closed,
                    row_fixed: false,
                    row_name: row_row_name$1
                  end)
            );
          ty$9 = newty2(current_level.contents, --[[ Tvariant ]]Block.__(8, {row$4}));
          return ctyp(--[[ Ttyp_variant ]]Block.__(7, {
                        tfields,
                        closed,
                        present
                      }), ty$9);end end end 
       if ___conditional___ = 8--[[ Ptyp_poly ]] then do
          vars = match[0];
          begin_def(--[[ () ]]0);
          new_univars = List.map((function (name) do
                  return --[[ tuple ]]{
                          name,
                          newvar(validate_name(name), --[[ () ]]0)
                        };
                end end), vars);
          old_univars = univars.contents;
          univars.contents = Pervasives.$at(new_univars, univars.contents);
          cty$1 = transl_type(env, policy, match[1]);
          ty$10 = cty$1.ctyp_type;
          univars.contents = old_univars;
          end_def(--[[ () ]]0);
          iter_generalize$1(do
                contents: --[[ [] ]]0
              end, ty$10);
          ty_list = List.fold_left((function (tyl, param) do
                  v = proxy(param[1]);
                  if (deep_occur(v, ty$10)) then do
                    match = v.desc;
                    if (typeof match ~= "number" and not match.tag and v.level == 100000000) then do
                      v.desc = --[[ Tunivar ]]Block.__(9, {match[0]});
                      return --[[ :: ]]{
                              v,
                              tyl
                            };
                    end
                     end 
                    throw {
                          __Error$6,
                          styp.ptyp_loc,
                          env,
                          --[[ Cannot_quantify ]]Block.__(14, {
                              param[0],
                              v
                            })
                        };
                  end else do
                    return tyl;
                  end end 
                end end), --[[ [] ]]0, new_univars);
          ty$prime = newty2(100000000, --[[ Tpoly ]]Block.__(10, {
                  ty$10,
                  List.rev(ty_list)
                }));
          unify_var(env, newvar(validate_name(undefined), --[[ () ]]0), ty$prime);
          return ctyp(--[[ Ttyp_poly ]]Block.__(8, {
                        vars,
                        cty$1
                      }), ty$prime);end end end 
       if ___conditional___ = 9--[[ Ptyp_package ]] then do
          match$10 = match[0];
          p = match$10[0];
          match$11 = create_package_mty(true, styp.ptyp_loc, env, --[[ tuple ]]{
                p,
                match$10[1]
              });
          l$1 = match$11[0];
          z = narrow(--[[ () ]]0);
          mty = Curry._2(transl_modtype.contents, env, match$11[1]);
          widen(z);
          ptys = List.map((function (param) do
                  return --[[ tuple ]]{
                          param[0],
                          transl_type(env, policy, param[1])
                        };
                end end), l$1);
          path$2 = Curry._3(transl_modtype_longident.contents, styp.ptyp_loc, env, p.txt);
          desc_001 = List.map((function (param) do
                  return param[0].txt;
                end end), l$1);
          desc_002 = List.map((function (param) do
                  return param[1].ctyp_type;
                end end), ptys);
          desc$1 = --[[ Tpackage ]]Block.__(11, {
              path$2,
              desc_001,
              desc_002
            });
          ty$11 = newty2(current_level.contents, desc$1);
          return ctyp(--[[ Ttyp_package ]]Block.__(9, {do
                          pack_path: path$2,
                          pack_fields: ptys,
                          pack_type: mty.mty_type,
                          pack_txt: p
                        end}), ty$11);end end end 
       if ___conditional___ = 10--[[ Ptyp_extension ]] then do
          throw {
                Error_forward,
                error_of_extension(match[0])
              };end end end 
       do
      
    end
  end end 
end end

function transl_poly_type(env, policy, t) do
  return transl_type(env, policy, force_poly(t));
end end

function transl_fields(loc, env, policy, seen, o, param) do
  if (param) then do
    match = param[0];
    s = match[0];
    if (List.mem(s, seen)) then do
      throw {
            __Error$6,
            loc,
            env,
            --[[ Repeated_method_label ]]Block.__(16, {s})
          };
    end
     end 
    ty2 = transl_fields(loc, env, policy, --[[ :: ]]{
          s,
          seen
        }, o, param[1]);
    return newty2(current_level.contents, --[[ Tfield ]]Block.__(5, {
                  s,
                  --[[ Fpresent ]]0,
                  match[2].ctyp_type,
                  ty2
                }));
  end else if (o) then do
    if (policy >= 2) then do
      return new_pre_univar(undefined, --[[ () ]]0);
    end else do
      return newvar(validate_name(undefined), --[[ () ]]0);
    end end 
  end else do
    return newty2(current_level.contents, --[[ Tnil ]]0);
  end end  end 
end end

function make_fixed_univars(ty) do
  ty$1 = repr(ty);
  if (ty$1.level >= 0) then do
    mark_type_node(ty$1);
    match = ty$1.desc;
    if (typeof match == "number" or match.tag ~= --[[ Tvariant ]]8) then do
      return iter_type_expr(make_fixed_univars, ty$1);
    end else do
      row = row_repr_aux(--[[ [] ]]0, match[0]);
      if (is_Tunivar(row_more(row))) then do
        ty$1.desc = --[[ Tvariant ]]Block.__(8, {do
              row_fields: List.map((function (p) do
                      match = row_field_repr_aux(--[[ [] ]]0, p[1]);
                      if (typeof match == "number" or not match.tag) then do
                        return p;
                      end else do
                        return --[[ tuple ]]{
                                p[0],
                                --[[ Reither ]]Block.__(1, {
                                    match[0],
                                    match[1],
                                    true,
                                    match[3]
                                  })
                              };
                      end end 
                    end end), row.row_fields),
              row_more: row.row_more,
              row_bound: row.row_bound,
              row_closed: row.row_closed,
              row_fixed: true,
              row_name: row.row_name
            end});
      end
       end 
      return iter_row(make_fixed_univars, row);
    end end 
  end else do
    return 0;
  end end 
end end

function globalize_used_variables(env, fixed) do
  r = do
    contents: --[[ [] ]]0
  end;
  iter$2((function (name, param) do
          loc = param[1];
          ty = param[0];
          v = new_global_var(validate_name(undefined), --[[ () ]]0);
          snap = snapshot(--[[ () ]]0);
          tmp;
          try do
            unify$2(env, v, ty);
            tmp = true;
          end
          catch (exn)do
            backtrack(snap);
            tmp = false;
          end
          if (tmp) then do
            try do
              r.contents = --[[ :: ]]{
                --[[ tuple ]]{
                  loc,
                  v,
                  find$2(name, type_variables.contents)
                },
                r.contents
              };
              return --[[ () ]]0;
            end
            catch (exn$1)do
              if (exn$1 == Caml_builtin_exceptions.not_found) then do
                if (fixed and is_Tvar(repr(ty))) then do
                  throw {
                        __Error$6,
                        loc,
                        env,
                        --[[ Unbound_type_variable ]]Block.__(0, {"'" .. name})
                      };
                end
                 end 
                v2 = new_global_var(validate_name(undefined), --[[ () ]]0);
                r.contents = --[[ :: ]]{
                  --[[ tuple ]]{
                    loc,
                    v,
                    v2
                  },
                  r.contents
                };
                type_variables.contents = add$5(name, v2, type_variables.contents);
                return --[[ () ]]0;
              end else do
                throw exn$1;
              end end 
            end
          end else do
            return 0;
          end end 
        end end), used_variables.contents);
  used_variables.contents = --[[ Empty ]]0;
  return (function (param) do
      return List.iter((function (param) do
                    try do
                      return unify$2(env, param[1], param[2]);
                    end
                    catch (raw_exn)do
                      exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                      if (exn[0] == Unify) then do
                        throw {
                              __Error$6,
                              param[0],
                              env,
                              --[[ Type_mismatch ]]Block.__(6, {exn[1]})
                            };
                      end
                       end 
                      throw exn;
                    end
                  end end), r.contents);
    end end);
end end

function transl_simple_type(env, fixed, styp) do
  univars.contents = --[[ [] ]]0;
  used_variables.contents = --[[ Empty ]]0;
  typ = transl_type(env, fixed and --[[ Fixed ]]0 or --[[ Extensible ]]1, styp);
  globalize_used_variables(env, fixed)(--[[ () ]]0);
  ty = typ.ctyp_type;
  make_fixed_univars(ty);
  unmark_type(ty);
  return typ;
end end

function transl_simple_type_univars(env, styp) do
  univars.contents = --[[ [] ]]0;
  used_variables.contents = --[[ Empty ]]0;
  pre_univars.contents = --[[ [] ]]0;
  begin_def(--[[ () ]]0);
  typ = transl_type(env, --[[ Univars ]]2, styp);
  new_variables = used_variables.contents;
  used_variables.contents = --[[ Empty ]]0;
  iter$2((function (name, p) do
          if (mem$4(name, type_variables.contents)) then do
            used_variables.contents = add$5(name, p, used_variables.contents);
            return --[[ () ]]0;
          end else do
            return 0;
          end end 
        end end), new_variables);
  globalize_used_variables(env, false)(--[[ () ]]0);
  end_def(--[[ () ]]0);
  iter_generalize$1(do
        contents: --[[ [] ]]0
      end, typ.ctyp_type);
  univs = List.fold_left((function (acc, v) do
          v$1 = repr(v);
          match = v$1.desc;
          if (typeof match == "number" or match.tag or v$1.level ~= 100000000) then do
            return acc;
          end else do
            v$1.desc = --[[ Tunivar ]]Block.__(9, {match[0]});
            return --[[ :: ]]{
                    v$1,
                    acc
                  };
          end end 
        end end), --[[ [] ]]0, pre_univars.contents);
  ty = typ.ctyp_type;
  make_fixed_univars(ty);
  unmark_type(ty);
  return do
          ctyp_desc: typ.ctyp_desc,
          ctyp_type: instance(undefined, env, newty2(100000000, --[[ Tpoly ]]Block.__(10, {
                      typ.ctyp_type,
                      univs
                    }))),
          ctyp_env: typ.ctyp_env,
          ctyp_loc: typ.ctyp_loc,
          ctyp_attributes: typ.ctyp_attributes
        end;
end end

function transl_simple_type_delayed(env, styp) do
  univars.contents = --[[ [] ]]0;
  used_variables.contents = --[[ Empty ]]0;
  typ = transl_type(env, --[[ Extensible ]]1, styp);
  ty = typ.ctyp_type;
  make_fixed_univars(ty);
  unmark_type(ty);
  return --[[ tuple ]]{
          typ,
          globalize_used_variables(env, false)
        };
end end

function transl_type_scheme(env, styp) do
  reset_type_variables(--[[ () ]]0);
  begin_def(--[[ () ]]0);
  typ = transl_simple_type(env, false, styp);
  end_def(--[[ () ]]0);
  iter_generalize$1(do
        contents: --[[ [] ]]0
      end, typ.ctyp_type);
  return typ;
end end

function spellcheck(ppf, fold, env, lid) do
  match = #last$1(lid);
  switcher = match - 1 | 0;
  cutoff = switcher > 3 or switcher < 0 and (
      switcher == 5 or switcher == 4 and 2 or 3
    ) or (
      switcher >= 2 and 1 or 0
    );
  compare = function (target, head, acc) do
    best_dist = acc[1];
    best_choice = acc[0];
    match = edit_distance(target, head, cutoff);
    if (match ~= undefined) then do
      dist = match;
      choice = dist < best_dist and --[[ :: ]]{
          head,
          --[[ [] ]]0
        } or (
          dist == best_dist and --[[ :: ]]{
              head,
              best_choice
            } or best_choice
        );
      return --[[ tuple ]]{
              choice,
              dist < best_dist and dist or best_dist
            };
    end else do
      return --[[ tuple ]]{
              best_choice,
              best_dist
            };
    end end 
  end end;
  init = --[[ tuple ]]{
    --[[ [] ]]0,
    Pervasives.max_int
  };
  handle = function (param) do
    match = List.rev(param[0]);
    if (match) then do
      rev_rest = match[1];
      return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Formatting_lit ]]Block.__(17, {
                          --[[ Force_newline ]]3,
                          --[[ String_literal ]]Block.__(11, {
                              "Hint: Did you mean ",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ Char_literal ]]Block.__(12, {
                                              --[[ "?" ]]63,
                                              --[[ End_of_format ]]0
                                            })
                                        })
                                    })
                                })
                            })
                        }),
                      "@\nHint: Did you mean %s%s%s?"
                    }), __String.concat(", ", List.rev(rev_rest)), rev_rest == --[[ [] ]]0 and "" or " or ", match[0]);
    end else do
      return --[[ () ]]0;
    end end 
  end end;
  Format.fprintf(ppf, --[[ Format ]]{
        --[[ Formatting_lit ]]Block.__(17, {
            --[[ FFlush ]]2,
            --[[ End_of_format ]]0
          }),
        "@?"
      });
  local ___conditional___=(lid.tag | 0);
  do
     if ___conditional___ = 0--[[ Lident ]] then do
        s = lid[0];
        return handle(Curry._4(fold, (function (param, param$1) do
                          return compare(s, param, param$1);
                        end end), undefined, env, init));end end end 
     if ___conditional___ = 1--[[ Ldot ]] then do
        s$1 = lid[1];
        return handle(Curry._4(fold, (function (param, param$1) do
                          return compare(s$1, param, param$1);
                        end end), lid[0], env, init));end end end 
     if ___conditional___ = 2--[[ Lapply ]] then do
        return --[[ () ]]0;end end end 
     do
    
  end
end end

function spellcheck_simple(ppf, fold, extr) do
  return (function (param, param$1) do
      return spellcheck(ppf, (function (f) do
                    return Curry._1(fold, (function (decl, x) do
                                  return Curry._2(f, Curry._1(extr, decl), x);
                                end end));
                  end end), param, param$1);
    end end);
end end

function spellcheck$1(ppf, fold) do
  return (function (param, param$1) do
      return spellcheck(ppf, (function (f) do
                    return Curry._1(fold, (function (s, param, param$1, x) do
                                  return Curry._2(f, s, x);
                                end end));
                  end end), param, param$1);
    end end);
end end

register_error_of_exn((function (param) do
        if (param[0] == __Error$6) then do
          env = param[2];
          return error_of_printer(param[1], (function (param, param$1) do
                        env$1 = env;
                        ppf = param;
                        param$2 = param$1;
                        if (typeof param$2 == "number") then do
                          if (param$2 == --[[ Recursive_type ]]0) then do
                            return Format.fprintf(ppf, --[[ Format ]]{
                                        --[[ String_literal ]]Block.__(11, {
                                            "This type is recursive",
                                            --[[ End_of_format ]]0
                                          }),
                                        "This type is recursive"
                                      });
                          end else do
                            return Format.fprintf(ppf, --[[ Format ]]{
                                        --[[ String_literal ]]Block.__(11, {
                                            "Illegal recursive module reference",
                                            --[[ End_of_format ]]0
                                          }),
                                        "Illegal recursive module reference"
                                      });
                          end end 
                        end else do
                          local ___conditional___=(param$2.tag | 0);
                          do
                             if ___conditional___ = 0--[[ Unbound_type_variable ]] then do
                                return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ String_literal ]]Block.__(11, {
                                                    "Unbound type parameter ",
                                                    --[[ String ]]Block.__(2, {
                                                        --[[ No_padding ]]0,
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Flush_newline ]]4,
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })
                                                  }),
                                                "Unbound type parameter %s@."
                                              }), param$2[0]);end end end 
                             if ___conditional___ = 1--[[ Unbound_type_constructor ]] then do
                                lid = param$2[0];
                                Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "Unbound type constructor ",
                                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                            }),
                                          "Unbound type constructor %a"
                                        }), longident, lid);
                                return spellcheck$1(ppf, fold_types)(env$1, lid);end end end 
                             if ___conditional___ = 2--[[ Unbound_type_constructor_2 ]] then do
                                return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ String_literal ]]Block.__(11, {
                                                    "The type constructor",
                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                        --[[ Break ]]Block.__(0, {
                                                            "@ ",
                                                            1,
                                                            0
                                                          }),
                                                        --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                --[[ Break ]]Block.__(0, {
                                                                    "@ ",
                                                                    1,
                                                                    0
                                                                  }),
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "is not yet completely defined",
                                                                    --[[ End_of_format ]]0
                                                                  })
                                                              })})
                                                      })
                                                  }),
                                                "The type constructor@ %a@ is not yet completely defined"
                                              }), path, param$2[0]);end end end 
                             if ___conditional___ = 3--[[ Type_arity_mismatch ]] then do
                                return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ Formatting_gen ]]Block.__(18, {
                                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                          --[[ End_of_format ]]0,
                                                          ""
                                                        }}),
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "The type constructor ",
                                                        --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                --[[ Break ]]Block.__(0, {
                                                                    "@ ",
                                                                    1,
                                                                    0
                                                                  }),
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "expects ",
                                                                    --[[ Int ]]Block.__(4, {
                                                                        --[[ Int_i ]]3,
                                                                        --[[ No_padding ]]0,
                                                                        --[[ No_precision ]]0,
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            " argument(s),",
                                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                                --[[ Break ]]Block.__(0, {
                                                                                    "@ ",
                                                                                    1,
                                                                                    0
                                                                                  }),
                                                                                --[[ String_literal ]]Block.__(11, {
                                                                                    "but is here applied to ",
                                                                                    --[[ Int ]]Block.__(4, {
                                                                                        --[[ Int_i ]]3,
                                                                                        --[[ No_padding ]]0,
                                                                                        --[[ No_precision ]]0,
                                                                                        --[[ String_literal ]]Block.__(11, {
                                                                                            " argument(s)",
                                                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                                                --[[ Close_box ]]0,
                                                                                                --[[ End_of_format ]]0
                                                                                              })
                                                                                          })
                                                                                      })
                                                                                  })
                                                                              })
                                                                          })
                                                                      })
                                                                  })
                                                              })})
                                                      })
                                                  }),
                                                "@[The type constructor %a@ expects %i argument(s),@ but is here applied to %i argument(s)@]"
                                              }), longident, param$2[0], param$2[1], param$2[2]);end end end 
                             if ___conditional___ = 4--[[ Bound_type_variable ]] then do
                                return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ String_literal ]]Block.__(11, {
                                                    "Already bound type parameter '",
                                                    --[[ String ]]Block.__(2, {
                                                        --[[ No_padding ]]0,
                                                        --[[ End_of_format ]]0
                                                      })
                                                  }),
                                                "Already bound type parameter '%s"
                                              }), param$2[0]);end end end 
                             if ___conditional___ = 5--[[ Unbound_row_variable ]] then do
                                return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ String_literal ]]Block.__(11, {
                                                    "Unbound row variable in #",
                                                    --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                  }),
                                                "Unbound row variable in #%a"
                                              }), longident, param$2[0]);end end end 
                             if ___conditional___ = 6--[[ Type_mismatch ]] then do
                                return report_unification_error(ppf, empty, undefined, param$2[0], (function (ppf) do
                                              return Format.fprintf(ppf, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "This type",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "This type"
                                                        });
                                            end end), (function (ppf) do
                                              return Format.fprintf(ppf, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "should be an instance of type",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "should be an instance of type"
                                                        });
                                            end end));end end end 
                             if ___conditional___ = 7--[[ Alias_type_mismatch ]] then do
                                return report_unification_error(ppf, empty, undefined, param$2[0], (function (ppf) do
                                              return Format.fprintf(ppf, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "This alias is bound to type",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "This alias is bound to type"
                                                        });
                                            end end), (function (ppf) do
                                              return Format.fprintf(ppf, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "but is used as an instance of type",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "but is used as an instance of type"
                                                        });
                                            end end));end end end 
                             if ___conditional___ = 8--[[ Present_has_conjunction ]] then do
                                return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ String_literal ]]Block.__(11, {
                                                    "The present constructor ",
                                                    --[[ String ]]Block.__(2, {
                                                        --[[ No_padding ]]0,
                                                        --[[ String_literal ]]Block.__(11, {
                                                            " has a conjunctive type",
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })
                                                  }),
                                                "The present constructor %s has a conjunctive type"
                                              }), param$2[0]);end end end 
                             if ___conditional___ = 9--[[ Present_has_no_type ]] then do
                                return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ String_literal ]]Block.__(11, {
                                                    "The present constructor ",
                                                    --[[ String ]]Block.__(2, {
                                                        --[[ No_padding ]]0,
                                                        --[[ String_literal ]]Block.__(11, {
                                                            " has no type",
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })
                                                  }),
                                                "The present constructor %s has no type"
                                              }), param$2[0]);end end end 
                             if ___conditional___ = 10--[[ Constructor_mismatch ]] then do
                                ty$prime = param$2[1];
                                ty = param$2[0];
                                return wrap_printing_env(env$1, (function (param) do
                                              reset_and_mark_loops_list(--[[ :: ]]{
                                                    ty,
                                                    --[[ :: ]]{
                                                      ty$prime,
                                                      --[[ [] ]]0
                                                    }
                                                  });
                                              return Curry._6(Format.fprintf(ppf, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "<hov>",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "<hov>"
                                                                      }}),
                                                                  --[[ String ]]Block.__(2, {
                                                                      --[[ No_padding ]]0,
                                                                      --[[ Char_literal ]]Block.__(12, {
                                                                          --[[ " " ]]32,
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Break ]]Block.__(0, {
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    }),
                                                                                  --[[ String ]]Block.__(2, {
                                                                                      --[[ No_padding ]]0,
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Break ]]Block.__(0, {
                                                                                              "@ ",
                                                                                              1,
                                                                                              0
                                                                                            }),
                                                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                  --[[ Close_box ]]0,
                                                                                                  --[[ End_of_format ]]0
                                                                                                })})
                                                                                        })
                                                                                    })
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[<hov>%s %a@ %s@ %a@]"
                                                            }), "This variant type contains a constructor", type_expr$1, ty, "which should be", type_expr$1, ty$prime);
                                            end end));end end end 
                             if ___conditional___ = 11--[[ Not_a_variant ]] then do
                                ty$1 = param$2[0];
                                reset(--[[ () ]]0);
                                mark_loops(ty$1);
                                return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ Formatting_gen ]]Block.__(18, {
                                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                          --[[ End_of_format ]]0,
                                                          ""
                                                        }}),
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "The type ",
                                                        --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                --[[ Break ]]Block.__(0, {
                                                                    "@ ",
                                                                    1,
                                                                    0
                                                                  }),
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "is not a polymorphic variant type",
                                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                                        --[[ Close_box ]]0,
                                                                        --[[ End_of_format ]]0
                                                                      })
                                                                  })
                                                              })})
                                                      })
                                                  }),
                                                "@[The type %a@ is not a polymorphic variant type@]"
                                              }), type_expr$1, ty$1);end end end 
                             if ___conditional___ = 12--[[ Variant_tags ]] then do
                                return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ Formatting_gen ]]Block.__(18, {
                                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                          --[[ End_of_format ]]0,
                                                          ""
                                                        }}),
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "Variant tags `",
                                                        --[[ String ]]Block.__(2, {
                                                            --[[ No_padding ]]0,
                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                --[[ Break ]]Block.__(0, {
                                                                    "@ ",
                                                                    1,
                                                                    0
                                                                  }),
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "and `",
                                                                    --[[ String ]]Block.__(2, {
                                                                        --[[ No_padding ]]0,
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            " have the same hash value.",
                                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                                --[[ Break ]]Block.__(0, {
                                                                                    "@ ",
                                                                                    1,
                                                                                    0
                                                                                  }),
                                                                                --[[ String ]]Block.__(2, {
                                                                                    --[[ No_padding ]]0,
                                                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                                                        --[[ Close_box ]]0,
                                                                                        --[[ End_of_format ]]0
                                                                                      })
                                                                                  })
                                                                              })
                                                                          })
                                                                      })
                                                                  })
                                                              })
                                                          })
                                                      })
                                                  }),
                                                "@[Variant tags `%s@ and `%s have the same hash value.@ %s@]"
                                              }), param$2[0], param$2[1], "Change one of them.");end end end 
                             if ___conditional___ = 13--[[ Invalid_variable_name ]] then do
                                return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ String_literal ]]Block.__(11, {
                                                    "The type variable name ",
                                                    --[[ String ]]Block.__(2, {
                                                        --[[ No_padding ]]0,
                                                        --[[ String_literal ]]Block.__(11, {
                                                            " is not allowed in programs",
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })
                                                  }),
                                                "The type variable name %s is not allowed in programs"
                                              }), param$2[0]);end end end 
                             if ___conditional___ = 14--[[ Cannot_quantify ]] then do
                                v = param$2[1];
                                return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ Formatting_gen ]]Block.__(18, {
                                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "<hov>",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "<hov>"
                                                        }}),
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "The universal type variable '",
                                                        --[[ String ]]Block.__(2, {
                                                            --[[ No_padding ]]0,
                                                            --[[ String_literal ]]Block.__(11, {
                                                                " cannot be generalized:",
                                                                --[[ Formatting_lit ]]Block.__(17, {
                                                                    --[[ Break ]]Block.__(0, {
                                                                        "@ ",
                                                                        1,
                                                                        0
                                                                      }),
                                                                    --[[ String ]]Block.__(2, {
                                                                        --[[ No_padding ]]0,
                                                                        --[[ Char_literal ]]Block.__(12, {
                                                                            --[[ "." ]]46,
                                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                                --[[ Close_box ]]0,
                                                                                --[[ End_of_format ]]0
                                                                              })
                                                                          })
                                                                      })
                                                                  })
                                                              })
                                                          })
                                                      })
                                                  }),
                                                "@[<hov>The universal type variable '%s cannot be generalized:@ %s.@]"
                                              }), param$2[0], is_Tvar(v) and "it escapes its scope" or (
                                              is_Tunivar(v) and "it is already bound to another variable" or "it is not a variable"
                                            ));end end end 
                             if ___conditional___ = 15--[[ Multiple_constraints_on_type ]] then do
                                return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ String_literal ]]Block.__(11, {
                                                    "Multiple constraints for type ",
                                                    --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                  }),
                                                "Multiple constraints for type %a"
                                              }), longident, param$2[0]);end end end 
                             if ___conditional___ = 16--[[ Repeated_method_label ]] then do
                                return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ Formatting_gen ]]Block.__(18, {
                                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                          --[[ End_of_format ]]0,
                                                          ""
                                                        }}),
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "This is the second method `",
                                                        --[[ String ]]Block.__(2, {
                                                            --[[ No_padding ]]0,
                                                            --[[ String_literal ]]Block.__(11, {
                                                                "' of this object type.",
                                                                --[[ Formatting_lit ]]Block.__(17, {
                                                                    --[[ Break ]]Block.__(0, {
                                                                        "@ ",
                                                                        1,
                                                                        0
                                                                      }),
                                                                    --[[ String ]]Block.__(2, {
                                                                        --[[ No_padding ]]0,
                                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                                            --[[ Close_box ]]0,
                                                                            --[[ End_of_format ]]0
                                                                          })
                                                                      })
                                                                  })
                                                              })
                                                          })
                                                      })
                                                  }),
                                                "@[This is the second method `%s' of this object type.@ %s@]"
                                              }), param$2[0], "Multiple occurences are not allowed.");end end end 
                             if ___conditional___ = 17--[[ Unbound_value ]] then do
                                lid$1 = param$2[0];
                                Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "Unbound value ",
                                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                            }),
                                          "Unbound value %a"
                                        }), longident, lid$1);
                                return spellcheck$1(ppf, fold_values)(env$1, lid$1);end end end 
                             if ___conditional___ = 18--[[ Unbound_constructor ]] then do
                                lid$2 = param$2[0];
                                Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "Unbound constructor ",
                                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                            }),
                                          "Unbound constructor %a"
                                        }), longident, lid$2);
                                return spellcheck_simple(ppf, fold_constructors, (function (d) do
                                                return d.cstr_name;
                                              end end))(env$1, lid$2);end end end 
                             if ___conditional___ = 19--[[ Unbound_label ]] then do
                                lid$3 = param$2[0];
                                Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "Unbound record field ",
                                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                            }),
                                          "Unbound record field %a"
                                        }), longident, lid$3);
                                return spellcheck_simple(ppf, fold_labels, (function (d) do
                                                return d.lbl_name;
                                              end end))(env$1, lid$3);end end end 
                             if ___conditional___ = 20--[[ Unbound_module ]] then do
                                lid$4 = param$2[0];
                                Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "Unbound module ",
                                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                            }),
                                          "Unbound module %a"
                                        }), longident, lid$4);
                                return spellcheck$1(ppf, fold_modules)(env$1, lid$4);end end end 
                             if ___conditional___ = 21--[[ Unbound_class ]] then do
                                lid$5 = param$2[0];
                                Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "Unbound class ",
                                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                            }),
                                          "Unbound class %a"
                                        }), longident, lid$5);
                                return spellcheck$1(ppf, fold_classs)(env$1, lid$5);end end end 
                             if ___conditional___ = 22--[[ Unbound_modtype ]] then do
                                lid$6 = param$2[0];
                                Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "Unbound module type ",
                                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                            }),
                                          "Unbound module type %a"
                                        }), longident, lid$6);
                                return spellcheck$1(ppf, fold_modtypes)(env$1, lid$6);end end end 
                             if ___conditional___ = 23--[[ Unbound_cltype ]] then do
                                lid$7 = param$2[0];
                                Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                          --[[ String_literal ]]Block.__(11, {
                                              "Unbound class type ",
                                              --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                            }),
                                          "Unbound class type %a"
                                        }), longident, lid$7);
                                return spellcheck$1(ppf, fold_cltypes)(env$1, lid$7);end end end 
                             if ___conditional___ = 24--[[ Ill_typed_functor_application ]] then do
                                return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ String_literal ]]Block.__(11, {
                                                    "Ill-typed functor application ",
                                                    --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                  }),
                                                "Ill-typed functor application %a"
                                              }), longident, param$2[0]);end end end 
                             if ___conditional___ = 25--[[ Access_functor_as_structure ]] then do
                                return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                --[[ String_literal ]]Block.__(11, {
                                                    "The module ",
                                                    --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                                            " is a functor, not a structure",
                                                            --[[ End_of_format ]]0
                                                          })})
                                                  }),
                                                "The module %a is a functor, not a structure"
                                              }), longident, param$2[0]);end end end 
                             do
                            
                          end
                        end end 
                      end end), param[3]);
        end else if (param[0] == Error_forward) then do
          return param[1];
        end else do
          return ;
        end end  end 
      end end));

__Error$7 = Caml_exceptions.create("Ocaml_typedtree_test.Typecore.Error");

Error_forward$1 = Caml_exceptions.create("Ocaml_typedtree_test.Typecore.Error_forward");

type_module = do
  contents: (function (env, md) do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "typecore.ml",
              77,
              22
            }
          };
    end end)
end;

type_open = do
  contents: (function (param) do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "typecore.ml",
              83,
              16
            }
          };
    end end)
end;

type_package = do
  contents: (function (param) do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "typecore.ml",
              88,
              16
            }
          };
    end end)
end;

type_object = do
  contents: (function (env, s) do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "typecore.ml",
              92,
              20
            }
          };
    end end)
end;

function re(node) do
  add_saved_type(--[[ Partial_expression ]]Block.__(2, {node}));
  record$2(--[[ Ti_expr ]]Block.__(1, {node}));
  return node;
end end

function rp(node) do
  add_saved_type(--[[ Partial_pattern ]]Block.__(3, {node}));
  record$2(--[[ Ti_pat ]]Block.__(0, {node}));
  return node;
end end

function snd3(param) do
  return param[1];
end end

function iter_expression(f, e) do
  expr = function (_e) do
    while(true) do
      e = _e;
      Curry._1(f, e);
      match = e.pexp_desc;
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 2--[[ Pexp_let ]] then do
            expr(match[2]);
            return List.iter(binding, match[1]);end end end 
         if ___conditional___ = 3--[[ Pexp_function ]] then do
            return List.iter(__case, match[0]);end end end 
         if ___conditional___ = 4--[[ Pexp_fun ]] then do
            may(expr, match[1]);
            _e = match[3];
            continue ;end end end 
         if ___conditional___ = 5--[[ Pexp_apply ]] then do
            expr(match[0]);
            return List.iter((function (param) do
                          return expr(param[1]);
                        end end), match[1]);end end end 
         if ___conditional___ = 6--[[ Pexp_match ]]
         or ___conditional___ = 7--[[ Pexp_try ]]
         or ___conditional___ = 9--[[ Pexp_construct ]]
         or ___conditional___ = 10--[[ Pexp_variant ]] then do
            return may(expr, match[1]);end end end 
         if ___conditional___ = 11--[[ Pexp_record ]] then do
            may(expr, match[1]);
            return List.iter((function (param) do
                          return expr(param[1]);
                        end end), match[0]);end end end 
         if ___conditional___ = 13--[[ Pexp_setfield ]] then do
            expr(match[0]);
            _e = match[2];
            continue ;end end end 
         if ___conditional___ = 8--[[ Pexp_tuple ]]
         or ___conditional___ = 14--[[ Pexp_array ]] then do
            return List.iter(expr, match[0]);end end end 
         if ___conditional___ = 15--[[ Pexp_ifthenelse ]] then do
            expr(match[0]);
            expr(match[1]);
            return may(expr, match[2]);end end end 
         if ___conditional___ = 16--[[ Pexp_sequence ]]
         or ___conditional___ = 17--[[ Pexp_while ]] then do
            expr(match[0]);
            _e = match[1];
            continue ;end end end 
         if ___conditional___ = 18--[[ Pexp_for ]] then do
            expr(match[1]);
            expr(match[2]);
            _e = match[4];
            continue ;end end end 
         if ___conditional___ = 24--[[ Pexp_override ]] then do
            return List.iter((function (param) do
                          return expr(param[1]);
                        end end), match[0]);end end end 
         if ___conditional___ = 25--[[ Pexp_letmodule ]] then do
            expr(match[2]);
            return module_expr(match[1]);end end end 
         if ___conditional___ = 29--[[ Pexp_object ]] then do
            return List.iter(class_field, match[0].pcstr_fields);end end end 
         if ___conditional___ = 23--[[ Pexp_setinstvar ]]
         or ___conditional___ = 30--[[ Pexp_newtype ]] then do
            _e = match[1];
            continue ;end end end 
         if ___conditional___ = 31--[[ Pexp_pack ]] then do
            return module_expr(match[0]);end end end 
         if ___conditional___ = 32--[[ Pexp_open ]] then do
            _e = match[2];
            continue ;end end end 
         if ___conditional___ = 0--[[ Pexp_ident ]]
         or ___conditional___ = 1--[[ Pexp_constant ]]
         or ___conditional___ = 22--[[ Pexp_new ]]
         or ___conditional___ = 33--[[ Pexp_extension ]] then do
            return --[[ () ]]0;end end end 
         do
        else do
          _e = match[0];
          continue ;
          end end
          
      end
      expr(match[0]);
      return List.iter(__case, match[1]);
    end;
  end end;
  __case = function (param) do
    may(expr, param.pc_guard);
    return expr(param.pc_rhs);
  end end;
  binding = function (x) do
    return expr(x.pvb_expr);
  end end;
  module_expr = function (_me) do
    while(true) do
      me = _me;
      match = me.pmod_desc;
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 1--[[ Pmod_structure ]] then do
            return List.iter(structure_item, match[0]);end end end 
         if ___conditional___ = 2--[[ Pmod_functor ]] then do
            _me = match[2];
            continue ;end end end 
         if ___conditional___ = 3--[[ Pmod_apply ]] then do
            module_expr(match[0]);
            _me = match[1];
            continue ;end end end 
         if ___conditional___ = 4--[[ Pmod_constraint ]] then do
            _me = match[0];
            continue ;end end end 
         if ___conditional___ = 5--[[ Pmod_unpack ]] then do
            return expr(match[0]);end end end 
         if ___conditional___ = 0--[[ Pmod_ident ]]
         or ___conditional___ = 6--[[ Pmod_extension ]] then do
            return --[[ () ]]0;end end end 
         do
        
      end
    end;
  end end;
  structure_item = function (str) do
    match = str.pstr_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 0--[[ Pstr_eval ]] then do
          return expr(match[0]);end end end 
       if ___conditional___ = 1--[[ Pstr_value ]] then do
          return List.iter(binding, match[1]);end end end 
       if ___conditional___ = 6--[[ Pstr_module ]] then do
          return module_expr(match[0].pmb_expr);end end end 
       if ___conditional___ = 7--[[ Pstr_recmodule ]] then do
          return List.iter((function (x) do
                        return module_expr(x.pmb_expr);
                      end end), match[0]);end end end 
       if ___conditional___ = 10--[[ Pstr_class ]] then do
          return List.iter((function (c) do
                        return class_expr(c.pci_expr);
                      end end), match[0]);end end end 
       if ___conditional___ = 12--[[ Pstr_include ]] then do
          return module_expr(match[0].pincl_mod);end end end 
       do
      else do
        return --[[ () ]]0;
        end end
        
    end
  end end;
  class_expr = function (_ce) do
    while(true) do
      ce = _ce;
      match = ce.pcl_desc;
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 1--[[ Pcl_structure ]] then do
            return List.iter(class_field, match[0].pcstr_fields);end end end 
         if ___conditional___ = 2--[[ Pcl_fun ]] then do
            may(expr, match[1]);
            _ce = match[3];
            continue ;end end end 
         if ___conditional___ = 3--[[ Pcl_apply ]] then do
            class_expr(match[0]);
            return List.iter((function (param) do
                          return expr(param[1]);
                        end end), match[1]);end end end 
         if ___conditional___ = 4--[[ Pcl_let ]] then do
            List.iter(binding, match[1]);
            _ce = match[2];
            continue ;end end end 
         if ___conditional___ = 5--[[ Pcl_constraint ]] then do
            _ce = match[0];
            continue ;end end end 
         if ___conditional___ = 0--[[ Pcl_constr ]]
         or ___conditional___ = 6--[[ Pcl_extension ]] then do
            return --[[ () ]]0;end end end 
         do
        
      end
    end;
  end end;
  class_field = function (cf) do
    match = cf.pcf_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 0--[[ Pcf_inherit ]] then do
          return class_expr(match[1]);end end end 
       if ___conditional___ = 1--[[ Pcf_val ]] then do
          match$1 = match[0][2];
          if (match$1.tag) then do
            return expr(match$1[1]);
          end else do
            return --[[ () ]]0;
          end end end end end 
       if ___conditional___ = 2--[[ Pcf_method ]] then do
          match$2 = match[0][2];
          if (match$2.tag) then do
            return expr(match$2[1]);
          end else do
            return --[[ () ]]0;
          end end end end end 
       if ___conditional___ = 4--[[ Pcf_initializer ]] then do
          return expr(match[0]);end end end 
       if ___conditional___ = 3--[[ Pcf_constraint ]]
       or ___conditional___ = 5--[[ Pcf_attribute ]]
       or ___conditional___ = 6--[[ Pcf_extension ]] then do
          return --[[ () ]]0;end end end 
       do
      
    end
  end end;
  return expr(e);
end end

function all_idents_cases(el) do
  idents = Hashtbl.create(undefined, 8);
  f = function (param) do
    match = param.pexp_desc;
    if (match.tag) then do
      return --[[ () ]]0;
    end else do
      match$1 = match[0].txt;
      local ___conditional___=(match$1.tag | 0);
      do
         if ___conditional___ = 0--[[ Lident ]] then do
            return Hashtbl.replace(idents, match$1[0], --[[ () ]]0);end end end 
         if ___conditional___ = 1--[[ Ldot ]]
         or ___conditional___ = 2--[[ Lapply ]] then do
            return --[[ () ]]0;end end end 
         do
        
      end
    end end 
  end end;
  List.iter((function (cp) do
          may((function (param) do
                  return iter_expression(f, param);
                end end), cp.pc_guard);
          return iter_expression(f, cp.pc_rhs);
        end end), el);
  return Hashtbl.fold((function (x, param, rest) do
                return --[[ :: ]]{
                        x,
                        rest
                      };
              end end), idents, --[[ [] ]]0);
end end

function type_constant(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Const_int ]] then do
        return instance_def(type_int);end end end 
     if ___conditional___ = 1--[[ Const_char ]] then do
        return instance_def(type_char);end end end 
     if ___conditional___ = 2--[[ Const_string ]] then do
        return instance_def(type_string);end end end 
     if ___conditional___ = 3--[[ Const_float ]] then do
        return instance_def(type_float);end end end 
     if ___conditional___ = 4--[[ Const_int32 ]] then do
        return instance_def(type_int32);end end end 
     if ___conditional___ = 5--[[ Const_int64 ]] then do
        return instance_def(type_int64);end end end 
     if ___conditional___ = 6--[[ Const_nativeint ]] then do
        return instance_def(type_nativeint);end end end 
     do
    
  end
end end

function type_option$1(ty) do
  return newty2(current_level.contents, --[[ Tconstr ]]Block.__(3, {
                path_option,
                --[[ :: ]]{
                  ty,
                  --[[ [] ]]0
                },
                do
                  contents: --[[ Mnil ]]0
                end
              }));
end end

function mkexp$1(exp_desc, exp_type, exp_loc, exp_env) do
  return do
          exp_desc: exp_desc,
          exp_loc: exp_loc,
          exp_extra: --[[ [] ]]0,
          exp_type: exp_type,
          exp_env: exp_env,
          exp_attributes: --[[ [] ]]0
        end;
end end

function option_none(ty, loc) do
  lid = --[[ Lident ]]Block.__(0, {"None"});
  cnone = lookup_constructor(lid, initial_safe_string);
  return mkexp$1(--[[ Texp_construct ]]Block.__(8, {
                do
                  txt: lid,
                  loc: none
                end,
                cnone,
                --[[ [] ]]0
              }), ty, loc, initial_safe_string);
end end

function option_some(texp) do
  lid = --[[ Lident ]]Block.__(0, {"Some"});
  csome = lookup_constructor(lid, initial_safe_string);
  return mkexp$1(--[[ Texp_construct ]]Block.__(8, {
                do
                  txt: lid,
                  loc: none
                end,
                csome,
                --[[ :: ]]{
                  texp,
                  --[[ [] ]]0
                }
              }), type_option$1(texp.exp_type), texp.exp_loc, texp.exp_env);
end end

function extract_option_type(env, ty) do
  match = expand_head(env, ty);
  match$1 = match.desc;
  if (typeof match$1 ~= "number" and match$1.tag == --[[ Tconstr ]]3) then do
    match$2 = match$1[1];
    if (match$2 and not match$2[1] and same(match$1[0], path_option)) then do
      return match$2[0];
    end
     end 
  end
   end 
  throw {
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "typecore.ml",
          275,
          9
        }
      };
end end

function extract_concrete_record(env, ty) do
  match = extract_concrete_typedecl(env, ty);
  match$1 = match[2].type_kind;
  if (typeof match$1 == "number") then do
    throw Caml_builtin_exceptions.not_found;
  end else if (match$1.tag) then do
    throw Caml_builtin_exceptions.not_found;
  end else do
    return --[[ tuple ]]{
            match[0],
            match[1],
            match$1[0]
          };
  end end  end 
end end

function extract_concrete_variant(env, ty) do
  match = extract_concrete_typedecl(env, ty);
  match$1 = match[2].type_kind;
  p = match[1];
  p0 = match[0];
  if (typeof match$1 == "number") then do
    if (match$1 == --[[ Type_abstract ]]0) then do
      throw Caml_builtin_exceptions.not_found;
    end else do
      return --[[ tuple ]]{
              p0,
              p,
              --[[ [] ]]0
            };
    end end 
  end else if (match$1.tag) then do
    return --[[ tuple ]]{
            p0,
            p,
            match$1[0]
          };
  end else do
    throw Caml_builtin_exceptions.not_found;
  end end  end 
end end

function extract_label_names(sexp, env, ty) do
  try do
    match = extract_concrete_record(env, ty);
    return List.map((function (l) do
                  return l.ld_id;
                end end), match[2]);
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "typecore.ml",
              293,
              4
            }
          };
    end
     end 
    throw exn;
  end
end end

function explicit_arity(param) do
  return List.exists((function (param) do
                local ___conditional___=(param[0].txt);
                do
                   if ___conditional___ = "explicit_arity"
                   or ___conditional___ = "ocaml.explicit_arity" then do
                      return true;end end end 
                   do
                  else do
                    return false;
                    end end
                    
                end
              end end), param);
end end

function unify_pat_types(loc, env, ty, ty$prime) do
  try do
    return unify$2(env, ty, ty$prime);
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      throw {
            __Error$7,
            loc,
            env,
            --[[ Pattern_type_clash ]]Block.__(3, {exn[1]})
          };
    end
     end 
    if (exn[0] == Tags) then do
      throw {
            __Error$6,
            loc,
            env,
            --[[ Variant_tags ]]Block.__(12, {
                exn[1],
                exn[2]
              })
          };
    end
     end 
    throw exn;
  end
end end

function unify_exp_types(loc, env, ty, expected_ty) do
  try do
    return unify$2(env, ty, expected_ty);
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      throw {
            __Error$7,
            loc,
            env,
            --[[ Expr_type_clash ]]Block.__(7, {exn[1]})
          };
    end
     end 
    if (exn[0] == Tags) then do
      throw {
            __Error$6,
            loc,
            env,
            --[[ Variant_tags ]]Block.__(12, {
                exn[1],
                exn[2]
              })
          };
    end
     end 
    throw exn;
  end
end end

newtype_level$1 = do
  contents: undefined
end;

function get_newtype_level$1(param) do
  match = newtype_level$1.contents;
  if (match ~= undefined) then do
    return match;
  end else do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "typecore.ml",
            331,
            12
          }
        };
  end end 
end end

function unify_pat_types_gadt(loc, env, ty, ty$prime) do
  match = newtype_level$1.contents;
  newtype_level$2;
  if (match ~= undefined) then do
    newtype_level$2 = match;
  end else do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "typecore.ml",
            336,
            14
          }
        };
  end end 
  try do
    lev = newtype_level$2;
    env$1 = env;
    ty1 = ty;
    ty2 = ty$prime;
    try do
      univar_pairs.contents = --[[ [] ]]0;
      newtype_level.contents = lev;
      set_mode_pattern(true, true, (function (param) do
              return unify$1(env$1, ty1, ty2);
            end end));
      newtype_level.contents = undefined;
      return Curry._1(TypePairs.clear, unify_eq_set);
    end
    catch (raw_e)do
      e = Caml_js_exceptions.internalToOCamlException(raw_e);
      Curry._1(TypePairs.clear, unify_eq_set);
      if (e[0] == Unify) then do
        throw {
              Unify,
              e[1]
            };
      end
       end 
      newtype_level.contents = undefined;
      throw e;
    end
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      throw {
            __Error$7,
            loc,
            env.contents,
            --[[ Pattern_type_clash ]]Block.__(3, {exn[1]})
          };
    end
     end 
    if (exn[0] == Tags) then do
      throw {
            __Error$6,
            loc,
            env.contents,
            --[[ Variant_tags ]]Block.__(12, {
                exn[1],
                exn[2]
              })
          };
    end
     end 
    if (exn[0] == Unification_recursive_abbrev) then do
      throw {
            __Error$7,
            loc,
            env.contents,
            --[[ Recursive_local_constraint ]]Block.__(33, {exn[1]})
          };
    end
     end 
    throw exn;
  end
end end

function unify_pat(env, pat, expected_ty) do
  return unify_pat_types(pat.pat_loc, env, pat.pat_type, expected_ty);
end end

function finalize_variant(pat) do
  match = pat.pat_desc;
  if (typeof match == "number" or match.tag ~= --[[ Tpat_variant ]]5) then do
    return --[[ () ]]0;
  end else do
    opat = match[1];
    match$1 = expand_head(pat.pat_env, pat.pat_type);
    match$2 = match$1.desc;
    row;
    if (typeof match$2 == "number") then do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "typecore.ml",
              362,
              15
            }
          };
    end else if (match$2.tag == --[[ Tvariant ]]8) then do
      row$1 = match$2[0];
      match[2].contents = row$1;
      row = row_repr_aux(--[[ [] ]]0, row$1);
    end else do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "typecore.ml",
              362,
              15
            }
          };
    end end  end 
    match$3 = row_field(match[0], row);
    if (typeof match$3 == "number" or not match$3.tag) then do
      return --[[ () ]]0;
    end else do
      c = match$3[0];
      if (c) then do
        if (not match$3[1] and not row.row_closed) then do
          return set_row_field(match$3[3], --[[ Rpresent ]]Block.__(0, {undefined}));
        end
         end 
      end else do
        match$4 = match$3[1];
        if (match$4 and not row.row_closed) then do
          ty = match$4[0];
          set_row_field(match$3[3], --[[ Rpresent ]]Block.__(0, {ty}));
          if (opat ~= undefined) then do
            pat$1 = opat;
            partial_arg = pat$1.pat_env;
            return List.iter((function (param) do
                          return unify_pat(partial_arg, pat$1, param);
                        end end), --[[ :: ]]{
                        ty,
                        match$4[1]
                      });
          end else do
            throw {
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "typecore.ml",
                    370,
                    40
                  }
                };
          end end 
        end
         end 
      end end 
      if (match$3[2] and not row_fixed(row)) then do
        return set_row_field(match$3[3], --[[ Reither ]]Block.__(1, {
                      c,
                      --[[ [] ]]0,
                      false,
                      do
                        contents: undefined
                      end
                    }));
      end else do
        return --[[ () ]]0;
      end end 
    end end 
  end end 
end end

function iter_pattern(f, p) do
  Curry._1(f, p);
  return iter_pattern_desc((function (param) do
                return iter_pattern(f, param);
              end end), p.pat_desc);
end end

function has_variants(p) do
  try do
    iter_pattern((function (param) do
            tmp = param.pat_desc;
            if (typeof tmp == "number" or tmp.tag ~= --[[ Tpat_variant ]]5) then do
              return --[[ () ]]0;
            end else do
              throw Pervasives.Exit;
            end end 
          end end), p);
    return false;
  end
  catch (exn)do
    if (exn == Pervasives.Exit) then do
      return true;
    end else do
      throw exn;
    end end 
  end
end end

pattern_variables = do
  contents: --[[ [] ]]0
end;

pattern_force = do
  contents: --[[ [] ]]0
end;

pattern_scope = do
  contents: undefined
end;

allow_modules = do
  contents: false
end;

module_variables = do
  contents: --[[ [] ]]0
end;

function reset_pattern(scope, allow) do
  pattern_variables.contents = --[[ [] ]]0;
  pattern_force.contents = --[[ [] ]]0;
  pattern_scope.contents = scope;
  allow_modules.contents = allow;
  module_variables.contents = --[[ [] ]]0;
  return --[[ () ]]0;
end end

function enter_variable(is_moduleOpt, is_as_variableOpt, loc, name, ty) do
  is_module = is_moduleOpt ~= undefined and is_moduleOpt or false;
  is_as_variable = is_as_variableOpt ~= undefined and is_as_variableOpt or false;
  if (List.exists((function (param) do
            return param[0].name == name.txt;
          end end), pattern_variables.contents)) then do
    throw {
          __Error$7,
          loc,
          empty,
          --[[ Multiply_bound_variable ]]Block.__(5, {name.txt})
        };
  end
   end 
  id = create(name.txt);
  pattern_variables.contents = --[[ :: ]]{
    --[[ tuple ]]{
      id,
      ty,
      name,
      loc,
      is_as_variable
    },
    pattern_variables.contents
  };
  if (is_module) then do
    if (not allow_modules.contents) then do
      throw {
            __Error$7,
            loc,
            empty,
            --[[ Modules_not_allowed ]]2
          };
    end
     end 
    module_variables.contents = --[[ :: ]]{
      --[[ tuple ]]{
        name,
        loc
      },
      module_variables.contents
    };
  end else do
    may((function (s) do
            return record$2(--[[ An_ident ]]Block.__(5, {
                          name.loc,
                          name.txt,
                          s
                        }));
          end end), pattern_scope.contents);
  end end 
  return id;
end end

function sort_pattern_variables(vs) do
  return List.sort((function (param, param$1) do
                return Caml_primitive.caml_string_compare(param[0].name, param$1[0].name);
              end end), vs);
end end

function enter_orpat_variables(loc, env, p1_vs, p2_vs) do
  p1_vs$1 = sort_pattern_variables(p1_vs);
  p2_vs$1 = sort_pattern_variables(p2_vs);
  unify_vars = function (_p1_vs, _p2_vs) do
    while(true) do
      p2_vs = _p2_vs;
      p1_vs = _p1_vs;
      if (p1_vs) then do
        match = p1_vs[0];
        x1 = match[0];
        if (p2_vs) then do
          rem2 = p2_vs[1];
          match$1 = p2_vs[0];
          x2 = match$1[0];
          rem1 = p1_vs[1];
          if (equal(x1, x2)) then do
            if (x1 == x2) then do
              _p2_vs = rem2;
              _p1_vs = rem1;
              continue ;
            end else do
              try do
                unify$2(env, match[1], match$1[1]);
              end
              catch (raw_exn)do
                exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                if (exn[0] == Unify) then do
                  throw {
                        __Error$7,
                        loc,
                        env,
                        --[[ Or_pattern_type_clash ]]Block.__(4, {
                            x1,
                            exn[1]
                          })
                      };
                end
                 end 
                throw exn;
              end
              return --[[ :: ]]{
                      --[[ tuple ]]{
                        x2,
                        x1
                      },
                      unify_vars(rem1, rem2)
                    };
            end end 
          end else do
            min_var = x1.name < x2.name and x1 or x2;
            throw {
                  __Error$7,
                  loc,
                  env,
                  --[[ Orpat_vars ]]Block.__(6, {min_var})
                };
          end end 
        end else do
          throw {
                __Error$7,
                loc,
                env,
                --[[ Orpat_vars ]]Block.__(6, {x1})
              };
        end end 
      end else if (p2_vs) then do
        throw {
              __Error$7,
              loc,
              env,
              --[[ Orpat_vars ]]Block.__(6, {p2_vs[0][0]})
            };
      end else do
        return --[[ [] ]]0;
      end end  end 
    end;
  end end;
  return unify_vars(p1_vs$1, p2_vs$1);
end end

function build_as_type(env, _p) do
  while(true) do
    p = _p;
    match = p.pat_desc;
    if (typeof match == "number") then do
      return p.pat_type;
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 1--[[ Tpat_alias ]] then do
            _p = match[0];
            continue ;end end end 
         if ___conditional___ = 3--[[ Tpat_tuple ]] then do
            tyl = List.map((function (param) do
                    return build_as_type(env, param);
                  end end), match[0]);
            return newty2(current_level.contents, --[[ Ttuple ]]Block.__(2, {tyl}));end end end 
         if ___conditional___ = 4--[[ Tpat_construct ]] then do
            pl = match[2];
            cstr = match[1];
            keep = cstr.cstr_private == --[[ Private ]]0 or cstr.cstr_existentials ~= --[[ [] ]]0;
            if (keep) then do
              return p.pat_type;
            end else do
              tyl$1 = List.map((function (param) do
                      return build_as_type(env, param);
                    end end), pl);
              match$1 = instance_constructor(undefined, cstr);
              List.iter2((function (param) do
                      p = param[0];
                      partial_arg = do
                        pat_desc: p.pat_desc,
                        pat_loc: p.pat_loc,
                        pat_extra: p.pat_extra,
                        pat_type: param[1],
                        pat_env: p.pat_env,
                        pat_attributes: p.pat_attributes
                      end;
                      return (function (param) do
                          return unify_pat(env, partial_arg, param);
                        end end);
                    end end), List.combine(pl, tyl$1), match$1[0]);
              return match$1[1];
            end end end end end 
         if ___conditional___ = 5--[[ Tpat_variant ]] then do
            ty = may_map((function (param) do
                    return build_as_type(env, param);
                  end end), match[1]);
            desc = --[[ Tvariant ]]Block.__(8, {do
                  row_fields: --[[ :: ]]{
                    --[[ tuple ]]{
                      match[0],
                      --[[ Rpresent ]]Block.__(0, {ty})
                    },
                    --[[ [] ]]0
                  },
                  row_more: newvar(undefined, --[[ () ]]0),
                  row_bound: --[[ () ]]0,
                  row_closed: false,
                  row_fixed: false,
                  row_name: undefined
                end});
            return newty2(current_level.contents, desc);end end end 
         if ___conditional___ = 6--[[ Tpat_record ]] then do
            lpl = match[0];
            lbl = snd3(List.hd(lpl));
            if (lbl.lbl_private == --[[ Private ]]0) then do
              return p.pat_type;
            end else do
              ty$1 = newvar(undefined, --[[ () ]]0);
              ppl = List.map((function (param) do
                      return --[[ tuple ]]{
                              param[1].lbl_pos,
                              param[2]
                            };
                    end end), lpl);
              do_label = (function(p,ty$1,ppl)do
              return function do_label(lbl) do
                match = instance_label(false, lbl);
                ty_arg = match[1];
                unify_pat(env, do
                      pat_desc: p.pat_desc,
                      pat_loc: p.pat_loc,
                      pat_extra: p.pat_extra,
                      pat_type: ty$1,
                      pat_env: p.pat_env,
                      pat_attributes: p.pat_attributes
                    end, match[2]);
                refinable = false;
                if (lbl.lbl_mut == --[[ Immutable ]]0) then do
                  tmp = false;
                  if (List.mem_assoc(lbl.lbl_pos, ppl)) then do
                    match$1 = repr(lbl.lbl_arg).desc;
                    tmp$1;
                    tmp$1 = typeof match$1 == "number" or match$1.tag ~= --[[ Tpoly ]]10 and true or false;
                    tmp = tmp$1;
                  end
                   end 
                  refinable = tmp;
                end
                 end 
                if (refinable) then do
                  arg = List.assoc(lbl.lbl_pos, ppl);
                  return unify_pat(env, do
                              pat_desc: arg.pat_desc,
                              pat_loc: arg.pat_loc,
                              pat_extra: arg.pat_extra,
                              pat_type: build_as_type(env, arg),
                              pat_env: arg.pat_env,
                              pat_attributes: arg.pat_attributes
                            end, ty_arg);
                end else do
                  match$2 = instance_label(false, lbl);
                  unify$2(env, ty_arg, match$2[1]);
                  return unify_pat(env, p, match$2[2]);
                end end 
              end end
              end(p,ty$1,ppl));
              __Array.iter(do_label, lbl.lbl_all);
              return ty$1;
            end end end end end 
         if ___conditional___ = 8--[[ Tpat_or ]] then do
            row = match[2];
            p2 = match[1];
            if (row ~= undefined) then do
              row$1 = row_repr_aux(--[[ [] ]]0, row);
              desc$1 = --[[ Tvariant ]]Block.__(8, {do
                    row_fields: row$1.row_fields,
                    row_more: newvar(undefined, --[[ () ]]0),
                    row_bound: row$1.row_bound,
                    row_closed: false,
                    row_fixed: row$1.row_fixed,
                    row_name: row$1.row_name
                  end});
              return newty2(current_level.contents, desc$1);
            end else do
              ty1 = build_as_type(env, match[0]);
              ty2 = build_as_type(env, p2);
              unify_pat(env, do
                    pat_desc: p2.pat_desc,
                    pat_loc: p2.pat_loc,
                    pat_extra: p2.pat_extra,
                    pat_type: ty2,
                    pat_env: p2.pat_env,
                    pat_attributes: p2.pat_attributes
                  end, ty1);
              return ty1;
            end end end end end 
         do
        else do
          return p.pat_type;
          end end
          
      end
    end end 
  end;
end end

function build_or_pat(env, loc, lid) do
  match = find_type(env, loc, lid);
  path = match[0];
  tyl = List.map((function (param) do
          return newvar(undefined, --[[ () ]]0);
        end end), match[1].type_params);
  ty = expand_head(env, newty2(current_level.contents, --[[ Tconstr ]]Block.__(3, {
              path,
              tyl,
              do
                contents: --[[ Mnil ]]0
              end
            })));
  match$1 = ty.desc;
  row0;
  exit = 0;
  if (typeof match$1 == "number" or match$1.tag ~= --[[ Tvariant ]]8) then do
    exit = 1;
  end else do
    row = match$1[0];
    if (static_row(row)) then do
      row0 = row;
    end else do
      exit = 1;
    end end 
  end end 
  if (exit == 1) then do
    throw {
          __Error$7,
          loc,
          env,
          --[[ Not_a_variant_type ]]Block.__(30, {lid})
        };
  end
   end 
  match$2 = List.fold_left((function (param, param$1) do
          l = param$1[0];
          fields = param[1];
          pats = param[0];
          match = row_field_repr_aux(--[[ [] ]]0, param$1[1]);
          if (typeof match == "number" or match.tag) then do
            return --[[ tuple ]]{
                    pats,
                    fields
                  };
          end else do
            match$1 = match[0];
            if (match$1 ~= undefined) then do
              ty = match$1;
              return --[[ tuple ]]{
                      --[[ :: ]]{
                        --[[ tuple ]]{
                          l,
                          do
                            pat_desc: --[[ Tpat_any ]]0,
                            pat_loc: none,
                            pat_extra: --[[ [] ]]0,
                            pat_type: ty,
                            pat_env: env,
                            pat_attributes: --[[ [] ]]0
                          end
                        },
                        pats
                      },
                      --[[ :: ]]{
                        --[[ tuple ]]{
                          l,
                          --[[ Reither ]]Block.__(1, {
                              false,
                              --[[ :: ]]{
                                ty,
                                --[[ [] ]]0
                              },
                              true,
                              do
                                contents: undefined
                              end
                            })
                        },
                        fields
                      }
                    };
            end else do
              return --[[ tuple ]]{
                      --[[ :: ]]{
                        --[[ tuple ]]{
                          l,
                          undefined
                        },
                        pats
                      },
                      --[[ :: ]]{
                        --[[ tuple ]]{
                          l,
                          --[[ Reither ]]Block.__(1, {
                              true,
                              --[[ [] ]]0,
                              true,
                              do
                                contents: undefined
                              end
                            })
                        },
                        fields
                      }
                    };
            end end 
          end end 
        end end), --[[ tuple ]]{
        --[[ [] ]]0,
        --[[ [] ]]0
      }, row_repr_aux(--[[ [] ]]0, row0).row_fields);
  row_row_fields = List.rev(match$2[1]);
  row_row_more = newvar(undefined, --[[ () ]]0);
  row_row_name = --[[ tuple ]]{
    path,
    tyl
  };
  row$1 = do
    row_fields: row_row_fields,
    row_more: row_row_more,
    row_bound: --[[ () ]]0,
    row_closed: false,
    row_fixed: false,
    row_name: row_row_name
  end;
  ty$1 = newty2(current_level.contents, --[[ Tvariant ]]Block.__(8, {row$1}));
  gloc_loc_start = loc.loc_start;
  gloc_loc_end = loc.loc_end;
  gloc = do
    loc_start: gloc_loc_start,
    loc_end: gloc_loc_end,
    loc_ghost: true
  end;
  row$prime = do
    contents: do
      row_fields: row_row_fields,
      row_more: newvar(undefined, --[[ () ]]0),
      row_bound: --[[ () ]]0,
      row_closed: false,
      row_fixed: false,
      row_name: row_row_name
    end
  end;
  pats = List.map((function (param) do
          return do
                  pat_desc: --[[ Tpat_variant ]]Block.__(5, {
                      param[0],
                      param[1],
                      row$prime
                    }),
                  pat_loc: gloc,
                  pat_extra: --[[ [] ]]0,
                  pat_type: ty$1,
                  pat_env: env,
                  pat_attributes: --[[ [] ]]0
                end;
        end end), match$2[0]);
  if (pats) then do
    r = List.fold_left((function (pat, pat0) do
            return do
                    pat_desc: --[[ Tpat_or ]]Block.__(8, {
                        pat0,
                        pat,
                        row0
                      }),
                    pat_loc: gloc,
                    pat_extra: --[[ [] ]]0,
                    pat_type: ty$1,
                    pat_env: env,
                    pat_attributes: --[[ [] ]]0
                  end;
          end end), pats[0], pats[1]);
    return --[[ tuple ]]{
            path,
            rp(do
                  pat_desc: r.pat_desc,
                  pat_loc: loc,
                  pat_extra: r.pat_extra,
                  pat_type: r.pat_type,
                  pat_env: r.pat_env,
                  pat_attributes: r.pat_attributes
                end),
            ty$1
          };
  end else do
    throw {
          __Error$7,
          loc,
          env,
          --[[ Not_a_variant_type ]]Block.__(30, {lid})
        };
  end end 
end end

function expand_path(env, _p) do
  while(true) do
    p = _p;
    decl;
    try do
      decl = find_type_full(p, env)[0];
    end
    catch (exn)do
      if (exn == Caml_builtin_exceptions.not_found) then do
        decl = undefined;
      end else do
        throw exn;
      end end 
    end
    if (decl ~= undefined) then do
      match = decl.type_manifest;
      if (match ~= undefined) then do
        match$1 = repr(match);
        match$2 = match$1.desc;
        if (typeof match$2 == "number" or match$2.tag ~= --[[ Tconstr ]]3) then do
          return p;
        end else do
          _p = match$2[0];
          continue ;
        end end 
      end
       end 
    end
     end 
    p$prime = normalize_path$1(undefined, env, p);
    if (same(p, p$prime)) then do
      return p;
    end else do
      _p = p$prime;
      continue ;
    end end 
  end;
end end

function compare_type_path(env, tpath1, tpath2) do
  return same(expand_path(env, tpath1), expand_path(env, tpath2));
end end

function wrap_disambiguate(kind, ty, f, x) do
  try do
    return Curry._1(f, x);
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == __Error$7) then do
      match = exn[3];
      if (typeof match == "number") then do
        throw exn;
      end else if (match.tag == --[[ Wrong_name ]]13) then do
        throw {
              __Error$7,
              exn[1],
              exn[2],
              --[[ Wrong_name ]]Block.__(13, {
                  kind,
                  ty,
                  match[2],
                  match[3],
                  match[4]
                })
            };
      end else do
        throw exn;
      end end  end 
    end else do
      throw exn;
    end end 
  end
end end

type_kind = "record";

function get_type_path$1(env, d) do
  match = d.lbl_res.desc;
  if (typeof match == "number") then do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "typecore.ml",
            602,
            11
          }
        };
  end else if (match.tag == --[[ Tconstr ]]3) then do
    return match[0];
  end else do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "typecore.ml",
            602,
            11
          }
        };
  end end  end 
end end

function lookup_from_type(env, tpath, lid) do
  descrs = find_type_full(tpath, env)[1][1];
  mark_type_used(env, last(tpath), find_type_full(tpath, env)[0]);
  match = lid.txt;
  local ___conditional___=(match.tag | 0);
  do
     if ___conditional___ = 0--[[ Lident ]] then do
        s = match[0];
        try do
          return List.find((function (nd) do
                        return nd.lbl_name == s;
                      end end), descrs);
        end
        catch (exn)do
          if (exn == Caml_builtin_exceptions.not_found) then do
            throw {
                  __Error$7,
                  lid.loc,
                  env,
                  --[[ Wrong_name ]]Block.__(13, {
                      "",
                      newvar(undefined, --[[ () ]]0),
                      type_kind,
                      tpath,
                      lid.txt
                    })
                };
          end
           end 
          throw exn;
        endend end end 
     if ___conditional___ = 1--[[ Ldot ]]
     or ___conditional___ = 2--[[ Lapply ]] then do
        throw Caml_builtin_exceptions.not_found;end end end 
     do
    
  end
end end

function unique(eq, _acc, _param) do
  while(true) do
    param = _param;
    acc = _acc;
    if (param) then do
      rem = param[1];
      x = param[0];
      if (List.exists(Curry._1(eq, x), acc)) then do
        _param = rem;
        continue ;
      end else do
        _param = rem;
        _acc = --[[ :: ]]{
          x,
          acc
        };
        continue ;
      end end 
    end else do
      return List.rev(acc);
    end end 
  end;
end end

function ambiguous_types(env, lbl, others) do
  tpath = get_type_path$1(env, lbl);
  others$1 = List.map((function (param) do
          return get_type_path$1(env, param[0]);
        end end), others);
  tpaths = unique((function (param, param$1) do
          return compare_type_path(env, param, param$1);
        end end), --[[ :: ]]{
        tpath,
        --[[ [] ]]0
      }, others$1);
  if (tpaths and not tpaths[1]) then do
    return --[[ [] ]]0;
  end else do
    return List.map(string_of_path, tpaths);
  end end 
end end

function disambiguate_by_type(env, tpath, lbls) do
  check_type = function (param) do
    lbl_tpath = get_type_path$1(env, param[0]);
    return compare_type_path(env, tpath, lbl_tpath);
  end end;
  return List.find(check_type, lbls);
end end

function disambiguate(warnOpt, check_lkOpt, scope, lid, env, opath, lbls) do
  warn = warnOpt ~= undefined and warnOpt or prerr_warning;
  check_lk = check_lkOpt ~= undefined and check_lkOpt or (function (param, param$1) do
        return --[[ () ]]0;
      end end);
  scope$1 = scope ~= undefined and scope or lbls;
  lbl;
  if (opath ~= undefined) then do
    match = opath;
    pr = match[2];
    tpath = match[1];
    warn_pr = function (param) do
      kind = type_kind == "record" and "field" or "constructor";
      return Curry._2(warn, lid.loc, --[[ Not_principal ]]Block.__(8, {"this type-based " .. (kind .. " disambiguation")}));
    end end;
    try do
      match$1 = disambiguate_by_type(env, tpath, scope$1);
      lbl$1 = match$1[0];
      Curry._1(match$1[1], --[[ () ]]0);
      if (not pr) then do
        if (lbls) then do
          lbl_tpath = get_type_path$1(env, lbls[0][0]);
          if (compare_type_path(env, tpath, lbl_tpath)) then do
            paths = ambiguous_types(env, lbl$1, lbls[1]);
            if (paths ~= --[[ [] ]]0) then do
              Curry._2(warn, lid.loc, --[[ Ambiguous_name ]]Block.__(24, {
                      --[[ :: ]]{
                        last$1(lid.txt),
                        --[[ [] ]]0
                      },
                      paths,
                      false
                    }));
            end
             end 
          end else do
            warn_pr(--[[ () ]]0);
          end end 
        end else do
          warn_pr(--[[ () ]]0);
        end end 
      end
       end 
      lbl = lbl$1;
    end
    catch (exn)do
      if (exn == Caml_builtin_exceptions.not_found) then do
        try do
          lbl$2 = lookup_from_type(env, tpath, lid);
          Curry._2(check_lk, tpath, lbl$2);
          s = string_of_out_ident(tree_of_path(tpath));
          Curry._2(warn, lid.loc, --[[ Name_out_of_scope ]]Block.__(23, {
                  s,
                  --[[ :: ]]{
                    last$1(lid.txt),
                    --[[ [] ]]0
                  },
                  false
                }));
          if (not pr) then do
            warn_pr(--[[ () ]]0);
          end
           end 
          lbl = lbl$2;
        end
        catch (exn$1)do
          if (exn$1 == Caml_builtin_exceptions.not_found) then do
            if (lbls == --[[ [] ]]0) then do
              lbl = unbound_label_error(env, lid);
            end else do
              tp_000 = match[0];
              tp_001 = expand_path(env, tpath);
              tp = --[[ tuple ]]{
                tp_000,
                tp_001
              };
              tpl = List.map((function (param) do
                      tp0 = get_type_path$1(env, param[0]);
                      tp = expand_path(env, tp0);
                      return --[[ tuple ]]{
                              tp0,
                              tp
                            };
                    end end), lbls);
              throw {
                    __Error$7,
                    lid.loc,
                    env,
                    --[[ Name_type_mismatch ]]Block.__(14, {
                        type_kind,
                        lid.txt,
                        tp,
                        tpl
                      })
                  };
            end end 
          end else do
            throw exn$1;
          end end 
        end
      end else do
        throw exn;
      end end 
    end
  end else if (lbls) then do
    match$2 = lbls[0];
    lbl$3 = match$2[0];
    Curry._1(match$2[1], --[[ () ]]0);
    paths$1 = ambiguous_types(env, lbl$3, lbls[1]);
    if (paths$1 ~= --[[ [] ]]0) then do
      Curry._2(warn, lid.loc, --[[ Ambiguous_name ]]Block.__(24, {
              --[[ :: ]]{
                last$1(lid.txt),
                --[[ [] ]]0
              },
              paths$1,
              false
            }));
    end
     end 
    lbl = lbl$3;
  end else do
    lbl = unbound_label_error(env, lid);
  end end  end 
  if (scope$1 and scope$1[0][0] == lbl) then do
    
  end else do
    prerr_warning(lid.loc, --[[ Disambiguated_name ]]Block.__(25, {lbl.lbl_name}));
  end end 
  return lbl;
end end

function disambiguate_label_by_ids(keep, env, closed, ids, labels) do
  check_ids = function (param) do
    lbls = Hashtbl.create(undefined, 8);
    __Array.iter((function (lbl) do
            return Hashtbl.add(lbls, lbl.lbl_name, --[[ () ]]0);
          end end), param[0].lbl_all);
    return List.for_all((function (param) do
                  return Hashtbl.mem(lbls, param);
                end end), ids);
  end end;
  check_closed = function (param) do
    if (closed) then do
      return List.length(ids) == #param[0].lbl_all;
    end else do
      return true;
    end end 
  end end;
  labels$prime = List.filter(check_ids)(labels);
  if (keep and labels$prime == --[[ [] ]]0) then do
    return --[[ tuple ]]{
            false,
            labels
          };
  end else do
    labels$prime$prime = List.filter(check_closed)(labels$prime);
    if (keep and labels$prime$prime == --[[ [] ]]0) then do
      return --[[ tuple ]]{
              false,
              labels$prime
            };
    end else do
      return --[[ tuple ]]{
              true,
              labels$prime$prime
            };
    end end 
  end end 
end end

function disambiguate_lid_a_list(loc, closed, env, opath, lid_a_list) do
  ids = List.map((function (param) do
          return last$1(param[0].txt);
        end end), lid_a_list);
  w_pr = do
    contents: false
  end;
  w_amb = do
    contents: --[[ [] ]]0
  end;
  w_scope = do
    contents: --[[ [] ]]0
  end;
  w_scope_ty = do
    contents: ""
  end;
  warn = function (loc, msg) do
    if (typeof msg == "number") then do
      return prerr_warning(loc, msg);
    end else do
      local ___conditional___=(msg.tag | 0);
      do
         if ___conditional___ = 8--[[ Not_principal ]] then do
            w_pr.contents = true;
            return --[[ () ]]0;end end end 
         if ___conditional___ = 23--[[ Name_out_of_scope ]] then do
            match = msg[1];
            if (match and not match[1]) then do
              w_scope.contents = --[[ :: ]]{
                match[0],
                w_scope.contents
              };
              w_scope_ty.contents = msg[0];
              return --[[ () ]]0;
            end else do
              return prerr_warning(loc, msg);
            end end end end end 
         if ___conditional___ = 24--[[ Ambiguous_name ]] then do
            match$1 = msg[0];
            if (match$1 and not match$1[1]) then do
              w_amb.contents = --[[ :: ]]{
                --[[ tuple ]]{
                  match$1[0],
                  msg[1]
                },
                w_amb.contents
              };
              return --[[ () ]]0;
            end else do
              return prerr_warning(loc, msg);
            end end end end end 
         do
        else do
          return prerr_warning(loc, msg);
          end end
          
      end
    end end 
  end end;
  process_label = function (lid) do
    scope = find_all_labels(env, lid.loc, lid.txt);
    if (opath == undefined and scope == --[[ [] ]]0) then do
      unbound_label_error(env, lid);
    end
     end 
    match;
    exit = 0;
    if (opath ~= undefined and opath[2]) then do
      match = --[[ tuple ]]{
        true,
        scope
      };
    end else do
      exit = 1;
    end end 
    if (exit == 1) then do
      match = disambiguate_label_by_ids(opath == undefined, env, closed, ids, scope);
    end
     end 
    labels = match[1];
    if (match[0]) then do
      return disambiguate(warn, undefined, scope, lid, env, opath, labels);
    end else do
      return List.hd(labels)[0];
    end end 
  end end;
  lbl_a_list = List.map((function (param) do
          lid = param[0];
          return --[[ tuple ]]{
                  lid,
                  process_label(lid),
                  param[1]
                };
        end end), lid_a_list);
  if (w_pr.contents) then do
    prerr_warning(loc, --[[ Not_principal ]]Block.__(8, {"this type-based record disambiguation"}));
  end else do
    amb = List.rev(w_amb.contents);
    if (amb) then do
      paths = List.map((function (param) do
              return get_type_path$1(env, param[1]);
            end end), lbl_a_list);
      path = List.hd(paths);
      if (List.for_all((function (param) do
                return compare_type_path(env, path, param);
              end end), List.tl(paths))) then do
        prerr_warning(loc, --[[ Ambiguous_name ]]Block.__(24, {
                List.map((function (prim) do
                        return prim[0];
                      end end), amb),
                amb[0][1],
                true
              }));
      end else do
        List.iter((function (param) do
                return prerr_warning(loc, --[[ Ambiguous_name ]]Block.__(24, {
                              --[[ :: ]]{
                                param[0],
                                --[[ [] ]]0
                              },
                              param[1],
                              false
                            }));
              end end), amb);
      end end 
    end
     end 
  end end 
  if (w_scope.contents ~= --[[ [] ]]0) then do
    prerr_warning(loc, --[[ Name_out_of_scope ]]Block.__(23, {
            w_scope_ty.contents,
            List.rev(w_scope.contents),
            true
          }));
  end
   end 
  return lbl_a_list;
end end

function find_record_qual(_param) do
  while(true) do
    param = _param;
    if (param) then do
      match = param[0][0].txt;
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 1--[[ Ldot ]] then do
            return match[0];end end end 
         if ___conditional___ = 0--[[ Lident ]]
         or ___conditional___ = 2--[[ Lapply ]] then do
            _param = param[1];
            continue ;end end end 
         do
        
      end
    end else do
      return ;
    end end 
  end;
end end

function type_label_a_list(labels, loc, closed, env, type_lbl_a, opath, lid_a_list) do
  lbl_a_list;
  exit = 0;
  if (lid_a_list) then do
    match = lid_a_list[0][0].txt;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 0--[[ Lident ]] then do
          if (labels ~= undefined) then do
            labels$1 = Caml_option.valFromOption(labels);
            if (Hashtbl.mem(labels$1, match[0])) then do
              lbl_a_list = List.map((function (param) do
                      lid = param[0];
                      match = lid.txt;
                      local ___conditional___=(match.tag | 0);
                      do
                         if ___conditional___ = 0--[[ Lident ]] then do
                            return --[[ tuple ]]{
                                    lid,
                                    Hashtbl.find(labels$1, match[0]),
                                    param[1]
                                  };end end end 
                         if ___conditional___ = 1--[[ Ldot ]]
                         or ___conditional___ = 2--[[ Lapply ]] then do
                            throw {
                                  Caml_builtin_exceptions.assert_failure,
                                  --[[ tuple ]]{
                                    "typecore.ml",
                                    819,
                                    17
                                  }
                                };end end end 
                         do
                        
                      end
                    end end), lid_a_list);
            end else do
              exit = 1;
            end end 
          end else do
            exit = 1;
          end end end else 
       if ___conditional___ = 1--[[ Ldot ]]
       or ___conditional___ = 2--[[ Lapply ]] then do
          exit = 1;end else 
       do end end end
      
    end
  end else do
    exit = 1;
  end end 
  if (exit == 1) then do
    match$1 = find_record_qual(lid_a_list);
    lid_a_list$1;
    if (match$1 ~= undefined) then do
      modname = match$1;
      lid_a_list$1 = List.map((function (lid_a) do
              lid = lid_a[0];
              match = lid.txt;
              local ___conditional___=(match.tag | 0);
              do
                 if ___conditional___ = 0--[[ Lident ]] then do
                    return --[[ tuple ]]{
                            do
                              txt: --[[ Ldot ]]Block.__(1, {
                                  modname,
                                  match[0]
                                }),
                              loc: lid.loc
                            end,
                            lid_a[1]
                          };end end end 
                 if ___conditional___ = 1--[[ Ldot ]]
                 or ___conditional___ = 2--[[ Lapply ]] then do
                    return lid_a;end end end 
                 do
                
              end
            end end), lid_a_list);
    end else do
      lid_a_list$1 = lid_a_list;
    end end 
    lbl_a_list = disambiguate_lid_a_list(loc, closed, env, opath, lid_a_list$1);
  end
   end 
  lbl_a_list$1 = List.sort((function (param, param$1) do
          return Caml_primitive.caml_int_compare(param[1].lbl_pos, param$1[1].lbl_pos);
        end end), lbl_a_list);
  return List.map(type_lbl_a, lbl_a_list$1);
end end

function check_recordpat_labels(loc, lbl_pat_list, closed) do
  if (lbl_pat_list) then do
    all = lbl_pat_list[0][1].lbl_all;
    defined = Caml_array.caml_make_vect(#all, false);
    check_defined = function (param) do
      label = param[1];
      if (Caml_array.caml_array_get(defined, label.lbl_pos)) then do
        throw {
              __Error$7,
              loc,
              empty,
              --[[ Label_multiply_defined ]]Block.__(10, {label.lbl_name})
            };
      end
       end 
      return Caml_array.caml_array_set(defined, label.lbl_pos, true);
    end end;
    List.iter(check_defined, lbl_pat_list);
    if (closed == --[[ Closed ]]0 and is_active(--[[ Non_closed_record_pattern ]]Block.__(4, {""}))) then do
      __undefined = --[[ [] ]]0;
      for i = 0 , #all - 1 | 0 , 1 do
        if (not Caml_array.caml_array_get(defined, i)) then do
          __undefined = --[[ :: ]]{
            Caml_array.caml_array_get(all, i).lbl_name,
            __undefined
          };
        end
         end 
      end
      if (__undefined ~= --[[ [] ]]0) then do
        u = __String.concat(", ", List.rev(__undefined));
        return prerr_warning(loc, --[[ Non_closed_record_pattern ]]Block.__(4, {u}));
      end else do
        return 0;
      end end 
    end else do
      return 0;
    end end 
  end else do
    return --[[ () ]]0;
  end end 
end end

type_kind$1 = "variant";

function get_type_path$2(env, d) do
  match = d.cstr_res.desc;
  if (typeof match == "number") then do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "typecore.ml",
            602,
            11
          }
        };
  end else if (match.tag == --[[ Tconstr ]]3) then do
    return match[0];
  end else do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "typecore.ml",
            602,
            11
          }
        };
  end end  end 
end end

function lookup_from_type$1(env, tpath, lid) do
  descrs = find_type_full(tpath, env)[1][0];
  mark_type_used(env, last(tpath), find_type_full(tpath, env)[0]);
  match = lid.txt;
  local ___conditional___=(match.tag | 0);
  do
     if ___conditional___ = 0--[[ Lident ]] then do
        s = match[0];
        try do
          return List.find((function (nd) do
                        return nd.cstr_name == s;
                      end end), descrs);
        end
        catch (exn)do
          if (exn == Caml_builtin_exceptions.not_found) then do
            throw {
                  __Error$7,
                  lid.loc,
                  env,
                  --[[ Wrong_name ]]Block.__(13, {
                      "",
                      newvar(undefined, --[[ () ]]0),
                      type_kind$1,
                      tpath,
                      lid.txt
                    })
                };
          end
           end 
          throw exn;
        endend end end 
     if ___conditional___ = 1--[[ Ldot ]]
     or ___conditional___ = 2--[[ Lapply ]] then do
        throw Caml_builtin_exceptions.not_found;end end end 
     do
    
  end
end end

function unique$1(eq, _acc, _param) do
  while(true) do
    param = _param;
    acc = _acc;
    if (param) then do
      rem = param[1];
      x = param[0];
      if (List.exists(Curry._1(eq, x), acc)) then do
        _param = rem;
        continue ;
      end else do
        _param = rem;
        _acc = --[[ :: ]]{
          x,
          acc
        };
        continue ;
      end end 
    end else do
      return List.rev(acc);
    end end 
  end;
end end

function ambiguous_types$1(env, lbl, others) do
  tpath = get_type_path$2(env, lbl);
  others$1 = List.map((function (param) do
          return get_type_path$2(env, param[0]);
        end end), others);
  tpaths = unique$1((function (param, param$1) do
          return compare_type_path(env, param, param$1);
        end end), --[[ :: ]]{
        tpath,
        --[[ [] ]]0
      }, others$1);
  if (tpaths and not tpaths[1]) then do
    return --[[ [] ]]0;
  end else do
    return List.map(string_of_path, tpaths);
  end end 
end end

function disambiguate_by_type$1(env, tpath, lbls) do
  check_type = function (param) do
    lbl_tpath = get_type_path$2(env, param[0]);
    return compare_type_path(env, tpath, lbl_tpath);
  end end;
  return List.find(check_type, lbls);
end end

function disambiguate$1(warnOpt, check_lkOpt, scope, lid, env, opath, lbls) do
  warn = warnOpt ~= undefined and warnOpt or prerr_warning;
  check_lk = check_lkOpt ~= undefined and check_lkOpt or (function (param, param$1) do
        return --[[ () ]]0;
      end end);
  scope$1 = scope ~= undefined and scope or lbls;
  lbl;
  if (opath ~= undefined) then do
    match = opath;
    pr = match[2];
    tpath = match[1];
    warn_pr = function (param) do
      kind = type_kind$1 == "record" and "field" or "constructor";
      return Curry._2(warn, lid.loc, --[[ Not_principal ]]Block.__(8, {"this type-based " .. (kind .. " disambiguation")}));
    end end;
    try do
      match$1 = disambiguate_by_type$1(env, tpath, scope$1);
      lbl$1 = match$1[0];
      Curry._1(match$1[1], --[[ () ]]0);
      if (not pr) then do
        if (lbls) then do
          lbl_tpath = get_type_path$2(env, lbls[0][0]);
          if (compare_type_path(env, tpath, lbl_tpath)) then do
            paths = ambiguous_types$1(env, lbl$1, lbls[1]);
            if (paths ~= --[[ [] ]]0) then do
              Curry._2(warn, lid.loc, --[[ Ambiguous_name ]]Block.__(24, {
                      --[[ :: ]]{
                        last$1(lid.txt),
                        --[[ [] ]]0
                      },
                      paths,
                      false
                    }));
            end
             end 
          end else do
            warn_pr(--[[ () ]]0);
          end end 
        end else do
          warn_pr(--[[ () ]]0);
        end end 
      end
       end 
      lbl = lbl$1;
    end
    catch (exn)do
      if (exn == Caml_builtin_exceptions.not_found) then do
        try do
          lbl$2 = lookup_from_type$1(env, tpath, lid);
          Curry._2(check_lk, tpath, lbl$2);
          s = string_of_out_ident(tree_of_path(tpath));
          Curry._2(warn, lid.loc, --[[ Name_out_of_scope ]]Block.__(23, {
                  s,
                  --[[ :: ]]{
                    last$1(lid.txt),
                    --[[ [] ]]0
                  },
                  false
                }));
          if (not pr) then do
            warn_pr(--[[ () ]]0);
          end
           end 
          lbl = lbl$2;
        end
        catch (exn$1)do
          if (exn$1 == Caml_builtin_exceptions.not_found) then do
            if (lbls == --[[ [] ]]0) then do
              lbl = unbound_constructor_error(env, lid);
            end else do
              tp_000 = match[0];
              tp_001 = expand_path(env, tpath);
              tp = --[[ tuple ]]{
                tp_000,
                tp_001
              };
              tpl = List.map((function (param) do
                      tp0 = get_type_path$2(env, param[0]);
                      tp = expand_path(env, tp0);
                      return --[[ tuple ]]{
                              tp0,
                              tp
                            };
                    end end), lbls);
              throw {
                    __Error$7,
                    lid.loc,
                    env,
                    --[[ Name_type_mismatch ]]Block.__(14, {
                        type_kind$1,
                        lid.txt,
                        tp,
                        tpl
                      })
                  };
            end end 
          end else do
            throw exn$1;
          end end 
        end
      end else do
        throw exn;
      end end 
    end
  end else if (lbls) then do
    match$2 = lbls[0];
    lbl$3 = match$2[0];
    Curry._1(match$2[1], --[[ () ]]0);
    paths$1 = ambiguous_types$1(env, lbl$3, lbls[1]);
    if (paths$1 ~= --[[ [] ]]0) then do
      Curry._2(warn, lid.loc, --[[ Ambiguous_name ]]Block.__(24, {
              --[[ :: ]]{
                last$1(lid.txt),
                --[[ [] ]]0
              },
              paths$1,
              false
            }));
    end
     end 
    lbl = lbl$3;
  end else do
    lbl = unbound_constructor_error(env, lid);
  end end  end 
  if (scope$1 and scope$1[0][0] == lbl) then do
    
  end else do
    prerr_warning(lid.loc, --[[ Disambiguated_name ]]Block.__(25, {lbl.cstr_name}));
  end end 
  return lbl;
end end

function unify_head_only(loc, env, ty, constr) do
  match = instance_constructor(undefined, constr);
  ty_res = match[1];
  match$1 = repr(ty_res).desc;
  if (typeof match$1 == "number") then do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "typecore.ml",
            892,
            9
          }
        };
  end else if (match$1.tag == --[[ Tconstr ]]3) then do
    ty_res.desc = --[[ Tconstr ]]Block.__(3, {
        match$1[0],
        List.map((function (param) do
                return newvar(undefined, --[[ () ]]0);
              end end), match$1[1]),
        match$1[2]
      });
    enforce_constraints(env, ty_res);
    return unify_pat_types(loc, env, ty_res, ty);
  end else do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "typecore.ml",
            892,
            9
          }
        };
  end end  end 
end end

function type_pat(constrs, labels, no_existentials, mode, env, sp, expected_ty) do
  type_pat$1 = function (modeOpt, envOpt) do
    mode$1 = modeOpt ~= undefined and modeOpt or mode;
    env$1 = envOpt ~= undefined and envOpt or env;
    return (function (param, param$1) do
        return type_pat(constrs, labels, no_existentials, mode$1, env$1, param, param$1);
      end end);
  end end;
  loc = sp.ppat_loc;
  match = sp.ppat_desc;
  if (typeof match == "number") then do
    return rp(do
                pat_desc: --[[ Tpat_any ]]0,
                pat_loc: loc,
                pat_extra: --[[ [] ]]0,
                pat_type: expected_ty,
                pat_env: env.contents,
                pat_attributes: sp.ppat_attributes
              end);
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 0--[[ Ppat_var ]] then do
          name = match[0];
          id = enter_variable(undefined, undefined, loc, name, expected_ty);
          return rp(do
                      pat_desc: --[[ Tpat_var ]]Block.__(0, {
                          id,
                          name
                        }),
                      pat_loc: loc,
                      pat_extra: --[[ [] ]]0,
                      pat_type: expected_ty,
                      pat_env: env.contents,
                      pat_attributes: sp.ppat_attributes
                    end);end end end 
       if ___conditional___ = 1--[[ Ppat_alias ]] then do
          name$1 = match[1];
          q = type_pat$1(undefined, undefined)(match[0], expected_ty);
          begin_def(--[[ () ]]0);
          ty_var = build_as_type(env.contents, q);
          end_def(--[[ () ]]0);
          iter_generalize$1(do
                contents: --[[ [] ]]0
              end, ty_var);
          id$1 = enter_variable(undefined, true, loc, name$1, ty_var);
          return rp(do
                      pat_desc: --[[ Tpat_alias ]]Block.__(1, {
                          q,
                          id$1,
                          name$1
                        }),
                      pat_loc: loc,
                      pat_extra: --[[ [] ]]0,
                      pat_type: q.pat_type,
                      pat_env: env.contents,
                      pat_attributes: sp.ppat_attributes
                    end);end end end 
       if ___conditional___ = 2--[[ Ppat_constant ]] then do
          cst = match[0];
          unify_pat_types(loc, env.contents, type_constant(cst), expected_ty);
          return rp(do
                      pat_desc: --[[ Tpat_constant ]]Block.__(2, {cst}),
                      pat_loc: loc,
                      pat_extra: --[[ [] ]]0,
                      pat_type: expected_ty,
                      pat_env: env.contents,
                      pat_attributes: sp.ppat_attributes
                    end);end end end 
       if ___conditional___ = 3--[[ Ppat_interval ]] then do
          match$1 = match[0];
          if (match$1.tag == --[[ Const_char ]]1) then do
            match$2 = match[1];
            if (match$2.tag == --[[ Const_char ]]1) then do
              c2 = match$2[0];
              c1 = match$1[0];
              gloc_loc_start = loc.loc_start;
              gloc_loc_end = loc.loc_end;
              gloc = do
                loc_start: gloc_loc_start,
                loc_end: gloc_loc_end,
                loc_ghost: true
              end;
              loop = function (c1, c2) do
                if (c1 == c2) then do
                  return constant(gloc, undefined, --[[ Const_char ]]Block.__(1, {c1}));
                end else do
                  return or_(gloc, undefined, constant(gloc, undefined, --[[ Const_char ]]Block.__(1, {c1})), loop(Char.chr(c1 + 1 | 0), c2));
                end end 
              end end;
              p = c1 <= c2 and loop(c1, c2) or loop(c2, c1);
              p_ppat_desc = p.ppat_desc;
              p_ppat_attributes = p.ppat_attributes;
              p$1 = do
                ppat_desc: p_ppat_desc,
                ppat_loc: loc,
                ppat_attributes: p_ppat_attributes
              end;
              return type_pat$1(undefined, undefined)(p$1, expected_ty);
            end else do
              throw {
                    __Error$7,
                    loc,
                    env.contents,
                    --[[ Invalid_interval ]]5
                  };
            end end 
          end else do
            throw {
                  __Error$7,
                  loc,
                  env.contents,
                  --[[ Invalid_interval ]]5
                };
          end end end end end 
       if ___conditional___ = 4--[[ Ppat_tuple ]] then do
          spl = match[0];
          if (List.length(spl) < 2) then do
            ill_formed_ast(loc, "Tuples must have at least 2 components.");
          end
           end 
          spl_ann = List.map((function (p) do
                  return --[[ tuple ]]{
                          p,
                          newvar(undefined, --[[ () ]]0)
                        };
                end end), spl);
          desc = --[[ Ttuple ]]Block.__(2, {List.map((function (prim) do
                      return prim[1];
                    end end), spl_ann)});
          ty = newty2(current_level.contents, desc);
          unify_pat_types(loc, env.contents, ty, expected_ty);
          pl = List.map((function (param) do
                  return type_pat$1(undefined, undefined)(param[0], param[1]);
                end end), spl_ann);
          return rp(do
                      pat_desc: --[[ Tpat_tuple ]]Block.__(3, {pl}),
                      pat_loc: loc,
                      pat_extra: --[[ [] ]]0,
                      pat_type: expected_ty,
                      pat_env: env.contents,
                      pat_attributes: sp.ppat_attributes
                    end);end end end 
       if ___conditional___ = 5--[[ Ppat_construct ]] then do
          sarg = match[1];
          lid = match[0];
          opath;
          try do
            match$3 = extract_concrete_variant(env.contents, expected_ty);
            opath = --[[ tuple ]]{
              match$3[0],
              match$3[1],
              true
            };
          end
          catch (exn)do
            if (exn == Caml_builtin_exceptions.not_found) then do
              opath = undefined;
            end else do
              throw exn;
            end end 
          end
          match$4 = lid.txt;
          constrs$1;
          exit = 0;
          local ___conditional___=(match$4.tag | 0);
          do
             if ___conditional___ = 0--[[ Lident ]] then do
                if (constrs ~= undefined) then do
                  constrs$2 = Caml_option.valFromOption(constrs);
                  s = match$4[0];
                  if (Hashtbl.mem(constrs$2, s)) then do
                    constrs$1 = --[[ :: ]]{
                      --[[ tuple ]]{
                        Hashtbl.find(constrs$2, s),
                        (function (param) do
                            return --[[ () ]]0;
                          end end)
                      },
                      --[[ [] ]]0
                    };
                  end else do
                    exit = 1;
                  end end 
                end else do
                  exit = 1;
                end end end else 
             if ___conditional___ = 1--[[ Ldot ]]
             or ___conditional___ = 2--[[ Lapply ]] then do
                exit = 1;end else 
             do end end end
            
          end
          if (exit == 1) then do
            constrs$1 = find_all_constructors(env.contents, lid.loc, lid.txt);
          end
           end 
          check_lk = function (tpath, constr) do
            if (constr.cstr_generalized) then do
              throw {
                    __Error$7,
                    lid.loc,
                    env.contents,
                    --[[ Unqualified_gadt_pattern ]]Block.__(34, {
                        tpath,
                        constr.cstr_name
                      })
                  };
            end else do
              return 0;
            end end 
          end end;
          partial_arg = env.contents;
          partial_arg$1 = check_lk;
          constr = wrap_disambiguate("This variant pattern is expected to have", expected_ty, (function (param) do
                  return disambiguate$1(undefined, partial_arg$1, undefined, lid, partial_arg, opath, param);
                end end), constrs$1);
          mark_constructor(--[[ Pattern ]]1, env.contents, last$1(lid.txt), constr);
          check_deprecated(loc, constr.cstr_attributes, constr.cstr_name);
          if (no_existentials and constr.cstr_existentials ~= --[[ [] ]]0) then do
            throw {
                  __Error$7,
                  loc,
                  env.contents,
                  --[[ Unexpected_existential ]]4
                };
          end
           end 
          if (constr.cstr_generalized) then do
            unify_head_only(loc, env.contents, expected_ty, constr);
          end
           end 
          sargs;
          if (sarg ~= undefined) then do
            sp$1 = sarg;
            match$5 = sp$1.ppat_desc;
            if (typeof match$5 == "number") then do
              if (constr.cstr_arity ~= 1) then do
                if (constr.cstr_arity == 0) then do
                  prerr_warning(sp$1.ppat_loc, --[[ Wildcard_arg_to_constant_constr ]]13);
                end
                 end 
                sargs = replicate_list(sp$1, constr.cstr_arity);
              end else do
                sargs = --[[ :: ]]{
                  sp$1,
                  --[[ [] ]]0
                };
              end end 
            end else do
              sargs = match$5.tag == --[[ Ppat_tuple ]]4 and (constr.cstr_arity > 1 or explicit_arity(sp.ppat_attributes)) and match$5[0] or --[[ :: ]]{
                  sp$1,
                  --[[ [] ]]0
                };
            end end 
          end else do
            sargs = --[[ [] ]]0;
          end end 
          if (List.length(sargs) ~= constr.cstr_arity) then do
            throw {
                  __Error$7,
                  loc,
                  env.contents,
                  --[[ Constructor_arity_mismatch ]]Block.__(1, {
                      lid.txt,
                      constr.cstr_arity,
                      List.length(sargs)
                    })
                };
          end
           end 
          match$6 = instance_constructor(--[[ tuple ]]{
                env,
                get_newtype_level$1(--[[ () ]]0)
              }, constr);
          ty_res = match$6[1];
          if (constr.cstr_generalized and mode == --[[ Normal ]]0) then do
            unify_pat_types_gadt(loc, env, ty_res, expected_ty);
          end else do
            unify_pat_types(loc, env.contents, ty_res, expected_ty);
          end end 
          args = List.map2((function (p, t) do
                  return type_pat$1(undefined, undefined)(p, t);
                end end), sargs, match$6[0]);
          return rp(do
                      pat_desc: --[[ Tpat_construct ]]Block.__(4, {
                          lid,
                          constr,
                          args
                        }),
                      pat_loc: loc,
                      pat_extra: --[[ [] ]]0,
                      pat_type: expected_ty,
                      pat_env: env.contents,
                      pat_attributes: sp.ppat_attributes
                    end);end end end 
       if ___conditional___ = 6--[[ Ppat_variant ]] then do
          sarg$1 = match[1];
          l = match[0];
          arg_type = sarg$1 ~= undefined and --[[ :: ]]{
              newvar(undefined, --[[ () ]]0),
              --[[ [] ]]0
            } or --[[ [] ]]0;
          row_row_fields = --[[ :: ]]{
            --[[ tuple ]]{
              l,
              --[[ Reither ]]Block.__(1, {
                  sarg$1 == undefined,
                  arg_type,
                  true,
                  do
                    contents: undefined
                  end
                })
            },
            --[[ [] ]]0
          };
          row_row_more = newvar(undefined, --[[ () ]]0);
          row = do
            row_fields: row_row_fields,
            row_more: row_row_more,
            row_bound: --[[ () ]]0,
            row_closed: false,
            row_fixed: false,
            row_name: undefined
          end;
          unify_pat_types(loc, env.contents, newty2(current_level.contents, --[[ Tvariant ]]Block.__(8, {row})), expected_ty);
          arg = sarg$1 ~= undefined and arg_type and not arg_type[1] and type_pat$1(undefined, undefined)(sarg$1, arg_type[0]) or undefined;
          return rp(do
                      pat_desc: --[[ Tpat_variant ]]Block.__(5, {
                          l,
                          arg,
                          do
                            contents: do
                              row_fields: row_row_fields,
                              row_more: newvar(undefined, --[[ () ]]0),
                              row_bound: --[[ () ]]0,
                              row_closed: false,
                              row_fixed: false,
                              row_name: undefined
                            end
                          end
                        }),
                      pat_loc: loc,
                      pat_extra: --[[ [] ]]0,
                      pat_type: expected_ty,
                      pat_env: env.contents,
                      pat_attributes: sp.ppat_attributes
                    end);end end end 
       if ___conditional___ = 7--[[ Ppat_record ]] then do
          closed = match[1];
          lid_sp_list = match[0];
          if (lid_sp_list == --[[ [] ]]0) then do
            ill_formed_ast(loc, "Records cannot be empty.");
          end
           end 
          match$7;
          try do
            match$8 = extract_concrete_record(env.contents, expected_ty);
            match$7 = --[[ tuple ]]{
              --[[ tuple ]]{
                match$8[0],
                match$8[1],
                true
              },
              expected_ty
            };
          end
          catch (exn$1)do
            if (exn$1 == Caml_builtin_exceptions.not_found) then do
              match$7 = --[[ tuple ]]{
                undefined,
                newvar(undefined, --[[ () ]]0)
              };
            end else do
              throw exn$1;
            end end 
          end
          record_ty = match$7[1];
          opath$1 = match$7[0];
          type_label_pat = function (param) do
            label = param[1];
            label_lid = param[0];
            begin_def(--[[ () ]]0);
            match = instance_label(false, label);
            ty_arg = match[1];
            vars = match[0];
            if (vars == --[[ [] ]]0) then do
              end_def(--[[ () ]]0);
            end
             end 
            try do
              unify_pat_types(loc, env.contents, match[2], record_ty);
            end
            catch (raw_exn)do
              exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn[0] == Unify) then do
                throw {
                      __Error$7,
                      label_lid.loc,
                      env.contents,
                      --[[ Label_mismatch ]]Block.__(2, {
                          label_lid.txt,
                          exn[1]
                        })
                    };
              end
               end 
              throw exn;
            end
            arg = type_pat$1(undefined, undefined)(param[2], ty_arg);
            if (vars ~= --[[ [] ]]0) then do
              end_def(--[[ () ]]0);
              iter_generalize$1(do
                    contents: --[[ [] ]]0
                  end, ty_arg);
              List.iter(generalize, vars);
              instantiated = function (tv) do
                tv$1 = expand_head(env.contents, tv);
                if (is_Tvar(tv$1)) then do
                  return tv$1.level ~= 100000000;
                end else do
                  return true;
                end end 
              end end;
              if (List.exists(instantiated, vars)) then do
                throw {
                      __Error$7,
                      label_lid.loc,
                      env.contents,
                      --[[ Polymorphic_label ]]Block.__(0, {label_lid.txt})
                    };
              end
               end 
            end
             end 
            return --[[ tuple ]]{
                    label_lid,
                    label,
                    arg
                  };
          end end;
          partial_arg$2 = env.contents;
          lbl_pat_list = wrap_disambiguate("This record pattern is expected to have", expected_ty, (function (param) do
                  return type_label_a_list(labels, loc, false, partial_arg$2, type_label_pat, opath$1, param);
                end end), lid_sp_list);
          check_recordpat_labels(loc, lbl_pat_list, closed);
          unify_pat_types(loc, env.contents, record_ty, expected_ty);
          return rp(do
                      pat_desc: --[[ Tpat_record ]]Block.__(6, {
                          lbl_pat_list,
                          closed
                        }),
                      pat_loc: loc,
                      pat_extra: --[[ [] ]]0,
                      pat_type: expected_ty,
                      pat_env: env.contents,
                      pat_attributes: sp.ppat_attributes
                    end);end end end 
       if ___conditional___ = 8--[[ Ppat_array ]] then do
          ty_elt = newvar(undefined, --[[ () ]]0);
          unify_pat_types(loc, env.contents, instance_def(type_array(ty_elt)), expected_ty);
          spl_ann$1 = List.map((function (p) do
                  return --[[ tuple ]]{
                          p,
                          newvar(undefined, --[[ () ]]0)
                        };
                end end), match[0]);
          pl$1 = List.map((function (param) do
                  return type_pat$1(undefined, undefined)(param[0], ty_elt);
                end end), spl_ann$1);
          return rp(do
                      pat_desc: --[[ Tpat_array ]]Block.__(7, {pl$1}),
                      pat_loc: loc,
                      pat_extra: --[[ [] ]]0,
                      pat_type: expected_ty,
                      pat_env: env.contents,
                      pat_attributes: sp.ppat_attributes
                    end);end end end 
       if ___conditional___ = 9--[[ Ppat_or ]] then do
          initial_pattern_variables = pattern_variables.contents;
          p1 = type_pat$1(--[[ Inside_or ]]1, undefined)(match[0], expected_ty);
          p1_variables = pattern_variables.contents;
          pattern_variables.contents = initial_pattern_variables;
          p2 = type_pat$1(--[[ Inside_or ]]1, undefined)(match[1], expected_ty);
          p2_variables = pattern_variables.contents;
          alpha_env = enter_orpat_variables(loc, env.contents, p1_variables, p2_variables);
          pattern_variables.contents = p1_variables;
          return rp(do
                      pat_desc: --[[ Tpat_or ]]Block.__(8, {
                          p1,
                          alpha_pat(alpha_env, p2),
                          undefined
                        }),
                      pat_loc: loc,
                      pat_extra: --[[ [] ]]0,
                      pat_type: expected_ty,
                      pat_env: env.contents,
                      pat_attributes: sp.ppat_attributes
                    end);end end end 
       if ___conditional___ = 10--[[ Ppat_constraint ]] then do
          sp$2 = match[0];
          match$9 = sp$2.ppat_desc;
          exit$1 = 0;
          if (typeof match$9 == "number" or match$9.tag) then do
            exit$1 = 1;
          end else do
            sty = match[1];
            tmp = sty.ptyp_desc;
            if (typeof tmp == "number" or tmp.tag ~= --[[ Ptyp_poly ]]8) then do
              exit$1 = 1;
            end else do
              lloc = sp$2.ppat_loc;
              name$2 = match$9[0];
              match$10 = transl_simple_type_delayed(env.contents, sty);
              cty = match$10[0];
              ty$1 = cty.ctyp_type;
              unify_pat_types(lloc, env.contents, ty$1, expected_ty);
              pattern_force.contents = --[[ :: ]]{
                match$10[1],
                pattern_force.contents
              };
              match$11 = ty$1.desc;
              if (typeof match$11 == "number") then do
                throw {
                      Caml_builtin_exceptions.assert_failure,
                      --[[ tuple ]]{
                        "typecore.ml",
                        955,
                        13
                      }
                    };
              end else if (match$11.tag == --[[ Tpoly ]]10) then do
                begin_def(--[[ () ]]0);
                match$12 = instance_poly(true, false, match$11[1], match$11[0]);
                ty$prime = match$12[1];
                end_def(--[[ () ]]0);
                iter_generalize$1(do
                      contents: --[[ [] ]]0
                    end, ty$prime);
                id$2 = enter_variable(undefined, undefined, lloc, name$2, ty$prime);
                return rp(do
                            pat_desc: --[[ Tpat_var ]]Block.__(0, {
                                id$2,
                                name$2
                              }),
                            pat_loc: lloc,
                            pat_extra: --[[ :: ]]{
                              --[[ tuple ]]{
                                --[[ Tpat_constraint ]]Block.__(0, {cty}),
                                loc,
                                sp.ppat_attributes
                              },
                              --[[ [] ]]0
                            },
                            pat_type: ty$1,
                            pat_env: env.contents,
                            pat_attributes: --[[ [] ]]0
                          end);
              end else do
                throw {
                      Caml_builtin_exceptions.assert_failure,
                      --[[ tuple ]]{
                        "typecore.ml",
                        955,
                        13
                      }
                    };
              end end  end 
            end end 
          end end 
          if (exit$1 == 1) then do
            begin_def(--[[ () ]]0);
            match$13 = transl_simple_type_delayed(env.contents, match[1]);
            cty$1 = match$13[0];
            ty$2 = cty$1.ctyp_type;
            end_def(--[[ () ]]0);
            generalize_structure$1(current_level.contents, ty$2);
            match_000 = instance(undefined, env.contents, ty$2);
            match_001 = instance(undefined, env.contents, ty$2);
            ty$3 = match_000;
            unify_pat_types(loc, env.contents, ty$3, expected_ty);
            p$2 = type_pat$1(undefined, undefined)(sp$2, match_001);
            pattern_force.contents = --[[ :: ]]{
              match$13[1],
              pattern_force.contents
            };
            extra_000 = --[[ Tpat_constraint ]]Block.__(0, {cty$1});
            extra_002 = sp$2.ppat_attributes;
            extra = --[[ tuple ]]{
              extra_000,
              loc,
              extra_002
            };
            match$14 = p$2.pat_desc;
            if (typeof match$14 ~= "number" and not match$14.tag) then do
              return do
                      pat_desc: --[[ Tpat_alias ]]Block.__(1, {
                          do
                            pat_desc: --[[ Tpat_any ]]0,
                            pat_loc: p$2.pat_loc,
                            pat_extra: p$2.pat_extra,
                            pat_type: p$2.pat_type,
                            pat_env: p$2.pat_env,
                            pat_attributes: --[[ [] ]]0
                          end,
                          match$14[0],
                          match$14[1]
                        }),
                      pat_loc: p$2.pat_loc,
                      pat_extra: --[[ :: ]]{
                        extra,
                        --[[ [] ]]0
                      },
                      pat_type: ty$3,
                      pat_env: p$2.pat_env,
                      pat_attributes: p$2.pat_attributes
                    end;
            end
             end 
            return do
                    pat_desc: p$2.pat_desc,
                    pat_loc: p$2.pat_loc,
                    pat_extra: --[[ :: ]]{
                      extra,
                      p$2.pat_extra
                    },
                    pat_type: ty$3,
                    pat_env: p$2.pat_env,
                    pat_attributes: p$2.pat_attributes
                  end;
          end
           end end else 
       if ___conditional___ = 11--[[ Ppat_type ]] then do
          lid$1 = match[0];
          match$15 = build_or_pat(env.contents, loc, lid$1.txt);
          p$3 = match$15[1];
          unify_pat_types(loc, env.contents, match$15[2], expected_ty);
          return do
                  pat_desc: p$3.pat_desc,
                  pat_loc: p$3.pat_loc,
                  pat_extra: --[[ :: ]]{
                    --[[ tuple ]]{
                      --[[ Tpat_type ]]Block.__(1, {
                          match$15[0],
                          lid$1
                        }),
                      loc,
                      sp.ppat_attributes
                    },
                    p$3.pat_extra
                  },
                  pat_type: p$3.pat_type,
                  pat_env: p$3.pat_env,
                  pat_attributes: p$3.pat_attributes
                end;end end end 
       if ___conditional___ = 12--[[ Ppat_lazy ]] then do
          nv = newvar(undefined, --[[ () ]]0);
          unify_pat_types(loc, env.contents, instance_def(type_lazy_t(nv)), expected_ty);
          p1$1 = type_pat$1(undefined, undefined)(match[0], nv);
          return rp(do
                      pat_desc: --[[ Tpat_lazy ]]Block.__(9, {p1$1}),
                      pat_loc: loc,
                      pat_extra: --[[ [] ]]0,
                      pat_type: expected_ty,
                      pat_env: env.contents,
                      pat_attributes: sp.ppat_attributes
                    end);end end end 
       if ___conditional___ = 13--[[ Ppat_unpack ]] then do
          name$3 = match[0];
          id$3 = enter_variable(true, undefined, loc, name$3, expected_ty);
          return rp(do
                      pat_desc: --[[ Tpat_var ]]Block.__(0, {
                          id$3,
                          name$3
                        }),
                      pat_loc: sp.ppat_loc,
                      pat_extra: --[[ :: ]]{
                        --[[ tuple ]]{
                          --[[ Tpat_unpack ]]0,
                          loc,
                          sp.ppat_attributes
                        },
                        --[[ [] ]]0
                      },
                      pat_type: expected_ty,
                      pat_env: env.contents,
                      pat_attributes: --[[ [] ]]0
                    end);end end end 
       if ___conditional___ = 14--[[ Ppat_exception ]] then do
          throw {
                __Error$7,
                loc,
                env.contents,
                --[[ Exception_pattern_below_toplevel ]]8
              };end end end 
       if ___conditional___ = 15--[[ Ppat_extension ]] then do
          throw {
                Error_forward$1,
                error_of_extension(match[0])
              };end end end 
       do
      
    end
  end end 
end end

function type_pat$1(allow_existentialsOpt, constrs, labels, levOpt, env, sp, expected_ty) do
  allow_existentials = allow_existentialsOpt ~= undefined and allow_existentialsOpt or false;
  lev = levOpt ~= undefined and levOpt or current_level.contents;
  newtype_level$1.contents = lev;
  try do
    r = type_pat(constrs, labels, not allow_existentials, --[[ Normal ]]0, env, sp, expected_ty);
    iter_pattern((function (p) do
            p.pat_env = env.contents;
            return --[[ () ]]0;
          end end), r);
    newtype_level$1.contents = undefined;
    return r;
  end
  catch (e)do
    newtype_level$1.contents = undefined;
    throw e;
  end
end end

function partial_pred(lev, env, expected_ty, constrs, labels, p) do
  snap = snapshot(--[[ () ]]0);
  try do
    reset_pattern(undefined, true);
    typed_p = type_pat$1(true, Caml_option.some(constrs), Caml_option.some(labels), lev, do
          contents: env
        end, p, expected_ty);
    backtrack(snap);
    return typed_p;
  end
  catch (exn)do
    backtrack(snap);
    return ;
  end
end end

function check_partial$1(levOpt, env, expected_ty) do
  lev = levOpt ~= undefined and levOpt or current_level.contents;
  return (function (param, param$1) do
      pred = function (param, param$1, param$2) do
        return partial_pred(lev, env, expected_ty, param, param$1, param$2);
      end end;
      loc = param;
      casel = param$1;
      first_check = check_partial(loc, casel);
      if (first_check) then do
        return check_partial_param((function (param, param$1, param$2) do
                      pred$1 = pred;
                      loc = param;
                      casel = param$1;
                      pss = param$2;
                      return do_check_partial(pred$1, exhaust_gadt$1, loc, casel, pss);
                    end end), do_check_fragile_gadt, loc, casel);
      end else do
        return --[[ Partial ]]0;
      end end 
    end end);
end end

function add_pattern_variables(check, check_as, env) do
  pv = get_ref(pattern_variables);
  return --[[ tuple ]]{
          List.fold_right((function (param, env) do
                  check$1 = param[4] and check_as or check;
                  return add_value(check$1, param[0], do
                              val_type: param[1],
                              val_kind: --[[ Val_reg ]]0,
                              val_loc: param[3],
                              val_attributes: --[[ [] ]]0
                            end, env);
                end end), pv, env),
          get_ref(module_variables)
        };
end end

function type_pattern(lev, env, spat, scope, expected_ty) do
  reset_pattern(scope, true);
  new_env = do
    contents: env
  end;
  pat = type_pat$1(true, undefined, undefined, lev, new_env, spat, expected_ty);
  match = add_pattern_variables((function (s) do
          return --[[ Unused_var_strict ]]Block.__(13, {s});
        end end), (function (s) do
          return --[[ Unused_var ]]Block.__(12, {s});
        end end), new_env.contents);
  return --[[ tuple ]]{
          pat,
          match[0],
          get_ref(pattern_force),
          match[1]
        };
end end

function type_pattern_list(env, spatl, scope, expected_tys, allow) do
  reset_pattern(scope, allow);
  new_env = do
    contents: env
  end;
  patl = List.map2((function (param, param$1) do
          return type_pat$1(undefined, undefined, undefined, undefined, new_env, param, param$1);
        end end), spatl, expected_tys);
  match = add_pattern_variables(undefined, undefined, new_env.contents);
  return --[[ tuple ]]{
          patl,
          match[0],
          get_ref(pattern_force),
          match[1]
        };
end end

function type_class_arg_pattern(cl_num, val_env, met_env, l, spat) do
  reset_pattern(undefined, false);
  nv = newvar(undefined, --[[ () ]]0);
  pat = type_pat$1(undefined, undefined, undefined, undefined, do
        contents: val_env
      end, spat, nv);
  if (has_variants(pat)) then do
    pressure_variants$1(val_env, --[[ :: ]]{
          pat,
          --[[ [] ]]0
        });
    iter_pattern(finalize_variant, pat);
  end
   end 
  List.iter((function (f) do
          return Curry._1(f, --[[ () ]]0);
        end end), get_ref(pattern_force));
  if (is_optional(l)) then do
    unify_pat(val_env, pat, type_option$1(newvar(undefined, --[[ () ]]0)));
  end
   end 
  match = List.fold_right((function (param, param$1) do
          as_var = param[4];
          ty = param[1];
          id = param[0];
          check = function (s) do
            if (as_var) then do
              return --[[ Unused_var ]]Block.__(12, {s});
            end else do
              return --[[ Unused_var_strict ]]Block.__(13, {s});
            end end 
          end end;
          id$prime = create(id.name);
          return --[[ tuple ]]{
                  --[[ :: ]]{
                    --[[ tuple ]]{
                      id$prime,
                      param[2],
                      id,
                      ty
                    },
                    param$1[0]
                  },
                  add_value(check, id$prime, do
                        val_type: ty,
                        val_kind: --[[ Val_ivar ]]Block.__(1, {
                            --[[ Immutable ]]0,
                            cl_num
                          }),
                        val_loc: param[3],
                        val_attributes: --[[ [] ]]0
                      end, param$1[1])
                };
        end end), pattern_variables.contents, --[[ tuple ]]{
        --[[ [] ]]0,
        met_env
      });
  match$1 = add_pattern_variables(undefined, undefined, val_env);
  return --[[ tuple ]]{
          pat,
          match[0],
          match$1[0],
          match[1]
        };
end end

function type_self_pattern(cl_num, privty, val_env, met_env, par_env, spat) do
  spat$1 = mk$1(undefined, undefined, --[[ Ppat_alias ]]Block.__(1, {
          mk$1(undefined, undefined, --[[ Ppat_alias ]]Block.__(1, {
                  spat,
                  do
                    txt: "selfpat-*",
                    loc: none
                  end
                })),
          do
            txt: "selfpat-" .. cl_num,
            loc: none
          end
        }));
  reset_pattern(undefined, false);
  nv = newvar(undefined, --[[ () ]]0);
  pat = type_pat$1(undefined, undefined, undefined, undefined, do
        contents: val_env
      end, spat$1, nv);
  List.iter((function (f) do
          return Curry._1(f, --[[ () ]]0);
        end end), get_ref(pattern_force));
  meths = do
    contents: --[[ Empty ]]0
  end;
  vars = do
    contents: --[[ Empty ]]0
  end;
  pv = pattern_variables.contents;
  pattern_variables.contents = --[[ [] ]]0;
  match = List.fold_right((function (param, param$1) do
          as_var = param[4];
          loc = param[3];
          ty = param[1];
          id = param[0];
          return --[[ tuple ]]{
                  add_value(undefined, id, do
                        val_type: ty,
                        val_kind: --[[ Val_unbound ]]1,
                        val_loc: loc,
                        val_attributes: --[[ [] ]]0
                      end, param$1[0]),
                  add_value((function (s) do
                          if (as_var) then do
                            return --[[ Unused_var ]]Block.__(12, {s});
                          end else do
                            return --[[ Unused_var_strict ]]Block.__(13, {s});
                          end end 
                        end end), id, do
                        val_type: ty,
                        val_kind: --[[ Val_self ]]Block.__(2, {
                            meths,
                            vars,
                            cl_num,
                            privty
                          }),
                        val_loc: loc,
                        val_attributes: --[[ [] ]]0
                      end, param$1[1]),
                  add_value(undefined, id, do
                        val_type: ty,
                        val_kind: --[[ Val_unbound ]]1,
                        val_loc: loc,
                        val_attributes: --[[ [] ]]0
                      end, param$1[2])
                };
        end end), pv, --[[ tuple ]]{
        val_env,
        met_env,
        par_env
      });
  return --[[ tuple ]]{
          pat,
          meths,
          vars,
          match[0],
          match[1],
          match[2]
        };
end end

delayed_checks = do
  contents: --[[ [] ]]0
end;

function add_delayed_check(f) do
  delayed_checks.contents = --[[ :: ]]{
    --[[ tuple ]]{
      f,
      current.contents
    },
    delayed_checks.contents
  };
  return --[[ () ]]0;
end end

function force_delayed_checks(param) do
  snap = snapshot(--[[ () ]]0);
  w_old = current.contents;
  List.iter((function (param) do
          current.contents = param[1];
          return Curry._1(param[0], --[[ () ]]0);
        end end), List.rev(delayed_checks.contents));
  current.contents = w_old;
  delayed_checks.contents = --[[ [] ]]0;
  return backtrack(snap);
end end

function final_subexpression(_sexp) do
  while(true) do
    sexp = _sexp;
    match = sexp.pexp_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 2--[[ Pexp_let ]] then do
          _sexp = match[2];
          continue ;end end end 
       if ___conditional___ = 6--[[ Pexp_match ]] then do
          match$1 = match[1];
          if (match$1) then do
            _sexp = match$1[0].pc_rhs;
            continue ;
          end else do
            return sexp;
          end end end end end 
       if ___conditional___ = 7--[[ Pexp_try ]] then do
          _sexp = match[0];
          continue ;end end end 
       if ___conditional___ = 15--[[ Pexp_ifthenelse ]]
       or ___conditional___ = 16--[[ Pexp_sequence ]] then do
          _sexp = match[1];
          continue ;end end end 
       do
      else do
        return sexp;
        end end
        
    end
  end;
end end

function is_nonexpansive(_exp) do
  while(true) do
    exp = _exp;
    match = exp.exp_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 2--[[ Texp_let ]] then do
          if (List.for_all((function (vb) do
                    return is_nonexpansive(vb.vb_expr);
                  end end), match[1])) then do
            _exp = match[2];
            continue ;
          end else do
            return false;
          end end end end end 
       if ___conditional___ = 0--[[ Texp_ident ]]
       or ___conditional___ = 1--[[ Texp_constant ]]
       or ___conditional___ = 3--[[ Texp_function ]] then do
          return true;end end end 
       if ___conditional___ = 4--[[ Texp_apply ]] then do
          match$1 = match[1];
          if (match$1 and not (match$1[0][1] ~= undefined or not is_nonexpansive(match[0]))) then do
            return List.for_all(is_nonexpansive_opt, List.map(snd3, match$1[1]));
          end else do
            return false;
          end end end end end 
       if ___conditional___ = 5--[[ Texp_match ]] then do
          if (match[2] or not is_nonexpansive(match[0])) then do
            return false;
          end else do
            return List.for_all((function (param) do
                          if (is_nonexpansive_opt(param.c_guard)) then do
                            return is_nonexpansive(param.c_rhs);
                          end else do
                            return false;
                          end end 
                        end end), match[1]);
          end end end end end 
       if ___conditional___ = 7--[[ Texp_tuple ]] then do
          return List.for_all(is_nonexpansive, match[0]);end end end 
       if ___conditional___ = 8--[[ Texp_construct ]] then do
          return List.for_all(is_nonexpansive, match[2]);end end end 
       if ___conditional___ = 9--[[ Texp_variant ]] then do
          return is_nonexpansive_opt(match[1]);end end end 
       if ___conditional___ = 10--[[ Texp_record ]] then do
          if (List.for_all((function (param) do
                    return param[1].lbl_mut == --[[ Immutable ]]0 and is_nonexpansive(param[2]) or false;
                  end end), match[0])) then do
            return is_nonexpansive_opt(match[1]);
          end else do
            return false;
          end end end end end 
       if ___conditional___ = 13--[[ Texp_array ]] then do
          if (match[0]) then do
            return false;
          end else do
            return true;
          end end end end end 
       if ___conditional___ = 14--[[ Texp_ifthenelse ]] then do
          if (is_nonexpansive(match[1])) then do
            return is_nonexpansive_opt(match[2]);
          end else do
            return false;
          end end end end end 
       if ___conditional___ = 15--[[ Texp_sequence ]] then do
          _exp = match[1];
          continue ;end end end 
       if ___conditional___ = 19--[[ Texp_new ]] then do
          return class_type_arity(match[2].cty_type) > 0;end end end 
       if ___conditional___ = 23--[[ Texp_letmodule ]] then do
          if (is_nonexpansive_mod(match[2])) then do
            _exp = match[3];
            continue ;
          end else do
            return false;
          end end end end end 
       if ___conditional___ = 11--[[ Texp_field ]]
       or ___conditional___ = 25--[[ Texp_lazy ]] then do
          _exp = match[0];
          continue ;end end end 
       if ___conditional___ = 26--[[ Texp_object ]] then do
          match$2 = match[0];
          count = do
            contents: 0
          end;
          if (List.for_all((function(count)do
                return function (field) do
                  match = field.cf_desc;
                  local ___conditional___=(match.tag | 0);
                  do
                     if ___conditional___ = 0--[[ Tcf_inherit ]] then do
                        return false;end end end 
                     if ___conditional___ = 1--[[ Tcf_val ]] then do
                        match$1 = match[3];
                        count.contents = count.contents + 1 | 0;
                        return match$1.tag and is_nonexpansive(match$1[1]) or true;end end end 
                     if ___conditional___ = 4--[[ Tcf_initializer ]] then do
                        return is_nonexpansive(match[0]);end end end 
                     do
                    else do
                      return true;
                      end end
                      
                  end
                end end
                end(count)), match$2.cstr_fields) and fold((function(count)do
                return function (param, param$1, b) do
                  count.contents = count.contents - 1 | 0;
                  return b and param$1[0] == --[[ Immutable ]]0 or false;
                end end
                end(count)), match$2.cstr_type.csig_vars, true)) then do
            return count.contents == 0;
          end else do
            return false;
          end end end end end 
       if ___conditional___ = 27--[[ Texp_pack ]] then do
          return is_nonexpansive_mod(match[0]);end end end 
       do
      else do
        return false;
        end end
        
    end
  end;
end end

function is_nonexpansive_mod(_mexp) do
  while(true) do
    mexp = _mexp;
    match = mexp.mod_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 1--[[ Tmod_structure ]] then do
          return List.for_all((function (item) do
                        match = item.str_desc;
                        local ___conditional___=(match.tag | 0);
                        do
                           if ___conditional___ = 1--[[ Tstr_value ]] then do
                              return List.for_all((function (vb) do
                                            return is_nonexpansive(vb.vb_expr);
                                          end end), match[1]);end end end 
                           if ___conditional___ = 4--[[ Tstr_typext ]] then do
                              return List.for_all((function (param) do
                                            if (param.ext_kind.tag) then do
                                              return true;
                                            end else do
                                              return false;
                                            end end 
                                          end end), match[0].tyext_constructors);end end end 
                           if ___conditional___ = 5--[[ Tstr_exception ]] then do
                              if (match[0].ext_kind.tag) then do
                                return true;
                              end else do
                                return false;
                              end end end end end 
                           if ___conditional___ = 6--[[ Tstr_module ]] then do
                              return is_nonexpansive_mod(match[0].mb_expr);end end end 
                           if ___conditional___ = 7--[[ Tstr_recmodule ]] then do
                              return List.for_all((function (param) do
                                            return is_nonexpansive_mod(param.mb_expr);
                                          end end), match[0]);end end end 
                           if ___conditional___ = 10--[[ Tstr_class ]] then do
                              return false;end end end 
                           if ___conditional___ = 12--[[ Tstr_include ]] then do
                              return is_nonexpansive_mod(match[0].incl_mod);end end end 
                           if ___conditional___ = 13--[[ Tstr_attribute ]] then do
                              return true;end end end 
                           do
                          else do
                            return true;
                            end end
                            
                        end
                      end end), match[0].str_items);end end end 
       if ___conditional___ = 0--[[ Tmod_ident ]]
       or ___conditional___ = 2--[[ Tmod_functor ]] then do
          return true;end end end 
       if ___conditional___ = 3--[[ Tmod_apply ]] then do
          return false;end end end 
       if ___conditional___ = 4--[[ Tmod_constraint ]] then do
          _mexp = match[0];
          continue ;end end end 
       if ___conditional___ = 5--[[ Tmod_unpack ]] then do
          return is_nonexpansive(match[0]);end end end 
       do
      
    end
  end;
end end

function is_nonexpansive_opt(param) do
  if (param ~= undefined) then do
    return is_nonexpansive(param);
  end else do
    return true;
  end end 
end end

function approx_type(env, _sty) do
  while(true) do
    sty = _sty;
    match = sty.ptyp_desc;
    if (typeof match == "number") then do
      return newvar(undefined, --[[ () ]]0);
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 1--[[ Ptyp_arrow ]] then do
            p = match[0];
            ty1 = is_optional(p) and type_option$1(newvar(undefined, --[[ () ]]0)) or newvar(undefined, --[[ () ]]0);
            desc_002 = approx_type(env, match[2]);
            desc = --[[ Tarrow ]]Block.__(1, {
                p,
                ty1,
                desc_002,
                --[[ Cok ]]0
              });
            return newty2(current_level.contents, desc);end end end 
         if ___conditional___ = 2--[[ Ptyp_tuple ]] then do
            desc$1 = --[[ Ttuple ]]Block.__(2, {List.map((function (param) do
                        return approx_type(env, param);
                      end end), match[0])});
            return newty2(current_level.contents, desc$1);end end end 
         if ___conditional___ = 3--[[ Ptyp_constr ]] then do
            ctl = match[1];
            try do
              match$1 = lookup_type$1(match[0].txt, env);
              if (List.length(ctl) ~= match$1[1].type_arity) then do
                throw Caml_builtin_exceptions.not_found;
              end
               end 
              tyl = List.map((function (param) do
                      return approx_type(env, param);
                    end end), ctl);
              return newconstr(match$1[0], tyl);
            end
            catch (exn)do
              if (exn == Caml_builtin_exceptions.not_found) then do
                return newvar(undefined, --[[ () ]]0);
              end else do
                throw exn;
              end end 
            endend end end 
         if ___conditional___ = 8--[[ Ptyp_poly ]] then do
            _sty = match[1];
            continue ;end end end 
         do
        else do
          return newvar(undefined, --[[ () ]]0);
          end end
          
      end
    end end 
  end;
end end

function type_approx(env, _sexp) do
  while(true) do
    sexp = _sexp;
    match = sexp.pexp_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 2--[[ Pexp_let ]] then do
          _sexp = match[2];
          continue ;end end end 
       if ___conditional___ = 3--[[ Pexp_function ]] then do
          match$1 = match[0];
          if (match$1) then do
            desc_001 = newvar(undefined, --[[ () ]]0);
            desc_002 = type_approx(env, match$1[0].pc_rhs);
            desc = --[[ Tarrow ]]Block.__(1, {
                "",
                desc_001,
                desc_002,
                --[[ Cok ]]0
              });
            return newty2(current_level.contents, desc);
          end else do
            return newvar(undefined, --[[ () ]]0);
          end end end end end 
       if ___conditional___ = 4--[[ Pexp_fun ]] then do
          e = match[3];
          p = match[0];
          if (is_optional(p)) then do
            desc_001$1 = type_option$1(newvar(undefined, --[[ () ]]0));
            desc_002$1 = type_approx(env, e);
            desc$1 = --[[ Tarrow ]]Block.__(1, {
                p,
                desc_001$1,
                desc_002$1,
                --[[ Cok ]]0
              });
            return newty2(current_level.contents, desc$1);
          end else do
            desc_001$2 = newvar(undefined, --[[ () ]]0);
            desc_002$2 = type_approx(env, e);
            desc$2 = --[[ Tarrow ]]Block.__(1, {
                p,
                desc_001$2,
                desc_002$2,
                --[[ Cok ]]0
              });
            return newty2(current_level.contents, desc$2);
          end end end end end 
       if ___conditional___ = 6--[[ Pexp_match ]] then do
          match$2 = match[1];
          if (match$2) then do
            _sexp = match$2[0].pc_rhs;
            continue ;
          end else do
            return newvar(undefined, --[[ () ]]0);
          end end end end end 
       if ___conditional___ = 7--[[ Pexp_try ]] then do
          _sexp = match[0];
          continue ;end end end 
       if ___conditional___ = 8--[[ Pexp_tuple ]] then do
          desc$3 = --[[ Ttuple ]]Block.__(2, {List.map((function (param) do
                      return type_approx(env, param);
                    end end), match[0])});
          return newty2(current_level.contents, desc$3);end end end 
       if ___conditional___ = 15--[[ Pexp_ifthenelse ]]
       or ___conditional___ = 16--[[ Pexp_sequence ]] then do
          _sexp = match[1];
          continue ;end end end 
       if ___conditional___ = 19--[[ Pexp_constraint ]] then do
          ty = type_approx(env, match[0]);
          ty1 = approx_type(env, match[1]);
          try do
            unify$2(env, ty, ty1);
          end
          catch (raw_exn)do
            exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn[0] == Unify) then do
              throw {
                    __Error$7,
                    sexp.pexp_loc,
                    env,
                    --[[ Expr_type_clash ]]Block.__(7, {exn[1]})
                  };
            end
             end 
            throw exn;
          end
          return ty1;end end end 
       if ___conditional___ = 20--[[ Pexp_coerce ]] then do
          approx_ty_opt = function (param) do
            if (param ~= undefined) then do
              return approx_type(env, param);
            end else do
              return newvar(undefined, --[[ () ]]0);
            end end 
          end end;
          ty$1 = type_approx(env, match[0]);
          ty1$1 = approx_ty_opt(match[1]);
          ty2 = approx_type(env, match[2]);
          try do
            unify$2(env, ty$1, ty1$1);
          end
          catch (raw_exn$1)do
            exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
            if (exn$1[0] == Unify) then do
              throw {
                    __Error$7,
                    sexp.pexp_loc,
                    env,
                    --[[ Expr_type_clash ]]Block.__(7, {exn$1[1]})
                  };
            end
             end 
            throw exn$1;
          end
          return ty2;end end end 
       do
      else do
        return newvar(undefined, --[[ () ]]0);
        end end
        
    end
  end;
end end

function list_labels(env, ty) do
  return wrap_trace_gadt_instances(env, (function (param) do
                env$1 = env;
                _visited = --[[ [] ]]0;
                _ls = --[[ [] ]]0;
                _ty_fun = param;
                while(true) do
                  ty_fun = _ty_fun;
                  ls = _ls;
                  visited = _visited;
                  ty = expand_head(env$1, ty_fun);
                  if (List.memq(ty, visited)) then do
                    return --[[ tuple ]]{
                            List.rev(ls),
                            false
                          };
                  end else do
                    match = ty.desc;
                    if (typeof match == "number" or match.tag ~= --[[ Tarrow ]]1) then do
                      return --[[ tuple ]]{
                              List.rev(ls),
                              is_Tvar(ty)
                            };
                    end else do
                      _ty_fun = match[2];
                      _ls = --[[ :: ]]{
                        match[0],
                        ls
                      };
                      _visited = --[[ :: ]]{
                        ty,
                        visited
                      };
                      continue ;
                    end end 
                  end end 
                end;
              end end), ty);
end end

function check_univars(env, expans, kind, exp, ty_expected, vars) do
  if (expans and not is_nonexpansive(exp)) then do
    generalize_expansive$1(env, exp.exp_type);
  end
   end 
  vars$1 = List.map((function (param) do
          return expand_head(env, param);
        end end), vars);
  vars$2 = List.map((function (param) do
          return expand_head(env, param);
        end end), vars$1);
  vars$prime = List.filter((function (t) do
            t$1 = repr(t);
            iter_generalize$1(do
                  contents: --[[ [] ]]0
                end, t$1);
            match = t$1.desc;
            if (typeof match == "number" or match.tag or t$1.level ~= 100000000) then do
              return false;
            end else do
              log_type(t$1);
              t$1.desc = --[[ Tunivar ]]Block.__(9, {match[0]});
              return true;
            end end 
          end end))(vars$2);
  if (List.length(vars$2) == List.length(vars$prime)) then do
    return --[[ () ]]0;
  end else do
    ty = newty2(100000000, --[[ Tpoly ]]Block.__(10, {
            repr(exp.exp_type),
            vars$prime
          }));
    ty_expected$1 = repr(ty_expected);
    throw {
          __Error$7,
          exp.exp_loc,
          env,
          --[[ Less_general ]]Block.__(31, {
              kind,
              --[[ :: ]]{
                --[[ tuple ]]{
                  ty,
                  ty
                },
                --[[ :: ]]{
                  --[[ tuple ]]{
                    ty_expected$1,
                    ty_expected$1
                  },
                  --[[ [] ]]0
                }
              }
            })
        };
  end end 
end end

function check_application_result(env, statement, exp) do
  loc = exp.exp_loc;
  match = expand_head(env, exp.exp_type).desc;
  if (typeof match ~= "number") then do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 0--[[ Tvar ]] then do
          return --[[ () ]]0;end end end 
       if ___conditional___ = 1--[[ Tarrow ]] then do
          return prerr_warning(exp.exp_loc, --[[ Partial_application ]]2);end end end 
       if ___conditional___ = 3--[[ Tconstr ]] then do
          if (same(match[0], path_unit)) then do
            return --[[ () ]]0;
          end
           end end else 
       do
      else do
        end end
        
    end
  end
   end 
  if (statement) then do
    return prerr_warning(loc, --[[ Statement_type ]]4);
  end else do
    return 0;
  end end 
end end

function generalizable(level, ty) do
  check = function (ty) do
    ty$1 = repr(ty);
    if (ty$1.level < 0) then do
      return --[[ () ]]0;
    end else do
      if (ty$1.level <= level) then do
        throw Pervasives.Exit;
      end
       end 
      mark_type_node(ty$1);
      return iter_type_expr(check, ty$1);
    end end 
  end end;
  try do
    check(ty);
    unmark_type(ty);
    return true;
  end
  catch (exn)do
    if (exn == Pervasives.Exit) then do
      unmark_type(ty);
      return false;
    end else do
      throw exn;
    end end 
  end
end end

self_coercion = do
  contents: --[[ [] ]]0
end;

function wrap_unpacks(sexp, unpacks) do
  return List.fold_left((function (sexp, param) do
                name = param[0];
                return Curry._5(Ast_helper_Exp.letmodule, sexp.pexp_loc, undefined, name, unpack$1(param[1], undefined, Curry._3(Ast_helper_Exp.ident, name.loc, undefined, do
                                    txt: --[[ Lident ]]Block.__(0, {name.txt}),
                                    loc: name.loc
                                  end)), sexp);
              end end), sexp, unpacks);
end end

function contains_variant_either(ty) do
  loop = function (ty) do
    ty$1 = repr(ty);
    if (ty$1.level >= 0) then do
      mark_type_node(ty$1);
      match = ty$1.desc;
      if (typeof match == "number" or match.tag ~= --[[ Tvariant ]]8) then do
        return iter_type_expr(loop, ty$1);
      end else do
        row = row_repr_aux(--[[ [] ]]0, match[0]);
        if (not row.row_fixed) then do
          List.iter((function (param) do
                  match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                  if (typeof match == "number" or not match.tag) then do
                    return --[[ () ]]0;
                  end else do
                    throw Pervasives.Exit;
                  end end 
                end end), row.row_fields);
        end
         end 
        return iter_row(loop, row);
      end end 
    end else do
      return 0;
    end end 
  end end;
  try do
    loop(ty);
    unmark_type(ty);
    return false;
  end
  catch (exn)do
    if (exn == Pervasives.Exit) then do
      unmark_type(ty);
      return true;
    end else do
      throw exn;
    end end 
  end
end end

function iter_ppat(f, p) do
  match = p.ppat_desc;
  if (typeof match == "number") then do
    return --[[ () ]]0;
  end else do
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 5--[[ Ppat_construct ]]
       or ___conditional___ = 6--[[ Ppat_variant ]] then do
          return may(f, match[1]);end end end 
       if ___conditional___ = 7--[[ Ppat_record ]] then do
          return List.iter((function (param) do
                        return Curry._1(f, param[1]);
                      end end), match[0]);end end end 
       if ___conditional___ = 4--[[ Ppat_tuple ]]
       or ___conditional___ = 8--[[ Ppat_array ]] then do
          return List.iter(f, match[0]);end end end 
       if ___conditional___ = 9--[[ Ppat_or ]] then do
          Curry._1(f, match[0]);
          return Curry._1(f, match[1]);end end end 
       if ___conditional___ = 1--[[ Ppat_alias ]]
       or ___conditional___ = 10--[[ Ppat_constraint ]]
       or ___conditional___ = 12--[[ Ppat_lazy ]]
       or ___conditional___ = 14--[[ Ppat_exception ]] then do
          return Curry._1(f, match[0]);end end end 
       do
      else do
        return --[[ () ]]0;
        end end
        
    end
  end end 
end end

function contains_polymorphic_variant(p) do
  loop = function (p) do
    match = p.ppat_desc;
    if (typeof match == "number") then do
      return iter_ppat(loop, p);
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 6--[[ Ppat_variant ]]
         or ___conditional___ = 11--[[ Ppat_type ]] then do
            throw Pervasives.Exit;end end end 
         do
        else do
          return iter_ppat(loop, p);
          end end
          
      end
    end end 
  end end;
  try do
    loop(p);
    return false;
  end
  catch (exn)do
    if (exn == Pervasives.Exit) then do
      return true;
    end else do
      throw exn;
    end end 
  end
end end

function contains_gadt(env, p) do
  loop = function (p) do
    match = p.ppat_desc;
    if (typeof match == "number" or match.tag ~= --[[ Ppat_construct ]]5) then do
      return iter_ppat(loop, p);
    end else do
      try do
        cstrs = lookup_all_constructors$1(match[0].txt, env);
        List.iter((function (param) do
                if (param[0].cstr_generalized) then do
                  throw Pervasives.Exit;
                end else do
                  return 0;
                end end 
              end end), cstrs);
      end
      catch (exn)do
        if (exn ~= Caml_builtin_exceptions.not_found) then do
          throw exn;
        end
         end 
      end
      return iter_ppat(loop, p);
    end end 
  end end;
  try do
    loop(p);
    return false;
  end
  catch (exn)do
    if (exn == Pervasives.Exit) then do
      return true;
    end else do
      throw exn;
    end end 
  end
end end

function check_absent_variant(env) do
  return (function (param) do
      return iter_pattern((function (pat) do
                    match = pat.pat_desc;
                    if (typeof match == "number" or match.tag ~= --[[ Tpat_variant ]]5) then do
                      return --[[ () ]]0;
                    end else do
                      arg = match[1];
                      s = match[0];
                      row = row_repr_aux(--[[ [] ]]0, match[2].contents);
                      if (List.exists((function (param) do
                                if (s == param[0]) then do
                                  return row_field_repr_aux(--[[ [] ]]0, param[1]) ~= --[[ Rabsent ]]0;
                                end else do
                                  return false;
                                end end 
                              end end), row.row_fields) or not row.row_fixed and not static_row(row)) then do
                        return --[[ () ]]0;
                      end else do
                        ty_arg = arg ~= undefined and --[[ :: ]]{
                            type_expr(identity, arg.pat_type),
                            --[[ [] ]]0
                          } or --[[ [] ]]0;
                        row$prime_row_fields = --[[ :: ]]{
                          --[[ tuple ]]{
                            s,
                            --[[ Reither ]]Block.__(1, {
                                arg == undefined,
                                ty_arg,
                                true,
                                do
                                  contents: undefined
                                end
                              })
                          },
                          --[[ [] ]]0
                        };
                        row$prime_row_more = newvar(undefined, --[[ () ]]0);
                        row$prime = do
                          row_fields: row$prime_row_fields,
                          row_more: row$prime_row_more,
                          row_bound: --[[ () ]]0,
                          row_closed: false,
                          row_fixed: false,
                          row_name: undefined
                        end;
                        return unify_pat(env, do
                                    pat_desc: pat.pat_desc,
                                    pat_loc: pat.pat_loc,
                                    pat_extra: pat.pat_extra,
                                    pat_type: newty2(current_level.contents, --[[ Tvariant ]]Block.__(8, {row$prime})),
                                    pat_env: pat.pat_env,
                                    pat_attributes: pat.pat_attributes
                                  end, type_expr(identity, pat.pat_type));
                      end end 
                    end end 
                  end end), param);
    end end);
end end

function duplicate_ident_types(loc, caselist, env) do
  caselist$1 = List.filter((function (param) do
            return contains_gadt(env, param.pc_lhs);
          end end))(caselist);
  idents = all_idents_cases(caselist$1);
  return List.fold_left((function (env, s) do
                try do
                  match = lookup_value$1(--[[ Lident ]]Block.__(0, {s}), env);
                  desc = match[1];
                  path = match[0];
                  local ___conditional___=(path.tag | 0);
                  do
                     if ___conditional___ = 0--[[ Pident ]] then do
                        desc_val_type = type_expr(identity, desc.val_type);
                        desc_val_kind = desc.val_kind;
                        desc_val_loc = desc.val_loc;
                        desc_val_attributes = desc.val_attributes;
                        desc$1 = do
                          val_type: desc_val_type,
                          val_kind: desc_val_kind,
                          val_loc: desc_val_loc,
                          val_attributes: desc_val_attributes
                        end;
                        return add_value(undefined, path[0], desc$1, env);end end end 
                     if ___conditional___ = 1--[[ Pdot ]]
                     or ___conditional___ = 2--[[ Papply ]] then do
                        return env;end end end 
                     do
                    
                  end
                end
                catch (exn)do
                  if (exn == Caml_builtin_exceptions.not_found) then do
                    return env;
                  end else do
                    throw exn;
                  end end 
                end
              end end), env, idents);
end end

function unify_exp(env, exp, expected_ty) do
  return unify_exp_types(exp.exp_loc, env, exp.exp_type, expected_ty);
end end

function type_exp(env, sexp) do
  return type_expect(undefined, env, sexp, newvar(undefined, --[[ () ]]0));
end end

function type_expect(in_function, env, sexp, ty_expected) do
  previous_saved_types = saved_types.contents;
  warning_enter_scope(--[[ () ]]0);
  warning_attribute(sexp.pexp_attributes);
  exp = type_expect_(in_function, env, sexp, ty_expected);
  warning_leave_scope(--[[ () ]]0);
  saved_types.contents = --[[ :: ]]{
    --[[ Partial_expression ]]Block.__(2, {exp}),
    previous_saved_types
  };
  return exp;
end end

function type_expect_(in_function, env, sexp, ty_expected) do
  loc = sexp.pexp_loc;
  rue = function (exp) do
    unify_exp(env, re(exp), instance(undefined, env, ty_expected));
    return exp;
  end end;
  match = sexp.pexp_desc;
  local ___conditional___=(match.tag | 0);
  do
     if ___conditional___ = 0--[[ Pexp_ident ]] then do
        lid = match[0];
        match$1 = find_value$1(env, loc, lid.txt);
        desc = match$1[1];
        path = match$1[0];
        if (annotations.contents) then do
          dloc = desc.val_loc;
          annot = dloc.loc_ghost and --[[ Iref_external ]]0 or --[[ Iref_internal ]]Block.__(0, {dloc});
          name$1 = name(parenthesized_ident, path);
          record$2(--[[ An_ident ]]Block.__(5, {
                  loc,
                  name$1,
                  annot
                }));
        end
         end 
        match$2 = desc.val_kind;
        tmp;
        if (typeof match$2 == "number") then do
          if (match$2 == --[[ Val_unbound ]]1) then do
            throw {
                  __Error$7,
                  loc,
                  env,
                  --[[ Masked_instance_variable ]]Block.__(29, {lid.txt})
                };
          end else do
            tmp = --[[ Texp_ident ]]Block.__(0, {
                path,
                lid,
                desc
              });
          end end 
        end else do
          local ___conditional___=(match$2.tag | 0);
          do
             if ___conditional___ = 1--[[ Val_ivar ]] then do
                match$3 = lookup_value$1(--[[ Lident ]]Block.__(0, {"self-" .. match$2[1]}), env);
                match$4 = lid.txt;
                tmp$1;
                local ___conditional___=(match$4.tag | 0);
                do
                   if ___conditional___ = 0--[[ Lident ]] then do
                      tmp$1 = do
                        txt: match$4[0],
                        loc: lid.loc
                      end;end else 
                   if ___conditional___ = 1--[[ Ldot ]]
                   or ___conditional___ = 2--[[ Lapply ]] then do
                      throw {
                            Caml_builtin_exceptions.assert_failure,
                            --[[ tuple ]]{
                              "typecore.ml",
                              1773,
                              38
                            }
                          };end end end 
                   do end
                  
                end
                tmp = --[[ Texp_instvar ]]Block.__(20, {
                    match$3[0],
                    path,
                    tmp$1
                  });end else 
             if ___conditional___ = 2--[[ Val_self ]] then do
                match$5 = lookup_value$1(--[[ Lident ]]Block.__(0, {"self-" .. match$2[2]}), env);
                tmp = --[[ Texp_ident ]]Block.__(0, {
                    match$5[0],
                    lid,
                    desc
                  });end else 
             do end end end
            else do
              tmp = --[[ Texp_ident ]]Block.__(0, {
                  path,
                  lid,
                  desc
                });
              end end
              
          end
        end end 
        return rue(do
                    exp_desc: tmp,
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: instance(undefined, env, desc.val_type),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end);end end end 
     if ___conditional___ = 1--[[ Pexp_constant ]] then do
        cst = match[0];
        if (cst.tag == --[[ Const_string ]]2) then do
          ty_exp = expand_head(env, ty_expected);
          fmt6_path_000 = --[[ Pident ]]Block.__(0, {do
                stamp: 0,
                name: "CamlinternalFormatBasics",
                flags: 1
              end});
          fmt6_path = --[[ Pdot ]]Block.__(1, {
              fmt6_path_000,
              "format6",
              0
            });
          match$6 = ty_exp.desc;
          is_format;
          if (typeof match$6 == "number" or not (match$6.tag == --[[ Tconstr ]]3 and same(match$6[0], fmt6_path))) then do
            is_format = false;
          end else do
            if (principal.contents and ty_exp.level ~= 100000000) then do
              prerr_warning(loc, --[[ Not_principal ]]Block.__(8, {"this coercion to format6"}));
            end
             end 
            is_format = true;
          end end 
          if (is_format) then do
            init = type_format(loc, cst[0], env);
            format_parsetree_pexp_desc = init.pexp_desc;
            format_parsetree_pexp_loc = sexp.pexp_loc;
            format_parsetree_pexp_attributes = init.pexp_attributes;
            format_parsetree = do
              pexp_desc: format_parsetree_pexp_desc,
              pexp_loc: format_parsetree_pexp_loc,
              pexp_attributes: format_parsetree_pexp_attributes
            end;
            return type_expect(in_function, env, format_parsetree, ty_expected);
          end else do
            return rue(do
                        exp_desc: --[[ Texp_constant ]]Block.__(1, {cst}),
                        exp_loc: loc,
                        exp_extra: --[[ [] ]]0,
                        exp_type: instance_def(type_string),
                        exp_env: env,
                        exp_attributes: sexp.pexp_attributes
                      end);
          end end 
        end else do
          return rue(do
                      exp_desc: --[[ Texp_constant ]]Block.__(1, {cst}),
                      exp_loc: loc,
                      exp_extra: --[[ [] ]]0,
                      exp_type: type_constant(cst),
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    end);
        end end end end end 
     if ___conditional___ = 2--[[ Pexp_let ]] then do
        rec_flag = match[0];
        exit = 0;
        if (rec_flag) then do
          exit = 1;
        end else do
          match$7 = match[1];
          if (match$7) then do
            match$8 = match$7[0];
            if (match$8.pvb_attributes or match$7[1]) then do
              exit = 1;
            end else do
              spat = match$8.pvb_pat;
              if (contains_gadt(env, spat)) then do
                return type_expect(in_function, env, do
                            pexp_desc: --[[ Pexp_match ]]Block.__(6, {
                                match$8.pvb_expr,
                                --[[ :: ]]{
                                  Curry._3(Ast_helper_Exp.__case, spat, undefined, match[2]),
                                  --[[ [] ]]0
                                }
                              }),
                            pexp_loc: sexp.pexp_loc,
                            pexp_attributes: sexp.pexp_attributes
                          end, ty_expected);
              end else do
                exit = 1;
              end end 
            end end 
          end else do
            exit = 1;
          end end 
        end end 
        if (exit == 1) then do
          sbody = match[2];
          match$9 = sexp.pexp_attributes;
          scp;
          exit$1 = 0;
          if (match$9 and match$9[0][0].txt == "#default" and not match$9[1]) then do
            scp = undefined;
          end else do
            exit$1 = 2;
          end end 
          if (exit$1 == 2) then do
            scp = rec_flag and --[[ Idef ]]Block.__(1, {loc}) or --[[ Idef ]]Block.__(1, {sbody.pexp_loc});
          end
           end 
          match$10 = type_let(undefined, undefined, env, rec_flag, match[1], scp, true);
          body = type_expect(undefined, match$10[1], wrap_unpacks(sbody, match$10[2]), ty_expected);
          return re(do
                      exp_desc: --[[ Texp_let ]]Block.__(2, {
                          rec_flag,
                          match$10[0],
                          body
                        }),
                      exp_loc: loc,
                      exp_extra: --[[ [] ]]0,
                      exp_type: body.exp_type,
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    end);
        end
         end end else 
     if ___conditional___ = 3--[[ Pexp_function ]] then do
        return type_function(in_function, loc, sexp.pexp_attributes, env, ty_expected, "", match[0]);end end end 
     if ___conditional___ = 4--[[ Pexp_fun ]] then do
        match$11 = match[1];
        l = match[0];
        if (match$11 ~= undefined) then do
          __default = match$11;
          if (not is_optional(l)) then do
            throw {
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "typecore.ml",
                    1852,
                    6
                  }
                };
          end
           end 
          default_loc = __default.pexp_loc;
          scases_000 = Curry._3(Ast_helper_Exp.__case, construct(default_loc, undefined, do
                    txt: --[[ Ldot ]]Block.__(1, {
                        --[[ Lident ]]Block.__(0, {"*predef*"}),
                        "Some"
                      }),
                    loc: none
                  end, __var$1(default_loc, undefined, do
                        txt: "*sth*",
                        loc: none
                      end)), undefined, Curry._3(Ast_helper_Exp.ident, default_loc, undefined, do
                    txt: --[[ Lident ]]Block.__(0, {"*sth*"}),
                    loc: none
                  end));
          scases_001 = --[[ :: ]]{
            Curry._3(Ast_helper_Exp.__case, construct(default_loc, undefined, do
                      txt: --[[ Ldot ]]Block.__(1, {
                          --[[ Lident ]]Block.__(0, {"*predef*"}),
                          "None"
                        }),
                      loc: none
                    end, undefined), undefined, __default),
            --[[ [] ]]0
          };
          scases = --[[ :: ]]{
            scases_000,
            scases_001
          };
          smatch = Curry._4(Ast_helper_Exp.match_, loc, undefined, Curry._3(Ast_helper_Exp.ident, loc, undefined, do
                    txt: --[[ Lident ]]Block.__(0, {"*opt*"}),
                    loc: none
                  end), scases);
          sfun = Curry._6(Ast_helper_Exp.fun_, loc, undefined, l, undefined, __var$1(loc, undefined, do
                    txt: "*opt*",
                    loc: none
                  end), Curry._5(Ast_helper_Exp.let_, loc, --[[ :: ]]{
                    --[[ tuple ]]{
                      do
                        txt: "#default",
                        loc: none
                      end,
                      --[[ PStr ]]Block.__(0, {--[[ [] ]]0})
                    },
                    --[[ [] ]]0
                  }, --[[ Nonrecursive ]]0, --[[ :: ]]{
                    mk$17(undefined, undefined, undefined, undefined, match[2], smatch),
                    --[[ [] ]]0
                  }, match[3]));
          return type_expect(in_function, env, sfun, ty_expected);
        end else do
          sexp$1 = match[3];
          return type_function(in_function, loc, sexp$1.pexp_attributes, env, ty_expected, l, --[[ :: ]]{
                      do
                        pc_lhs: match[2],
                        pc_guard: undefined,
                        pc_rhs: sexp$1
                      end,
                      --[[ [] ]]0
                    });
        end end end end end 
     if ___conditional___ = 5--[[ Pexp_apply ]] then do
        sargs = match[1];
        if (sargs == --[[ [] ]]0) then do
          ill_formed_ast(loc, "Function application with no argument.");
        end
         end 
        begin_def(--[[ () ]]0);
        if (principal.contents) then do
          begin_def(--[[ () ]]0);
        end
         end 
        funct = type_exp(env, match[0]);
        if (principal.contents) then do
          end_def(--[[ () ]]0);
          generalize_structure$1(current_level.contents, funct.exp_type);
        end
         end 
        ty = instance(undefined, env, funct.exp_type);
        end_def(--[[ () ]]0);
        wrap_trace_gadt_instances(env, (function (param) do
                _seen = --[[ [] ]]0;
                _ty_fun = param;
                while(true) do
                  ty_fun = _ty_fun;
                  seen = _seen;
                  ty = expand_head(env, ty_fun);
                  if (List.memq(ty, seen)) then do
                    return --[[ () ]]0;
                  end else do
                    match = ty.desc;
                    if (typeof match == "number" or match.tag ~= --[[ Tarrow ]]1) then do
                      return --[[ () ]]0;
                    end else do
                      try do
                        unify_var(env, newvar(undefined, --[[ () ]]0), match[1]);
                      end
                      catch (raw_exn)do
                        exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                        if (exn[0] == Unify) then do
                          throw {
                                Caml_builtin_exceptions.assert_failure,
                                --[[ tuple ]]{
                                  "typecore.ml",
                                  1903,
                                  65
                                }
                              };
                        end
                         end 
                        throw exn;
                      end
                      _ty_fun = match[2];
                      _seen = --[[ :: ]]{
                        ty,
                        seen
                      };
                      continue ;
                    end end 
                  end end 
                end;
              end end), ty);
        begin_def(--[[ () ]]0);
        match$12 = type_application(env, funct, sargs);
        end_def(--[[ () ]]0);
        unify_var(env, newvar(undefined, --[[ () ]]0), funct.exp_type);
        return rue(do
                    exp_desc: --[[ Texp_apply ]]Block.__(4, {
                        funct,
                        match$12[0]
                      }),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: match$12[1],
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end);end end end 
     if ___conditional___ = 6--[[ Pexp_match ]] then do
        begin_def(--[[ () ]]0);
        arg = type_exp(env, match[0]);
        end_def(--[[ () ]]0);
        if (is_nonexpansive(arg)) then do
          iter_generalize$1(do
                contents: --[[ [] ]]0
              end, arg.exp_type);
        end else do
          generalize_expansive$1(env, arg.exp_type);
        end end 
        split_cases = function (_vc, _ec, _param) do
          while(true) do
            param = _param;
            ec = _ec;
            vc = _vc;
            if (param) then do
              c = param[0];
              match = c.pc_lhs.ppat_desc;
              if (typeof match ~= "number" and match.tag == --[[ Ppat_exception ]]14) then do
                _param = param[1];
                _ec = --[[ :: ]]{
                  do
                    pc_lhs: match[0],
                    pc_guard: c.pc_guard,
                    pc_rhs: c.pc_rhs
                  end,
                  ec
                };
                continue ;
              end
               end 
              _param = param[1];
              _vc = --[[ :: ]]{
                c,
                vc
              };
              continue ;
            end else do
              return --[[ tuple ]]{
                      List.rev(vc),
                      List.rev(ec)
                    };
            end end 
          end;
        end end;
        match$13 = split_cases(--[[ [] ]]0, --[[ [] ]]0, match[1]);
        exn_caselist = match$13[1];
        val_caselist = match$13[0];
        if (val_caselist == --[[ [] ]]0 and exn_caselist ~= --[[ [] ]]0) then do
          throw {
                __Error$7,
                loc,
                env,
                --[[ No_value_clauses ]]7
              };
        end
         end 
        match$14 = type_cases(undefined, env, arg.exp_type, ty_expected, true, loc, val_caselist);
        match$15 = type_cases(undefined, env, type_exn, ty_expected, false, loc, exn_caselist);
        return re(do
                    exp_desc: --[[ Texp_match ]]Block.__(5, {
                        arg,
                        match$14[0],
                        match$15[0],
                        match$14[1]
                      }),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: instance(undefined, env, ty_expected),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end);end end end 
     if ___conditional___ = 7--[[ Pexp_try ]] then do
        body$1 = type_expect(undefined, env, match[0], ty_expected);
        match$16 = type_cases(undefined, env, type_exn, ty_expected, false, loc, match[1]);
        return re(do
                    exp_desc: --[[ Texp_try ]]Block.__(6, {
                        body$1,
                        match$16[0]
                      }),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: body$1.exp_type,
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end);end end end 
     if ___conditional___ = 8--[[ Pexp_tuple ]] then do
        sexpl = match[0];
        if (List.length(sexpl) < 2) then do
          ill_formed_ast(loc, "Tuples must have at least 2 components.");
        end
         end 
        subtypes = List.map((function (param) do
                return newty2(100000000, --[[ Tvar ]]Block.__(0, {undefined}));
              end end), sexpl);
        to_unify = newty2(100000000, --[[ Ttuple ]]Block.__(2, {subtypes}));
        unify_exp_types(loc, env, to_unify, ty_expected);
        expl = List.map2((function (body, ty) do
                return type_expect(undefined, env, body, ty);
              end end), sexpl, subtypes);
        desc$1 = --[[ Ttuple ]]Block.__(2, {List.map((function (e) do
                    return e.exp_type;
                  end end), expl)});
        return re(do
                    exp_desc: --[[ Texp_tuple ]]Block.__(7, {expl}),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: newty2(current_level.contents, desc$1),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end);end end end 
     if ___conditional___ = 9--[[ Pexp_construct ]] then do
        env$1 = env;
        loc$1 = loc;
        lid$1 = match[0];
        sarg = match[1];
        ty_expected$1 = ty_expected;
        attrs = sexp.pexp_attributes;
        opath;
        try do
          match$17 = extract_concrete_variant(env$1, ty_expected$1);
          opath = --[[ tuple ]]{
            match$17[0],
            match$17[1],
            ty_expected$1.level == 100000000 or not principal.contents
          };
        end
        catch (exn)do
          if (exn == Caml_builtin_exceptions.not_found) then do
            opath = undefined;
          end else do
            throw exn;
          end end 
        end
        constrs = find_all_constructors(env$1, lid$1.loc, lid$1.txt);
        constr = wrap_disambiguate("This variant expression is expected to have", ty_expected$1, (function (param) do
                return disambiguate$1(undefined, undefined, undefined, lid$1, env$1, opath, param);
              end end), constrs);
        mark_constructor(--[[ Positive ]]0, env$1, last$1(lid$1.txt), constr);
        check_deprecated(loc$1, constr.cstr_attributes, constr.cstr_name);
        sargs$1;
        if (sarg ~= undefined) then do
          se = sarg;
          match$18 = se.pexp_desc;
          sargs$1 = match$18.tag == --[[ Pexp_tuple ]]8 and (constr.cstr_arity > 1 or explicit_arity(attrs)) and match$18[0] or --[[ :: ]]{
              se,
              --[[ [] ]]0
            };
        end else do
          sargs$1 = --[[ [] ]]0;
        end end 
        if (List.length(sargs$1) ~= constr.cstr_arity) then do
          throw {
                __Error$7,
                loc$1,
                env$1,
                --[[ Constructor_arity_mismatch ]]Block.__(1, {
                    lid$1.txt,
                    constr.cstr_arity,
                    List.length(sargs$1)
                  })
              };
        end
         end 
        separate = principal.contents or env$1.local_constraints;
        if (separate) then do
          begin_def(--[[ () ]]0);
          begin_def(--[[ () ]]0);
        end
         end 
        match$19 = instance_constructor(undefined, constr);
        ty_res = match$19[1];
        ty_args = match$19[0];
        texp = re(do
              exp_desc: --[[ Texp_construct ]]Block.__(8, {
                  lid$1,
                  constr,
                  --[[ [] ]]0
                }),
              exp_loc: loc$1,
              exp_extra: --[[ [] ]]0,
              exp_type: ty_res,
              exp_env: env$1,
              exp_attributes: attrs
            end);
        if (separate) then do
          end_def(--[[ () ]]0);
          generalize_structure$1(current_level.contents, ty_res);
          unify_exp(env$1, do
                exp_desc: texp.exp_desc,
                exp_loc: texp.exp_loc,
                exp_extra: texp.exp_extra,
                exp_type: instance_def(ty_res),
                exp_env: texp.exp_env,
                exp_attributes: texp.exp_attributes
              end, instance(undefined, env$1, ty_expected$1));
          end_def(--[[ () ]]0);
          List.iter(generalize_structure$2, ty_args);
          generalize_structure$1(current_level.contents, ty_res);
        end
         end 
        match$20 = instance_list(env$1, --[[ :: ]]{
              ty_res,
              ty_args
            });
        match$21;
        if (match$20) then do
          match$21 = --[[ tuple ]]{
            match$20[1],
            match$20[0]
          };
        end else do
          throw {
                Caml_builtin_exceptions.assert_failure,
                --[[ tuple ]]{
                  "typecore.ml",
                  3375,
                  11
                }
              };
        end end 
        ty_res$1 = match$21[1];
        texp_exp_desc = texp.exp_desc;
        texp_exp_loc = texp.exp_loc;
        texp_exp_extra = texp.exp_extra;
        texp_exp_env = texp.exp_env;
        texp_exp_attributes = texp.exp_attributes;
        texp$1 = do
          exp_desc: texp_exp_desc,
          exp_loc: texp_exp_loc,
          exp_extra: texp_exp_extra,
          exp_type: ty_res$1,
          exp_env: texp_exp_env,
          exp_attributes: texp_exp_attributes
        end;
        if (not separate) then do
          unify_exp(env$1, texp$1, instance(undefined, env$1, ty_expected$1));
        end
         end 
        args = List.map2((function (e, param) do
                return type_argument(env$1, e, param[0], param[1]);
              end end), sargs$1, List.combine(ty_args, match$21[0]));
        if (constr.cstr_private == --[[ Private ]]0) then do
          throw {
                __Error$7,
                loc$1,
                env$1,
                --[[ Private_type ]]Block.__(19, {ty_res$1})
              };
        end
         end 
        return do
                exp_desc: --[[ Texp_construct ]]Block.__(8, {
                    lid$1,
                    constr,
                    args
                  }),
                exp_loc: texp_exp_loc,
                exp_extra: texp_exp_extra,
                exp_type: ty_res$1,
                exp_env: texp_exp_env,
                exp_attributes: texp_exp_attributes
              end;end end end 
     if ___conditional___ = 10--[[ Pexp_variant ]] then do
        sarg$1 = match[1];
        l$1 = match[0];
        ty_expected0 = instance(undefined, env, ty_expected);
        try do
          match$22 = expand_head(env, ty_expected);
          match$23 = expand_head(env, ty_expected0);
          if (sarg$1 ~= undefined) then do
            match$24 = match$22.desc;
            if (typeof match$24 == "number") then do
              throw Caml_builtin_exceptions.not_found;
            end else if (match$24.tag == --[[ Tvariant ]]8) then do
              match$25 = match$23.desc;
              if (typeof match$25 == "number") then do
                throw Caml_builtin_exceptions.not_found;
              end else if (match$25.tag == --[[ Tvariant ]]8) then do
                row = row_repr_aux(--[[ [] ]]0, match$24[0]);
                match$26 = row_field_repr_aux(--[[ [] ]]0, List.assoc(l$1, row.row_fields));
                match$27 = row_field_repr_aux(--[[ [] ]]0, List.assoc(l$1, match$25[0].row_fields));
                if (typeof match$26 == "number") then do
                  throw Caml_builtin_exceptions.not_found;
                end else if (match$26.tag) then do
                  throw Caml_builtin_exceptions.not_found;
                end else do
                  match$28 = match$26[0];
                  if (match$28 ~= undefined) then do
                    if (typeof match$27 == "number") then do
                      throw Caml_builtin_exceptions.not_found;
                    end else if (match$27.tag) then do
                      throw Caml_builtin_exceptions.not_found;
                    end else do
                      match$29 = match$27[0];
                      if (match$29 ~= undefined) then do
                        arg$1 = type_argument(env, sarg$1, match$28, match$29);
                        return re(do
                                    exp_desc: --[[ Texp_variant ]]Block.__(9, {
                                        l$1,
                                        arg$1
                                      }),
                                    exp_loc: loc,
                                    exp_extra: --[[ [] ]]0,
                                    exp_type: ty_expected0,
                                    exp_env: env,
                                    exp_attributes: sexp.pexp_attributes
                                  end);
                      end else do
                        throw Caml_builtin_exceptions.not_found;
                      end end 
                    end end  end 
                  end else do
                    throw Caml_builtin_exceptions.not_found;
                  end end 
                end end  end 
              end else do
                throw Caml_builtin_exceptions.not_found;
              end end  end 
            end else do
              throw Caml_builtin_exceptions.not_found;
            end end  end 
          end else do
            throw Caml_builtin_exceptions.not_found;
          end end 
        end
        catch (exn$1)do
          if (exn$1 == Caml_builtin_exceptions.not_found) then do
            arg$2 = may_map((function (param) do
                    return type_exp(env, param);
                  end end), sarg$1);
            arg_type = may_map((function (arg) do
                    return arg.exp_type;
                  end end), arg$2);
            desc$2 = --[[ Tvariant ]]Block.__(8, {do
                  row_fields: --[[ :: ]]{
                    --[[ tuple ]]{
                      l$1,
                      --[[ Rpresent ]]Block.__(0, {arg_type})
                    },
                    --[[ [] ]]0
                  },
                  row_more: newvar(undefined, --[[ () ]]0),
                  row_bound: --[[ () ]]0,
                  row_closed: false,
                  row_fixed: false,
                  row_name: undefined
                end});
            return rue(do
                        exp_desc: --[[ Texp_variant ]]Block.__(9, {
                            l$1,
                            arg$2
                          }),
                        exp_loc: loc,
                        exp_extra: --[[ [] ]]0,
                        exp_type: newty2(current_level.contents, desc$2),
                        exp_env: env,
                        exp_attributes: sexp.pexp_attributes
                      end);
          end else do
            throw exn$1;
          end end 
        endend end end 
     if ___conditional___ = 11--[[ Pexp_record ]] then do
        opt_sexp = match[1];
        lid_sexp_list = match[0];
        if (lid_sexp_list == --[[ [] ]]0) then do
          ill_formed_ast(loc, "Records cannot be empty.");
        end
         end 
        opt_exp;
        if (opt_sexp ~= undefined) then do
          if (principal.contents) then do
            begin_def(--[[ () ]]0);
          end
           end 
          exp = type_exp(env, opt_sexp);
          if (principal.contents) then do
            end_def(--[[ () ]]0);
            generalize_structure$1(current_level.contents, exp.exp_type);
          end
           end 
          opt_exp = exp;
        end else do
          opt_exp = undefined;
        end end 
        get_path = function (ty) do
          try do
            match = extract_concrete_record(env, ty);
            return --[[ tuple ]]{
                    match[0],
                    match[1],
                    ty.level == 100000000 or not principal.contents
                  };
          end
          catch (exn)do
            if (exn == Caml_builtin_exceptions.not_found) then do
              return ;
            end else do
              throw exn;
            end end 
          end
        end end;
        op = get_path(ty_expected);
        match$30;
        if (op ~= undefined) then do
          match$30 = --[[ tuple ]]{
            ty_expected,
            op
          };
        end else if (opt_exp ~= undefined) then do
          op$1 = get_path(opt_exp.exp_type);
          if (op$1 ~= undefined) then do
            p$prime = op$1[1];
            decl = find_type_full(p$prime, env)[0];
            begin_def(--[[ () ]]0);
            ty$1 = newconstr(p$prime, instance_list(env, decl.type_params));
            end_def(--[[ () ]]0);
            generalize_structure$1(current_level.contents, ty$1);
            match$30 = --[[ tuple ]]{
              ty$1,
              op$1
            };
          end else do
            match$30 = --[[ tuple ]]{
              newvar(undefined, --[[ () ]]0),
              undefined
            };
          end end 
        end else do
          match$30 = --[[ tuple ]]{
            newvar(undefined, --[[ () ]]0),
            undefined
          };
        end end  end 
        opath$1 = match$30[1];
        ty_record = match$30[0];
        closed = opt_sexp == undefined;
        lbl_exp_list = wrap_disambiguate("This record expression is expected to have", ty_record, (function (param) do
                return type_label_a_list(undefined, loc, closed, env, (function (param) do
                              return type_label_exp(true, env, loc, ty_record, param);
                            end end), opath$1, param);
              end end), lid_sexp_list);
        unify_exp_types(loc, env, ty_record, instance(undefined, env, ty_expected));
        check_duplicates = function (_param) do
          while(true) do
            param = _param;
            if (param) then do
              rem = param[1];
              lbl1 = param[0][1];
              if (rem) then do
                if (lbl1.lbl_pos == rem[0][1].lbl_pos) then do
                  throw {
                        __Error$7,
                        loc,
                        env,
                        --[[ Label_multiply_defined ]]Block.__(10, {lbl1.lbl_name})
                      };
                end
                 end 
                _param = rem;
                continue ;
              end else do
                _param = rem;
                continue ;
              end end 
            end else do
              return --[[ () ]]0;
            end end 
          end;
        end end;
        check_duplicates(lbl_exp_list);
        opt_exp$1;
        if (opt_exp ~= undefined) then do
          if (lbl_exp_list) then do
            exp$1 = opt_exp;
            ty_exp$1 = instance(undefined, env, exp$1.exp_type);
            unify_kept = function (lbl) do
              if (List.for_all((function (param) do
                        return param[1].lbl_pos ~= lbl.lbl_pos;
                      end end), lbl_exp_list)) then do
                match = instance_label(false, lbl);
                match$1 = instance_label(false, lbl);
                unify$2(env, match[1], match$1[1]);
                unify$2(env, instance(undefined, env, ty_expected), match$1[2]);
                return unify_exp_types(exp$1.exp_loc, env, ty_exp$1, match[2]);
              end else do
                return 0;
              end end 
            end end;
            __Array.iter(unify_kept, lbl_exp_list[0][1].lbl_all);
            opt_exp$1 = do
              exp_desc: exp$1.exp_desc,
              exp_loc: exp$1.exp_loc,
              exp_extra: exp$1.exp_extra,
              exp_type: ty_exp$1,
              exp_env: exp$1.exp_env,
              exp_attributes: exp$1.exp_attributes
            end;
          end else do
            throw {
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "typecore.ml",
                    2092,
                    15
                  }
                };
          end end 
        end else do
          opt_exp$1 = undefined;
        end end 
        num_fields;
        if (lbl_exp_list) then do
          num_fields = #lbl_exp_list[0][1].lbl_all;
        end else do
          throw {
                Caml_builtin_exceptions.assert_failure,
                --[[ tuple ]]{
                  "typecore.ml",
                  2095,
                  38
                }
              };
        end end 
        if (opt_sexp == undefined and List.length(lid_sexp_list) ~= num_fields) then do
          present_indices = List.map((function (param) do
                  return param[1].lbl_pos;
                end end), lbl_exp_list);
          label_names = extract_label_names(sexp, env, ty_expected);
          missing_labels = function (_n, _param) do
            while(true) do
              param = _param;
              n = _n;
              if (param) then do
                rem = param[1];
                if (List.mem(n, present_indices)) then do
                  _param = rem;
                  _n = n + 1 | 0;
                  continue ;
                end else do
                  return --[[ :: ]]{
                          param[0],
                          missing_labels(n + 1 | 0, rem)
                        };
                end end 
              end else do
                return --[[ [] ]]0;
              end end 
            end;
          end end;
          missing = missing_labels(0, label_names);
          throw {
                __Error$7,
                loc,
                env,
                --[[ Label_missing ]]Block.__(11, {missing})
              };
        end else if (opt_sexp ~= undefined and List.length(lid_sexp_list) == num_fields) then do
          prerr_warning(loc, --[[ Useless_record_with ]]11);
        end
         end  end 
        return re(do
                    exp_desc: --[[ Texp_record ]]Block.__(10, {
                        lbl_exp_list,
                        opt_exp$1
                      }),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: instance(undefined, env, ty_expected),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end);end end end 
     if ___conditional___ = 12--[[ Pexp_field ]] then do
        lid$2 = match[1];
        match$31 = type_label_access(env, loc, match[0], lid$2);
        label = match$31[1];
        record$3 = match$31[0];
        match$32 = instance_label(false, label);
        unify_exp(env, record$3, match$32[2]);
        return rue(do
                    exp_desc: --[[ Texp_field ]]Block.__(11, {
                        record$3,
                        lid$2,
                        label
                      }),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: match$32[1],
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end);end end end 
     if ___conditional___ = 13--[[ Pexp_setfield ]] then do
        lid$3 = match[1];
        match$33 = type_label_access(env, loc, match[0], lid$3);
        record$4 = match$33[0];
        ty_record$1 = match$33[2] == undefined and newvar(undefined, --[[ () ]]0) or record$4.exp_type;
        match$34 = type_label_exp(false, env, loc, ty_record$1, --[[ tuple ]]{
              lid$3,
              match$33[1],
              match[2]
            });
        label$1 = match$34[1];
        unify_exp(env, record$4, ty_record$1);
        if (label$1.lbl_mut == --[[ Immutable ]]0) then do
          throw {
                __Error$7,
                loc,
                env,
                --[[ Label_not_mutable ]]Block.__(12, {lid$3.txt})
              };
        end
         end 
        return rue(do
                    exp_desc: --[[ Texp_setfield ]]Block.__(12, {
                        record$4,
                        match$34[0],
                        label$1,
                        match$34[2]
                      }),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: instance_def(type_unit),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end);end end end 
     if ___conditional___ = 14--[[ Pexp_array ]] then do
        ty$2 = newty2(100000000, --[[ Tvar ]]Block.__(0, {undefined}));
        to_unify$1 = type_array(ty$2);
        unify_exp_types(loc, env, to_unify$1, ty_expected);
        argl = List.map((function (sarg) do
                return type_expect(undefined, env, sarg, ty$2);
              end end), match[0]);
        return re(do
                    exp_desc: --[[ Texp_array ]]Block.__(13, {argl}),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: instance(undefined, env, ty_expected),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end);end end end 
     if ___conditional___ = 15--[[ Pexp_ifthenelse ]] then do
        sifnot = match[2];
        sifso = match[1];
        cond = type_expect(undefined, env, match[0], type_bool);
        if (sifnot ~= undefined) then do
          ifso = type_expect(undefined, env, sifso, ty_expected);
          ifnot = type_expect(undefined, env, sifnot, ty_expected);
          unify_exp(env, ifnot, ifso.exp_type);
          return re(do
                      exp_desc: --[[ Texp_ifthenelse ]]Block.__(14, {
                          cond,
                          ifso,
                          ifnot
                        }),
                      exp_loc: loc,
                      exp_extra: --[[ [] ]]0,
                      exp_type: ifso.exp_type,
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    end);
        end else do
          ifso$1 = type_expect(undefined, env, sifso, type_unit);
          return rue(do
                      exp_desc: --[[ Texp_ifthenelse ]]Block.__(14, {
                          cond,
                          ifso$1,
                          undefined
                        }),
                      exp_loc: loc,
                      exp_extra: --[[ [] ]]0,
                      exp_type: ifso$1.exp_type,
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    end);
        end end end end end 
     if ___conditional___ = 16--[[ Pexp_sequence ]] then do
        exp1 = type_statement(env, match[0]);
        exp2 = type_expect(undefined, env, match[1], ty_expected);
        return re(do
                    exp_desc: --[[ Texp_sequence ]]Block.__(15, {
                        exp1,
                        exp2
                      }),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: exp2.exp_type,
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end);end end end 
     if ___conditional___ = 17--[[ Pexp_while ]] then do
        cond$1 = type_expect(undefined, env, match[0], type_bool);
        body$2 = type_statement(env, match[1]);
        return rue(do
                    exp_desc: --[[ Texp_while ]]Block.__(16, {
                        cond$1,
                        body$2
                      }),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: instance_def(type_unit),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end);end end end 
     if ___conditional___ = 18--[[ Pexp_for ]] then do
        param = match[0];
        low = type_expect(undefined, env, match[1], type_int);
        high = type_expect(undefined, env, match[2], type_int);
        match$35 = param.ppat_desc;
        match$36;
        if (typeof match$35 == "number") then do
          match$36 = --[[ tuple ]]{
            create("_for"),
            env
          };
        end else if (match$35.tag) then do
          throw {
                __Error$7,
                param.ppat_loc,
                env,
                --[[ Invalid_for_loop_index ]]6
              };
        end else do
          match$36 = enter_value((function (s) do
                    return --[[ Unused_for_index ]]Block.__(19, {s});
                  end end))(match$35[0].txt, do
                val_type: instance_def(type_int),
                val_kind: --[[ Val_reg ]]0,
                val_loc: loc,
                val_attributes: --[[ [] ]]0
              end, env);
        end end  end 
        body$3 = type_statement(match$36[1], match[4]);
        return rue(do
                    exp_desc: --[[ Texp_for ]]Block.__(17, {
                        match$36[0],
                        param,
                        low,
                        high,
                        match[3],
                        body$3
                      }),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: instance_def(type_unit),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end);end end end 
     if ___conditional___ = 19--[[ Pexp_constraint ]] then do
        sarg$2 = match[0];
        begin_def(--[[ () ]]0);
        cty = transl_simple_type(env, false, match[1]);
        ty$3 = cty.ctyp_type;
        end_def(--[[ () ]]0);
        generalize_structure$1(current_level.contents, ty$3);
        match_000 = type_argument(env, sarg$2, ty$3, instance(undefined, env, ty$3));
        match_001 = instance(undefined, env, ty$3);
        arg$3 = match_000;
        return rue(do
                    exp_desc: arg$3.exp_desc,
                    exp_loc: arg$3.exp_loc,
                    exp_extra: --[[ :: ]]{
                      --[[ tuple ]]{
                        --[[ Texp_constraint ]]Block.__(0, {cty}),
                        loc,
                        sexp.pexp_attributes
                      },
                      arg$3.exp_extra
                    },
                    exp_type: match_001,
                    exp_env: env,
                    exp_attributes: arg$3.exp_attributes
                  end);end end end 
     if ___conditional___ = 20--[[ Pexp_coerce ]] then do
        sty$prime = match[2];
        sty = match[1];
        sarg$3 = match[0];
        match$37;
        if (sty ~= undefined) then do
          begin_def(--[[ () ]]0);
          match$38 = transl_simple_type_delayed(env, sty);
          cty$1 = match$38[0];
          match$39 = transl_simple_type_delayed(env, sty$prime);
          cty$prime = match$39[0];
          ty$4 = cty$1.ctyp_type;
          ty$prime = cty$prime.ctyp_type;
          try do
            force$prime$prime = subtype(env, ty$4, ty$prime);
            Curry._1(match$38[1], --[[ () ]]0);
            Curry._1(match$39[1], --[[ () ]]0);
            Curry._1(force$prime$prime, --[[ () ]]0);
          end
          catch (raw_exn)do
            exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn$2[0] == Subtype) then do
              throw {
                    __Error$7,
                    loc,
                    env,
                    --[[ Not_subtype ]]Block.__(23, {
                        exn$2[1],
                        exn$2[2]
                      })
                  };
            end
             end 
            throw exn$2;
          end
          end_def(--[[ () ]]0);
          generalize_structure$1(current_level.contents, ty$4);
          generalize_structure$1(current_level.contents, ty$prime);
          match$37 = --[[ tuple ]]{
            type_argument(env, sarg$3, ty$4, instance(undefined, env, ty$4)),
            instance(undefined, env, ty$prime),
            cty$1,
            cty$prime
          };
        end else do
          match$40 = transl_simple_type_delayed(env, sty$prime);
          force = match$40[1];
          cty$prime$1 = match$40[0];
          ty$prime$1 = cty$prime$1.ctyp_type;
          begin_def(--[[ () ]]0);
          arg$4 = type_exp(env, sarg$3);
          end_def(--[[ () ]]0);
          tv = newvar(undefined, --[[ () ]]0);
          gen = generalizable(tv.level, arg$4.exp_type);
          unify_var(env, tv, arg$4.exp_type);
          gen$1 = gen;
          match$41 = arg$4.exp_desc;
          match$42 = self_coercion.contents;
          match$43 = repr(ty$prime$1).desc;
          exit$2 = 0;
          if (match$41.tag) then do
            exit$2 = 1;
          end else do
            tmp$2 = match$41[2].val_kind;
            if (typeof tmp$2 == "number" or not (tmp$2.tag == --[[ Val_self ]]2 and match$42 and not (typeof match$43 == "number" or match$43.tag ~= --[[ Tconstr ]]3))) then do
              exit$2 = 1;
            end else do
              match$44 = match$42[0];
              r = match$44[1];
              if (same(match$44[0], match$43[0])) then do
                r.contents = --[[ :: ]]{
                  loc,
                  r.contents
                };
                Curry._1(force, --[[ () ]]0);
              end else do
                exit$2 = 1;
              end end 
            end end 
          end end 
          if (exit$2 == 1) then do
            if (free_variables$1(Caml_option.some(env), arg$4.exp_type) == --[[ [] ]]0 and free_variables$1(Caml_option.some(env), ty$prime$1) == --[[ [] ]]0) then do
              tmp$3 = false;
              if (not gen$1) then do
                snap = snapshot(--[[ () ]]0);
                match$45 = enlarge_type(env, ty$prime$1);
                tmp$4;
                try do
                  Curry._1(force, --[[ () ]]0);
                  unify$2(env, arg$4.exp_type, match$45[0]);
                  tmp$4 = true;
                end
                catch (raw_exn$1)do
                  exn$3 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
                  if (exn$3[0] == Unify) then do
                    backtrack(snap);
                    tmp$4 = false;
                  end else do
                    throw exn$3;
                  end end 
                end
                tmp$3 = tmp$4;
              end
               end 
              if (not tmp$3) then do
                try do
                  force$prime = subtype(env, arg$4.exp_type, ty$prime$1);
                  Curry._1(force, --[[ () ]]0);
                  Curry._1(force$prime, --[[ () ]]0);
                  if (not gen$1) then do
                    prerr_warning(loc, --[[ Not_principal ]]Block.__(8, {"this ground coercion"}));
                  end
                   end 
                end
                catch (raw_exn$2)do
                  exn$4 = Caml_js_exceptions.internalToOCamlException(raw_exn$2);
                  if (exn$4[0] == Subtype) then do
                    throw {
                          __Error$7,
                          loc,
                          env,
                          --[[ Not_subtype ]]Block.__(23, {
                              exn$4[1],
                              exn$4[2]
                            })
                        };
                  end
                   end 
                  throw exn$4;
                end
              end
               end 
            end else do
              match$46 = enlarge_type(env, ty$prime$1);
              Curry._1(force, --[[ () ]]0);
              try do
                unify$2(env, arg$4.exp_type, match$46[0]);
              end
              catch (raw_exn$3)do
                exn$5 = Caml_js_exceptions.internalToOCamlException(raw_exn$3);
                if (exn$5[0] == Unify) then do
                  throw {
                        __Error$7,
                        sarg$3.pexp_loc,
                        env,
                        --[[ Coercion_failure ]]Block.__(25, {
                            ty$prime$1,
                            full_expand(env, ty$prime$1),
                            exn$5[1],
                            match$46[1]
                          })
                      };
                end
                 end 
                throw exn$5;
              end
            end end 
          end
           end 
          match$37 = --[[ tuple ]]{
            arg$4,
            ty$prime$1,
            undefined,
            cty$prime$1
          };
        end end 
        arg$5 = match$37[0];
        return rue(do
                    exp_desc: arg$5.exp_desc,
                    exp_loc: arg$5.exp_loc,
                    exp_extra: --[[ :: ]]{
                      --[[ tuple ]]{
                        --[[ Texp_coerce ]]Block.__(1, {
                            match$37[2],
                            match$37[3]
                          }),
                        loc,
                        sexp.pexp_attributes
                      },
                      arg$5.exp_extra
                    },
                    exp_type: match$37[1],
                    exp_env: env,
                    exp_attributes: arg$5.exp_attributes
                  end);end end end 
     if ___conditional___ = 21--[[ Pexp_send ]] then do
        met = match[1];
        e = match[0];
        if (principal.contents) then do
          begin_def(--[[ () ]]0);
        end
         end 
        obj = type_exp(env, e);
        try do
          match$47 = obj.exp_desc;
          match$48;
          exit$3 = 0;
          if (match$47.tag) then do
            exit$3 = 1;
          end else do
            match$49 = match$47[2].val_kind;
            lid$4 = match$47[1];
            if (typeof match$49 == "number") then do
              exit$3 = 1;
            end else do
              local ___conditional___=(match$49.tag | 0);
              do
                 if ___conditional___ = 2--[[ Val_self ]] then do
                    match$50 = filter_self_method(env, met, --[[ Private ]]0, match$49[0], match$49[3]);
                    typ = match$50[1];
                    if (is_Tvar(repr(typ))) then do
                      prerr_warning(loc, --[[ Undeclared_virtual_method ]]Block.__(7, {met}));
                    end
                     end 
                    match$48 = --[[ tuple ]]{
                      --[[ Tmeth_val ]]Block.__(1, {match$50[0]}),
                      undefined,
                      typ
                    };end else 
                 if ___conditional___ = 3--[[ Val_anc ]] then do
                    cl_num = match$49[1];
                    method_id;
                    try do
                      method_id = List.assoc(met, match$49[0]);
                    end
                    catch (exn$6)do
                      if (exn$6 == Caml_builtin_exceptions.not_found) then do
                        throw {
                              __Error$7,
                              e.pexp_loc,
                              env,
                              --[[ Undefined_inherited_method ]]Block.__(17, {met})
                            };
                      end
                       end 
                      throw exn$6;
                    end
                    match$51 = lookup_value$1(--[[ Lident ]]Block.__(0, {"selfpat-" .. cl_num}), env);
                    match$52 = lookup_value$1(--[[ Lident ]]Block.__(0, {"self-" .. cl_num}), env);
                    desc$3 = match$51[1];
                    match$53 = desc$3.val_kind;
                    if (typeof match$53 == "number") then do
                      throw {
                            Caml_builtin_exceptions.assert_failure,
                            --[[ tuple ]]{
                              "typecore.ml",
                              2384,
                              18
                            }
                          };
                    end else if (match$53.tag == --[[ Val_self ]]2) then do
                      match$54 = filter_self_method(env, met, --[[ Private ]]0, match$53[0], match$53[3]);
                      typ$1 = match$54[1];
                      method_type = newvar(undefined, --[[ () ]]0);
                      match$55 = filter_arrow(env, method_type, "");
                      unify$2(env, match$55[0], desc$3.val_type);
                      unify$2(env, match$55[1], instance(undefined, env, typ$1));
                      exp_000 = do
                        exp_desc: --[[ Texp_ident ]]Block.__(0, {
                            --[[ Pident ]]Block.__(0, {method_id}),
                            lid$4,
                            do
                              val_type: method_type,
                              val_kind: --[[ Val_reg ]]0,
                              val_loc: none,
                              val_attributes: --[[ [] ]]0
                            end
                          }),
                        exp_loc: loc,
                        exp_extra: --[[ [] ]]0,
                        exp_type: method_type,
                        exp_env: env,
                        exp_attributes: --[[ [] ]]0
                      end;
                      exp_001 = --[[ :: ]]{
                        --[[ tuple ]]{
                          "",
                          do
                            exp_desc: --[[ Texp_ident ]]Block.__(0, {
                                match$52[0],
                                lid$4,
                                desc$3
                              }),
                            exp_loc: obj.exp_loc,
                            exp_extra: --[[ [] ]]0,
                            exp_type: desc$3.val_type,
                            exp_env: env,
                            exp_attributes: --[[ [] ]]0
                          end,
                          --[[ Required ]]0
                        },
                        --[[ [] ]]0
                      };
                      exp$2 = --[[ Texp_apply ]]Block.__(4, {
                          exp_000,
                          exp_001
                        });
                      match$48 = --[[ tuple ]]{
                        --[[ Tmeth_name ]]Block.__(0, {met}),
                        re(do
                              exp_desc: exp$2,
                              exp_loc: loc,
                              exp_extra: --[[ [] ]]0,
                              exp_type: typ$1,
                              exp_env: env,
                              exp_attributes: --[[ [] ]]0
                            end),
                        typ$1
                      };
                    end else do
                      throw {
                            Caml_builtin_exceptions.assert_failure,
                            --[[ tuple ]]{
                              "typecore.ml",
                              2384,
                              18
                            }
                          };
                    end end  end end else 
                 do end end end
                else do
                  exit$3 = 1;
                  end end
                  
              end
            end end 
          end end 
          if (exit$3 == 1) then do
            match$48 = --[[ tuple ]]{
              --[[ Tmeth_name ]]Block.__(0, {met}),
              undefined,
              filter_method(env, met, --[[ Public ]]1, obj.exp_type)
            };
          end
           end 
          typ$2 = match$48[2];
          if (principal.contents) then do
            end_def(--[[ () ]]0);
            generalize_structure$1(current_level.contents, typ$2);
          end
           end 
          ty$5 = repr(typ$2);
          match$56 = ty$5.desc;
          typ$3;
          if (typeof match$56 == "number") then do
            throw {
                  Caml_builtin_exceptions.assert_failure,
                  --[[ tuple ]]{
                    "typecore.ml",
                    2410,
                    14
                  }
                };
          end else do
            local ___conditional___=(match$56.tag | 0);
            do
               if ___conditional___ = 0--[[ Tvar ]] then do
                  ty$prime$2 = newvar(undefined, --[[ () ]]0);
                  unify$2(env, instance_def(ty$5), newty2(current_level.contents, --[[ Tpoly ]]Block.__(10, {
                              ty$prime$2,
                              --[[ [] ]]0
                            })));
                  typ$3 = ty$prime$2;end else 
               if ___conditional___ = 10--[[ Tpoly ]] then do
                  tl = match$56[1];
                  ty$6 = match$56[0];
                  if (tl) then do
                    l$2 = ty$5.level;
                    if (principal.contents and l$2 ~= 100000000) then do
                      prerr_warning(loc, --[[ Not_principal ]]Block.__(8, {"this use of a polymorphic method"}));
                    end
                     end 
                    typ$3 = instance_poly(undefined, false, tl, ty$6)[1];
                  end else do
                    typ$3 = instance(undefined, env, ty$6);
                  end end end else 
               do end end end
              else do
                throw {
                      Caml_builtin_exceptions.assert_failure,
                      --[[ tuple ]]{
                        "typecore.ml",
                        2410,
                        14
                      }
                    };
                end end
                
            end
          end end 
          return rue(do
                      exp_desc: --[[ Texp_send ]]Block.__(18, {
                          obj,
                          match$48[0],
                          match$48[1]
                        }),
                      exp_loc: loc,
                      exp_extra: --[[ [] ]]0,
                      exp_type: typ$3,
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    end);
        end
        catch (raw_exn$4)do
          exn$7 = Caml_js_exceptions.internalToOCamlException(raw_exn$4);
          if (exn$7[0] == Unify) then do
            throw {
                  __Error$7,
                  e.pexp_loc,
                  env,
                  --[[ Undefined_method ]]Block.__(16, {
                      obj.exp_type,
                      met
                    })
                };
          end
           end 
          throw exn$7;
        endend else 
     if ___conditional___ = 22--[[ Pexp_new ]] then do
        cl = match[0];
        match$57 = find_class$1(env, loc, cl.txt);
        cl_decl = match$57[1];
        match$58 = cl_decl.cty_new;
        if (match$58 ~= undefined) then do
          return rue(do
                      exp_desc: --[[ Texp_new ]]Block.__(19, {
                          match$57[0],
                          cl,
                          cl_decl
                        }),
                      exp_loc: loc,
                      exp_extra: --[[ [] ]]0,
                      exp_type: instance_def(match$58),
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    end);
        end else do
          throw {
                __Error$7,
                loc,
                env,
                --[[ Virtual_class ]]Block.__(18, {cl.txt})
              };
        end end end end end 
     if ___conditional___ = 23--[[ Pexp_setinstvar ]] then do
        lab = match[0];
        try do
          match$59 = lookup_value$1(--[[ Lident ]]Block.__(0, {lab.txt}), env);
          desc$4 = match$59[1];
          match$60 = desc$4.val_kind;
          exit$4 = 0;
          if (typeof match$60 == "number" or match$60.tag ~= --[[ Val_ivar ]]1) then do
            exit$4 = 1;
          end else if (match$60[0]) then do
            newval = type_expect(undefined, env, match[1], instance(undefined, env, desc$4.val_type));
            match$61 = lookup_value$1(--[[ Lident ]]Block.__(0, {"self-" .. match$60[1]}), env);
            return rue(do
                        exp_desc: --[[ Texp_setinstvar ]]Block.__(21, {
                            match$61[0],
                            match$59[0],
                            lab,
                            newval
                          }),
                        exp_loc: loc,
                        exp_extra: --[[ [] ]]0,
                        exp_type: instance_def(type_unit),
                        exp_env: env,
                        exp_attributes: sexp.pexp_attributes
                      end);
          end else do
            throw {
                  __Error$7,
                  loc,
                  env,
                  --[[ Instance_variable_not_mutable ]]Block.__(22, {
                      true,
                      lab.txt
                    })
                };
          end end  end 
          if (exit$4 == 1) then do
            throw {
                  __Error$7,
                  loc,
                  env,
                  --[[ Instance_variable_not_mutable ]]Block.__(22, {
                      false,
                      lab.txt
                    })
                };
          end
           end 
        end
        catch (exn$8)do
          if (exn$8 == Caml_builtin_exceptions.not_found) then do
            throw {
                  __Error$7,
                  loc,
                  env,
                  --[[ Unbound_instance_variable ]]Block.__(21, {lab.txt})
                };
          end
           end 
          throw exn$8;
        endend else 
     if ___conditional___ = 24--[[ Pexp_override ]] then do
        lst = match[0];
        List.fold_right((function (param, l) do
                lab = param[0];
                if (List.exists((function (l) do
                          return l.txt == lab.txt;
                        end end), l)) then do
                  throw {
                        __Error$7,
                        loc,
                        env,
                        --[[ Value_multiply_overridden ]]Block.__(24, {lab.txt})
                      };
                end
                 end 
                return --[[ :: ]]{
                        lab,
                        l
                      };
              end end), lst, --[[ [] ]]0);
        match$62;
        try do
          match$62 = --[[ tuple ]]{
            lookup_value$1(--[[ Lident ]]Block.__(0, {"selfpat-*"}), env),
            lookup_value$1(--[[ Lident ]]Block.__(0, {"self-*"}), env)
          };
        end
        catch (exn$9)do
          if (exn$9 == Caml_builtin_exceptions.not_found) then do
            throw {
                  __Error$7,
                  loc,
                  env,
                  --[[ Outside_class ]]0
                };
          end
           end 
          throw exn$9;
        end
        match$63 = match$62[0][1];
        match$64 = match$63.val_kind;
        if (typeof match$64 == "number") then do
          throw {
                Caml_builtin_exceptions.assert_failure,
                --[[ tuple ]]{
                  "typecore.ml",
                  2494,
                  10
                }
              };
        end else if (match$64.tag == --[[ Val_self ]]2) then do
          vars = match$64[1];
          type_override = function (param) do
            lab = param[0];
            try do
              match = find(lab.txt, vars.contents);
              return --[[ tuple ]]{
                      --[[ Pident ]]Block.__(0, {match[0]}),
                      lab,
                      type_expect(undefined, env, param[1], instance(undefined, env, match[3]))
                    };
            end
            catch (exn)do
              if (exn == Caml_builtin_exceptions.not_found) then do
                throw {
                      __Error$7,
                      loc,
                      env,
                      --[[ Unbound_instance_variable ]]Block.__(21, {lab.txt})
                    };
              end
               end 
              throw exn;
            end
          end end;
          modifs = List.map(type_override, lst);
          return rue(do
                      exp_desc: --[[ Texp_override ]]Block.__(22, {
                          match$62[1][0],
                          modifs
                        }),
                      exp_loc: loc,
                      exp_extra: --[[ [] ]]0,
                      exp_type: match$63.val_type,
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    end);
        end else do
          throw {
                Caml_builtin_exceptions.assert_failure,
                --[[ tuple ]]{
                  "typecore.ml",
                  2494,
                  10
                }
              };
        end end  end end end end 
     if ___conditional___ = 25--[[ Pexp_letmodule ]] then do
        name$2 = match[0];
        ty$7 = newvar(undefined, --[[ () ]]0);
        begin_def(--[[ () ]]0);
        set_current_time(ty$7.level);
        context = narrow(--[[ () ]]0);
        modl = Curry._2(type_module.contents, env, match[1]);
        match$65 = enter_module(undefined, name$2.txt, modl.mod_type, env);
        new_env = match$65[1];
        init_def(currentstamp.contents);
        widen(context);
        body$4 = type_expect(undefined, new_env, match[2], ty_expected);
        end_def(--[[ () ]]0);
        try do
          unify_var(new_env, ty$7, body$4.exp_type);
        end
        catch (raw_exn$5)do
          exn$10 = Caml_js_exceptions.internalToOCamlException(raw_exn$5);
          if (exn$10[0] == Unify) then do
            throw {
                  __Error$7,
                  loc,
                  env,
                  --[[ Scoping_let_module ]]Block.__(28, {
                      name$2.txt,
                      body$4.exp_type
                    })
                };
          end
           end 
          throw exn$10;
        end
        return re(do
                    exp_desc: --[[ Texp_letmodule ]]Block.__(23, {
                        match$65[0],
                        name$2,
                        modl,
                        body$4
                      }),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: ty$7,
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end);end end end 
     if ___conditional___ = 26--[[ Pexp_assert ]] then do
        cond$2 = type_expect(undefined, env, match[0], type_bool);
        match$66 = cond$2.exp_desc;
        exp_type;
        exp_type = match$66.tag == --[[ Texp_construct ]]8 and match$66[1].cstr_name == "false" and instance(undefined, env, ty_expected) or instance_def(type_unit);
        return rue(do
                    exp_desc: --[[ Texp_assert ]]Block.__(24, {cond$2}),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: exp_type,
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end);end end end 
     if ___conditional___ = 27--[[ Pexp_lazy ]] then do
        ty$8 = newty2(100000000, --[[ Tvar ]]Block.__(0, {undefined}));
        to_unify$2 = type_lazy_t(ty$8);
        unify_exp_types(loc, env, to_unify$2, ty_expected);
        arg$6 = type_expect(undefined, env, match[0], ty$8);
        return re(do
                    exp_desc: --[[ Texp_lazy ]]Block.__(25, {arg$6}),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: instance(undefined, env, ty_expected),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end);end end end 
     if ___conditional___ = 28--[[ Pexp_poly ]] then do
        sty$1 = match[1];
        sbody$1 = match[0];
        if (principal.contents) then do
          begin_def(--[[ () ]]0);
        end
         end 
        match$67;
        if (sty$1 ~= undefined) then do
          sty$2 = force_poly(sty$1);
          cty$2 = transl_simple_type(env, false, sty$2);
          match$67 = --[[ tuple ]]{
            repr(cty$2.ctyp_type),
            cty$2
          };
        end else do
          match$67 = --[[ tuple ]]{
            repr(ty_expected),
            undefined
          };
        end end 
        ty$9 = match$67[0];
        if (principal.contents) then do
          end_def(--[[ () ]]0);
          generalize_structure$1(current_level.contents, ty$9);
        end
         end 
        if (sty$1 ~= undefined) then do
          unify_exp_types(loc, env, instance(undefined, env, ty$9), instance(undefined, env, ty_expected));
        end
         end 
        match$68 = expand_head(env, ty$9).desc;
        exp$3;
        if (typeof match$68 == "number") then do
          throw {
                Caml_builtin_exceptions.assert_failure,
                --[[ tuple ]]{
                  "typecore.ml",
                  2600,
                  15
                }
              };
        end else do
          local ___conditional___=(match$68.tag | 0);
          do
             if ___conditional___ = 0--[[ Tvar ]] then do
                exp$4 = type_exp(env, sbody$1);
                exp_exp_desc = exp$4.exp_desc;
                exp_exp_loc = exp$4.exp_loc;
                exp_exp_extra = exp$4.exp_extra;
                exp_exp_type = newty2(current_level.contents, --[[ Tpoly ]]Block.__(10, {
                        exp$4.exp_type,
                        --[[ [] ]]0
                      }));
                exp_exp_env = exp$4.exp_env;
                exp_exp_attributes = exp$4.exp_attributes;
                exp$5 = do
                  exp_desc: exp_exp_desc,
                  exp_loc: exp_exp_loc,
                  exp_extra: exp_exp_extra,
                  exp_type: exp_exp_type,
                  exp_env: exp_exp_env,
                  exp_attributes: exp_exp_attributes
                end;
                unify_exp(env, exp$5, ty$9);
                exp$3 = exp$5;end else 
             if ___conditional___ = 10--[[ Tpoly ]] then do
                tl$1 = match$68[1];
                ty$prime$3 = match$68[0];
                if (tl$1) then do
                  begin_def(--[[ () ]]0);
                  if (principal.contents) then do
                    begin_def(--[[ () ]]0);
                  end
                   end 
                  match$69 = instance_poly(undefined, true, tl$1, ty$prime$3);
                  ty$prime$prime = match$69[1];
                  if (principal.contents) then do
                    end_def(--[[ () ]]0);
                    generalize_structure$1(current_level.contents, ty$prime$prime);
                  end
                   end 
                  exp$6 = type_expect(undefined, env, sbody$1, ty$prime$prime);
                  end_def(--[[ () ]]0);
                  check_univars(env, false, "method", exp$6, ty_expected, match$69[0]);
                  exp$3 = do
                    exp_desc: exp$6.exp_desc,
                    exp_loc: exp$6.exp_loc,
                    exp_extra: exp$6.exp_extra,
                    exp_type: instance(undefined, env, ty$9),
                    exp_env: exp$6.exp_env,
                    exp_attributes: exp$6.exp_attributes
                  end;
                end else do
                  exp$7 = type_expect(undefined, env, sbody$1, ty$prime$3);
                  exp$3 = do
                    exp_desc: exp$7.exp_desc,
                    exp_loc: exp$7.exp_loc,
                    exp_extra: exp$7.exp_extra,
                    exp_type: instance(undefined, env, ty$9),
                    exp_env: exp$7.exp_env,
                    exp_attributes: exp$7.exp_attributes
                  end;
                end end end else 
             do end end end
            else do
              throw {
                    Caml_builtin_exceptions.assert_failure,
                    --[[ tuple ]]{
                      "typecore.ml",
                      2600,
                      15
                    }
                  };
              end end
              
          end
        end end 
        return re(do
                    exp_desc: exp$3.exp_desc,
                    exp_loc: exp$3.exp_loc,
                    exp_extra: --[[ :: ]]{
                      --[[ tuple ]]{
                        --[[ Texp_poly ]]Block.__(3, {match$67[1]}),
                        loc,
                        sexp.pexp_attributes
                      },
                      exp$3.exp_extra
                    },
                    exp_type: exp$3.exp_type,
                    exp_env: exp$3.exp_env,
                    exp_attributes: exp$3.exp_attributes
                  end);end end end 
     if ___conditional___ = 29--[[ Pexp_object ]] then do
        match$70 = Curry._3(type_object.contents, env, loc, match[0]);
        return rue(do
                    exp_desc: --[[ Texp_object ]]Block.__(26, {
                        match$70[0],
                        match$70[2]
                      }),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: match$70[1].csig_self,
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end);end end end 
     if ___conditional___ = 30--[[ Pexp_newtype ]] then do
        name$3 = match[0];
        ty$10 = newvar(undefined, --[[ () ]]0);
        begin_def(--[[ () ]]0);
        level = current_level.contents;
        decl_type_newtype_level = --[[ tuple ]]{
          level,
          level
        };
        decl$1 = do
          type_params: --[[ [] ]]0,
          type_arity: 0,
          type_kind: --[[ Type_abstract ]]0,
          type_private: --[[ Public ]]1,
          type_manifest: undefined,
          type_variance: --[[ [] ]]0,
          type_newtype_level: decl_type_newtype_level,
          type_loc: loc,
          type_attributes: --[[ [] ]]0
        end;
        set_current_time(ty$10.level);
        match$71 = enter_type(name$3, decl$1, env);
        id = match$71[0];
        init_def(currentstamp.contents);
        body$5 = type_exp(match$71[1], match[1]);
        seen = Hashtbl.create(undefined, 8);
        replace = function (t) do
          if (Hashtbl.mem(seen, t.id)) then do
            return --[[ () ]]0;
          end else do
            Hashtbl.add(seen, t.id, --[[ () ]]0);
            match = t.desc;
            if (typeof match == "number" or match.tag ~= --[[ Tconstr ]]3) then do
              return iter_type_expr(replace, t);
            end else do
              match$1 = match[0];
              local ___conditional___=(match$1.tag | 0);
              do
                 if ___conditional___ = 0--[[ Pident ]] then do
                    if (id == match$1[0]) then do
                      return link_type(t, ty$10);
                    end else do
                      return iter_type_expr(replace, t);
                    end end end end end 
                 if ___conditional___ = 1--[[ Pdot ]]
                 or ___conditional___ = 2--[[ Papply ]] then do
                    return iter_type_expr(replace, t);end end end 
                 do
                
              end
            end end 
          end end 
        end end;
        ety = type_expr(identity, body$5.exp_type);
        replace(ety);
        end_def(--[[ () ]]0);
        return rue(do
                    exp_desc: body$5.exp_desc,
                    exp_loc: loc,
                    exp_extra: --[[ :: ]]{
                      --[[ tuple ]]{
                        --[[ Texp_newtype ]]Block.__(4, {name$3}),
                        loc,
                        sexp.pexp_attributes
                      },
                      body$5.exp_extra
                    },
                    exp_type: ety,
                    exp_env: body$5.exp_env,
                    exp_attributes: body$5.exp_attributes
                  end);end end end 
     if ___conditional___ = 31--[[ Pexp_pack ]] then do
        match$72 = expand_head(env, instance(undefined, env, ty_expected));
        match$73 = match$72.desc;
        match$74;
        if (typeof match$73 == "number") then do
          throw {
                __Error$7,
                loc,
                env,
                --[[ Not_a_packed_module ]]Block.__(32, {ty_expected})
              };
        end else do
          local ___conditional___=(match$73.tag | 0);
          do
             if ___conditional___ = 0--[[ Tvar ]] then do
                throw {
                      __Error$7,
                      loc,
                      env,
                      --[[ Cannot_infer_signature ]]3
                    };end end end 
             if ___conditional___ = 11--[[ Tpackage ]] then do
                if (principal.contents and expand_head(env, ty_expected).level < 100000000) then do
                  prerr_warning(loc, --[[ Not_principal ]]Block.__(8, {"this module packing"}));
                end
                 end 
                match$74 = --[[ tuple ]]{
                  match$73[0],
                  match$73[1],
                  match$73[2]
                };end else 
             do end
            else do
              throw {
                    __Error$7,
                    loc,
                    env,
                    --[[ Not_a_packed_module ]]Block.__(32, {ty_expected})
                  };
              end end
              
          end
        end end 
        nl = match$74[1];
        p = match$74[0];
        match$75 = Curry._5(type_package.contents, env, match[0], p, nl, match$74[2]);
        return rue(do
                    exp_desc: --[[ Texp_pack ]]Block.__(27, {match$75[0]}),
                    exp_loc: loc,
                    exp_extra: --[[ [] ]]0,
                    exp_type: newty2(current_level.contents, --[[ Tpackage ]]Block.__(11, {
                            p,
                            nl,
                            match$75[1]
                          })),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  end);end end end 
     if ___conditional___ = 32--[[ Pexp_open ]] then do
        lid$5 = match[1];
        ovf = match[0];
        match$76 = Curry._4(type_open.contents, ovf, env, sexp.pexp_loc, lid$5);
        newenv = match$76[1];
        exp$8 = type_expect(undefined, newenv, match[2], ty_expected);
        return do
                exp_desc: exp$8.exp_desc,
                exp_loc: exp$8.exp_loc,
                exp_extra: --[[ :: ]]{
                  --[[ tuple ]]{
                    --[[ Texp_open ]]Block.__(2, {
                        ovf,
                        match$76[0],
                        lid$5,
                        newenv
                      }),
                    loc,
                    sexp.pexp_attributes
                  },
                  exp$8.exp_extra
                },
                exp_type: exp$8.exp_type,
                exp_env: exp$8.exp_env,
                exp_attributes: exp$8.exp_attributes
              end;end end end 
     if ___conditional___ = 33--[[ Pexp_extension ]] then do
        throw {
              Error_forward$1,
              error_of_extension(match[0])
            };end end end 
     do
    
  end
end end

function type_function(in_function, loc, attrs, env, ty_expected, l, caselist) do
  match = in_function ~= undefined and in_function or --[[ tuple ]]{
      loc,
      instance(undefined, env, ty_expected)
    };
  ty_fun = match[1];
  loc_fun = match[0];
  separate = principal.contents or env.local_constraints;
  if (separate) then do
    begin_def(--[[ () ]]0);
  end
   end 
  match$1;
  try do
    match$1 = filter_arrow(env, instance(undefined, env, ty_expected), l);
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      ty = expand_head(env, ty_expected);
      match$2 = ty.desc;
      exit = 0;
      if (typeof match$2 == "number" or match$2.tag ~= --[[ Tarrow ]]1) then do
        exit = 1;
      end else do
        throw {
              __Error$7,
              loc,
              env,
              --[[ Abstract_wrong_label ]]Block.__(27, {
                  l,
                  ty
                })
            };
      end end 
      if (exit == 1) then do
        throw {
              __Error$7,
              loc_fun,
              env,
              --[[ Too_many_arguments ]]Block.__(26, {
                  in_function ~= undefined,
                  ty_fun
                })
            };
      end
       end 
    end else do
      throw exn;
    end end 
  end
  ty_res = match$1[1];
  ty_arg = match$1[0];
  ty_arg$1;
  if (is_optional(l)) then do
    tv = newvar(undefined, --[[ () ]]0);
    try do
      unify$2(env, ty_arg, type_option$1(tv));
    end
    catch (raw_exn$1)do
      exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
      if (exn$1[0] == Unify) then do
        throw {
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "typecore.ml",
                2706,
                24
              }
            };
      end
       end 
      throw exn$1;
    end
    ty_arg$1 = type_option$1(tv);
  end else do
    ty_arg$1 = ty_arg;
  end end 
  if (separate) then do
    end_def(--[[ () ]]0);
    generalize_structure$1(current_level.contents, ty_arg$1);
    generalize_structure$1(current_level.contents, ty_res);
  end
   end 
  match$3 = type_cases(--[[ tuple ]]{
        loc_fun,
        ty_fun
      }, env, ty_arg$1, ty_res, true, loc, caselist);
  cases = match$3[0];
  not_function = function (ty) do
    match = list_labels(env, ty);
    if (match[0] == --[[ [] ]]0) then do
      return not match[1];
    end else do
      return false;
    end end 
  end end;
  if (is_optional(l) and not_function(ty_res)) then do
    prerr_warning(List.hd(cases).c_lhs.pat_loc, --[[ Unerasable_optional_argument ]]8);
  end
   end 
  return re(do
              exp_desc: --[[ Texp_function ]]Block.__(3, {
                  l,
                  cases,
                  match$3[1]
                }),
              exp_loc: loc,
              exp_extra: --[[ [] ]]0,
              exp_type: instance(undefined, env, newty2(100000000, --[[ Tarrow ]]Block.__(1, {
                          l,
                          ty_arg$1,
                          ty_res,
                          --[[ Cok ]]0
                        }))),
              exp_env: env,
              exp_attributes: attrs
            end);
end end

function type_label_access(env, loc, srecord, lid) do
  if (principal.contents) then do
    begin_def(--[[ () ]]0);
  end
   end 
  record = type_exp(env, srecord);
  if (principal.contents) then do
    end_def(--[[ () ]]0);
    generalize_structure$1(current_level.contents, record.exp_type);
  end
   end 
  ty_exp = record.exp_type;
  opath;
  try do
    match = extract_concrete_record(env, ty_exp);
    opath = --[[ tuple ]]{
      match[0],
      match[1],
      ty_exp.level == 100000000 or not principal.contents
    };
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      opath = undefined;
    end else do
      throw exn;
    end end 
  end
  labels = find_all_labels(env, lid.loc, lid.txt);
  label = wrap_disambiguate("This expression has", ty_exp, (function (param) do
          return disambiguate(undefined, undefined, undefined, lid, env, opath, param);
        end end), labels);
  return --[[ tuple ]]{
          record,
          label,
          opath
        };
end end

function type_format(loc, str, env) do
  throw {
        Caml_builtin_exceptions.assert_failure,
        --[[ tuple ]]{
          "typecore.ml",
          2759,
          11
        }
      };
end end

function type_label_exp(create, env, loc, ty_expected, param) do
  sarg = param[2];
  label = param[1];
  lid = param[0];
  begin_def(--[[ () ]]0);
  separate = principal.contents or env.local_constraints;
  if (separate) then do
    begin_def(--[[ () ]]0);
    begin_def(--[[ () ]]0);
  end
   end 
  match = instance_label(true, label);
  ty_res = match[2];
  ty_arg = match[1];
  vars = match[0];
  if (separate) then do
    end_def(--[[ () ]]0);
    generalize_structure$1(current_level.contents, ty_arg);
    generalize_structure$1(current_level.contents, ty_res);
  end
   end 
  try do
    unify$2(env, instance_def(ty_res), instance(undefined, env, ty_expected));
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      throw {
            __Error$7,
            lid.loc,
            env,
            --[[ Label_mismatch ]]Block.__(2, {
                lid.txt,
                exn[1]
              })
          };
    end
     end 
    throw exn;
  end
  ty_arg$1 = instance_def(ty_arg);
  if (separate) then do
    end_def(--[[ () ]]0);
    generalize_structure$1(current_level.contents, ty_arg$1);
  end
   end 
  if (label.lbl_private == --[[ Private ]]0) then do
    if (create) then do
      throw {
            __Error$7,
            loc,
            env,
            --[[ Private_type ]]Block.__(19, {ty_expected})
          };
    end
     end 
    throw {
          __Error$7,
          lid.loc,
          env,
          --[[ Private_label ]]Block.__(20, {
              lid.txt,
              ty_expected
            })
        };
  end
   end 
  snap = vars == --[[ [] ]]0 and undefined or Caml_option.some(snapshot(--[[ () ]]0));
  arg = type_argument(env, sarg, ty_arg$1, instance(undefined, env, ty_arg$1));
  end_def(--[[ () ]]0);
  arg$1;
  try do
    check_univars(env, vars ~= --[[ [] ]]0, "field value", arg, label.lbl_arg, vars);
    arg$1 = arg;
  end
  catch (exn$1)do
    if (is_nonexpansive(arg)) then do
      throw exn$1;
    end else do
      try do
        may(backtrack, snap);
        begin_def(--[[ () ]]0);
        arg$2 = type_exp(env, sarg);
        end_def(--[[ () ]]0);
        generalize_expansive$1(env, arg$2.exp_type);
        unify_exp(env, arg$2, ty_arg$1);
        check_univars(env, false, "field value", arg$2, label.lbl_arg, vars);
        arg$1 = arg$2;
      end
      catch (raw_e)do
        e = Caml_js_exceptions.internalToOCamlException(raw_e);
        if (e[0] == __Error$7) then do
          tmp = e[3];
          if (typeof tmp == "number") then do
            throw exn$1;
          end else if (tmp.tag == --[[ Less_general ]]31) then do
            throw e;
          end else do
            throw exn$1;
          end end  end 
        end else do
          throw exn$1;
        end end 
      end
    end end 
  end
  return --[[ tuple ]]{
          lid,
          label,
          do
            exp_desc: arg$1.exp_desc,
            exp_loc: arg$1.exp_loc,
            exp_extra: arg$1.exp_extra,
            exp_type: instance(undefined, env, arg$1.exp_type),
            exp_env: arg$1.exp_env,
            exp_attributes: arg$1.exp_attributes
          end
        };
end end

function type_argument(env, sarg, ty_expected$prime, ty_expected) do
  no_labels = function (ty) do
    match = list_labels(env, ty);
    if (match[1]) then do
      return false;
    end else do
      return List.for_all((function (param) do
                    return "" == param;
                  end end), match[0]);
    end end 
  end end;
  is_inferred = function (_sexp) do
    while(true) do
      sexp = _sexp;
      match = sexp.pexp_desc;
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 15--[[ Pexp_ifthenelse ]] then do
            match$1 = match[2];
            if (match$1 ~= undefined and is_inferred(match[1])) then do
              _sexp = match$1;
              continue ;
            end else do
              return false;
            end end end end end 
         if ___conditional___ = 16--[[ Pexp_sequence ]] then do
            _sexp = match[1];
            continue ;end end end 
         if ___conditional___ = 0--[[ Pexp_ident ]]
         or ___conditional___ = 5--[[ Pexp_apply ]]
         or ___conditional___ = 12--[[ Pexp_field ]]
         or ___conditional___ = 19--[[ Pexp_constraint ]]
         or ___conditional___ = 20--[[ Pexp_coerce ]]
         or ___conditional___ = 21--[[ Pexp_send ]]
         or ___conditional___ = 22--[[ Pexp_new ]] then do
            return true;end end end 
         if ___conditional___ = 32--[[ Pexp_open ]] then do
            _sexp = match[2];
            continue ;end end end 
         do
        else do
          return false;
          end end
          
      end
    end;
  end end;
  match = expand_head(env, ty_expected$prime);
  match$1 = match.desc;
  if (typeof match$1 ~= "number" and match$1.tag == --[[ Tarrow ]]1 and match$1[0] == "") then do
    ty_res = match$1[2];
    lv = match.level;
    if (is_inferred(sarg)) then do
      if (principal.contents) then do
        begin_def(--[[ () ]]0);
      end
       end 
      texp = type_exp(env, sarg);
      if (principal.contents) then do
        end_def(--[[ () ]]0);
        generalize_structure$1(current_level.contents, texp.exp_type);
      end
       end 
      make_args = function (_args, _ty_fun) do
        while(true) do
          ty_fun = _ty_fun;
          args = _args;
          match = expand_head(env, ty_fun).desc;
          if (typeof match ~= "number") then do
            local ___conditional___=(match.tag | 0);
            do
               if ___conditional___ = 0--[[ Tvar ]] then do
                  return --[[ tuple ]]{
                          List.rev(args),
                          ty_fun,
                          false
                        };end end end 
               if ___conditional___ = 1--[[ Tarrow ]] then do
                  ty_fun$1 = match[2];
                  l = match[0];
                  if (is_optional(l)) then do
                    ty = option_none(instance(undefined, env, match[1]), sarg.pexp_loc);
                    _ty_fun = ty_fun$1;
                    _args = --[[ :: ]]{
                      --[[ tuple ]]{
                        l,
                        ty,
                        --[[ Optional ]]1
                      },
                      args
                    };
                    continue ;
                  end else if (l == "" or classic.contents) then do
                    return --[[ tuple ]]{
                            List.rev(args),
                            ty_fun,
                            no_labels(ty_fun$1)
                          };
                  end
                   end  end end else 
               do end
              else do
                end end
                
            end
          end
           end 
          return --[[ tuple ]]{
                  --[[ [] ]]0,
                  texp.exp_type,
                  false
                };
        end;
      end end;
      match$2 = make_args(--[[ [] ]]0, texp.exp_type);
      ty_fun$prime = match$2[1];
      args = match$2[0];
      warn = principal.contents and (lv ~= 100000000 or repr(ty_fun$prime).level ~= 100000000);
      texp_exp_desc = texp.exp_desc;
      texp_exp_loc = texp.exp_loc;
      texp_exp_extra = texp.exp_extra;
      texp_exp_type = instance(undefined, env, texp.exp_type);
      texp_exp_env = texp.exp_env;
      texp_exp_attributes = texp.exp_attributes;
      texp$1 = do
        exp_desc: texp_exp_desc,
        exp_loc: texp_exp_loc,
        exp_extra: texp_exp_extra,
        exp_type: texp_exp_type,
        exp_env: texp_exp_env,
        exp_attributes: texp_exp_attributes
      end;
      ty_fun = instance(undefined, env, ty_fun$prime);
      if (match$2[2] or no_labels(ty_res)) then do
        unify_exp(env, do
              exp_desc: texp_exp_desc,
              exp_loc: texp_exp_loc,
              exp_extra: texp_exp_extra,
              exp_type: ty_fun,
              exp_env: texp_exp_env,
              exp_attributes: texp_exp_attributes
            end, ty_expected);
        if (args == --[[ [] ]]0) then do
          return texp$1;
        end else do
          var_pair = function (name, ty) do
            id = create(name);
            return --[[ tuple ]]{
                    do
                      pat_desc: --[[ Tpat_var ]]Block.__(0, {
                          id,
                          do
                            txt: name,
                            loc: none
                          end
                        }),
                      pat_loc: none,
                      pat_extra: --[[ [] ]]0,
                      pat_type: ty,
                      pat_env: env,
                      pat_attributes: --[[ [] ]]0
                    end,
                    do
                      exp_desc: --[[ Texp_ident ]]Block.__(0, {
                          --[[ Pident ]]Block.__(0, {id}),
                          do
                            txt: --[[ Lident ]]Block.__(0, {name}),
                            loc: none
                          end,
                          do
                            val_type: ty,
                            val_kind: --[[ Val_reg ]]0,
                            val_loc: none,
                            val_attributes: --[[ [] ]]0
                          end
                        }),
                      exp_loc: none,
                      exp_extra: --[[ [] ]]0,
                      exp_type: ty,
                      exp_env: env,
                      exp_attributes: --[[ [] ]]0
                    end
                  };
          end end;
          match$3 = var_pair("eta", match$1[1]);
          eta_var = match$3[1];
          eta_pat = match$3[0];
          func = function (texp) do
            e_exp_desc = --[[ Texp_apply ]]Block.__(4, {
                texp,
                Pervasives.$at(args, --[[ :: ]]{
                      --[[ tuple ]]{
                        "",
                        eta_var,
                        --[[ Required ]]0
                      },
                      --[[ [] ]]0
                    })
              });
            e_exp_loc = texp.exp_loc;
            e_exp_extra = texp.exp_extra;
            e_exp_env = texp.exp_env;
            e_exp_attributes = texp.exp_attributes;
            e = do
              exp_desc: e_exp_desc,
              exp_loc: e_exp_loc,
              exp_extra: e_exp_extra,
              exp_type: ty_res,
              exp_env: e_exp_env,
              exp_attributes: e_exp_attributes
            end;
            return do
                    exp_desc: --[[ Texp_function ]]Block.__(3, {
                        "",
                        --[[ :: ]]{
                          do
                            c_lhs: eta_pat,
                            c_guard: undefined,
                            c_rhs: e
                          end,
                          --[[ [] ]]0
                        },
                        --[[ Total ]]1
                      }),
                    exp_loc: texp.exp_loc,
                    exp_extra: texp.exp_extra,
                    exp_type: ty_fun,
                    exp_env: texp.exp_env,
                    exp_attributes: texp.exp_attributes
                  end;
          end end;
          prerr_warning(texp_exp_loc, --[[ Eliminated_optional_arguments ]]Block.__(31, {List.map((function (param) do
                          return param[0];
                        end end), args)}));
          if (warn) then do
            prerr_warning(texp_exp_loc, --[[ Without_principality ]]Block.__(9, {"eliminated optional argument"}));
          end
           end 
          if (is_nonexpansive(texp$1)) then do
            return func(texp$1);
          end else do
            match$4 = var_pair("arg", texp_exp_type);
            return re(do
                        exp_desc: --[[ Texp_let ]]Block.__(2, {
                            --[[ Nonrecursive ]]0,
                            --[[ :: ]]{
                              do
                                vb_pat: match$4[0],
                                vb_expr: texp$1,
                                vb_attributes: --[[ [] ]]0,
                                vb_loc: none
                              end,
                              --[[ [] ]]0
                            },
                            func(match$4[1])
                          }),
                        exp_loc: texp_exp_loc,
                        exp_extra: texp_exp_extra,
                        exp_type: ty_fun,
                        exp_env: texp_exp_env,
                        exp_attributes: texp_exp_attributes
                      end);
          end end 
        end end 
      end else do
        unify_exp(env, texp$1, ty_expected);
        return texp$1;
      end end 
    end
     end 
  end
   end 
  texp$2 = type_expect(undefined, env, sarg, ty_expected$prime);
  unify_exp(env, texp$2, ty_expected);
  return texp$2;
end end

function type_application(env, funct, sargs) do
  result_type = function (omitted, ty_fun) do
    return List.fold_left((function (ty_fun, param) do
                  return newty2(param[2], --[[ Tarrow ]]Block.__(1, {
                                param[0],
                                param[1],
                                ty_fun,
                                --[[ Cok ]]0
                              }));
                end end), ty_fun, omitted);
  end end;
  has_label = function (l, ty_fun) do
    match = list_labels(env, ty_fun);
    if (match[1]) then do
      return true;
    end else do
      return List.mem(l, match[0]);
    end end 
  end end;
  ignored = do
    contents: --[[ [] ]]0
  end;
  ignore_labels = true;
  if (not classic.contents) then do
    match = list_labels(env, funct.exp_type);
    tmp = false;
    if (not match[1]) then do
      labels = List.filter((function (l) do
                return not is_optional(l);
              end end))(match[0]);
      tmp = List.length(labels) == List.length(sargs) and List.for_all((function (param) do
              return param[0] == "";
            end end), sargs) and List.exists((function (l) do
              return l ~= "";
            end end), labels) and (prerr_warning(funct.exp_loc, --[[ Labels_omitted ]]3), true);
    end
     end 
    ignore_labels = tmp;
  end
   end 
  warned = do
    contents: false
  end;
  type_args = function (_args, _omitted, _ty_fun, _ty_fun0, _ty_old, _sargs, _more_sargs) do
    while(true) do
      more_sargs = _more_sargs;
      sargs = _sargs;
      ty_old = _ty_old;
      ty_fun0 = _ty_fun0;
      ty_fun = _ty_fun;
      omitted = _omitted;
      args = _args;
      match = expand_head(env, ty_fun);
      match$1 = expand_head(env, ty_fun0);
      match$2 = match.desc;
      exit = 0;
      if (typeof match$2 == "number" or match$2.tag ~= --[[ Tarrow ]]1) then do
        exit = 1;
      end else do
        ty_fun$1 = match$2[2];
        ty = match$2[1];
        l = match$2[0];
        lv = match.level;
        match$3 = match$1.desc;
        if (typeof match$3 == "number" or match$3.tag ~= --[[ Tarrow ]]1) then do
          exit = 1;
        end else do
          ty0 = match$3[1];
          if ((sargs ~= --[[ [] ]]0 or more_sargs ~= --[[ [] ]]0) and commu_repr(match$2[3]) == --[[ Cok ]]0) then do
            may_warn = (function(lv)do
            return function may_warn(loc, w) do
              if (not warned.contents and principal.contents and lv ~= 100000000) then do
                warned.contents = true;
                return prerr_warning(loc, w);
              end else do
                return 0;
              end end 
            end end
            end(lv));
            name = label_name(l);
            optional = is_optional(l) and --[[ Optional ]]1 or --[[ Required ]]0;
            match$4;
            if (ignore_labels and not is_optional(l)) then do
              if (sargs) then do
                match$5 = sargs[0];
                throw {
                      __Error$7,
                      match$5[1].pexp_loc,
                      env,
                      --[[ Apply_wrong_label ]]Block.__(9, {
                          match$5[0],
                          ty_old
                        })
                    };
              end else if (more_sargs) then do
                match$6 = more_sargs[0];
                sarg0 = match$6[1];
                l$prime = match$6[0];
                if (l ~= l$prime and l$prime ~= "") then do
                  throw {
                        __Error$7,
                        sarg0.pexp_loc,
                        env,
                        --[[ Apply_wrong_label ]]Block.__(9, {
                            l$prime,
                            match
                          })
                      };
                end
                 end 
                match$4 = --[[ tuple ]]{
                  --[[ [] ]]0,
                  more_sargs[1],
                  (function(ty,ty0,sarg0)do
                  return function (param) do
                    return type_argument(env, sarg0, ty, ty0);
                  end end
                  end(ty,ty0,sarg0))
                };
              end else do
                throw {
                      Caml_builtin_exceptions.assert_failure,
                      --[[ tuple ]]{
                        "typecore.ml",
                        3250,
                        16
                      }
                    };
              end end  end 
            end else do
              try do
                match$7;
                try do
                  match$8 = extract_label_aux(--[[ [] ]]0, name, sargs);
                  sargs1 = match$8[2];
                  sarg0$1 = match$8[1];
                  if (sargs1 ~= --[[ [] ]]0) then do
                    may_warn(sarg0$1.pexp_loc, --[[ Not_principal ]]Block.__(8, {"commuting this argument"}));
                  end
                   end 
                  match$7 = --[[ tuple ]]{
                    match$8[0],
                    sarg0$1,
                    Pervasives.$at(sargs1, match$8[3]),
                    more_sargs
                  };
                end
                catch (exn)do
                  if (exn == Caml_builtin_exceptions.not_found) then do
                    match$9 = extract_label_aux(--[[ [] ]]0, name, more_sargs);
                    sargs1$1 = match$9[2];
                    sarg0$2 = match$9[1];
                    if (sargs1$1 ~= --[[ [] ]]0 or sargs ~= --[[ [] ]]0) then do
                      may_warn(sarg0$2.pexp_loc, --[[ Not_principal ]]Block.__(8, {"commuting this argument"}));
                    end
                     end 
                    match$7 = --[[ tuple ]]{
                      match$9[0],
                      sarg0$2,
                      Pervasives.$at(sargs, sargs1$1),
                      match$9[3]
                    };
                  end else do
                    throw exn;
                  end end 
                end
                sarg0$3 = match$7[1];
                l$prime$1 = match$7[0];
                if (optional == --[[ Required ]]0 and is_optional(l$prime$1)) then do
                  prerr_warning(sarg0$3.pexp_loc, --[[ Nonoptional_label ]]Block.__(26, {l}));
                end
                 end 
                match$4 = --[[ tuple ]]{
                  match$7[2],
                  match$7[3],
                  optional == --[[ Required ]]0 or is_optional(l$prime$1) and (function(ty,ty0,sarg0$3)do
                    return function (param) do
                      return type_argument(env, sarg0$3, ty, ty0);
                    end end
                    end(ty,ty0,sarg0$3)) or (may_warn(sarg0$3.pexp_loc, --[[ Not_principal ]]Block.__(8, {"using an optional argument here"})), (function(ty,ty0,sarg0$3)do
                      return function (param) do
                        return option_some(type_argument(env, sarg0$3, extract_option_type(env, ty), extract_option_type(env, ty0)));
                      end end
                      end(ty,ty0,sarg0$3)))
                };
              end
              catch (exn$1)do
                if (exn$1 == Caml_builtin_exceptions.not_found) then do
                  match$4 = --[[ tuple ]]{
                    sargs,
                    more_sargs,
                    optional == --[[ Optional ]]1 and (List.mem_assoc("", sargs) or List.mem_assoc("", more_sargs)) and (may_warn(funct.exp_loc, --[[ Without_principality ]]Block.__(9, {"eliminated optional argument"})), ignored.contents = --[[ :: ]]{
                          --[[ tuple ]]{
                            l,
                            ty,
                            lv
                          },
                          ignored.contents
                        }, (function(ty)do
                        return function (param) do
                          return option_none(instance(undefined, env, ty), none);
                        end end
                        end(ty))) or (may_warn(funct.exp_loc, --[[ Without_principality ]]Block.__(9, {"commuted an argument"})), undefined)
                  };
                end else do
                  throw exn$1;
                end end 
              end
            end end 
            arg = match$4[2];
            sargs$1 = match$4[0];
            omitted$1 = arg == undefined and --[[ :: ]]{
                --[[ tuple ]]{
                  l,
                  ty,
                  lv
                },
                omitted
              } or omitted;
            ty_old$1 = sargs$1 == --[[ [] ]]0 and ty_fun$1 or ty_old;
            _more_sargs = match$4[1];
            _sargs = sargs$1;
            _ty_old = ty_old$1;
            _ty_fun0 = match$3[2];
            _ty_fun = ty_fun$1;
            _omitted = omitted$1;
            _args = --[[ :: ]]{
              --[[ tuple ]]{
                l,
                arg,
                optional
              },
              args
            };
            continue ;
          end else do
            exit = 1;
          end end 
        end end 
      end end 
      if (exit == 1) then do
        if (sargs and ignore_labels) then do
          match$10 = sargs[0];
          throw {
                __Error$7,
                match$10[1].pexp_loc,
                env,
                --[[ Apply_wrong_label ]]Block.__(9, {
                    match$10[0],
                    ty_old
                  })
              };
        end
         end 
        _args$1 = args;
        omitted$2 = omitted;
        _ty_fun$1 = ty_fun0;
        _param = Pervasives.$at(sargs, more_sargs);
        while(true) do
          param = _param;
          ty_fun$2 = _ty_fun$1;
          args$1 = _args$1;
          if (param) then do
            match$11 = param[0];
            sarg1 = match$11[1];
            l1 = match$11[0];
            ty_fun$3 = expand_head(env, ty_fun$2);
            td = ty_fun$3.desc;
            match$12;
            exit$1 = 0;
            if (typeof td == "number") then do
              exit$1 = 1;
            end else do
              local ___conditional___=(td.tag | 0);
              do
                 if ___conditional___ = 0--[[ Tvar ]] then do
                    t1 = newvar(undefined, --[[ () ]]0);
                    t2 = newvar(undefined, --[[ () ]]0);
                    not_identity = function (param) do
                      if (param.tag) then do
                        return true;
                      end else do
                        match = param[2].val_kind;
                        if (typeof match == "number" or match.tag or match[0].prim_name ~= "%identity") then do
                          return true;
                        end else do
                          return false;
                        end end 
                      end end 
                    end end;
                    if (ty_fun$3.level >= t1.level and not_identity(funct.exp_desc)) then do
                      prerr_warning(sarg1.pexp_loc, --[[ Unused_argument ]]9);
                    end
                     end 
                    unify$2(env, ty_fun$3, newty2(current_level.contents, --[[ Tarrow ]]Block.__(1, {
                                l1,
                                t1,
                                t2,
                                --[[ Clink ]]{do
                                    contents: --[[ Cunknown ]]1
                                  end}
                              })));
                    match$12 = --[[ tuple ]]{
                      t1,
                      t2
                    };end else 
                 if ___conditional___ = 1--[[ Tarrow ]] then do
                    l$1 = td[0];
                    if (l$1 == l1 or classic.contents and l1 == "" and not is_optional(l$1)) then do
                      match$12 = --[[ tuple ]]{
                        td[1],
                        td[2]
                      };
                    end else do
                      exit$1 = 1;
                    end end end else 
                 do end end end
                else do
                  exit$1 = 1;
                  end end
                  
              end
            end end 
            if (exit$1 == 1) then do
              ty_fun$4;
              ty_fun$4 = typeof td == "number" or td.tag ~= --[[ Tarrow ]]1 and ty_fun$3 or newty2(current_level.contents, td);
              ty_res = result_type(Pervasives.$at(omitted$2, ignored.contents), ty_fun$4);
              match$13 = ty_res.desc;
              exit$2 = 0;
              if (typeof match$13 == "number" or match$13.tag ~= --[[ Tarrow ]]1) then do
                exit$2 = 2;
              end else do
                if (classic.contents or not has_label(l1, ty_fun$4)) then do
                  throw {
                        __Error$7,
                        sarg1.pexp_loc,
                        env,
                        --[[ Apply_wrong_label ]]Block.__(9, {
                            l1,
                            ty_res
                          })
                      };
                end
                 end 
                throw {
                      __Error$7,
                      funct.exp_loc,
                      env,
                      --[[ Incoherent_label_order ]]1
                    };
              end end 
              if (exit$2 == 2) then do
                throw {
                      __Error$7,
                      funct.exp_loc,
                      env,
                      --[[ Apply_non_function ]]Block.__(8, {expand_head(env, funct.exp_type)})
                    };
              end
               end 
            end
             end 
            ty1 = match$12[0];
            optional$1 = is_optional(l1) and --[[ Optional ]]1 or --[[ Required ]]0;
            arg1 = (function(sarg1,ty1,optional$1)do
            return function arg1(param) do
              arg1$1 = type_expect(undefined, env, sarg1, ty1);
              if (optional$1 == --[[ Optional ]]1) then do
                unify_exp(env, arg1$1, type_option$1(newvar(undefined, --[[ () ]]0)));
              end
               end 
              return arg1$1;
            end end
            end(sarg1,ty1,optional$1));
            _param = param[1];
            _ty_fun$1 = match$12[1];
            _args$1 = --[[ :: ]]{
              --[[ tuple ]]{
                l1,
                arg1,
                optional$1
              },
              args$1
            };
            continue ;
          end else do
            return --[[ tuple ]]{
                    List.map((function (param) do
                            match = param[1];
                            l = param[0];
                            if (match ~= undefined) then do
                              return --[[ tuple ]]{
                                      l,
                                      Curry._1(match, --[[ () ]]0),
                                      param[2]
                                    };
                            end else do
                              return --[[ tuple ]]{
                                      l,
                                      undefined,
                                      param[2]
                                    };
                            end end 
                          end end), List.rev(args$1)),
                    instance(undefined, env, result_type(omitted$2, ty_fun$2))
                  };
          end end 
        end;
      end
       end 
    end;
  end end;
  match$1 = funct.exp_desc;
  if (not match$1.tag) then do
    match$2 = match$1[2].val_kind;
    if (typeof match$2 ~= "number" and not match$2.tag and match$2[0].prim_name == "%ignore" and sargs) then do
      match$3 = sargs[0];
      if (match$3[0] == "" and not sargs[1]) then do
        match$4 = filter_arrow(env, instance(undefined, env, funct.exp_type), "");
        exp = type_expect(undefined, env, match$3[1], match$4[0]);
        match$5 = expand_head(env, exp.exp_type).desc;
        if (typeof match$5 ~= "number") then do
          local ___conditional___=(match$5.tag | 0);
          do
             if ___conditional___ = 0--[[ Tvar ]] then do
                add_delayed_check((function (param) do
                        return check_application_result(env, false, exp);
                      end end));end else 
             if ___conditional___ = 1--[[ Tarrow ]] then do
                prerr_warning(exp.exp_loc, --[[ Partial_application ]]2);end else 
             do end end end
            else do
              end end
              
          end
        end
         end 
        return --[[ tuple ]]{
                --[[ :: ]]{
                  --[[ tuple ]]{
                    "",
                    exp,
                    --[[ Required ]]0
                  },
                  --[[ [] ]]0
                },
                match$4[1]
              };
      end
       end 
    end
     end 
  end
   end 
  ty = funct.exp_type;
  if (ignore_labels) then do
    return type_args(--[[ [] ]]0, --[[ [] ]]0, ty, instance(undefined, env, ty), ty, --[[ [] ]]0, sargs);
  end else do
    return type_args(--[[ [] ]]0, --[[ [] ]]0, ty, instance(undefined, env, ty), ty, sargs, --[[ [] ]]0);
  end end 
end end

function type_statement(env, sexp) do
  loc = final_subexpression(sexp).pexp_loc;
  begin_def(--[[ () ]]0);
  exp = type_exp(env, sexp);
  end_def(--[[ () ]]0);
  if (strict_sequence.contents) then do
    expected_ty = instance_def(type_unit);
    unify_exp(env, exp, expected_ty);
    return exp;
  end else do
    ty = expand_head(env, exp.exp_type);
    tv = newvar(undefined, --[[ () ]]0);
    match = ty.desc;
    if (typeof match == "number") then do
      prerr_warning(loc, --[[ Statement_type ]]4);
    end else do
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 0--[[ Tvar ]] then do
            if (ty.level > tv.level) then do
              prerr_warning(loc, --[[ Nonreturning_statement ]]10);
            end else do
              add_delayed_check((function (param) do
                      return check_application_result(env, true, exp);
                    end end));
            end end end else 
         if ___conditional___ = 1--[[ Tarrow ]] then do
            prerr_warning(loc, --[[ Partial_application ]]2);end else 
         if ___conditional___ = 3--[[ Tconstr ]] then do
            if (not same(match[0], path_unit)) then do
              prerr_warning(loc, --[[ Statement_type ]]4);
            end
             end end else 
         do end end end end
        else do
          prerr_warning(loc, --[[ Statement_type ]]4);
          end end
          
      end
    end end 
    unify_var(env, tv, ty);
    return exp;
  end end 
end end

function type_cases(in_function, env, ty_arg, ty_res, partial_flag, loc, caselist) do
  patterns = List.map((function (param) do
          return param.pc_lhs;
        end end), caselist);
  erase_either = List.exists(contains_polymorphic_variant, patterns) and contains_variant_either(ty_arg);
  has_gadts = List.exists((function (param) do
          return contains_gadt(env, param);
        end end), patterns);
  ty_arg$1 = (has_gadts or erase_either) and not principal.contents and type_expr(identity, ty_arg) or ty_arg;
  match = has_gadts and not principal.contents and --[[ tuple ]]{
      type_expr(identity, ty_res),
      duplicate_ident_types(loc, caselist, env)
    } or --[[ tuple ]]{
      ty_res,
      env
    };
  env$1 = match[1];
  ty_res$1 = match[0];
  match$1;
  if (has_gadts) then do
    begin_def(--[[ () ]]0);
    set_current_time(current_level.contents);
    lev = currentstamp.contents;
    init_def(lev + 1000 | 0);
    match$1 = --[[ tuple ]]{
      lev,
      add_gadt_instance_level(lev, env$1)
    };
  end else do
    match$1 = --[[ tuple ]]{
      current_level.contents,
      env$1
    };
  end end 
  env$2 = match$1[1];
  lev$1 = match$1[0];
  begin_def(--[[ () ]]0);
  ty_arg$prime = newvar(undefined, --[[ () ]]0);
  pattern_force = do
    contents: --[[ [] ]]0
  end;
  pat_env_list = List.map((function (param) do
          pc_rhs = param.pc_rhs;
          pc_guard = param.pc_guard;
          loc;
          if (pc_guard ~= undefined) then do
            init = pc_rhs.pexp_loc;
            loc = do
              loc_start: pc_guard.pexp_loc.loc_start,
              loc_end: init.loc_end,
              loc_ghost: init.loc_ghost
            end;
          end else do
            loc = pc_rhs.pexp_loc;
          end end 
          if (principal.contents) then do
            begin_def(--[[ () ]]0);
          end
           end 
          scope = --[[ Idef ]]Block.__(1, {loc});
          partial = principal.contents or erase_either and false or undefined;
          ty_arg$2 = instance(partial, env$2, ty_arg$1);
          match = type_pattern(lev$1, env$2, param.pc_lhs, scope, ty_arg$2);
          pat = match[0];
          pattern_force.contents = Pervasives.$at(match[2], pattern_force.contents);
          pat$1 = principal.contents and (end_def(--[[ () ]]0), iter_pattern((function (param) do
                      return generalize_structure$1(current_level.contents, param.pat_type);
                    end end), pat), do
                pat_desc: pat.pat_desc,
                pat_loc: pat.pat_loc,
                pat_extra: pat.pat_extra,
                pat_type: instance(undefined, env$2, pat.pat_type),
                pat_env: pat.pat_env,
                pat_attributes: pat.pat_attributes
              end) or pat;
          return --[[ tuple ]]{
                  pat$1,
                  --[[ tuple ]]{
                    match[1],
                    match[3]
                  }
                };
        end end), caselist);
  patl = List.map((function (prim) do
          return prim[0];
        end end), pat_env_list);
  List.iter((function (pat) do
          return unify_pat(env$2, pat, ty_arg$prime);
        end end), patl);
  if (List.exists(has_variants, patl)) then do
    pressure_variants$1(env$2, patl);
    List.iter((function (param) do
            return iter_pattern(finalize_variant, param);
          end end), patl);
  end
   end 
  List.iter((function (f) do
          return Curry._1(f, --[[ () ]]0);
        end end), pattern_force.contents);
  List.iter((function (param) do
          return iter_pattern((function (param) do
                        return unify_var(env$2, param.pat_type, newvar(undefined, --[[ () ]]0));
                      end end), param);
        end end), patl);
  List.iter((function (pat) do
          return unify_pat(env$2, pat, instance(undefined, env$2, ty_arg$1));
        end end), patl);
  end_def(--[[ () ]]0);
  List.iter((function (param) do
          return iter_pattern((function (param) do
                        return iter_generalize$1(do
                                    contents: --[[ [] ]]0
                                  end, param.pat_type);
                      end end), param);
        end end), patl);
  in_function$1 = List.length(caselist) == 1 and in_function or undefined;
  cases = List.map2((function (param, param$1) do
          pc_guard = param$1.pc_guard;
          match = param[1];
          unpacks = match[1];
          ext_env = match[0];
          sexp = wrap_unpacks(param$1.pc_rhs, unpacks);
          ty_res$prime;
          if (principal.contents) then do
            begin_def(--[[ () ]]0);
            ty = instance(true, env$2, ty_res$1);
            end_def(--[[ () ]]0);
            generalize_structure$1(current_level.contents, ty);
            ty_res$prime = ty;
          end else do
            ty_res$prime = contains_gadt(env$2, param$1.pc_lhs) and type_expr(identity, ty_res$1) or ty_res$1;
          end end 
          guard = pc_guard ~= undefined and type_expect(undefined, ext_env, wrap_unpacks(pc_guard, unpacks), type_bool) or undefined;
          exp = type_expect(in_function$1, ext_env, sexp, ty_res$prime);
          return do
                  c_lhs: param[0],
                  c_guard: guard,
                  c_rhs: do
                    exp_desc: exp.exp_desc,
                    exp_loc: exp.exp_loc,
                    exp_extra: exp.exp_extra,
                    exp_type: instance(undefined, env$2, ty_res$prime),
                    exp_env: exp.exp_env,
                    exp_attributes: exp.exp_attributes
                  end
                end;
        end end), pat_env_list, caselist);
  if (principal.contents or has_gadts) then do
    ty_res$prime = instance(undefined, env$2, ty_res$1);
    List.iter((function (c) do
            return unify_exp(env$2, c.c_rhs, ty_res$prime);
          end end), cases);
  end
   end 
  partial = partial_flag and check_partial$1(lev$1, env$2, ty_arg$1)(loc, cases) or --[[ Partial ]]0;
  add_delayed_check((function (param) do
          List.iter((function (param) do
                  return check_absent_variant(param[1][0])(param[0]);
                end end), pat_env_list);
          casel = cases;
          if (is_active(--[[ Unused_match ]]5)) then do
            _pref = --[[ [] ]]0;
            _param = casel;
            while(true) do
              param$1 = _param;
              pref = _pref;
              if (param$1) then do
                rem = param$1[1];
                match = param$1[0];
                q = match.c_lhs;
                qs = --[[ :: ]]{
                  q,
                  --[[ [] ]]0
                };
                try do
                  pss = get_mins(le_pats, List.filter((function(qs)do
                            return function (param) do
                              return compats(qs, param);
                            end end
                            end(qs)))(pref));
                  r = every_satisfiables(List.map(make_row, pss), do
                        no_ors: --[[ [] ]]0,
                        ors: --[[ [] ]]0,
                        active: qs
                      end);
                  if (typeof r == "number") then do
                    if (r ~= 0) then do
                      prerr_warning(q.pat_loc, --[[ Unused_match ]]5);
                    end
                     end 
                  end else do
                    List.iter((function (p) do
                            return prerr_warning(p.pat_loc, --[[ Unused_pat ]]6);
                          end end), r[0]);
                  end end 
                end
                catch (exn)do
                  exit = 0;
                  if (exn == Empty or exn == Caml_builtin_exceptions.not_found or exn == NoGuard) then do
                    exit = 1;
                  end else do
                    throw exn;
                  end end 
                  if (exit == 1) then do
                    throw {
                          Caml_builtin_exceptions.assert_failure,
                          --[[ tuple ]]{
                            "parmatch.ml",
                            1947,
                            48
                          }
                        };
                  end
                   end 
                end
                if (match.c_guard ~= undefined) then do
                  _param = rem;
                  continue ;
                end else do
                  _param = rem;
                  _pref = --[[ :: ]]{
                    --[[ :: ]]{
                      q,
                      --[[ [] ]]0
                    },
                    pref
                  };
                  continue ;
                end end 
              end else do
                return --[[ () ]]0;
              end end 
            end;
          end else do
            return 0;
          end end 
        end end));
  if (has_gadts) then do
    end_def(--[[ () ]]0);
    unify_exp_types(loc, env$2, instance(undefined, env$2, ty_res$1), newvar(undefined, --[[ () ]]0));
  end
   end 
  return --[[ tuple ]]{
          cases,
          partial
        };
end end

function type_let(checkOpt, check_strictOpt, env, rec_flag, spat_sexp_list, scope, allow) do
  check = checkOpt ~= undefined and checkOpt or (function (s) do
        return --[[ Unused_var ]]Block.__(12, {s});
      end end);
  check_strict = check_strictOpt ~= undefined and check_strictOpt or (function (s) do
        return --[[ Unused_var_strict ]]Block.__(13, {s});
      end end);
  begin_def(--[[ () ]]0);
  if (principal.contents) then do
    begin_def(--[[ () ]]0);
  end
   end 
  is_fake_let;
  if (spat_sexp_list) then do
    match = spat_sexp_list[0].pvb_expr.pexp_desc;
    if (match.tag == --[[ Pexp_match ]]6) then do
      match$1 = match[0].pexp_desc;
      if (match$1.tag) then do
        is_fake_let = false;
      end else do
        match$2 = match$1[0].txt;
        local ___conditional___=(match$2.tag | 0);
        do
           if ___conditional___ = 0--[[ Lident ]] then do
              is_fake_let = match$2[0] == "*opt*" and not spat_sexp_list[1] and true or false;end else 
           if ___conditional___ = 1--[[ Ldot ]]
           or ___conditional___ = 2--[[ Lapply ]] then do
              is_fake_let = false;end else 
           do end end end
          
        end
      end end 
    end else do
      is_fake_let = false;
    end end 
  end else do
    is_fake_let = false;
  end end 
  check$1 = is_fake_let and check_strict or check;
  spatl = List.map((function (param) do
          spat = param.pvb_pat;
          match = spat.ppat_desc;
          match$1 = param.pvb_expr.pexp_desc;
          sty;
          if (typeof match == "number" or match.tag == --[[ Ppat_constraint ]]10) then do
            return spat;
          end else do
            local ___conditional___=(match$1.tag | 0);
            do
               if ___conditional___ = 19--[[ Pexp_constraint ]] then do
                  sty = match$1[1];end else 
               if ___conditional___ = 20--[[ Pexp_coerce ]] then do
                  sty = match$1[2];end else 
               do end end end
              else do
                return spat;
                end end
                
            end
          end end 
          if (principal.contents) then do
            init = spat.ppat_loc;
            return constraint_(do
                        loc_start: init.loc_start,
                        loc_end: init.loc_end,
                        loc_ghost: true
                      end, undefined, spat, sty);
          end else do
            return spat;
          end end 
        end end), spat_sexp_list);
  nvs = List.map((function (param) do
          return newvar(undefined, --[[ () ]]0);
        end end), spatl);
  match$3 = type_pattern_list(env, spatl, scope, nvs, allow);
  unpacks = match$3[3];
  new_env = match$3[1];
  pat_list = match$3[0];
  is_recursive = rec_flag == --[[ Recursive ]]1;
  if (is_recursive) then do
    List.iter2((function (pat, binding) do
            match = pat.pat_type.desc;
            pat$1;
            pat$1 = typeof match == "number" or match.tag ~= --[[ Tpoly ]]10 and pat or (do
                  pat_desc: pat.pat_desc,
                  pat_loc: pat.pat_loc,
                  pat_extra: pat.pat_extra,
                  pat_type: instance_poly(true, false, match[1], match[0])[1],
                  pat_env: pat.pat_env,
                  pat_attributes: pat.pat_attributes
                end);
            return unify_pat(env, pat$1, type_approx(env, binding.pvb_expr));
          end end), pat_list, spat_sexp_list);
  end
   end 
  List.iter((function (pat) do
          if (has_variants(pat)) then do
            pressure_variants$1(env, --[[ :: ]]{
                  pat,
                  --[[ [] ]]0
                });
            return iter_pattern(finalize_variant, pat);
          end else do
            return 0;
          end end 
        end end), pat_list);
  pat_list$1 = principal.contents and (end_def(--[[ () ]]0), List.map((function (pat) do
              iter_pattern((function (pat) do
                      return generalize_structure$1(current_level.contents, pat.pat_type);
                    end end), pat);
              return do
                      pat_desc: pat.pat_desc,
                      pat_loc: pat.pat_loc,
                      pat_extra: pat.pat_extra,
                      pat_type: instance(undefined, env, pat.pat_type),
                      pat_env: pat.pat_env,
                      pat_attributes: pat.pat_attributes
                    end;
            end end), pat_list)) or pat_list;
  List.iter((function (f) do
          return Curry._1(f, --[[ () ]]0);
        end end), match$3[2]);
  exp_env = is_recursive and new_env or env;
  current_slot = do
    contents: undefined
  end;
  rec_needed = do
    contents: false
  end;
  warn_unused = is_active(Curry._1(check$1, "")) or is_active(Curry._1(check_strict, "")) or is_recursive and is_active(--[[ Unused_rec_flag ]]15);
  pat_slot_list = List.map((function (pat) do
          if (warn_unused) then do
            some_used = do
              contents: false
            end;
            slot = do
              contents: --[[ [] ]]0
            end;
            List.iter((function (param) do
                    id = param[0];
                    vd = find_value(--[[ Pident ]]Block.__(0, {id}), new_env);
                    name = id.name;
                    used = do
                      contents: false
                    end;
                    if (not (name == "" or Caml_string.get(name, 0) == --[[ "_" ]]95 or Caml_string.get(name, 0) == --[[ "#" ]]35)) then do
                      add_delayed_check((function (param) do
                              if (used.contents) then do
                                return 0;
                              end else do
                                return prerr_warning(vd.val_loc, Curry._1(some_used.contents and check_strict or check$1, name));
                              end end 
                            end end));
                    end
                     end 
                    name$1 = name;
                    vd$1 = vd;
                    callback = function (param) do
                      match = current_slot.contents;
                      if (match ~= undefined) then do
                        slot$1 = match;
                        slot$1.contents = --[[ :: ]]{
                          --[[ tuple ]]{
                            name,
                            vd
                          },
                          slot$1.contents
                        };
                        rec_needed.contents = true;
                        return --[[ () ]]0;
                      end else do
                        List.iter((function (param) do
                                return mark_value_used(env, param[0], param[1]);
                              end end), get_ref(slot));
                        used.contents = true;
                        some_used.contents = true;
                        return --[[ () ]]0;
                      end end 
                    end end;
                    key_001 = vd$1.val_loc;
                    key = --[[ tuple ]]{
                      name$1,
                      key_001
                    };
                    try do
                      old = Hashtbl.find(value_declarations, key);
                      return Hashtbl.replace(value_declarations, key, (function (param) do
                                    Curry._1(old, --[[ () ]]0);
                                    return Curry._1(callback, --[[ () ]]0);
                                  end end));
                    end
                    catch (exn)do
                      if (exn == Caml_builtin_exceptions.not_found) then do
                        return Hashtbl.add(value_declarations, key, callback);
                      end else do
                        throw exn;
                      end end 
                    end
                  end end), pat_bound_idents(pat));
            return --[[ tuple ]]{
                    pat,
                    slot
                  };
          end else do
            return --[[ tuple ]]{
                    pat,
                    undefined
                  };
          end end 
        end end), pat_list$1);
  exp_list = List.map2((function (param, param$1) do
          pat = param$1[0];
          sexp = param.pvb_expr;
          sexp$1 = rec_flag == --[[ Recursive ]]1 and wrap_unpacks(sexp, unpacks) or sexp;
          if (is_recursive) then do
            current_slot.contents = param$1[1];
          end
           end 
          match = pat.pat_type.desc;
          if (typeof match == "number" or match.tag ~= --[[ Tpoly ]]10) then do
            return type_expect(undefined, exp_env, sexp$1, pat.pat_type);
          end else do
            begin_def(--[[ () ]]0);
            if (principal.contents) then do
              begin_def(--[[ () ]]0);
            end
             end 
            match$1 = instance_poly(true, true, match[1], match[0]);
            ty$prime = match$1[1];
            if (principal.contents) then do
              end_def(--[[ () ]]0);
              generalize_structure$1(current_level.contents, ty$prime);
            end
             end 
            exp = type_expect(undefined, exp_env, sexp$1, ty$prime);
            end_def(--[[ () ]]0);
            check_univars(env, true, "definition", exp, pat.pat_type, match$1[0]);
            return do
                    exp_desc: exp.exp_desc,
                    exp_loc: exp.exp_loc,
                    exp_extra: exp.exp_extra,
                    exp_type: instance(undefined, env, exp.exp_type),
                    exp_env: exp.exp_env,
                    exp_attributes: exp.exp_attributes
                  end;
          end end 
        end end), spat_sexp_list, pat_slot_list);
  current_slot.contents = undefined;
  if (is_recursive and not rec_needed.contents and is_active(--[[ Unused_rec_flag ]]15)) then do
    prerr_warning(List.hd(spat_sexp_list).pvb_pat.ppat_loc, --[[ Unused_rec_flag ]]15);
  end
   end 
  List.iter2((function (pat, exp) do
          check_partial$1(undefined, env, pat.pat_type)(pat.pat_loc, --[[ :: ]]{
                do
                  c_lhs: pat,
                  c_guard: undefined,
                  c_rhs: exp
                end,
                --[[ [] ]]0
              });
          return --[[ () ]]0;
        end end), pat_list$1, exp_list);
  end_def(--[[ () ]]0);
  List.iter2((function (pat, exp) do
          if (is_nonexpansive(exp)) then do
            return 0;
          end else do
            return iter_pattern((function (pat) do
                          return generalize_expansive$1(env, pat.pat_type);
                        end end), pat);
          end end 
        end end), pat_list$1, exp_list);
  List.iter((function (pat) do
          return iter_pattern((function (pat) do
                        return iter_generalize$1(do
                                    contents: --[[ [] ]]0
                                  end, pat.pat_type);
                      end end), pat);
        end end), pat_list$1);
  l = List.combine(pat_list$1, exp_list);
  l$1 = List.map2((function (param, pvb) do
          return do
                  vb_pat: param[0],
                  vb_expr: param[1],
                  vb_attributes: pvb.pvb_attributes,
                  vb_loc: pvb.pvb_loc
                end;
        end end), l, spat_sexp_list);
  return --[[ tuple ]]{
          l$1,
          new_env,
          unpacks
        };
end end

function type_binding(env, rec_flag, spat_sexp_list, scope) do
  reset_type_variables(--[[ () ]]0);
  match = type_let((function (s) do
          return --[[ Unused_value_declaration ]]Block.__(16, {s});
        end end), (function (s) do
          return --[[ Unused_value_declaration ]]Block.__(16, {s});
        end end), env, rec_flag, spat_sexp_list, scope, false);
  return --[[ tuple ]]{
          match[0],
          match[1]
        };
end end

function type_let$1(env, rec_flag, spat_sexp_list, scope) do
  match = type_let(undefined, undefined, env, rec_flag, spat_sexp_list, scope, false);
  return --[[ tuple ]]{
          match[0],
          match[1]
        };
end end

function type_expression(env, sexp) do
  reset_type_variables(--[[ () ]]0);
  begin_def(--[[ () ]]0);
  exp = type_exp(env, sexp);
  end_def(--[[ () ]]0);
  if (is_nonexpansive(exp)) then do
    iter_generalize$1(do
          contents: --[[ [] ]]0
        end, exp.exp_type);
  end else do
    generalize_expansive$1(env, exp.exp_type);
  end end 
  match = sexp.pexp_desc;
  if (match.tag) then do
    return exp;
  end else do
    match$1 = lookup_value$1(match[0].txt, env);
    return do
            exp_desc: exp.exp_desc,
            exp_loc: exp.exp_loc,
            exp_extra: exp.exp_extra,
            exp_type: match$1[1].val_type,
            exp_env: exp.exp_env,
            exp_attributes: exp.exp_attributes
          end;
  end end 
end end

register_error_of_exn((function (param) do
        if (param[0] == __Error$7) then do
          env = param[2];
          return error_of_printer(param[1], (function (param, param$1) do
                        env$1 = env;
                        ppf = param;
                        err = param$1;
                        return wrap_printing_env(env$1, (function (param) do
                                      env$2 = env$1;
                                      ppf$1 = ppf;
                                      param$1 = err;
                                      if (typeof param$1 == "number") then do
                                        local ___conditional___=(param$1);
                                        do
                                           if ___conditional___ = 0--[[ Outside_class ]] then do
                                              return Format.fprintf(ppf$1, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "This object duplication occurs outside a method definition",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "This object duplication occurs outside a method definition"
                                                        });end end end 
                                           if ___conditional___ = 1--[[ Incoherent_label_order ]] then do
                                              Format.fprintf(ppf$1, --[[ Format ]]{
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "This function is applied to arguments",
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Break ]]Block.__(0, {
                                                                "@ ",
                                                                1,
                                                                0
                                                              }),
                                                            --[[ End_of_format ]]0
                                                          })
                                                      }),
                                                    "This function is applied to arguments@ "
                                                  });
                                              Format.fprintf(ppf$1, --[[ Format ]]{
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "in an order different from other calls.",
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Break ]]Block.__(0, {
                                                                "@ ",
                                                                1,
                                                                0
                                                              }),
                                                            --[[ End_of_format ]]0
                                                          })
                                                      }),
                                                    "in an order different from other calls.@ "
                                                  });
                                              return Format.fprintf(ppf$1, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "This is only allowed when the real type is known.",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "This is only allowed when the real type is known."
                                                        });end end end 
                                           if ___conditional___ = 2--[[ Modules_not_allowed ]] then do
                                              return Format.fprintf(ppf$1, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "Modules are not allowed in this pattern.",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "Modules are not allowed in this pattern."
                                                        });end end end 
                                           if ___conditional___ = 3--[[ Cannot_infer_signature ]] then do
                                              return Format.fprintf(ppf$1, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "The signature for this packaged module couldn't be inferred.",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "The signature for this packaged module couldn't be inferred."
                                                        });end end end 
                                           if ___conditional___ = 4--[[ Unexpected_existential ]] then do
                                              return Format.fprintf(ppf$1, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "Unexpected existential",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "Unexpected existential"
                                                        });end end end 
                                           if ___conditional___ = 5--[[ Invalid_interval ]] then do
                                              return Format.fprintf(ppf$1, --[[ Format ]]{
                                                          --[[ Formatting_gen ]]Block.__(18, {
                                                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                    --[[ End_of_format ]]0,
                                                                    ""
                                                                  }}),
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "Only character intervals are supported in patterns.",
                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Close_box ]]0,
                                                                      --[[ End_of_format ]]0
                                                                    })
                                                                })
                                                            }),
                                                          "@[Only character intervals are supported in patterns.@]"
                                                        });end end end 
                                           if ___conditional___ = 6--[[ Invalid_for_loop_index ]] then do
                                              return Format.fprintf(ppf$1, --[[ Format ]]{
                                                          --[[ Formatting_gen ]]Block.__(18, {
                                                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                    --[[ End_of_format ]]0,
                                                                    ""
                                                                  }}),
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "Invalid for-loop index: only variables and _ are allowed.",
                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Close_box ]]0,
                                                                      --[[ End_of_format ]]0
                                                                    })
                                                                })
                                                            }),
                                                          "@[Invalid for-loop index: only variables and _ are allowed.@]"
                                                        });end end end 
                                           if ___conditional___ = 7--[[ No_value_clauses ]] then do
                                              return Format.fprintf(ppf$1, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "None of the patterns in this 'match' expression match values.",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "None of the patterns in this 'match' expression match values."
                                                        });end end end 
                                           if ___conditional___ = 8--[[ Exception_pattern_below_toplevel ]] then do
                                              return Format.fprintf(ppf$1, --[[ Format ]]{
                                                          --[[ Formatting_gen ]]Block.__(18, {
                                                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                    --[[ End_of_format ]]0,
                                                                    ""
                                                                  }}),
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "Exception patterns must be at the top level of a match case.",
                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Close_box ]]0,
                                                                      --[[ End_of_format ]]0
                                                                    })
                                                                })
                                                            }),
                                                          "@[Exception patterns must be at the top level of a match case.@]"
                                                        });end end end 
                                           do
                                          
                                        end
                                      end else do
                                        local ___conditional___=(param$1.tag | 0);
                                        do
                                           if ___conditional___ = 0--[[ Polymorphic_label ]] then do
                                              return Curry._3(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The record field ",
                                                                      --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                                                              " is polymorphic.",
                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Break ]]Block.__(0, {
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    }),
                                                                                  --[[ String ]]Block.__(2, {
                                                                                      --[[ No_padding ]]0,
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Close_box ]]0,
                                                                                          --[[ End_of_format ]]0
                                                                                        })
                                                                                    })
                                                                                })
                                                                            })})
                                                                    })
                                                                }),
                                                              "@[The record field %a is polymorphic.@ %s@]"
                                                            }), longident, param$1[0], "You cannot instantiate it in a pattern.");end end end 
                                           if ___conditional___ = 1--[[ Constructor_arity_mismatch ]] then do
                                              return Curry._4(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The constructor ",
                                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Break ]]Block.__(0, {
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                }),
                                                                              --[[ String_literal ]]Block.__(11, {
                                                                                  "expects ",
                                                                                  --[[ Int ]]Block.__(4, {
                                                                                      --[[ Int_i ]]3,
                                                                                      --[[ No_padding ]]0,
                                                                                      --[[ No_precision ]]0,
                                                                                      --[[ String_literal ]]Block.__(11, {
                                                                                          " argument(s),",
                                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                                              --[[ Break ]]Block.__(0, {
                                                                                                  "@ ",
                                                                                                  1,
                                                                                                  0
                                                                                                }),
                                                                                              --[[ String_literal ]]Block.__(11, {
                                                                                                  "but is applied here to ",
                                                                                                  --[[ Int ]]Block.__(4, {
                                                                                                      --[[ Int_i ]]3,
                                                                                                      --[[ No_padding ]]0,
                                                                                                      --[[ No_precision ]]0,
                                                                                                      --[[ String_literal ]]Block.__(11, {
                                                                                                          " argument(s)",
                                                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                                                              --[[ Close_box ]]0,
                                                                                                              --[[ End_of_format ]]0
                                                                                                            })
                                                                                                        })
                                                                                                    })
                                                                                                })
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })
                                                                            })})
                                                                    })
                                                                }),
                                                              "@[The constructor %a@ expects %i argument(s),@ but is applied here to %i argument(s)@]"
                                                            }), longident, param$1[0], param$1[1], param$1[2]);end end end 
                                           if ___conditional___ = 2--[[ Label_mismatch ]] then do
                                              lid = param$1[0];
                                              return report_unification_error(ppf$1, env$2, undefined, param$1[1], (function (ppf) do
                                                            return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                                            --[[ String_literal ]]Block.__(11, {
                                                                                "The record field ",
                                                                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                        --[[ Break ]]Block.__(0, {
                                                                                            "@ ",
                                                                                            1,
                                                                                            0
                                                                                          }),
                                                                                        --[[ String_literal ]]Block.__(11, {
                                                                                            "belongs to the type",
                                                                                            --[[ End_of_format ]]0
                                                                                          })
                                                                                      })})
                                                                              }),
                                                                            "The record field %a@ belongs to the type"
                                                                          }), longident, lid);
                                                          end end), (function (ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "but is mixed here with fields of type",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "but is mixed here with fields of type"
                                                                      });
                                                          end end));end end end 
                                           if ___conditional___ = 3--[[ Pattern_type_clash ]] then do
                                              return report_unification_error(ppf$1, env$2, undefined, param$1[0], (function (ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "This pattern matches values of type",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "This pattern matches values of type"
                                                                      });
                                                          end end), (function (ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "but a pattern was expected which matches values of type",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "but a pattern was expected which matches values of type"
                                                                      });
                                                          end end));end end end 
                                           if ___conditional___ = 4--[[ Or_pattern_type_clash ]] then do
                                              id = param$1[0];
                                              return report_unification_error(ppf$1, env$2, undefined, param$1[1], (function (ppf) do
                                                            return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                                            --[[ String_literal ]]Block.__(11, {
                                                                                "The variable ",
                                                                                --[[ String ]]Block.__(2, {
                                                                                    --[[ No_padding ]]0,
                                                                                    --[[ String_literal ]]Block.__(11, {
                                                                                        " on the left-hand side of this or-pattern has type",
                                                                                        --[[ End_of_format ]]0
                                                                                      })
                                                                                  })
                                                                              }),
                                                                            "The variable %s on the left-hand side of this or-pattern has type"
                                                                          }), id.name);
                                                          end end), (function (ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "but on the right-hand side it has type",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "but on the right-hand side it has type"
                                                                      });
                                                          end end));end end end 
                                           if ___conditional___ = 5--[[ Multiply_bound_variable ]] then do
                                              return Curry._1(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "Variable ",
                                                                  --[[ String ]]Block.__(2, {
                                                                      --[[ No_padding ]]0,
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          " is bound several times in this matching",
                                                                          --[[ End_of_format ]]0
                                                                        })
                                                                    })
                                                                }),
                                                              "Variable %s is bound several times in this matching"
                                                            }), param$1[0]);end end end 
                                           if ___conditional___ = 6--[[ Orpat_vars ]] then do
                                              return Curry._1(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "Variable ",
                                                                  --[[ String ]]Block.__(2, {
                                                                      --[[ No_padding ]]0,
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          " must occur on both sides of this | pattern",
                                                                          --[[ End_of_format ]]0
                                                                        })
                                                                    })
                                                                }),
                                                              "Variable %s must occur on both sides of this | pattern"
                                                            }), param$1[0].name);end end end 
                                           if ___conditional___ = 7--[[ Expr_type_clash ]] then do
                                              return report_unification_error(ppf$1, env$2, undefined, param$1[0], (function (ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "This expression has type",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "This expression has type"
                                                                      });
                                                          end end), (function (ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "but an expression was expected of type",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "but an expression was expected of type"
                                                                      });
                                                          end end));end end end 
                                           if ___conditional___ = 8--[[ Apply_non_function ]] then do
                                              typ = param$1[0];
                                              reset(--[[ () ]]0);
                                              mark_loops(typ);
                                              match = repr(typ).desc;
                                              if (typeof match ~= "number" and match.tag == --[[ Tarrow ]]1) then do
                                                Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                          --[[ Formatting_gen ]]Block.__(18, {
                                                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                    --[[ String_literal ]]Block.__(11, {
                                                                        "<v>",
                                                                        --[[ End_of_format ]]0
                                                                      }),
                                                                    "<v>"
                                                                  }}),
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "<2>",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "<2>"
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "This function has type",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Close_box ]]0,
                                                                                  --[[ End_of_format ]]0
                                                                                })})
                                                                        })
                                                                    })
                                                                })
                                                            }),
                                                          "@[<v>@[<2>This function has type@ %a@]"
                                                        }), type_expr$1, typ);
                                                return Curry._1(Format.fprintf(ppf$1, --[[ Format ]]{
                                                                --[[ Formatting_lit ]]Block.__(17, {
                                                                    --[[ Break ]]Block.__(0, {
                                                                        "@ ",
                                                                        1,
                                                                        0
                                                                      }),
                                                                    --[[ Formatting_gen ]]Block.__(18, {
                                                                        --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                              --[[ End_of_format ]]0,
                                                                              ""
                                                                            }}),
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "It is applied to too many arguments;",
                                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                                --[[ Break ]]Block.__(0, {
                                                                                    "@ ",
                                                                                    1,
                                                                                    0
                                                                                  }),
                                                                                --[[ String ]]Block.__(2, {
                                                                                    --[[ No_padding ]]0,
                                                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                                                        --[[ Close_box ]]0,
                                                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                                                            --[[ Close_box ]]0,
                                                                                            --[[ End_of_format ]]0
                                                                                          })
                                                                                      })
                                                                                  })
                                                                              })
                                                                          })
                                                                      })
                                                                  }),
                                                                "@ @[It is applied to too many arguments;@ %s@]@]"
                                                              }), "maybe you forgot a `;'.");
                                              end
                                               end 
                                              return Curry._3(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "<v>",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "<v>"
                                                                      }}),
                                                                  --[[ Formatting_gen ]]Block.__(18, {
                                                                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                            --[[ String_literal ]]Block.__(11, {
                                                                                "<2>",
                                                                                --[[ End_of_format ]]0
                                                                              }),
                                                                            "<2>"
                                                                          }}),
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          "This expression has type",
                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Break ]]Block.__(0, {
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                }),
                                                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Close_box ]]0,
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Break ]]Block.__(0, {
                                                                                              "@ ",
                                                                                              1,
                                                                                              0
                                                                                            }),
                                                                                          --[[ String ]]Block.__(2, {
                                                                                              --[[ No_padding ]]0,
                                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                                  --[[ Close_box ]]0,
                                                                                                  --[[ End_of_format ]]0
                                                                                                })
                                                                                            })
                                                                                        })
                                                                                    })})
                                                                            })
                                                                        })
                                                                    })
                                                                }),
                                                              "@[<v>@[<2>This expression has type@ %a@]@ %s@]"
                                                            }), type_expr$1, typ, "This is not a function; it cannot be applied.");end end end 
                                           if ___conditional___ = 9--[[ Apply_wrong_label ]] then do
                                              ty = param$1[1];
                                              print_label = function (ppf, l) do
                                                if (l == "") then do
                                                  return Format.fprintf(ppf, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "without label",
                                                                  --[[ End_of_format ]]0
                                                                }),
                                                              "without label"
                                                            });
                                                end else do
                                                  return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "with label ",
                                                                      --[[ String ]]Block.__(2, {
                                                                          --[[ No_padding ]]0,
                                                                          --[[ End_of_format ]]0
                                                                        })
                                                                    }),
                                                                  "with label %s"
                                                                }), prefixed_label_name(l));
                                                end end 
                                              end end;
                                              reset(--[[ () ]]0);
                                              mark_loops(ty);
                                              return Curry._4(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "<v>",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "<v>"
                                                                      }}),
                                                                  --[[ Formatting_gen ]]Block.__(18, {
                                                                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                            --[[ String_literal ]]Block.__(11, {
                                                                                "<2>",
                                                                                --[[ End_of_format ]]0
                                                                              }),
                                                                            "<2>"
                                                                          }}),
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          "The function applied to this argument has type",
                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Break ]]Block.__(0, {
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                }),
                                                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Close_box ]]0,
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Flush_newline ]]4,
                                                                                          --[[ String_literal ]]Block.__(11, {
                                                                                              "This argument cannot be applied ",
                                                                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                      --[[ Close_box ]]0,
                                                                                                      --[[ End_of_format ]]0
                                                                                                    })})
                                                                                            })
                                                                                        })
                                                                                    })})
                                                                            })
                                                                        })
                                                                    })
                                                                }),
                                                              "@[<v>@[<2>The function applied to this argument has type@ %a@]@.This argument cannot be applied %a@]"
                                                            }), type_expr$1, ty, print_label, param$1[0]);end end end 
                                           if ___conditional___ = 10--[[ Label_multiply_defined ]] then do
                                              return Curry._1(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "The record field label ",
                                                                  --[[ String ]]Block.__(2, {
                                                                      --[[ No_padding ]]0,
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          " is defined several times",
                                                                          --[[ End_of_format ]]0
                                                                        })
                                                                    })
                                                                }),
                                                              "The record field label %s is defined several times"
                                                            }), param$1[0]);end end end 
                                           if ___conditional___ = 11--[[ Label_missing ]] then do
                                              print_labels = function (ppf) do
                                                return (function (param) do
                                                    return List.iter((function (lbl) do
                                                                  return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Break ]]Block.__(0, {
                                                                                          "@ ",
                                                                                          1,
                                                                                          0
                                                                                        }),
                                                                                      --[[ String ]]Block.__(2, {
                                                                                          --[[ No_padding ]]0,
                                                                                          --[[ End_of_format ]]0
                                                                                        })
                                                                                    }),
                                                                                  "@ %s"
                                                                                }), lbl.name);
                                                                end end), param);
                                                  end end);
                                              end end;
                                              return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "<hov>",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "<hov>"
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "Some record fields are undefined:",
                                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Close_box ]]0,
                                                                              --[[ End_of_format ]]0
                                                                            })})
                                                                    })
                                                                }),
                                                              "@[<hov>Some record fields are undefined:%a@]"
                                                            }), print_labels, param$1[0]);end end end 
                                           if ___conditional___ = 12--[[ Label_not_mutable ]] then do
                                              return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "The record field ",
                                                                  --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                                                          " is not mutable",
                                                                          --[[ End_of_format ]]0
                                                                        })})
                                                                }),
                                                              "The record field %a is not mutable"
                                                            }), longident, param$1[0]);end end end 
                                           if ___conditional___ = 13--[[ Wrong_name ]] then do
                                              lid$1 = param$1[4];
                                              p = param$1[3];
                                              kind = param$1[2];
                                              ty$1 = param$1[1];
                                              reset(--[[ () ]]0);
                                              mark_loops(ty$1);
                                              Curry._3(Format.fprintf(ppf$1, --[[ Format ]]{
                                                        --[[ Formatting_gen ]]Block.__(18, {
                                                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                  --[[ End_of_format ]]0,
                                                                  ""
                                                                }}),
                                                            --[[ Formatting_gen ]]Block.__(18, {
                                                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          "<2>",
                                                                          --[[ End_of_format ]]0
                                                                        }),
                                                                      "<2>"
                                                                    }}),
                                                                --[[ String ]]Block.__(2, {
                                                                    --[[ No_padding ]]0,
                                                                    --[[ String_literal ]]Block.__(11, {
                                                                        " type",
                                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                                            --[[ Break ]]Block.__(0, {
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              }),
                                                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                    --[[ Close_box ]]0,
                                                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                                                        --[[ Break ]]Block.__(0, {
                                                                                            "@ ",
                                                                                            1,
                                                                                            0
                                                                                          }),
                                                                                        --[[ End_of_format ]]0
                                                                                      })
                                                                                  })})
                                                                          })
                                                                      })
                                                                  })
                                                              })
                                                          }),
                                                        "@[@[<2>%s type@ %a@]@ "
                                                      }), param$1[0], type_expr$1, ty$1);
                                              Curry._5(Format.fprintf(ppf$1, --[[ Format ]]{
                                                        --[[ String_literal ]]Block.__(11, {
                                                            "The ",
                                                            --[[ String ]]Block.__(2, {
                                                                --[[ No_padding ]]0,
                                                                --[[ Char_literal ]]Block.__(12, {
                                                                    --[[ " " ]]32,
                                                                    --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                                                            " does not belong to type ",
                                                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                    --[[ Close_box ]]0,
                                                                                    --[[ End_of_format ]]0
                                                                                  })})
                                                                          })})
                                                                  })
                                                              })
                                                          }),
                                                        "The %s %a does not belong to type %a@]"
                                                      }), kind == "record" and "field" or "constructor", longident, lid$1, path, p);
                                              if (kind == "record") then do
                                                ppf$2 = ppf$1;
                                                env$3 = env$2;
                                                p$1 = p;
                                                lid$2 = lid$1;
                                                return spellcheck_simple(ppf$2, fold_labels, (function (d) do
                                                                if (compare_type_path(env$3, p$1, get_type_path$1(env$3, d))) then do
                                                                  return d.lbl_name;
                                                                end else do
                                                                  return "";
                                                                end end 
                                                              end end))(env$3, lid$2);
                                              end else do
                                                ppf$3 = ppf$1;
                                                env$4 = env$2;
                                                p$2 = p;
                                                lid$3 = lid$1;
                                                return spellcheck_simple(ppf$3, fold_constructors, (function (d) do
                                                                if (compare_type_path(env$4, p$2, get_type_path$2(env$4, d))) then do
                                                                  return d.cstr_name;
                                                                end else do
                                                                  return "";
                                                                end end 
                                                              end end))(env$4, lid$3);
                                              end end end end end 
                                           if ___conditional___ = 14--[[ Name_type_mismatch ]] then do
                                              lid$4 = param$1[1];
                                              kind$1 = param$1[0];
                                              name = kind$1 == "record" and "field" or "constructor";
                                              ppf$4 = ppf$1;
                                              env$5 = env$2;
                                              param$2 = param$1[2];
                                              tpl = param$1[3];
                                              txt1 = function (ppf) do
                                                return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "The ",
                                                                    --[[ String ]]Block.__(2, {
                                                                        --[[ No_padding ]]0,
                                                                        --[[ Char_literal ]]Block.__(12, {
                                                                            --[[ " " ]]32,
                                                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                    --[[ Break ]]Block.__(0, {
                                                                                        "@ ",
                                                                                        1,
                                                                                        0
                                                                                      }),
                                                                                    --[[ String_literal ]]Block.__(11, {
                                                                                        "belongs to the ",
                                                                                        --[[ String ]]Block.__(2, {
                                                                                            --[[ No_padding ]]0,
                                                                                            --[[ String_literal ]]Block.__(11, {
                                                                                                " type",
                                                                                                --[[ End_of_format ]]0
                                                                                              })
                                                                                          })
                                                                                      })
                                                                                  })})
                                                                          })
                                                                      })
                                                                  }),
                                                                "The %s %a@ belongs to the %s type"
                                                              }), name, longident, lid$4, kind$1);
                                              end end;
                                              txt2 = function (ppf) do
                                                return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "The ",
                                                                    --[[ String ]]Block.__(2, {
                                                                        --[[ No_padding ]]0,
                                                                        --[[ Char_literal ]]Block.__(12, {
                                                                            --[[ " " ]]32,
                                                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                    --[[ Break ]]Block.__(0, {
                                                                                        "@ ",
                                                                                        1,
                                                                                        0
                                                                                      }),
                                                                                    --[[ String_literal ]]Block.__(11, {
                                                                                        "belongs to one of the following ",
                                                                                        --[[ String ]]Block.__(2, {
                                                                                            --[[ No_padding ]]0,
                                                                                            --[[ String_literal ]]Block.__(11, {
                                                                                                " types:",
                                                                                                --[[ End_of_format ]]0
                                                                                              })
                                                                                          })
                                                                                      })
                                                                                  })})
                                                                          })
                                                                      })
                                                                  }),
                                                                "The %s %a@ belongs to one of the following %s types:"
                                                              }), name, longident, lid$4, kind$1);
                                              end end;
                                              txt3 = function (ppf) do
                                                return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "but a ",
                                                                    --[[ String ]]Block.__(2, {
                                                                        --[[ No_padding ]]0,
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            " was expected belonging to the ",
                                                                            --[[ String ]]Block.__(2, {
                                                                                --[[ No_padding ]]0,
                                                                                --[[ String_literal ]]Block.__(11, {
                                                                                    " type",
                                                                                    --[[ End_of_format ]]0
                                                                                  })
                                                                              })
                                                                          })
                                                                      })
                                                                  }),
                                                                "but a %s was expected belonging to the %s type"
                                                              }), name, kind$1);
                                              end end;
                                              tp0$prime = param$2[1];
                                              tp0 = param$2[0];
                                              return wrap_printing_env(env$5, (function (param) do
                                                            reset(--[[ () ]]0);
                                                            List.iter((function (param) do
                                                                    path_same_name(tp0, param[0]);
                                                                    return path_same_name(tp0$prime, param[1]);
                                                                  end end), tpl);
                                                            if (tpl) then do
                                                              if (tpl[1]) then do
                                                                return Curry._6(Format.fprintf(ppf$4, --[[ Format ]]{
                                                                                --[[ Formatting_gen ]]Block.__(18, {
                                                                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                                          --[[ End_of_format ]]0,
                                                                                          ""
                                                                                        }}),
                                                                                    --[[ Theta ]]Block.__(16, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                            --[[ Break ]]Block.__(0, {
                                                                                                "@;<1 2>",
                                                                                                1,
                                                                                                2
                                                                                              }),
                                                                                            --[[ Formatting_gen ]]Block.__(18, {
                                                                                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                                                      --[[ String_literal ]]Block.__(11, {
                                                                                                          "<hv>",
                                                                                                          --[[ End_of_format ]]0
                                                                                                        }),
                                                                                                      "<hv>"
                                                                                                    }}),
                                                                                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                        --[[ Close_box ]]0,
                                                                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                                                                            --[[ Break ]]Block.__(0, {
                                                                                                                "@ ",
                                                                                                                1,
                                                                                                                0
                                                                                                              }),
                                                                                                            --[[ Theta ]]Block.__(16, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                                    --[[ Break ]]Block.__(0, {
                                                                                                                        "@;<1 2>",
                                                                                                                        1,
                                                                                                                        2
                                                                                                                      }),
                                                                                                                    --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                                            --[[ Close_box ]]0,
                                                                                                                            --[[ End_of_format ]]0
                                                                                                                          })})
                                                                                                                  })})
                                                                                                          })
                                                                                                      })})
                                                                                              })
                                                                                          })})
                                                                                  }),
                                                                                "@[%t@;<1 2>@[<hv>%a@]@ %t@;<1 2>%a@]"
                                                                              }), txt2, type_path_list, tpl, txt3, (function (param, param$1) do
                                                                              return type_path_expansion(tp0, param, param$1);
                                                                            end end), tp0$prime);
                                                              end else do
                                                                match = tpl[0];
                                                                tp = match[0];
                                                                return Curry._6(Format.fprintf(ppf$4, --[[ Format ]]{
                                                                                --[[ Formatting_gen ]]Block.__(18, {
                                                                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                                          --[[ End_of_format ]]0,
                                                                                          ""
                                                                                        }}),
                                                                                    --[[ Theta ]]Block.__(16, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                            --[[ Break ]]Block.__(0, {
                                                                                                "@;<1 2>",
                                                                                                1,
                                                                                                2
                                                                                              }),
                                                                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                    --[[ Break ]]Block.__(0, {
                                                                                                        "@ ",
                                                                                                        1,
                                                                                                        0
                                                                                                      }),
                                                                                                    --[[ Theta ]]Block.__(16, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                            --[[ Break ]]Block.__(0, {
                                                                                                                "@;<1 2>",
                                                                                                                1,
                                                                                                                2
                                                                                                              }),
                                                                                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                                    --[[ Close_box ]]0,
                                                                                                                    --[[ End_of_format ]]0
                                                                                                                  })})
                                                                                                          })})
                                                                                                  })})
                                                                                          })})
                                                                                  }),
                                                                                "@[%t@;<1 2>%a@ %t@;<1 2>%a@]"
                                                                              }), txt1, (function (param, param$1) do
                                                                              return type_path_expansion(tp, param, param$1);
                                                                            end end), match[1], txt3, (function (param, param$1) do
                                                                              return type_path_expansion(tp0, param, param$1);
                                                                            end end), tp0$prime);
                                                              end end 
                                                            end else do
                                                              throw {
                                                                    Caml_builtin_exceptions.assert_failure,
                                                                    --[[ tuple ]]{
                                                                      "printtyp.ml",
                                                                      1585,
                                                                      12
                                                                    }
                                                                  };
                                                            end end 
                                                          end end));end end end 
                                           if ___conditional___ = 15--[[ Invalid_format ]] then do
                                              return Curry._1(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ String ]]Block.__(2, {
                                                                  --[[ No_padding ]]0,
                                                                  --[[ End_of_format ]]0
                                                                }),
                                                              "%s"
                                                            }), param$1[0]);end end end 
                                           if ___conditional___ = 16--[[ Undefined_method ]] then do
                                              ty$2 = param$1[0];
                                              reset(--[[ () ]]0);
                                              mark_loops(ty$2);
                                              return Curry._3(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "<v>",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "<v>"
                                                                      }}),
                                                                  --[[ Formatting_gen ]]Block.__(18, {
                                                                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                            --[[ End_of_format ]]0,
                                                                            ""
                                                                          }}),
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          "This expression has type",
                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Break ]]Block.__(0, {
                                                                                  "@;<1 2>",
                                                                                  1,
                                                                                  2
                                                                                }),
                                                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Close_box ]]0,
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Break ]]Block.__(0, {
                                                                                              "@,",
                                                                                              0,
                                                                                              0
                                                                                            }),
                                                                                          --[[ String_literal ]]Block.__(11, {
                                                                                              "It has no method ",
                                                                                              --[[ String ]]Block.__(2, {
                                                                                                  --[[ No_padding ]]0,
                                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                                      --[[ Close_box ]]0,
                                                                                                      --[[ End_of_format ]]0
                                                                                                    })
                                                                                                })
                                                                                            })
                                                                                        })
                                                                                    })})
                                                                            })
                                                                        })
                                                                    })
                                                                }),
                                                              "@[<v>@[This expression has type@;<1 2>%a@]@,It has no method %s@]"
                                                            }), type_expr$1, ty$2, param$1[1]);end end end 
                                           if ___conditional___ = 17--[[ Undefined_inherited_method ]] then do
                                              return Curry._1(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "This expression has no method ",
                                                                  --[[ String ]]Block.__(2, {
                                                                      --[[ No_padding ]]0,
                                                                      --[[ End_of_format ]]0
                                                                    })
                                                                }),
                                                              "This expression has no method %s"
                                                            }), param$1[0]);end end end 
                                           if ___conditional___ = 18--[[ Virtual_class ]] then do
                                              return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "Cannot instantiate the virtual class ",
                                                                  --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                                }),
                                                              "Cannot instantiate the virtual class %a"
                                                            }), longident, param$1[0]);end end end 
                                           if ___conditional___ = 19--[[ Private_type ]] then do
                                              return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "Cannot create values of the private type ",
                                                                  --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                                }),
                                                              "Cannot create values of the private type %a"
                                                            }), type_expr$1, param$1[0]);end end end 
                                           if ___conditional___ = 20--[[ Private_label ]] then do
                                              return Curry._4(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "Cannot assign field ",
                                                                  --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                                                          " of the private type ",
                                                                          --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                                        })})
                                                                }),
                                                              "Cannot assign field %a of the private type %a"
                                                            }), longident, param$1[0], type_expr$1, param$1[1]);end end end 
                                           if ___conditional___ = 21--[[ Unbound_instance_variable ]] then do
                                              return Curry._1(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "Unbound instance variable ",
                                                                  --[[ String ]]Block.__(2, {
                                                                      --[[ No_padding ]]0,
                                                                      --[[ End_of_format ]]0
                                                                    })
                                                                }),
                                                              "Unbound instance variable %s"
                                                            }), param$1[0]);end end end 
                                           if ___conditional___ = 22--[[ Instance_variable_not_mutable ]] then do
                                              v = param$1[1];
                                              if (param$1[0]) then do
                                                return Curry._1(Format.fprintf(ppf$1, --[[ Format ]]{
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "The instance variable ",
                                                                    --[[ String ]]Block.__(2, {
                                                                        --[[ No_padding ]]0,
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            " is not mutable",
                                                                            --[[ End_of_format ]]0
                                                                          })
                                                                      })
                                                                  }),
                                                                "The instance variable %s is not mutable"
                                                              }), v);
                                              end else do
                                                return Curry._1(Format.fprintf(ppf$1, --[[ Format ]]{
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "The value ",
                                                                    --[[ String ]]Block.__(2, {
                                                                        --[[ No_padding ]]0,
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            " is not an instance variable",
                                                                            --[[ End_of_format ]]0
                                                                          })
                                                                      })
                                                                  }),
                                                                "The value %s is not an instance variable"
                                                              }), v);
                                              end end end end end 
                                           if ___conditional___ = 23--[[ Not_subtype ]] then do
                                              ppf$5 = ppf$1;
                                              env$6 = env$2;
                                              tr1 = param$1[0];
                                              txt1$1 = "is not a subtype of";
                                              tr2 = param$1[1];
                                              return wrap_printing_env(env$6, (function (param) do
                                                            reset(--[[ () ]]0);
                                                            tr1$1 = List.map(prepare_expansion, tr1);
                                                            tr2$1 = List.map(prepare_expansion, tr2);
                                                            partial_arg = tr2$1 == --[[ [] ]]0;
                                                            Curry._2(Format.fprintf(ppf$5, --[[ Format ]]{
                                                                      --[[ Formatting_gen ]]Block.__(18, {
                                                                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                                --[[ String_literal ]]Block.__(11, {
                                                                                    "<v>",
                                                                                    --[[ End_of_format ]]0
                                                                                  }),
                                                                                "<v>"
                                                                              }}),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                                        }),
                                                                      "@[<v>%a"
                                                                    }), (function (param, param$1) do
                                                                    return trace$1(true, partial_arg, txt1$1, param, param$1);
                                                                  end end), tr1$1);
                                                            if (tr2$1 == --[[ [] ]]0) then do
                                                              return Format.fprintf(ppf$5, --[[ Format ]]{
                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Close_box ]]0,
                                                                              --[[ End_of_format ]]0
                                                                            }),
                                                                          "@]"
                                                                        });
                                                            end else do
                                                              mis = mismatch(true, tr2$1);
                                                              partial_arg$1 = mis == undefined;
                                                              return Curry._3(Format.fprintf(ppf$5, --[[ Format ]]{
                                                                              --[[ Alpha ]]Block.__(15, {--[[ Theta ]]Block.__(16, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Close_box ]]0,
                                                                                          --[[ End_of_format ]]0
                                                                                        })})}),
                                                                              "%a%t@]"
                                                                            }), (function (param, param$1) do
                                                                            return trace$1(false, partial_arg$1, "is not compatible with type", param, param$1);
                                                                          end end), tr2$1, (function (param) do
                                                                            return explanation(true, mis, param);
                                                                          end end));
                                                            end end 
                                                          end end));end end end 
                                           if ___conditional___ = 24--[[ Value_multiply_overridden ]] then do
                                              return Curry._1(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "The instance variable ",
                                                                  --[[ String ]]Block.__(2, {
                                                                      --[[ No_padding ]]0,
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          " is overridden several times",
                                                                          --[[ End_of_format ]]0
                                                                        })
                                                                    })
                                                                }),
                                                              "The instance variable %s is overridden several times"
                                                            }), param$1[0]);end end end 
                                           if ___conditional___ = 25--[[ Coercion_failure ]] then do
                                              ty$prime = param$1[1];
                                              ty$3 = param$1[0];
                                              report_unification_error(ppf$1, env$2, undefined, param$1[2], (function (ppf) do
                                                      match = prepare_expansion(--[[ tuple ]]{
                                                            ty$3,
                                                            ty$prime
                                                          });
                                                      ty$4 = match[0];
                                                      return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          "This expression cannot be coerced to type",
                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Break ]]Block.__(0, {
                                                                                  "@;<1 2>",
                                                                                  1,
                                                                                  2
                                                                                }),
                                                                              --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                                                      --[[ ";" ]]59,
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Break ]]Block.__(0, {
                                                                                              "@ ",
                                                                                              1,
                                                                                              0
                                                                                            }),
                                                                                          --[[ String_literal ]]Block.__(11, {
                                                                                              "it has type",
                                                                                              --[[ End_of_format ]]0
                                                                                            })
                                                                                        })
                                                                                    })})
                                                                            })
                                                                        }),
                                                                      "This expression cannot be coerced to type@;<1 2>%a;@ it has type"
                                                                    }), (function (param, param$1) do
                                                                    return type_expansion(ty$4, param, param$1);
                                                                  end end), match[1]);
                                                    end end), (function (ppf) do
                                                      return Format.fprintf(ppf, --[[ Format ]]{
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "but is here used with type",
                                                                      --[[ End_of_format ]]0
                                                                    }),
                                                                  "but is here used with type"
                                                                });
                                                    end end));
                                              if (param$1[3]) then do
                                                return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                                --[[ Char_literal ]]Block.__(12, {
                                                                    --[[ "." ]]46,
                                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                                        --[[ Flush_newline ]]4,
                                                                        --[[ Formatting_gen ]]Block.__(18, {
                                                                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                                  --[[ String_literal ]]Block.__(11, {
                                                                                      "<hov>",
                                                                                      --[[ End_of_format ]]0
                                                                                    }),
                                                                                  "<hov>"
                                                                                }}),
                                                                            --[[ String ]]Block.__(2, {
                                                                                --[[ No_padding ]]0,
                                                                                --[[ Formatting_lit ]]Block.__(17, {
                                                                                    --[[ Break ]]Block.__(0, {
                                                                                        "@ ",
                                                                                        1,
                                                                                        0
                                                                                      }),
                                                                                    --[[ String ]]Block.__(2, {
                                                                                        --[[ No_padding ]]0,
                                                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                                                            --[[ Close_box ]]0,
                                                                                            --[[ End_of_format ]]0
                                                                                          })
                                                                                      })
                                                                                  })
                                                                              })
                                                                          })
                                                                      })
                                                                  }),
                                                                ".@.@[<hov>%s@ %s@]"
                                                              }), "This simple coercion was not fully general.", "Consider using a double coercion.");
                                              end else do
                                                return 0;
                                              end end end end end 
                                           if ___conditional___ = 26--[[ Too_many_arguments ]] then do
                                              ty$4 = param$1[1];
                                              reset(--[[ () ]]0);
                                              mark_loops(ty$4);
                                              if (param$1[0]) then do
                                                Format.fprintf(ppf$1, --[[ Format ]]{
                                                      --[[ String_literal ]]Block.__(11, {
                                                          "This function expects too many arguments,",
                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Break ]]Block.__(0, {
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                }),
                                                              --[[ End_of_format ]]0
                                                            })
                                                        }),
                                                      "This function expects too many arguments,@ "
                                                    });
                                                return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "it should have type",
                                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                                        --[[ Break ]]Block.__(0, {
                                                                            "@ ",
                                                                            1,
                                                                            0
                                                                          }),
                                                                        --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                                      })
                                                                  }),
                                                                "it should have type@ %a"
                                                              }), type_expr$1, ty$4);
                                              end else do
                                                Format.fprintf(ppf$1, --[[ Format ]]{
                                                      --[[ String_literal ]]Block.__(11, {
                                                          "This expression should not be a function,",
                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Break ]]Block.__(0, {
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                }),
                                                              --[[ End_of_format ]]0
                                                            })
                                                        }),
                                                      "This expression should not be a function,@ "
                                                    });
                                                return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "the expected type is",
                                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                                        --[[ Break ]]Block.__(0, {
                                                                            "@ ",
                                                                            1,
                                                                            0
                                                                          }),
                                                                        --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                                      })
                                                                  }),
                                                                "the expected type is@ %a"
                                                              }), type_expr$1, ty$4);
                                              end end end end end 
                                           if ___conditional___ = 27--[[ Abstract_wrong_label ]] then do
                                              ty$5 = param$1[1];
                                              label_mark = function (l) do
                                                if (l == "") then do
                                                  return "but its first argument is not labelled";
                                                end else do
                                                  return Curry._1(Format.sprintf(--[[ Format ]]{
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "but its first argument is labelled ",
                                                                      --[[ String ]]Block.__(2, {
                                                                          --[[ No_padding ]]0,
                                                                          --[[ End_of_format ]]0
                                                                        })
                                                                    }),
                                                                  "but its first argument is labelled %s"
                                                                }), prefixed_label_name(l));
                                                end end 
                                              end end;
                                              reset(--[[ () ]]0);
                                              mark_loops(ty$5);
                                              return Curry._3(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "<v>",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "<v>"
                                                                      }}),
                                                                  --[[ Formatting_gen ]]Block.__(18, {
                                                                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                            --[[ String_literal ]]Block.__(11, {
                                                                                "<2>",
                                                                                --[[ End_of_format ]]0
                                                                              }),
                                                                            "<2>"
                                                                          }}),
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          "This function should have type",
                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Break ]]Block.__(0, {
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                }),
                                                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Close_box ]]0,
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Break ]]Block.__(0, {
                                                                                              "@,",
                                                                                              0,
                                                                                              0
                                                                                            }),
                                                                                          --[[ String ]]Block.__(2, {
                                                                                              --[[ No_padding ]]0,
                                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                                  --[[ Close_box ]]0,
                                                                                                  --[[ End_of_format ]]0
                                                                                                })
                                                                                            })
                                                                                        })
                                                                                    })})
                                                                            })
                                                                        })
                                                                    })
                                                                }),
                                                              "@[<v>@[<2>This function should have type@ %a@]@,%s@]"
                                                            }), type_expr$1, ty$5, label_mark(param$1[0]));end end end 
                                           if ___conditional___ = 28--[[ Scoping_let_module ]] then do
                                              ty$6 = param$1[1];
                                              reset(--[[ () ]]0);
                                              mark_loops(ty$6);
                                              Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                        --[[ String_literal ]]Block.__(11, {
                                                            "This `let module' expression has type",
                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                --[[ Break ]]Block.__(0, {
                                                                    "@ ",
                                                                    1,
                                                                    0
                                                                  }),
                                                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                        --[[ Break ]]Block.__(0, {
                                                                            "@ ",
                                                                            1,
                                                                            0
                                                                          }),
                                                                        --[[ End_of_format ]]0
                                                                      })})
                                                              })
                                                          }),
                                                        "This `let module' expression has type@ %a@ "
                                                      }), type_expr$1, ty$6);
                                              return Curry._1(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "In this type, the locally bound module name ",
                                                                  --[[ String ]]Block.__(2, {
                                                                      --[[ No_padding ]]0,
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          " escapes its scope",
                                                                          --[[ End_of_format ]]0
                                                                        })
                                                                    })
                                                                }),
                                                              "In this type, the locally bound module name %s escapes its scope"
                                                            }), param$1[0]);end end end 
                                           if ___conditional___ = 29--[[ Masked_instance_variable ]] then do
                                              return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "The instance variable ",
                                                                  --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ String_literal ]]Block.__(11, {
                                                                              "cannot be accessed from the definition of another instance variable",
                                                                              --[[ End_of_format ]]0
                                                                            })
                                                                        })})
                                                                }),
                                                              "The instance variable %a@ cannot be accessed from the definition of another instance variable"
                                                            }), longident, param$1[0]);end end end 
                                           if ___conditional___ = 30--[[ Not_a_variant_type ]] then do
                                              return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "The type ",
                                                                  --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ String_literal ]]Block.__(11, {
                                                                              "is not a variant type",
                                                                              --[[ End_of_format ]]0
                                                                            })
                                                                        })})
                                                                }),
                                                              "The type %a@ is not a variant type"
                                                            }), longident, param$1[0]);end end end 
                                           if ___conditional___ = 31--[[ Less_general ]] then do
                                              kind$2 = param$1[0];
                                              return report_unification_error(ppf$1, env$2, undefined, param$1[1], (function (ppf) do
                                                            return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                                            --[[ String_literal ]]Block.__(11, {
                                                                                "This ",
                                                                                --[[ String ]]Block.__(2, {
                                                                                    --[[ No_padding ]]0,
                                                                                    --[[ String_literal ]]Block.__(11, {
                                                                                        " has type",
                                                                                        --[[ End_of_format ]]0
                                                                                      })
                                                                                  })
                                                                              }),
                                                                            "This %s has type"
                                                                          }), kind$2);
                                                          end end), (function (ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "which is less general than",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "which is less general than"
                                                                      });
                                                          end end));end end end 
                                           if ___conditional___ = 32--[[ Not_a_packed_module ]] then do
                                              return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "This expression is packed module, but the expected type is",
                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Break ]]Block.__(0, {
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        }),
                                                                      --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                                    })
                                                                }),
                                                              "This expression is packed module, but the expected type is@ %a"
                                                            }), type_expr$1, param$1[0]);end end end 
                                           if ___conditional___ = 33--[[ Recursive_local_constraint ]] then do
                                              return report_unification_error(ppf$1, env$2, undefined, param$1[0], (function (ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "Recursive local constraint when unifying",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "Recursive local constraint when unifying"
                                                                      });
                                                          end end), (function (ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "with",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "with"
                                                                      });
                                                          end end));end end end 
                                           if ___conditional___ = 34--[[ Unqualified_gadt_pattern ]] then do
                                              return Curry._4(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The GADT constructor ",
                                                                      --[[ String ]]Block.__(2, {
                                                                          --[[ No_padding ]]0,
                                                                          --[[ String_literal ]]Block.__(11, {
                                                                              " of type ",
                                                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Break ]]Block.__(0, {
                                                                                          "@ ",
                                                                                          1,
                                                                                          0
                                                                                        }),
                                                                                      --[[ String ]]Block.__(2, {
                                                                                          --[[ No_padding ]]0,
                                                                                          --[[ Char_literal ]]Block.__(12, {
                                                                                              --[[ "." ]]46,
                                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                                  --[[ Close_box ]]0,
                                                                                                  --[[ End_of_format ]]0
                                                                                                })
                                                                                            })
                                                                                        })
                                                                                    })})
                                                                            })
                                                                        })
                                                                    })
                                                                }),
                                                              "@[The GADT constructor %s of type %a@ %s.@]"
                                                            }), param$1[1], path, param$1[0], "must be qualified in this pattern");end end end 
                                           do
                                          
                                        end
                                      end end 
                                    end end));
                      end end), param[3]);
        end else if (param[0] == Error_forward$1) then do
          return param[1];
        end else do
          return ;
        end end  end 
      end end));

add_delayed_check_forward.contents = add_delayed_check;

__Error$8 = Caml_exceptions.create("Ocaml_typedtree_test.Typedecl.Error");

function enter_type$1(env, sdecl, id) do
  match = sdecl.ptype_manifest;
  decl_type_params = List.map((function (param) do
          return newty2(100000000, --[[ Tvar ]]Block.__(0, {undefined}));
        end end), sdecl.ptype_params);
  decl_type_arity = List.length(sdecl.ptype_params);
  decl_type_private = sdecl.ptype_private;
  decl_type_manifest = match ~= undefined and newvar(undefined, --[[ () ]]0) or undefined;
  decl_type_variance = List.map((function (param) do
          return Types_Variance.full;
        end end), sdecl.ptype_params);
  decl_type_loc = sdecl.ptype_loc;
  decl_type_attributes = sdecl.ptype_attributes;
  decl = do
    type_params: decl_type_params,
    type_arity: decl_type_arity,
    type_kind: --[[ Type_abstract ]]0,
    type_private: decl_type_private,
    type_manifest: decl_type_manifest,
    type_variance: decl_type_variance,
    type_newtype_level: undefined,
    type_loc: decl_type_loc,
    type_attributes: decl_type_attributes
  end;
  return add_type$1(true, id, decl, env);
end end

function is_fixed_type(sd) do
  match = sd.ptype_manifest;
  if (match ~= undefined and sd.ptype_kind == --[[ Ptype_abstract ]]0 and sd.ptype_private == --[[ Private ]]0) then do
    _sty = match;
    while(true) do
      sty = _sty;
      match$1 = sty.ptyp_desc;
      if (typeof match$1 == "number") then do
        return false;
      end else do
        local ___conditional___=(match$1.tag | 0);
        do
           if ___conditional___ = 4--[[ Ptyp_object ]] then do
              if (match$1[1]) then do
                return true;
              end else do
                return false;
              end end end end end 
           if ___conditional___ = 5--[[ Ptyp_class ]] then do
              return true;end end end 
           if ___conditional___ = 6--[[ Ptyp_alias ]] then do
              _sty = match$1[0];
              continue ;end end end 
           if ___conditional___ = 7--[[ Ptyp_variant ]] then do
              if (match$1[1]) then do
                return true;
              end else do
                return match$1[2] ~= undefined;
              end end end end end 
           do
          else do
            return false;
            end end
            
        end
      end end 
    end;
  end else do
    return false;
  end end 
end end

function set_fixed_row(env, loc, p, decl) do
  match = decl.type_manifest;
  tm;
  if (match ~= undefined) then do
    tm = expand_head(env, match);
  end else do
    throw {
          Caml_builtin_exceptions.assert_failure,
          --[[ tuple ]]{
            "typedecl.ml",
            113,
            14
          }
        };
  end end 
  match$1 = tm.desc;
  rv;
  if (typeof match$1 == "number") then do
    throw {
          __Error$8,
          loc,
          --[[ Bad_fixed_type ]]Block.__(18, {"is not an object or variant"})
        };
  end else do
    local ___conditional___=(match$1.tag | 0);
    do
       if ___conditional___ = 4--[[ Tobject ]] then do
          rv = flatten_fields(match$1[0])[1];end else 
       if ___conditional___ = 8--[[ Tvariant ]] then do
          row = row_repr_aux(--[[ [] ]]0, match$1[0]);
          tm.desc = --[[ Tvariant ]]Block.__(8, {do
                row_fields: row.row_fields,
                row_more: row.row_more,
                row_bound: row.row_bound,
                row_closed: row.row_closed,
                row_fixed: true,
                row_name: row.row_name
              end});
          rv = static_row(row) and newty2(100000000, --[[ Tnil ]]0) or row.row_more;end else 
       do end end end
      else do
        throw {
              __Error$8,
              loc,
              --[[ Bad_fixed_type ]]Block.__(18, {"is not an object or variant"})
            };
        end end
        
    end
  end end 
  if (not is_Tvar(rv)) then do
    throw {
          __Error$8,
          loc,
          --[[ Bad_fixed_type ]]Block.__(18, {"has no row variable"})
        };
  end
   end 
  rv.desc = --[[ Tconstr ]]Block.__(3, {
      p,
      decl.type_params,
      do
        contents: --[[ Mnil ]]0
      end
    });
  return --[[ () ]]0;
end end

function height$10(param) do
  if (param) then do
    return param[--[[ h ]]3];
  end else do
    return 0;
  end end 
end end

function create$11(l, v, r) do
  hl = l and l[--[[ h ]]3] or 0;
  hr = r and r[--[[ h ]]3] or 0;
  return --[[ Node ]]{
          --[[ l ]]l,
          --[[ v ]]v,
          --[[ r ]]r,
          --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
        };
end end

function bal$10(l, v, r) do
  hl = l and l[--[[ h ]]3] or 0;
  hr = r and r[--[[ h ]]3] or 0;
  if (hl > (hr + 2 | 0)) then do
    if (l) then do
      lr = l[--[[ r ]]2];
      lv = l[--[[ v ]]1];
      ll = l[--[[ l ]]0];
      if (height$10(ll) >= height$10(lr)) then do
        return create$11(ll, lv, create$11(lr, v, r));
      end else if (lr) then do
        return create$11(create$11(ll, lv, lr[--[[ l ]]0]), lr[--[[ v ]]1], create$11(lr[--[[ r ]]2], v, r));
      end else do
        throw {
              Caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            };
      end end  end 
    end else do
      throw {
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          };
    end end 
  end else if (hr > (hl + 2 | 0)) then do
    if (r) then do
      rr = r[--[[ r ]]2];
      rv = r[--[[ v ]]1];
      rl = r[--[[ l ]]0];
      if (height$10(rr) >= height$10(rl)) then do
        return create$11(create$11(l, v, rl), rv, rr);
      end else if (rl) then do
        return create$11(create$11(l, v, rl[--[[ l ]]0]), rl[--[[ v ]]1], create$11(rl[--[[ r ]]2], rv, rr));
      end else do
        throw {
              Caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            };
      end end  end 
    end else do
      throw {
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          };
    end end 
  end else do
    return --[[ Node ]]{
            --[[ l ]]l,
            --[[ v ]]v,
            --[[ r ]]r,
            --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
          };
  end end  end 
end end

function add$12(x, t) do
  if (t) then do
    r = t[--[[ r ]]2];
    v = t[--[[ v ]]1];
    l = t[--[[ l ]]0];
    c = Caml_primitive.caml_string_compare(x, v);
    if (c == 0) then do
      return t;
    end else if (c < 0) then do
      ll = add$12(x, l);
      if (l == ll) then do
        return t;
      end else do
        return bal$10(ll, v, r);
      end end 
    end else do
      rr = add$12(x, r);
      if (r == rr) then do
        return t;
      end else do
        return bal$10(l, v, rr);
      end end 
    end end  end 
  end else do
    return --[[ Node ]]{
            --[[ l : Empty ]]0,
            --[[ v ]]x,
            --[[ r : Empty ]]0,
            --[[ h ]]1
          };
  end end 
end end

function mem$6(x, _param) do
  while(true) do
    param = _param;
    if (param) then do
      c = Caml_primitive.caml_string_compare(x, param[--[[ v ]]1]);
      if (c == 0) then do
        return true;
      end else do
        _param = c < 0 and param[--[[ l ]]0] or param[--[[ r ]]2];
        continue ;
      end end 
    end else do
      return false;
    end end 
  end;
end end

function make_params(env, params) do
  make_param = function (param) do
    sty = param[0];
    try do
      return --[[ tuple ]]{
              transl_type_param(env, sty),
              param[1]
            };
    end
    catch (exn)do
      if (exn == Already_bound) then do
        throw {
              __Error$8,
              sty.ptyp_loc,
              --[[ Repeated_parameter ]]0
            };
      end
       end 
      throw exn;
    end
  end end;
  return List.map(make_param, params);
end end

function make_constructor(env, type_path, type_params, sargs, sret_type) do
  if (sret_type ~= undefined) then do
    sret_type$1 = sret_type;
    z = narrow(--[[ () ]]0);
    reset_type_variables(--[[ () ]]0);
    targs = List.map((function (param) do
            return transl_simple_type(env, false, param);
          end end), sargs);
    args = List.map((function (cty) do
            return cty.ctyp_type;
          end end), targs);
    tret_type = transl_simple_type(env, false, sret_type$1);
    ret_type = tret_type.ctyp_type;
    match = repr(ret_type).desc;
    exit = 0;
    if (typeof match == "number" or not (match.tag == --[[ Tconstr ]]3 and same(type_path, match[0]))) then do
      exit = 1;
    end
     end 
    if (exit == 1) then do
      throw {
            __Error$8,
            sret_type$1.ptyp_loc,
            --[[ Constraint_failed ]]Block.__(5, {
                ret_type,
                newconstr(type_path, type_params)
              })
          };
    end
     end 
    widen(z);
    return --[[ tuple ]]{
            targs,
            tret_type,
            args,
            ret_type
          };
  end else do
    targs$1 = List.map((function (param) do
            return transl_simple_type(env, true, param);
          end end), sargs);
    args$1 = List.map((function (cty) do
            return cty.ctyp_type;
          end end), targs$1);
    return --[[ tuple ]]{
            targs$1,
            undefined,
            args$1,
            undefined
          };
  end end 
end end

function generalize_decl(decl) do
  List.iter(generalize, decl.type_params);
  match = decl.type_kind;
  if (typeof match == "number") then do
    match == --[[ Type_abstract ]]0;
  end else if (match.tag) then do
    List.iter((function (c) do
            List.iter(generalize, c.cd_args);
            return may(generalize, c.cd_res);
          end end), match[0]);
  end else do
    List.iter((function (l) do
            return iter_generalize$1(do
                        contents: --[[ [] ]]0
                      end, l.ld_type);
          end end), match[0]);
  end end  end 
  match$1 = decl.type_manifest;
  if (match$1 ~= undefined) then do
    return iter_generalize$1(do
                contents: --[[ [] ]]0
              end, match$1);
  end else do
    return --[[ () ]]0;
  end end 
end end

function check_constraints_rec(env, loc, visited, _ty) do
  while(true) do
    ty = _ty;
    ty$1 = repr(ty);
    if (mem$3(ty$1, visited.contents)) then do
      return --[[ () ]]0;
    end else do
      visited.contents = add$3(ty$1, visited.contents);
      match = ty$1.desc;
      if (typeof match == "number") then do
        return iter_type_expr((function (param) do
                      return check_constraints_rec(env, loc, visited, param);
                    end end), ty$1);
      end else do
        local ___conditional___=(match.tag | 0);
        do
           if ___conditional___ = 3--[[ Tconstr ]] then do
              args = match[1];
              path = match[0];
              args$prime = List.map((function (param) do
                      return newvar(undefined, --[[ () ]]0);
                    end end), args);
              ty$prime = newconstr(path, args$prime);
              try do
                enforce_constraints(env, ty$prime);
              end
              catch (raw_exn)do
                exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                if (exn[0] == Unify) then do
                  throw {
                        Caml_builtin_exceptions.assert_failure,
                        --[[ tuple ]]{
                          "typedecl.ml",
                          360,
                          28
                        }
                      };
                end
                 end 
                if (exn == Caml_builtin_exceptions.not_found) then do
                  throw {
                        __Error$8,
                        loc,
                        --[[ Unavailable_type_constructor ]]Block.__(17, {path})
                      };
                end
                 end 
                throw exn;
              end
              if (not matches(env, ty$1, ty$prime)) then do
                throw {
                      __Error$8,
                      loc,
                      --[[ Constraint_failed ]]Block.__(5, {
                          ty$1,
                          ty$prime
                        })
                    };
              end
               end 
              return List.iter((function (param) do
                            return check_constraints_rec(env, loc, visited, param);
                          end end), args);end end end 
           if ___conditional___ = 10--[[ Tpoly ]] then do
              match$1 = instance_poly(undefined, false, match[1], match[0]);
              _ty = match$1[1];
              continue ;end end end 
           do
          else do
            return iter_type_expr((function (param) do
                          return check_constraints_rec(env, loc, visited, param);
                        end end), ty$1);
            end end
            
        end
      end end 
    end end 
  end;
end end

function height$11(param) do
  if (param) then do
    return param[--[[ h ]]4];
  end else do
    return 0;
  end end 
end end

function create$12(l, x, d, r) do
  hl = height$11(l);
  hr = height$11(r);
  return --[[ Node ]]{
          --[[ l ]]l,
          --[[ v ]]x,
          --[[ d ]]d,
          --[[ r ]]r,
          --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
        };
end end

function bal$11(l, x, d, r) do
  hl = l and l[--[[ h ]]4] or 0;
  hr = r and r[--[[ h ]]4] or 0;
  if (hl > (hr + 2 | 0)) then do
    if (l) then do
      lr = l[--[[ r ]]3];
      ld = l[--[[ d ]]2];
      lv = l[--[[ v ]]1];
      ll = l[--[[ l ]]0];
      if (height$11(ll) >= height$11(lr)) then do
        return create$12(ll, lv, ld, create$12(lr, x, d, r));
      end else if (lr) then do
        return create$12(create$12(ll, lv, ld, lr[--[[ l ]]0]), lr[--[[ v ]]1], lr[--[[ d ]]2], create$12(lr[--[[ r ]]3], x, d, r));
      end else do
        throw {
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            };
      end end  end 
    end else do
      throw {
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          };
    end end 
  end else if (hr > (hl + 2 | 0)) then do
    if (r) then do
      rr = r[--[[ r ]]3];
      rd = r[--[[ d ]]2];
      rv = r[--[[ v ]]1];
      rl = r[--[[ l ]]0];
      if (height$11(rr) >= height$11(rl)) then do
        return create$12(create$12(l, x, d, rl), rv, rd, rr);
      end else if (rl) then do
        return create$12(create$12(l, x, d, rl[--[[ l ]]0]), rl[--[[ v ]]1], rl[--[[ d ]]2], create$12(rl[--[[ r ]]3], rv, rd, rr));
      end else do
        throw {
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            };
      end end  end 
    end else do
      throw {
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          };
    end end 
  end else do
    return --[[ Node ]]{
            --[[ l ]]l,
            --[[ v ]]x,
            --[[ d ]]d,
            --[[ r ]]r,
            --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
          };
  end end  end 
end end

function add$13(x, data, m) do
  if (m) then do
    r = m[--[[ r ]]3];
    d = m[--[[ d ]]2];
    v = m[--[[ v ]]1];
    l = m[--[[ l ]]0];
    c = Caml_primitive.caml_string_compare(x, v);
    if (c == 0) then do
      if (d == data) then do
        return m;
      end else do
        return --[[ Node ]]{
                --[[ l ]]l,
                --[[ v ]]x,
                --[[ d ]]data,
                --[[ r ]]r,
                --[[ h ]]m[--[[ h ]]4]
              };
      end end 
    end else if (c < 0) then do
      ll = add$13(x, data, l);
      if (l == ll) then do
        return m;
      end else do
        return bal$11(ll, v, d, r);
      end end 
    end else do
      rr = add$13(x, data, r);
      if (r == rr) then do
        return m;
      end else do
        return bal$11(l, v, d, rr);
      end end 
    end end  end 
  end else do
    return --[[ Node ]]{
            --[[ l : Empty ]]0,
            --[[ v ]]x,
            --[[ d ]]data,
            --[[ r : Empty ]]0,
            --[[ h ]]1
          };
  end end 
end end

function find$6(x, _param) do
  while(true) do
    param = _param;
    if (param) then do
      c = Caml_primitive.caml_string_compare(x, param[--[[ v ]]1]);
      if (c == 0) then do
        return param[--[[ d ]]2];
      end else do
        _param = c < 0 and param[--[[ l ]]0] or param[--[[ r ]]3];
        continue ;
      end end 
    end else do
      throw Caml_builtin_exceptions.not_found;
    end end 
  end;
end end

function check_coherence(env, loc, id, decl) do
  match = decl.type_kind;
  if (typeof match == "number" and match == 0) then do
    return --[[ () ]]0;
  end
   end 
  match$1 = decl.type_manifest;
  if (match$1 ~= undefined) then do
    ty = match$1;
    match$2 = repr(ty).desc;
    if (typeof match$2 == "number") then do
      throw {
            __Error$8,
            loc,
            --[[ Definition_mismatch ]]Block.__(4, {
                ty,
                --[[ [] ]]0
              })
          };
    end else if (match$2.tag == --[[ Tconstr ]]3) then do
      args = match$2[1];
      path = match$2[0];
      try do
        decl$prime = find_type_full(path, env)[0];
        err = List.length(args) ~= List.length(decl.type_params) and --[[ :: ]]{
            --[[ Arity ]]0,
            --[[ [] ]]0
          } or (
            equal$4(env, false, args, decl.type_params) and type_declarations$1(true, env, last(path), decl$prime, id, type_declaration(add_type(id, path, identity), decl)) or --[[ :: ]]{
                --[[ Constraint ]]3,
                --[[ [] ]]0
              }
          );
        if (err ~= --[[ [] ]]0) then do
          throw {
                __Error$8,
                loc,
                --[[ Definition_mismatch ]]Block.__(4, {
                    ty,
                    err
                  })
              };
        end else do
          return 0;
        end end 
      end
      catch (exn)do
        if (exn == Caml_builtin_exceptions.not_found) then do
          throw {
                __Error$8,
                loc,
                --[[ Unavailable_type_constructor ]]Block.__(17, {path})
              };
        end
         end 
        throw exn;
      end
    end else do
      throw {
            __Error$8,
            loc,
            --[[ Definition_mismatch ]]Block.__(4, {
                ty,
                --[[ [] ]]0
              })
          };
    end end  end 
  end else do
    return --[[ () ]]0;
  end end 
end end

function check_well_founded(env, loc, path, to_check, ty) do
  visited = do
    contents: --[[ Empty ]]0
  end;
  check = function (ty0, exp_nodes, ty) do
    ty$1 = repr(ty);
    if (mem$3(ty$1, exp_nodes)) then do
      match = ty0.desc;
      tmp;
      tmp = typeof match == "number" or match.tag ~= --[[ Tconstr ]]3 and false or same(match[0], path);
      if (tmp) then do
        throw {
              __Error$8,
              loc,
              --[[ Recursive_abbrev ]]Block.__(2, {name(undefined, path)})
            };
      end
       end 
      throw {
            __Error$8,
            loc,
            --[[ Cycle_in_def ]]Block.__(3, {
                name(undefined, path),
                ty0
              })
          };
    end
     end 
    match$1;
    try do
      prev = find$1(ty$1, visited.contents);
      match$1 = subset$1(exp_nodes, prev) and --[[ tuple ]]{
          true,
          exp_nodes
        } or --[[ tuple ]]{
          false,
          union$2(exp_nodes, prev)
        };
    end
    catch (exn)do
      if (exn == Caml_builtin_exceptions.not_found) then do
        match$1 = --[[ tuple ]]{
          false,
          exp_nodes
        };
      end else do
        throw exn;
      end end 
    end
    exp_nodes$1 = match$1[1];
    snap = snapshot(--[[ () ]]0);
    if (match$1[0]) then do
      return --[[ () ]]0;
    end else do
      try do
        visited.contents = add$4(ty$1, exp_nodes$1, visited.contents);
        match$2 = ty$1.desc;
        if (typeof match$2 == "number") then do
          throw Cannot_expand;
        end else if (match$2.tag == --[[ Tconstr ]]3) then do
          if (not (
              exp_nodes$1 and false or true
            ) or Curry._1(to_check, match$2[0])) then do
            ty$prime = try_expand_once_opt(env, ty$1);
            ty0$1 = (
              exp_nodes$1 and false or true
            ) and ty$1 or ty0;
            return check(ty0$1, add$3(ty$1, exp_nodes$1), ty$prime);
          end else do
            throw Cannot_expand;
          end end 
        end else do
          throw Cannot_expand;
        end end  end 
      end
      catch (raw_exn)do
        exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn$1 == Cannot_expand) then do
          tmp$1 = true;
          if (not (recursive_types.contents and is_contractive(env, ty$1))) then do
            match$3 = ty$1.desc;
            tmp$2;
            if (typeof match$3 == "number") then do
              tmp$2 = false;
            end else do
              local ___conditional___=(match$3.tag | 0);
              do
                 if ___conditional___ = 4--[[ Tobject ]]
                 or ___conditional___ = 8--[[ Tvariant ]] then do
                    tmp$2 = true;end else 
                 do end end
                else do
                  tmp$2 = false;
                  end end
                  
              end
            end end 
            tmp$1 = tmp$2;
          end
           end 
          nodes = tmp$1 and --[[ Empty ]]0 or exp_nodes$1;
          return iter_type_expr((function (param) do
                        return check(ty0, nodes, param);
                      end end), ty$1);
        end else if (exn$1[0] == Unify) then do
          return backtrack(snap);
        end else do
          throw exn$1;
        end end  end 
      end
    end end 
  end end;
  return wrap_trace_gadt_instances(env, (function (param) do
                return check(ty, --[[ Empty ]]0, param);
              end end), ty);
end end

function check_well_founded_decl(env, loc, path, decl, to_check) do
  it_it_type_expr = function (param) do
    return (function (param) do
        return check_well_founded(env, loc, path, to_check, param);
      end end);
  end end;
  it = do
    it_signature: it_signature,
    it_signature_item: it_signature_item,
    it_value_description: it_value_description,
    it_type_declaration: it_type_declaration,
    it_extension_constructor: it_extension_constructor,
    it_module_declaration: it_module_declaration,
    it_modtype_declaration: it_modtype_declaration,
    it_class_declaration: it_class_declaration,
    it_class_type_declaration: it_class_type_declaration,
    it_module_type: it_module_type,
    it_class_type: it_class_type,
    it_type_kind: it_type_kind,
    it_do_type_expr: it_do_type_expr,
    it_type_expr: it_it_type_expr,
    it_path: it_path
  end;
  return it_type_declaration(it, instance_declaration(decl));
end end

function check_recursion(env, loc, path, decl, to_check) do
  if (decl.type_params == --[[ [] ]]0) then do
    return --[[ () ]]0;
  end else do
    visited = do
      contents: --[[ [] ]]0
    end;
    check_regular = function (cpath, args, prev_exp, _ty) do
      while(true) do
        ty = _ty;
        ty$1 = repr(ty);
        if (List.memq(ty$1, visited.contents)) then do
          return 0;
        end else do
          visited.contents = --[[ :: ]]{
            ty$1,
            visited.contents
          };
          match = ty$1.desc;
          if (typeof match == "number") then do
            return iter_type_expr((function (param) do
                          return check_regular(cpath, args, prev_exp, param);
                        end end), ty$1);
          end else do
            local ___conditional___=(match.tag | 0);
            do
               if ___conditional___ = 3--[[ Tconstr ]] then do
                  args$prime = match[1];
                  path$prime = match[0];
                  if (same(path, path$prime)) then do
                    if (not equal$4(env, false, args, args$prime)) then do
                      throw {
                            __Error$8,
                            loc,
                            --[[ Parameters_differ ]]Block.__(8, {
                                cpath,
                                ty$1,
                                newconstr(path, args)
                              })
                          };
                    end
                     end 
                  end else if (Curry._1(to_check, path$prime) and not List.mem(path$prime, prev_exp)) then do
                    try do
                      match$1 = find_type_expansion(path$prime, env);
                      params0 = match$1[0];
                      match$2 = instance_parameterized_type(undefined, params0, match$1[1]);
                      try do
                        List.iter2((function (param, param$1) do
                                return unify$2(env, param, param$1);
                              end end), match$2[0], args$prime);
                      end
                      catch (raw_exn)do
                        exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                        if (exn[0] == Unify) then do
                          throw {
                                __Error$8,
                                loc,
                                --[[ Constraint_failed ]]Block.__(5, {
                                    ty$1,
                                    newconstr(path$prime, params0)
                                  })
                              };
                        end
                         end 
                        throw exn;
                      end
                      check_regular(path$prime, args, --[[ :: ]]{
                            path$prime,
                            prev_exp
                          }, match$2[1]);
                    end
                    catch (exn$1)do
                      if (exn$1 ~= Caml_builtin_exceptions.not_found) then do
                        throw exn$1;
                      end
                       end 
                    end
                  end
                   end  end 
                  return List.iter((function (param) do
                                return check_regular(cpath, args, prev_exp, param);
                              end end), args$prime);end end end 
               if ___conditional___ = 10--[[ Tpoly ]] then do
                  match$3 = instance_poly(true, false, match[1], match[0]);
                  _ty = match$3[1];
                  continue ;end end end 
               do
              else do
                return iter_type_expr((function (param) do
                              return check_regular(cpath, args, prev_exp, param);
                            end end), ty$1);
                end end
                
            end
          end end 
        end end 
      end;
    end end;
    return may((function (body) do
                  match = instance_parameterized_type(true, decl.type_params, body);
                  return check_regular(path, match[0], --[[ [] ]]0, match[1]);
                end end), decl.type_manifest);
  end end 
end end

function get_variance(ty, visited) do
  try do
    return find$1(ty, visited.contents);
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return Types_Variance.__null;
    end else do
      throw exn;
    end end 
  end
end end

function compute_variance(env, visited, vari, ty) do
  compute_variance_rec = function (_vari, _ty) do
    while(true) do
      ty = _ty;
      vari = _vari;
      ty$1 = repr(ty);
      vari$prime = get_variance(ty$1, visited);
      if (Curry._2(Types_Variance.subset, vari, vari$prime)) then do
        return --[[ () ]]0;
      end else do
        vari$1 = Curry._2(Types_Variance.union, vari, vari$prime);
        visited.contents = add$4(ty$1, vari$1, visited.contents);
        compute_same = (function(vari$1)do
        return function compute_same(param) do
          return compute_variance_rec(vari$1, param);
        end end
        end(vari$1));
        match = ty$1.desc;
        if (typeof match == "number") then do
          return --[[ () ]]0;
        end else do
          local ___conditional___=(match.tag | 0);
          do
             if ___conditional___ = 1--[[ Tarrow ]] then do
                v = Curry._1(Types_Variance.conjugate, vari$1);
                v1 = Curry._2(Types_Variance.mem, --[[ May_pos ]]0, v) or Curry._2(Types_Variance.mem, --[[ May_neg ]]1, v) and Curry._3(Types_Variance.set, --[[ May_weak ]]2, true, v) or v;
                compute_variance_rec(v1, match[1]);
                _ty = match[2];
                _vari = vari$1;
                continue ;end end end 
             if ___conditional___ = 2--[[ Ttuple ]] then do
                return List.iter(compute_same, match[0]);end end end 
             if ___conditional___ = 3--[[ Tconstr ]] then do
                tl = match[1];
                if (tl == --[[ [] ]]0) then do
                  return --[[ () ]]0;
                end else do
                  try do
                    decl = find_type_full(match[0], env)[0];
                    return List.iter2((function(vari$1)do
                              return function (ty, v) do
                                strict = Curry._2(Types_Variance.mem, --[[ Inv ]]6, vari$1) and Curry._2(Types_Variance.mem, --[[ Inj ]]3, v) or (Curry._2(Types_Variance.mem, --[[ Pos ]]4, vari$1) or Curry._2(Types_Variance.mem, --[[ Neg ]]5, vari$1)) and Curry._2(Types_Variance.mem, --[[ Inv ]]6, v);
                                if (strict) then do
                                  return compute_variance_rec(Types_Variance.full, ty);
                                end else do
                                  p1 = Curry._2(Types_Variance.inter, v, vari$1);
                                  n1 = Curry._2(Types_Variance.inter, v, Curry._1(Types_Variance.conjugate, vari$1));
                                  v1 = Curry._2(Types_Variance.union, Curry._2(Types_Variance.inter, Types_Variance.covariant, Curry._2(Types_Variance.union, p1, Curry._1(Types_Variance.conjugate, p1))), Curry._2(Types_Variance.inter, Curry._1(Types_Variance.conjugate, Types_Variance.covariant), Curry._2(Types_Variance.union, n1, Curry._1(Types_Variance.conjugate, n1))));
                                  weak = Curry._2(Types_Variance.mem, --[[ May_weak ]]2, vari$1) and (Curry._2(Types_Variance.mem, --[[ May_pos ]]0, v) or Curry._2(Types_Variance.mem, --[[ May_neg ]]1, v)) or (Curry._2(Types_Variance.mem, --[[ May_pos ]]0, vari$1) or Curry._2(Types_Variance.mem, --[[ May_neg ]]1, vari$1)) and Curry._2(Types_Variance.mem, --[[ May_weak ]]2, v);
                                  v2 = Curry._3(Types_Variance.set, --[[ May_weak ]]2, weak, v1);
                                  return compute_variance_rec(v2, ty);
                                end end 
                              end end
                              end(vari$1)), tl, decl.type_variance);
                  end
                  catch (exn)do
                    if (exn == Caml_builtin_exceptions.not_found) then do
                      return List.iter((function (param) do
                                    return compute_variance_rec(Types_Variance.may_inv, param);
                                  end end), tl);
                    end else do
                      throw exn;
                    end end 
                  end
                end end end end end 
             if ___conditional___ = 5--[[ Tfield ]] then do
                compute_variance_rec(vari$1, match[2]);
                _ty = match[3];
                _vari = vari$1;
                continue ;end end end 
             if ___conditional___ = 8--[[ Tvariant ]] then do
                row = row_repr_aux(--[[ [] ]]0, match[0]);
                List.iter((function(vari$1)do
                    return function (param) do
                      match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                      if (typeof match == "number") then do
                        return --[[ () ]]0;
                      end else if (match.tag) then do
                        upper = List.fold_left((function (s, f) do
                                return Curry._3(Types_Variance.set, f, true, s);
                              end end), Types_Variance.__null, --[[ :: ]]{
                              --[[ May_pos ]]0,
                              --[[ :: ]]{
                                --[[ May_neg ]]1,
                                --[[ :: ]]{
                                  --[[ May_weak ]]2,
                                  --[[ [] ]]0
                                }
                              }
                            });
                        v = Curry._2(Types_Variance.inter, vari$1, upper);
                        return List.iter((function (param) do
                                      return compute_variance_rec(v, param);
                                    end end), match[1]);
                      end else do
                        match$1 = match[0];
                        if (match$1 ~= undefined) then do
                          return compute_variance_rec(vari$1, match$1);
                        end else do
                          return --[[ () ]]0;
                        end end 
                      end end  end 
                    end end
                    end(vari$1)), row.row_fields);
                _ty = row.row_more;
                _vari = vari$1;
                continue ;end end end 
             if ___conditional___ = 4--[[ Tobject ]]
             or ___conditional___ = 7--[[ Tsubst ]]
             or ___conditional___ = 10--[[ Tpoly ]] then do
                _ty = match[0];
                _vari = vari$1;
                continue ;end end end 
             if ___conditional___ = 11--[[ Tpackage ]] then do
                v$1 = Curry._2(Types_Variance.mem, --[[ Pos ]]4, vari$1) or Curry._2(Types_Variance.mem, --[[ Neg ]]5, vari$1) and Types_Variance.full or Types_Variance.may_inv;
                return List.iter((function(v$1)do
                          return function (param) do
                            return compute_variance_rec(v$1, param);
                          end end
                          end(v$1)), match[2]);end end end 
             do
            else do
              return --[[ () ]]0;
              end end
              
          end
        end end 
      end end 
    end;
  end end;
  return compute_variance_rec(vari, ty);
end end

function make(p, n, i) do
  return Curry._3(Types_Variance.set, --[[ May_pos ]]0, p, Curry._3(Types_Variance.set, --[[ May_neg ]]1, n, Curry._3(Types_Variance.set, --[[ May_weak ]]2, n, Curry._3(Types_Variance.set, --[[ Inj ]]3, i, Types_Variance.__null))));
end end

function compute_variance_type(env, check, param, decl, tyl) do
  loc = param[1];
  required = List.map((function (param) do
          i = param[2];
          n = param[1];
          c = param[0];
          if (c or n) then do
            return --[[ tuple ]]{
                    c,
                    n,
                    i
                  };
          end else do
            return --[[ tuple ]]{
                    true,
                    true,
                    i
                  };
          end end 
        end end), param[0]);
  params = List.map(repr, decl.type_params);
  tvl = do
    contents: --[[ Empty ]]0
  end;
  List.iter((function (param) do
          return compute_variance(env, tvl, param[0] and Types_Variance.full or Types_Variance.covariant, param[1]);
        end end), tyl);
  if (check) then do
    pos = do
      contents: 0
    end;
    List.iter2((function (ty, param) do
            i = param[2];
            n = param[1];
            c = param[0];
            pos.contents = pos.contents + 1 | 0;
            __var = get_variance(ty, tvl);
            match = Curry._1(Types_Variance.get_upper, __var);
            cn = match[1];
            co = match[0];
            ij = Curry._2(Types_Variance.mem, --[[ Inj ]]3, __var);
            if (is_Tvar(ty) and (co and not c or cn and not n or not ij and i)) then do
              throw {
                    __Error$8,
                    loc,
                    --[[ Bad_variance ]]Block.__(16, {
                        pos.contents,
                        --[[ tuple ]]{
                          co,
                          cn,
                          ij
                        },
                        --[[ tuple ]]{
                          c,
                          n,
                          i
                        }
                      })
                  };
            end else do
              return 0;
            end end 
          end end), params, required);
    args = newty2(100000000, --[[ Ttuple ]]Block.__(2, {params}));
    fvl = free_variables$1(undefined, args);
    fvl$1 = List.filter((function (v) do
              return not List.memq(v, params);
            end end))(fvl);
    if (fvl$1 ~= --[[ [] ]]0) then do
      tvl2 = do
        contents: --[[ Empty ]]0
      end;
      List.iter2((function (ty, param) do
              if (is_Tvar(ty)) then do
                return --[[ () ]]0;
              end else do
                v = param[0] and (
                    param[1] and Types_Variance.full or Types_Variance.covariant
                  ) or Curry._1(Types_Variance.conjugate, Types_Variance.covariant);
                return compute_variance(env, tvl2, v, ty);
              end end 
            end end), params, required);
      visited = do
        contents: --[[ Empty ]]0
      end;
      check$1 = function (ty) do
        ty$1 = repr(ty);
        if (mem$3(ty$1, visited.contents)) then do
          return --[[ () ]]0;
        end else do
          visited$prime = add$3(ty$1, visited.contents);
          visited.contents = visited$prime;
          v1 = get_variance(ty$1, tvl);
          snap = snapshot(--[[ () ]]0);
          v2 = fold$3((function (t, vt, v) do
                  if (equal$4(env, false, --[[ :: ]]{
                          ty$1,
                          --[[ [] ]]0
                        }, --[[ :: ]]{
                          t,
                          --[[ [] ]]0
                        })) then do
                    return Curry._2(Types_Variance.union, vt, v);
                  end else do
                    return v;
                  end end 
                end end), tvl2.contents, Types_Variance.__null);
          backtrack(snap);
          match = Curry._1(Types_Variance.get_upper, v1);
          n1 = match[1];
          c1 = match[0];
          match$1 = Curry._1(Types_Variance.get_lower, v2);
          n2 = match$1[1];
          c2 = match$1[0];
          if (c1 and not c2 or n1 and not n2) then do
            if (List.memq(ty$1, fvl$1)) then do
              code = match$1[3] and (
                  c2 or n2 and -1 or -3
                ) or -2;
              throw {
                    __Error$8,
                    loc,
                    --[[ Bad_variance ]]Block.__(16, {
                        code,
                        --[[ tuple ]]{
                          c1,
                          n1,
                          false
                        },
                        --[[ tuple ]]{
                          c2,
                          n2,
                          false
                        }
                      })
                  };
            end else do
              return iter_type_expr(check$1, ty$1);
            end end 
          end else do
            return 0;
          end end 
        end end 
      end end;
      List.iter((function (param) do
              return check$1(param[1]);
            end end), tyl);
    end
     end 
  end
   end 
  return List.map2((function (ty, param) do
                v = get_variance(ty, tvl);
                tr = decl.type_private;
                concr = decl.type_kind ~= --[[ Type_abstract ]]0;
                match = tr == --[[ Private ]]0 or not is_Tvar(ty) and --[[ tuple ]]{
                    param[0],
                    param[1]
                  } or --[[ tuple ]]{
                    false,
                    false
                  };
                n = match[1];
                p = match[0];
                i = concr or param[2] and tr == --[[ Private ]]0;
                v$1 = Curry._2(Types_Variance.union, v, make(p, n, i));
                v$2 = concr and (
                    Curry._2(Types_Variance.mem, --[[ Pos ]]4, v$1) and Curry._2(Types_Variance.mem, --[[ Neg ]]5, v$1) and Types_Variance.full or (
                        is_Tvar(ty) and v$1 or Curry._2(Types_Variance.union, v$1, p and (
                                  n and Types_Variance.full or Types_Variance.covariant
                                ) or Curry._1(Types_Variance.conjugate, Types_Variance.covariant))
                      )
                  ) or v$1;
                if (decl.type_kind == --[[ Type_abstract ]]0 and tr == --[[ Public ]]1) then do
                  return v$2;
                end else do
                  return Curry._3(Types_Variance.set, --[[ May_weak ]]2, Curry._2(Types_Variance.mem, --[[ May_neg ]]1, v$2), v$2);
                end end 
              end end), params, required);
end end

function add_false(param) do
  return List.map((function (ty) do
                return --[[ tuple ]]{
                        false,
                        ty
                      };
              end end), param);
end end

function constrained(env, vars, ty) do
  match = ty.desc;
  if (typeof match == "number" or match.tag) then do
    return true;
  end else do
    return List.exists((function (tl) do
                  return List.memq(ty, tl);
                end end), vars);
  end end 
end end

function compute_variance_gadt(env, check, rloc, decl, param) do
  ret_type_opt = param[1];
  tl = param[0];
  loc = rloc[1];
  if (ret_type_opt ~= undefined) then do
    match = repr(ret_type_opt);
    match$1 = match.desc;
    if (typeof match$1 == "number") then do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "typedecl.ml",
              809,
              13
            }
          };
    end else if (match$1.tag == --[[ Tconstr ]]3) then do
      tyl = List.map(repr, match$1[1]);
      fvl = List.map((function (param) do
              return free_variables$1(undefined, param);
            end end), tyl);
      List.fold_left2((function (param, ty, param$1) do
              fv2 = param[1];
              if (fv2) then do
                fv2$1 = fv2[1];
                fv1 = param[0];
                if ((param$1[0] or param$1[1]) and constrained(env, Pervasives.$at(fv1, fv2$1), ty)) then do
                  throw {
                        __Error$8,
                        loc,
                        --[[ Varying_anonymous ]]4
                      };
                end
                 end 
                return --[[ tuple ]]{
                        --[[ :: ]]{
                          fv2[0],
                          fv1
                        },
                        fv2$1
                      };
              end else do
                throw {
                      Caml_builtin_exceptions.assert_failure,
                      --[[ tuple ]]{
                        "typedecl.ml",
                        798,
                        37
                      }
                    };
              end end 
            end end), --[[ tuple ]]{
            --[[ [] ]]0,
            fvl
          }, tyl, rloc[0]);
      return compute_variance_type(env, check, rloc, do
                  type_params: tyl,
                  type_arity: decl.type_arity,
                  type_kind: decl.type_kind,
                  type_private: --[[ Private ]]0,
                  type_manifest: decl.type_manifest,
                  type_variance: decl.type_variance,
                  type_newtype_level: decl.type_newtype_level,
                  type_loc: decl.type_loc,
                  type_attributes: decl.type_attributes
                end, add_false(tl));
    end else do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "typedecl.ml",
              809,
              13
            }
          };
    end end  end 
  end else do
    return compute_variance_type(env, check, rloc, do
                type_params: decl.type_params,
                type_arity: decl.type_arity,
                type_kind: decl.type_kind,
                type_private: --[[ Private ]]0,
                type_manifest: decl.type_manifest,
                type_variance: decl.type_variance,
                type_newtype_level: decl.type_newtype_level,
                type_loc: decl.type_loc,
                type_attributes: decl.type_attributes
              end, add_false(tl));
  end end 
end end

function compute_variance_extension(env, check, decl, ext, rloc) do
  return compute_variance_gadt(env, check, rloc, do
              type_params: ext.ext_type_params,
              type_arity: decl.type_arity,
              type_kind: decl.type_kind,
              type_private: decl.type_private,
              type_manifest: decl.type_manifest,
              type_variance: decl.type_variance,
              type_newtype_level: decl.type_newtype_level,
              type_loc: decl.type_loc,
              type_attributes: decl.type_attributes
            end, --[[ tuple ]]{
              ext.ext_args,
              ext.ext_ret_type
            });
end end

function compute_variance_decl(env, check, decl, rloc) do
  if ((decl.type_kind == --[[ Type_abstract ]]0 or decl.type_kind == --[[ Type_open ]]1) and decl.type_manifest == undefined) then do
    return List.map((function (param) do
                  return make(not param[1], not param[0], decl.type_kind ~= --[[ Type_abstract ]]0 or param[2]);
                end end), rloc[0]);
  end else do
    match = decl.type_manifest;
    mn = match ~= undefined and --[[ :: ]]{
        --[[ tuple ]]{
          false,
          match
        },
        --[[ [] ]]0
      } or --[[ [] ]]0;
    match$1 = decl.type_kind;
    if (typeof match$1 == "number") then do
      return compute_variance_type(env, check, rloc, decl, mn);
    end else if (match$1.tag) then do
      tll = match$1[0];
      if (List.for_all((function (c) do
                return c.cd_res == undefined;
              end end), tll)) then do
        return compute_variance_type(env, check, rloc, decl, Pervasives.$at(mn, add_false(List.flatten(List.map((function (c) do
                                      return c.cd_args;
                                    end end), tll)))));
      end else do
        mn$1 = List.map((function (param) do
                return --[[ tuple ]]{
                        --[[ :: ]]{
                          param[1],
                          --[[ [] ]]0
                        },
                        undefined
                      };
              end end), mn);
        tll$1 = Pervasives.$at(mn$1, List.map((function (c) do
                    return --[[ tuple ]]{
                            c.cd_args,
                            c.cd_res
                          };
                  end end), tll));
        match$2 = List.map((function (param) do
                return compute_variance_gadt(env, check, rloc, decl, param);
              end end), tll$1);
        if (match$2) then do
          varl = List.fold_left((function (param, param$1) do
                  return List.map2(Types_Variance.union, param, param$1);
                end end), match$2[0], match$2[1]);
          return List.map((function (v) do
                        if (Curry._2(Types_Variance.mem, --[[ Pos ]]4, v) and Curry._2(Types_Variance.mem, --[[ Neg ]]5, v)) then do
                          return Types_Variance.full;
                        end else do
                          return v;
                        end end 
                      end end), varl);
        end else do
          throw {
                Caml_builtin_exceptions.assert_failure,
                --[[ tuple ]]{
                  "typedecl.ml",
                  848,
                  15
                }
              };
        end end 
      end end 
    end else do
      return compute_variance_type(env, check, rloc, decl, Pervasives.$at(mn, List.map((function (param) do
                            return --[[ tuple ]]{
                                    param.ld_mutable == --[[ Mutable ]]1,
                                    param.ld_type
                                  };
                          end end), match$1[0])));
    end end  end 
  end end 
end end

function is_sharp(id) do
  s = id.name;
  if (#s ~= 0) then do
    return Caml_string.get(s, 0) == --[[ "#" ]]35;
  end else do
    return false;
  end end 
end end

function compute_variance_fixpoint(env, decls, required, _variances) do
  while(true) do
    variances = _variances;
    new_decls = List.map2((function (param, variance) do
            decl = param[1];
            return --[[ tuple ]]{
                    param[0],
                    do
                      type_params: decl.type_params,
                      type_arity: decl.type_arity,
                      type_kind: decl.type_kind,
                      type_private: decl.type_private,
                      type_manifest: decl.type_manifest,
                      type_variance: variance,
                      type_newtype_level: decl.type_newtype_level,
                      type_loc: decl.type_loc,
                      type_attributes: decl.type_attributes
                    end
                  };
          end end), decls, variances);
    new_env = List.fold_right((function (param, env) do
            return add_type$1(true, param[0], param[1], env);
          end end), new_decls, env);
    new_variances = List.map2((function(new_env)do
        return function (param) do
          decl = param[1];
          return (function (param) do
              return compute_variance_decl(new_env, false, decl, param);
            end end);
        end end
        end(new_env)), new_decls, required);
    new_variances$1 = List.map2((function (param, param$1) do
            return List.map2(Types_Variance.union, param, param$1);
          end end), new_variances, variances);
    if (Caml_obj.caml_notequal(new_variances$1, variances)) then do
      _variances = new_variances$1;
      continue ;
    end else do
      List.iter2((function(new_env)do
          return function (param, req) do
            if (is_sharp(param[0])) then do
              return 0;
            end else do
              compute_variance_decl(new_env, true, param[1], req);
              return --[[ () ]]0;
            end end 
          end end
          end(new_env)), new_decls, required);
      return --[[ tuple ]]{
              new_decls,
              new_env
            };
    end end 
  end;
end end

function init_variance(param) do
  return List.map((function (param) do
                return Types_Variance.__null;
              end end), param[1].type_params);
end end

function add_injectivity(param) do
  return List.map((function (param) do
                local ___conditional___=(param);
                do
                   if ___conditional___ = 0--[[ Covariant ]] then do
                      return --[[ tuple ]]{
                              true,
                              false,
                              false
                            };end end end 
                   if ___conditional___ = 1--[[ Contravariant ]] then do
                      return --[[ tuple ]]{
                              false,
                              true,
                              false
                            };end end end 
                   if ___conditional___ = 2--[[ Invariant ]] then do
                      return --[[ tuple ]]{
                              false,
                              false,
                              false
                            };end end end 
                   do
                  
                end
              end end), param);
end end

function compute_variance_decls(env, cldecls) do
  match = List.fold_right((function (param, param$1) do
          ci = param[5];
          variance = List.map((function (prim) do
                  return prim[1];
                end end), ci.ci_params);
          return --[[ tuple ]]{
                  --[[ :: ]]{
                    --[[ tuple ]]{
                      param[0],
                      param[1]
                    },
                    param$1[0]
                  },
                  --[[ :: ]]{
                    --[[ tuple ]]{
                      add_injectivity(variance),
                      ci.ci_loc
                    },
                    param$1[1]
                  }
                };
        end end), cldecls, --[[ tuple ]]{
        --[[ [] ]]0,
        --[[ [] ]]0
      });
  decls = match[0];
  variances = List.map(init_variance, decls);
  match$1 = compute_variance_fixpoint(env, decls, match[1], variances);
  return List.map2((function (param, param$1) do
                cltydef = param$1[4];
                clty = param$1[3];
                cl_abbr = param$1[2];
                decl = param[1];
                variance = decl.type_variance;
                return --[[ tuple ]]{
                        decl,
                        do
                          type_params: cl_abbr.type_params,
                          type_arity: cl_abbr.type_arity,
                          type_kind: cl_abbr.type_kind,
                          type_private: cl_abbr.type_private,
                          type_manifest: cl_abbr.type_manifest,
                          type_variance: variance,
                          type_newtype_level: cl_abbr.type_newtype_level,
                          type_loc: cl_abbr.type_loc,
                          type_attributes: cl_abbr.type_attributes
                        end,
                        do
                          cty_params: clty.cty_params,
                          cty_type: clty.cty_type,
                          cty_path: clty.cty_path,
                          cty_new: clty.cty_new,
                          cty_variance: variance,
                          cty_loc: clty.cty_loc,
                          cty_attributes: clty.cty_attributes
                        end,
                        do
                          clty_params: cltydef.clty_params,
                          clty_type: cltydef.clty_type,
                          clty_path: cltydef.clty_path,
                          clty_variance: variance,
                          clty_loc: cltydef.clty_loc,
                          clty_attributes: cltydef.clty_attributes
                        end
                      };
              end end), match$1[0], cldecls);
end end

function check_duplicates(sdecl_list) do
  labels = Hashtbl.create(undefined, 7);
  constrs = Hashtbl.create(undefined, 7);
  return List.iter((function (sdecl) do
                match = sdecl.ptype_kind;
                if (typeof match == "number") then do
                  return --[[ () ]]0;
                end else if (match.tag) then do
                  return List.iter((function (param) do
                                cname = param.pld_name;
                                try do
                                  name$prime = Hashtbl.find(labels, cname.txt);
                                  return prerr_warning(param.pld_loc, --[[ Duplicate_definitions ]]Block.__(14, {
                                                "label",
                                                cname.txt,
                                                name$prime,
                                                sdecl.ptype_name.txt
                                              }));
                                end
                                catch (exn)do
                                  if (exn == Caml_builtin_exceptions.not_found) then do
                                    return Hashtbl.add(labels, cname.txt, sdecl.ptype_name.txt);
                                  end else do
                                    throw exn;
                                  end end 
                                end
                              end end), match[0]);
                end else do
                  return List.iter((function (pcd) do
                                try do
                                  name$prime = Hashtbl.find(constrs, pcd.pcd_name.txt);
                                  return prerr_warning(pcd.pcd_loc, --[[ Duplicate_definitions ]]Block.__(14, {
                                                "constructor",
                                                pcd.pcd_name.txt,
                                                name$prime,
                                                sdecl.ptype_name.txt
                                              }));
                                end
                                catch (exn)do
                                  if (exn == Caml_builtin_exceptions.not_found) then do
                                    return Hashtbl.add(constrs, pcd.pcd_name.txt, sdecl.ptype_name.txt);
                                  end else do
                                    throw exn;
                                  end end 
                                end
                              end end), match[0]);
                end end  end 
              end end), sdecl_list);
end end

function name_recursion(sdecl, id, decl) do
  match = decl.type_kind;
  if (typeof match == "number" and not (match ~= 0 or decl.type_private)) then do
    match$1 = decl.type_manifest;
    if (match$1 ~= undefined and is_fixed_type(sdecl)) then do
      ty = repr(match$1);
      ty$prime = newty2(ty.level, ty.desc);
      if (deep_occur(ty, ty$prime)) then do
        td_000 = --[[ Pident ]]Block.__(0, {id});
        td_001 = decl.type_params;
        td_002 = do
          contents: --[[ Mnil ]]0
        end;
        td = --[[ Tconstr ]]Block.__(3, {
            td_000,
            td_001,
            td_002
          });
        link_type(ty, newty2(ty.level, td));
        return do
                type_params: decl.type_params,
                type_arity: decl.type_arity,
                type_kind: decl.type_kind,
                type_private: decl.type_private,
                type_manifest: ty$prime,
                type_variance: decl.type_variance,
                type_newtype_level: decl.type_newtype_level,
                type_loc: decl.type_loc,
                type_attributes: decl.type_attributes
              end;
      end else do
        return decl;
      end end 
    end else do
      return decl;
    end end 
  end else do
    return decl;
  end end 
end end

function transl_type_decl(env, rec_flag, sdecl_list) do
  fixed_types = List.filter(is_fixed_type)(sdecl_list);
  sdecl_list$1 = Pervasives.$at(List.map((function (sdecl) do
              ptype_name_txt = sdecl.ptype_name.txt .. "#row";
              ptype_name_loc = sdecl.ptype_name.loc;
              ptype_name = do
                txt: ptype_name_txt,
                loc: ptype_name_loc
              end;
              return do
                      ptype_name: ptype_name,
                      ptype_params: sdecl.ptype_params,
                      ptype_cstrs: sdecl.ptype_cstrs,
                      ptype_kind: --[[ Ptype_abstract ]]0,
                      ptype_private: sdecl.ptype_private,
                      ptype_manifest: undefined,
                      ptype_attributes: sdecl.ptype_attributes,
                      ptype_loc: sdecl.ptype_loc
                    end;
            end end), fixed_types), sdecl_list);
  id_list = List.map((function (sdecl) do
          return create(sdecl.ptype_name.txt);
        end end), sdecl_list$1);
  init_def(currentstamp.contents);
  begin_def(--[[ () ]]0);
  temp_env = rec_flag and List.fold_left2(enter_type$1, env, sdecl_list$1, id_list) or env;
  current_slot = do
    contents: undefined
  end;
  warn_unused = is_active(--[[ Unused_type_declaration ]]Block.__(18, {""}));
  id_slots = function (id) do
    if (rec_flag and warn_unused) then do
      slot = do
        contents: --[[ [] ]]0
      end;
      td = find_type_full(--[[ Pident ]]Block.__(0, {id}), temp_env)[0];
      name = id.name;
      set_type_used_callback(name, td, (function (old_callback) do
              match = current_slot.contents;
              if (match ~= undefined) then do
                slot$1 = match;
                slot$1.contents = --[[ :: ]]{
                  --[[ tuple ]]{
                    name,
                    td
                  },
                  slot$1.contents
                };
                return --[[ () ]]0;
              end else do
                List.iter((function (param) do
                        return mark_type_used(env, param[0], param[1]);
                      end end), get_ref(slot));
                return Curry._1(old_callback, --[[ () ]]0);
              end end 
            end end));
      return --[[ tuple ]]{
              id,
              slot
            };
    end else do
      return --[[ tuple ]]{
              id,
              undefined
            };
    end end 
  end end;
  transl_declaration = function (name_sdecl, param) do
    current_slot.contents = param[1];
    env = temp_env;
    sdecl = name_sdecl;
    id = param[0];
    reset_type_variables(--[[ () ]]0);
    begin_def(--[[ () ]]0);
    tparams = make_params(env, sdecl.ptype_params);
    params = List.map((function (param) do
            return param[0].ctyp_type;
          end end), tparams);
    cstrs = List.map((function (param) do
            return --[[ tuple ]]{
                    transl_simple_type(env, false, param[0]),
                    transl_simple_type(env, false, param[1]),
                    param[2]
                  };
          end end), sdecl.ptype_cstrs);
    match = sdecl.ptype_kind;
    match$1;
    if (typeof match == "number") then do
      match$1 = match == --[[ Ptype_abstract ]]0 and --[[ tuple ]]{
          --[[ Ttype_abstract ]]0,
          --[[ Type_abstract ]]0
        } or --[[ tuple ]]{
          --[[ Ttype_open ]]1,
          --[[ Type_open ]]1
        };
    end else if (match.tag) then do
      lbls = match[0];
      if (lbls == --[[ [] ]]0) then do
        ill_formed_ast(sdecl.ptype_loc, "Records cannot be empty.");
      end
       end 
      all_labels = do
        contents: --[[ Empty ]]0
      end;
      List.iter((function (param) do
              name = param.pld_name.txt;
              if (mem$6(name, all_labels.contents)) then do
                throw {
                      __Error$8,
                      sdecl.ptype_loc,
                      --[[ Duplicate_label ]]Block.__(1, {name})
                    };
              end
               end 
              all_labels.contents = add$12(name, all_labels.contents);
              return --[[ () ]]0;
            end end), lbls);
      lbls$1 = List.map((function (param) do
              name = param.pld_name;
              arg = force_poly(param.pld_type);
              cty = transl_simple_type(env, true, arg);
              return do
                      ld_id: create(name.txt),
                      ld_name: name,
                      ld_mutable: param.pld_mutable,
                      ld_type: cty,
                      ld_loc: param.pld_loc,
                      ld_attributes: param.pld_attributes
                    end;
            end end), lbls);
      lbls$prime = List.map((function (ld) do
              ty = ld.ld_type.ctyp_type;
              match = ty.desc;
              ty$1;
              ty$1 = typeof match == "number" or not (match.tag == --[[ Tpoly ]]10 and not match[1]) and ty or match[0];
              return do
                      ld_id: ld.ld_id,
                      ld_mutable: ld.ld_mutable,
                      ld_type: ty$1,
                      ld_loc: ld.ld_loc,
                      ld_attributes: ld.ld_attributes
                    end;
            end end), lbls$1);
      rep = List.for_all((function (l) do
              env$1 = env;
              ty = l.ld_type;
              match = repr(expand_head_opt(env$1, ty));
              match$1 = match.desc;
              if (typeof match$1 == "number" or match$1.tag ~= --[[ Tconstr ]]3) then do
                return false;
              end else do
                return same(match$1[0], path_float);
              end end 
            end end), lbls$prime) and --[[ Record_float ]]1 or --[[ Record_regular ]]0;
      match$1 = --[[ tuple ]]{
        --[[ Ttype_record ]]Block.__(1, {lbls$1}),
        --[[ Type_record ]]Block.__(0, {
            lbls$prime,
            rep
          })
      };
    end else do
      scstrs = match[0];
      if (scstrs == --[[ [] ]]0) then do
        ill_formed_ast(sdecl.ptype_loc, "Variant types cannot be empty.");
      end
       end 
      all_constrs = do
        contents: --[[ Empty ]]0
      end;
      List.iter((function (param) do
              name = param.pcd_name.txt;
              if (mem$6(name, all_constrs.contents)) then do
                throw {
                      __Error$8,
                      sdecl.ptype_loc,
                      --[[ Duplicate_constructor ]]Block.__(0, {name})
                    };
              end
               end 
              all_constrs.contents = add$12(name, all_constrs.contents);
              return --[[ () ]]0;
            end end), scstrs);
      if (List.length(List.filter((function (cd) do
                      return cd.pcd_args ~= --[[ [] ]]0;
                    end end))(scstrs)) > 246) then do
        throw {
              __Error$8,
              sdecl.ptype_loc,
              --[[ Too_many_constructors ]]1
            };
      end
       end 
      make_cstr = function (scstr) do
        name = create(scstr.pcd_name.txt);
        match = make_constructor(env, --[[ Pident ]]Block.__(0, {id}), params, scstr.pcd_args, scstr.pcd_res);
        tcstr_cd_name = scstr.pcd_name;
        tcstr_cd_args = match[0];
        tcstr_cd_res = match[1];
        tcstr_cd_loc = scstr.pcd_loc;
        tcstr_cd_attributes = scstr.pcd_attributes;
        tcstr = do
          cd_id: name,
          cd_name: tcstr_cd_name,
          cd_args: tcstr_cd_args,
          cd_res: tcstr_cd_res,
          cd_loc: tcstr_cd_loc,
          cd_attributes: tcstr_cd_attributes
        end;
        cstr_cd_args = match[2];
        cstr_cd_res = match[3];
        cstr_cd_loc = scstr.pcd_loc;
        cstr_cd_attributes = scstr.pcd_attributes;
        cstr = do
          cd_id: name,
          cd_args: cstr_cd_args,
          cd_res: cstr_cd_res,
          cd_loc: cstr_cd_loc,
          cd_attributes: cstr_cd_attributes
        end;
        return --[[ tuple ]]{
                tcstr,
                cstr
              };
      end end;
      match$2 = List.split(List.map(make_cstr, scstrs));
      match$1 = --[[ tuple ]]{
        --[[ Ttype_variant ]]Block.__(0, {match$2[0]}),
        --[[ Type_variant ]]Block.__(1, {match$2[1]})
      };
    end end  end 
    match$3 = sdecl.ptype_manifest;
    match$4;
    if (match$3 ~= undefined) then do
      no_row = not is_fixed_type(sdecl);
      cty = transl_simple_type(env, no_row, match$3);
      match$4 = --[[ tuple ]]{
        cty,
        cty.ctyp_type
      };
    end else do
      match$4 = --[[ tuple ]]{
        undefined,
        undefined
      };
    end end 
    man = match$4[1];
    decl_type_arity = List.length(params);
    decl_type_kind = match$1[1];
    decl_type_private = sdecl.ptype_private;
    decl_type_variance = List.map((function (param) do
            return Types_Variance.full;
          end end), params);
    decl_type_loc = sdecl.ptype_loc;
    decl_type_attributes = sdecl.ptype_attributes;
    decl = do
      type_params: params,
      type_arity: decl_type_arity,
      type_kind: decl_type_kind,
      type_private: decl_type_private,
      type_manifest: man,
      type_variance: decl_type_variance,
      type_newtype_level: undefined,
      type_loc: decl_type_loc,
      type_attributes: decl_type_attributes
    end;
    List.iter((function (param) do
            ty = param[0].ctyp_type;
            ty$prime = param[1].ctyp_type;
            try do
              return unify$2(env, ty, ty$prime);
            end
            catch (raw_exn)do
              exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn[0] == Unify) then do
                throw {
                      __Error$8,
                      param[2],
                      --[[ Inconsistent_constraint ]]Block.__(6, {
                          env,
                          exn[1]
                        })
                    };
              end
               end 
              throw exn;
            end
          end end), cstrs);
    end_def(--[[ () ]]0);
    if (is_fixed_type(sdecl)) then do
      match$5;
      try do
        match$5 = lookup_type$1(--[[ Lident ]]Block.__(0, {id.name .. "#row"}), env);
      end
      catch (exn)do
        if (exn == Caml_builtin_exceptions.not_found) then do
          throw {
                Caml_builtin_exceptions.assert_failure,
                --[[ tuple ]]{
                  "typedecl.ml",
                  301,
                  26
                }
              };
        end
         end 
        throw exn;
      end
      set_fixed_row(env, sdecl.ptype_loc, match$5[0], decl);
    end
     end 
    if (man ~= undefined and cyclic_abbrev(env, id, man)) then do
      throw {
            __Error$8,
            sdecl.ptype_loc,
            --[[ Recursive_abbrev ]]Block.__(2, {sdecl.ptype_name.txt})
          };
    end
     end 
    return do
            typ_id: id,
            typ_name: sdecl.ptype_name,
            typ_params: tparams,
            typ_type: decl,
            typ_cstrs: cstrs,
            typ_kind: match$1[0],
            typ_private: sdecl.ptype_private,
            typ_manifest: match$4[0],
            typ_loc: sdecl.ptype_loc,
            typ_attributes: sdecl.ptype_attributes
          end;
  end end;
  tdecls = List.map2(transl_declaration, sdecl_list$1, List.map(id_slots, id_list));
  decls = List.map((function (tdecl) do
          return --[[ tuple ]]{
                  tdecl.typ_id,
                  tdecl.typ_type
                };
        end end), tdecls);
  current_slot.contents = undefined;
  check_duplicates(sdecl_list$1);
  newenv = List.fold_right((function (param, env) do
          return add_type$1(true, param[0], param[1], env);
        end end), decls, env);
  if (rec_flag) then do
    List.iter2((function (id, sdecl) do
            temp_env$1 = temp_env;
            env = newenv;
            id$1 = id;
            loc = sdecl.ptype_loc;
            path = --[[ Pident ]]Block.__(0, {id$1});
            decl = find_type_full(path, temp_env$1)[0];
            match = decl.type_manifest;
            if (match ~= undefined) then do
              params = List.map((function (param) do
                      return newvar(undefined, --[[ () ]]0);
                    end end), decl.type_params);
              try do
                return unify$2(env, newconstr(path, params), match);
              end
              catch (raw_exn)do
                exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                if (exn[0] == Unify) then do
                  throw {
                        __Error$8,
                        loc,
                        --[[ Type_clash ]]Block.__(7, {
                            env,
                            exn[1]
                          })
                      };
                end
                 end 
                throw exn;
              end
            end else do
              return --[[ () ]]0;
            end end 
          end end), id_list, sdecl_list$1);
  end
   end 
  end_def(--[[ () ]]0);
  List.iter((function (param) do
          return generalize_decl(param[1]);
        end end), decls);
  id_loc_list = List.map2((function (id, sdecl) do
          return --[[ tuple ]]{
                  id,
                  sdecl.ptype_loc
                };
        end end), id_list, sdecl_list$1);
  List.iter((function (param) do
          id = param[0];
          env = newenv;
          loc = List.assoc(id, id_loc_list);
          path = --[[ Pident ]]Block.__(0, {id});
          decl = param[1];
          if (decl.type_manifest == undefined) then do
            return --[[ () ]]0;
          end else do
            args = List.map((function (param) do
                    return newvar(undefined, --[[ () ]]0);
                  end end), decl.type_params);
            return check_well_founded(env, loc, path, (function (param) do
                          return same(path, param);
                        end end), newconstr(path, args));
          end end 
        end end), decls);
  to_check = function (param) do
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ = 0--[[ Pident ]] then do
          return List.mem_assoc(param[0], id_loc_list);end end end 
       if ___conditional___ = 1--[[ Pdot ]]
       or ___conditional___ = 2--[[ Papply ]] then do
          return false;end end end 
       do
      
    end
  end end;
  List.iter((function (param) do
          id = param[0];
          return check_well_founded_decl(newenv, List.assoc(id, id_loc_list), --[[ Pident ]]Block.__(0, {id}), param[1], to_check);
        end end), decls);
  List.iter((function (param) do
          env = newenv;
          id_loc_list$1 = id_loc_list;
          to_check$1 = to_check;
          tdecl = param;
          decl = tdecl.typ_type;
          id = tdecl.typ_id;
          return check_recursion(env, List.assoc(id, id_loc_list$1), --[[ Pident ]]Block.__(0, {id}), decl, to_check$1);
        end end), tdecls);
  List.iter2((function (sdecl, tdecl) do
          decl = tdecl.typ_type;
          match = closed_type_decl(decl);
          if (match ~= undefined) then do
            throw {
                  __Error$8,
                  sdecl.ptype_loc,
                  --[[ Unbound_type_var ]]Block.__(9, {
                      match,
                      decl
                    })
                };
          end else do
            return --[[ () ]]0;
          end end 
        end end), sdecl_list$1, tdecls);
  List.iter2((function (param, param$1) do
          env = newenv;
          sdecl = param;
          param$2 = param$1;
          decl = param$2[1];
          visited = do
            contents: --[[ Empty ]]0
          end;
          match = decl.type_kind;
          if (typeof match == "number") then do
            match == --[[ Type_abstract ]]0;
          end else if (match.tag) then do
            find_pl = function (param) do
              if (typeof param == "number") then do
                throw {
                      Caml_builtin_exceptions.assert_failure,
                      --[[ tuple ]]{
                        "typedecl.ml",
                        382,
                        58
                      }
                    };
              end else if (param.tag) then do
                throw {
                      Caml_builtin_exceptions.assert_failure,
                      --[[ tuple ]]{
                        "typedecl.ml",
                        382,
                        58
                      }
                    };
              end else do
                return param[0];
              end end  end 
            end end;
            pl = find_pl(sdecl.ptype_kind);
            foldf = function (acc, x) do
              return add$13(x.pcd_name.txt, x, acc);
            end end;
            pl_index = List.fold_left(foldf, --[[ Empty ]]0, pl);
            List.iter((function (param) do
                    ret_type = param.cd_res;
                    match;
                    try do
                      match = find$6(param.cd_id.name, pl_index);
                    end
                    catch (exn)do
                      if (exn == Caml_builtin_exceptions.not_found) then do
                        throw {
                              Caml_builtin_exceptions.assert_failure,
                              --[[ tuple ]]{
                                "typedecl.ml",
                                395,
                                30
                              }
                            };
                      end
                       end 
                      throw exn;
                    end
                    sret_type = match.pcd_res;
                    List.iter2((function (sty, ty) do
                            return check_constraints_rec(env, sty.ptyp_loc, visited, ty);
                          end end), match.pcd_args, param.cd_args);
                    if (sret_type ~= undefined and ret_type ~= undefined) then do
                      return check_constraints_rec(env, sret_type.ptyp_loc, visited, ret_type);
                    end else do
                      return --[[ () ]]0;
                    end end 
                  end end), match[0]);
          end else do
            find_pl$1 = function (param) do
              if (typeof param == "number") then do
                throw {
                      Caml_builtin_exceptions.assert_failure,
                      --[[ tuple ]]{
                        "typedecl.ml",
                        409,
                        59
                      }
                    };
              end else if (param.tag == --[[ Ptype_record ]]1) then do
                return param[0];
              end else do
                throw {
                      Caml_builtin_exceptions.assert_failure,
                      --[[ tuple ]]{
                        "typedecl.ml",
                        409,
                        59
                      }
                    };
              end end  end 
            end end;
            pl$1 = find_pl$1(sdecl.ptype_kind);
            get_loc = function (name, _param) do
              while(true) do
                param = _param;
                if (param) then do
                  pld = param[0];
                  if (name == pld.pld_name.txt) then do
                    return pld.pld_type.ptyp_loc;
                  end else do
                    _param = param[1];
                    continue ;
                  end end 
                end else do
                  throw {
                        Caml_builtin_exceptions.assert_failure,
                        --[[ tuple ]]{
                          "typedecl.ml",
                          413,
                          16
                        }
                      };
                end end 
              end;
            end end;
            List.iter((function (param) do
                    return check_constraints_rec(env, get_loc(param.ld_id.name, pl$1), visited, param.ld_type);
                  end end), match[0]);
          end end  end 
          match$1 = decl.type_manifest;
          if (match$1 ~= undefined) then do
            match$2 = sdecl.ptype_manifest;
            sty;
            if (match$2 ~= undefined) then do
              sty = match$2;
            end else do
              throw {
                    Caml_builtin_exceptions.assert_failure,
                    --[[ tuple ]]{
                      "typedecl.ml",
                      428,
                      63
                    }
                  };
            end end 
            return check_constraints_rec(env, sty.ptyp_loc, visited, match$1);
          end else do
            return --[[ () ]]0;
          end end 
        end end), sdecl_list$1, decls);
  decls$1 = List.map2((function (sdecl, param) do
          id = param[0];
          return --[[ tuple ]]{
                  id,
                  name_recursion(sdecl, id, param[1])
                };
        end end), sdecl_list$1, decls);
  required = List.map((function (sdecl) do
          return --[[ tuple ]]{
                  add_injectivity(List.map((function (prim) do
                              return prim[1];
                            end end), sdecl.ptype_params)),
                  sdecl.ptype_loc
                };
        end end), sdecl_list$1);
  match = compute_variance_fixpoint(env, decls$1, required, List.map(init_variance, decls$1));
  final_env = match[1];
  final_decls = match[0];
  List.iter2((function (param, param$1) do
          env = final_env;
          sdecl = param;
          param$2 = param$1;
          return check_coherence(env, sdecl.ptype_loc, param$2[0], param$2[1]);
        end end), sdecl_list$1, final_decls);
  final_decls$1 = List.map2((function (tdecl, param) do
          return do
                  typ_id: tdecl.typ_id,
                  typ_name: tdecl.typ_name,
                  typ_params: tdecl.typ_params,
                  typ_type: param[1],
                  typ_cstrs: tdecl.typ_cstrs,
                  typ_kind: tdecl.typ_kind,
                  typ_private: tdecl.typ_private,
                  typ_manifest: tdecl.typ_manifest,
                  typ_loc: tdecl.typ_loc,
                  typ_attributes: tdecl.typ_attributes
                end;
        end end), tdecls, final_decls);
  return --[[ tuple ]]{
          final_decls$1,
          final_env
        };
end end

function transl_extension_constructor(env, check_open, type_path, type_params, typext_params, priv, sext) do
  id = create(sext.pext_name.txt);
  match = sext.pext_kind;
  match$1;
  if (match.tag) then do
    lid = match[0];
    cdescr = find_constructor(env, sext.pext_loc, lid.txt);
    usage = cdescr.cstr_private == --[[ Private ]]0 or priv == --[[ Public ]]1 and --[[ Positive ]]0 or --[[ Privatize ]]2;
    mark_constructor(usage, env, last$1(lid.txt), cdescr);
    match$2 = instance_constructor(undefined, cdescr);
    args = match$2[0];
    match$3;
    if (cdescr.cstr_generalized) then do
      params = instance_list(env, type_params);
      res = newconstr(type_path, params);
      ret_type = newconstr(type_path, params);
      match$3 = --[[ tuple ]]{
        res,
        ret_type
      };
    end else do
      match$3 = --[[ tuple ]]{
        newconstr(type_path, typext_params),
        undefined
      };
    end end 
    try do
      unify$2(env, match$2[1], match$3[0]);
    end
    catch (raw_exn)do
      exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] == Unify) then do
        throw {
              __Error$8,
              lid.loc,
              --[[ Rebind_wrong_type ]]Block.__(13, {
                  lid.txt,
                  env,
                  exn[1]
                })
            };
      end
       end 
      throw exn;
    end
    if (not cdescr.cstr_generalized) then do
      vars = free_variables$1(undefined, newty2(100000000, --[[ Ttuple ]]Block.__(2, {args})));
      List.iter((function (ty) do
              match = ty.desc;
              if (typeof match == "number" or match.tag) then do
                return --[[ () ]]0;
              end else do
                match$1 = match[0];
                if (match$1 ~= undefined and match$1 == "_" and List.memq(ty, vars)) then do
                  ty.desc = --[[ Tvar ]]Block.__(0, {undefined});
                  return --[[ () ]]0;
                end else do
                  return --[[ () ]]0;
                end end 
              end end 
            end end), typext_params);
    end
     end 
    match$4 = cdescr.cstr_res.desc;
    match$5;
    if (typeof match$4 == "number") then do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "typedecl.ml",
              1162,
              17
            }
          };
    end else if (match$4.tag == --[[ Tconstr ]]3) then do
      p = match$4[0];
      decl = find_type_full(p, env)[0];
      match$5 = --[[ tuple ]]{
        p,
        decl.type_params
      };
    end else do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "typedecl.ml",
              1162,
              17
            }
          };
    end end  end 
    cstr_type_params = match$5[1];
    cstr_type_path = match$5[0];
    cstr_types_000 = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
            cstr_type_path,
            cstr_type_params,
            do
              contents: --[[ Mnil ]]0
            end
          }));
    cstr_types = --[[ :: ]]{
      cstr_types_000,
      cstr_type_params
    };
    ext_types_000 = newty2(100000000, --[[ Tconstr ]]Block.__(3, {
            type_path,
            type_params,
            do
              contents: --[[ Mnil ]]0
            end
          }));
    ext_types = --[[ :: ]]{
      ext_types_000,
      type_params
    };
    if (not equal$4(env, true, cstr_types, ext_types)) then do
      throw {
            __Error$8,
            lid.loc,
            --[[ Rebind_mismatch ]]Block.__(14, {
                lid.txt,
                cstr_type_path,
                type_path
              })
          };
    end
     end 
    match$6 = cdescr.cstr_private;
    if (not match$6 and priv) then do
      throw {
            __Error$8,
            lid.loc,
            --[[ Rebind_private ]]Block.__(15, {lid.txt})
          };
    end
     end 
    match$7 = cdescr.cstr_tag;
    path;
    local ___conditional___=(match$7.tag | 0);
    do
       if ___conditional___ = 0--[[ Cstr_constant ]]
       or ___conditional___ = 1--[[ Cstr_block ]] then do
          throw {
                Caml_builtin_exceptions.assert_failure,
                --[[ tuple ]]{
                  "typedecl.ml",
                  1187,
                  17
                }
              };end end end 
       if ___conditional___ = 2--[[ Cstr_extension ]] then do
          path = match$7[0];end else 
       do end
      
    end
    match$1 = --[[ tuple ]]{
      args,
      match$3[1],
      --[[ Text_rebind ]]Block.__(1, {
          path,
          lid
        })
    };
  end else do
    match$8 = make_constructor(env, type_path, typext_params, match[0], match[1]);
    match$1 = --[[ tuple ]]{
      match$8[2],
      match$8[3],
      --[[ Text_decl ]]Block.__(0, {
          match$8[0],
          match$8[1]
        })
    };
  end end 
  ext_ext_args = match$1[0];
  ext_ext_ret_type = match$1[1];
  ext_ext_loc = sext.pext_loc;
  ext_ext_attributes = sext.pext_attributes;
  ext = do
    ext_type_path: type_path,
    ext_type_params: typext_params,
    ext_args: ext_ext_args,
    ext_ret_type: ext_ext_ret_type,
    ext_private: priv,
    ext_loc: ext_ext_loc,
    ext_attributes: ext_ext_attributes
  end;
  return do
          ext_id: id,
          ext_name: sext.pext_name,
          ext_type: ext,
          ext_kind: match$1[2],
          ext_loc: sext.pext_loc,
          ext_attributes: sext.pext_attributes
        end;
end end

function transl_type_extension(check_open, env, loc, styext) do
  reset_type_variables(--[[ () ]]0);
  begin_def(--[[ () ]]0);
  match = find_type(env, loc, styext.ptyext_path.txt);
  type_decl = match[1];
  type_path = match[0];
  match$1 = type_decl.type_kind;
  if (typeof match$1 == "number") then do
    if (match$1 == 0 and check_open) then do
      try do
        match$2 = List.find((function (param) do
                if (param.pext_kind.tag) then do
                  return false;
                end else do
                  return true;
                end end 
              end end), styext.ptyext_constructors);
        throw {
              __Error$8,
              match$2.pext_loc,
              --[[ Not_open_type ]]Block.__(10, {type_path})
            };
      end
      catch (exn)do
        if (exn ~= Caml_builtin_exceptions.not_found) then do
          throw exn;
        end
         end 
      end
    end
     end 
  end else do
    throw {
          __Error$8,
          loc,
          --[[ Not_extensible_type ]]Block.__(11, {type_path})
        };
  end end 
  type_variance = List.map((function (v) do
          match = Curry._1(Types_Variance.get_upper, v);
          return --[[ tuple ]]{
                  not match[1],
                  not match[0],
                  false
                };
        end end), type_decl.type_variance);
  err = type_decl.type_arity ~= List.length(styext.ptyext_params) and --[[ :: ]]{
      --[[ Arity ]]0,
      --[[ [] ]]0
    } or (
      List.for_all2((function (param, param$1) do
              if (not param$1[0] or param[0]) then do
                if (param$1[1]) then do
                  return param[1];
                end else do
                  return true;
                end end 
              end else do
                return false;
              end end 
            end end), type_variance, add_injectivity(List.map((function (prim) do
                      return prim[1];
                    end end), styext.ptyext_params))) and --[[ [] ]]0 or --[[ :: ]]{
          --[[ Variance ]]5,
          --[[ [] ]]0
        }
    );
  if (err ~= --[[ [] ]]0) then do
    throw {
          __Error$8,
          loc,
          --[[ Extension_mismatch ]]Block.__(12, {
              type_path,
              err
            })
        };
  end
   end 
  ttype_params = make_params(env, styext.ptyext_params);
  type_params = List.map((function (param) do
          return param[0].ctyp_type;
        end end), ttype_params);
  List.iter2((function (param, param$1) do
          return unify_var(env, param, param$1);
        end end), instance_list(env, type_decl.type_params), type_params);
  partial_arg = styext.ptyext_private;
  partial_arg$1 = type_decl.type_params;
  constructors = List.map((function (param) do
          return transl_extension_constructor(env, check_open, type_path, partial_arg$1, type_params, partial_arg, param);
        end end), styext.ptyext_constructors);
  end_def(--[[ () ]]0);
  List.iter(generalize, type_params);
  List.iter((function (ext) do
          List.iter(generalize, ext.ext_type.ext_args);
          return may(generalize, ext.ext_type.ext_ret_type);
        end end), constructors);
  List.iter((function (ext) do
          match = closed_extension_constructor(ext.ext_type);
          if (match ~= undefined) then do
            throw {
                  __Error$8,
                  ext.ext_loc,
                  --[[ Unbound_type_var_ext ]]Block.__(19, {
                      match,
                      ext.ext_type
                    })
                };
          end else do
            return --[[ () ]]0;
          end end 
        end end), constructors);
  List.iter((function (ext) do
          compute_variance_extension(env, true, type_decl, ext.ext_type, --[[ tuple ]]{
                type_variance,
                loc
              });
          return --[[ () ]]0;
        end end), constructors);
  newenv = List.fold_left((function (env, ext) do
          return add_extension(true, ext.ext_id, ext.ext_type, env);
        end end), env, constructors);
  tyext_tyext_txt = styext.ptyext_path;
  tyext_tyext_private = styext.ptyext_private;
  tyext_tyext_attributes = styext.ptyext_attributes;
  tyext = do
    tyext_path: type_path,
    tyext_txt: tyext_tyext_txt,
    tyext_params: ttype_params,
    tyext_constructors: constructors,
    tyext_private: tyext_tyext_private,
    tyext_attributes: tyext_tyext_attributes
  end;
  return --[[ tuple ]]{
          tyext,
          newenv
        };
end end

function transl_exception(env, sext) do
  reset_type_variables(--[[ () ]]0);
  begin_def(--[[ () ]]0);
  ext = transl_extension_constructor(env, false, path_exn, --[[ [] ]]0, --[[ [] ]]0, --[[ Public ]]1, sext);
  end_def(--[[ () ]]0);
  List.iter(generalize, ext.ext_type.ext_args);
  may(generalize, ext.ext_type.ext_ret_type);
  match = closed_extension_constructor(ext.ext_type);
  if (match ~= undefined) then do
    throw {
          __Error$8,
          ext.ext_loc,
          --[[ Unbound_type_var_ext ]]Block.__(19, {
              match,
              ext.ext_type
            })
        };
  end
   end 
  newenv = add_extension(true, ext.ext_id, ext.ext_type, env);
  return --[[ tuple ]]{
          ext,
          newenv
        };
end end

function customize_arity(arity, pval_attributes) do
  cur_arity = do
    contents: arity
  end;
  List.iter((function (x) do
          if (x[0].txt == "internal.arity") then do
            match = x[1];
            local ___conditional___=(match.tag | 0);
            do
               if ___conditional___ = 0--[[ PStr ]] then do
                  match$1 = match[0];
                  if (match$1) then do
                    match$2 = match$1[0].pstr_desc;
                    if (match$2.tag) then do
                      return --[[ () ]]0;
                    end else do
                      match$3 = match$2[0].pexp_desc;
                      if (match$3.tag == --[[ Pexp_constant ]]1) then do
                        match$4 = match$3[0];
                        if (match$4.tag or match$1[1]) then do
                          return --[[ () ]]0;
                        end else do
                          i = match$4[0];
                          if (i < cur_arity.contents) then do
                            cur_arity.contents = i;
                            return --[[ () ]]0;
                          end else do
                            return 0;
                          end end 
                        end end 
                      end else do
                        return --[[ () ]]0;
                      end end 
                    end end 
                  end else do
                    return --[[ () ]]0;
                  end end end end end 
               if ___conditional___ = 1--[[ PTyp ]]
               or ___conditional___ = 2--[[ PPat ]] then do
                  return --[[ () ]]0;end end end 
               do
              
            end
          end else do
            return --[[ () ]]0;
          end end 
        end end), pval_attributes);
  return cur_arity.contents;
end end

function transl_value_decl(env, loc, valdecl) do
  cty = transl_type_scheme(env, valdecl.pval_type);
  ty = cty.ctyp_type;
  decl = valdecl.pval_prim;
  v;
  if (decl) then do
    arity$1 = customize_arity(arity(ty), valdecl.pval_attributes);
    prim = parse_declaration(arity$1, decl);
    prim_native_name = prim.prim_native_name;
    if (arity$1 == 0 and not (#prim_native_name > 3 and prim_native_name[0] == "B" and prim_native_name[1] == "S" and prim_native_name[2] == ":") and (#prim.prim_name == 0 or Caml_string.get(prim.prim_name, 0) ~= --[[ "%" ]]37 and Caml_string.get(prim.prim_name, 0) ~= --[[ "#" ]]35)) then do
      throw {
            __Error$8,
            valdecl.pval_type.ptyp_loc,
            --[[ Null_arity_external ]]2
          };
    end
     end 
    if (native_code.contents and prim.prim_arity > 5 and prim_native_name == "") then do
      throw {
            __Error$8,
            valdecl.pval_type.ptyp_loc,
            --[[ Missing_native_external ]]3
          };
    end
     end 
    v = do
      val_type: ty,
      val_kind: --[[ Val_prim ]]Block.__(0, {prim}),
      val_loc: loc,
      val_attributes: valdecl.pval_attributes
    end;
  end else do
    v = do
      val_type: ty,
      val_kind: --[[ Val_reg ]]0,
      val_loc: loc,
      val_attributes: valdecl.pval_attributes
    end;
  end end 
  match = enter_value((function (s) do
            return --[[ Unused_value_declaration ]]Block.__(16, {s});
          end end))(valdecl.pval_name.txt, v, env);
  desc_val_id = match[0];
  desc_val_name = valdecl.pval_name;
  desc_val_prim = valdecl.pval_prim;
  desc_val_loc = valdecl.pval_loc;
  desc_val_attributes = valdecl.pval_attributes;
  desc = do
    val_id: desc_val_id,
    val_name: desc_val_name,
    val_desc: cty,
    val_val: v,
    val_prim: desc_val_prim,
    val_loc: desc_val_loc,
    val_attributes: desc_val_attributes
  end;
  return --[[ tuple ]]{
          desc,
          match[1]
        };
end end

function transl_with_constraint(env, id, row_path, orig_decl, sdecl) do
  mark_type_used(env, id.name, orig_decl);
  reset_type_variables(--[[ () ]]0);
  begin_def(--[[ () ]]0);
  tparams = make_params(env, sdecl.ptype_params);
  params = List.map((function (param) do
          return param[0].ctyp_type;
        end end), tparams);
  orig_decl$1 = instance_declaration(orig_decl);
  arity_ok = List.length(params) == orig_decl$1.type_arity;
  if (arity_ok) then do
    List.iter2((function (param, param$1) do
            return unify_var(env, param, param$1);
          end end), params, orig_decl$1.type_params);
  end
   end 
  constraints = List.map((function (param) do
          loc = param[2];
          try do
            cty = transl_simple_type(env, false, param[0]);
            cty$prime = transl_simple_type(env, false, param[1]);
            ty = cty.ctyp_type;
            ty$prime = cty$prime.ctyp_type;
            unify$2(env, ty, ty$prime);
            return --[[ tuple ]]{
                    cty,
                    cty$prime,
                    loc
                  };
          end
          catch (raw_exn)do
            exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn[0] == Unify) then do
              throw {
                    __Error$8,
                    loc,
                    --[[ Inconsistent_constraint ]]Block.__(6, {
                        env,
                        exn[1]
                      })
                  };
            end
             end 
            throw exn;
          end
        end end), sdecl.ptype_cstrs);
  no_row = not is_fixed_type(sdecl);
  match = sdecl.ptype_manifest;
  match$1;
  if (match ~= undefined) then do
    cty = transl_simple_type(env, no_row, match);
    match$1 = --[[ tuple ]]{
      cty,
      cty.ctyp_type
    };
  end else do
    match$1 = --[[ tuple ]]{
      undefined,
      undefined
    };
  end end 
  man = match$1[1];
  priv = sdecl.ptype_private == --[[ Private ]]0 and --[[ Private ]]0 or (
      arity_ok and orig_decl$1.type_kind ~= --[[ Type_abstract ]]0 and orig_decl$1.type_private or sdecl.ptype_private
    );
  if (arity_ok and orig_decl$1.type_kind ~= --[[ Type_abstract ]]0 and sdecl.ptype_private == --[[ Private ]]0) then do
    prerr_warning(sdecl.ptype_loc, --[[ Deprecated ]]Block.__(0, {"spurious use of private"}));
  end
   end 
  decl_type_arity = List.length(params);
  decl_type_kind = arity_ok and man ~= undefined and orig_decl$1.type_kind or --[[ Type_abstract ]]0;
  decl_type_loc = sdecl.ptype_loc;
  decl_type_attributes = sdecl.ptype_attributes;
  decl = do
    type_params: params,
    type_arity: decl_type_arity,
    type_kind: decl_type_kind,
    type_private: priv,
    type_manifest: man,
    type_variance: --[[ [] ]]0,
    type_newtype_level: undefined,
    type_loc: decl_type_loc,
    type_attributes: decl_type_attributes
  end;
  if (row_path ~= undefined) then do
    set_fixed_row(env, sdecl.ptype_loc, row_path, decl);
  end
   end 
  match$2 = closed_type_decl(decl);
  if (match$2 ~= undefined) then do
    throw {
          __Error$8,
          sdecl.ptype_loc,
          --[[ Unbound_type_var ]]Block.__(9, {
              match$2,
              decl
            })
        };
  end
   end 
  decl$1 = name_recursion(sdecl, id, decl);
  decl_type_params = decl$1.type_params;
  decl_type_arity$1 = decl$1.type_arity;
  decl_type_kind$1 = decl$1.type_kind;
  decl_type_private = decl$1.type_private;
  decl_type_manifest = decl$1.type_manifest;
  decl_type_variance = compute_variance_decl(env, false, decl$1, --[[ tuple ]]{
        add_injectivity(List.map((function (prim) do
                    return prim[1];
                  end end), sdecl.ptype_params)),
        sdecl.ptype_loc
      });
  decl_type_newtype_level = decl$1.type_newtype_level;
  decl_type_loc$1 = decl$1.type_loc;
  decl_type_attributes$1 = decl$1.type_attributes;
  decl$2 = do
    type_params: decl_type_params,
    type_arity: decl_type_arity$1,
    type_kind: decl_type_kind$1,
    type_private: decl_type_private,
    type_manifest: decl_type_manifest,
    type_variance: decl_type_variance,
    type_newtype_level: decl_type_newtype_level,
    type_loc: decl_type_loc$1,
    type_attributes: decl_type_attributes$1
  end;
  end_def(--[[ () ]]0);
  generalize_decl(decl$2);
  return do
          typ_id: id,
          typ_name: sdecl.ptype_name,
          typ_params: tparams,
          typ_type: decl$2,
          typ_cstrs: constraints,
          typ_kind: --[[ Ttype_abstract ]]0,
          typ_private: sdecl.ptype_private,
          typ_manifest: match$1[0],
          typ_loc: sdecl.ptype_loc,
          typ_attributes: sdecl.ptype_attributes
        end;
end end

function abstract_type_decl(arity) do
  make_params = function (n) do
    if (n <= 0) then do
      return --[[ [] ]]0;
    end else do
      return --[[ :: ]]{
              newvar(undefined, --[[ () ]]0),
              make_params(n - 1 | 0)
            };
    end end 
  end end;
  begin_def(--[[ () ]]0);
  decl_type_params = make_params(arity);
  decl_type_variance = replicate_list(Types_Variance.full, arity);
  decl = do
    type_params: decl_type_params,
    type_arity: arity,
    type_kind: --[[ Type_abstract ]]0,
    type_private: --[[ Public ]]1,
    type_manifest: undefined,
    type_variance: decl_type_variance,
    type_newtype_level: undefined,
    type_loc: none,
    type_attributes: --[[ [] ]]0
  end;
  end_def(--[[ () ]]0);
  generalize_decl(decl);
  return decl;
end end

function approx_type_decl(env, sdecl_list) do
  return List.map((function (sdecl) do
                return --[[ tuple ]]{
                        create(sdecl.ptype_name.txt),
                        abstract_type_decl(List.length(sdecl.ptype_params))
                      };
              end end), sdecl_list);
end end

function explain_unbound(ppf, tv, tl, typ, kwd, lab) do
  try do
    ti = List.find((function (ti) do
            return deep_occur(tv, Curry._1(typ, ti));
          end end), tl);
    ty0 = newty2(100000000, --[[ Tobject ]]Block.__(4, {
            tv,
            do
              contents: undefined
            end
          }));
    reset_and_mark_loops_list(--[[ :: ]]{
          Curry._1(typ, ti),
          --[[ :: ]]{
            ty0,
            --[[ [] ]]0
          }
        });
    return Curry._6(Format.fprintf(ppf, --[[ Format ]]{
                    --[[ Char_literal ]]Block.__(12, {
                        --[[ "." ]]46,
                        --[[ Formatting_lit ]]Block.__(17, {
                            --[[ Flush_newline ]]4,
                            --[[ Formatting_gen ]]Block.__(18, {
                                --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                      --[[ String_literal ]]Block.__(11, {
                                          "<hov2>",
                                          --[[ End_of_format ]]0
                                        }),
                                      "<hov2>"
                                    }}),
                                --[[ String_literal ]]Block.__(11, {
                                    "In ",
                                    --[[ String ]]Block.__(2, {
                                        --[[ No_padding ]]0,
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ String ]]Block.__(2, {
                                                --[[ No_padding ]]0,
                                                --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                        --[[ Break ]]Block.__(0, {
                                                            "@;<1 -2>",
                                                            1,
                                                            -2
                                                          }),
                                                        --[[ String_literal ]]Block.__(11, {
                                                            "the variable ",
                                                            --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                                                    " is unbound",
                                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                                        --[[ Close_box ]]0,
                                                                        --[[ End_of_format ]]0
                                                                      })
                                                                  })})
                                                          })
                                                      })})
                                              })
                                          })
                                      })
                                  })
                              })
                          })
                      }),
                    ".@.@[<hov2>In %s@ %s%a@;<1 -2>the variable %a is unbound@]"
                  }), kwd, Curry._1(lab, ti), type_expr$1, Curry._1(typ, ti), type_expr$1, tv);
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      return --[[ () ]]0;
    end else do
      throw exn;
    end end 
  end
end end

function report_error$5(ppf, param) do
  if (typeof param == "number") then do
    local ___conditional___=(param);
    do
       if ___conditional___ = 0--[[ Repeated_parameter ]] then do
          return Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "A type parameter occurs several times",
                          --[[ End_of_format ]]0
                        }),
                      "A type parameter occurs several times"
                    });end end end 
       if ___conditional___ = 1--[[ Too_many_constructors ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "Too many non-constant constructors",
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ String_literal ]]Block.__(11, {
                                          "-- maximum is ",
                                          --[[ Int ]]Block.__(4, {
                                              --[[ Int_i ]]3,
                                              --[[ No_padding ]]0,
                                              --[[ No_precision ]]0,
                                              --[[ Char_literal ]]Block.__(12, {
                                                  --[[ " " ]]32,
                                                  --[[ String ]]Block.__(2, {
                                                      --[[ No_padding ]]0,
                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                          --[[ Close_box ]]0,
                                                          --[[ End_of_format ]]0
                                                        })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[Too many non-constant constructors@ -- maximum is %i %s@]"
                        }), 246, "non-constant constructors");end end end 
       if ___conditional___ = 2--[[ Null_arity_external ]] then do
          return Format.fprintf(ppf, --[[ Format ]]{
                      --[[ String_literal ]]Block.__(11, {
                          "External identifiers must be functions",
                          --[[ End_of_format ]]0
                        }),
                      "External identifiers must be functions"
                    });end end end 
       if ___conditional___ = 3--[[ Missing_native_external ]] then do
          return Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Formatting_gen ]]Block.__(18, {
                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                --[[ String_literal ]]Block.__(11, {
                                    "<hv>",
                                    --[[ End_of_format ]]0
                                  }),
                                "<hv>"
                              }}),
                          --[[ String_literal ]]Block.__(11, {
                              "An external function with more than 5 arguments requires a second stub function",
                              --[[ Formatting_lit ]]Block.__(17, {
                                  --[[ Break ]]Block.__(0, {
                                      "@ ",
                                      1,
                                      0
                                    }),
                                  --[[ String_literal ]]Block.__(11, {
                                      "for native-code compilation",
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Close_box ]]0,
                                          --[[ End_of_format ]]0
                                        })
                                    })
                                })
                            })
                        }),
                      "@[<hv>An external function with more than 5 arguments requires a second stub function@ for native-code compilation@]"
                    });end end end 
       if ___conditional___ = 4--[[ Varying_anonymous ]] then do
          return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ String ]]Block.__(2, {
                                          --[[ No_padding ]]0,
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@ ",
                                                  1,
                                                  0
                                                }),
                                              --[[ String ]]Block.__(2, {
                                                  --[[ No_padding ]]0,
                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Close_box ]]0,
                                                      --[[ End_of_format ]]0
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[%s@ %s@ %s@]"
                        }), "In this GADT definition,", "the variance of some parameter", "cannot be checked");end end end 
       do
      
    end
  end else do
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ = 0--[[ Duplicate_constructor ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "Two constructors are named ",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ End_of_format ]]0
                                })
                            }),
                          "Two constructors are named %s"
                        }), param[0]);end end end 
       if ___conditional___ = 1--[[ Duplicate_label ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "Two labels are named ",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ End_of_format ]]0
                                })
                            }),
                          "Two labels are named %s"
                        }), param[0]);end end end 
       if ___conditional___ = 2--[[ Recursive_abbrev ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "The type abbreviation ",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ String_literal ]]Block.__(11, {
                                      " is cyclic",
                                      --[[ End_of_format ]]0
                                    })
                                })
                            }),
                          "The type abbreviation %s is cyclic"
                        }), param[0]);end end end 
       if ___conditional___ = 3--[[ Cycle_in_def ]] then do
          ty = param[1];
          reset(--[[ () ]]0);
          mark_loops(ty);
          return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<v>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<v>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "The definition of ",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ String_literal ]]Block.__(11, {
                                          " contains a cycle:",
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@ ",
                                                  1,
                                                  0
                                                }),
                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Close_box ]]0,
                                                      --[[ End_of_format ]]0
                                                    })})
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[<v>The definition of %s contains a cycle:@ %a@]"
                        }), param[0], type_expr$1, ty);end end end 
       if ___conditional___ = 4--[[ Definition_mismatch ]] then do
          ty$1 = param[0];
          reset(--[[ () ]]0);
          mark_loops(ty$1);
          return Curry._6(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<v>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<v>"
                                  }}),
                              --[[ Formatting_gen ]]Block.__(18, {
                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                        --[[ String_literal ]]Block.__(11, {
                                            "<hov>",
                                            --[[ End_of_format ]]0
                                          }),
                                        "<hov>"
                                      }}),
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ String ]]Block.__(2, {
                                              --[[ No_padding ]]0,
                                              --[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Break ]]Block.__(0, {
                                                      "@;<1 2>",
                                                      1,
                                                      2
                                                    }),
                                                  --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                          --[[ Close_box ]]0,
                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                  --[[ Close_box ]]0,
                                                                  --[[ End_of_format ]]0
                                                                })})
                                                        })})
                                                })
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[<v>@[<hov>%s@ %s@;<1 2>%a@]%a@]"
                        }), "This variant or record definition", "does not match that of type", type_expr$1, ty$1, (function (param) do
                        return report_type_mismatch("the original", "this", "definition", param);
                      end end), param[1]);end end end 
       if ___conditional___ = 5--[[ Constraint_failed ]] then do
          ty$prime = param[1];
          ty$2 = param[0];
          reset(--[[ () ]]0);
          mark_loops(ty$2);
          mark_loops(ty$prime);
          return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ Formatting_gen ]]Block.__(18, {
                                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                --[[ String_literal ]]Block.__(11, {
                                                    "<hv>",
                                                    --[[ End_of_format ]]0
                                                  }),
                                                "<hv>"
                                              }}),
                                          --[[ String_literal ]]Block.__(11, {
                                              "Type",
                                              --[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Break ]]Block.__(0, {
                                                      "@ ",
                                                      1,
                                                      0
                                                    }),
                                                  --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                          --[[ Break ]]Block.__(0, {
                                                              "@ ",
                                                              1,
                                                              0
                                                            }),
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "should be an instance of",
                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                  --[[ Break ]]Block.__(0, {
                                                                      "@ ",
                                                                      1,
                                                                      0
                                                                    }),
                                                                  --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Close_box ]]0,
                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Close_box ]]0,
                                                                              --[[ End_of_format ]]0
                                                                            })
                                                                        })})
                                                                })
                                                            })
                                                        })})
                                                })
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[%s@ @[<hv>Type@ %a@ should be an instance of@ %a@]@]"
                        }), "Constraints are not satisfied in this type.", type_expr$1, ty$2, type_expr$1, ty$prime);end end end 
       if ___conditional___ = 6--[[ Inconsistent_constraint ]] then do
          Format.fprintf(ppf, --[[ Format ]]{
                --[[ String_literal ]]Block.__(11, {
                    "The type constraints are not consistent.",
                    --[[ Formatting_lit ]]Block.__(17, {
                        --[[ Flush_newline ]]4,
                        --[[ End_of_format ]]0
                      })
                  }),
                "The type constraints are not consistent.@."
              });
          return report_unification_error(ppf, param[0], undefined, param[1], (function (ppf) do
                        return Format.fprintf(ppf, --[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "Type",
                                        --[[ End_of_format ]]0
                                      }),
                                    "Type"
                                  });
                      end end), (function (ppf) do
                        return Format.fprintf(ppf, --[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "is not compatible with type",
                                        --[[ End_of_format ]]0
                                      }),
                                    "is not compatible with type"
                                  });
                      end end));end end end 
       if ___conditional___ = 7--[[ Type_clash ]] then do
          return report_unification_error(ppf, param[0], undefined, param[1], (function (ppf) do
                        return Format.fprintf(ppf, --[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "This type constructor expands to type",
                                        --[[ End_of_format ]]0
                                      }),
                                    "This type constructor expands to type"
                                  });
                      end end), (function (ppf) do
                        return Format.fprintf(ppf, --[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "but is used here with type",
                                        --[[ End_of_format ]]0
                                      }),
                                    "but is used here with type"
                                  });
                      end end));end end end 
       if ___conditional___ = 8--[[ Parameters_differ ]] then do
          ty$prime$1 = param[2];
          ty$3 = param[1];
          reset(--[[ () ]]0);
          mark_loops(ty$3);
          mark_loops(ty$prime$1);
          return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<hv>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<hv>"
                                  }}),
                              --[[ String_literal ]]Block.__(11, {
                                  "In the definition of ",
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ String_literal ]]Block.__(11, {
                                          ", type",
                                          --[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@ ",
                                                  1,
                                                  0
                                                }),
                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Break ]]Block.__(0, {
                                                          "@ ",
                                                          1,
                                                          0
                                                        }),
                                                      --[[ String_literal ]]Block.__(11, {
                                                          "should be",
                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Break ]]Block.__(0, {
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                }),
                                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Close_box ]]0,
                                                                      --[[ End_of_format ]]0
                                                                    })})
                                                            })
                                                        })
                                                    })})
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[<hv>In the definition of %s, type@ %a@ should be@ %a@]"
                        }), name(undefined, param[0]), type_expr$1, ty$3, type_expr$1, ty$prime$1);end end end 
       if ___conditional___ = 9--[[ Unbound_type_var ]] then do
          decl = param[1];
          Format.fprintf(ppf, --[[ Format ]]{
                --[[ String_literal ]]Block.__(11, {
                    "A type variable is unbound in this type declaration",
                    --[[ End_of_format ]]0
                  }),
                "A type variable is unbound in this type declaration"
              });
          ty$4 = repr(param[0]);
          match = decl.type_kind;
          match$1 = decl.type_manifest;
          if (typeof match == "number") then do
            if (match == --[[ Type_abstract ]]0 and match$1 ~= undefined) then do
              ppf$1 = ppf;
              tv = ty$4;
              ty$5 = match$1;
              trivial = function (ty) do
                return explain_unbound(ppf$1, tv, --[[ :: ]]{
                            ty,
                            --[[ [] ]]0
                          }, (function (t) do
                              return t;
                            end end), "type", (function (param) do
                              return "";
                            end end));
              end end;
              match$2 = repr(ty$5).desc;
              if (typeof match$2 == "number") then do
                return trivial(ty$5);
              end else do
                local ___conditional___=(match$2.tag | 0);
                do
                   if ___conditional___ = 4--[[ Tobject ]] then do
                      match$3 = flatten_fields(match$2[0]);
                      if (match$3[1] == tv) then do
                        return trivial(ty$5);
                      end else do
                        return explain_unbound(ppf$1, tv, match$3[0], (function (param) do
                                      return param[2];
                                    end end), "method", (function (param) do
                                      return param[0] .. ": ";
                                    end end));
                      end end end end end 
                   if ___conditional___ = 8--[[ Tvariant ]] then do
                      row = row_repr_aux(--[[ [] ]]0, match$2[0]);
                      if (row.row_more == tv) then do
                        return trivial(ty$5);
                      end else do
                        return explain_unbound(ppf$1, tv, row.row_fields, (function (param) do
                                      match = row_field_repr_aux(--[[ [] ]]0, param[1]);
                                      if (typeof match == "number") then do
                                        return newty2(100000000, --[[ Ttuple ]]Block.__(2, {--[[ [] ]]0}));
                                      end else if (match.tag) then do
                                        tl = match[1];
                                        if (tl and not tl[1]) then do
                                          return tl[0];
                                        end else do
                                          return newty2(100000000, --[[ Ttuple ]]Block.__(2, {tl}));
                                        end end 
                                      end else do
                                        match$1 = match[0];
                                        if (match$1 ~= undefined) then do
                                          return match$1;
                                        end else do
                                          return newty2(100000000, --[[ Ttuple ]]Block.__(2, {--[[ [] ]]0}));
                                        end end 
                                      end end  end 
                                    end end), "case", (function (param) do
                                      return "`" .. (param[0] .. " of ");
                                    end end));
                      end end end end end 
                   do
                  else do
                    return trivial(ty$5);
                    end end
                    
                end
              end end 
            end else do
              return --[[ () ]]0;
            end end 
          end else if (match.tag) then do
            return explain_unbound(ppf, ty$4, match[0], (function (c) do
                          return newty2(100000000, --[[ Ttuple ]]Block.__(2, {c.cd_args}));
                        end end), "case", (function (c) do
                          return c.cd_id.name .. " of ";
                        end end));
          end else do
            return explain_unbound(ppf, ty$4, match[0], (function (l) do
                          return l.ld_type;
                        end end), "field", (function (l) do
                          return l.ld_id.name .. ": ";
                        end end));
          end end  end end end end 
       if ___conditional___ = 10--[[ Not_open_type ]] then do
          return Curry._3(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Close_box ]]0,
                                              --[[ End_of_format ]]0
                                            })})
                                    })
                                })
                            }),
                          "@[%s@ %a@]"
                        }), "Cannot extend type definition", path, param[0]);end end end 
       if ___conditional___ = 11--[[ Not_extensible_type ]] then do
          return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@ ",
                                                  1,
                                                  0
                                                }),
                                              --[[ String ]]Block.__(2, {
                                                  --[[ No_padding ]]0,
                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Close_box ]]0,
                                                      --[[ End_of_format ]]0
                                                    })
                                                })
                                            })})
                                    })
                                })
                            }),
                          "@[%s@ %a@ %s@]"
                        }), "Type", path, param[0], "is not extensible");end end end 
       if ___conditional___ = 12--[[ Extension_mismatch ]] then do
          return Curry._5(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "<v>",
                                        --[[ End_of_format ]]0
                                      }),
                                    "<v>"
                                  }}),
                              --[[ Formatting_gen ]]Block.__(18, {
                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                        --[[ String_literal ]]Block.__(11, {
                                            "<hov>",
                                            --[[ End_of_format ]]0
                                          }),
                                        "<hov>"
                                      }}),
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ String ]]Block.__(2, {
                                              --[[ No_padding ]]0,
                                              --[[ Formatting_lit ]]Block.__(17, {
                                                  --[[ Break ]]Block.__(0, {
                                                      "@;<1 2>",
                                                      1,
                                                      2
                                                    }),
                                                  --[[ String ]]Block.__(2, {
                                                      --[[ No_padding ]]0,
                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                          --[[ Close_box ]]0,
                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                  --[[ Close_box ]]0,
                                                                  --[[ End_of_format ]]0
                                                                })})
                                                        })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            }),
                          "@[<v>@[<hov>%s@ %s@;<1 2>%s@]%a@]"
                        }), "This extension", "does not match the definition of type", name(undefined, param[0]), (function (param) do
                        return report_type_mismatch("the type", "this extension", "definition", param);
                      end end), param[1]);end end end 
       if ___conditional___ = 13--[[ Rebind_wrong_type ]] then do
          lid = param[0];
          return report_unification_error(ppf, param[1], undefined, param[2], (function (ppf) do
                        return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                        --[[ String_literal ]]Block.__(11, {
                                            "The constructor ",
                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                    --[[ Break ]]Block.__(0, {
                                                        "@ ",
                                                        1,
                                                        0
                                                      }),
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "has type",
                                                        --[[ End_of_format ]]0
                                                      })
                                                  })})
                                          }),
                                        "The constructor %a@ has type"
                                      }), longident, lid);
                      end end), (function (ppf) do
                        return Format.fprintf(ppf, --[[ Format ]]{
                                    --[[ String_literal ]]Block.__(11, {
                                        "but was expected to be of type",
                                        --[[ End_of_format ]]0
                                      }),
                                    "but was expected to be of type"
                                  });
                      end end));end end end 
       if ___conditional___ = 14--[[ Rebind_mismatch ]] then do
          return Curry._8(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@ ",
                                                  1,
                                                  0
                                                }),
                                              --[[ String ]]Block.__(2, {
                                                  --[[ No_padding ]]0,
                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Break ]]Block.__(0, {
                                                          "@ ",
                                                          1,
                                                          0
                                                        }),
                                                      --[[ String ]]Block.__(2, {
                                                          --[[ No_padding ]]0,
                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                              --[[ Break ]]Block.__(0, {
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                }),
                                                              --[[ String ]]Block.__(2, {
                                                                  --[[ No_padding ]]0,
                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Break ]]Block.__(0, {
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        }),
                                                                      --[[ String ]]Block.__(2, {
                                                                          --[[ No_padding ]]0,
                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Break ]]Block.__(0, {
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                }),
                                                                              --[[ String ]]Block.__(2, {
                                                                                  --[[ No_padding ]]0,
                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Close_box ]]0,
                                                                                      --[[ End_of_format ]]0
                                                                                    })
                                                                                })
                                                                            })
                                                                        })
                                                                    })
                                                                })
                                                            })
                                                        })
                                                    })
                                                })
                                            })})
                                    })
                                })
                            }),
                          "@[%s@ %a@ %s@ %s@ %s@ %s@ %s@]"
                        }), "The constructor", longident, param[0], "extends type", name(undefined, param[1]), "whose declaration does not match", "the declaration of type", name(undefined, param[2]));end end end 
       if ___conditional___ = 15--[[ Rebind_private ]] then do
          return Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ Formatting_gen ]]Block.__(18, {
                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                    --[[ End_of_format ]]0,
                                    ""
                                  }}),
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                              --[[ Break ]]Block.__(0, {
                                                  "@ ",
                                                  1,
                                                  0
                                                }),
                                              --[[ String ]]Block.__(2, {
                                                  --[[ No_padding ]]0,
                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                      --[[ Close_box ]]0,
                                                      --[[ End_of_format ]]0
                                                    })
                                                })
                                            })})
                                    })
                                })
                            }),
                          "@[%s@ %a@ %s@]"
                        }), "The constructor", longident, param[0], "is private");end end end 
       if ___conditional___ = 16--[[ Bad_variance ]] then do
          n = param[0];
          variance = function (param) do
            n = param[1];
            inj = param[2] and "injective " or "";
            if (param[0]) then do
              if (n) then do
                return inj .. "invariant";
              end else do
                return inj .. "covariant";
              end end 
            end else if (n) then do
              return inj .. "contravariant";
            end else if (inj == "") then do
              return "unrestricted";
            end else do
              return inj;
            end end  end  end 
          end end;
          suffix = function (n) do
            teen = (n % 100 / 10 | 0) == 1;
            match = n % 10;
            local ___conditional___=(match);
            do
               if ___conditional___ = 1 then do
                  if (teen) then do
                    return "th";
                  end else do
                    return "st";
                  end end end end end 
               if ___conditional___ = 2 then do
                  if (teen) then do
                    return "th";
                  end else do
                    return "nd";
                  end end end end end 
               if ___conditional___ = 3 then do
                  if (teen) then do
                    return "th";
                  end else do
                    return "rd";
                  end end end end end 
               do
              else do
                return "th";
                end end
                
            end
          end end;
          if (n == -1) then do
            Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Formatting_gen ]]Block.__(18, {
                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                --[[ End_of_format ]]0,
                                ""
                              }}),
                          --[[ String ]]Block.__(2, {
                              --[[ No_padding ]]0,
                              --[[ Formatting_lit ]]Block.__(17, {
                                  --[[ Break ]]Block.__(0, {
                                      "@ ",
                                      1,
                                      0
                                    }),
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ String_literal ]]Block.__(11, {
                                              "It",
                                              --[[ End_of_format ]]0
                                            })
                                        })
                                    })
                                })
                            })
                        }),
                      "@[%s@ %s@ It"
                    }), "In this definition, a type variable has a variance that", "is not reflected by its occurrence in type parameters.");
          end else if (n == -2) then do
            Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Formatting_gen ]]Block.__(18, {
                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                --[[ End_of_format ]]0,
                                ""
                              }}),
                          --[[ String ]]Block.__(2, {
                              --[[ No_padding ]]0,
                              --[[ Formatting_lit ]]Block.__(17, {
                                  --[[ Break ]]Block.__(0, {
                                      "@ ",
                                      1,
                                      0
                                    }),
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Close_box ]]0,
                                          --[[ End_of_format ]]0
                                        })
                                    })
                                })
                            })
                        }),
                      "@[%s@ %s@]"
                    }), "In this definition, a type variable cannot be deduced", "from the type parameters.");
          end else if (n == -3) then do
            Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Formatting_gen ]]Block.__(18, {
                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                --[[ End_of_format ]]0,
                                ""
                              }}),
                          --[[ String ]]Block.__(2, {
                              --[[ No_padding ]]0,
                              --[[ Formatting_lit ]]Block.__(17, {
                                  --[[ Break ]]Block.__(0, {
                                      "@ ",
                                      1,
                                      0
                                    }),
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ String_literal ]]Block.__(11, {
                                              "It",
                                              --[[ End_of_format ]]0
                                            })
                                        })
                                    })
                                })
                            })
                        }),
                      "@[%s@ %s@ It"
                    }), "In this definition, a type variable has a variance that", "cannot be deduced from the type parameters.");
          end else do
            Curry._4(Format.fprintf(ppf, --[[ Format ]]{
                      --[[ Formatting_gen ]]Block.__(18, {
                          --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                --[[ End_of_format ]]0,
                                ""
                              }}),
                          --[[ String ]]Block.__(2, {
                              --[[ No_padding ]]0,
                              --[[ Formatting_lit ]]Block.__(17, {
                                  --[[ Break ]]Block.__(0, {
                                      "@ ",
                                      1,
                                      0
                                    }),
                                  --[[ String ]]Block.__(2, {
                                      --[[ No_padding ]]0,
                                      --[[ Formatting_lit ]]Block.__(17, {
                                          --[[ Break ]]Block.__(0, {
                                              "@ ",
                                              1,
                                              0
                                            }),
                                          --[[ String_literal ]]Block.__(11, {
                                              "The ",
                                              --[[ Int ]]Block.__(4, {
                                                  --[[ Int_d ]]0,
                                                  --[[ No_padding ]]0,
                                                  --[[ No_precision ]]0,
                                                  --[[ String ]]Block.__(2, {
                                                      --[[ No_padding ]]0,
                                                      --[[ String_literal ]]Block.__(11, {
                                                          " type parameter",
                                                          --[[ End_of_format ]]0
                                                        })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            })
                        }),
                      "@[%s@ %s@ The %d%s type parameter"
                    }), "In this definition, expected parameter", "variances are not satisfied.", n, suffix(n));
          end end  end  end 
          if (n ~= -2) then do
            return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                            --[[ String_literal ]]Block.__(11, {
                                " was expected to be ",
                                --[[ String ]]Block.__(2, {
                                    --[[ No_padding ]]0,
                                    --[[ Char_literal ]]Block.__(12, {
                                        --[[ "," ]]44,
                                        --[[ Formatting_lit ]]Block.__(17, {
                                            --[[ Break ]]Block.__(0, {
                                                "@ ",
                                                1,
                                                0
                                              }),
                                            --[[ String_literal ]]Block.__(11, {
                                                "but it is ",
                                                --[[ String ]]Block.__(2, {
                                                    --[[ No_padding ]]0,
                                                    --[[ Char_literal ]]Block.__(12, {
                                                        --[[ "." ]]46,
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Close_box ]]0,
                                                            --[[ End_of_format ]]0
                                                          })
                                                      })
                                                  })
                                              })
                                          })
                                      })
                                  })
                              }),
                            " was expected to be %s,@ but it is %s.@]"
                          }), variance(param[2]), variance(param[1]));
          end else do
            return 0;
          end end end end end 
       if ___conditional___ = 17--[[ Unavailable_type_constructor ]] then do
          return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "The definition of type ",
                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Break ]]Block.__(0, {
                                          "@ ",
                                          1,
                                          0
                                        }),
                                      --[[ String_literal ]]Block.__(11, {
                                          "is unavailable",
                                          --[[ End_of_format ]]0
                                        })
                                    })})
                            }),
                          "The definition of type %a@ is unavailable"
                        }), path, param[0]);end end end 
       if ___conditional___ = 18--[[ Bad_fixed_type ]] then do
          return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                          --[[ String_literal ]]Block.__(11, {
                              "This fixed type ",
                              --[[ String ]]Block.__(2, {
                                  --[[ No_padding ]]0,
                                  --[[ End_of_format ]]0
                                })
                            }),
                          "This fixed type %s"
                        }), param[0]);end end end 
       if ___conditional___ = 19--[[ Unbound_type_var_ext ]] then do
          Format.fprintf(ppf, --[[ Format ]]{
                --[[ String_literal ]]Block.__(11, {
                    "A type variable is unbound in this extension constructor",
                    --[[ End_of_format ]]0
                  }),
                "A type variable is unbound in this extension constructor"
              });
          return explain_unbound(ppf, param[0], param[1].ext_args, (function (c) do
                        return c;
                      end end), "type", (function (param) do
                        return "";
                      end end));end end end 
       do
      
    end
  end end 
end end

register_error_of_exn((function (param) do
        if (param[0] == __Error$8) then do
          return error_of_printer(param[1], report_error$5, param[2]);
        end
         end 
      end end));

__Error$9 = Caml_exceptions.create("Ocaml_typedtree_test.Typeclass.Error");

Error_forward$2 = Caml_exceptions.create("Ocaml_typedtree_test.Typeclass.Error_forward");

function ctyp(desc, typ, env, loc) do
  return do
          ctyp_desc: desc,
          ctyp_type: typ,
          ctyp_env: env,
          ctyp_loc: loc,
          ctyp_attributes: --[[ [] ]]0
        end;
end end

unbound_class = --[[ Pident ]]Block.__(0, {create("")});

function scrape_class_type(_cty) do
  while(true) do
    cty = _cty;
    local ___conditional___=(cty.tag | 0);
    do
       if ___conditional___ = 0--[[ Cty_constr ]] then do
          _cty = cty[2];
          continue ;end end end 
       if ___conditional___ = 1--[[ Cty_signature ]]
       or ___conditional___ = 2--[[ Cty_arrow ]] then do
          return cty;end end end 
       do
      
    end
  end;
end end

function generalize_class_type(gen, _param) do
  while(true) do
    param = _param;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ = 0--[[ Cty_constr ]] then do
          List.iter(gen, param[1]);
          _param = param[2];
          continue ;end end end 
       if ___conditional___ = 1--[[ Cty_signature ]] then do
          match = param[0];
          Curry._1(gen, match.csig_self);
          iter$1((function (param, param$1) do
                  return Curry._1(gen, param$1[2]);
                end end), match.csig_vars);
          return List.iter((function (param) do
                        return List.iter(gen, param[1]);
                      end end), match.csig_inher);end end end 
       if ___conditional___ = 2--[[ Cty_arrow ]] then do
          Curry._1(gen, param[1]);
          _param = param[2];
          continue ;end end end 
       do
      
    end
  end;
end end

function virtual_methods(sign) do
  match = flatten_fields(object_fields(sign.csig_self));
  return List.fold_left((function (virt, param) do
                lab = param[0];
                if (lab == dummy_method or mem$2(lab, sign.csig_concr)) then do
                  return virt;
                end else do
                  return --[[ :: ]]{
                          lab,
                          virt
                        };
                end end 
              end end), --[[ [] ]]0, match[0]);
end end

function constructor_type(constr, _cty) do
  while(true) do
    cty = _cty;
    local ___conditional___=(cty.tag | 0);
    do
       if ___conditional___ = 0--[[ Cty_constr ]] then do
          _cty = cty[2];
          continue ;end end end 
       if ___conditional___ = 1--[[ Cty_signature ]] then do
          return constr;end end end 
       if ___conditional___ = 2--[[ Cty_arrow ]] then do
          desc_000 = cty[0];
          desc_001 = cty[1];
          desc_002 = constructor_type(constr, cty[2]);
          desc = --[[ Tarrow ]]Block.__(1, {
              desc_000,
              desc_001,
              desc_002,
              --[[ Cok ]]0
            });
          return newty2(current_level.contents, desc);end end end 
       do
      
    end
  end;
end end

function class_body(_cty) do
  while(true) do
    cty = _cty;
    local ___conditional___=(cty.tag | 0);
    do
       if ___conditional___ = 0--[[ Cty_constr ]]
       or ___conditional___ = 1--[[ Cty_signature ]] then do
          return cty;end end end 
       if ___conditional___ = 2--[[ Cty_arrow ]] then do
          _cty = cty[2];
          continue ;end end end 
       do
      
    end
  end;
end end

function extract_constraints(cty) do
  sign = signature_of_class_type(cty);
  match = flatten_fields(object_fields(sign.csig_self));
  return --[[ tuple ]]{
          fold((function (lab, param, vars) do
                  return --[[ :: ]]{
                          lab,
                          vars
                        };
                end end), sign.csig_vars, --[[ [] ]]0),
          List.fold_left((function (meths, param) do
                  lab = param[0];
                  if (lab == dummy_method) then do
                    return meths;
                  end else do
                    return --[[ :: ]]{
                            lab,
                            meths
                          };
                  end end 
                end end), --[[ [] ]]0, match[0]),
          sign.csig_concr
        };
end end

function abbreviate_class_type(path, params, cty) do
  local ___conditional___=(cty.tag | 0);
  do
     if ___conditional___ = 0--[[ Cty_constr ]]
     or ___conditional___ = 1--[[ Cty_signature ]] then do
        return --[[ Cty_constr ]]Block.__(0, {
                  path,
                  params,
                  cty
                });end end end 
     if ___conditional___ = 2--[[ Cty_arrow ]] then do
        return --[[ Cty_arrow ]]Block.__(2, {
                  cty[0],
                  cty[1],
                  abbreviate_class_type(path, params, cty[2])
                });end end end 
     do
    
  end
end end

function closed_class$1(cty) do
  if (List.for_all(closed_schema, cty.cty_params)) then do
    _param = cty.cty_type;
    while(true) do
      param = _param;
      local ___conditional___=(param.tag | 0);
      do
         if ___conditional___ = 0--[[ Cty_constr ]] then do
            return List.for_all(closed_schema, param[1]);end end end 
         if ___conditional___ = 1--[[ Cty_signature ]] then do
            sign = param[0];
            if (closed_schema(sign.csig_self)) then do
              return fold((function (param, param$1, cc) do
                            if (closed_schema(param$1[2])) then do
                              return cc;
                            end else do
                              return false;
                            end end 
                          end end), sign.csig_vars, true);
            end else do
              return false;
            end end end end end 
         if ___conditional___ = 2--[[ Cty_arrow ]] then do
            if (closed_schema(param[1])) then do
              _param = param[2];
              continue ;
            end else do
              return false;
            end end end end end 
         do
        
      end
    end;
  end else do
    return false;
  end end 
end end

function limited_generalize$1(rv, _param) do
  while(true) do
    param = _param;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ = 0--[[ Cty_constr ]] then do
          List.iter((function (param) do
                  return limited_generalize(rv, param);
                end end), param[1]);
          _param = param[2];
          continue ;end end end 
       if ___conditional___ = 1--[[ Cty_signature ]] then do
          sign = param[0];
          limited_generalize(rv, sign.csig_self);
          iter$1((function (param, param$1) do
                  return limited_generalize(rv, param$1[2]);
                end end), sign.csig_vars);
          return List.iter((function (param) do
                        return List.iter((function (param) do
                                      return limited_generalize(rv, param);
                                    end end), param[1]);
                      end end), sign.csig_inher);end end end 
       if ___conditional___ = 2--[[ Cty_arrow ]] then do
          limited_generalize(rv, param[1]);
          _param = param[2];
          continue ;end end end 
       do
      
    end
  end;
end end

function rc(node) do
  add_saved_type(--[[ Partial_class_expr ]]Block.__(4, {node}));
  record$2(--[[ Ti_class ]]Block.__(2, {node}));
  return node;
end end

function enter_met_env(check, loc, lab, kind, ty, val_env, met_env, par_env) do
  match = enter_value(undefined)(lab, do
        val_type: ty,
        val_kind: --[[ Val_unbound ]]1,
        val_loc: loc,
        val_attributes: --[[ [] ]]0
      end, val_env);
  id = match[0];
  return --[[ tuple ]]{
          id,
          match[1],
          add_value(check, id, do
                val_type: ty,
                val_kind: kind,
                val_loc: loc,
                val_attributes: --[[ [] ]]0
              end, met_env),
          add_value(undefined, id, do
                val_type: ty,
                val_kind: --[[ Val_unbound ]]1,
                val_loc: loc,
                val_attributes: --[[ [] ]]0
              end, par_env)
        };
end end

function enter_val(cl_num, vars, inh, lab, mut, virt, ty, val_env, met_env, par_env, loc) do
  match;
  try do
    match$1 = find(lab, vars.contents);
    virt$prime = match$1[2];
    if (match$1[1] ~= mut) then do
      throw {
            __Error$9,
            loc,
            val_env,
            --[[ Mutability_mismatch ]]Block.__(22, {
                lab,
                mut
              })
          };
    end
     end 
    unify$2(val_env, instance(undefined, val_env, ty), instance(undefined, val_env, match$1[3]));
    match = --[[ tuple ]]{
      inh and undefined or match$1[0],
      virt$prime == --[[ Concrete ]]1 and virt$prime or virt
    };
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      throw {
            __Error$9,
            loc,
            val_env,
            --[[ Field_type_mismatch ]]Block.__(1, {
                "instance variable",
                lab,
                exn[1]
              })
          };
    end
     end 
    if (exn == Caml_builtin_exceptions.not_found) then do
      match = --[[ tuple ]]{
        undefined,
        virt
      };
    end else do
      throw exn;
    end end 
  end
  id = match[0];
  result = id ~= undefined and --[[ tuple ]]{
      id,
      val_env,
      met_env,
      par_env
    } or enter_met_env(undefined, none, lab, --[[ Val_ivar ]]Block.__(1, {
            mut,
            cl_num
          }), ty, val_env, met_env, par_env);
  vars.contents = add$1(lab, --[[ tuple ]]{
        result[0],
        mut,
        match[1],
        ty
      }, vars.contents);
  return result;
end end

function concr_vals(vars) do
  return fold((function (id, param, s) do
                if (param[1] == --[[ Virtual ]]0) then do
                  return s;
                end else do
                  return add$2(id, s);
                end end 
              end end), vars, --[[ Empty ]]0);
end end

function inheritance(self_type, env, ovf, concr_meths, warn_vals, loc, parent) do
  match = scrape_class_type(parent);
  local ___conditional___=(match.tag | 0);
  do
     if ___conditional___ = 1--[[ Cty_signature ]] then do
        cl_sig = match[0];
        try do
          unify$2(env, self_type, cl_sig.csig_self);
        end
        catch (raw_exn)do
          exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn[0] == Unify) then do
            trace = exn[1];
            exit = 0;
            if (trace) then do
              match$1 = trace[1];
              if (match$1) then do
                match$2 = match$1[1];
                if (match$2) then do
                  match$3 = match$2[1];
                  if (match$3) then do
                    match$4 = match$3[0][0].desc;
                    if (typeof match$4 == "number" or match$4.tag ~= --[[ Tfield ]]5) then do
                      exit = 1;
                    end else do
                      throw {
                            __Error$9,
                            loc,
                            env,
                            --[[ Field_type_mismatch ]]Block.__(1, {
                                "method",
                                match$4[0],
                                match$3[1]
                              })
                          };
                    end end 
                  end else do
                    exit = 1;
                  end end 
                end else do
                  exit = 1;
                end end 
              end else do
                exit = 1;
              end end 
            end else do
              exit = 1;
            end end 
            if (exit == 1) then do
              throw {
                    Caml_builtin_exceptions.assert_failure,
                    --[[ tuple ]]{
                      "typeclass.ml",
                      261,
                      12
                    }
                  };
            end
             end 
          end else do
            throw exn;
          end end 
        end
        over_meths = inter$1(cl_sig.csig_concr, concr_meths);
        concr_vals$1 = concr_vals(cl_sig.csig_vars);
        over_vals = inter$1(concr_vals$1, warn_vals);
        if (ovf ~= undefined) then do
          if (ovf) then do
            cname;
            local ___conditional___=(parent.tag | 0);
            do
               if ___conditional___ = 0--[[ Cty_constr ]] then do
                  cname = name(undefined, parent[0]);end else 
               if ___conditional___ = 1--[[ Cty_signature ]]
               or ___conditional___ = 2--[[ Cty_arrow ]] then do
                  cname = "inherited";end else 
               do end end end
              
            end
            if (not (
                over_meths and false or true
              )) then do
              prerr_warning(loc, --[[ Method_override ]]Block.__(2, {--[[ :: ]]{
                        cname,
                        elements_aux(--[[ [] ]]0, over_meths)
                      }}));
            end
             end 
            if (not (
                over_vals and false or true
              )) then do
              prerr_warning(loc, --[[ Instance_variable_override ]]Block.__(5, {--[[ :: ]]{
                        cname,
                        elements_aux(--[[ [] ]]0, over_vals)
                      }}));
            end
             end 
          end else if ((
              over_meths and false or true
            ) and (
              over_vals and false or true
            )) then do
            throw {
                  __Error$9,
                  loc,
                  env,
                  --[[ No_overriding ]]Block.__(23, {
                      "",
                      ""
                    })
                };
          end
           end  end 
        end
         end 
        concr_meths$1 = union$1(cl_sig.csig_concr, concr_meths);
        warn_vals$1 = union$1(concr_vals$1, warn_vals);
        return --[[ tuple ]]{
                cl_sig,
                concr_meths$1,
                warn_vals$1
              };end end end 
     if ___conditional___ = 0--[[ Cty_constr ]]
     or ___conditional___ = 2--[[ Cty_arrow ]] then do
        throw {
              __Error$9,
              loc,
              env,
              --[[ Structure_expected ]]Block.__(2, {parent})
            };end end end 
     do
    
  end
end end

function virtual_method(val_env, meths, self_type, lab, priv, sty, loc) do
  match = filter_self_method(val_env, lab, priv, meths, self_type);
  sty$1 = force_poly(sty);
  cty = transl_simple_type(val_env, false, sty$1);
  ty = cty.ctyp_type;
  try do
    unify$2(val_env, ty, match[1]);
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      throw {
            __Error$9,
            loc,
            val_env,
            --[[ Field_type_mismatch ]]Block.__(1, {
                "method",
                lab,
                exn[1]
              })
          };
    end
     end 
    throw exn;
  end
  return cty;
end end

delayed_meth_specs = do
  contents: --[[ [] ]]0
end;

function declare_method(val_env, meths, self_type, lab, priv, sty, loc) do
  match = filter_self_method(val_env, lab, priv, meths, self_type);
  ty$prime = match[1];
  unif = function (ty) do
    try do
      return unify$2(val_env, ty, ty$prime);
    end
    catch (raw_exn)do
      exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] == Unify) then do
        throw {
              __Error$9,
              loc,
              val_env,
              --[[ Field_type_mismatch ]]Block.__(1, {
                  "method",
                  lab,
                  exn[1]
                })
            };
      end
       end 
      throw exn;
    end
  end end;
  sty$1 = force_poly(sty);
  match$1 = sty$1.ptyp_desc;
  if (typeof match$1 ~= "number" and match$1.tag == --[[ Ptyp_poly ]]8 and not match$1[0] and priv) then do
    sty$prime = match$1[1];
    returned_cty = ctyp(--[[ Ttyp_any ]]0, newty2(current_level.contents, --[[ Tnil ]]0), val_env, loc);
    delayed_meth_specs.contents = --[[ :: ]]{
      Caml_obj.caml_lazy_make((function (param) do
              cty = transl_simple_type_univars(val_env, sty$prime);
              ty = cty.ctyp_type;
              unif(ty);
              returned_cty.ctyp_desc = --[[ Ttyp_poly ]]Block.__(8, {
                  --[[ [] ]]0,
                  cty
                });
              returned_cty.ctyp_type = ty;
              return --[[ () ]]0;
            end end)),
      delayed_meth_specs.contents
    };
    return returned_cty;
  end
   end 
  cty = transl_simple_type(val_env, false, sty$1);
  ty = cty.ctyp_type;
  unif(ty);
  return cty;
end end

function type_constraint(val_env, sty, sty$prime, loc) do
  cty = transl_simple_type(val_env, false, sty);
  ty = cty.ctyp_type;
  cty$prime = transl_simple_type(val_env, false, sty$prime);
  ty$prime = cty$prime.ctyp_type;
  try do
    unify$2(val_env, ty, ty$prime);
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      throw {
            __Error$9,
            loc,
            val_env,
            --[[ Unconsistent_constraint ]]Block.__(0, {exn[1]})
          };
    end
     end 
    throw exn;
  end
  return --[[ tuple ]]{
          cty,
          cty$prime
        };
end end

function make_method(loc, cl_num, expr) do
  return Curry._6(Ast_helper_Exp.fun_, expr.pexp_loc, undefined, "", undefined, alias$1(loc, undefined, __var$1(loc, undefined, do
                      txt: "self-*",
                      loc: loc
                    end), do
                  txt: "self-" .. cl_num,
                  loc: loc
                end), expr);
end end

function add_val(env, loc, lab, param, val_sig) do
  virt = param[1];
  virt$1;
  try do
    match = find(lab, val_sig);
    virt$prime = match[1];
    virt$1 = virt$prime == --[[ Concrete ]]1 and virt$prime or virt;
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      virt$1 = virt;
    end else do
      throw exn;
    end end 
  end
  return add$1(lab, --[[ tuple ]]{
              param[0],
              virt$1,
              param[2]
            }, val_sig);
end end

function class_signature$1(env, param) do
  sty = param.pcsig_self;
  meths = do
    contents: --[[ Empty ]]0
  end;
  self_cty = transl_simple_type(env, false, sty);
  self_cty$1 = do
    ctyp_desc: self_cty.ctyp_desc,
    ctyp_type: expand_head(env, self_cty.ctyp_type),
    ctyp_env: self_cty.ctyp_env,
    ctyp_loc: self_cty.ctyp_loc,
    ctyp_attributes: self_cty.ctyp_attributes
  end;
  self_type = self_cty$1.ctyp_type;
  dummy_obj = newvar(undefined, --[[ () ]]0);
  unify$2(env, filter_method(env, dummy_method, --[[ Private ]]0, dummy_obj), newty2(current_level.contents, --[[ Ttuple ]]Block.__(2, {--[[ [] ]]0})));
  try do
    unify$2(env, self_type, dummy_obj);
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      throw {
            __Error$9,
            sty.ptyp_loc,
            env,
            --[[ Pattern_type_clash ]]Block.__(5, {self_type})
          };
    end
     end 
    throw exn;
  end
  warning_enter_scope(--[[ () ]]0);
  match = List.fold_left((function (param, param$1) do
          env$1 = env;
          self_type$1 = self_type;
          meths$1 = meths;
          param$2 = param;
          ctf = param$1;
          inher = param$2[3];
          concr_meths = param$2[2];
          val_sig = param$2[1];
          fields = param$2[0];
          loc = ctf.pctf_loc;
          mkctf = function (desc) do
            return do
                    ctf_desc: desc,
                    ctf_loc: loc,
                    ctf_attributes: ctf.pctf_attributes
                  end;
          end end;
          match = ctf.pctf_desc;
          local ___conditional___=(match.tag | 0);
          do
             if ___conditional___ = 0--[[ Pctf_inherit ]] then do
                sparent = match[0];
                parent = class_type$3(env$1, sparent);
                match$1 = parent.cltyp_type;
                inher$1;
                local ___conditional___=(match$1.tag | 0);
                do
                   if ___conditional___ = 0--[[ Cty_constr ]] then do
                      inher$1 = --[[ :: ]]{
                        --[[ tuple ]]{
                          match$1[0],
                          match$1[1]
                        },
                        inher
                      };end else 
                   if ___conditional___ = 1--[[ Cty_signature ]]
                   or ___conditional___ = 2--[[ Cty_arrow ]] then do
                      inher$1 = inher;end else 
                   do end end end
                  
                end
                match$2 = inheritance(self_type$1, env$1, undefined, concr_meths, --[[ Empty ]]0, sparent.pcty_loc, parent.cltyp_type);
                partial_arg = sparent.pcty_loc;
                val_sig$1 = fold((function (param, param$1, param$2) do
                        return add_val(env$1, partial_arg, param, param$1, param$2);
                      end end), match$2[0].csig_vars, val_sig);
                return --[[ tuple ]]{
                        --[[ :: ]]{
                          mkctf(--[[ Tctf_inherit ]]Block.__(0, {parent})),
                          fields
                        },
                        val_sig$1,
                        match$2[1],
                        inher$1
                      };end end end 
             if ___conditional___ = 1--[[ Pctf_val ]] then do
                match$3 = match[0];
                virt = match$3[2];
                mut = match$3[1];
                lab = match$3[0];
                cty = transl_simple_type(env$1, false, match$3[3]);
                ty = cty.ctyp_type;
                return --[[ tuple ]]{
                        --[[ :: ]]{
                          mkctf(--[[ Tctf_val ]]Block.__(1, {--[[ tuple ]]{
                                    lab,
                                    mut,
                                    virt,
                                    cty
                                  }})),
                          fields
                        },
                        add_val(env$1, ctf.pctf_loc, lab, --[[ tuple ]]{
                              mut,
                              virt,
                              ty
                            }, val_sig),
                        concr_meths,
                        inher
                      };end end end 
             if ___conditional___ = 2--[[ Pctf_method ]] then do
                match$4 = match[0];
                virt$1 = match$4[2];
                priv = match$4[1];
                lab$1 = match$4[0];
                cty$1 = declare_method(env$1, meths$1, self_type$1, lab$1, priv, match$4[3], ctf.pctf_loc);
                concr_meths$1 = virt$1 and add$2(lab$1, concr_meths) or concr_meths;
                return --[[ tuple ]]{
                        --[[ :: ]]{
                          mkctf(--[[ Tctf_method ]]Block.__(2, {--[[ tuple ]]{
                                    lab$1,
                                    priv,
                                    virt$1,
                                    cty$1
                                  }})),
                          fields
                        },
                        val_sig,
                        concr_meths$1,
                        inher
                      };end end end 
             if ___conditional___ = 3--[[ Pctf_constraint ]] then do
                match$5 = match[0];
                match$6 = type_constraint(env$1, match$5[0], match$5[1], ctf.pctf_loc);
                return --[[ tuple ]]{
                        --[[ :: ]]{
                          mkctf(--[[ Tctf_constraint ]]Block.__(3, {--[[ tuple ]]{
                                    match$6[0],
                                    match$6[1]
                                  }})),
                          fields
                        },
                        val_sig,
                        concr_meths,
                        inher
                      };end end end 
             if ___conditional___ = 4--[[ Pctf_attribute ]] then do
                x = match[0];
                warning_attribute(--[[ :: ]]{
                      x,
                      --[[ [] ]]0
                    });
                return --[[ tuple ]]{
                        --[[ :: ]]{
                          mkctf(--[[ Tctf_attribute ]]Block.__(4, {x})),
                          fields
                        },
                        val_sig,
                        concr_meths,
                        inher
                      };end end end 
             if ___conditional___ = 5--[[ Pctf_extension ]] then do
                throw {
                      Error_forward$2,
                      error_of_extension(match[0])
                    };end end end 
             do
            
          end
        end end), --[[ tuple ]]{
        --[[ [] ]]0,
        --[[ Empty ]]0,
        --[[ Empty ]]0,
        --[[ [] ]]0
      }, param.pcsig_fields);
  warning_leave_scope(--[[ () ]]0);
  cty_csig_vars = match[1];
  cty_csig_concr = match[2];
  cty_csig_inher = match[3];
  cty = do
    csig_self: self_type,
    csig_vars: cty_csig_vars,
    csig_concr: cty_csig_concr,
    csig_inher: cty_csig_inher
  end;
  return do
          csig_self: self_cty$1,
          csig_fields: List.rev(match[0]),
          csig_type: cty
        end;
end end

function class_type$3(env, scty) do
  cltyp = function (desc, typ) do
    return do
            cltyp_desc: desc,
            cltyp_type: typ,
            cltyp_env: env,
            cltyp_loc: scty.pcty_loc,
            cltyp_attributes: scty.pcty_attributes
          end;
  end end;
  match = scty.pcty_desc;
  local ___conditional___=(match.tag | 0);
  do
     if ___conditional___ = 0--[[ Pcty_constr ]] then do
        styl = match[1];
        lid = match[0];
        match$1 = find_class_type(env, scty.pcty_loc, lid.txt);
        decl = match$1[1];
        path = match$1[0];
        if (same(decl.clty_path, unbound_class)) then do
          throw {
                __Error$9,
                scty.pcty_loc,
                env,
                --[[ Unbound_class_type_2 ]]Block.__(7, {lid.txt})
              };
        end
         end 
        match$2 = instance_class(decl.clty_params, decl.clty_type);
        params = match$2[0];
        if (List.length(params) ~= List.length(styl)) then do
          throw {
                __Error$9,
                scty.pcty_loc,
                env,
                --[[ Parameter_arity_mismatch ]]Block.__(11, {
                    lid.txt,
                    List.length(params),
                    List.length(styl)
                  })
              };
        end
         end 
        ctys = List.map2((function (sty, ty) do
                cty$prime = transl_simple_type(env, false, sty);
                ty$prime = cty$prime.ctyp_type;
                try do
                  unify$2(env, ty$prime, ty);
                end
                catch (raw_exn)do
                  exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                  if (exn[0] == Unify) then do
                    throw {
                          __Error$9,
                          sty.ptyp_loc,
                          env,
                          --[[ Parameter_mismatch ]]Block.__(12, {exn[1]})
                        };
                  end
                   end 
                  throw exn;
                end
                return cty$prime;
              end end), styl, params);
        typ_002 = match$2[1];
        typ = --[[ Cty_constr ]]Block.__(0, {
            path,
            params,
            typ_002
          });
        return cltyp(--[[ Tcty_constr ]]Block.__(0, {
                      path,
                      lid,
                      ctys
                    }), typ);end end end 
     if ___conditional___ = 1--[[ Pcty_signature ]] then do
        clsig = class_signature$1(env, match[0]);
        typ$1 = --[[ Cty_signature ]]Block.__(1, {clsig.csig_type});
        return cltyp(--[[ Tcty_signature ]]Block.__(1, {clsig}), typ$1);end end end 
     if ___conditional___ = 2--[[ Pcty_arrow ]] then do
        l = match[0];
        cty = transl_simple_type(env, false, match[1]);
        ty = cty.ctyp_type;
        clty = class_type$3(env, match[2]);
        typ_002$1 = clty.cltyp_type;
        typ$2 = --[[ Cty_arrow ]]Block.__(2, {
            l,
            ty,
            typ_002$1
          });
        return cltyp(--[[ Tcty_arrow ]]Block.__(2, {
                      l,
                      cty,
                      clty
                    }), typ$2);end end end 
     if ___conditional___ = 3--[[ Pcty_extension ]] then do
        throw {
              Error_forward$2,
              error_of_extension(match[0])
            };end end end 
     do
    
  end
end end

function class_type$4(env, scty) do
  delayed_meth_specs.contents = --[[ [] ]]0;
  cty = class_type$3(env, scty);
  List.iter(CamlinternalLazy.force, List.rev(delayed_meth_specs.contents));
  delayed_meth_specs.contents = --[[ [] ]]0;
  return cty;
end end

function class_structure(cl_num, __final, val_env, met_env, loc, param) do
  spat = param.pcstr_self;
  init = spat.ppat_loc;
  self_loc_loc_start = init.loc_start;
  self_loc_loc_end = init.loc_end;
  self_loc = do
    loc_start: self_loc_loc_start,
    loc_end: self_loc_loc_end,
    loc_ghost: true
  end;
  self_type = newvar(undefined, --[[ () ]]0);
  unify$2(val_env, filter_method(val_env, dummy_method, --[[ Private ]]0, self_type), newty2(current_level.contents, --[[ Ttuple ]]Block.__(2, {--[[ [] ]]0})));
  private_self = __final and newvar(undefined, --[[ () ]]0) or self_type;
  match = type_self_pattern(cl_num, private_self, val_env, met_env, met_env, spat);
  val_env$1 = match[3];
  vars = match[2];
  meths = match[1];
  pat = match[0];
  public_self = pat.pat_type;
  ty;
  if (__final) then do
    desc_000 = newvar(undefined, --[[ () ]]0);
    desc_001 = do
      contents: undefined
    end;
    desc = --[[ Tobject ]]Block.__(4, {
        desc_000,
        desc_001
      });
    ty = newty2(current_level.contents, desc);
  end else do
    ty = self_type;
  end end 
  try do
    unify$2(val_env$1, public_self, ty);
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == Unify) then do
      throw {
            __Error$9,
            spat.ppat_loc,
            val_env$1,
            --[[ Pattern_type_clash ]]Block.__(5, {public_self})
          };
    end
     end 
    throw exn;
  end
  get_methods = function (ty) do
    return flatten_fields(object_fields(expand_head(val_env$1, ty)))[0];
  end end;
  if (__final) then do
    List.iter((function (param) do
            k = field_kind_repr(param[1]) == --[[ Fpresent ]]0 and --[[ Public ]]1 or --[[ Private ]]0;
            try do
              return unify$2(val_env$1, param[2], filter_method(val_env$1, param[0], k, self_type));
            end
            catch (exn)do
              throw {
                    Caml_builtin_exceptions.assert_failure,
                    --[[ tuple ]]{
                      "typeclass.ml",
                      760,
                      18
                    }
                  };
            end
          end end), get_methods(public_self));
  end
   end 
  warning_enter_scope(--[[ () ]]0);
  match$1 = List.fold_left((function (param, param$1) do
          self_loc$1 = self_loc;
          cl_num$1 = cl_num;
          self_type$1 = self_type;
          meths$1 = meths;
          vars$1 = vars;
          param$2 = param;
          cf = param$1;
          local_vals = param$2[8];
          local_meths = param$2[7];
          inher = param$2[6];
          warn_vals = param$2[5];
          concr_meths = param$2[4];
          fields = param$2[3];
          par_env = param$2[2];
          met_env = param$2[1];
          val_env = param$2[0];
          loc = cf.pcf_loc;
          mkcf = function (desc) do
            return do
                    cf_desc: desc,
                    cf_loc: loc,
                    cf_attributes: cf.pcf_attributes
                  end;
          end end;
          match = cf.pcf_desc;
          local ___conditional___=(match.tag | 0);
          do
             if ___conditional___ = 0--[[ Pcf_inherit ]] then do
                __super = match[2];
                sparent = match[1];
                ovf = match[0];
                parent = class_expr(cl_num$1, val_env, par_env, sparent);
                match$1 = parent.cl_type;
                inher$1;
                local ___conditional___=(match$1.tag | 0);
                do
                   if ___conditional___ = 0--[[ Cty_constr ]] then do
                      inher$1 = --[[ :: ]]{
                        --[[ tuple ]]{
                          match$1[0],
                          match$1[1]
                        },
                        inher
                      };end else 
                   if ___conditional___ = 1--[[ Cty_signature ]]
                   or ___conditional___ = 2--[[ Cty_arrow ]] then do
                      inher$1 = inher;end else 
                   do end end end
                  
                end
                match$2 = inheritance(self_type$1, val_env, ovf, concr_meths, warn_vals, sparent.pcl_loc, parent.cl_type);
                cl_sig = match$2[0];
                match$3 = fold((function (lab, info, param) do
                        match = enter_val(cl_num$1, vars$1, true, lab, info[0], info[1], info[2], param[0], param[1], param[2], sparent.pcl_loc);
                        return --[[ tuple ]]{
                                match[1],
                                match[2],
                                match[3],
                                --[[ :: ]]{
                                  --[[ tuple ]]{
                                    lab,
                                    match[0]
                                  },
                                  param[3]
                                }
                              };
                      end end), cl_sig.csig_vars, --[[ tuple ]]{
                      val_env,
                      met_env,
                      par_env,
                      --[[ [] ]]0
                    });
                inh_vars = match$3[3];
                par_env$1 = match$3[2];
                met_env$1 = match$3[1];
                val_env$1 = match$3[0];
                inh_meths = fold$1((function (lab, rem) do
                        return --[[ :: ]]{
                                --[[ tuple ]]{
                                  lab,
                                  create(lab)
                                },
                                rem
                              };
                      end end), cl_sig.csig_concr, --[[ [] ]]0);
                match$4;
                if (__super ~= undefined) then do
                  match$5 = enter_met_env((function (s) do
                          return --[[ Unused_ancestor ]]Block.__(20, {s});
                        end end), sparent.pcl_loc, __super, --[[ Val_anc ]]Block.__(3, {
                          inh_meths,
                          cl_num$1
                        }), self_type$1, val_env$1, met_env$1, par_env$1);
                  match$4 = --[[ tuple ]]{
                    match$5[1],
                    match$5[2],
                    match$5[3]
                  };
                end else do
                  match$4 = --[[ tuple ]]{
                    val_env$1,
                    met_env$1,
                    par_env$1
                  };
                end end 
                return --[[ tuple ]]{
                        match$4[0],
                        match$4[1],
                        match$4[2],
                        --[[ :: ]]{
                          Caml_obj.caml_lazy_make((function (param) do
                                  return mkcf(--[[ Tcf_inherit ]]Block.__(0, {
                                                ovf,
                                                parent,
                                                __super,
                                                inh_vars,
                                                inh_meths
                                              }));
                                end end)),
                          fields
                        },
                        match$2[1],
                        match$2[2],
                        inher$1,
                        local_meths,
                        local_vals
                      };end end end 
             if ___conditional___ = 1--[[ Pcf_val ]] then do
                match$6 = match[0];
                match$7 = match$6[2];
                mut = match$6[1];
                lab = match$6[0];
                if (match$7.tag) then do
                  ovf$1 = match$7[0];
                  if (mem$2(lab.txt, local_vals)) then do
                    throw {
                          __Error$9,
                          loc,
                          val_env,
                          --[[ Duplicate ]]Block.__(24, {
                              "instance variable",
                              lab.txt
                            })
                        };
                  end
                   end 
                  if (mem$2(lab.txt, warn_vals)) then do
                    if (ovf$1 == --[[ Fresh ]]1) then do
                      prerr_warning(lab.loc, --[[ Instance_variable_override ]]Block.__(5, {--[[ :: ]]{
                                lab.txt,
                                --[[ [] ]]0
                              }}));
                    end
                     end 
                  end else if (ovf$1 == --[[ Override ]]0) then do
                    throw {
                          __Error$9,
                          loc,
                          val_env,
                          --[[ No_overriding ]]Block.__(23, {
                              "instance variable",
                              lab.txt
                            })
                        };
                  end
                   end  end 
                  if (principal.contents) then do
                    begin_def(--[[ () ]]0);
                  end
                   end 
                  exp;
                  try do
                    exp = type_exp(val_env, match$7[1]);
                  end
                  catch (raw_exn)do
                    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn[0] == Unify) then do
                      match$8 = exn[1];
                      if (match$8) then do
                        if (match$8[1]) then do
                          throw exn;
                        end
                         end 
                        throw {
                              __Error$9,
                              loc,
                              val_env,
                              --[[ Make_nongen_seltype ]]Block.__(17, {match$8[0][0]})
                            };
                      end else do
                        throw exn;
                      end end 
                    end else do
                      throw exn;
                    end end 
                  end
                  if (principal.contents) then do
                    end_def(--[[ () ]]0);
                    generalize_structure$1(current_level.contents, exp.exp_type);
                  end
                   end 
                  match$9 = enter_val(cl_num$1, vars$1, false, lab.txt, mut, --[[ Concrete ]]1, exp.exp_type, val_env, met_env, par_env, loc);
                  met_env$prime = match$9[2];
                  id = match$9[0];
                  return --[[ tuple ]]{
                          match$9[1],
                          met_env$prime,
                          match$9[3],
                          --[[ :: ]]{
                            Caml_obj.caml_lazy_make((function (param) do
                                    return mkcf(--[[ Tcf_val ]]Block.__(1, {
                                                  lab,
                                                  mut,
                                                  id,
                                                  --[[ Tcfk_concrete ]]Block.__(1, {
                                                      ovf$1,
                                                      exp
                                                    }),
                                                  met_env == met_env$prime
                                                }));
                                  end end)),
                            fields
                          },
                          concr_meths,
                          add$2(lab.txt, warn_vals),
                          inher,
                          local_meths,
                          add$2(lab.txt, local_vals)
                        };
                end else do
                  if (principal.contents) then do
                    begin_def(--[[ () ]]0);
                  end
                   end 
                  cty = transl_simple_type(val_env, false, match$7[0]);
                  ty = cty.ctyp_type;
                  if (principal.contents) then do
                    end_def(--[[ () ]]0);
                    generalize_structure$1(current_level.contents, ty);
                  end
                   end 
                  match$10 = enter_val(cl_num$1, vars$1, false, lab.txt, mut, --[[ Virtual ]]0, ty, val_env, met_env, par_env, loc);
                  met_env$prime$1 = match$10[2];
                  id$1 = match$10[0];
                  return --[[ tuple ]]{
                          match$10[1],
                          met_env$prime$1,
                          match$10[3],
                          --[[ :: ]]{
                            Caml_obj.caml_lazy_make((function (param) do
                                    return mkcf(--[[ Tcf_val ]]Block.__(1, {
                                                  lab,
                                                  mut,
                                                  id$1,
                                                  --[[ Tcfk_virtual ]]Block.__(0, {cty}),
                                                  met_env == met_env$prime$1
                                                }));
                                  end end)),
                            fields
                          },
                          concr_meths,
                          warn_vals,
                          inher,
                          local_meths,
                          local_vals
                        };
                end end end end end 
             if ___conditional___ = 2--[[ Pcf_method ]] then do
                match$11 = match[0];
                match$12 = match$11[2];
                priv = match$11[1];
                lab$1 = match$11[0];
                if (match$12.tag) then do
                  expr = match$12[1];
                  ovf$2 = match$12[0];
                  match$13 = expr.pexp_desc;
                  expr$1;
                  expr$1 = match$13.tag == --[[ Pexp_poly ]]28 and expr or Curry._4(Ast_helper_Exp.poly, expr.pexp_loc, undefined, expr, undefined);
                  if (mem$2(lab$1.txt, local_meths)) then do
                    throw {
                          __Error$9,
                          loc,
                          val_env,
                          --[[ Duplicate ]]Block.__(24, {
                              "method",
                              lab$1.txt
                            })
                        };
                  end
                   end 
                  if (mem$2(lab$1.txt, concr_meths)) then do
                    if (ovf$2 == --[[ Fresh ]]1) then do
                      prerr_warning(loc, --[[ Method_override ]]Block.__(2, {--[[ :: ]]{
                                lab$1.txt,
                                --[[ [] ]]0
                              }}));
                    end
                     end 
                  end else if (ovf$2 == --[[ Override ]]0) then do
                    throw {
                          __Error$9,
                          loc,
                          val_env,
                          --[[ No_overriding ]]Block.__(23, {
                              "method",
                              lab$1.txt
                            })
                        };
                  end
                   end  end 
                  match$14 = filter_self_method(val_env, lab$1.txt, priv, meths$1, self_type$1);
                  ty$1 = match$14[1];
                  try do
                    match$15 = expr$1.pexp_desc;
                    if (match$15.tag == --[[ Pexp_poly ]]28) then do
                      sty = match$15[1];
                      sbody = match$15[0];
                      if (sty ~= undefined) then do
                        sty$1 = force_poly(sty);
                        cty$prime = transl_simple_type(val_env, false, sty$1);
                        ty$prime = cty$prime.ctyp_type;
                        unify$2(val_env, ty$prime, ty$1);
                      end
                       end 
                      match$16 = repr(ty$1).desc;
                      if (typeof match$16 == "number") then do
                        throw {
                              Caml_builtin_exceptions.assert_failure,
                              --[[ tuple ]]{
                                "typeclass.ml",
                                662,
                                17
                              }
                            };
                      end else do
                        local ___conditional___=(match$16.tag | 0);
                        do
                           if ___conditional___ = 0--[[ Tvar ]] then do
                              ty$prime$1 = newvar(undefined, --[[ () ]]0);
                              unify$2(val_env, newty2(current_level.contents, --[[ Tpoly ]]Block.__(10, {
                                          ty$prime$1,
                                          --[[ [] ]]0
                                        })), ty$1);
                              unify$2(val_env, type_approx(val_env, sbody), ty$prime$1);end else 
                           if ___conditional___ = 10--[[ Tpoly ]] then do
                              match$17 = instance_poly(undefined, false, match$16[1], match$16[0]);
                              ty2 = type_approx(val_env, sbody);
                              unify$2(val_env, ty2, match$17[1]);end else 
                           do end end end
                          else do
                            throw {
                                  Caml_builtin_exceptions.assert_failure,
                                  --[[ tuple ]]{
                                    "typeclass.ml",
                                    662,
                                    17
                                  }
                                };
                            end end
                            
                        end
                      end end 
                    end else do
                      throw {
                            Caml_builtin_exceptions.assert_failure,
                            --[[ tuple ]]{
                              "typeclass.ml",
                              664,
                              13
                            }
                          };
                    end end 
                  end
                  catch (raw_exn$1)do
                    exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
                    if (exn$1[0] == Unify) then do
                      throw {
                            __Error$9,
                            loc,
                            val_env,
                            --[[ Field_type_mismatch ]]Block.__(1, {
                                "method",
                                lab$1.txt,
                                exn$1[1]
                              })
                          };
                    end
                     end 
                    throw exn$1;
                  end
                  meth_expr = make_method(self_loc$1, cl_num$1, expr$1);
                  vars_local = vars$1.contents;
                  field = Caml_obj.caml_lazy_make((function (param) do
                          meth_type = newty2(100000000, --[[ Tarrow ]]Block.__(1, {
                                  "",
                                  self_type$1,
                                  ty$1,
                                  --[[ Cok ]]0
                                }));
                          raise_nongen_level(--[[ () ]]0);
                          vars$1.contents = vars_local;
                          texp = type_expect(undefined, met_env, meth_expr, meth_type);
                          end_def(--[[ () ]]0);
                          return mkcf(--[[ Tcf_method ]]Block.__(2, {
                                        lab$1,
                                        priv,
                                        --[[ Tcfk_concrete ]]Block.__(1, {
                                            ovf$2,
                                            texp
                                          })
                                      }));
                        end end));
                  return --[[ tuple ]]{
                          val_env,
                          met_env,
                          par_env,
                          --[[ :: ]]{
                            field,
                            fields
                          },
                          add$2(lab$1.txt, concr_meths),
                          warn_vals,
                          inher,
                          add$2(lab$1.txt, local_meths),
                          local_vals
                        };
                end else do
                  cty$1 = virtual_method(val_env, meths$1, self_type$1, lab$1.txt, priv, match$12[0], loc);
                  return --[[ tuple ]]{
                          val_env,
                          met_env,
                          par_env,
                          --[[ :: ]]{
                            Caml_obj.caml_lazy_make((function (param) do
                                    return mkcf(--[[ Tcf_method ]]Block.__(2, {
                                                  lab$1,
                                                  priv,
                                                  --[[ Tcfk_virtual ]]Block.__(0, {cty$1})
                                                }));
                                  end end)),
                            fields
                          },
                          concr_meths,
                          warn_vals,
                          inher,
                          local_meths,
                          local_vals
                        };
                end end end end end 
             if ___conditional___ = 3--[[ Pcf_constraint ]] then do
                match$18 = match[0];
                match$19 = type_constraint(val_env, match$18[0], match$18[1], loc);
                cty$prime$1 = match$19[1];
                cty$2 = match$19[0];
                return --[[ tuple ]]{
                        val_env,
                        met_env,
                        par_env,
                        --[[ :: ]]{
                          Caml_obj.caml_lazy_make((function (param) do
                                  return mkcf(--[[ Tcf_constraint ]]Block.__(3, {
                                                cty$2,
                                                cty$prime$1
                                              }));
                                end end)),
                          fields
                        },
                        concr_meths,
                        warn_vals,
                        inher,
                        local_meths,
                        local_vals
                      };end end end 
             if ___conditional___ = 4--[[ Pcf_initializer ]] then do
                expr$2 = make_method(self_loc$1, cl_num$1, match[0]);
                vars_local$1 = vars$1.contents;
                field$1 = Caml_obj.caml_lazy_make((function (param) do
                        raise_nongen_level(--[[ () ]]0);
                        desc_002 = instance_def(type_unit);
                        desc = --[[ Tarrow ]]Block.__(1, {
                            "",
                            self_type$1,
                            desc_002,
                            --[[ Cok ]]0
                          });
                        meth_type = newty2(current_level.contents, desc);
                        vars$1.contents = vars_local$1;
                        texp = type_expect(undefined, met_env, expr$2, meth_type);
                        end_def(--[[ () ]]0);
                        return mkcf(--[[ Tcf_initializer ]]Block.__(4, {texp}));
                      end end));
                return --[[ tuple ]]{
                        val_env,
                        met_env,
                        par_env,
                        --[[ :: ]]{
                          field$1,
                          fields
                        },
                        concr_meths,
                        warn_vals,
                        inher,
                        local_meths,
                        local_vals
                      };end end end 
             if ___conditional___ = 5--[[ Pcf_attribute ]] then do
                x = match[0];
                warning_attribute(--[[ :: ]]{
                      x,
                      --[[ [] ]]0
                    });
                return --[[ tuple ]]{
                        val_env,
                        met_env,
                        par_env,
                        --[[ :: ]]{
                          Caml_obj.caml_lazy_make((function (param) do
                                  return mkcf(--[[ Tcf_attribute ]]Block.__(5, {x}));
                                end end)),
                          fields
                        },
                        concr_meths,
                        warn_vals,
                        inher,
                        local_meths,
                        local_vals
                      };end end end 
             if ___conditional___ = 6--[[ Pcf_extension ]] then do
                throw {
                      Error_forward$2,
                      error_of_extension(match[0])
                    };end end end 
             do
            
          end
        end end), --[[ tuple ]]{
        val_env$1,
        match[4],
        match[5],
        --[[ [] ]]0,
        --[[ Empty ]]0,
        --[[ Empty ]]0,
        --[[ [] ]]0,
        --[[ Empty ]]0,
        --[[ Empty ]]0
      }, param.pcstr_fields);
  inher = match$1[6];
  concr_meths = match$1[4];
  warning_leave_scope(--[[ () ]]0);
  unify$2(val_env$1, self_type, newvar(undefined, --[[ () ]]0));
  sign_csig_vars = map((function (param) do
          return --[[ tuple ]]{
                  param[1],
                  param[2],
                  param[3]
                };
        end end), vars.contents);
  sign = do
    csig_self: public_self,
    csig_vars: sign_csig_vars,
    csig_concr: concr_meths,
    csig_inher: inher
  end;
  methods = get_methods(self_type);
  priv_meths = List.filter((function (param) do
            return field_kind_repr(param[1]) ~= --[[ Fpresent ]]0;
          end end))(methods);
  if (__final) then do
    close_object(self_type);
    mets = virtual_methods(do
          csig_self: self_type,
          csig_vars: sign_csig_vars,
          csig_concr: concr_meths,
          csig_inher: inher
        end);
    vals = fold((function (name, param, l) do
            if (param[1] == --[[ Virtual ]]0) then do
              return --[[ :: ]]{
                      name,
                      l
                    };
            end else do
              return l;
            end end 
          end end), sign_csig_vars, --[[ [] ]]0);
    if (mets ~= --[[ [] ]]0 or vals ~= --[[ [] ]]0) then do
      throw {
            __Error$9,
            loc,
            val_env$1,
            --[[ Virtual_class ]]Block.__(10, {
                true,
                __final,
                mets,
                vals
              })
          };
    end
     end 
    self_methods = List.fold_right((function (param, rem) do
            kind = param[1];
            lab = param[0];
            if (lab == dummy_method) then do
              match = field_kind_repr(kind);
              if (typeof match == "number") then do
                return rem;
              end else do
                set_kind(match[0], --[[ Fabsent ]]1);
                return rem;
              end end 
            end else do
              desc_001 = copy_kind(kind);
              desc_002 = param[2];
              desc = --[[ Tfield ]]Block.__(5, {
                  lab,
                  desc_001,
                  desc_002,
                  rem
                });
              return newty2(current_level.contents, desc);
            end end 
          end end), methods, newty2(current_level.contents, --[[ Tnil ]]0));
    try do
      unify$2(val_env$1, private_self, newty2(current_level.contents, --[[ Tobject ]]Block.__(4, {
                  self_methods,
                  do
                    contents: undefined
                  end
                })));
      unify$2(val_env$1, public_self, self_type);
    end
    catch (raw_exn$1)do
      exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
      if (exn$1[0] == Unify) then do
        throw {
              __Error$9,
              loc,
              val_env$1,
              --[[ Final_self_clash ]]Block.__(21, {exn$1[1]})
            };
      end
       end 
      throw exn$1;
    end
  end
   end 
  if (principal.contents) then do
    List.iter((function (param) do
            return generalize_spine(param[2]);
          end end), methods);
  end
   end 
  fields = List.map(CamlinternalLazy.force, List.rev(match$1[3]));
  if (principal.contents) then do
    List.iter((function (param) do
            return unify$2(val_env$1, param[2], newvar(undefined, --[[ () ]]0));
          end end), methods);
  end
   end 
  meths$1 = map((function (param) do
          return param[0];
        end end), meths.contents);
  pub_meths$prime = List.filter((function (param) do
            return field_kind_repr(param[1]) == --[[ Fpresent ]]0;
          end end))(get_methods(public_self));
  names = function (param) do
    return List.map((function (param) do
                  return param[0];
                end end), param);
  end end;
  l1 = names(priv_meths);
  l2 = names(pub_meths$prime);
  added = List.filter((function (x) do
            return List.mem(x, l1);
          end end))(l2);
  if (added ~= --[[ [] ]]0) then do
    prerr_warning(loc, --[[ Implicit_public_methods ]]Block.__(6, {added}));
  end
   end 
  sign$1 = __final and sign or (do
        csig_self: expand_head(val_env$1, public_self),
        csig_vars: sign_csig_vars,
        csig_concr: concr_meths,
        csig_inher: inher
      end);
  return --[[ tuple ]]{
          do
            cstr_self: pat,
            cstr_fields: fields,
            cstr_type: sign$1,
            cstr_meths: meths$1
          end,
          sign$1
        };
end end

function class_expr(cl_num, val_env, met_env, _scl) do
  while(true) do
    scl = _scl;
    match = scl.pcl_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 0--[[ Pcl_constr ]] then do
          lid = match[0];
          match$1 = find_class$1(val_env, scl.pcl_loc, lid.txt);
          decl = match$1[1];
          path = match$1[0];
          if (same(decl.cty_path, unbound_class)) then do
            throw {
                  __Error$9,
                  scl.pcl_loc,
                  val_env,
                  --[[ Unbound_class_2 ]]Block.__(6, {lid.txt})
                };
          end
           end 
          tyl = List.map((function (sty) do
                  return transl_simple_type(val_env, false, sty);
                end end), match[1]);
          match$2 = instance_class(decl.cty_params, decl.cty_type);
          clty = match$2[1];
          params = match$2[0];
          clty$prime = abbreviate_class_type(path, params, clty);
          if (List.length(params) ~= List.length(tyl)) then do
            throw {
                  __Error$9,
                  scl.pcl_loc,
                  val_env,
                  --[[ Parameter_arity_mismatch ]]Block.__(11, {
                      lid.txt,
                      List.length(params),
                      List.length(tyl)
                    })
                };
          end
           end 
          List.iter2((function (cty$prime, ty) do
                  ty$prime = cty$prime.ctyp_type;
                  try do
                    return unify$2(val_env, ty$prime, ty);
                  end
                  catch (raw_exn)do
                    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn[0] == Unify) then do
                      throw {
                            __Error$9,
                            cty$prime.ctyp_loc,
                            val_env,
                            --[[ Parameter_mismatch ]]Block.__(12, {exn[1]})
                          };
                    end
                     end 
                    throw exn;
                  end
                end end), tyl, params);
          cl = rc(do
                cl_desc: --[[ Tcl_ident ]]Block.__(0, {
                    path,
                    lid,
                    tyl
                  }),
                cl_loc: scl.pcl_loc,
                cl_type: clty$prime,
                cl_env: val_env,
                cl_attributes: scl.pcl_attributes
              end);
          match$3 = extract_constraints(clty);
          return rc(do
                      cl_desc: --[[ Tcl_constraint ]]Block.__(5, {
                          cl,
                          undefined,
                          match$3[0],
                          match$3[1],
                          match$3[2]
                        }),
                      cl_loc: scl.pcl_loc,
                      cl_type: clty$prime,
                      cl_env: val_env,
                      cl_attributes: --[[ [] ]]0
                    end);end end end 
       if ___conditional___ = 1--[[ Pcl_structure ]] then do
          match$4 = class_structure(cl_num, false, val_env, met_env, scl.pcl_loc, match[0]);
          return rc(do
                      cl_desc: --[[ Tcl_structure ]]Block.__(1, {match$4[0]}),
                      cl_loc: scl.pcl_loc,
                      cl_type: --[[ Cty_signature ]]Block.__(1, {match$4[1]}),
                      cl_env: val_env,
                      cl_attributes: scl.pcl_attributes
                    end);end end end 
       if ___conditional___ = 2--[[ Pcl_fun ]] then do
          match$5 = match[1];
          l = match[0];
          if (match$5 ~= undefined) then do
            __default = match$5;
            loc = __default.pexp_loc;
            scases_000 = Curry._3(Ast_helper_Exp.__case, construct(loc, undefined, do
                      txt: --[[ Ldot ]]Block.__(1, {
                          --[[ Lident ]]Block.__(0, {"*predef*"}),
                          "Some"
                        }),
                      loc: none
                    end, __var$1(loc, undefined, do
                          txt: "*sth*",
                          loc: none
                        end)), undefined, Curry._3(Ast_helper_Exp.ident, loc, undefined, do
                      txt: --[[ Lident ]]Block.__(0, {"*sth*"}),
                      loc: none
                    end));
            scases_001 = --[[ :: ]]{
              Curry._3(Ast_helper_Exp.__case, construct(loc, undefined, do
                        txt: --[[ Ldot ]]Block.__(1, {
                            --[[ Lident ]]Block.__(0, {"*predef*"}),
                            "None"
                          }),
                        loc: none
                      end, undefined), undefined, __default),
              --[[ [] ]]0
            };
            scases = --[[ :: ]]{
              scases_000,
              scases_001
            };
            smatch = Curry._4(Ast_helper_Exp.match_, loc, undefined, Curry._3(Ast_helper_Exp.ident, loc, undefined, do
                      txt: --[[ Lident ]]Block.__(0, {"*opt*"}),
                      loc: none
                    end), scases);
            sfun = fun_$1(scl.pcl_loc, undefined, l, undefined, __var$1(loc, undefined, do
                      txt: "*opt*",
                      loc: none
                    end), let_$1(scl.pcl_loc, undefined, --[[ Nonrecursive ]]0, --[[ :: ]]{
                      mk$17(undefined, undefined, undefined, undefined, match[2], smatch),
                      --[[ [] ]]0
                    }, match[3]));
            _scl = sfun;
            continue ;
          end else do
            if (principal.contents) then do
              begin_def(--[[ () ]]0);
            end
             end 
            match$6 = type_class_arg_pattern(cl_num, val_env, met_env, l, match[2]);
            val_env$prime = match$6[2];
            pat = match$6[0];
            if (principal.contents) then do
              end_def(--[[ () ]]0);
              iter_pattern((function (param) do
                      return generalize_structure$1(current_level.contents, param.pat_type);
                    end end), pat);
            end
             end 
            pv = List.map((function(val_env$prime)do
                return function (param) do
                  id = param[0];
                  path = --[[ Pident ]]Block.__(0, {param[2]});
                  vd = find_value(path, val_env$prime);
                  return --[[ tuple ]]{
                          id,
                          param[1],
                          do
                            exp_desc: --[[ Texp_ident ]]Block.__(0, {
                                path,
                                do
                                  txt: --[[ Lident ]]Block.__(0, {id.name}),
                                  loc: none
                                end,
                                vd
                              }),
                            exp_loc: none,
                            exp_extra: --[[ [] ]]0,
                            exp_type: instance(undefined, val_env$prime, vd.val_type),
                            exp_env: val_env$prime,
                            exp_attributes: --[[ [] ]]0
                          end
                        };
                end end
                end(val_env$prime)), match$6[1]);
            not_function = function (param) do
              local ___conditional___=(param.tag | 0);
              do
                 if ___conditional___ = 0--[[ Cty_constr ]]
                 or ___conditional___ = 1--[[ Cty_signature ]] then do
                    return true;end end end 
                 if ___conditional___ = 2--[[ Cty_arrow ]] then do
                    return false;end end end 
                 do
                
              end
            end end;
            partial = check_partial$1(undefined, val_env, pat.pat_type)(pat.pat_loc, --[[ :: ]]{
                  do
                    c_lhs: pat,
                    c_guard: undefined,
                    c_rhs: do
                      exp_desc: --[[ Texp_constant ]]Block.__(1, {--[[ Const_int ]]Block.__(0, {1})}),
                      exp_loc: none,
                      exp_extra: --[[ [] ]]0,
                      exp_type: none$2,
                      exp_env: empty,
                      exp_attributes: --[[ [] ]]0
                    end
                  end,
                  --[[ [] ]]0
                });
            raise_nongen_level(--[[ () ]]0);
            cl$1 = class_expr(cl_num, val_env$prime, match$6[3], match[3]);
            end_def(--[[ () ]]0);
            if (is_optional(l) and not_function(cl$1.cl_type)) then do
              prerr_warning(pat.pat_loc, --[[ Unerasable_optional_argument ]]8);
            end
             end 
            return rc(do
                        cl_desc: --[[ Tcl_fun ]]Block.__(2, {
                            l,
                            pat,
                            pv,
                            cl$1,
                            partial
                          }),
                        cl_loc: scl.pcl_loc,
                        cl_type: --[[ Cty_arrow ]]Block.__(2, {
                            l,
                            instance_def(pat.pat_type),
                            cl$1.cl_type
                          }),
                        cl_env: val_env,
                        cl_attributes: scl.pcl_attributes
                      end);
          end end end end end 
       if ___conditional___ = 3--[[ Pcl_apply ]] then do
          sargs = match[1];
          if (sargs == --[[ [] ]]0) then do
            ill_formed_ast(scl.pcl_loc, "Function application with no argument.");
          end
           end 
          if (principal.contents) then do
            begin_def(--[[ () ]]0);
          end
           end 
          cl$2 = class_expr(cl_num, val_env, met_env, match[0]);
          if (principal.contents) then do
            end_def(--[[ () ]]0);
            ((function (param) do
                    return generalize_class_type(generalize_structure$2, param);
                  end end)(cl$2.cl_type));
          end
           end 
          nonopt_labels = function (_ls, _ty_fun) do
            while(true) do
              ty_fun = _ty_fun;
              ls = _ls;
              local ___conditional___=(ty_fun.tag | 0);
              do
                 if ___conditional___ = 0--[[ Cty_constr ]]
                 or ___conditional___ = 1--[[ Cty_signature ]] then do
                    return ls;end end end 
                 if ___conditional___ = 2--[[ Cty_arrow ]] then do
                    ty_res = ty_fun[2];
                    l = ty_fun[0];
                    if (is_optional(l)) then do
                      _ty_fun = ty_res;
                      continue ;
                    end else do
                      _ty_fun = ty_res;
                      _ls = --[[ :: ]]{
                        l,
                        ls
                      };
                      continue ;
                    end end end end end 
                 do
                
              end
            end;
          end end;
          ignore_labels = true;
          if (not classic.contents) then do
            labels = nonopt_labels(--[[ [] ]]0, cl$2.cl_type);
            ignore_labels = List.length(labels) == List.length(sargs) and List.for_all((function (param) do
                    return param[0] == "";
                  end end), sargs) and List.exists((function (l) do
                    return l ~= "";
                  end end), labels) and (prerr_warning(cl$2.cl_loc, --[[ Labels_omitted ]]3), true);
          end
           end 
          type_args = (function(cl$2,ignore_labels)do
          return function type_args(_args, _omitted, _ty_fun, _ty_fun0, _sargs, _more_sargs) do
            while(true) do
              more_sargs = _more_sargs;
              sargs = _sargs;
              ty_fun0 = _ty_fun0;
              ty_fun = _ty_fun;
              omitted = _omitted;
              args = _args;
              local ___conditional___=(ty_fun.tag | 0);
              do
                 if ___conditional___ = 0--[[ Cty_constr ]]
                 or ___conditional___ = 1--[[ Cty_signature ]]
                 or ___conditional___ = 2--[[ Cty_arrow ]] then do
                    ty = ty_fun[1];
                    l = ty_fun[0];
                    local ___conditional___=(ty_fun0.tag | 0);
                    do
                       if ___conditional___ = 0--[[ Cty_constr ]]
                       or ___conditional___ = 1--[[ Cty_signature ]]
                       or ___conditional___ = 2--[[ Cty_arrow ]] then do
                          if (sargs ~= --[[ [] ]]0 or more_sargs ~= --[[ [] ]]0) then do
                            ty0 = ty_fun0[1];
                            name = label_name(l);
                            optional = is_optional(l) and --[[ Optional ]]1 or --[[ Required ]]0;
                            match;
                            if (ignore_labels and not is_optional(l)) then do
                              if (sargs) then do
                                match$1 = sargs[0];
                                throw {
                                      __Error$9,
                                      match$1[1].pexp_loc,
                                      val_env,
                                      --[[ Apply_wrong_label ]]Block.__(4, {match$1[0]})
                                    };
                              end else if (more_sargs) then do
                                match$2 = more_sargs[0];
                                sarg0 = match$2[1];
                                l$prime = match$2[0];
                                if (l ~= l$prime and l$prime ~= "") then do
                                  throw {
                                        __Error$9,
                                        sarg0.pexp_loc,
                                        val_env,
                                        --[[ Apply_wrong_label ]]Block.__(4, {l$prime})
                                      };
                                end
                                 end 
                                match = --[[ tuple ]]{
                                  --[[ [] ]]0,
                                  more_sargs[1],
                                  type_argument(val_env, sarg0, ty, ty0)
                                };
                              end else do
                                throw {
                                      Caml_builtin_exceptions.assert_failure,
                                      --[[ tuple ]]{
                                        "typeclass.ml",
                                        1017,
                                        20
                                      }
                                    };
                              end end  end 
                            end else do
                              try do
                                match$3;
                                try do
                                  match$4 = extract_label_aux(--[[ [] ]]0, name, sargs);
                                  match$3 = --[[ tuple ]]{
                                    match$4[0],
                                    match$4[1],
                                    Pervasives.$at(match$4[2], match$4[3]),
                                    more_sargs
                                  };
                                end
                                catch (exn)do
                                  if (exn == Caml_builtin_exceptions.not_found) then do
                                    match$5 = extract_label_aux(--[[ [] ]]0, name, more_sargs);
                                    match$3 = --[[ tuple ]]{
                                      match$5[0],
                                      match$5[1],
                                      Pervasives.$at(sargs, match$5[2]),
                                      match$5[3]
                                    };
                                  end else do
                                    throw exn;
                                  end end 
                                end
                                sarg0$1 = match$3[1];
                                l$prime$1 = match$3[0];
                                if (optional == --[[ Required ]]0 and is_optional(l$prime$1)) then do
                                  prerr_warning(sarg0$1.pexp_loc, --[[ Nonoptional_label ]]Block.__(26, {l}));
                                end
                                 end 
                                tmp;
                                if (optional == --[[ Required ]]0 or is_optional(l$prime$1)) then do
                                  tmp = type_argument(val_env, sarg0$1, ty, ty0);
                                end else do
                                  ty$prime = extract_option_type(val_env, ty);
                                  ty0$prime = extract_option_type(val_env, ty0);
                                  arg = type_argument(val_env, sarg0$1, ty$prime, ty0$prime);
                                  tmp = option_some(arg);
                                end end 
                                match = --[[ tuple ]]{
                                  match$3[2],
                                  match$3[3],
                                  tmp
                                };
                              end
                              catch (exn$1)do
                                if (exn$1 == Caml_builtin_exceptions.not_found) then do
                                  match = --[[ tuple ]]{
                                    sargs,
                                    more_sargs,
                                    is_optional(l) and (List.mem_assoc("", sargs) or List.mem_assoc("", more_sargs)) and option_none(ty0, none) or undefined
                                  };
                                end else do
                                  throw exn$1;
                                end end 
                              end
                            end end 
                            arg$1 = match[2];
                            omitted$1 = arg$1 == undefined and --[[ :: ]]{
                                --[[ tuple ]]{
                                  l,
                                  ty0
                                },
                                omitted
                              } or omitted;
                            _more_sargs = match[1];
                            _sargs = match[0];
                            _ty_fun0 = ty_fun0[2];
                            _ty_fun = ty_fun[2];
                            _omitted = omitted$1;
                            _args = --[[ :: ]]{
                              --[[ tuple ]]{
                                l,
                                arg$1,
                                optional
                              },
                              args
                            };
                            continue ;
                          end
                           end end else 
                       do end end
                      
                    endend else 
                 do end end
                
              end
              match$6 = Pervasives.$at(sargs, more_sargs);
              if (match$6) then do
                if (omitted ~= --[[ [] ]]0) then do
                  match$7 = match$6[0];
                  throw {
                        __Error$9,
                        match$7[1].pexp_loc,
                        val_env,
                        --[[ Apply_wrong_label ]]Block.__(4, {match$7[0]})
                      };
                end else do
                  throw {
                        __Error$9,
                        cl$2.cl_loc,
                        val_env,
                        --[[ Cannot_apply ]]Block.__(3, {cl$2.cl_type})
                      };
                end end 
              end else do
                return --[[ tuple ]]{
                        List.rev(args),
                        List.fold_left((function (ty_fun, param) do
                                return --[[ Cty_arrow ]]Block.__(2, {
                                          param[0],
                                          param[1],
                                          ty_fun
                                        });
                              end end), ty_fun0, omitted)
                      };
              end end 
            end;
          end end
          end(cl$2,ignore_labels));
          match$7 = instance_class(--[[ [] ]]0, cl$2.cl_type);
          ty_fun0 = match$7[1];
          match$8 = ignore_labels and type_args(--[[ [] ]]0, --[[ [] ]]0, cl$2.cl_type, ty_fun0, --[[ [] ]]0, sargs) or type_args(--[[ [] ]]0, --[[ [] ]]0, cl$2.cl_type, ty_fun0, sargs, --[[ [] ]]0);
          return rc(do
                      cl_desc: --[[ Tcl_apply ]]Block.__(3, {
                          cl$2,
                          match$8[0]
                        }),
                      cl_loc: scl.pcl_loc,
                      cl_type: match$8[1],
                      cl_env: val_env,
                      cl_attributes: scl.pcl_attributes
                    end);end end end 
       if ___conditional___ = 4--[[ Pcl_let ]] then do
          rec_flag = match[0];
          match$9;
          try do
            match$9 = type_let$1(val_env, rec_flag, match[1], undefined);
          end
          catch (raw_exn)do
            exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn[0] == Unify) then do
              match$10 = exn[1];
              if (match$10) then do
                if (match$10[1]) then do
                  throw exn;
                end
                 end 
                throw {
                      __Error$9,
                      scl.pcl_loc,
                      val_env,
                      --[[ Make_nongen_seltype ]]Block.__(17, {match$10[0][0]})
                    };
              end else do
                throw exn;
              end end 
            end else do
              throw exn;
            end end 
          end
          val_env$1 = match$9[1];
          defs = match$9[0];
          match$11 = List.fold_right((function(val_env$1)do
              return function (param, param$1) do
                id = param[0];
                path = --[[ Pident ]]Block.__(0, {id});
                vd = find_value(path, val_env$1);
                begin_def(--[[ () ]]0);
                expr_exp_desc = --[[ Texp_ident ]]Block.__(0, {
                    path,
                    do
                      txt: --[[ Lident ]]Block.__(0, {id.name}),
                      loc: none
                    end,
                    vd
                  });
                expr_exp_type = instance(undefined, val_env$1, vd.val_type);
                expr = do
                  exp_desc: expr_exp_desc,
                  exp_loc: none,
                  exp_extra: --[[ [] ]]0,
                  exp_type: expr_exp_type,
                  exp_env: val_env$1,
                  exp_attributes: --[[ [] ]]0
                end;
                end_def(--[[ () ]]0);
                iter_generalize$1(do
                      contents: --[[ [] ]]0
                    end, expr_exp_type);
                desc_val_type = expr_exp_type;
                desc_val_kind = --[[ Val_ivar ]]Block.__(1, {
                    --[[ Immutable ]]0,
                    cl_num
                  });
                desc_val_loc = vd.val_loc;
                desc = do
                  val_type: desc_val_type,
                  val_kind: desc_val_kind,
                  val_loc: desc_val_loc,
                  val_attributes: --[[ [] ]]0
                end;
                id$prime = create(id.name);
                return --[[ tuple ]]{
                        --[[ :: ]]{
                          --[[ tuple ]]{
                            id$prime,
                            param[1],
                            expr
                          },
                          param$1[0]
                        },
                        add_value(undefined, id$prime, desc, param$1[1])
                      };
              end end
              end(val_env$1)), List.rev(rev_let_bound_idents_with_loc(defs)), --[[ tuple ]]{
                --[[ [] ]]0,
                met_env
              });
          cl$3 = class_expr(cl_num, val_env$1, match$11[1], match[2]);
          return rc(do
                      cl_desc: --[[ Tcl_let ]]Block.__(4, {
                          rec_flag,
                          defs,
                          match$11[0],
                          cl$3
                        }),
                      cl_loc: scl.pcl_loc,
                      cl_type: cl$3.cl_type,
                      cl_env: val_env$1,
                      cl_attributes: scl.pcl_attributes
                    end);end end end 
       if ___conditional___ = 5--[[ Pcl_constraint ]] then do
          begin_class_def(--[[ () ]]0);
          context = narrow(--[[ () ]]0);
          cl$4 = class_expr(cl_num, val_env, met_env, match[0]);
          widen(context);
          context$1 = narrow(--[[ () ]]0);
          clty$1 = class_type$4(val_env, match[1]);
          widen(context$1);
          end_def(--[[ () ]]0);
          limited_generalize$1(row_variable(repr(signature_of_class_type(cl$4.cl_type).csig_self)), cl$4.cl_type);
          limited_generalize$1(row_variable(repr(signature_of_class_type(clty$1.cltyp_type).csig_self)), clty$1.cltyp_type);
          error = class_types(val_env, cl$4.cl_type, clty$1.cltyp_type);
          if (error) then do
            throw {
                  __Error$9,
                  cl$4.cl_loc,
                  val_env,
                  --[[ Class_match_failure ]]Block.__(14, {error})
                };
          end
           end 
          match$12 = extract_constraints(clty$1.cltyp_type);
          return rc(do
                      cl_desc: --[[ Tcl_constraint ]]Block.__(5, {
                          cl$4,
                          clty$1,
                          match$12[0],
                          match$12[1],
                          match$12[2]
                        }),
                      cl_loc: scl.pcl_loc,
                      cl_type: instance_class(--[[ [] ]]0, clty$1.cltyp_type)[1],
                      cl_env: val_env,
                      cl_attributes: scl.pcl_attributes
                    end);end end end 
       if ___conditional___ = 6--[[ Pcl_extension ]] then do
          throw {
                Error_forward$2,
                error_of_extension(match[0])
              };end end end 
       do
      
    end
  end;
end end

var_option = type_option(newty2(100000000, --[[ Tvar ]]Block.__(0, {undefined})));

function approx_declaration(_cl) do
  while(true) do
    cl = _cl;
    match = cl.pcl_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 2--[[ Pcl_fun ]] then do
          l = match[0];
          arg = is_optional(l) and instance_def(var_option) or newvar(undefined, --[[ () ]]0);
          desc_002 = approx_declaration(match[3]);
          desc = --[[ Tarrow ]]Block.__(1, {
              l,
              arg,
              desc_002,
              --[[ Cok ]]0
            });
          return newty2(current_level.contents, desc);end end end 
       if ___conditional___ = 4--[[ Pcl_let ]] then do
          _cl = match[2];
          continue ;end end end 
       if ___conditional___ = 5--[[ Pcl_constraint ]] then do
          _cl = match[0];
          continue ;end end end 
       do
      else do
        return newvar(undefined, --[[ () ]]0);
        end end
        
    end
  end;
end end

function approx_description(ct) do
  match = ct.pcty_desc;
  if (match.tag == --[[ Pcty_arrow ]]2) then do
    l = match[0];
    arg = is_optional(l) and instance_def(var_option) or newvar(undefined, --[[ () ]]0);
    desc_002 = approx_description(match[2]);
    desc = --[[ Tarrow ]]Block.__(1, {
        l,
        arg,
        desc_002,
        --[[ Cok ]]0
      });
    return newty2(current_level.contents, desc);
  end else do
    return newvar(undefined, --[[ () ]]0);
  end end 
end end

function temp_abbrev(loc, env, id, arity) do
  params = --[[ [] ]]0;
  for _i = 1 , arity , 1 do
    params = --[[ :: ]]{
      newvar(undefined, --[[ () ]]0),
      params
    };
  end
  ty = newobj(newvar(undefined, --[[ () ]]0));
  env$1 = add_type$1(true, id, do
        type_params: params,
        type_arity: arity,
        type_kind: --[[ Type_abstract ]]0,
        type_private: --[[ Public ]]1,
        type_manifest: ty,
        type_variance: replicate_list(Types_Variance.full, arity),
        type_newtype_level: undefined,
        type_loc: loc,
        type_attributes: --[[ [] ]]0
      end, env);
  return --[[ tuple ]]{
          params,
          ty,
          env$1
        };
end end

function extract_type_decls(param, decls) do
  return --[[ :: ]]{
          --[[ tuple ]]{
            param[5],
            param[6],
            param[8],
            param[2],
            param[4],
            param[13]
          },
          decls
        };
end end

function merge_type_decls(param, param$1) do
  return --[[ tuple ]]{
          param[0],
          param[1],
          param$1[2],
          param[3],
          param$1[3],
          param[5],
          param$1[0],
          param[7],
          param$1[1],
          param[9],
          param[10],
          param[11],
          param[12],
          param[13]
        };
end end

function type_classes(define_class, approx, kind, env, cls) do
  cls$1 = List.map((function (cl) do
          return --[[ tuple ]]{
                  cl,
                  create(cl.pci_name.txt),
                  create(cl.pci_name.txt),
                  create(cl.pci_name.txt),
                  create("#" .. cl.pci_name.txt)
                };
        end end), cls);
  init_def(currentstamp.contents);
  begin_class_def(--[[ () ]]0);
  match = List.fold_left((function (param, param$1) do
          define_class$1 = define_class;
          approx$1 = approx;
          param$2 = param;
          param$3 = param$1;
          cl_id = param$3[4];
          obj_id = param$3[3];
          ty_id = param$3[2];
          id = param$3[1];
          cl = param$3[0];
          arity = List.length(cl.pci_params);
          match = temp_abbrev(cl.pci_loc, param$2[1], obj_id, arity);
          match$1 = temp_abbrev(cl.pci_loc, match[2], cl_id, arity);
          env = match$1[2];
          constr_type = Curry._1(approx$1, cl.pci_expr);
          if (principal.contents) then do
            generalize_spine(constr_type);
          end
           end 
          dummy_cty = --[[ Cty_signature ]]Block.__(1, {do
                csig_self: newvar(undefined, --[[ () ]]0),
                csig_vars: --[[ Empty ]]0,
                csig_concr: --[[ Empty ]]0,
                csig_inher: --[[ [] ]]0
              end});
          match$2 = cl.pci_virt;
          dummy_class = do
            cty_params: --[[ [] ]]0,
            cty_type: dummy_cty,
            cty_path: unbound_class,
            cty_new: match$2 and constr_type or undefined,
            cty_variance: --[[ [] ]]0,
            cty_loc: none,
            cty_attributes: --[[ [] ]]0
          end;
          env$1 = add_cltype(ty_id, do
                clty_params: --[[ [] ]]0,
                clty_type: dummy_cty,
                clty_path: unbound_class,
                clty_variance: --[[ [] ]]0,
                clty_loc: none,
                clty_attributes: --[[ [] ]]0
              end, define_class$1 and add_class(id, dummy_class, env) or env);
          return --[[ tuple ]]{
                  --[[ :: ]]{
                    --[[ tuple ]]{
                      cl,
                      id,
                      ty_id,
                      obj_id,
                      match[0],
                      match[1],
                      cl_id,
                      match$1[0],
                      match$1[1],
                      constr_type,
                      dummy_class
                    },
                    param$2[0]
                  },
                  env$1
                };
        end end), --[[ tuple ]]{
        --[[ [] ]]0,
        env
      }, cls$1);
  match$1 = List.fold_right((function (param, param$1) do
          define_class$1 = define_class;
          kind$1 = kind;
          param$2 = param;
          param$3 = param$1;
          env = param$3[1];
          constr_type = param$2[9];
          cl_ty = param$2[8];
          cl_params = param$2[7];
          cl_id = param$2[6];
          obj_ty = param$2[5];
          obj_params = param$2[4];
          obj_id = param$2[3];
          ty_id = param$2[2];
          id = param$2[1];
          cl = param$2[0];
          reset_type_variables(--[[ () ]]0);
          begin_class_def(--[[ () ]]0);
          make_param = function (param) do
            sty = param[0];
            try do
              return --[[ tuple ]]{
                      transl_type_param(env, sty),
                      param[1]
                    };
            end
            catch (exn)do
              if (exn == Already_bound) then do
                throw {
                      __Error$9,
                      sty.ptyp_loc,
                      env,
                      --[[ Repeated_parameter ]]0
                    };
              end
               end 
              throw exn;
            end
          end end;
          ci_params = List.map(make_param, cl.pci_params);
          params = List.map((function (param) do
                  return param[0].ctyp_type;
                end end), ci_params);
          coercion_locs = do
            contents: --[[ [] ]]0
          end;
          match;
          try do
            self_coercion.contents = --[[ :: ]]{
              --[[ tuple ]]{
                --[[ Pident ]]Block.__(0, {obj_id}),
                coercion_locs
              },
              self_coercion.contents
            };
            res = Curry._2(kind$1, env, cl.pci_expr);
            self_coercion.contents = List.tl(self_coercion.contents);
            match = res;
          end
          catch (exn)do
            self_coercion.contents = --[[ [] ]]0;
            throw exn;
          end
          typ = match[1];
          end_def(--[[ () ]]0);
          sty = repr(signature_of_class_type(typ).csig_self);
          match$1 = flatten_fields(object_fields(sty));
          List.iter((function (param) do
                  if (param[0] == dummy_method) then do
                    return iter_generalize$1(do
                                contents: --[[ [] ]]0
                              end, param[2]);
                  end else do
                    return 0;
                  end end 
                end end), match$1[0]);
          rv = row_variable(sty);
          List.iter((function (param) do
                  return limited_generalize(rv, param);
                end end), params);
          limited_generalize$1(rv, typ);
          match$2 = instance_class(params, typ);
          obj_type = match$2[1];
          obj_params$prime = match$2[0];
          constr = newconstr(--[[ Pident ]]Block.__(0, {obj_id}), obj_params);
          ty = repr(signature_of_class_type(obj_type).csig_self);
          hide_private_methods(ty);
          close_object(ty);
          try do
            List.iter2((function (param, param$1) do
                    return unify$2(env, param, param$1);
                  end end), obj_params, obj_params$prime);
          end
          catch (raw_exn)do
            exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn$1[0] == Unify) then do
              throw {
                    __Error$9,
                    cl.pci_loc,
                    env,
                    --[[ Bad_parameters ]]Block.__(13, {
                        obj_id,
                        constr,
                        newconstr(--[[ Pident ]]Block.__(0, {obj_id}), obj_params$prime)
                      })
                  };
            end
             end 
            throw exn$1;
          end
          try do
            unify$2(env, ty, constr);
          end
          catch (raw_exn$1)do
            exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
            if (exn$2[0] == Unify) then do
              throw {
                    __Error$9,
                    cl.pci_loc,
                    env,
                    --[[ Abbrev_type_clash ]]Block.__(8, {
                        constr,
                        ty,
                        expand_head(env, constr)
                      })
                  };
            end
             end 
            throw exn$2;
          end
          match$3 = instance_class(params, typ);
          cl_params$prime = match$3[0];
          ty$1 = repr(signature_of_class_type(match$3[1]).csig_self);
          hide_private_methods(ty$1);
          set_object_name(obj_id, row_variable(ty$1), cl_params, ty$1);
          try do
            List.iter2((function (param, param$1) do
                    return unify$2(env, param, param$1);
                  end end), cl_params, cl_params$prime);
          end
          catch (raw_exn$2)do
            exn$3 = Caml_js_exceptions.internalToOCamlException(raw_exn$2);
            if (exn$3[0] == Unify) then do
              throw {
                    __Error$9,
                    cl.pci_loc,
                    env,
                    --[[ Bad_parameters ]]Block.__(13, {
                        cl_id,
                        newconstr(--[[ Pident ]]Block.__(0, {cl_id}), cl_params),
                        newconstr(--[[ Pident ]]Block.__(0, {cl_id}), cl_params$prime)
                      })
                  };
            end
             end 
            throw exn$3;
          end
          try do
            unify$2(env, ty$1, cl_ty);
          end
          catch (raw_exn$3)do
            exn$4 = Caml_js_exceptions.internalToOCamlException(raw_exn$3);
            if (exn$4[0] == Unify) then do
              constr$1 = newconstr(--[[ Pident ]]Block.__(0, {cl_id}), params);
              throw {
                    __Error$9,
                    cl.pci_loc,
                    env,
                    --[[ Abbrev_type_clash ]]Block.__(8, {
                        constr$1,
                        ty$1,
                        cl_ty
                      })
                  };
            end else do
              throw exn$4;
            end end 
          end
          try do
            unify$2(env, constructor_type(constr, obj_type), instance(undefined, env, constr_type));
          end
          catch (raw_exn$4)do
            exn$5 = Caml_js_exceptions.internalToOCamlException(raw_exn$4);
            if (exn$5[0] == Unify) then do
              throw {
                    __Error$9,
                    cl.pci_loc,
                    env,
                    --[[ Constructor_type_mismatch ]]Block.__(9, {
                        cl.pci_name.txt,
                        exn$5[1]
                      })
                  };
            end
             end 
            throw exn$5;
          end
          cty_variance = List.map((function (param) do
                  return Types_Variance.full;
                end end), params);
          cltydef_clty_type = class_body(typ);
          cltydef_clty_path = --[[ Pident ]]Block.__(0, {obj_id});
          cltydef_clty_loc = cl.pci_loc;
          cltydef_clty_attributes = cl.pci_attributes;
          cltydef = do
            clty_params: params,
            clty_type: cltydef_clty_type,
            clty_path: cltydef_clty_path,
            clty_variance: cty_variance,
            clty_loc: cltydef_clty_loc,
            clty_attributes: cltydef_clty_attributes
          end;
          match$4 = cl.pci_virt;
          clty = do
            cty_params: params,
            cty_type: typ,
            cty_path: --[[ Pident ]]Block.__(0, {obj_id}),
            cty_new: match$4 and constr_type or undefined,
            cty_variance: cty_variance,
            cty_loc: cl.pci_loc,
            cty_attributes: cl.pci_attributes
          end;
          param$2[10].cty_type = typ;
          env$1 = add_cltype(ty_id, cltydef, define_class$1 and add_class(id, clty, env) or env);
          if (cl.pci_virt == --[[ Concrete ]]1) then do
            sign = signature_of_class_type(typ);
            mets = virtual_methods(sign);
            vals = fold((function (name, param, l) do
                    if (param[1] == --[[ Virtual ]]0) then do
                      return --[[ :: ]]{
                              name,
                              l
                            };
                    end else do
                      return l;
                    end end 
                  end end), sign.csig_vars, --[[ [] ]]0);
            if (mets ~= --[[ [] ]]0 or vals ~= --[[ [] ]]0) then do
              throw {
                    __Error$9,
                    cl.pci_loc,
                    env$1,
                    --[[ Virtual_class ]]Block.__(10, {
                        define_class$1,
                        false,
                        mets,
                        vals
                      })
                  };
            end
             end 
          end
           end 
          arity = class_type_arity(typ);
          match$5 = flatten_fields(object_fields(expand_head(env$1, obj_ty)));
          pub_meths = List.map((function (param) do
                  return param[0];
                end end), match$5[0]);
          match$6 = instance_class(params, typ);
          typ$prime = match$6[1];
          params$prime = match$6[0];
          cltydef_clty_type$1 = class_body(typ$prime);
          cltydef_clty_path$1 = --[[ Pident ]]Block.__(0, {obj_id});
          cltydef_clty_loc$1 = cl.pci_loc;
          cltydef_clty_attributes$1 = cl.pci_attributes;
          cltydef$1 = do
            clty_params: params$prime,
            clty_type: cltydef_clty_type$1,
            clty_path: cltydef_clty_path$1,
            clty_variance: cty_variance,
            clty_loc: cltydef_clty_loc$1,
            clty_attributes: cltydef_clty_attributes$1
          end;
          match$7 = cl.pci_virt;
          clty$1 = do
            cty_params: params$prime,
            cty_type: typ$prime,
            cty_path: --[[ Pident ]]Block.__(0, {obj_id}),
            cty_new: match$7 and instance(undefined, env$1, constr_type) or undefined,
            cty_variance: cty_variance,
            cty_loc: cl.pci_loc,
            cty_attributes: cl.pci_attributes
          end;
          obj_abbr_type_arity = List.length(obj_params);
          obj_abbr_type_manifest = obj_ty;
          obj_abbr_type_variance = List.map((function (param) do
                  return Types_Variance.full;
                end end), obj_params);
          obj_abbr_type_loc = cl.pci_loc;
          obj_abbr = do
            type_params: obj_params,
            type_arity: obj_abbr_type_arity,
            type_kind: --[[ Type_abstract ]]0,
            type_private: --[[ Public ]]1,
            type_manifest: obj_abbr_type_manifest,
            type_variance: obj_abbr_type_variance,
            type_newtype_level: undefined,
            type_loc: obj_abbr_type_loc,
            type_attributes: --[[ [] ]]0
          end;
          match$8 = instance_parameterized_type(undefined, params, repr(signature_of_class_type(typ).csig_self));
          cl_ty$1 = match$8[1];
          cl_params$1 = match$8[0];
          hide_private_methods(cl_ty$1);
          set_object_name(obj_id, row_variable(cl_ty$1), cl_params$1, cl_ty$1);
          cl_abbr_type_arity = List.length(cl_params$1);
          cl_abbr_type_manifest = cl_ty$1;
          cl_abbr_type_variance = List.map((function (param) do
                  return Types_Variance.full;
                end end), cl_params$1);
          cl_abbr_type_loc = cl.pci_loc;
          cl_abbr = do
            type_params: cl_params$1,
            type_arity: cl_abbr_type_arity,
            type_kind: --[[ Type_abstract ]]0,
            type_private: --[[ Public ]]1,
            type_manifest: cl_abbr_type_manifest,
            type_variance: cl_abbr_type_variance,
            type_newtype_level: undefined,
            type_loc: cl_abbr_type_loc,
            type_attributes: --[[ [] ]]0
          end;
          return --[[ tuple ]]{
                  --[[ :: ]]{
                    --[[ tuple ]]{
                      cl,
                      id,
                      clty$1,
                      ty_id,
                      cltydef$1,
                      obj_id,
                      obj_abbr,
                      cl_id,
                      cl_abbr,
                      ci_params,
                      arity,
                      pub_meths,
                      List.rev(coercion_locs.contents),
                      match[0]
                    },
                    param$3[0]
                  },
                  env$1
                };
        end end), match[0], --[[ tuple ]]{
        --[[ [] ]]0,
        match[1]
      });
  env$1 = match$1[1];
  end_def(--[[ () ]]0);
  res = List.rev_map((function (param) do
          env$2 = env$1;
          define_class$1 = define_class;
          param$1 = param;
          expr = param$1[13];
          cl_abbr = param$1[8];
          cl_id = param$1[7];
          obj_abbr = param$1[6];
          obj_id = param$1[5];
          cltydef = param$1[4];
          ty_id = param$1[3];
          clty = param$1[2];
          id = param$1[1];
          cl = param$1[0];
          try do
            collapse_conj_params(env$2, clty.cty_params);
          end
          catch (raw_exn)do
            exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn[0] == Unify) then do
              throw {
                    __Error$9,
                    cl.pci_loc,
                    env$2,
                    --[[ Non_collapsable_conjunction ]]Block.__(20, {
                        id,
                        clty,
                        exn[1]
                      })
                  };
            end
             end 
            throw exn;
          end
          List.iter(generalize, clty.cty_params);
          ((function (param) do
                  return generalize_class_type(generalize, param);
                end end)(clty.cty_type));
          may(generalize, clty.cty_new);
          List.iter(generalize, obj_abbr.type_params);
          may(generalize, obj_abbr.type_manifest);
          List.iter(generalize, cl_abbr.type_params);
          may(generalize, cl_abbr.type_manifest);
          if (not closed_class$1(clty)) then do
            throw {
                  __Error$9,
                  cl.pci_loc,
                  env$2,
                  --[[ Non_generalizable_class ]]Block.__(18, {
                      id,
                      clty
                    })
                };
          end
           end 
          match = closed_class(clty.cty_params, signature_of_class_type(clty.cty_type));
          if (match ~= undefined) then do
            printer = define_class$1 and (function (ppf) do
                  return class_declaration$1(id, ppf, clty);
                end end) or (function (ppf) do
                  return cltype_declaration$1(id, ppf, cltydef);
                end end);
            throw {
                  __Error$9,
                  cl.pci_loc,
                  env$2,
                  --[[ Unbound_type_var ]]Block.__(16, {
                      printer,
                      match
                    })
                };
          end
           end 
          return --[[ tuple ]]{
                  id,
                  cl.pci_name,
                  clty,
                  ty_id,
                  cltydef,
                  obj_id,
                  obj_abbr,
                  cl_id,
                  cl_abbr,
                  param$1[10],
                  param$1[11],
                  param$1[12],
                  expr,
                  do
                    ci_virt: cl.pci_virt,
                    ci_params: param$1[9],
                    ci_id_name: cl.pci_name,
                    ci_id_class: id,
                    ci_id_class_type: ty_id,
                    ci_id_object: obj_id,
                    ci_id_typesharp: cl_id,
                    ci_expr: expr,
                    ci_decl: clty,
                    ci_type_decl: cltydef,
                    ci_loc: cl.pci_loc,
                    ci_attributes: cl.pci_attributes
                  end
                };
        end end), match$1[0]);
  decls = List.fold_right(extract_type_decls, res, --[[ [] ]]0);
  decls$1 = compute_variance_decls(env$1, decls);
  res$1 = List.map2(merge_type_decls, res, decls$1);
  env$2 = List.fold_left((function (param, param$1) do
          define_class$1 = define_class;
          env = param;
          param$2 = param$1;
          return add_type$1(true, param$2[5], type_declaration(identity, param$2[6]), add_type$1(true, param$2[7], type_declaration(identity, param$2[8]), add_cltype(param$2[3], cltype_declaration(identity, param$2[4]), define_class$1 and add_class(param$2[0], class_declaration(identity, param$2[2]), env) or env)));
        end end), env$1, res$1);
  res$2 = List.map((function (param) do
          env$3 = env$2;
          param$1 = param;
          coercion_locs = param$1[11];
          cl_abbr = param$1[8];
          obj_abbr = param$1[6];
          if (coercion_locs) then do
            loc = coercion_locs[0];
            match = cl_abbr.type_manifest;
            match$1 = obj_abbr.type_manifest;
            match$2;
            if (match ~= undefined) then do
              if (match$1 ~= undefined) then do
                match$3 = instance_parameterized_type(undefined, cl_abbr.type_params, match);
                match$4 = instance_parameterized_type(undefined, obj_abbr.type_params, match$1);
                List.iter2((function (param, param$1) do
                        return unify$2(env$3, param, param$1);
                      end end), match$3[0], match$4[0]);
                match$2 = --[[ tuple ]]{
                  match$3[1],
                  match$4[1]
                };
              end else do
                throw {
                      Caml_builtin_exceptions.assert_failure,
                      --[[ tuple ]]{
                        "typeclass.ml",
                        1562,
                        15
                      }
                    };
              end end 
            end else do
              throw {
                    Caml_builtin_exceptions.assert_failure,
                    --[[ tuple ]]{
                      "typeclass.ml",
                      1562,
                      15
                    }
                  };
            end end 
            obj_ty = match$2[1];
            cl_ty = match$2[0];
            try do
              subtype(env$3, cl_ty, obj_ty)(--[[ () ]]0);
            end
            catch (raw_exn)do
              exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn[0] == Subtype) then do
                throw {
                      __Error$7,
                      loc,
                      env$3,
                      --[[ Not_subtype ]]Block.__(23, {
                          exn[1],
                          exn[2]
                        })
                    };
              end
               end 
              throw exn;
            end
            if (not opened_object(cl_ty)) then do
              throw {
                    __Error$9,
                    loc,
                    env$3,
                    --[[ Cannot_coerce_self ]]Block.__(19, {obj_ty})
                  };
            end
             end 
          end
           end 
          return --[[ tuple ]]{
                  param$1[0],
                  param$1[1],
                  param$1[2],
                  param$1[3],
                  param$1[4],
                  param$1[5],
                  obj_abbr,
                  param$1[7],
                  cl_abbr,
                  param$1[9],
                  param$1[10],
                  param$1[13]
                };
        end end), res$1);
  return --[[ tuple ]]{
          res$2,
          env$2
        };
end end

class_num = do
  contents: 0
end;

function class_declaration$2(env, sexpr) do
  class_num.contents = class_num.contents + 1 | 0;
  expr = class_expr(String(class_num.contents), env, env, sexpr);
  return --[[ tuple ]]{
          expr,
          expr.cl_type
        };
end end

function class_description(env, sexpr) do
  expr = class_type$4(env, sexpr);
  return --[[ tuple ]]{
          expr,
          expr.cltyp_type
        };
end end

function class_declarations$2(env, cls) do
  return type_classes(true, approx_declaration, class_declaration$2, env, cls);
end end

function class_descriptions(env, cls) do
  return type_classes(true, approx_description, class_description, env, cls);
end end

function class_type_declarations$2(env, cls) do
  match = type_classes(false, approx_description, class_description, env, cls);
  return --[[ tuple ]]{
          List.map((function (param) do
                  return --[[ tuple ]]{
                          param[3],
                          param[1],
                          param[4],
                          param[5],
                          param[6],
                          param[7],
                          param[8],
                          param[11]
                        };
                end end), match[0]),
          match[1]
        };
end end

function unify_parents_struct(env, ty, st) do
  return List.iter((function (param) do
                match = param.cf_desc;
                if (match.tag) then do
                  return --[[ () ]]0;
                end else do
                  env$1 = env;
                  ty$1 = ty;
                  _cl = match[1];
                  while(true) do
                    cl = _cl;
                    match$1 = cl.cl_desc;
                    local ___conditional___=(match$1.tag | 0);
                    do
                       if ___conditional___ = 0--[[ Tcl_ident ]] then do
                          try do
                            decl = find_class(match$1[0], env$1);
                            match$2 = find_cltype_for_path(env$1, decl.cty_path);
                            return unify$2(env$1, ty$1, instance(undefined, env$1, match$2[1]));
                          end
                          catch (exn)do
                            if (exn == Caml_builtin_exceptions.not_found) then do
                              return --[[ () ]]0;
                            end else do
                              throw {
                                    Caml_builtin_exceptions.assert_failure,
                                    --[[ tuple ]]{
                                      "typeclass.ml",
                                      1639,
                                      15
                                    }
                                  };
                            end end 
                          endend end end 
                       if ___conditional___ = 1--[[ Tcl_structure ]] then do
                          return unify_parents_struct(env$1, ty$1, match$1[0]);end end end 
                       if ___conditional___ = 2--[[ Tcl_fun ]]
                       or ___conditional___ = 4--[[ Tcl_let ]] then do
                          _cl = match$1[3];
                          continue ;end end end 
                       if ___conditional___ = 3--[[ Tcl_apply ]]
                       or ___conditional___ = 5--[[ Tcl_constraint ]] then do
                          _cl = match$1[0];
                          continue ;end end end 
                       do
                      
                    end
                  end;
                end end 
              end end), st.cstr_fields);
end end

function type_object$1(env, loc, s) do
  class_num.contents = class_num.contents + 1 | 0;
  match = class_structure(String(class_num.contents), true, env, env, loc, s);
  sign = match[1];
  desc = match[0];
  sty = expand_head(env, sign.csig_self);
  hide_private_methods(sty);
  match$1 = flatten_fields(object_fields(sty));
  meths = List.map((function (param) do
          return param[0];
        end end), match$1[0]);
  unify_parents_struct(env, sign.csig_self, desc);
  return --[[ tuple ]]{
          desc,
          sign,
          meths
        };
end end

type_object.contents = type_object$1;

function approx_class(sdecl) do
  self$prime = mk(undefined, undefined, --[[ Ptyp_any ]]0);
  clty$prime = signature$1(sdecl.pci_expr.pcty_loc, undefined, do
        pcsig_self: self$prime,
        pcsig_fields: --[[ [] ]]0
      end);
  return do
          pci_virt: sdecl.pci_virt,
          pci_params: sdecl.pci_params,
          pci_name: sdecl.pci_name,
          pci_expr: clty$prime,
          pci_loc: sdecl.pci_loc,
          pci_attributes: sdecl.pci_attributes
        end;
end end

function approx_class_declarations(env, sdecls) do
  return class_type_declarations$2(env, List.map(approx_class, sdecls))[0];
end end

register_error_of_exn((function (param) do
        if (param[0] == __Error$9) then do
          env = param[2];
          return error_of_printer(param[1], (function (param, param$1) do
                        env$1 = env;
                        ppf = param;
                        err = param$1;
                        return wrap_printing_env(env$1, (function (param) do
                                      env$2 = env$1;
                                      ppf$1 = ppf;
                                      param$1 = err;
                                      if (typeof param$1 == "number") then do
                                        return Format.fprintf(ppf$1, --[[ Format ]]{
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "A type parameter occurs several times",
                                                        --[[ End_of_format ]]0
                                                      }),
                                                    "A type parameter occurs several times"
                                                  });
                                      end else do
                                        local ___conditional___=(param$1.tag | 0);
                                        do
                                           if ___conditional___ = 0--[[ Unconsistent_constraint ]] then do
                                              Format.fprintf(ppf$1, --[[ Format ]]{
                                                    --[[ String_literal ]]Block.__(11, {
                                                        "The class constraints are not consistent.",
                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                            --[[ Flush_newline ]]4,
                                                            --[[ End_of_format ]]0
                                                          })
                                                      }),
                                                    "The class constraints are not consistent.@."
                                                  });
                                              return report_unification_error(ppf$1, env$2, undefined, param$1[0], (function (ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "Type",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "Type"
                                                                      });
                                                          end end), (function (ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "is not compatible with type",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "is not compatible with type"
                                                                      });
                                                          end end));end end end 
                                           if ___conditional___ = 1--[[ Field_type_mismatch ]] then do
                                              m = param$1[1];
                                              k = param$1[0];
                                              return report_unification_error(ppf$1, env$2, undefined, param$1[2], (function (ppf) do
                                                            return Curry._2(Format.fprintf(ppf, --[[ Format ]]{
                                                                            --[[ String_literal ]]Block.__(11, {
                                                                                "The ",
                                                                                --[[ String ]]Block.__(2, {
                                                                                    --[[ No_padding ]]0,
                                                                                    --[[ Char_literal ]]Block.__(12, {
                                                                                        --[[ " " ]]32,
                                                                                        --[[ String ]]Block.__(2, {
                                                                                            --[[ No_padding ]]0,
                                                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                                                --[[ Break ]]Block.__(0, {
                                                                                                    "@ ",
                                                                                                    1,
                                                                                                    0
                                                                                                  }),
                                                                                                --[[ String_literal ]]Block.__(11, {
                                                                                                    "has type",
                                                                                                    --[[ End_of_format ]]0
                                                                                                  })
                                                                                              })
                                                                                          })
                                                                                      })
                                                                                  })
                                                                              }),
                                                                            "The %s %s@ has type"
                                                                          }), k, m);
                                                          end end), (function (ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "but is expected to have type",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "but is expected to have type"
                                                                      });
                                                          end end));end end end 
                                           if ___conditional___ = 2--[[ Structure_expected ]] then do
                                              return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "This class expression is not a class structure; it has type",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Close_box ]]0,
                                                                                  --[[ End_of_format ]]0
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[This class expression is not a class structure; it has type@ %a@]"
                                                            }), class_type$2, param$1[0]);end end end 
                                           if ___conditional___ = 3--[[ Cannot_apply ]] then do
                                              return Format.fprintf(ppf$1, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "This class expression is not a class function, it cannot be applied",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "This class expression is not a class function, it cannot be applied"
                                                        });end end end 
                                           if ___conditional___ = 4--[[ Apply_wrong_label ]] then do
                                              mark_label = function (l) do
                                                if (l == "") then do
                                                  return "out label";
                                                end else do
                                                  return Curry._1(Format.sprintf(--[[ Format ]]{
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      " label ~",
                                                                      --[[ String ]]Block.__(2, {
                                                                          --[[ No_padding ]]0,
                                                                          --[[ End_of_format ]]0
                                                                        })
                                                                    }),
                                                                  " label ~%s"
                                                                }), l);
                                                end end 
                                              end end;
                                              return Curry._1(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "This argument cannot be applied with",
                                                                  --[[ String ]]Block.__(2, {
                                                                      --[[ No_padding ]]0,
                                                                      --[[ End_of_format ]]0
                                                                    })
                                                                }),
                                                              "This argument cannot be applied with%s"
                                                            }), mark_label(param$1[0]));end end end 
                                           if ___conditional___ = 5--[[ Pattern_type_clash ]] then do
                                              ty = param$1[0];
                                              reset(--[[ () ]]0);
                                              mark_loops(ty);
                                              return Curry._3(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String ]]Block.__(2, {
                                                                      --[[ No_padding ]]0,
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Close_box ]]0,
                                                                                  --[[ End_of_format ]]0
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[%s@ %a@]"
                                                            }), "This pattern cannot match self: it only matches values of type", type_expr$1, ty);end end end 
                                           if ___conditional___ = 6--[[ Unbound_class_2 ]] then do
                                              return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The class",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Break ]]Block.__(0, {
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    }),
                                                                                  --[[ String_literal ]]Block.__(11, {
                                                                                      "is not yet completely defined",
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Close_box ]]0,
                                                                                          --[[ End_of_format ]]0
                                                                                        })
                                                                                    })
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[The class@ %a@ is not yet completely defined@]"
                                                            }), longident, param$1[0]);end end end 
                                           if ___conditional___ = 7--[[ Unbound_class_type_2 ]] then do
                                              return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The class type",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Break ]]Block.__(0, {
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    }),
                                                                                  --[[ String_literal ]]Block.__(11, {
                                                                                      "is not yet completely defined",
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Close_box ]]0,
                                                                                          --[[ End_of_format ]]0
                                                                                        })
                                                                                    })
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[The class type@ %a@ is not yet completely defined@]"
                                                            }), longident, param$1[0]);end end end 
                                           if ___conditional___ = 8--[[ Abbrev_type_clash ]] then do
                                              expected = param$1[2];
                                              actual = param$1[1];
                                              abbrev = param$1[0];
                                              reset_and_mark_loops_list(--[[ :: ]]{
                                                    abbrev,
                                                    --[[ :: ]]{
                                                      actual,
                                                      --[[ :: ]]{
                                                        expected,
                                                        --[[ [] ]]0
                                                      }
                                                    }
                                                  });
                                              return Curry._6(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The abbreviation",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Break ]]Block.__(0, {
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    }),
                                                                                  --[[ String_literal ]]Block.__(11, {
                                                                                      "expands to type",
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Break ]]Block.__(0, {
                                                                                              "@ ",
                                                                                              1,
                                                                                              0
                                                                                            }),
                                                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                  --[[ Break ]]Block.__(0, {
                                                                                                      "@ ",
                                                                                                      1,
                                                                                                      0
                                                                                                    }),
                                                                                                  --[[ String_literal ]]Block.__(11, {
                                                                                                      "but is used with type",
                                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                                          --[[ Break ]]Block.__(0, {
                                                                                                              "@ ",
                                                                                                              1,
                                                                                                              0
                                                                                                            }),
                                                                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                                  --[[ Close_box ]]0,
                                                                                                                  --[[ End_of_format ]]0
                                                                                                                })})
                                                                                                        })
                                                                                                    })
                                                                                                })})
                                                                                        })
                                                                                    })
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[The abbreviation@ %a@ expands to type@ %a@ but is used with type@ %a@]"
                                                            }), type_expr$1, abbrev, type_expr$1, actual, type_expr$1, expected);end end end 
                                           if ___conditional___ = 9--[[ Constructor_type_mismatch ]] then do
                                              c = param$1[0];
                                              return report_unification_error(ppf$1, env$2, undefined, param$1[1], (function (ppf) do
                                                            return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                                            --[[ String_literal ]]Block.__(11, {
                                                                                "The expression \"new ",
                                                                                --[[ String ]]Block.__(2, {
                                                                                    --[[ No_padding ]]0,
                                                                                    --[[ String_literal ]]Block.__(11, {
                                                                                        "\" has type",
                                                                                        --[[ End_of_format ]]0
                                                                                      })
                                                                                  })
                                                                              }),
                                                                            "The expression \"new %s\" has type"
                                                                          }), c);
                                                          end end), (function (ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "but is used with type",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "but is used with type"
                                                                      });
                                                          end end));end end end 
                                           if ___conditional___ = 10--[[ Virtual_class ]] then do
                                              vals = param$1[3];
                                              mets = param$1[2];
                                              imm = param$1[1];
                                              cl = param$1[0];
                                              print_mets = function (ppf, mets) do
                                                return List.iter((function (met) do
                                                              return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Break ]]Block.__(0, {
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    }),
                                                                                  --[[ String ]]Block.__(2, {
                                                                                      --[[ No_padding ]]0,
                                                                                      --[[ End_of_format ]]0
                                                                                    })
                                                                                }),
                                                                              "@ %s"
                                                                            }), met);
                                                            end end), mets);
                                              end end;
                                              missings = mets and (
                                                  vals and "methods and variables" or "methods"
                                                ) or "variables";
                                              print_msg = function (ppf) do
                                                if (imm) then do
                                                  return Curry._1(Format.fprintf(ppf, --[[ Format ]]{
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "This object has virtual ",
                                                                      --[[ String ]]Block.__(2, {
                                                                          --[[ No_padding ]]0,
                                                                          --[[ End_of_format ]]0
                                                                        })
                                                                    }),
                                                                  "This object has virtual %s"
                                                                }), missings);
                                                end else if (cl) then do
                                                  return Format.fprintf(ppf, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "This class should be virtual",
                                                                  --[[ End_of_format ]]0
                                                                }),
                                                              "This class should be virtual"
                                                            });
                                                end else do
                                                  return Format.fprintf(ppf, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "This class type should be virtual",
                                                                  --[[ End_of_format ]]0
                                                                }),
                                                              "This class type should be virtual"
                                                            });
                                                end end  end 
                                              end end;
                                              return Curry._4(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ Theta ]]Block.__(16, {--[[ Char_literal ]]Block.__(12, {
                                                                          --[[ "." ]]46,
                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Break ]]Block.__(0, {
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                }),
                                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                                        --[[ String_literal ]]Block.__(11, {
                                                                                            "<2>",
                                                                                            --[[ End_of_format ]]0
                                                                                          }),
                                                                                        "<2>"
                                                                                      }}),
                                                                                  --[[ String_literal ]]Block.__(11, {
                                                                                      "The following ",
                                                                                      --[[ String ]]Block.__(2, {
                                                                                          --[[ No_padding ]]0,
                                                                                          --[[ String_literal ]]Block.__(11, {
                                                                                              " are undefined :",
                                                                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                      --[[ Close_box ]]0,
                                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                                          --[[ Close_box ]]0,
                                                                                                          --[[ End_of_format ]]0
                                                                                                        })
                                                                                                    })})
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })
                                                                            })
                                                                        })})
                                                                }),
                                                              "@[%t.@ @[<2>The following %s are undefined :%a@]@]"
                                                            }), print_msg, missings, print_mets, Pervasives.$at(mets, vals));end end end 
                                           if ___conditional___ = 11--[[ Parameter_arity_mismatch ]] then do
                                              return Curry._4(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The class constructor ",
                                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Break ]]Block.__(0, {
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                }),
                                                                              --[[ String_literal ]]Block.__(11, {
                                                                                  "expects ",
                                                                                  --[[ Int ]]Block.__(4, {
                                                                                      --[[ Int_i ]]3,
                                                                                      --[[ No_padding ]]0,
                                                                                      --[[ No_precision ]]0,
                                                                                      --[[ String_literal ]]Block.__(11, {
                                                                                          " type argument(s),",
                                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                                              --[[ Break ]]Block.__(0, {
                                                                                                  "@ ",
                                                                                                  1,
                                                                                                  0
                                                                                                }),
                                                                                              --[[ String_literal ]]Block.__(11, {
                                                                                                  "but is here applied to ",
                                                                                                  --[[ Int ]]Block.__(4, {
                                                                                                      --[[ Int_i ]]3,
                                                                                                      --[[ No_padding ]]0,
                                                                                                      --[[ No_precision ]]0,
                                                                                                      --[[ String_literal ]]Block.__(11, {
                                                                                                          " type argument(s)",
                                                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                                                              --[[ Close_box ]]0,
                                                                                                              --[[ End_of_format ]]0
                                                                                                            })
                                                                                                        })
                                                                                                    })
                                                                                                })
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })
                                                                            })})
                                                                    })
                                                                }),
                                                              "@[The class constructor %a@ expects %i type argument(s),@ but is here applied to %i type argument(s)@]"
                                                            }), longident, param$1[0], param$1[1], param$1[2]);end end end 
                                           if ___conditional___ = 12--[[ Parameter_mismatch ]] then do
                                              return report_unification_error(ppf$1, env$2, undefined, param$1[0], (function (ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "The type parameter",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "The type parameter"
                                                                      });
                                                          end end), (function (ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "does not meet its constraint: it should be",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "does not meet its constraint: it should be"
                                                                      });
                                                          end end));end end end 
                                           if ___conditional___ = 13--[[ Bad_parameters ]] then do
                                              cstrs = param$1[2];
                                              params = param$1[1];
                                              reset_and_mark_loops_list(--[[ :: ]]{
                                                    params,
                                                    --[[ :: ]]{
                                                      cstrs,
                                                      --[[ [] ]]0
                                                    }
                                                  });
                                              return Curry._6(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The abbreviation ",
                                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Break ]]Block.__(0, {
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                }),
                                                                              --[[ String_literal ]]Block.__(11, {
                                                                                  "is used with parameters",
                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Break ]]Block.__(0, {
                                                                                          "@ ",
                                                                                          1,
                                                                                          0
                                                                                        }),
                                                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                              --[[ Break ]]Block.__(0, {
                                                                                                  "@ ",
                                                                                                  1,
                                                                                                  0
                                                                                                }),
                                                                                              --[[ String_literal ]]Block.__(11, {
                                                                                                  "wich are incompatible with constraints",
                                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                                      --[[ Break ]]Block.__(0, {
                                                                                                          "@ ",
                                                                                                          1,
                                                                                                          0
                                                                                                        }),
                                                                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                              --[[ Close_box ]]0,
                                                                                                              --[[ End_of_format ]]0
                                                                                                            })})
                                                                                                    })
                                                                                                })
                                                                                            })})
                                                                                    })
                                                                                })
                                                                            })})
                                                                    })
                                                                }),
                                                              "@[The abbreviation %a@ is used with parameters@ %a@ wich are incompatible with constraints@ %a@]"
                                                            }), ident$3, param$1[0], type_expr$1, params, type_expr$1, cstrs);end end end 
                                           if ___conditional___ = 14--[[ Class_match_failure ]] then do
                                              return report_error$3(ppf$1, param$1[0]);end end end 
                                           if ___conditional___ = 15--[[ Unbound_val ]] then do
                                              return Curry._1(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "Unbound instance variable ",
                                                                  --[[ String ]]Block.__(2, {
                                                                      --[[ No_padding ]]0,
                                                                      --[[ End_of_format ]]0
                                                                    })
                                                                }),
                                                              "Unbound instance variable %s"
                                                            }), param$1[0]);end end end 
                                           if ___conditional___ = 16--[[ Unbound_type_var ]] then do
                                              print_common = function (ppf, kind, ty0, real, lab, ty) do
                                                ty1 = real and ty0 or newty2(100000000, --[[ Tobject ]]Block.__(4, {
                                                          ty0,
                                                          do
                                                            contents: undefined
                                                          end
                                                        }));
                                                mark_loops(ty1);
                                                return Curry._6(Format.fprintf(ppf, --[[ Format ]]{
                                                                --[[ String_literal ]]Block.__(11, {
                                                                    "The ",
                                                                    --[[ String ]]Block.__(2, {
                                                                        --[[ No_padding ]]0,
                                                                        --[[ Char_literal ]]Block.__(12, {
                                                                            --[[ " " ]]32,
                                                                            --[[ String ]]Block.__(2, {
                                                                                --[[ No_padding ]]0,
                                                                                --[[ Formatting_lit ]]Block.__(17, {
                                                                                    --[[ Break ]]Block.__(0, {
                                                                                        "@ ",
                                                                                        1,
                                                                                        0
                                                                                      }),
                                                                                    --[[ String_literal ]]Block.__(11, {
                                                                                        "has type",
                                                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                                                            --[[ Break ]]Block.__(0, {
                                                                                                "@;<1 2>",
                                                                                                1,
                                                                                                2
                                                                                              }),
                                                                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                    --[[ Break ]]Block.__(0, {
                                                                                                        "@ ",
                                                                                                        1,
                                                                                                        0
                                                                                                      }),
                                                                                                    --[[ String_literal ]]Block.__(11, {
                                                                                                        "where",
                                                                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                                                                            --[[ Break ]]Block.__(0, {
                                                                                                                "@ ",
                                                                                                                1,
                                                                                                                0
                                                                                                              }),
                                                                                                            --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                                    --[[ Break ]]Block.__(0, {
                                                                                                                        "@ ",
                                                                                                                        1,
                                                                                                                        0
                                                                                                                      }),
                                                                                                                    --[[ String_literal ]]Block.__(11, {
                                                                                                                        "is unbound",
                                                                                                                        --[[ End_of_format ]]0
                                                                                                                      })
                                                                                                                  })})
                                                                                                          })
                                                                                                      })
                                                                                                  })})
                                                                                          })
                                                                                      })
                                                                                  })
                                                                              })
                                                                          })
                                                                      })
                                                                  }),
                                                                "The %s %s@ has type@;<1 2>%a@ where@ %a@ is unbound"
                                                              }), kind, lab, type_expr$1, ty, type_expr$1, ty0);
                                              end end;
                                              print_reason = function (ppf, param) do
                                                if (param.tag) then do
                                                  return print_common(ppf, "instance variable", param[0], param[1], param[2], param[3]);
                                                end else do
                                                  return print_common(ppf, "method", param[0], param[1], param[2], param[3]);
                                                end end 
                                              end end;
                                              reset(--[[ () ]]0);
                                              return Curry._3(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "<v>",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "<v>"
                                                                      }}),
                                                                  --[[ Formatting_gen ]]Block.__(18, {
                                                                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                            --[[ End_of_format ]]0,
                                                                            ""
                                                                          }}),
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          "Some type variables are unbound in this type:",
                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Break ]]Block.__(0, {
                                                                                  "@;<1 2>",
                                                                                  1,
                                                                                  2
                                                                                }),
                                                                              --[[ Theta ]]Block.__(16, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Close_box ]]0,
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Break ]]Block.__(0, {
                                                                                              "@ ",
                                                                                              1,
                                                                                              0
                                                                                            }),
                                                                                          --[[ Formatting_gen ]]Block.__(18, {
                                                                                              --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                                                    --[[ End_of_format ]]0,
                                                                                                    ""
                                                                                                  }}),
                                                                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                      --[[ Close_box ]]0,
                                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                                          --[[ Close_box ]]0,
                                                                                                          --[[ End_of_format ]]0
                                                                                                        })
                                                                                                    })})
                                                                                            })
                                                                                        })
                                                                                    })})
                                                                            })
                                                                        })
                                                                    })
                                                                }),
                                                              "@[<v>@[Some type variables are unbound in this type:@;<1 2>%t@]@ @[%a@]@]"
                                                            }), param$1[0], print_reason, param$1[1]);end end end 
                                           if ___conditional___ = 17--[[ Make_nongen_seltype ]] then do
                                              return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "<v>",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "<v>"
                                                                      }}),
                                                                  --[[ Formatting_gen ]]Block.__(18, {
                                                                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                            --[[ End_of_format ]]0,
                                                                            ""
                                                                          }}),
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          "Self type should not occur in the non-generic type",
                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Break ]]Block.__(0, {
                                                                                  "@;<1 2>",
                                                                                  1,
                                                                                  2
                                                                                }),
                                                                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Close_box ]]0,
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Break ]]Block.__(0, {
                                                                                              "@,",
                                                                                              0,
                                                                                              0
                                                                                            }),
                                                                                          --[[ String_literal ]]Block.__(11, {
                                                                                              "It would escape the scope of its class",
                                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                                  --[[ Close_box ]]0,
                                                                                                  --[[ End_of_format ]]0
                                                                                                })
                                                                                            })
                                                                                        })
                                                                                    })})
                                                                            })
                                                                        })
                                                                    })
                                                                }),
                                                              "@[<v>@[Self type should not occur in the non-generic type@;<1 2>%a@]@,It would escape the scope of its class@]"
                                                            }), type_scheme, param$1[0]);end end end 
                                           if ___conditional___ = 18--[[ Non_generalizable_class ]] then do
                                              id = param$1[0];
                                              return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The type of this class,",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                                                  --[[ "," ]]44,
                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Break ]]Block.__(0, {
                                                                                          "@ ",
                                                                                          1,
                                                                                          0
                                                                                        }),
                                                                                      --[[ String_literal ]]Block.__(11, {
                                                                                          "contains type variables that cannot be generalized",
                                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                                              --[[ Close_box ]]0,
                                                                                              --[[ End_of_format ]]0
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[The type of this class,@ %a,@ contains type variables that cannot be generalized@]"
                                                            }), (function (param, param$1) do
                                                            return class_declaration$1(id, param, param$1);
                                                          end end), param$1[1]);end end end 
                                           if ___conditional___ = 19--[[ Cannot_coerce_self ]] then do
                                              return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The type of self cannot be coerced to",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ String_literal ]]Block.__(11, {
                                                                              "the type of the current class:",
                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Break ]]Block.__(0, {
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    }),
                                                                                  --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                                                          --[[ "." ]]46,
                                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                                              --[[ Flush_newline ]]4,
                                                                                              --[[ String_literal ]]Block.__(11, {
                                                                                                  "Some occurrences are contravariant",
                                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                                      --[[ Close_box ]]0,
                                                                                                      --[[ End_of_format ]]0
                                                                                                    })
                                                                                                })
                                                                                            })
                                                                                        })})
                                                                                })
                                                                            })
                                                                        })
                                                                    })
                                                                }),
                                                              "@[The type of self cannot be coerced to@ the type of the current class:@ %a.@.Some occurrences are contravariant@]"
                                                            }), type_scheme, param$1[0]);end end end 
                                           if ___conditional___ = 20--[[ Non_collapsable_conjunction ]] then do
                                              id$1 = param$1[0];
                                              Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                        --[[ Formatting_gen ]]Block.__(18, {
                                                            --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                  --[[ End_of_format ]]0,
                                                                  ""
                                                                }}),
                                                            --[[ String_literal ]]Block.__(11, {
                                                                "The type of this class,",
                                                                --[[ Formatting_lit ]]Block.__(17, {
                                                                    --[[ Break ]]Block.__(0, {
                                                                        "@ ",
                                                                        1,
                                                                        0
                                                                      }),
                                                                    --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                                            --[[ "," ]]44,
                                                                            --[[ Formatting_lit ]]Block.__(17, {
                                                                                --[[ Break ]]Block.__(0, {
                                                                                    "@ ",
                                                                                    1,
                                                                                    0
                                                                                  }),
                                                                                --[[ String_literal ]]Block.__(11, {
                                                                                    "contains non-collapsible conjunctive types in constraints",
                                                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                                                        --[[ Close_box ]]0,
                                                                                        --[[ End_of_format ]]0
                                                                                      })
                                                                                  })
                                                                              })
                                                                          })})
                                                                  })
                                                              })
                                                          }),
                                                        "@[The type of this class,@ %a,@ contains non-collapsible conjunctive types in constraints@]"
                                                      }), (function (param, param$1) do
                                                      return class_declaration$1(id$1, param, param$1);
                                                    end end), param$1[1]);
                                              return report_unification_error(ppf$1, env$2, undefined, param$1[2], (function (ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "Type",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "Type"
                                                                      });
                                                          end end), (function (ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "is not compatible with type",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "is not compatible with type"
                                                                      });
                                                          end end));end end end 
                                           if ___conditional___ = 21--[[ Final_self_clash ]] then do
                                              return report_unification_error(ppf$1, env$2, undefined, param$1[0], (function (ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "This object is expected to have type",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "This object is expected to have type"
                                                                      });
                                                          end end), (function (ppf) do
                                                            return Format.fprintf(ppf, --[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "but actually has type",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "but actually has type"
                                                                      });
                                                          end end));end end end 
                                           if ___conditional___ = 22--[[ Mutability_mismatch ]] then do
                                              match = param$1[1] == --[[ Immutable ]]0 and --[[ tuple ]]{
                                                  "mutable",
                                                  "immutable"
                                                } or --[[ tuple ]]{
                                                  "immutable",
                                                  "mutable"
                                                };
                                              return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The instance variable is ",
                                                                      --[[ String ]]Block.__(2, {
                                                                          --[[ No_padding ]]0,
                                                                          --[[ Char_literal ]]Block.__(12, {
                                                                              --[[ ";" ]]59,
                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Break ]]Block.__(0, {
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    }),
                                                                                  --[[ String_literal ]]Block.__(11, {
                                                                                      "it cannot be redefined as ",
                                                                                      --[[ String ]]Block.__(2, {
                                                                                          --[[ No_padding ]]0,
                                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                                              --[[ Close_box ]]0,
                                                                                              --[[ End_of_format ]]0
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })
                                                                            })
                                                                        })
                                                                    })
                                                                }),
                                                              "@[The instance variable is %s;@ it cannot be redefined as %s@]"
                                                            }), match[0], match[1]);end end end 
                                           if ___conditional___ = 23--[[ No_overriding ]] then do
                                              name = param$1[1];
                                              if (name == "") then do
                                                return Curry._1(Format.fprintf(ppf$1, --[[ Format ]]{
                                                                --[[ Formatting_gen ]]Block.__(18, {
                                                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                          --[[ End_of_format ]]0,
                                                                          ""
                                                                        }}),
                                                                    --[[ String_literal ]]Block.__(11, {
                                                                        "This inheritance does not override any method",
                                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                                            --[[ Break ]]Block.__(0, {
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              }),
                                                                            --[[ String ]]Block.__(2, {
                                                                                --[[ No_padding ]]0,
                                                                                --[[ Formatting_lit ]]Block.__(17, {
                                                                                    --[[ Close_box ]]0,
                                                                                    --[[ End_of_format ]]0
                                                                                  })
                                                                              })
                                                                          })
                                                                      })
                                                                  }),
                                                                "@[This inheritance does not override any method@ %s@]"
                                                              }), "instance variable");
                                              end else do
                                                return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                                --[[ Formatting_gen ]]Block.__(18, {
                                                                    --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                          --[[ End_of_format ]]0,
                                                                          ""
                                                                        }}),
                                                                    --[[ String_literal ]]Block.__(11, {
                                                                        "The ",
                                                                        --[[ String ]]Block.__(2, {
                                                                            --[[ No_padding ]]0,
                                                                            --[[ String_literal ]]Block.__(11, {
                                                                                " `",
                                                                                --[[ String ]]Block.__(2, {
                                                                                    --[[ No_padding ]]0,
                                                                                    --[[ Char_literal ]]Block.__(12, {
                                                                                        --[[ "'" ]]39,
                                                                                        --[[ Formatting_lit ]]Block.__(17, {
                                                                                            --[[ Break ]]Block.__(0, {
                                                                                                "@ ",
                                                                                                1,
                                                                                                0
                                                                                              }),
                                                                                            --[[ String_literal ]]Block.__(11, {
                                                                                                "has no previous definition",
                                                                                                --[[ Formatting_lit ]]Block.__(17, {
                                                                                                    --[[ Close_box ]]0,
                                                                                                    --[[ End_of_format ]]0
                                                                                                  })
                                                                                              })
                                                                                          })
                                                                                      })
                                                                                  })
                                                                              })
                                                                          })
                                                                      })
                                                                  }),
                                                                "@[The %s `%s'@ has no previous definition@]"
                                                              }), param$1[0], name);
                                              end end end end end 
                                           if ___conditional___ = 24--[[ Duplicate ]] then do
                                              return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The ",
                                                                      --[[ String ]]Block.__(2, {
                                                                          --[[ No_padding ]]0,
                                                                          --[[ String_literal ]]Block.__(11, {
                                                                              " `",
                                                                              --[[ String ]]Block.__(2, {
                                                                                  --[[ No_padding ]]0,
                                                                                  --[[ Char_literal ]]Block.__(12, {
                                                                                      --[[ "'" ]]39,
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Break ]]Block.__(0, {
                                                                                              "@ ",
                                                                                              1,
                                                                                              0
                                                                                            }),
                                                                                          --[[ String_literal ]]Block.__(11, {
                                                                                              "has multiple definitions in this object",
                                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                                  --[[ Close_box ]]0,
                                                                                                  --[[ End_of_format ]]0
                                                                                                })
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })
                                                                            })
                                                                        })
                                                                    })
                                                                }),
                                                              "@[The %s `%s'@ has multiple definitions in this object@]"
                                                            }), param$1[0], param$1[1]);end end end 
                                           do
                                          
                                        end
                                      end end 
                                    end end));
                      end end), param[3]);
        end else if (param[0] == Error_forward$2) then do
          return param[1];
        end else do
          return ;
        end end  end 
      end end));

__Error$10 = Caml_exceptions.create("Ocaml_typedtree_test.Typemod.Error");

Error_forward$3 = Caml_exceptions.create("Ocaml_typedtree_test.Typemod.Error_forward");

function fst3(param) do
  return param[0];
end end

function path_concat(head, p) do
  local ___conditional___=(p.tag | 0);
  do
     if ___conditional___ = 0--[[ Pident ]] then do
        return --[[ Pdot ]]Block.__(1, {
                  --[[ Pident ]]Block.__(0, {head}),
                  p[0].name,
                  0
                });end end end 
     if ___conditional___ = 1--[[ Pdot ]] then do
        return --[[ Pdot ]]Block.__(1, {
                  path_concat(head, p[0]),
                  p[1],
                  p[2]
                });end end end 
     if ___conditional___ = 2--[[ Papply ]] then do
        throw {
              Caml_builtin_exceptions.assert_failure,
              --[[ tuple ]]{
                "typemod.ml",
                54,
                16
              }
            };end end end 
     do
    
  end
end end

function extract_sig(env, loc, mty) do
  match = scrape_alias(env, undefined, mty);
  if (match.tag == --[[ Mty_signature ]]1) then do
    return match[0];
  end else do
    throw {
          __Error$10,
          loc,
          env,
          --[[ Signature_expected ]]0
        };
  end end 
end end

function extract_sig_open(env, loc, mty) do
  match = scrape_alias(env, undefined, mty);
  if (match.tag == --[[ Mty_signature ]]1) then do
    return match[0];
  end else do
    throw {
          __Error$10,
          loc,
          env,
          --[[ Structure_expected ]]Block.__(3, {mty})
        };
  end end 
end end

function type_open_(toplevel, ovf, env, loc, lid) do
  match = find_module$1(env, lid.loc, lid.txt);
  path = match[0];
  sg = extract_sig_open(env, lid.loc, match[1].md_type);
  return --[[ tuple ]]{
          path,
          open_signature$1(loc, toplevel, ovf, path, sg, env)
        };
end end

function type_open$1(toplevel, env, sod) do
  match = type_open_(toplevel, sod.popen_override, env, sod.popen_loc, sod.popen_lid);
  path = match[0];
  od_open_txt = sod.popen_lid;
  od_open_override = sod.popen_override;
  od_open_loc = sod.popen_loc;
  od_open_attributes = sod.popen_attributes;
  od = do
    open_path: path,
    open_txt: od_open_txt,
    open_override: od_open_override,
    open_loc: od_open_loc,
    open_attributes: od_open_attributes
  end;
  return --[[ tuple ]]{
          path,
          match[1],
          od
        };
end end

type_module_type_of_fwd = do
  contents: (function (env, m) do
      throw {
            Caml_builtin_exceptions.assert_failure,
            --[[ tuple ]]{
              "typemod.ml",
              99,
              22
            }
          };
    end end)
end;

function add_rec_types(_env, _param) do
  while(true) do
    param = _param;
    env = _env;
    if (param) then do
      match = param[0];
      if (match.tag == --[[ Sig_type ]]1 and match[2] >= 2) then do
        _param = param[1];
        _env = add_type$1(true, match[0], match[1], env);
        continue ;
      end else do
        return env;
      end end 
    end else do
      return env;
    end end 
  end;
end end

function check_type_decl(env, loc, id, row_id, newdecl, decl, rs, rem) do
  env$1 = add_type$1(true, id, newdecl, env);
  env$2 = row_id ~= undefined and add_type$1(true, row_id, newdecl, env$1) or env$1;
  env$3 = rs == --[[ Trec_not ]]0 and env$2 or add_rec_types(env$2, rem);
  type_declarations$3(env$3, id, newdecl, decl);
  return check_coherence(env$3, loc, id, newdecl);
end end

function update_rec_next(rs, rem) do
  if (rs >= 2 or not rem) then do
    return rem;
  end else do
    match = rem[0];
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 1--[[ Sig_type ]] then do
          if (match[2] >= 2) then do
            return --[[ :: ]]{
                    --[[ Sig_type ]]Block.__(1, {
                        match[0],
                        match[1],
                        rs
                      }),
                    rem[1]
                  };
          end else do
            return rem;
          end end end end end 
       if ___conditional___ = 3--[[ Sig_module ]] then do
          if (match[2] >= 2) then do
            return --[[ :: ]]{
                    --[[ Sig_module ]]Block.__(3, {
                        match[0],
                        match[1],
                        rs
                      }),
                    rem[1]
                  };
          end else do
            return rem;
          end end end end end 
       do
      else do
        return rem;
        end end
        
    end
  end end 
end end

function merge_constraint(initial_env, loc, sg, constr) do
  lid;
  local ___conditional___=(constr.tag | 0);
  do
     if ___conditional___ = 0--[[ Pwith_type ]]
     or ___conditional___ = 1--[[ Pwith_module ]] then do
        lid = constr[0];end else 
     if ___conditional___ = 2--[[ Pwith_typesubst ]] then do
        s = constr[0].ptype_name;
        lid = do
          txt: --[[ Lident ]]Block.__(0, {s.txt}),
          loc: s.loc
        end;end else 
     if ___conditional___ = 3--[[ Pwith_modsubst ]] then do
        s$1 = constr[0];
        lid = do
          txt: --[[ Lident ]]Block.__(0, {s$1.txt}),
          loc: s$1.loc
        end;end else 
     do end end end end
    
  end
  real_id = do
    contents: undefined
  end;
  merge = function (env, _sg, namelist, _row_id) do
    while(true) do
      row_id = _row_id;
      sg = _sg;
      if (sg) then do
        item = sg[0];
        local ___conditional___=(item.tag | 0);
        do
           if ___conditional___ = 1--[[ Sig_type ]] then do
              if (namelist and not namelist[1]) then do
                s = namelist[0];
                rem = sg[1];
                rs = item[2];
                decl = item[1];
                id = item[0];
                exit = 0;
                local ___conditional___=(constr.tag | 0);
                do
                   if ___conditional___ = 0--[[ Pwith_type ]] then do
                      sdecl = constr[1];
                      match = sdecl.ptype_kind;
                      exit$1 = 0;
                      if (typeof match == "number" and not (match ~= 0 or not (id.name == s and is_fixed_type(sdecl)))) then do
                        decl_row_type_params = List.map((function (param) do
                                return newty2(100000000, --[[ Tvar ]]Block.__(0, {undefined}));
                              end end), sdecl.ptype_params);
                        decl_row_type_arity = List.length(sdecl.ptype_params);
                        decl_row_type_variance = List.map((function (param) do
                                match;
                                local ___conditional___=(param[1]);
                                do
                                   if ___conditional___ = 0--[[ Covariant ]] then do
                                      match = --[[ tuple ]]{
                                        true,
                                        false
                                      };end else 
                                   if ___conditional___ = 1--[[ Contravariant ]] then do
                                      match = --[[ tuple ]]{
                                        false,
                                        true
                                      };end else 
                                   if ___conditional___ = 2--[[ Invariant ]] then do
                                      match = --[[ tuple ]]{
                                        false,
                                        false
                                      };end else 
                                   do end end end end
                                  
                                end
                                p = not match[1];
                                n = not match[0];
                                i = false;
                                return Curry._3(Types_Variance.set, --[[ May_pos ]]0, p, Curry._3(Types_Variance.set, --[[ May_neg ]]1, n, Curry._3(Types_Variance.set, --[[ May_weak ]]2, n, Curry._3(Types_Variance.set, --[[ Inj ]]3, i, Types_Variance.__null))));
                              end end), sdecl.ptype_params);
                        decl_row_type_loc = sdecl.ptype_loc;
                        decl_row = do
                          type_params: decl_row_type_params,
                          type_arity: decl_row_type_arity,
                          type_kind: --[[ Type_abstract ]]0,
                          type_private: --[[ Private ]]0,
                          type_manifest: undefined,
                          type_variance: decl_row_type_variance,
                          type_newtype_level: undefined,
                          type_loc: decl_row_type_loc,
                          type_attributes: --[[ [] ]]0
                        end;
                        id_row = create(s .. "#row");
                        initial_env$1 = add_type$1(true, id_row, decl_row, initial_env);
                        tdecl = transl_with_constraint(initial_env$1, id, --[[ Pident ]]Block.__(0, {id_row}), decl, sdecl);
                        newdecl = tdecl.typ_type;
                        check_type_decl(env, sdecl.ptype_loc, id, row_id, newdecl, decl, rs, rem);
                        decl_row_type_params$1 = newdecl.type_params;
                        decl_row_type_arity$1 = decl_row_type_arity;
                        decl_row_type_variance$1 = decl_row_type_variance;
                        decl_row_type_loc$1 = decl_row_type_loc;
                        decl_row$1 = do
                          type_params: decl_row_type_params$1,
                          type_arity: decl_row_type_arity$1,
                          type_kind: --[[ Type_abstract ]]0,
                          type_private: --[[ Private ]]0,
                          type_manifest: undefined,
                          type_variance: decl_row_type_variance$1,
                          type_newtype_level: undefined,
                          type_loc: decl_row_type_loc$1,
                          type_attributes: --[[ [] ]]0
                        end;
                        rs$prime = rs == --[[ Trec_first ]]1 and --[[ Trec_not ]]0 or rs;
                        return --[[ tuple ]]{
                                --[[ tuple ]]{
                                  --[[ Pident ]]Block.__(0, {id}),
                                  lid,
                                  --[[ Twith_type ]]Block.__(0, {tdecl})
                                },
                                --[[ :: ]]{
                                  --[[ Sig_type ]]Block.__(1, {
                                      id_row,
                                      decl_row$1,
                                      rs$prime
                                    }),
                                  --[[ :: ]]{
                                    --[[ Sig_type ]]Block.__(1, {
                                        id,
                                        newdecl,
                                        rs
                                      }),
                                    rem
                                  }
                                }
                              };
                      end else do
                        exit$1 = 3;
                      end end 
                      if (exit$1 == 3) then do
                        if (id.name == s) then do
                          tdecl$1 = transl_with_constraint(initial_env, id, undefined, decl, sdecl);
                          newdecl$1 = tdecl$1.typ_type;
                          check_type_decl(env, sdecl.ptype_loc, id, row_id, newdecl$1, decl, rs, rem);
                          return --[[ tuple ]]{
                                  --[[ tuple ]]{
                                    --[[ Pident ]]Block.__(0, {id}),
                                    lid,
                                    --[[ Twith_type ]]Block.__(0, {tdecl$1})
                                  },
                                  --[[ :: ]]{
                                    --[[ Sig_type ]]Block.__(1, {
                                        id,
                                        newdecl$1,
                                        rs
                                      }),
                                    rem
                                  }
                                };
                        end else do
                          exit = 2;
                        end end 
                      end
                       end end else 
                   if ___conditional___ = 2--[[ Pwith_typesubst ]] then do
                      exit = 2;end else 
                   if ___conditional___ = 1--[[ Pwith_module ]]
                   or ___conditional___ = 3--[[ Pwith_modsubst ]]
                   do end end end
                  
                end
                if (exit == 2) then do
                  if (id.name == s .. "#row") then do
                    _row_id = id;
                    _sg = rem;
                    continue ;
                  end else if (constr.tag) then do
                    sdecl$1 = constr[0];
                    if (id.name == s) then do
                      tdecl$2 = transl_with_constraint(initial_env, id, undefined, decl, sdecl$1);
                      newdecl$2 = tdecl$2.typ_type;
                      check_type_decl(env, sdecl$1.ptype_loc, id, row_id, newdecl$2, decl, rs, rem);
                      real_id.contents = id;
                      return --[[ tuple ]]{
                              --[[ tuple ]]{
                                --[[ Pident ]]Block.__(0, {id}),
                                lid,
                                --[[ Twith_typesubst ]]Block.__(2, {tdecl$2})
                              },
                              update_rec_next(rs, rem)
                            };
                    end
                     end 
                  end
                   end  end 
                end
                 end 
              end
               end end else 
           if ___conditional___ = 3--[[ Sig_module ]] then do
              if (namelist) then do
                namelist$1 = namelist[1];
                s$1 = namelist[0];
                rem$1 = sg[1];
                rs$1 = item[2];
                md = item[1];
                id$1 = item[0];
                exit$2 = 0;
                if (namelist$1) then do
                  exit$2 = 2;
                end else do
                  local ___conditional___=(constr.tag | 0);
                  do
                     if ___conditional___ = 1--[[ Pwith_module ]] then do
                        lid$prime = constr[1];
                        if (id$1.name == s$1) then do
                          match$1 = find_module$1(initial_env, loc, lid$prime.txt);
                          md$prime = match$1[1];
                          path = match$1[0];
                          md$prime$prime_md_type = remove_aliases$1(env, md$prime.md_type);
                          md$prime$prime_md_attributes = md$prime.md_attributes;
                          md$prime$prime_md_loc = md$prime.md_loc;
                          md$prime$prime = do
                            md_type: md$prime$prime_md_type,
                            md_attributes: md$prime$prime_md_attributes,
                            md_loc: md$prime$prime_md_loc
                          end;
                          newmd = strengthen_decl(env, md$prime$prime, path);
                          modtypes$1(env, newmd.md_type, md.md_type);
                          return --[[ tuple ]]{
                                  --[[ tuple ]]{
                                    --[[ Pident ]]Block.__(0, {id$1}),
                                    lid,
                                    --[[ Twith_module ]]Block.__(1, {
                                        path,
                                        lid$prime
                                      })
                                  },
                                  --[[ :: ]]{
                                    --[[ Sig_module ]]Block.__(3, {
                                        id$1,
                                        newmd,
                                        rs$1
                                      }),
                                    rem$1
                                  }
                                };
                        end else do
                          exit$2 = 2;
                        end end end else 
                     if ___conditional___ = 0--[[ Pwith_type ]]
                     or ___conditional___ = 2--[[ Pwith_typesubst ]] then do
                        exit$2 = 2;end else 
                     if ___conditional___ = 3--[[ Pwith_modsubst ]] then do
                        lid$prime$1 = constr[1];
                        if (id$1.name == s$1) then do
                          match$2 = find_module$1(initial_env, loc, lid$prime$1.txt);
                          path$1 = match$2[0];
                          newmd$1 = strengthen_decl(env, match$2[1], path$1);
                          modtypes$1(env, newmd$1.md_type, md.md_type);
                          real_id.contents = id$1;
                          return --[[ tuple ]]{
                                  --[[ tuple ]]{
                                    --[[ Pident ]]Block.__(0, {id$1}),
                                    lid,
                                    --[[ Twith_modsubst ]]Block.__(3, {
                                        path$1,
                                        lid$prime$1
                                      })
                                  },
                                  update_rec_next(rs$1, rem$1)
                                };
                        end else do
                          exit$2 = 2;
                        end end end else 
                     do end end end end
                    
                  end
                end end 
                if (exit$2 == 2 and id$1.name == s$1) then do
                  match$3 = merge(env, extract_sig(env, loc, md.md_type), namelist$1, undefined);
                  match$4 = match$3[0];
                  return --[[ tuple ]]{
                          --[[ tuple ]]{
                            path_concat(id$1, match$4[0]),
                            lid,
                            match$4[2]
                          },
                          --[[ :: ]]{
                            --[[ Sig_module ]]Block.__(3, {
                                id$1,
                                do
                                  md_type: --[[ Mty_signature ]]Block.__(1, {match$3[1]}),
                                  md_attributes: md.md_attributes,
                                  md_loc: md.md_loc
                                end,
                                rs$1
                              }),
                            rem$1
                          }
                        };
                end
                 end 
              end
               end end else 
           do end end end
          else do
            end end
            
        end
        match$5 = merge(add_item(item, env), sg[1], namelist, row_id);
        return --[[ tuple ]]{
                match$5[0],
                --[[ :: ]]{
                  item,
                  match$5[1]
                }
              };
      end else do
        throw {
              __Error$10,
              loc,
              env,
              --[[ With_no_component ]]Block.__(4, {lid.txt})
            };
      end end 
    end;
  end end;
  try do
    names = flat(--[[ [] ]]0, lid.txt);
    match = merge(initial_env, sg, names, undefined);
    sg$1 = match[1];
    sg$2;
    if (names and not names[1]) then do
      local ___conditional___=(constr.tag | 0);
      do
         if ___conditional___ = 0--[[ Pwith_type ]]
         or ___conditional___ = 1--[[ Pwith_module ]] then do
            sg$2 = sg$1;end else 
         if ___conditional___ = 2--[[ Pwith_typesubst ]] then do
            sdecl = constr[0];
            match$1 = real_id.contents;
            id;
            if (match$1 ~= undefined) then do
              id = match$1;
            end else do
              throw {
                    Caml_builtin_exceptions.assert_failure,
                    --[[ tuple ]]{
                      "typemod.ml",
                      246,
                      38
                    }
                  };
            end end 
            lid$1;
            try do
              match$2 = sdecl.ptype_manifest;
              if (match$2 ~= undefined) then do
                match$3 = match$2.ptyp_desc;
                if (typeof match$3 == "number") then do
                  throw Pervasives.Exit;
                end else if (match$3.tag == --[[ Ptyp_constr ]]3) then do
                  stl = match$3[1];
                  if (List.length(stl) == List.length(sdecl.ptype_params)) then do
                    List.iter2((function (x, param) do
                            match = x.ptyp_desc;
                            if (typeof match == "number") then do
                              throw Pervasives.Exit;
                            end else if (match.tag) then do
                              throw Pervasives.Exit;
                            end else do
                              match$1 = param[0].ptyp_desc;
                              if (typeof match$1 == "number") then do
                                throw Pervasives.Exit;
                              end else if (match$1.tag) then do
                                throw Pervasives.Exit;
                              end else if (match[0] == match$1[0]) then do
                                return --[[ () ]]0;
                              end else do
                                throw Pervasives.Exit;
                              end end  end  end 
                            end end  end 
                          end end), stl, sdecl.ptype_params);
                    lid$1 = match$3[0];
                  end else do
                    throw Pervasives.Exit;
                  end end 
                end else do
                  throw Pervasives.Exit;
                end end  end 
              end else do
                throw Pervasives.Exit;
              end end 
            end
            catch (exn)do
              if (exn == Pervasives.Exit) then do
                throw {
                      __Error$10,
                      sdecl.ptype_loc,
                      initial_env,
                      --[[ With_need_typeconstr ]]2
                    };
              end
               end 
              throw exn;
            end
            match$4;
            try do
              match$4 = lookup_type$1(lid$1.txt, initial_env);
            end
            catch (exn$1)do
              if (exn$1 == Caml_builtin_exceptions.not_found) then do
                throw {
                      Caml_builtin_exceptions.assert_failure,
                      --[[ tuple ]]{
                        "typemod.ml",
                        263,
                        68
                      }
                    };
              end
               end 
              throw exn$1;
            end
            sub = add_type(id, match$4[0], identity);
            sg$2 = signature$2(sub, sg$1);end else 
         if ___conditional___ = 3--[[ Pwith_modsubst ]] then do
            match$5 = real_id.contents;
            id$1;
            if (match$5 ~= undefined) then do
              id$1 = match$5;
            end else do
              throw {
                    Caml_builtin_exceptions.assert_failure,
                    --[[ tuple ]]{
                      "typemod.ml",
                      269,
                      38
                    }
                  };
            end end 
            path = lookup_module$1(undefined, initial_env, loc, constr[1].txt);
            sub$1 = add_module(id$1, path, identity);
            sg$2 = signature$2(sub$1, sg$1);end else 
         do end end end end
        
      end
    end else do
      sg$2 = sg$1;
    end end 
    return --[[ tuple ]]{
            match[0],
            sg$2
          };
  end
  catch (raw_exn)do
    exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn$2[0] == __Error$5) then do
      throw {
            __Error$10,
            loc,
            initial_env,
            --[[ With_mismatch ]]Block.__(5, {
                lid.txt,
                exn$2[1]
              })
          };
    end
     end 
    throw exn$2;
  end
end end

function map_rec(fn, decls, rem) do
  if (decls) then do
    return --[[ :: ]]{
            Curry._2(fn, --[[ Trec_first ]]1, decls[0]),
            map_end(Curry._1(fn, --[[ Trec_next ]]2), decls[1], rem)
          };
  end else do
    return rem;
  end end 
end end

function map_rec_type(rec_flag, fn, decls, rem) do
  if (decls) then do
    first = rec_flag and --[[ Trec_first ]]1 or --[[ Trec_not ]]0;
    return --[[ :: ]]{
            Curry._2(fn, first, decls[0]),
            map_end(Curry._1(fn, --[[ Trec_next ]]2), decls[1], rem)
          };
  end else do
    return rem;
  end end 
end end

function map_rec_type_with_row_types(rec_flag, fn, decls, rem) do
  if (decls) then do
    d1 = decls[0];
    if (is_row_name(d1.typ_id.name)) then do
      return --[[ :: ]]{
              Curry._2(fn, --[[ Trec_not ]]0, d1),
              map_rec_type_with_row_types(rec_flag, fn, decls[1], rem)
            };
    end else do
      return map_rec_type(rec_flag, fn, decls, rem);
    end end 
  end else do
    return rem;
  end end 
end end

function rec_flag_of_ptype_declarations(tds) do
  is_nonrec = List.exists((function (td) do
          return List.exists((function (param) do
                        return param[0].txt == "nonrec";
                      end end), td.ptype_attributes);
        end end), tds);
  if (is_nonrec) then do
    return --[[ Nonrecursive ]]0;
  end else do
    return --[[ Recursive ]]1;
  end end 
end end

function map_ext(fn, exts, rem) do
  if (exts) then do
    return --[[ :: ]]{
            Curry._2(fn, --[[ Text_first ]]0, exts[0]),
            map_end(Curry._1(fn, --[[ Text_next ]]1), exts[1], rem)
          };
  end else do
    return rem;
  end end 
end end

function approx_modtype(env, _smty) do
  while(true) do
    smty = _smty;
    match = smty.pmty_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 0--[[ Pmty_ident ]] then do
          match$1 = find_modtype$1(env, smty.pmty_loc, match[0].txt);
          return --[[ Mty_ident ]]Block.__(0, {match$1[0]});end end end 
       if ___conditional___ = 1--[[ Pmty_signature ]] then do
          return --[[ Mty_signature ]]Block.__(1, {approx_sig(env, match[0])});end end end 
       if ___conditional___ = 2--[[ Pmty_functor ]] then do
          arg = may_map((function (param) do
                  return approx_modtype(env, param);
                end end), match[1]);
          match$2 = enter_module(true, match[0].txt, default_mty(arg), env);
          res = approx_modtype(match$2[1], match[2]);
          return --[[ Mty_functor ]]Block.__(2, {
                    match$2[0],
                    arg,
                    res
                  });end end end 
       if ___conditional___ = 3--[[ Pmty_with ]] then do
          _smty = match[0];
          continue ;end end end 
       if ___conditional___ = 4--[[ Pmty_typeof ]] then do
          return Curry._2(type_module_type_of_fwd.contents, env, match[0])[1];end end end 
       if ___conditional___ = 5--[[ Pmty_extension ]] then do
          throw {
                Error_forward$3,
                error_of_extension(match[0])
              };end end end 
       if ___conditional___ = 6--[[ Pmty_alias ]] then do
          path = lookup_module$1(undefined, env, smty.pmty_loc, match[0].txt);
          return --[[ Mty_alias ]]Block.__(3, {path});end end end 
       do
      
    end
  end;
end end

function approx_module_declaration(env, pmd) do
  return do
          md_type: approx_modtype(env, pmd.pmd_type),
          md_attributes: pmd.pmd_attributes,
          md_loc: pmd.pmd_loc
        end;
end end

function approx_sig(_env, _ssg) do
  while(true) do
    ssg = _ssg;
    env = _env;
    if (ssg) then do
      srem = ssg[1];
      match = ssg[0].psig_desc;
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 1--[[ Psig_type ]] then do
            sdecls = match[0];
            rec_flag = rec_flag_of_ptype_declarations(sdecls);
            decls = approx_type_decl(env, sdecls);
            rem = approx_sig(env, srem);
            return map_rec_type(rec_flag, (function (rs, param) do
                          return --[[ Sig_type ]]Block.__(1, {
                                    param[0],
                                    param[1],
                                    rs
                                  });
                        end end), decls, rem);end end end 
         if ___conditional___ = 4--[[ Psig_module ]] then do
            pmd = match[0];
            md = approx_module_declaration(env, pmd);
            match$1 = enter_module_declaration(undefined, pmd.pmd_name.txt, md, env);
            return --[[ :: ]]{
                    --[[ Sig_module ]]Block.__(3, {
                        match$1[0],
                        md,
                        --[[ Trec_not ]]0
                      }),
                    approx_sig(match$1[1], srem)
                  };end end end 
         if ___conditional___ = 5--[[ Psig_recmodule ]] then do
            decls$1 = List.map((function(env)do
                return function (pmd) do
                  return --[[ tuple ]]{
                          create(pmd.pmd_name.txt),
                          approx_module_declaration(env, pmd)
                        };
                end end
                end(env)), match[0]);
            newenv = List.fold_left((function (env, param) do
                    return add_module_declaration(undefined, param[0], param[1], env);
                  end end), env, decls$1);
            return map_rec((function (rs, param) do
                          return --[[ Sig_module ]]Block.__(3, {
                                    param[0],
                                    param[1],
                                    rs
                                  });
                        end end), decls$1, approx_sig(newenv, srem));end end end 
         if ___conditional___ = 6--[[ Psig_modtype ]] then do
            d = match[0];
            info = approx_modtype_info(env, d);
            match$2 = enter_modtype(d.pmtd_name.txt, info, env);
            return --[[ :: ]]{
                    --[[ Sig_modtype ]]Block.__(4, {
                        match$2[0],
                        info
                      }),
                    approx_sig(match$2[1], srem)
                  };end end end 
         if ___conditional___ = 7--[[ Psig_open ]] then do
            match$3 = type_open$1(undefined, env, match[0]);
            _ssg = srem;
            _env = match$3[1];
            continue ;end end end 
         if ___conditional___ = 8--[[ Psig_include ]] then do
            smty = match[0].pincl_mod;
            mty = approx_modtype(env, smty);
            sg = signature$2(identity, extract_sig(env, smty.pmty_loc, mty));
            newenv$1 = add_signature(sg, env);
            return Pervasives.$at(sg, approx_sig(newenv$1, srem));end end end 
         if ___conditional___ = 9--[[ Psig_class ]]
         or ___conditional___ = 10--[[ Psig_class_type ]]
         do
        else do
          _ssg = srem;
          continue ;
          end end
          
      end
      decls$2 = approx_class_declarations(env, match[0]);
      rem$1 = approx_sig(env, srem);
      return List.flatten(map_rec((function (rs, param) do
                        return --[[ :: ]]{
                                --[[ Sig_class_type ]]Block.__(6, {
                                    param[0],
                                    param[2],
                                    rs
                                  }),
                                --[[ :: ]]{
                                  --[[ Sig_type ]]Block.__(1, {
                                      param[3],
                                      param[4],
                                      rs
                                    }),
                                  --[[ :: ]]{
                                    --[[ Sig_type ]]Block.__(1, {
                                        param[5],
                                        param[6],
                                        rs
                                      }),
                                    --[[ [] ]]0
                                  }
                                }
                              };
                      end end), decls$2, --[[ :: ]]{
                      rem$1,
                      --[[ [] ]]0
                    }));
    end else do
      return --[[ [] ]]0;
    end end 
  end;
end end

function approx_modtype_info(env, sinfo) do
  return do
          mtd_type: may_map((function (param) do
                  return approx_modtype(env, param);
                end end), sinfo.pmtd_type),
          mtd_attributes: sinfo.pmtd_attributes,
          mtd_loc: sinfo.pmtd_loc
        end;
end end

function check_recmod_typedecls(env, sdecls, decls) do
  recmod_ids = List.map(fst3, decls);
  return List.iter2((function (pmd, param) do
                mty = param[2].mty_type;
                return List.iter((function (path) do
                              env$1 = env;
                              loc = pmd.pmd_type.pmty_loc;
                              recmod_ids$1 = recmod_ids;
                              path$1 = path;
                              decl = find_type_full(path, env)[0];
                              to_check = function (path) do
                                return List.exists((function (id) do
                                              return isfree(id, path);
                                            end end), recmod_ids$1);
                              end end;
                              check_well_founded_decl(env$1, loc, path$1, decl, to_check);
                              return check_recursion(env$1, loc, path$1, decl, to_check);
                            end end), type_paths(env, --[[ Pident ]]Block.__(0, {param[0]}), mty));
              end end), sdecls, decls);
end end

function height$12(param) do
  if (param) then do
    return param[--[[ h ]]3];
  end else do
    return 0;
  end end 
end end

function create$13(l, v, r) do
  hl = l and l[--[[ h ]]3] or 0;
  hr = r and r[--[[ h ]]3] or 0;
  return --[[ Node ]]{
          --[[ l ]]l,
          --[[ v ]]v,
          --[[ r ]]r,
          --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
        };
end end

function bal$12(l, v, r) do
  hl = l and l[--[[ h ]]3] or 0;
  hr = r and r[--[[ h ]]3] or 0;
  if (hl > (hr + 2 | 0)) then do
    if (l) then do
      lr = l[--[[ r ]]2];
      lv = l[--[[ v ]]1];
      ll = l[--[[ l ]]0];
      if (height$12(ll) >= height$12(lr)) then do
        return create$13(ll, lv, create$13(lr, v, r));
      end else if (lr) then do
        return create$13(create$13(ll, lv, lr[--[[ l ]]0]), lr[--[[ v ]]1], create$13(lr[--[[ r ]]2], v, r));
      end else do
        throw {
              Caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            };
      end end  end 
    end else do
      throw {
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          };
    end end 
  end else if (hr > (hl + 2 | 0)) then do
    if (r) then do
      rr = r[--[[ r ]]2];
      rv = r[--[[ v ]]1];
      rl = r[--[[ l ]]0];
      if (height$12(rr) >= height$12(rl)) then do
        return create$13(create$13(l, v, rl), rv, rr);
      end else if (rl) then do
        return create$13(create$13(l, v, rl[--[[ l ]]0]), rl[--[[ v ]]1], create$13(rl[--[[ r ]]2], rv, rr));
      end else do
        throw {
              Caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            };
      end end  end 
    end else do
      throw {
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          };
    end end 
  end else do
    return --[[ Node ]]{
            --[[ l ]]l,
            --[[ v ]]v,
            --[[ r ]]r,
            --[[ h ]]hl >= hr and hl + 1 | 0 or hr + 1 | 0
          };
  end end  end 
end end

function add$14(x, t) do
  if (t) then do
    r = t[--[[ r ]]2];
    v = t[--[[ v ]]1];
    l = t[--[[ l ]]0];
    c = Caml_primitive.caml_string_compare(x, v);
    if (c == 0) then do
      return t;
    end else if (c < 0) then do
      ll = add$14(x, l);
      if (l == ll) then do
        return t;
      end else do
        return bal$12(ll, v, r);
      end end 
    end else do
      rr = add$14(x, r);
      if (r == rr) then do
        return t;
      end else do
        return bal$12(l, v, rr);
      end end 
    end end  end 
  end else do
    return --[[ Node ]]{
            --[[ l : Empty ]]0,
            --[[ v ]]x,
            --[[ r : Empty ]]0,
            --[[ h ]]1
          };
  end end 
end end

function mem$7(x, _param) do
  while(true) do
    param = _param;
    if (param) then do
      c = Caml_primitive.caml_string_compare(x, param[--[[ v ]]1]);
      if (c == 0) then do
        return true;
      end else do
        _param = c < 0 and param[--[[ l ]]0] or param[--[[ r ]]2];
        continue ;
      end end 
    end else do
      return false;
    end end 
  end;
end end

function check(cl, loc, set_ref, name) do
  if (mem$7(name, set_ref.contents)) then do
    throw {
          __Error$10,
          loc,
          empty,
          --[[ Repeated_name ]]Block.__(6, {
              cl,
              name
            })
        };
  end
   end 
  set_ref.contents = add$14(name, set_ref.contents);
  return --[[ () ]]0;
end end

function check_name(cl, set_ref, name) do
  return check(cl, name.loc, set_ref, name.txt);
end end

function check_sig_item(type_names, module_names, modtype_names, loc, param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 1--[[ Sig_type ]] then do
        return check("type", loc, type_names, param[0].name);end end end 
     if ___conditional___ = 3--[[ Sig_module ]] then do
        return check("module", loc, module_names, param[0].name);end end end 
     if ___conditional___ = 4--[[ Sig_modtype ]] then do
        return check("module type", loc, modtype_names, param[0].name);end end end 
     do
    else do
      return --[[ () ]]0;
      end end
      
  end
end end

function remove_duplicates(val_ids, ext_ids, _param) do
  while(true) do
    param = _param;
    if (param) then do
      f = param[0];
      local ___conditional___=(f.tag | 0);
      do
         if ___conditional___ = 0--[[ Sig_value ]] then do
            id = f[0];
            if (List.exists((function(id)do
                  return function (param) do
                    return equal(id, param);
                  end end
                  end(id)), val_ids)) then do
              _param = param[1];
              continue ;
            end
             end end else 
         if ___conditional___ = 2--[[ Sig_typext ]] then do
            id$1 = f[0];
            exit = 0;
            if (f[2] ~= 0) then do
              exit = 2;
            end else do
              match = param[1];
              if (match) then do
                match$1 = match[0];
                if (match$1.tag == --[[ Sig_typext ]]2 and not (match$1[2] ~= 1 or not List.exists((function(id$1)do
                        return function (param) do
                          return equal(id$1, param);
                        end end
                        end(id$1)), ext_ids))) then do
                  _param = --[[ :: ]]{
                    --[[ Sig_typext ]]Block.__(2, {
                        match$1[0],
                        match$1[1],
                        --[[ Text_first ]]0
                      }),
                    match[1]
                  };
                  continue ;
                end else do
                  exit = 2;
                end end 
              end else do
                exit = 2;
              end end 
            end end 
            if (exit == 2 and List.exists((function(id$1)do
                  return function (param) do
                    return equal(id$1, param);
                  end end
                  end(id$1)), ext_ids)) then do
              _param = param[1];
              continue ;
            end
             end end else 
         do end end end
        else do
          end end
          
      end
      return --[[ :: ]]{
              f,
              remove_duplicates(val_ids, ext_ids, param[1])
            };
    end else do
      return --[[ [] ]]0;
    end end 
  end;
end end

function get_values(_param) do
  while(true) do
    param = _param;
    if (param) then do
      f = param[0];
      if (f.tag) then do
        _param = param[1];
        continue ;
      end else do
        return --[[ :: ]]{
                f[0],
                get_values(param[1])
              };
      end end 
    end else do
      return --[[ [] ]]0;
    end end 
  end;
end end

function get_extension_constructors(_param) do
  while(true) do
    param = _param;
    if (param) then do
      f = param[0];
      if (f.tag == --[[ Sig_typext ]]2) then do
        return --[[ :: ]]{
                f[0],
                get_extension_constructors(param[1])
              };
      end else do
        _param = param[1];
        continue ;
      end end 
    end else do
      return --[[ [] ]]0;
    end end 
  end;
end end

function transl_modtype_longident$1(loc, env, lid) do
  return find_modtype$1(env, loc, lid)[0];
end end

function transl_module_alias(loc, env, lid) do
  return lookup_module$1(undefined, env, loc, lid);
end end

function mkmty$1(desc, typ, env, loc, attrs) do
  mty = do
    mty_desc: desc,
    mty_type: typ,
    mty_env: env,
    mty_loc: loc,
    mty_attributes: attrs
  end;
  add_saved_type(--[[ Partial_module_type ]]Block.__(7, {mty}));
  return mty;
end end

function mksig$1(desc, env, loc) do
  sg = do
    sig_desc: desc,
    sig_env: env,
    sig_loc: loc
  end;
  add_saved_type(--[[ Partial_signature_item ]]Block.__(6, {sg}));
  return sg;
end end

function transl_modtype$1(env, smty) do
  loc = smty.pmty_loc;
  match = smty.pmty_desc;
  local ___conditional___=(match.tag | 0);
  do
     if ___conditional___ = 0--[[ Pmty_ident ]] then do
        lid = match[0];
        path = transl_modtype_longident$1(loc, env, lid.txt);
        return mkmty$1(--[[ Tmty_ident ]]Block.__(0, {
                      path,
                      lid
                    }), --[[ Mty_ident ]]Block.__(0, {path}), env, loc, smty.pmty_attributes);end end end 
     if ___conditional___ = 1--[[ Pmty_signature ]] then do
        sg = transl_signature(env, match[0]);
        return mkmty$1(--[[ Tmty_signature ]]Block.__(1, {sg}), --[[ Mty_signature ]]Block.__(1, {sg.sig_type}), env, loc, smty.pmty_attributes);end end end 
     if ___conditional___ = 2--[[ Pmty_functor ]] then do
        param = match[0];
        arg = may_map((function (param) do
                return transl_modtype$1(env, param);
              end end), match[1]);
        ty_arg = may_map((function (m) do
                return m.mty_type;
              end end), arg);
        match$1 = enter_module(true, param.txt, default_mty(ty_arg), env);
        id = match$1[0];
        init_def(currentstamp.contents);
        res = transl_modtype$1(match$1[1], match[2]);
        return mkmty$1(--[[ Tmty_functor ]]Block.__(2, {
                      id,
                      param,
                      arg,
                      res
                    }), --[[ Mty_functor ]]Block.__(2, {
                      id,
                      ty_arg,
                      res.mty_type
                    }), env, loc, smty.pmty_attributes);end end end 
     if ___conditional___ = 3--[[ Pmty_with ]] then do
        sbody = match[0];
        body = transl_modtype$1(env, sbody);
        init_sg = extract_sig(env, sbody.pmty_loc, body.mty_type);
        match$2 = List.fold_left((function (param, sdecl) do
                match = merge_constraint(env, smty.pmty_loc, param[1], sdecl);
                return --[[ tuple ]]{
                        --[[ :: ]]{
                          match[0],
                          param[0]
                        },
                        match[1]
                      };
              end end), --[[ tuple ]]{
              --[[ [] ]]0,
              init_sg
            }, match[1]);
        return mkmty$1(--[[ Tmty_with ]]Block.__(3, {
                      body,
                      List.rev(match$2[0])
                    }), modtype(identity, --[[ Mty_signature ]]Block.__(1, {match$2[1]})), env, loc, smty.pmty_attributes);end end end 
     if ___conditional___ = 4--[[ Pmty_typeof ]] then do
        match$3 = Curry._2(type_module_type_of_fwd.contents, env, match[0]);
        return mkmty$1(--[[ Tmty_typeof ]]Block.__(4, {match$3[0]}), match$3[1], env, loc, smty.pmty_attributes);end end end 
     if ___conditional___ = 5--[[ Pmty_extension ]] then do
        throw {
              Error_forward$3,
              error_of_extension(match[0])
            };end end end 
     if ___conditional___ = 6--[[ Pmty_alias ]] then do
        lid$1 = match[0];
        path$1 = transl_module_alias(loc, env, lid$1.txt);
        return mkmty$1(--[[ Tmty_alias ]]Block.__(5, {
                      path$1,
                      lid$1
                    }), --[[ Mty_alias ]]Block.__(3, {path$1}), env, loc, smty.pmty_attributes);end end end 
     do
    
  end
end end

function transl_signature(env, sg) do
  type_names = do
    contents: --[[ Empty ]]0
  end;
  module_names = do
    contents: --[[ Empty ]]0
  end;
  modtype_names = do
    contents: --[[ Empty ]]0
  end;
  transl_sig = function (env, sg) do
    init_def(currentstamp.contents);
    if (sg) then do
      srem = sg[1];
      item = sg[0];
      loc = item.psig_loc;
      match = item.psig_desc;
      local ___conditional___=(match.tag | 0);
      do
         if ___conditional___ = 0--[[ Psig_value ]] then do
            match$1 = transl_value_decl(env, item.psig_loc, match[0]);
            tdesc = match$1[0];
            match$2 = transl_sig(match$1[1], srem);
            rem = match$2[1];
            partial_arg = tdesc.val_id;
            return --[[ tuple ]]{
                    --[[ :: ]]{
                      mksig$1(--[[ Tsig_value ]]Block.__(0, {tdesc}), env, loc),
                      match$2[0]
                    },
                    List.exists((function (param) do
                            return equal(partial_arg, param);
                          end end), get_values(rem)) and rem or --[[ :: ]]{
                        --[[ Sig_value ]]Block.__(0, {
                            tdesc.val_id,
                            tdesc.val_val
                          }),
                        rem
                      },
                    match$2[2]
                  };end end end 
         if ___conditional___ = 1--[[ Psig_type ]] then do
            sdecls = match[0];
            rec_flag = rec_flag_of_ptype_declarations(sdecls);
            List.iter((function (decl) do
                    return check_name("type", type_names, decl.ptype_name);
                  end end), sdecls);
            match$3 = transl_type_decl(env, rec_flag, sdecls);
            decls = match$3[0];
            match$4 = transl_sig(match$3[1], srem);
            return --[[ tuple ]]{
                    --[[ :: ]]{
                      mksig$1(--[[ Tsig_type ]]Block.__(1, {decls}), env, loc),
                      match$4[0]
                    },
                    map_rec_type_with_row_types(rec_flag, (function (rs, td) do
                            return --[[ Sig_type ]]Block.__(1, {
                                      td.typ_id,
                                      td.typ_type,
                                      rs
                                    });
                          end end), decls, match$4[1]),
                    match$4[2]
                  };end end end 
         if ___conditional___ = 2--[[ Psig_typext ]] then do
            match$5 = transl_type_extension(false, env, item.psig_loc, match[0]);
            tyext = match$5[0];
            match$6 = transl_sig(match$5[1], srem);
            rem$1 = match$6[1];
            constructors = List.filter((function (ext) do
                      partial_arg = ext.ext_id;
                      return not List.exists((function (param) do
                                    return equal(partial_arg, param);
                                  end end), get_extension_constructors(rem$1));
                    end end))(tyext.tyext_constructors);
            return --[[ tuple ]]{
                    --[[ :: ]]{
                      mksig$1(--[[ Tsig_typext ]]Block.__(2, {tyext}), env, loc),
                      match$6[0]
                    },
                    map_ext((function (es, ext) do
                            return --[[ Sig_typext ]]Block.__(2, {
                                      ext.ext_id,
                                      ext.ext_type,
                                      es
                                    });
                          end end), constructors, rem$1),
                    match$6[2]
                  };end end end 
         if ___conditional___ = 3--[[ Psig_exception ]] then do
            match$7 = transl_exception(env, match[0]);
            ext = match$7[0];
            match$8 = transl_sig(match$7[1], srem);
            rem$2 = match$8[1];
            partial_arg$1 = ext.ext_id;
            shadowed = List.exists((function (param) do
                    return equal(partial_arg$1, param);
                  end end), get_extension_constructors(rem$2));
            return --[[ tuple ]]{
                    --[[ :: ]]{
                      mksig$1(--[[ Tsig_exception ]]Block.__(3, {ext}), env, loc),
                      match$8[0]
                    },
                    shadowed and rem$2 or --[[ :: ]]{
                        --[[ Sig_typext ]]Block.__(2, {
                            ext.ext_id,
                            ext.ext_type,
                            --[[ Text_exception ]]2
                          }),
                        rem$2
                      },
                    match$8[2]
                  };end end end 
         if ___conditional___ = 4--[[ Psig_module ]] then do
            pmd = match[0];
            check_name("module", module_names, pmd.pmd_name);
            tmty = transl_modtype$1(env, pmd.pmd_type);
            md_md_type = tmty.mty_type;
            md_md_attributes = pmd.pmd_attributes;
            md_md_loc = pmd.pmd_loc;
            md = do
              md_type: md_md_type,
              md_attributes: md_md_attributes,
              md_loc: md_md_loc
            end;
            match$9 = enter_module_declaration(undefined, pmd.pmd_name.txt, md, env);
            id = match$9[0];
            match$10 = transl_sig(match$9[1], srem);
            return --[[ tuple ]]{
                    --[[ :: ]]{
                      mksig$1(--[[ Tsig_module ]]Block.__(4, {do
                                md_id: id,
                                md_name: pmd.pmd_name,
                                md_type: tmty,
                                md_attributes: pmd.pmd_attributes,
                                md_loc: pmd.pmd_loc
                              end}), env, loc),
                      match$10[0]
                    },
                    --[[ :: ]]{
                      --[[ Sig_module ]]Block.__(3, {
                          id,
                          md,
                          --[[ Trec_not ]]0
                        }),
                      match$10[1]
                    },
                    match$10[2]
                  };end end end 
         if ___conditional___ = 5--[[ Psig_recmodule ]] then do
            sdecls$1 = match[0];
            List.iter((function (pmd) do
                    return check_name("module", module_names, pmd.pmd_name);
                  end end), sdecls$1);
            match$11 = transl_recmodule_modtypes(item.psig_loc, env, sdecls$1);
            decls$1 = match$11[0];
            match$12 = transl_sig(match$11[1], srem);
            return --[[ tuple ]]{
                    --[[ :: ]]{
                      mksig$1(--[[ Tsig_recmodule ]]Block.__(5, {decls$1}), env, loc),
                      match$12[0]
                    },
                    map_rec((function (rs, md) do
                            d_md_type = md.md_type.mty_type;
                            d_md_attributes = md.md_attributes;
                            d_md_loc = md.md_loc;
                            d = do
                              md_type: d_md_type,
                              md_attributes: d_md_attributes,
                              md_loc: d_md_loc
                            end;
                            return --[[ Sig_module ]]Block.__(3, {
                                      md.md_id,
                                      d,
                                      rs
                                    });
                          end end), decls$1, match$12[1]),
                    match$12[2]
                  };end end end 
         if ___conditional___ = 6--[[ Psig_modtype ]] then do
            match$13 = transl_modtype_decl(modtype_names, env, item.psig_loc, match[0]);
            match$14 = transl_sig(match$13[0], srem);
            return --[[ tuple ]]{
                    --[[ :: ]]{
                      mksig$1(--[[ Tsig_modtype ]]Block.__(6, {match$13[1]}), env, loc),
                      match$14[0]
                    },
                    --[[ :: ]]{
                      match$13[2],
                      match$14[1]
                    },
                    match$14[2]
                  };end end end 
         if ___conditional___ = 7--[[ Psig_open ]] then do
            match$15 = type_open$1(undefined, env, match[0]);
            match$16 = transl_sig(match$15[1], srem);
            return --[[ tuple ]]{
                    --[[ :: ]]{
                      mksig$1(--[[ Tsig_open ]]Block.__(7, {match$15[2]}), env, loc),
                      match$16[0]
                    },
                    match$16[1],
                    match$16[2]
                  };end end end 
         if ___conditional___ = 8--[[ Psig_include ]] then do
            sincl = match[0];
            smty = sincl.pincl_mod;
            tmty$1 = transl_modtype$1(env, smty);
            mty = tmty$1.mty_type;
            sg$1 = signature$2(identity, extract_sig(env, smty.pmty_loc, mty));
            partial_arg$2 = item.psig_loc;
            List.iter((function (param) do
                    return check_sig_item(type_names, module_names, modtype_names, partial_arg$2, param);
                  end end), sg$1);
            newenv = add_signature(sg$1, env);
            incl_incl_loc = sincl.pincl_loc;
            incl_incl_attributes = sincl.pincl_attributes;
            incl = do
              incl_mod: tmty$1,
              incl_type: sg$1,
              incl_loc: incl_incl_loc,
              incl_attributes: incl_incl_attributes
            end;
            match$17 = transl_sig(newenv, srem);
            rem$3 = match$17[1];
            return --[[ tuple ]]{
                    --[[ :: ]]{
                      mksig$1(--[[ Tsig_include ]]Block.__(8, {incl}), env, loc),
                      match$17[0]
                    },
                    Pervasives.$at(remove_duplicates(get_values(rem$3), get_extension_constructors(rem$3), sg$1), rem$3),
                    match$17[2]
                  };end end end 
         if ___conditional___ = 9--[[ Psig_class ]] then do
            cl = match[0];
            List.iter((function (param) do
                    return check_name("type", type_names, param.pci_name);
                  end end), cl);
            match$18 = class_descriptions(env, cl);
            classes = match$18[0];
            match$19 = transl_sig(match$18[1], srem);
            return --[[ tuple ]]{
                    --[[ :: ]]{
                      mksig$1(--[[ Tsig_class ]]Block.__(9, {List.map2((function (pcl, tcl) do
                                      return tcl[11];
                                    end end), cl, classes)}), env, loc),
                      match$19[0]
                    },
                    List.flatten(map_rec((function (rs, param) do
                                return --[[ :: ]]{
                                        --[[ Sig_class ]]Block.__(5, {
                                            param[0],
                                            param[2],
                                            rs
                                          }),
                                        --[[ :: ]]{
                                          --[[ Sig_class_type ]]Block.__(6, {
                                              param[3],
                                              param[4],
                                              rs
                                            }),
                                          --[[ :: ]]{
                                            --[[ Sig_type ]]Block.__(1, {
                                                param[5],
                                                param[6],
                                                rs
                                              }),
                                            --[[ :: ]]{
                                              --[[ Sig_type ]]Block.__(1, {
                                                  param[7],
                                                  param[8],
                                                  rs
                                                }),
                                              --[[ [] ]]0
                                            }
                                          }
                                        }
                                      };
                              end end), classes, --[[ :: ]]{
                              match$19[1],
                              --[[ [] ]]0
                            })),
                    match$19[2]
                  };end end end 
         if ___conditional___ = 10--[[ Psig_class_type ]] then do
            cl$1 = match[0];
            List.iter((function (param) do
                    return check_name("type", type_names, param.pci_name);
                  end end), cl$1);
            match$20 = class_type_declarations$2(env, cl$1);
            classes$1 = match$20[0];
            match$21 = transl_sig(match$20[1], srem);
            return --[[ tuple ]]{
                    --[[ :: ]]{
                      mksig$1(--[[ Tsig_class_type ]]Block.__(10, {List.map2((function (pcl, tcl) do
                                      return tcl[7];
                                    end end), cl$1, classes$1)}), env, loc),
                      match$21[0]
                    },
                    List.flatten(map_rec((function (rs, param) do
                                return --[[ :: ]]{
                                        --[[ Sig_class_type ]]Block.__(6, {
                                            param[0],
                                            param[2],
                                            rs
                                          }),
                                        --[[ :: ]]{
                                          --[[ Sig_type ]]Block.__(1, {
                                              param[3],
                                              param[4],
                                              rs
                                            }),
                                          --[[ :: ]]{
                                            --[[ Sig_type ]]Block.__(1, {
                                                param[5],
                                                param[6],
                                                rs
                                              }),
                                            --[[ [] ]]0
                                          }
                                        }
                                      };
                              end end), classes$1, --[[ :: ]]{
                              match$21[1],
                              --[[ [] ]]0
                            })),
                    match$21[2]
                  };end end end 
         if ___conditional___ = 11--[[ Psig_attribute ]] then do
            x = match[0];
            warning_attribute(--[[ :: ]]{
                  x,
                  --[[ [] ]]0
                });
            match$22 = transl_sig(env, srem);
            return --[[ tuple ]]{
                    --[[ :: ]]{
                      mksig$1(--[[ Tsig_attribute ]]Block.__(11, {x}), env, loc),
                      match$22[0]
                    },
                    match$22[1],
                    match$22[2]
                  };end end end 
         if ___conditional___ = 12--[[ Psig_extension ]] then do
            throw {
                  Error_forward$3,
                  error_of_extension(match[0])
                };end end end 
         do
        
      end
    end else do
      return --[[ tuple ]]{
              --[[ [] ]]0,
              --[[ [] ]]0,
              env
            };
    end end 
  end end;
  previous_saved_types = saved_types.contents;
  warning_enter_scope(--[[ () ]]0);
  match = transl_sig(in_signature(env), sg);
  sg_sig_items = match[0];
  sg_sig_type = match[1];
  sg_sig_final_env = match[2];
  sg$1 = do
    sig_items: sg_sig_items,
    sig_type: sg_sig_type,
    sig_final_env: sg_sig_final_env
  end;
  warning_leave_scope(--[[ () ]]0);
  saved_types.contents = --[[ :: ]]{
    --[[ Partial_signature ]]Block.__(5, {sg$1}),
    previous_saved_types
  };
  return sg$1;
end end

function transl_modtype_decl(modtype_names, env, loc, param) do
  pmtd_loc = param.pmtd_loc;
  pmtd_attributes = param.pmtd_attributes;
  pmtd_name = param.pmtd_name;
  check_name("module type", modtype_names, pmtd_name);
  tmty = may_map((function (param) do
          return transl_modtype$1(env, param);
        end end), param.pmtd_type);
  decl_mtd_type = may_map((function (t) do
          return t.mty_type;
        end end), tmty);
  decl = do
    mtd_type: decl_mtd_type,
    mtd_attributes: pmtd_attributes,
    mtd_loc: pmtd_loc
  end;
  match = enter_modtype(pmtd_name.txt, decl, env);
  id = match[0];
  mtd = do
    mtd_id: id,
    mtd_name: pmtd_name,
    mtd_type: tmty,
    mtd_attributes: pmtd_attributes,
    mtd_loc: pmtd_loc
  end;
  return --[[ tuple ]]{
          match[1],
          mtd,
          --[[ Sig_modtype ]]Block.__(4, {
              id,
              decl
            })
        };
end end

function transl_recmodule_modtypes(loc, env, sdecls) do
  make_env = function (curr) do
    return List.fold_left((function (env, param) do
                  return add_module$1(true, param[0], param[2], env);
                end end), env, curr);
  end end;
  make_env2 = function (curr) do
    return List.fold_left((function (env, param) do
                  return add_module$1(true, param[0], param[2].mty_type, env);
                end end), env, curr);
  end end;
  transition = function (env_c, curr) do
    return List.map2((function (pmd, param) do
                  return --[[ tuple ]]{
                          param[0],
                          param[1],
                          transl_modtype$1(env_c, pmd.pmd_type)
                        };
                end end), sdecls, curr);
  end end;
  ids = List.map((function (x) do
          return create(x.pmd_name.txt);
        end end), sdecls);
  approx_env = List.fold_left((function (env, id) do
          dummy = --[[ Mty_ident ]]Block.__(0, {--[[ Pident ]]Block.__(0, {create("#recmod#")})});
          return add_module$1(true, id, dummy, env);
        end end), env, ids);
  init = List.map2((function (id, pmd) do
          return --[[ tuple ]]{
                  id,
                  pmd.pmd_name,
                  approx_modtype(approx_env, pmd.pmd_type)
                };
        end end), ids, sdecls);
  env0 = make_env(init);
  dcl1 = transition(env0, init);
  env1 = make_env2(dcl1);
  check_recmod_typedecls(env1, sdecls, dcl1);
  dcl2 = transition(env1, dcl1);
  env2 = make_env2(dcl2);
  check_recmod_typedecls(env2, sdecls, dcl2);
  dcl2$1 = List.map2((function (pmd, param) do
          return do
                  md_id: param[0],
                  md_name: param[1],
                  md_type: param[2],
                  md_attributes: pmd.pmd_attributes,
                  md_loc: pmd.pmd_loc
                end;
        end end), sdecls, dcl2);
  return --[[ tuple ]]{
          dcl2$1,
          env2
        };
end end

function simplify_signature(sg) do
  aux = function (param) do
    if (param) then do
      component = param[0];
      local ___conditional___=(component.tag | 0);
      do
         if ___conditional___ = 0--[[ Sig_value ]] then do
            k = aux(param[1]);
            val_names = k[1];
            name = component[0].name;
            if (mem$7(name, val_names)) then do
              return k;
            end else do
              return --[[ tuple ]]{
                      --[[ :: ]]{
                        component,
                        k[0]
                      },
                      add$14(name, val_names),
                      k[2]
                    };
            end end end end end 
         if ___conditional___ = 2--[[ Sig_typext ]] then do
            k$1 = aux(param[1]);
            ext_names = k$1[2];
            val_names$1 = k$1[1];
            sg = k$1[0];
            name$1 = component[0].name;
            if (mem$7(name$1, ext_names)) then do
              if (component[2] ~= 0 or not sg) then do
                return k$1;
              end else do
                match = sg[0];
                if (match.tag == --[[ Sig_typext ]]2 and match[2] == 1) then do
                  return --[[ tuple ]]{
                          --[[ :: ]]{
                            --[[ Sig_typext ]]Block.__(2, {
                                match[0],
                                match[1],
                                --[[ Text_first ]]0
                              }),
                            sg[1]
                          },
                          val_names$1,
                          ext_names
                        };
                end else do
                  return k$1;
                end end 
              end end 
            end else do
              return --[[ tuple ]]{
                      --[[ :: ]]{
                        component,
                        sg
                      },
                      val_names$1,
                      add$14(name$1, ext_names)
                    };
            end end end end end 
         do
        else do
          match$1 = aux(param[1]);
          return --[[ tuple ]]{
                  --[[ :: ]]{
                    component,
                    match$1[0]
                  },
                  match$1[1],
                  match$1[2]
                };
          end end
          
      end
    end else do
      return --[[ tuple ]]{
              --[[ [] ]]0,
              --[[ Empty ]]0,
              --[[ Empty ]]0
            };
    end end 
  end end;
  return aux(sg)[0];
end end

Not_a_path = Caml_exceptions.create("Ocaml_typedtree_test.Typemod.Not_a_path");

function path_of_module(_mexp) do
  while(true) do
    mexp = _mexp;
    match = mexp.mod_desc;
    local ___conditional___=(match.tag | 0);
    do
       if ___conditional___ = 0--[[ Tmod_ident ]] then do
          return match[0];end end end 
       if ___conditional___ = 3--[[ Tmod_apply ]] then do
          if (applicative_functors.contents) then do
            return --[[ Papply ]]Block.__(2, {
                      path_of_module(match[0]),
                      path_of_module(match[1])
                    });
          end else do
            throw Not_a_path;
          end end end end end 
       if ___conditional___ = 4--[[ Tmod_constraint ]] then do
          _mexp = match[0];
          continue ;end end end 
       do
      else do
        throw Not_a_path;
        end end
        
    end
  end;
end end

function path_of_module$1(mexp) do
  try do
    return path_of_module(mexp);
  end
  catch (exn)do
    if (exn == Not_a_path) then do
      return ;
    end else do
      throw exn;
    end end 
  end
end end

function closed_modtype(_param) do
  while(true) do
    param = _param;
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ = 1--[[ Mty_signature ]] then do
          return List.for_all(closed_signature_item, param[0]);end end end 
       if ___conditional___ = 2--[[ Mty_functor ]] then do
          _param = param[2];
          continue ;end end end 
       if ___conditional___ = 0--[[ Mty_ident ]]
       or ___conditional___ = 3--[[ Mty_alias ]] then do
          return true;end end end 
       do
      
    end
  end;
end end

function closed_signature_item(param) do
  local ___conditional___=(param.tag | 0);
  do
     if ___conditional___ = 0--[[ Sig_value ]] then do
        return closed_schema(param[1].val_type);end end end 
     if ___conditional___ = 3--[[ Sig_module ]] then do
        return closed_modtype(param[1].md_type);end end end 
     do
    else do
      return true;
      end end
      
  end
end end

function anchor_submodule(name, anchor) do
  if (anchor ~= undefined) then do
    return --[[ Pdot ]]Block.__(1, {
              anchor,
              name,
              -1
            });
  end
   end 
end end

function enrich_type_decls(anchor, decls, oldenv, newenv) do
  if (anchor ~= undefined) then do
    p = anchor;
    return List.fold_left((function (e, info) do
                  id = info.typ_id;
                  info$prime = enrich_typedecl(oldenv, --[[ Pdot ]]Block.__(1, {
                          p,
                          id.name,
                          -1
                        }), info.typ_type);
                  return add_type$1(true, id, info$prime, e);
                end end), oldenv, decls);
  end else do
    return newenv;
  end end 
end end

function enrich_module_type(anchor, name, mty, env) do
  if (anchor ~= undefined) then do
    return enrich_modtype(env, --[[ Pdot ]]Block.__(1, {
                  anchor,
                  name,
                  -1
                }), mty);
  end else do
    return mty;
  end end 
end end

function check_recmodule_inclusion(env, bindings) do
  subst_and_strengthen = function (env, s, id, mty) do
    return strengthen$1(env, modtype(s, mty), module_path(s, --[[ Pident ]]Block.__(0, {id})));
  end end;
  _first_time = true;
  _n = List.length(bindings);
  _env = env;
  _s = identity;
  while(true) do
    s = _s;
    env$1 = _env;
    n = _n;
    first_time = _first_time;
    if (n > 0) then do
      bindings1 = List.map((function (param) do
              id = param[0];
              return --[[ tuple ]]{
                      id,
                      rename(id),
                      param[4]
                    };
            end end), bindings);
      env$prime = List.fold_left((function(first_time,s)do
          return function (env, param) do
            mty_actual = param[2];
            mty_actual$prime = first_time and mty_actual or subst_and_strengthen(env, s, param[0], mty_actual);
            return add_module$1(false, param[1], mty_actual$prime, env);
          end end
          end(first_time,s)), env$1, bindings1);
      s$prime = List.fold_left((function (s, param) do
              return add_module(param[0], --[[ Pident ]]Block.__(0, {param[1]}), s);
            end end), identity, bindings1);
      _s = s$prime;
      _env = env$prime;
      _n = n - 1 | 0;
      _first_time = false;
      continue ;
    end else do
      check_inclusion = (function(env$1,s)do
      return function check_inclusion(param) do
        modl = param[3];
        mty_decl = param[2];
        id = param[0];
        mty_decl$prime = modtype(s, mty_decl.mty_type);
        mty_actual$prime = subst_and_strengthen(env$1, s, id, param[4]);
        coercion;
        try do
          coercion = modtypes$1(env$1, mty_actual$prime, mty_decl$prime);
        end
        catch (raw_exn)do
          exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn[0] == __Error$5) then do
            throw {
                  __Error$10,
                  modl.mod_loc,
                  env$1,
                  --[[ Not_included ]]Block.__(1, {exn[1]})
                };
          end
           end 
          throw exn;
        end
        modl$prime_mod_desc = --[[ Tmod_constraint ]]Block.__(4, {
            modl,
            mty_decl.mty_type,
            --[[ Tmodtype_explicit ]]{mty_decl},
            coercion
          });
        modl$prime_mod_loc = modl.mod_loc;
        modl$prime_mod_type = mty_decl.mty_type;
        modl$prime = do
          mod_desc: modl$prime_mod_desc,
          mod_loc: modl$prime_mod_loc,
          mod_type: modl$prime_mod_type,
          mod_env: env$1,
          mod_attributes: --[[ [] ]]0
        end;
        return do
                mb_id: id,
                mb_name: param[1],
                mb_expr: modl$prime,
                mb_attributes: param[5],
                mb_loc: param[6]
              end;
      end end
      end(env$1,s));
      return List.map(check_inclusion, bindings);
    end end 
  end;
end end

function package_constraints(env, loc, mty, constrs) do
  if (constrs == --[[ [] ]]0) then do
    return mty;
  end else do
    sg = extract_sig(env, loc, mty);
    sg$prime = List.map((function (item) do
            local ___conditional___=(item.tag | 0);
            do
               if ___conditional___ = 1--[[ Sig_type ]] then do
                  td = item[1];
                  if (td.type_params) then do
                    return item;
                  end else do
                    id = item[0];
                    if (List.mem_assoc(--[[ :: ]]{
                            id.name,
                            --[[ [] ]]0
                          }, constrs)) then do
                      ty = List.assoc(--[[ :: ]]{
                            id.name,
                            --[[ [] ]]0
                          }, constrs);
                      return --[[ Sig_type ]]Block.__(1, {
                                id,
                                do
                                  type_params: td.type_params,
                                  type_arity: td.type_arity,
                                  type_kind: td.type_kind,
                                  type_private: td.type_private,
                                  type_manifest: ty,
                                  type_variance: td.type_variance,
                                  type_newtype_level: td.type_newtype_level,
                                  type_loc: td.type_loc,
                                  type_attributes: td.type_attributes
                                end,
                                item[2]
                              });
                    end else do
                      return item;
                    end end 
                  end end end end end 
               if ___conditional___ = 3--[[ Sig_module ]] then do
                  md = item[1];
                  id$1 = item[0];
                  aux = function (_param) do
                    while(true) do
                      param = _param;
                      if (param) then do
                        match = param[0];
                        match$1 = match[0];
                        if (match$1) then do
                          l = match$1[1];
                          if (l) then do
                            if (match$1[0] == id$1.name) then do
                              return --[[ :: ]]{
                                      --[[ tuple ]]{
                                        l,
                                        match[1]
                                      },
                                      aux(param[1])
                                    };
                            end else do
                              _param = param[1];
                              continue ;
                            end end 
                          end else do
                            _param = param[1];
                            continue ;
                          end end 
                        end else do
                          _param = param[1];
                          continue ;
                        end end 
                      end else do
                        return --[[ [] ]]0;
                      end end 
                    end;
                  end end;
                  md_md_type = package_constraints(env, loc, md.md_type, aux(constrs));
                  md_md_attributes = md.md_attributes;
                  md_md_loc = md.md_loc;
                  md$1 = do
                    md_type: md_md_type,
                    md_attributes: md_md_attributes,
                    md_loc: md_md_loc
                  end;
                  return --[[ Sig_module ]]Block.__(3, {
                            id$1,
                            md$1,
                            item[2]
                          });end end end 
               do
              else do
                return item;
                end end
                
            end
          end end), sg);
    return --[[ Mty_signature ]]Block.__(1, {sg$prime});
  end end 
end end

function modtype_of_package(env, loc, p, nl, tl) do
  try do
    match = find_modtype(p, env).mtd_type;
    exit = 0;
    if (match ~= undefined and nl ~= --[[ [] ]]0) then do
      return package_constraints(env, loc, match, List.combine(List.map(flatten, nl), tl));
    end else do
      exit = 1;
    end end 
    if (exit == 1) then do
      if (nl == --[[ [] ]]0) then do
        return --[[ Mty_ident ]]Block.__(0, {p});
      end else do
        throw {
              __Error$10,
              loc,
              env,
              --[[ Signature_expected ]]0
            };
      end end 
    end
     end 
  end
  catch (exn)do
    if (exn == Caml_builtin_exceptions.not_found) then do
      error = --[[ Unbound_modtype ]]Block.__(22, {lid_of_path(undefined, p)});
      throw {
            __Error$6,
            loc,
            env,
            error
          };
    end else do
      throw exn;
    end end 
  end
end end

function package_subtype$1(env, p1, nl1, tl1, p2, nl2, tl2) do
  mkmty = function (p, nl, tl) do
    ntl = List.filter((function (param) do
              return free_variables$1(undefined, param[1]) == --[[ [] ]]0;
            end end))(List.combine(nl, tl));
    match = List.split(ntl);
    return modtype_of_package(env, none, p, match[0], match[1]);
  end end;
  mty1 = mkmty(p1, nl1, tl1);
  mty2 = mkmty(p2, nl2, tl2);
  try do
    return modtypes$1(env, mty1, mty2) == --[[ Tcoerce_none ]]0;
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == __Error$5) then do
      return false;
    end else do
      throw exn;
    end end 
  end
end end

package_subtype.contents = package_subtype$1;

function wrap_constraint(env, arg, mty, explicit) do
  coercion;
  try do
    coercion = modtypes$1(env, arg.mod_type, mty);
  end
  catch (raw_exn)do
    exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] == __Error$5) then do
      throw {
            __Error$10,
            arg.mod_loc,
            env,
            --[[ Not_included ]]Block.__(1, {exn[1]})
          };
    end
     end 
    throw exn;
  end
  return do
          mod_desc: --[[ Tmod_constraint ]]Block.__(4, {
              arg,
              mty,
              explicit,
              coercion
            }),
          mod_loc: arg.mod_loc,
          mod_type: mty,
          mod_env: env,
          mod_attributes: --[[ [] ]]0
        end;
end end

function type_module$1(aliasOpt, sttn, funct_body, anchor, env, smod) do
  alias = aliasOpt ~= undefined and aliasOpt or false;
  match = smod.pmod_desc;
  local ___conditional___=(match.tag | 0);
  do
     if ___conditional___ = 0--[[ Pmod_ident ]] then do
        lid = match[0];
        path = lookup_module$1(not alias, env, smod.pmod_loc, lid.txt);
        md_mod_desc = --[[ Tmod_ident ]]Block.__(0, {
            path,
            lid
          });
        md_mod_loc = smod.pmod_loc;
        md_mod_type = --[[ Mty_alias ]]Block.__(3, {path});
        md_mod_attributes = smod.pmod_attributes;
        md = do
          mod_desc: md_mod_desc,
          mod_loc: md_mod_loc,
          mod_type: md_mod_type,
          mod_env: env,
          mod_attributes: md_mod_attributes
        end;
        node;
        if (alias and not is_functor_arg(path, env)) then do
          add_required_global(head(path));
          node = md;
        end else do
          mty = find_module(false, path, env).md_type;
          exit = 0;
          if (mty.tag == --[[ Mty_alias ]]3 and not alias) then do
            p1 = normalize_path$1(smod.pmod_loc, env, mty[0]);
            mty$1 = expand_module_alias(env, --[[ [] ]]0, p1);
            node = do
              mod_desc: --[[ Tmod_constraint ]]Block.__(4, {
                  md,
                  mty$1,
                  --[[ Tmodtype_implicit ]]0,
                  --[[ Tcoerce_alias ]]Block.__(3, {
                      p1,
                      --[[ Tcoerce_none ]]0
                    })
                }),
              mod_loc: md_mod_loc,
              mod_type: sttn and strengthen$1(env, mty$1, p1) or mty$1,
              mod_env: env,
              mod_attributes: md_mod_attributes
            end;
          end else do
            exit = 1;
          end end 
          if (exit == 1) then do
            mty$2 = sttn and strengthen$1(env, mty, path) or mty;
            node = do
              mod_desc: md_mod_desc,
              mod_loc: md_mod_loc,
              mod_type: mty$2,
              mod_env: env,
              mod_attributes: md_mod_attributes
            end;
          end
           end 
        end end 
        record$2(--[[ Ti_mod ]]Block.__(3, {node}));
        return node;end end end 
     if ___conditional___ = 1--[[ Pmod_structure ]] then do
        match$1 = type_structure(undefined, funct_body, anchor, env, match[0], smod.pmod_loc);
        sg = match$1[1];
        node_mod_desc = --[[ Tmod_structure ]]Block.__(1, {match$1[0]});
        node_mod_loc = smod.pmod_loc;
        node_mod_type = --[[ Mty_signature ]]Block.__(1, {sg});
        node_mod_attributes = smod.pmod_attributes;
        node$1 = do
          mod_desc: node_mod_desc,
          mod_loc: node_mod_loc,
          mod_type: node_mod_type,
          mod_env: env,
          mod_attributes: node_mod_attributes
        end;
        record$2(--[[ Ti_mod ]]Block.__(3, {node$1}));
        sg$prime = simplify_signature(sg);
        if (List.length(sg$prime) == List.length(sg)) then do
          return node$1;
        end else do
          return wrap_constraint(implicit_coercion(env), node$1, --[[ Mty_signature ]]Block.__(1, {sg$prime}), --[[ Tmodtype_implicit ]]0);
        end end end end end 
     if ___conditional___ = 2--[[ Pmod_functor ]] then do
        name = match[0];
        mty$3 = may_map((function (param) do
                return transl_modtype$1(env, param);
              end end), match[1]);
        ty_arg = may_map((function (m) do
                return m.mty_type;
              end end), mty$3);
        match$2 = ty_arg ~= undefined and --[[ tuple ]]{
            enter_module(true, name.txt, ty_arg, env),
            true
          } or --[[ tuple ]]{
            --[[ tuple ]]{
              create("*"),
              env
            },
            false
          };
        match$3 = match$2[0];
        id = match$3[0];
        body = type_module$1(undefined, sttn, match$2[1], undefined, match$3[1], match[2]);
        node_mod_desc$1 = --[[ Tmod_functor ]]Block.__(2, {
            id,
            name,
            mty$3,
            body
          });
        node_mod_loc$1 = smod.pmod_loc;
        node_mod_type$1 = --[[ Mty_functor ]]Block.__(2, {
            id,
            ty_arg,
            body.mod_type
          });
        node_mod_attributes$1 = smod.pmod_attributes;
        node$2 = do
          mod_desc: node_mod_desc$1,
          mod_loc: node_mod_loc$1,
          mod_type: node_mod_type$1,
          mod_env: env,
          mod_attributes: node_mod_attributes$1
        end;
        record$2(--[[ Ti_mod ]]Block.__(3, {node$2}));
        return node$2;end end end 
     if ___conditional___ = 3--[[ Pmod_apply ]] then do
        sarg = match[1];
        sfunct = match[0];
        arg = type_module$1(undefined, true, funct_body, undefined, env, sarg);
        path$1 = path_of_module$1(arg);
        funct = type_module$1(undefined, sttn and path$1 ~= undefined, funct_body, undefined, env, sfunct);
        mty_functor = scrape_alias(env, undefined, funct.mod_type);
        if (mty_functor.tag == --[[ Mty_functor ]]2) then do
          mty_res = mty_functor[2];
          mty_param = mty_functor[1];
          param = mty_functor[0];
          generative = mty_param == undefined;
          mty_param$1 = default_mty(mty_param);
          if (generative) then do
            if (Caml_obj.caml_notequal(sarg.pmod_desc, --[[ Pmod_structure ]]Block.__(1, {--[[ [] ]]0}))) then do
              throw {
                    __Error$10,
                    sfunct.pmod_loc,
                    env,
                    --[[ Apply_generative ]]4
                  };
            end
             end 
            if (funct_body and contains_type$1(env, funct.mod_type)) then do
              throw {
                    __Error$10,
                    smod.pmod_loc,
                    env,
                    --[[ Not_allowed_in_functor_body ]]1
                  };
            end
             end 
          end
           end 
          coercion;
          try do
            coercion = modtypes$1(env, arg.mod_type, mty_param$1);
          end
          catch (raw_exn)do
            exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn[0] == __Error$5) then do
              throw {
                    __Error$10,
                    sarg.pmod_loc,
                    env,
                    --[[ Not_included ]]Block.__(1, {exn[1]})
                  };
            end
             end 
            throw exn;
          end
          mty_appl;
          if (path$1 ~= undefined) then do
            mty_appl = modtype(add_module(param, path$1, identity), mty_res);
          end else if (generative) then do
            mty_appl = mty_res;
          end else do
            try do
              mty_appl = nondep_supertype(add_module$1(true, param, arg.mod_type, env), param, mty_res);
            end
            catch (exn$1)do
              if (exn$1 == Caml_builtin_exceptions.not_found) then do
                throw {
                      __Error$10,
                      smod.pmod_loc,
                      env,
                      --[[ Cannot_eliminate_dependency ]]Block.__(2, {mty_functor})
                    };
              end
               end 
              throw exn$1;
            end
          end end  end 
          node_mod_desc$2 = --[[ Tmod_apply ]]Block.__(3, {
              funct,
              arg,
              coercion
            });
          node_mod_loc$2 = smod.pmod_loc;
          node_mod_attributes$2 = smod.pmod_attributes;
          node$3 = do
            mod_desc: node_mod_desc$2,
            mod_loc: node_mod_loc$2,
            mod_type: mty_appl,
            mod_env: env,
            mod_attributes: node_mod_attributes$2
          end;
          record$2(--[[ Ti_mod ]]Block.__(3, {node$3}));
          return node$3;
        end else do
          throw {
                __Error$10,
                sfunct.pmod_loc,
                env,
                --[[ Cannot_apply ]]Block.__(0, {funct.mod_type})
              };
        end end end end end 
     if ___conditional___ = 4--[[ Pmod_constraint ]] then do
        arg$1 = type_module$1(alias, true, funct_body, anchor, env, match[0]);
        mty$4 = transl_modtype$1(env, match[1]);
        init = wrap_constraint(env, arg$1, mty$4.mty_type, --[[ Tmodtype_explicit ]]{mty$4});
        node_mod_desc$3 = init.mod_desc;
        node_mod_loc$3 = smod.pmod_loc;
        node_mod_type$2 = init.mod_type;
        node_mod_env = init.mod_env;
        node_mod_attributes$3 = smod.pmod_attributes;
        node$4 = do
          mod_desc: node_mod_desc$3,
          mod_loc: node_mod_loc$3,
          mod_type: node_mod_type$2,
          mod_env: node_mod_env,
          mod_attributes: node_mod_attributes$3
        end;
        record$2(--[[ Ti_mod ]]Block.__(3, {node$4}));
        return node$4;end end end 
     if ___conditional___ = 5--[[ Pmod_unpack ]] then do
        if (principal.contents) then do
          begin_def(--[[ () ]]0);
        end
         end 
        exp = type_exp(env, match[0]);
        if (principal.contents) then do
          end_def(--[[ () ]]0);
          generalize_structure$1(current_level.contents, exp.exp_type);
        end
         end 
        match$4 = expand_head(env, exp.exp_type);
        match$5 = match$4.desc;
        mty$5;
        exit$1 = 0;
        if (typeof match$5 == "number") then do
          exit$1 = 1;
        end else do
          local ___conditional___=(match$5.tag | 0);
          do
             if ___conditional___ = 0--[[ Tvar ]] then do
                throw {
                      __Error$7,
                      smod.pmod_loc,
                      env,
                      --[[ Cannot_infer_signature ]]3
                    };end end end 
             if ___conditional___ = 11--[[ Tpackage ]] then do
                tl = match$5[2];
                if (List.exists((function (t) do
                          return free_variables$1(undefined, t) ~= --[[ [] ]]0;
                        end end), tl)) then do
                  throw {
                        __Error$10,
                        smod.pmod_loc,
                        env,
                        --[[ Incomplete_packed_module ]]Block.__(13, {exp.exp_type})
                      };
                end
                 end 
                if (principal.contents and not generalizable(99999999, exp.exp_type)) then do
                  prerr_warning(smod.pmod_loc, --[[ Not_principal ]]Block.__(8, {"this module unpacking"}));
                end
                 end 
                mty$5 = modtype_of_package(env, smod.pmod_loc, match$5[0], match$5[1], tl);end else 
             do end
            else do
              exit$1 = 1;
              end end
              
          end
        end end 
        if (exit$1 == 1) then do
          throw {
                __Error$10,
                smod.pmod_loc,
                env,
                --[[ Not_a_packed_module ]]Block.__(12, {exp.exp_type})
              };
        end
         end 
        if (funct_body and contains_type$1(env, mty$5)) then do
          throw {
                __Error$10,
                smod.pmod_loc,
                env,
                --[[ Not_allowed_in_functor_body ]]1
              };
        end
         end 
        node_mod_desc$4 = --[[ Tmod_unpack ]]Block.__(5, {
            exp,
            mty$5
          });
        node_mod_loc$4 = smod.pmod_loc;
        node_mod_attributes$4 = smod.pmod_attributes;
        node$5 = do
          mod_desc: node_mod_desc$4,
          mod_loc: node_mod_loc$4,
          mod_type: mty$5,
          mod_env: env,
          mod_attributes: node_mod_attributes$4
        end;
        record$2(--[[ Ti_mod ]]Block.__(3, {node$5}));
        return node$5;end end end 
     if ___conditional___ = 6--[[ Pmod_extension ]] then do
        throw {
              Error_forward$3,
              error_of_extension(match[0])
            };end end end 
     do
    
  end
end end

function type_structure(toplevelOpt, funct_body, anchor, env, sstr, scope) do
  toplevel = toplevelOpt ~= undefined and toplevelOpt or false;
  type_names = do
    contents: --[[ Empty ]]0
  end;
  module_names = do
    contents: --[[ Empty ]]0
  end;
  modtype_names = do
    contents: --[[ Empty ]]0
  end;
  type_str_item = function (env, srem, param) do
    loc = param.pstr_loc;
    desc = param.pstr_desc;
    local ___conditional___=(desc.tag | 0);
    do
       if ___conditional___ = 0--[[ Pstr_eval ]] then do
          expr = type_expression(env, desc[0]);
          return --[[ tuple ]]{
                  --[[ Tstr_eval ]]Block.__(0, {
                      expr,
                      desc[1]
                    }),
                  --[[ [] ]]0,
                  env
                };end end end 
       if ___conditional___ = 1--[[ Pstr_value ]] then do
          rec_flag = desc[0];
          scope$1;
          if (rec_flag) then do
            scope$1 = --[[ Idef ]]Block.__(1, {do
                  loc_start: loc.loc_start,
                  loc_end: scope.loc_end,
                  loc_ghost: scope.loc_ghost
                end});
          end else do
            start = srem and srem[0].pstr_loc.loc_start or loc.loc_end;
            scope$1 = --[[ Idef ]]Block.__(1, {do
                  loc_start: start,
                  loc_end: scope.loc_end,
                  loc_ghost: scope.loc_ghost
                end});
          end end 
          match = type_binding(env, rec_flag, desc[1], scope$1);
          newenv = match[1];
          defs = match[0];
          return --[[ tuple ]]{
                  --[[ Tstr_value ]]Block.__(1, {
                      rec_flag,
                      defs
                    }),
                  List.map((function (id) do
                          return --[[ Sig_value ]]Block.__(0, {
                                    id,
                                    find_value(--[[ Pident ]]Block.__(0, {id}), newenv)
                                  });
                        end end), let_bound_idents(defs)),
                  newenv
                };end end end 
       if ___conditional___ = 2--[[ Pstr_primitive ]] then do
          match$1 = transl_value_decl(env, loc, desc[0]);
          desc$1 = match$1[0];
          return --[[ tuple ]]{
                  --[[ Tstr_primitive ]]Block.__(2, {desc$1}),
                  --[[ :: ]]{
                    --[[ Sig_value ]]Block.__(0, {
                        desc$1.val_id,
                        desc$1.val_val
                      }),
                    --[[ [] ]]0
                  },
                  match$1[1]
                };end end end 
       if ___conditional___ = 3--[[ Pstr_type ]] then do
          sdecls = desc[0];
          rec_flag$1 = rec_flag_of_ptype_declarations(sdecls);
          List.iter((function (decl) do
                  return check_name("type", type_names, decl.ptype_name);
                end end), sdecls);
          match$2 = transl_type_decl(env, rec_flag$1, sdecls);
          decls = match$2[0];
          return --[[ tuple ]]{
                  --[[ Tstr_type ]]Block.__(3, {decls}),
                  map_rec_type_with_row_types(rec_flag$1, (function (rs, info) do
                          return --[[ Sig_type ]]Block.__(1, {
                                    info.typ_id,
                                    info.typ_type,
                                    rs
                                  });
                        end end), decls, --[[ [] ]]0),
                  enrich_type_decls(anchor, decls, env, match$2[1])
                };end end end 
       if ___conditional___ = 4--[[ Pstr_typext ]] then do
          match$3 = transl_type_extension(true, env, loc, desc[0]);
          tyext = match$3[0];
          return --[[ tuple ]]{
                  --[[ Tstr_typext ]]Block.__(4, {tyext}),
                  map_ext((function (es, ext) do
                          return --[[ Sig_typext ]]Block.__(2, {
                                    ext.ext_id,
                                    ext.ext_type,
                                    es
                                  });
                        end end), tyext.tyext_constructors, --[[ [] ]]0),
                  match$3[1]
                };end end end 
       if ___conditional___ = 5--[[ Pstr_exception ]] then do
          match$4 = transl_exception(env, desc[0]);
          ext = match$4[0];
          return --[[ tuple ]]{
                  --[[ Tstr_exception ]]Block.__(5, {ext}),
                  --[[ :: ]]{
                    --[[ Sig_typext ]]Block.__(2, {
                        ext.ext_id,
                        ext.ext_type,
                        --[[ Text_exception ]]2
                      }),
                    --[[ [] ]]0
                  },
                  match$4[1]
                };end end end 
       if ___conditional___ = 6--[[ Pstr_module ]] then do
          match$5 = desc[0];
          pmb_loc = match$5.pmb_loc;
          attrs = match$5.pmb_attributes;
          name = match$5.pmb_name;
          check_name("module", module_names, name);
          modl = type_module$1(true, true, funct_body, anchor_submodule(name.txt, anchor), env, match$5.pmb_expr);
          md_md_type = enrich_module_type(anchor, name.txt, modl.mod_type, env);
          md = do
            md_type: md_md_type,
            md_attributes: attrs,
            md_loc: pmb_loc
          end;
          match$6 = enter_module_declaration(undefined, name.txt, md, env);
          id = match$6[0];
          return --[[ tuple ]]{
                  --[[ Tstr_module ]]Block.__(6, {do
                        mb_id: id,
                        mb_name: name,
                        mb_expr: modl,
                        mb_attributes: attrs,
                        mb_loc: pmb_loc
                      end}),
                  --[[ :: ]]{
                    --[[ Sig_module ]]Block.__(3, {
                        id,
                        do
                          md_type: modl.mod_type,
                          md_attributes: attrs,
                          md_loc: pmb_loc
                        end,
                        --[[ Trec_not ]]0
                      }),
                    --[[ [] ]]0
                  },
                  match$6[1]
                };end end end 
       if ___conditional___ = 7--[[ Pstr_recmodule ]] then do
          sbind = List.map((function (mb) do
                  match = mb.pmb_expr.pmod_desc;
                  if (match.tag == --[[ Pmod_constraint ]]4) then do
                    return --[[ tuple ]]{
                            mb.pmb_name,
                            match[1],
                            match[0],
                            mb.pmb_attributes,
                            mb.pmb_loc
                          };
                  end else do
                    throw {
                          __Error$10,
                          mb.pmb_expr.pmod_loc,
                          env,
                          --[[ Recursive_module_require_explicit_type ]]3
                        };
                  end end 
                end end), desc[0]);
          List.iter((function (param) do
                  return check_name("module", module_names, param[0]);
                end end), sbind);
          match$7 = transl_recmodule_modtypes(loc, env, List.map((function (param) do
                      return do
                              pmd_name: param[0],
                              pmd_type: param[1],
                              pmd_attributes: param[3],
                              pmd_loc: param[4]
                            end;
                    end end), sbind));
          newenv$1 = match$7[1];
          decls$1 = match$7[0];
          bindings1 = List.map2((function (param, param$1) do
                  id = param.md_id;
                  modl = type_module$1(undefined, true, funct_body, --[[ Pident ]]Block.__(0, {id}), newenv$1, param$1[2]);
                  mty$prime = enrich_module_type(anchor, id.name, modl.mod_type, newenv$1);
                  return --[[ tuple ]]{
                          id,
                          param$1[0],
                          param.md_type,
                          modl,
                          mty$prime,
                          param$1[3],
                          param$1[4]
                        };
                end end), decls$1, sbind);
          newenv$2 = List.fold_left((function (env, md) do
                  mdecl_md_type = md.md_type.mty_type;
                  mdecl_md_attributes = md.md_attributes;
                  mdecl_md_loc = md.md_loc;
                  mdecl = do
                    md_type: mdecl_md_type,
                    md_attributes: mdecl_md_attributes,
                    md_loc: mdecl_md_loc
                  end;
                  return add_module_declaration(undefined, md.md_id, mdecl, env);
                end end), env, decls$1);
          bindings2 = check_recmodule_inclusion(newenv$2, bindings1);
          return --[[ tuple ]]{
                  --[[ Tstr_recmodule ]]Block.__(7, {bindings2}),
                  map_rec((function (rs, mb) do
                          return --[[ Sig_module ]]Block.__(3, {
                                    mb.mb_id,
                                    do
                                      md_type: mb.mb_expr.mod_type,
                                      md_attributes: mb.mb_attributes,
                                      md_loc: mb.mb_loc
                                    end,
                                    rs
                                  });
                        end end), bindings2, --[[ [] ]]0),
                  newenv$2
                };end end end 
       if ___conditional___ = 8--[[ Pstr_modtype ]] then do
          match$8 = transl_modtype_decl(modtype_names, env, loc, desc[0]);
          return --[[ tuple ]]{
                  --[[ Tstr_modtype ]]Block.__(8, {match$8[1]}),
                  --[[ :: ]]{
                    match$8[2],
                    --[[ [] ]]0
                  },
                  match$8[0]
                };end end end 
       if ___conditional___ = 9--[[ Pstr_open ]] then do
          match$9 = type_open$1(toplevel, env, desc[0]);
          return --[[ tuple ]]{
                  --[[ Tstr_open ]]Block.__(9, {match$9[2]}),
                  --[[ [] ]]0,
                  match$9[1]
                };end end end 
       if ___conditional___ = 10--[[ Pstr_class ]] then do
          cl = desc[0];
          List.iter((function (param) do
                  return check_name("type", type_names, param.pci_name);
                end end), cl);
          match$10 = class_declarations$2(env, cl);
          classes = match$10[0];
          return --[[ tuple ]]{
                  --[[ Tstr_class ]]Block.__(10, {List.map((function (param) do
                              vf = param[2].cty_new == undefined and --[[ Virtual ]]0 or --[[ Concrete ]]1;
                              return --[[ tuple ]]{
                                      param[11],
                                      param[10],
                                      vf
                                    };
                            end end), classes)}),
                  List.flatten(map_rec((function (rs, param) do
                              return --[[ :: ]]{
                                      --[[ Sig_class ]]Block.__(5, {
                                          param[0],
                                          param[2],
                                          rs
                                        }),
                                      --[[ :: ]]{
                                        --[[ Sig_class_type ]]Block.__(6, {
                                            param[3],
                                            param[4],
                                            rs
                                          }),
                                        --[[ :: ]]{
                                          --[[ Sig_type ]]Block.__(1, {
                                              param[5],
                                              param[6],
                                              rs
                                            }),
                                          --[[ :: ]]{
                                            --[[ Sig_type ]]Block.__(1, {
                                                param[7],
                                                param[8],
                                                rs
                                              }),
                                            --[[ [] ]]0
                                          }
                                        }
                                      }
                                    };
                            end end), classes, --[[ [] ]]0)),
                  match$10[1]
                };end end end 
       if ___conditional___ = 11--[[ Pstr_class_type ]] then do
          cl$1 = desc[0];
          List.iter((function (param) do
                  return check_name("type", type_names, param.pci_name);
                end end), cl$1);
          match$11 = class_type_declarations$2(env, cl$1);
          classes$1 = match$11[0];
          return --[[ tuple ]]{
                  --[[ Tstr_class_type ]]Block.__(11, {List.map((function (param) do
                              return --[[ tuple ]]{
                                      param[0],
                                      param[1],
                                      param[7]
                                    };
                            end end), classes$1)}),
                  List.flatten(map_rec((function (rs, param) do
                              return --[[ :: ]]{
                                      --[[ Sig_class_type ]]Block.__(6, {
                                          param[0],
                                          param[2],
                                          rs
                                        }),
                                      --[[ :: ]]{
                                        --[[ Sig_type ]]Block.__(1, {
                                            param[3],
                                            param[4],
                                            rs
                                          }),
                                        --[[ :: ]]{
                                          --[[ Sig_type ]]Block.__(1, {
                                              param[5],
                                              param[6],
                                              rs
                                            }),
                                          --[[ [] ]]0
                                        }
                                      }
                                    };
                            end end), classes$1, --[[ [] ]]0)),
                  match$11[1]
                };end end end 
       if ___conditional___ = 12--[[ Pstr_include ]] then do
          sincl = desc[0];
          smodl = sincl.pincl_mod;
          modl$1 = type_module$1(undefined, true, funct_body, undefined, env, smodl);
          sg = signature$2(identity, extract_sig_open(env, smodl.pmod_loc, modl$1.mod_type));
          match$12 = modl$1.mod_desc;
          sg$1;
          if (match$12.tag) then do
            sg$1 = sg;
          end else do
            p = match$12[0];
            if (is_functor_arg(p, env)) then do
              sg$1 = sg;
            end else do
              add_required_global(head(p));
              pos = do
                contents: 0
              end;
              sg$1 = List.map((function (it) do
                      local ___conditional___=(it.tag | 0);
                      do
                         if ___conditional___ = 0--[[ Sig_value ]] then do
                            match = it[1].val_kind;
                            if (typeof match == "number" and match == 0) then do
                              pos.contents = pos.contents + 1 | 0;
                              return it;
                            end else do
                              return it;
                            end end end end end 
                         if ___conditional___ = 3--[[ Sig_module ]] then do
                            md = it[1];
                            id = it[0];
                            n = pos.contents;
                            pos.contents = pos.contents + 1 | 0;
                            return --[[ Sig_module ]]Block.__(3, {
                                      id,
                                      do
                                        md_type: --[[ Mty_alias ]]Block.__(3, {--[[ Pdot ]]Block.__(1, {
                                                p,
                                                id.name,
                                                n
                                              })}),
                                        md_attributes: md.md_attributes,
                                        md_loc: md.md_loc
                                      end,
                                      it[2]
                                    });end end end 
                         if ___conditional___ = 2--[[ Sig_typext ]]
                         or ___conditional___ = 5--[[ Sig_class ]] then do
                            pos.contents = pos.contents + 1 | 0;
                            return it;end end end 
                         do
                        else do
                          return it;
                          end end
                          
                      end
                    end end), sg);
            end end 
          end end 
          List.iter((function (param) do
                  return check_sig_item(type_names, module_names, modtype_names, loc, param);
                end end), sg$1);
          new_env = add_signature(sg$1, env);
          incl_incl_loc = sincl.pincl_loc;
          incl_incl_attributes = sincl.pincl_attributes;
          incl = do
            incl_mod: modl$1,
            incl_type: sg$1,
            incl_loc: incl_incl_loc,
            incl_attributes: incl_incl_attributes
          end;
          return --[[ tuple ]]{
                  --[[ Tstr_include ]]Block.__(12, {incl}),
                  sg$1,
                  new_env
                };end end end 
       if ___conditional___ = 13--[[ Pstr_attribute ]] then do
          x = desc[0];
          warning_attribute(--[[ :: ]]{
                x,
                --[[ [] ]]0
              });
          return --[[ tuple ]]{
                  --[[ Tstr_attribute ]]Block.__(13, {x}),
                  --[[ [] ]]0,
                  env
                };end end end 
       if ___conditional___ = 14--[[ Pstr_extension ]] then do
          throw {
                Error_forward$3,
                error_of_extension(desc[0])
              };end end end 
       do
      
    end
  end end;
  type_struct = function (env, sstr) do
    init_def(currentstamp.contents);
    if (sstr) then do
      srem = sstr[1];
      pstr = sstr[0];
      previous_saved_types = saved_types.contents;
      match = type_str_item(env, srem, pstr);
      str_str_desc = match[0];
      str_str_loc = pstr.pstr_loc;
      str = do
        str_desc: str_str_desc,
        str_loc: str_str_loc,
        str_env: env
      end;
      saved_types.contents = --[[ :: ]]{
        --[[ Partial_structure_item ]]Block.__(1, {str}),
        previous_saved_types
      };
      match$1 = type_struct(match[2], srem);
      return --[[ tuple ]]{
              --[[ :: ]]{
                str,
                match$1[0]
              },
              Pervasives.$at(match[1], match$1[1]),
              match$1[2]
            };
    end else do
      return --[[ tuple ]]{
              --[[ [] ]]0,
              --[[ [] ]]0,
              env
            };
    end end 
  end end;
  if (annotations.contents) then do
    List.iter((function (param) do
            loc = param.pstr_loc;
            if (annotations.contents) then do
              phrases.contents = --[[ :: ]]{
                loc,
                phrases.contents
              };
              return --[[ () ]]0;
            end else do
              return 0;
            end end 
          end end), sstr);
  end
   end 
  previous_saved_types = saved_types.contents;
  warning_enter_scope(--[[ () ]]0);
  match = type_struct(env, sstr);
  final_env = match[2];
  sg = match[1];
  str_str_items = match[0];
  str = do
    str_items: str_str_items,
    str_type: sg,
    str_final_env: final_env
  end;
  warning_leave_scope(--[[ () ]]0);
  saved_types.contents = --[[ :: ]]{
    --[[ Partial_structure ]]Block.__(0, {str}),
    previous_saved_types
  };
  return --[[ tuple ]]{
          str,
          sg,
          final_env
        };
end end

function type_module$2(param, param$1) do
  return type_module$1(undefined, true, false, undefined, param, param$1);
end end

function type_structure$1(param, param$1, param$2) do
  return type_structure(undefined, false, undefined, param, param$1, param$2);
end end

function normalize_signature(env) do
  return (function (param) do
      return List.iter((function (param) do
                    env$1 = env;
                    param$1 = param;
                    local ___conditional___=(param$1.tag | 0);
                    do
                       if ___conditional___ = 0--[[ Sig_value ]] then do
                          return normalize_type(env$1, param$1[1].val_type);end end end 
                       if ___conditional___ = 3--[[ Sig_module ]] then do
                          env$2 = env$1;
                          _param = param$1[1].md_type;
                          while(true) do
                            param$2 = _param;
                            local ___conditional___=(param$2.tag | 0);
                            do
                               if ___conditional___ = 1--[[ Mty_signature ]] then do
                                  return normalize_signature(env$2)(param$2[0]);end end end 
                               if ___conditional___ = 2--[[ Mty_functor ]] then do
                                  _param = param$2[2];
                                  continue ;end end end 
                               if ___conditional___ = 0--[[ Mty_ident ]]
                               or ___conditional___ = 3--[[ Mty_alias ]] then do
                                  return --[[ () ]]0;end end end 
                               do
                              
                            end
                          end;end end end 
                       do
                      else do
                        return --[[ () ]]0;
                        end end
                        
                    end
                  end end), param);
    end end);
end end

function type_module_type_of(env, smod) do
  match = smod.pmod_desc;
  tmty;
  if (match.tag) then do
    tmty = type_module$2(env, smod);
  end else do
    lid = match[0];
    match$1 = find_module$1(env, smod.pmod_loc, lid.txt);
    node_mod_desc = --[[ Tmod_ident ]]Block.__(0, {
        match$1[0],
        lid
      });
    node_mod_loc = smod.pmod_loc;
    node_mod_type = match$1[1].md_type;
    node_mod_attributes = smod.pmod_attributes;
    node = do
      mod_desc: node_mod_desc,
      mod_loc: node_mod_loc,
      mod_type: node_mod_type,
      mod_env: env,
      mod_attributes: node_mod_attributes
    end;
    record$2(--[[ Ti_mod ]]Block.__(3, {node}));
    tmty = node;
  end end 
  mty = tmty.mod_type;
  mty$1 = remove_aliases$1(env, mty);
  if (not closed_modtype(mty$1)) then do
    throw {
          __Error$10,
          smod.pmod_loc,
          env,
          --[[ Non_generalizable_module ]]Block.__(9, {mty$1})
        };
  end
   end 
  return --[[ tuple ]]{
          tmty,
          mty$1
        };
end end

function type_package$1(env, m, p, nl, tl) do
  lv = current_level.contents;
  begin_def(--[[ () ]]0);
  set_current_time(lv);
  context = narrow(--[[ () ]]0);
  modl = type_module$2(env, m);
  init_def(currentstamp.contents);
  widen(context);
  match = modl.mod_desc;
  match$1;
  if (match.tag) then do
    match$2 = enter_module(true, "%M", modl.mod_type, env);
    match$1 = --[[ tuple ]]{
      --[[ Pident ]]Block.__(0, {match$2[0]}),
      match$2[1]
    };
  end else do
    match$1 = --[[ tuple ]]{
      match[0],
      env
    };
  end end 
  env$1 = match$1[1];
  mp = match$1[0];
  mkpath = function (mp, param) do
    local ___conditional___=(param.tag | 0);
    do
       if ___conditional___ = 0--[[ Lident ]] then do
          return --[[ Pdot ]]Block.__(1, {
                    mp,
                    param[0],
                    -1
                  });end end end 
       if ___conditional___ = 1--[[ Ldot ]] then do
          return --[[ Pdot ]]Block.__(1, {
                    mkpath(mp, param[0]),
                    param[1],
                    -1
                  });end end end 
       if ___conditional___ = 2--[[ Lapply ]] then do
          throw {
                Caml_builtin_exceptions.assert_failure,
                --[[ tuple ]]{
                  "typemod.ml",
                  1565,
                  11
                }
              };end end end 
       do
      
    end
  end end;
  tl$prime = List.map((function (name) do
          return newty2(100000000, --[[ Tconstr ]]Block.__(3, {
                        mkpath(mp, name),
                        --[[ [] ]]0,
                        do
                          contents: --[[ Mnil ]]0
                        end
                      }));
        end end), nl);
  end_def(--[[ () ]]0);
  if (nl == --[[ [] ]]0) then do
    return --[[ tuple ]]{
            wrap_constraint(env$1, modl, --[[ Mty_ident ]]Block.__(0, {p}), --[[ Tmodtype_implicit ]]0),
            --[[ [] ]]0
          };
  end else do
    mty = modtype_of_package(env$1, modl.mod_loc, p, nl, tl$prime);
    List.iter2((function (n, ty) do
            try do
              return unify$2(env$1, ty, newvar(undefined, --[[ () ]]0));
            end
            catch (raw_exn)do
              exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn[0] == Unify) then do
                throw {
                      __Error$10,
                      m.pmod_loc,
                      env$1,
                      --[[ Scoping_pack ]]Block.__(14, {
                          n,
                          ty
                        })
                    };
              end
               end 
              throw exn;
            end
          end end), nl, tl$prime);
    return --[[ tuple ]]{
            wrap_constraint(env$1, modl, mty, --[[ Tmodtype_implicit ]]0),
            tl$prime
          };
  end end 
end end

type_module.contents = type_module$2;

transl_modtype_longident.contents = transl_modtype_longident$1;

transl_modtype.contents = transl_modtype$1;

type_open.contents = (function (param, param$1, param$2, param$3) do
    return type_open_(undefined, param, param$1, param$2, param$3);
  end end);

type_package.contents = type_package$1;

type_module_type_of_fwd.contents = type_module_type_of;

function type_implementation_more(sourcefile, outputprefix, modulename, initial_env, ast) do
  clear(--[[ () ]]0);
  try do
    delayed_checks.contents = --[[ [] ]]0;
    required_globals.contents = --[[ [] ]]0;
    Curry._2(newrecord$1.structure, newrecord$1, ast);
    match = type_structure$1(initial_env, ast, in_file(sourcefile));
    finalenv = match[2];
    sg = match[1];
    str = match[0];
    simple_sg = simplify_signature(sg);
    if (print_types.contents) then do
      wrap_printing_env(initial_env, (function (param) do
              return Curry._2(Format.fprintf(Format.std_formatter, --[[ Format ]]{
                              --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                      --[[ Flush_newline ]]4,
                                      --[[ End_of_format ]]0
                                    })}),
                              "%a@."
                            }), signature$3, simple_sg);
            end end));
      return --[[ tuple ]]{
              str,
              --[[ Tcoerce_none ]]0,
              finalenv,
              simple_sg
            };
    end else do
      sourceintf = chop_extension_if_any(sourcefile) .. interface_suffix.contents;
      mli_status = assume_no_mli.contents;
      if (mli_status == --[[ Mli_na ]]0 and Caml_external_polyfill.resolve("caml_sys_file_exists")(sourceintf) or mli_status == --[[ Mli_exists ]]1) then do
        intf_file;
        try do
          intf_file = find_in_path_uncap(load_path.contents, modulename .. ".cmi");
        end
        catch (exn)do
          if (exn == Caml_builtin_exceptions.not_found) then do
            throw {
                  __Error$10,
                  in_file(sourcefile),
                  empty,
                  --[[ Interface_not_compiled ]]Block.__(11, {sourceintf})
                };
          end
           end 
          throw exn;
        end
        dclsig = read_signature(modulename, intf_file);
        coercion = compunit(initial_env, sourcefile, sg, intf_file, dclsig);
        force_delayed_checks(--[[ () ]]0);
        save_cmt(outputprefix .. ".cmt", modulename, --[[ Implementation ]]Block.__(1, {str}), sourcefile, initial_env, undefined);
        return --[[ tuple ]]{
                str,
                coercion,
                finalenv,
                dclsig
              };
      end else do
        List.iter((function (param) do
                env = finalenv;
                str = param;
                match = str.str_desc;
                local ___conditional___=(match.tag | 0);
                do
                   if ___conditional___ = 1--[[ Tstr_value ]] then do
                      return List.iter((function (param) do
                                    exp = param.vb_expr;
                                    if (closed_schema(exp.exp_type)) then do
                                      return 0;
                                    end else do
                                      throw {
                                            __Error$10,
                                            exp.exp_loc,
                                            env,
                                            --[[ Non_generalizable ]]Block.__(7, {exp.exp_type})
                                          };
                                    end end 
                                  end end), match[1]);end end end 
                   if ___conditional___ = 6--[[ Tstr_module ]] then do
                      md = match[0].mb_expr;
                      if (closed_modtype(md.mod_type)) then do
                        return 0;
                      end else do
                        throw {
                              __Error$10,
                              md.mod_loc,
                              env,
                              --[[ Non_generalizable_module ]]Block.__(9, {md.mod_type})
                            };
                      end end end end end 
                   do
                  else do
                    return --[[ () ]]0;
                    end end
                    
                end
              end end), str.str_items);
        normalize_signature(finalenv)(simple_sg);
        coercion$1 = compunit(initial_env, sourcefile, sg, "(inferred signature)", simple_sg);
        force_delayed_checks(--[[ () ]]0);
        if (not dont_write_files.contents) then do
          sg$1 = save_signature(simple_sg, modulename, outputprefix .. ".cmi");
          save_cmt(outputprefix .. ".cmt", modulename, --[[ Implementation ]]Block.__(1, {str}), sourcefile, initial_env, sg$1);
        end
         end 
        return --[[ tuple ]]{
                str,
                coercion$1,
                finalenv,
                simple_sg
              };
      end end 
    end end 
  end
  catch (e)do
    save_cmt(outputprefix .. ".cmt", modulename, --[[ Partial_implementation ]]Block.__(3, {__Array.of_list(saved_types.contents)}), sourcefile, initial_env, undefined);
    throw e;
  end
end end

function type_implementation(sourcefile, outputprefix, modulename, initial_env, ast) do
  match = type_implementation_more(sourcefile, outputprefix, modulename, initial_env, ast);
  return --[[ tuple ]]{
          match[0],
          match[1]
        };
end end

register_error_of_exn((function (param) do
        if (param[0] == __Error$10) then do
          env = param[2];
          return error_of_printer(param[1], (function (param, param$1) do
                        env$1 = env;
                        ppf = param;
                        err = param$1;
                        return wrap_printing_env(env$1, (function (param) do
                                      ppf$1 = ppf;
                                      param$1 = err;
                                      if (typeof param$1 == "number") then do
                                        local ___conditional___=(param$1);
                                        do
                                           if ___conditional___ = 0--[[ Signature_expected ]] then do
                                              return Format.fprintf(ppf$1, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "This module type is not a signature",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "This module type is not a signature"
                                                        });end end end 
                                           if ___conditional___ = 1--[[ Not_allowed_in_functor_body ]] then do
                                              return Curry._1(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "This expression creates fresh types.",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ String ]]Block.__(2, {
                                                                              --[[ No_padding ]]0,
                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Close_box ]]0,
                                                                                  --[[ End_of_format ]]0
                                                                                })
                                                                            })
                                                                        })
                                                                    })
                                                                }),
                                                              "@[This expression creates fresh types.@ %s@]"
                                                            }), "It is not allowed inside applicative functors.");end end end 
                                           if ___conditional___ = 2--[[ With_need_typeconstr ]] then do
                                              return Format.fprintf(ppf$1, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "Only type constructors with identical parameters can be substituted.",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "Only type constructors with identical parameters can be substituted."
                                                        });end end end 
                                           if ___conditional___ = 3--[[ Recursive_module_require_explicit_type ]] then do
                                              return Format.fprintf(ppf$1, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "Recursive modules require an explicit module type.",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "Recursive modules require an explicit module type."
                                                        });end end end 
                                           if ___conditional___ = 4--[[ Apply_generative ]] then do
                                              return Format.fprintf(ppf$1, --[[ Format ]]{
                                                          --[[ String_literal ]]Block.__(11, {
                                                              "This is a generative functor. It can only be applied to ()",
                                                              --[[ End_of_format ]]0
                                                            }),
                                                          "This is a generative functor. It can only be applied to ()"
                                                        });end end end 
                                           do
                                          
                                        end
                                      end else do
                                        local ___conditional___=(param$1.tag | 0);
                                        do
                                           if ___conditional___ = 0--[[ Cannot_apply ]] then do
                                              return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "This module is not a functor; it has type",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Close_box ]]0,
                                                                                  --[[ End_of_format ]]0
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[This module is not a functor; it has type@ %a@]"
                                                            }), modtype$1, param$1[0]);end end end 
                                           if ___conditional___ = 1--[[ Not_included ]] then do
                                              return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "<v>",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "<v>"
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "Signature mismatch:",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Close_box ]]0,
                                                                                  --[[ End_of_format ]]0
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[<v>Signature mismatch:@ %a@]"
                                                            }), report_error$4, param$1[0]);end end end 
                                           if ___conditional___ = 2--[[ Cannot_eliminate_dependency ]] then do
                                              return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "This functor has type",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Break ]]Block.__(0, {
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    }),
                                                                                  --[[ String_literal ]]Block.__(11, {
                                                                                      "The parameter cannot be eliminated in the result type.",
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Break ]]Block.__(0, {
                                                                                              "@ ",
                                                                                              1,
                                                                                              0
                                                                                            }),
                                                                                          --[[ String_literal ]]Block.__(11, {
                                                                                              " Please bind the argument to a module identifier.",
                                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                                  --[[ Close_box ]]0,
                                                                                                  --[[ End_of_format ]]0
                                                                                                })
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[This functor has type@ %a@ The parameter cannot be eliminated in the result type.@  Please bind the argument to a module identifier.@]"
                                                            }), modtype$1, param$1[0]);end end end 
                                           if ___conditional___ = 3--[[ Structure_expected ]] then do
                                              return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "This module is not a structure; it has type",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[This module is not a structure; it has type@ %a"
                                                            }), modtype$1, param$1[0]);end end end 
                                           if ___conditional___ = 4--[[ With_no_component ]] then do
                                              return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The signature constrained by `with' has no component named ",
                                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Close_box ]]0,
                                                                              --[[ End_of_format ]]0
                                                                            })})
                                                                    })
                                                                }),
                                                              "@[The signature constrained by `with' has no component named %a@]"
                                                            }), longident, param$1[0]);end end end 
                                           if ___conditional___ = 5--[[ With_mismatch ]] then do
                                              return Curry._4(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ String_literal ]]Block.__(11, {
                                                                            "<v>",
                                                                            --[[ End_of_format ]]0
                                                                          }),
                                                                        "<v>"
                                                                      }}),
                                                                  --[[ Formatting_gen ]]Block.__(18, {
                                                                      --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                            --[[ End_of_format ]]0,
                                                                            ""
                                                                          }}),
                                                                      --[[ String_literal ]]Block.__(11, {
                                                                          "In this `with' constraint, the new definition of ",
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                  --[[ Break ]]Block.__(0, {
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    }),
                                                                                  --[[ String_literal ]]Block.__(11, {
                                                                                      "does not match its original definition",
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Break ]]Block.__(0, {
                                                                                              "@ ",
                                                                                              1,
                                                                                              0
                                                                                            }),
                                                                                          --[[ String_literal ]]Block.__(11, {
                                                                                              "in the constrained signature:",
                                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                                  --[[ Close_box ]]0,
                                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                                      --[[ Break ]]Block.__(0, {
                                                                                                          "@ ",
                                                                                                          1,
                                                                                                          0
                                                                                                        }),
                                                                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                                                              --[[ Close_box ]]0,
                                                                                                              --[[ End_of_format ]]0
                                                                                                            })})
                                                                                                    })
                                                                                                })
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[<v>@[In this `with' constraint, the new definition of %a@ does not match its original definition@ in the constrained signature:@]@ %a@]"
                                                            }), longident, param$1[0], report_error$4, param$1[1]);end end end 
                                           if ___conditional___ = 6--[[ Repeated_name ]] then do
                                              return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "Multiple definition of the ",
                                                                      --[[ String ]]Block.__(2, {
                                                                          --[[ No_padding ]]0,
                                                                          --[[ String_literal ]]Block.__(11, {
                                                                              " name ",
                                                                              --[[ String ]]Block.__(2, {
                                                                                  --[[ No_padding ]]0,
                                                                                  --[[ Char_literal ]]Block.__(12, {
                                                                                      --[[ "." ]]46,
                                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                                          --[[ Break ]]Block.__(0, {
                                                                                              "@ ",
                                                                                              1,
                                                                                              0
                                                                                            }),
                                                                                          --[[ String_literal ]]Block.__(11, {
                                                                                              "Names must be unique in a given structure or signature.",
                                                                                              --[[ Formatting_lit ]]Block.__(17, {
                                                                                                  --[[ Close_box ]]0,
                                                                                                  --[[ End_of_format ]]0
                                                                                                })
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })
                                                                            })
                                                                        })
                                                                    })
                                                                }),
                                                              "@[Multiple definition of the %s name %s.@ Names must be unique in a given structure or signature.@]"
                                                            }), param$1[0], param$1[1]);end end end 
                                           if ___conditional___ = 7--[[ Non_generalizable ]] then do
                                              return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The type of this expression,",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                                                  --[[ "," ]]44,
                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Break ]]Block.__(0, {
                                                                                          "@ ",
                                                                                          1,
                                                                                          0
                                                                                        }),
                                                                                      --[[ String_literal ]]Block.__(11, {
                                                                                          "contains type variables that cannot be generalized",
                                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                                              --[[ Close_box ]]0,
                                                                                              --[[ End_of_format ]]0
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[The type of this expression,@ %a,@ contains type variables that cannot be generalized@]"
                                                            }), type_scheme, param$1[0]);end end end 
                                           if ___conditional___ = 8--[[ Non_generalizable_class ]] then do
                                              id = param$1[0];
                                              return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The type of this class,",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                                                  --[[ "," ]]44,
                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Break ]]Block.__(0, {
                                                                                          "@ ",
                                                                                          1,
                                                                                          0
                                                                                        }),
                                                                                      --[[ String_literal ]]Block.__(11, {
                                                                                          "contains type variables that cannot be generalized",
                                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                                              --[[ Close_box ]]0,
                                                                                              --[[ End_of_format ]]0
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[The type of this class,@ %a,@ contains type variables that cannot be generalized@]"
                                                            }), (function (param, param$1) do
                                                            return class_declaration$1(id, param, param$1);
                                                          end end), param$1[1]);end end end 
                                           if ___conditional___ = 9--[[ Non_generalizable_module ]] then do
                                              return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The type of this module,",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                                                  --[[ "," ]]44,
                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Break ]]Block.__(0, {
                                                                                          "@ ",
                                                                                          1,
                                                                                          0
                                                                                        }),
                                                                                      --[[ String_literal ]]Block.__(11, {
                                                                                          "contains type variables that cannot be generalized",
                                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                                              --[[ Close_box ]]0,
                                                                                              --[[ End_of_format ]]0
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[The type of this module,@ %a,@ contains type variables that cannot be generalized@]"
                                                            }), modtype$1, param$1[0]);end end end 
                                           if ___conditional___ = 10--[[ Implementation_is_required ]] then do
                                              return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "The interface ",
                                                                      --[[ Alpha ]]Block.__(15, {--[[ Formatting_lit ]]Block.__(17, {
                                                                              --[[ Break ]]Block.__(0, {
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                }),
                                                                              --[[ String_literal ]]Block.__(11, {
                                                                                  "declares values, not just types.",
                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Break ]]Block.__(0, {
                                                                                          "@ ",
                                                                                          1,
                                                                                          0
                                                                                        }),
                                                                                      --[[ String_literal ]]Block.__(11, {
                                                                                          "An implementation must be provided.",
                                                                                          --[[ Formatting_lit ]]Block.__(17, {
                                                                                              --[[ Close_box ]]0,
                                                                                              --[[ End_of_format ]]0
                                                                                            })
                                                                                        })
                                                                                    })
                                                                                })
                                                                            })})
                                                                    })
                                                                }),
                                                              "@[The interface %a@ declares values, not just types.@ An implementation must be provided.@]"
                                                            }), print_filename, param$1[0]);end end end 
                                           if ___conditional___ = 11--[[ Interface_not_compiled ]] then do
                                              return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ Formatting_gen ]]Block.__(18, {
                                                                  --[[ Open_box ]]Block.__(1, {--[[ Format ]]{
                                                                        --[[ End_of_format ]]0,
                                                                        ""
                                                                      }}),
                                                                  --[[ String_literal ]]Block.__(11, {
                                                                      "Could not find the .cmi file for interface",
                                                                      --[[ Formatting_lit ]]Block.__(17, {
                                                                          --[[ Break ]]Block.__(0, {
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            }),
                                                                          --[[ Alpha ]]Block.__(15, {--[[ Char_literal ]]Block.__(12, {
                                                                                  --[[ "." ]]46,
                                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                                      --[[ Close_box ]]0,
                                                                                      --[[ End_of_format ]]0
                                                                                    })
                                                                                })})
                                                                        })
                                                                    })
                                                                }),
                                                              "@[Could not find the .cmi file for interface@ %a.@]"
                                                            }), print_filename, param$1[0]);end end end 
                                           if ___conditional___ = 12--[[ Not_a_packed_module ]] then do
                                              return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "This expression is not a packed module. It has type",
                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Break ]]Block.__(0, {
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        }),
                                                                      --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                                    })
                                                                }),
                                                              "This expression is not a packed module. It has type@ %a"
                                                            }), type_expr$1, param$1[0]);end end end 
                                           if ___conditional___ = 13--[[ Incomplete_packed_module ]] then do
                                              return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "The type of this packed module contains variables:",
                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Break ]]Block.__(0, {
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        }),
                                                                      --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                                    })
                                                                }),
                                                              "The type of this packed module contains variables:@ %a"
                                                            }), type_expr$1, param$1[0]);end end end 
                                           if ___conditional___ = 14--[[ Scoping_pack ]] then do
                                              Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                        --[[ String_literal ]]Block.__(11, {
                                                            "The type ",
                                                            --[[ Alpha ]]Block.__(15, {--[[ String_literal ]]Block.__(11, {
                                                                    " in this module cannot be exported.",
                                                                    --[[ Formatting_lit ]]Block.__(17, {
                                                                        --[[ Break ]]Block.__(0, {
                                                                            "@ ",
                                                                            1,
                                                                            0
                                                                          }),
                                                                        --[[ End_of_format ]]0
                                                                      })
                                                                  })})
                                                          }),
                                                        "The type %a in this module cannot be exported.@ "
                                                      }), longident, param$1[0]);
                                              return Curry._2(Format.fprintf(ppf$1, --[[ Format ]]{
                                                              --[[ String_literal ]]Block.__(11, {
                                                                  "Its type contains local dependencies:",
                                                                  --[[ Formatting_lit ]]Block.__(17, {
                                                                      --[[ Break ]]Block.__(0, {
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        }),
                                                                      --[[ Alpha ]]Block.__(15, {--[[ End_of_format ]]0})
                                                                    })
                                                                }),
                                                              "Its type contains local dependencies:@ %a"
                                                            }), type_expr$1, param$1[1]);end end end 
                                           do
                                          
                                        end
                                      end end 
                                    end end));
                      end end), param[3]);
        end else if (param[0] == Error_forward$3) then do
          return param[1];
        end else do
          return ;
        end end  end 
      end end));

suites = do
  contents: --[[ [] ]]0
end;

test_id = do
  contents: 0
end;

function eq(loc, x, y) do
  test_id.contents = test_id.contents + 1 | 0;
  suites.contents = --[[ :: ]]{
    --[[ tuple ]]{
      loc .. (" id " .. String(test_id.contents)),
      (function (param) do
          return --[[ Eq ]]Block.__(0, {
                    x,
                    y
                  });
        end end)
    },
    suites.contents
  };
  return --[[ () ]]0;
end end

dont_write_files.contents = true;

unsafe_string = false;

debug = true;

record_event_when_debug = false;

binary_annotations.contents = false;

nopervasives = true;

assume_no_mli.contents = --[[ Mli_non_exists ]]2;

modulename = "Test";

x = type_implementation(modulename, modulename, modulename, empty, wrap$1(implementation, Lexing.from_string("\ntype int\nexternal ( ~- ) : int -> int = \"%negint\"\nexternal ( ~+ ) : int -> int = \"%identity\"\nexternal succ : int -> int = \"%succint\"\nexternal pred : int -> int = \"%predint\"\nexternal ( + ) : int -> int -> int = \"%addint\"\nexternal ( - ) : int -> int -> int = \"%subint\"\nexternal ( * ) : int -> int -> int = \"%mulint\"\nexternal ( / ) : int -> int -> int = \"%divint\"\nexternal ( mod ) : int -> int -> int = \"%modint\"\n let f x y = x + y")));

match$1 = x[0].str_items;

if (match$1) then do
  match$2 = match$1[0];
  match$3 = match$2.str_desc;
  if (match$3.tag == --[[ Tstr_type ]]3) then do
    match$4 = match$3[0];
    if (match$4) then do
      match$5 = match$4[0];
      match$6 = match$5.typ_id;
      if (match$6.name == "int") then do
        match$7 = match$6.flags;
        if (match$7 ~= 0) then do
          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
        end else do
          match$8 = match$5.typ_name;
          if (match$8.txt == "int") then do
            match$9 = match$8.loc;
            match$10 = match$9.loc_start;
            if (match$10.pos_fname == "" and not (match$10.pos_lnum ~= 2 or match$10.pos_bol ~= 1 or match$10.pos_cnum ~= 6)) then do
              match$11 = match$9.loc_end;
              if (match$11.pos_fname == "" and not (match$11.pos_lnum ~= 2 or match$11.pos_bol ~= 1 or match$11.pos_cnum ~= 9 or match$9.loc_ghost or match$5.typ_params)) then do
                match$12 = match$5.typ_type;
                if (match$12.type_params or match$12.type_arity ~= 0) then do
                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                end else do
                  match$13 = match$12.type_kind;
                  if (typeof match$13 == "number" and not (match$13 ~= 0 or not (match$12.type_private and not (match$12.type_manifest ~= undefined or match$12.type_variance or match$12.type_newtype_level ~= undefined)))) then do
                    match$14 = match$12.type_loc;
                    match$15 = match$14.loc_start;
                    if (match$15.pos_fname == "" and not (match$15.pos_lnum ~= 2 or match$15.pos_bol ~= 1 or match$15.pos_cnum ~= 1)) then do
                      match$16 = match$14.loc_end;
                      if (match$16.pos_fname == "" and not (match$16.pos_lnum ~= 2 or match$16.pos_bol ~= 1 or match$16.pos_cnum ~= 9 or match$14.loc_ghost or match$12.type_attributes or match$5.typ_cstrs)) then do
                        match$17 = match$5.typ_kind;
                        if (typeof match$17 == "number" and not (match$17 ~= 0 or not (match$5.typ_private and match$5.typ_manifest == undefined))) then do
                          match$18 = match$5.typ_loc;
                          match$19 = match$18.loc_start;
                          if (match$19.pos_fname == "" and not (match$19.pos_lnum ~= 2 or match$19.pos_bol ~= 1 or match$19.pos_cnum ~= 1)) then do
                            match$20 = match$18.loc_end;
                            if (match$20.pos_fname == "" and not (match$20.pos_lnum ~= 2 or match$20.pos_bol ~= 1 or match$20.pos_cnum ~= 9 or match$18.loc_ghost or match$5.typ_attributes or match$4[1])) then do
                              match$21 = match$2.str_loc;
                              match$22 = match$21.loc_start;
                              if (match$22.pos_fname == "" and not (match$22.pos_lnum ~= 2 or match$22.pos_bol ~= 1 or match$22.pos_cnum ~= 1)) then do
                                match$23 = match$21.loc_end;
                                if (match$23.pos_fname == "" and not (match$23.pos_lnum ~= 2 or match$23.pos_bol ~= 1 or match$23.pos_cnum ~= 9 or match$21.loc_ghost)) then do
                                  match$24 = match$1[1];
                                  if (match$24) then do
                                    match$25 = match$24[0].str_desc;
                                    if (match$25.tag == --[[ Tstr_primitive ]]2) then do
                                      match$26 = match$25[0];
                                      match$27 = match$26.val_id;
                                      if (match$27.name == "~-") then do
                                        match$28 = match$27.flags;
                                        if (match$28 ~= 0) then do
                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                        end else do
                                          match$29 = match$26.val_name;
                                          if (match$29.txt == "~-") then do
                                            match$30 = match$29.loc;
                                            match$31 = match$30.loc_start;
                                            if (match$31.pos_fname == "" and not (match$31.pos_lnum ~= 3 or match$31.pos_bol ~= 10 or match$31.pos_cnum ~= 19)) then do
                                              match$32 = match$30.loc_end;
                                              if (match$32.pos_fname == "" and not (match$32.pos_lnum ~= 3 or match$32.pos_bol ~= 10 or match$32.pos_cnum ~= 25 or match$30.loc_ghost)) then do
                                                match$33 = match$26.val_desc;
                                                match$34 = match$33.ctyp_desc;
                                                if (typeof match$34 == "number" or not (match$34.tag == --[[ Ttyp_arrow ]]1 and match$34[0] == "")) then do
                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                end else do
                                                  match$35 = match$34[1];
                                                  match$36 = match$35.ctyp_desc;
                                                  if (typeof match$36 == "number" or match$36.tag ~= --[[ Ttyp_constr ]]3) then do
                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                  end else do
                                                    match$37 = match$36[0];
                                                    local ___conditional___=(match$37.tag | 0);
                                                    do
                                                       if ___conditional___ = 0--[[ Pident ]] then do
                                                          match$38 = match$37[0];
                                                          if (match$38.name == "int") then do
                                                            match$39 = match$38.flags;
                                                            if (match$39 ~= 0) then do
                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                            end else do
                                                              match$40 = match$36[1];
                                                              match$41 = match$40.txt;
                                                              local ___conditional___=(match$41.tag | 0);
                                                              do
                                                                 if ___conditional___ = 0--[[ Lident ]] then do
                                                                    if (match$41[0] == "int") then do
                                                                      match$42 = match$40.loc;
                                                                      match$43 = match$42.loc_start;
                                                                      if (match$43.pos_fname == "" and not (match$43.pos_lnum ~= 3 or match$43.pos_bol ~= 10 or match$43.pos_cnum ~= 28)) then do
                                                                        match$44 = match$42.loc_end;
                                                                        if (match$44.pos_fname == "" and not (match$44.pos_lnum ~= 3 or match$44.pos_bol ~= 10 or match$44.pos_cnum ~= 31 or match$42.loc_ghost or match$36[2])) then do
                                                                          match$45 = match$35.ctyp_type;
                                                                          match$46 = match$45.desc;
                                                                          if (typeof match$46 == "number" or match$46.tag ~= --[[ Tconstr ]]3) then do
                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                          end else do
                                                                            match$47 = match$46[0];
                                                                            local ___conditional___=(match$47.tag | 0);
                                                                            do
                                                                               if ___conditional___ = 0--[[ Pident ]] then do
                                                                                  match$48 = match$47[0];
                                                                                  if (match$48.name == "int") then do
                                                                                    match$49 = match$48.flags;
                                                                                    if (match$49 ~= 0 or match$46[1]) then do
                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                    end else do
                                                                                      match$50 = match$46[2].contents;
                                                                                      if (typeof match$50 == "number") then do
                                                                                        match$51 = match$35.ctyp_loc;
                                                                                        match$52 = match$51.loc_start;
                                                                                        if (match$52.pos_fname == "" and not (match$52.pos_lnum ~= 3 or match$52.pos_bol ~= 10 or match$52.pos_cnum ~= 28)) then do
                                                                                          match$53 = match$51.loc_end;
                                                                                          if (match$53.pos_fname == "" and not (match$53.pos_lnum ~= 3 or match$53.pos_bol ~= 10 or match$53.pos_cnum ~= 31 or match$51.loc_ghost or match$35.ctyp_attributes)) then do
                                                                                            match$54 = match$34[2];
                                                                                            match$55 = match$54.ctyp_desc;
                                                                                            if (typeof match$55 == "number" or match$55.tag ~= --[[ Ttyp_constr ]]3) then do
                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                            end else do
                                                                                              match$56 = match$55[0];
                                                                                              local ___conditional___=(match$56.tag | 0);
                                                                                              do
                                                                                                 if ___conditional___ = 0--[[ Pident ]] then do
                                                                                                    match$57 = match$56[0];
                                                                                                    if (match$57.name == "int") then do
                                                                                                      match$58 = match$57.flags;
                                                                                                      if (match$58 ~= 0) then do
                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                      end else do
                                                                                                        match$59 = match$55[1];
                                                                                                        match$60 = match$59.txt;
                                                                                                        local ___conditional___=(match$60.tag | 0);
                                                                                                        do
                                                                                                           if ___conditional___ = 0--[[ Lident ]] then do
                                                                                                              if (match$60[0] == "int") then do
                                                                                                                match$61 = match$59.loc;
                                                                                                                match$62 = match$61.loc_start;
                                                                                                                if (match$62.pos_fname == "" and not (match$62.pos_lnum ~= 3 or match$62.pos_bol ~= 10 or match$62.pos_cnum ~= 35)) then do
                                                                                                                  match$63 = match$61.loc_end;
                                                                                                                  if (match$63.pos_fname == "" and not (match$63.pos_lnum ~= 3 or match$63.pos_bol ~= 10 or match$63.pos_cnum ~= 38 or match$61.loc_ghost or match$55[2])) then do
                                                                                                                    match$64 = match$54.ctyp_type;
                                                                                                                    match$65 = match$64.desc;
                                                                                                                    if (typeof match$65 == "number" or match$65.tag ~= --[[ Tconstr ]]3) then do
                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                    end else do
                                                                                                                      match$66 = match$65[0];
                                                                                                                      local ___conditional___=(match$66.tag | 0);
                                                                                                                      do
                                                                                                                         if ___conditional___ = 0--[[ Pident ]] then do
                                                                                                                            match$67 = match$66[0];
                                                                                                                            if (match$67.name == "int") then do
                                                                                                                              match$68 = match$67.flags;
                                                                                                                              if (match$68 ~= 0 or match$65[1]) then do
                                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                              end else do
                                                                                                                                match$69 = match$65[2].contents;
                                                                                                                                if (typeof match$69 == "number") then do
                                                                                                                                  match$70 = match$54.ctyp_loc;
                                                                                                                                  match$71 = match$70.loc_start;
                                                                                                                                  if (match$71.pos_fname == "" and not (match$71.pos_lnum ~= 3 or match$71.pos_bol ~= 10 or match$71.pos_cnum ~= 35)) then do
                                                                                                                                    match$72 = match$70.loc_end;
                                                                                                                                    if (match$72.pos_fname == "" and not (match$72.pos_lnum ~= 3 or match$72.pos_bol ~= 10 or match$72.pos_cnum ~= 38 or match$70.loc_ghost or match$54.ctyp_attributes)) then do
                                                                                                                                      match$73 = match$33.ctyp_type;
                                                                                                                                      match$74 = match$73.desc;
                                                                                                                                      if (typeof match$74 == "number" or not (match$74.tag == --[[ Tarrow ]]1 and match$74[0] == "")) then do
                                                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                      end else do
                                                                                                                                        match$75 = match$74[1].desc;
                                                                                                                                        if (typeof match$75 == "number" or match$75.tag ~= --[[ Tconstr ]]3) then do
                                                                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                        end else do
                                                                                                                                          match$76 = match$75[0];
                                                                                                                                          local ___conditional___=(match$76.tag | 0);
                                                                                                                                          do
                                                                                                                                             if ___conditional___ = 0--[[ Pident ]] then do
                                                                                                                                                match$77 = match$76[0];
                                                                                                                                                if (match$77.name == "int") then do
                                                                                                                                                  match$78 = match$77.flags;
                                                                                                                                                  if (match$78 ~= 0 or match$75[1]) then do
                                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                  end else do
                                                                                                                                                    match$79 = match$75[2].contents;
                                                                                                                                                    if (typeof match$79 == "number") then do
                                                                                                                                                      match$80 = match$74[2].desc;
                                                                                                                                                      if (typeof match$80 == "number" or match$80.tag ~= --[[ Tconstr ]]3) then do
                                                                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                      end else do
                                                                                                                                                        match$81 = match$80[0];
                                                                                                                                                        local ___conditional___=(match$81.tag | 0);
                                                                                                                                                        do
                                                                                                                                                           if ___conditional___ = 0--[[ Pident ]] then do
                                                                                                                                                              match$82 = match$81[0];
                                                                                                                                                              if (match$82.name == "int") then do
                                                                                                                                                                match$83 = match$82.flags;
                                                                                                                                                                if (match$83 ~= 0 or match$80[1]) then do
                                                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                end else do
                                                                                                                                                                  match$84 = match$80[2].contents;
                                                                                                                                                                  if (typeof match$84 == "number") then do
                                                                                                                                                                    match$85 = match$74[3];
                                                                                                                                                                    if (typeof match$85 == "number" and match$85 == 0) then do
                                                                                                                                                                      match$86 = match$33.ctyp_loc;
                                                                                                                                                                      match$87 = match$86.loc_start;
                                                                                                                                                                      if (match$87.pos_fname == "" and not (match$87.pos_lnum ~= 3 or match$87.pos_bol ~= 10 or match$87.pos_cnum ~= 28)) then do
                                                                                                                                                                        match$88 = match$86.loc_end;
                                                                                                                                                                        if (match$88.pos_fname == "" and not (match$88.pos_lnum ~= 3 or match$88.pos_bol ~= 10 or match$88.pos_cnum ~= 38 or match$86.loc_ghost or match$33.ctyp_attributes)) then do
                                                                                                                                                                          match$89 = match$26.val_val;
                                                                                                                                                                          match$90 = match$89.val_type.desc;
                                                                                                                                                                          if (typeof match$90 == "number" or not (match$90.tag == --[[ Tarrow ]]1 and match$90[0] == "")) then do
                                                                                                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                          end else do
                                                                                                                                                                            match$91 = match$90[1].desc;
                                                                                                                                                                            if (typeof match$91 == "number" or match$91.tag ~= --[[ Tconstr ]]3) then do
                                                                                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                            end else do
                                                                                                                                                                              match$92 = match$91[0];
                                                                                                                                                                              local ___conditional___=(match$92.tag | 0);
                                                                                                                                                                              do
                                                                                                                                                                                 if ___conditional___ = 0--[[ Pident ]] then do
                                                                                                                                                                                    match$93 = match$92[0];
                                                                                                                                                                                    if (match$93.name == "int") then do
                                                                                                                                                                                      match$94 = match$93.flags;
                                                                                                                                                                                      if (match$94 ~= 0 or match$91[1]) then do
                                                                                                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                      end else do
                                                                                                                                                                                        match$95 = match$91[2].contents;
                                                                                                                                                                                        if (typeof match$95 == "number") then do
                                                                                                                                                                                          match$96 = match$90[2].desc;
                                                                                                                                                                                          if (typeof match$96 == "number" or match$96.tag ~= --[[ Tconstr ]]3) then do
                                                                                                                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                          end else do
                                                                                                                                                                                            match$97 = match$96[0];
                                                                                                                                                                                            local ___conditional___=(match$97.tag | 0);
                                                                                                                                                                                            do
                                                                                                                                                                                               if ___conditional___ = 0--[[ Pident ]] then do
                                                                                                                                                                                                  match$98 = match$97[0];
                                                                                                                                                                                                  if (match$98.name == "int") then do
                                                                                                                                                                                                    match$99 = match$98.flags;
                                                                                                                                                                                                    if (match$99 ~= 0 or match$96[1]) then do
                                                                                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                                    end else do
                                                                                                                                                                                                      match$100 = match$96[2].contents;
                                                                                                                                                                                                      if (typeof match$100 == "number") then do
                                                                                                                                                                                                        match$101 = match$90[3];
                                                                                                                                                                                                        if (typeof match$101 == "number" and match$101 == 0) then do
                                                                                                                                                                                                          match$102 = match$89.val_kind;
                                                                                                                                                                                                          if (typeof match$102 == "number" or match$102.tag) then do
                                                                                                                                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                                          end else do
                                                                                                                                                                                                            match$103 = match$102[0];
                                                                                                                                                                                                            if (match$103.prim_name == "%negint" and not (match$103.prim_arity ~= 1 or not (match$103.prim_alloc and match$103.prim_native_name == "" and not match$103.prim_native_float))) then do
                                                                                                                                                                                                              match$104 = match$89.val_loc;
                                                                                                                                                                                                              match$105 = match$104.loc_start;
                                                                                                                                                                                                              if (match$105.pos_fname == "" and not (match$105.pos_lnum ~= 3 or match$105.pos_bol ~= 10 or match$105.pos_cnum ~= 10)) then do
                                                                                                                                                                                                                match$106 = match$104.loc_end;
                                                                                                                                                                                                                if (match$106.pos_fname == "" and not (match$106.pos_lnum ~= 3 or match$106.pos_bol ~= 10 or match$106.pos_cnum ~= 50 or match$104.loc_ghost or match$89.val_attributes)) then do
                                                                                                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 220, characters 14-21", true, true);
                                                                                                                                                                                                                end else do
                                                                                                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                                                end end 
                                                                                                                                                                                                              end else do
                                                                                                                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                                              end end 
                                                                                                                                                                                                            end else do
                                                                                                                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                                            end end 
                                                                                                                                                                                                          end end 
                                                                                                                                                                                                        end else do
                                                                                                                                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                                        end end 
                                                                                                                                                                                                      end else do
                                                                                                                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                                      end end 
                                                                                                                                                                                                    end end 
                                                                                                                                                                                                  end else do
                                                                                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                                  end end end else 
                                                                                                                                                                                               if ___conditional___ = 1--[[ Pdot ]]
                                                                                                                                                                                               or ___conditional___ = 2--[[ Papply ]] then do
                                                                                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);end else 
                                                                                                                                                                                               do end end end
                                                                                                                                                                                              
                                                                                                                                                                                            end
                                                                                                                                                                                          end end 
                                                                                                                                                                                        end else do
                                                                                                                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                        end end 
                                                                                                                                                                                      end end 
                                                                                                                                                                                    end else do
                                                                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                    end end end else 
                                                                                                                                                                                 if ___conditional___ = 1--[[ Pdot ]]
                                                                                                                                                                                 or ___conditional___ = 2--[[ Papply ]] then do
                                                                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);end else 
                                                                                                                                                                                 do end end end
                                                                                                                                                                                
                                                                                                                                                                              end
                                                                                                                                                                            end end 
                                                                                                                                                                          end end 
                                                                                                                                                                        end else do
                                                                                                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                        end end 
                                                                                                                                                                      end else do
                                                                                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                      end end 
                                                                                                                                                                    end else do
                                                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                    end end 
                                                                                                                                                                  end else do
                                                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                  end end 
                                                                                                                                                                end end 
                                                                                                                                                              end else do
                                                                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                              end end end else 
                                                                                                                                                           if ___conditional___ = 1--[[ Pdot ]]
                                                                                                                                                           or ___conditional___ = 2--[[ Papply ]] then do
                                                                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);end else 
                                                                                                                                                           do end end end
                                                                                                                                                          
                                                                                                                                                        end
                                                                                                                                                      end end 
                                                                                                                                                    end else do
                                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                    end end 
                                                                                                                                                  end end 
                                                                                                                                                end else do
                                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                end end end else 
                                                                                                                                             if ___conditional___ = 1--[[ Pdot ]]
                                                                                                                                             or ___conditional___ = 2--[[ Papply ]] then do
                                                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);end else 
                                                                                                                                             do end end end
                                                                                                                                            
                                                                                                                                          end
                                                                                                                                        end end 
                                                                                                                                      end end 
                                                                                                                                    end else do
                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                    end end 
                                                                                                                                  end else do
                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                  end end 
                                                                                                                                end else do
                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                end end 
                                                                                                                              end end 
                                                                                                                            end else do
                                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                            end end end else 
                                                                                                                         if ___conditional___ = 1--[[ Pdot ]]
                                                                                                                         or ___conditional___ = 2--[[ Papply ]] then do
                                                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);end else 
                                                                                                                         do end end end
                                                                                                                        
                                                                                                                      end
                                                                                                                    end end 
                                                                                                                  end else do
                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                  end end 
                                                                                                                end else do
                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                end end 
                                                                                                              end else do
                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                              end end end else 
                                                                                                           if ___conditional___ = 1--[[ Ldot ]]
                                                                                                           or ___conditional___ = 2--[[ Lapply ]] then do
                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);end else 
                                                                                                           do end end end
                                                                                                          
                                                                                                        end
                                                                                                      end end 
                                                                                                    end else do
                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                    end end end else 
                                                                                                 if ___conditional___ = 1--[[ Pdot ]]
                                                                                                 or ___conditional___ = 2--[[ Papply ]] then do
                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);end else 
                                                                                                 do end end end
                                                                                                
                                                                                              end
                                                                                            end end 
                                                                                          end else do
                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                          end end 
                                                                                        end else do
                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                        end end 
                                                                                      end else do
                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                      end end 
                                                                                    end end 
                                                                                  end else do
                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                  end end end else 
                                                                               if ___conditional___ = 1--[[ Pdot ]]
                                                                               or ___conditional___ = 2--[[ Papply ]] then do
                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);end else 
                                                                               do end end end
                                                                              
                                                                            end
                                                                          end end 
                                                                        end else do
                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                        end end 
                                                                      end else do
                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                      end end 
                                                                    end else do
                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                    end end end else 
                                                                 if ___conditional___ = 1--[[ Ldot ]]
                                                                 or ___conditional___ = 2--[[ Lapply ]] then do
                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);end else 
                                                                 do end end end
                                                                
                                                              end
                                                            end end 
                                                          end else do
                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                          end end end else 
                                                       if ___conditional___ = 1--[[ Pdot ]]
                                                       or ___conditional___ = 2--[[ Papply ]] then do
                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);end else 
                                                       do end end end
                                                      
                                                    end
                                                  end end 
                                                end end 
                                              end else do
                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                              end end 
                                            end else do
                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                            end end 
                                          end else do
                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                          end end 
                                        end end 
                                      end else do
                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                      end end 
                                    end else do
                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                    end end 
                                  end else do
                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                  end end 
                                end else do
                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                end end 
                              end else do
                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                              end end 
                            end else do
                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                            end end 
                          end else do
                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                          end end 
                        end else do
                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                        end end 
                      end else do
                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                      end end 
                    end else do
                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                    end end 
                  end else do
                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                  end end 
                end end 
              end else do
                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
              end end 
            end else do
              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
            end end 
          end else do
            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
          end end 
        end end 
      end else do
        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
      end end 
    end else do
      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
    end end 
  end else do
    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
  end end 
end else do
  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
end end 

from_pair_suites("Ocaml_typedtree_test", suites.contents);

--[[  Not a pure module ]]
